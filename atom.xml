<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[稀有猿诉]]></title>
  <link href="http://toughcoder.net/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2022-09-15T20:09:20+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Understanding Dijkstra Algorithm]]></title>
    <link href="http://toughcoder.net/blog/2022/09/12/understanding-dijkstra-algorithm/"/>
    <updated>2022-09-12T10:49:54+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/12/understanding-dijkstra-algorithm</id>
    <content type="html"><![CDATA[<p>最短路径问题，是图论中经常遇到的问题，对于非加权图，用广度优先搜索（BFS）就可以找到两个顶点之间的最短路径（最少边数），但对于加权图，就需要用到著名的犾克斯特拉算法（<a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra Algorithm</a>）。</p>

<p><a href="http://toughcoder.net/blog/2022/09/12/understanding-dijkstra-algorithm/"><img src="https://www.researchgate.net/profile/Atta_Ur_Rehman14/publication/331484960/figure/fig1/AS:732550733512704@1551665113143/Illustration-of-Dijkstras-algorithm.ppm" title="auto auto" ></a></p>

<!-- more -->


<h2>思路</h2>

<p>犾克斯特拉算法的核心思想是：</p>

<ol>
<li>以起步的顶点作为<strong>当前顶点</strong></li>
<li>检查当前顶点的所有邻接顶点，计算当前顶点到所有其邻接顶点的权重，并记录下来</li>
<li>从<strong>未访问过</strong>的邻接顶点中，选择一个总权重最小的顶点，作为下一个<strong>当前顶点</strong></li>
<li>重复第3步，直到图中所有的顶点都被访问过</li>
</ol>


<p>这样就能得到起步顶点到其他所有顶点的最短路径（最小权重）。</p>

<p><img src="https://img-blog.csdnimg.cn/201902261948522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc5NTkyMQ==,size_16,color_FFFFFF,t_70" alt="" /></p>

<h2>实例</h2>

<p>前面的思路听起来还是不够清爽，我们来看一个具体的实例，比如计算不同的城市之间的飞行费用问题，就可以用Dijkstra算法来求解，一共有五个城市，以及它们之间的航班费用：</p>

<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>


<script>mermaid.initialize({startOnLoad:true});</script>


<div class="mermaid">
flowchart LR;
    A([Atlanta])
    B([Boston])
    C([Chicago])
    D([Denver])
    E([El Paso])
        A&#45;&#45; 100 &#45;&#45;>B;
    A&#45;&#45; 160 &#45;&#45;>D;    B&#45;&#45; 120 &#45;&#45;>C;    B&#45;&#45; 180 &#45;&#45;>D;    D&#45;&#45; 40 &#45;&#45;>C;
    D&#45;&#45; 140 &#45;&#45;>E;
    </div>


<p>以Atlanta为起点，来计算到其他几个城市的最小飞行费用，为方便用一个表格来展现Dijkstra算法的每一步：</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 步骤 </th>
<th style="text-align:left;"> 当前顶点 </th>
<th style="text-align:center;"> Atlanta </th>
<th style="text-align:center;"> Boston </th>
<th style="text-align:center;"> Chicago </th>
<th style="text-align:center;"> Denver </th>
<th style="text-align:center;"> El Paso </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 初始化 </td>
<td style="text-align:left;"> n/a </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:left;"> inf为正无穷，代表还未有计算的距离  </td>
</tr>
<tr>
<td style="text-align:left;"> 第1步<br/>起始顶点作为当前顶点 </td>
<td style="text-align:left;"> Atlanta </td>
<td style="text-align:center;"> 0 </td>
<td style="text-align:center;"> 100 </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:center;"> 160 </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:left;"> Atlanta能到达Boston和Denver，是邻接 的顶点 直接填权重 </td>
</tr>
<tr>
<td style="text-align:left;"> 第2步<br/>未访问顶点Boston和Denver中选择权重小的Boston </td>
<td style="text-align:left;"> Boston </td>
<td style="text-align:center;"> 0 </td>
<td style="text-align:center;"> 100 </td>
<td style="text-align:center;"> 220 </td>
<td style="text-align:center;"> 160 </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:left;"> 到Boston的费用是100，以此为基础，<br/>Boston到Chicago是120，所以起始点到Chicago的费用是220。<br/>Boston到Denver是180再加上基础100就是280，它大于Atlanta直飞Denver，所以这个放弃 </td>
</tr>
<tr>
<td style="text-align:left;"> 第3步<br/>未访问的中Denver最小，所以用Denver </td>
<td style="text-align:left;"> Denver </td>
<td style="text-align:center;"> 0 </td>
<td style="text-align:center;"> 100 </td>
<td style="text-align:center;"> 200 </td>
<td style="text-align:center;"> 160 </td>
<td style="text-align:center;"> 300 </td>
<td style="text-align:left;"> 到Denver的费用是160，以此为基础，<br/>Denver到Chicago是40，经Denver到Chicago更划算，所以到Chicago更新为200；<br/>Denver还可以到达El Paso费用是300 </td>
</tr>
<tr>
<td style="text-align:left;"> 第4步<br/>未访问的中Chicago最小，所以用Chicago </td>
<td style="text-align:left;"> Chicago </td>
<td style="text-align:center;"> 0 </td>
<td style="text-align:center;"> 100 </td>
<td style="text-align:center;"> 200 </td>
<td style="text-align:center;"> 160 </td>
<td style="text-align:center;"> 280 </td>
<td style="text-align:left;"> 到Chicago的费用是200，以此为基础，<br/>Chicago到El Paso是80，经Chicago到El Paso更划算，所以到El Paso更新为280 </td>
</tr>
<tr>
<td style="text-align:left;"> 第5步<br/>只有El Paso未访问了，所以用El Paso </td>
<td style="text-align:left;"> El Paso </td>
<td style="text-align:center;"> 0 </td>
<td style="text-align:center;"> 100 </td>
<td style="text-align:center;"> 200 </td>
<td style="text-align:center;"> 160 </td>
<td style="text-align:center;"> 280 </td>
<td style="text-align:left;"> 到El Paso的费用是280，以此为基础，<br/>El Paso到Boston是100，不划算，所以不用更新。<br/>所有顶点都访问过了，这就是Atlanta出发到所有城市的最小飞行费用 </td>
</tr>
</tbody>
</table>


<h2>实现</h2>

<p>Dijkstra算法比较复杂，它的时间空间复杂度都比较高。算法的输入是一个加树图，和一个起始顶点，输出则是一个列表，表示起始顶点到其他顶点的最短路径。</p>

<h3>实现思路</h3>

<ol>
<li>创建一个结果列表，长度是顶点数量N，尽管其实不管起始顶点，但为了方便还是加上，用以存储起始顶点到所有顶点的最小距离，列表初始化为正无穷</li>
<li>创建一个标记列表，长度是N，用以标记顶点是否访问过，在选择下一个当前节点时，以及判断算法是否结束时，都需要用到此列表</li>
<li>选择实始顶点为当前顶点</li>
<li>把当前节点加入到标记列表中</li>
<li>更新最小距离列表：以当前顶点为基础，计算到它的每个邻接顶点的距离（也即基础值加上与其邻接的边的权重），如果距离小于结果列表中的距离，就更新结果列表</li>
<li>选择下一个当前顶点：遍历结果列表，找最小值，并且还未访问过（不在标记列表里），作为下一个当前顶点</li>
<li>重复第4到第6步，直到所有顶点都已标记，这时在第6步肯定 找不到下一个当前顶点</li>
</ol>


<h3>伪代码</h3>

<p>有了前面的实现思路，就不难写出伪代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>creat a list with length of N distanceList, init with MAX
</span><span class='line'>create a set visitedSet
</span><span class='line'>currentNode = start
</span><span class='line'>distanceList[start] = 0
</span><span class='line'>while currentNode is not null:
</span><span class='line'>    add currentNode to visitedSet
</span><span class='line'>    
</span><span class='line'>    base = distanceList[currentNode]
</span><span class='line'>    for each node adjacent with currentNode:
</span><span class='line'>         if node.weight + base &lt; distanceList[node]:
</span><span class='line'>              distanceList[node] = node.weight + base
</span><span class='line'>              
</span><span class='line'>    min = null
</span><span class='line'>    for each node in distanceList:
</span><span class='line'>        if node not in visitedSet and min &gt; distanceList[node]:
</span><span class='line'>              min = node;
</span><span class='line'>    currentNode = min</span></code></pre></td></tr></table></div></figure>


<h3>示例代码</h3>

<p>到了代码层面的实现，需要灵活选择数据结构，如果顶点可以方便的用下标来代表的话，那么就可以用数组代替列表，否则可能就要使用哈希表。这里为了方便，用下标来代表顶点：0代表Atlanta，1代表Boston，2代表Chicago，3代表Denver，4代表El Paso，这样就都可以用数组来当列表用。</p>

<p>图用矩阵来表示，每一行代表到另一个城市的费用，其实默认值可以都用0，在计算费用时就不用特殊处理了，但为了体现邻接顶点，所以没有连通的顶点用-1，自己用0，相邻的顶点才有权重。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DijkstraAlgorithm</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">dijkstra</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">graph</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">final</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
</span><span class='line'>        <span class="kt">int</span><span class="o">[]</span> <span class="n">distance</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
</span><span class='line'>        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
</span><span class='line'>        <span class="n">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">distance</span><span class="o">,</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
</span><span class='line'>        <span class="n">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">visited</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
</span><span class='line'>        <span class="n">distance</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">current</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(</span><span class="n">current</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">// Mark as current node as visited</span>
</span><span class='line'>            <span class="n">visited</span><span class="o">[</span><span class="n">current</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// Update the shortest distance for the nodes adjacent with current node</span>
</span><span class='line'>            <span class="kd">final</span> <span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="n">distance</span><span class="o">[</span><span class="n">current</span><span class="o">];</span>
</span><span class='line'>            <span class="kt">int</span><span class="o">[]</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="n">graph</span><span class="o">[</span><span class="n">current</span><span class="o">];</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">neighbors</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                    <span class="c1">// Skip not adjacent node</span>
</span><span class='line'>                    <span class="k">continue</span><span class="o">;</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">neighbors</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">distance</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">neighbors</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// Pick next current node</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">min</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">distance</span><span class="o">[</span><span class="n">min</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">distance</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">min</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">current</span> <span class="o">=</span> <span class="n">min</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">distance</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">String</span><span class="o">[]</span> <span class="n">cities</span> <span class="o">=</span> <span class="o">{</span><span class="s">&quot;Atlanta&quot;</span><span class="o">,</span> <span class="s">&quot;Boston&quot;</span><span class="o">,</span> <span class="s">&quot;Chicago&quot;</span><span class="o">,</span> <span class="s">&quot;Denver&quot;</span><span class="o">,</span> <span class="s">&quot;El Paso&quot;</span><span class="o">};</span>
</span><span class='line'>        <span class="kt">int</span><span class="o">[][]</span> <span class="n">graph</span> <span class="o">=</span> <span class="o">{</span>
</span><span class='line'>                <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">100</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">160</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">},</span>
</span><span class='line'>                <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">120</span><span class="o">,</span> <span class="mi">180</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">},</span>
</span><span class='line'>                <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">80</span><span class="o">},</span>
</span><span class='line'>                <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">40</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">140</span><span class="o">},</span>
</span><span class='line'>                <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">100</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span>
</span><span class='line'>        <span class="o">};</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>        <span class="kt">int</span><span class="o">[]</span> <span class="n">shortestPath</span> <span class="o">=</span> <span class="n">dijkstra</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">start</span><span class="o">);</span>
</span><span class='line'>        <span class="n">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">graph</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>
</span><span class='line'>                <span class="o">.</span><span class="na">mapToObj</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="s">&quot;Shortest distance from &quot;</span> <span class="o">+</span> <span class="n">cities</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">+</span> <span class="s">&quot; to &quot;</span> <span class="o">+</span> <span class="n">cities</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="n">shortestPath</span><span class="o">[</span><span class="n">i</span><span class="o">])</span>
</span><span class='line'>                <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出结果：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Shortest</span> <span class="n">distance</span> <span class="n">from</span> <span class="n">Atlanta</span> <span class="n">to</span> <span class="nl">Boston:</span> <span class="mi">100</span>
</span><span class='line'><span class="n">Shortest</span> <span class="n">distance</span> <span class="n">from</span> <span class="n">Atlanta</span> <span class="n">to</span> <span class="nl">Chicago:</span> <span class="mi">200</span>
</span><span class='line'><span class="n">Shortest</span> <span class="n">distance</span> <span class="n">from</span> <span class="n">Atlanta</span> <span class="n">to</span> <span class="nl">Denver:</span> <span class="mi">160</span>
</span><span class='line'><span class="n">Shortest</span> <span class="n">distance</span> <span class="n">from</span> <span class="n">Atlanta</span> <span class="n">to</span> <span class="n">El</span> <span class="nl">Paso:</span> <span class="mi">280</span>
</span></code></pre></td></tr></table></div></figure>


<h2>应用</h2>

<p>Dijkstra算法只能用于有向无环加权图（DAG），且没有负权重的情况下，才可以正常工作。并且，它的复杂度较高，如果顶点数量为n，那么它的时间复杂度会达到O(n<sup>2</sup>)。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/">Dijkstra’s Shortest Path Algorithm</a></li>
<li><a href="https://www.freecodecamp.org/news/dijkstras-shortest-path-algorithm-visual-introduction/">Dijkstra&rsquo;s Shortest Path Algorithm - A Detailed and Visual Introduction</a></li>
<li><a href="https://www.programiz.com/dsa/dijkstra-algorithm">Dijkstra&rsquo;s Algorithm</a></li>
<li><a href="https://brilliant.org/wiki/dijkstras-short-path-finder/">Dijkstra&rsquo;s Shortest Path Algorithm</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/338414118">Dijkstra算法详解 通俗易懂</a></li>
<li><a href="https://blog.csdn.net/lbperfect123/article/details/84281300">Dijkstra算法图文详解</a></li>
<li><a href="https://blog.csdn.net/qq_35644234/article/details/60870719">最短路径问题&mdash;Dijkstra算法详解</a></li>
<li><a href="https://www.cnblogs.com/dijkstra2003/p/7222182.html">Dijkstra 最短路径算法 秒懂详解</a></li>
<li><a href="https://www.cnblogs.com/goldsunshine/p/12978305.html">一篇文章讲透Dijkstra最短路径算法</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图论基础知识]]></title>
    <link href="http://toughcoder.net/blog/2022/09/08/graph-data-structure-made-easy/"/>
    <updated>2022-09-08T18:05:45+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/08/graph-data-structure-made-easy</id>
    <content type="html"><![CDATA[<p>图（<a href="https://en.wikipedia.org/wiki/Graph_(abstract_data_type">Graph</a>)）是一个由节点和边组成的略复杂的二维数据结构，通常用于表示物体之间的关系。</p>

<p><a href="http://toughcoder.net/blog/2022/09/08/graph-data-structure-made-easy/"><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.-HB8jzKKYmCKNH9ui2LDpwHaDH?pid=ImgDet&rs=1" title="auto auto" ></a></p>

<!-- more -->


<h2>图的基础知识</h2>

<p>图由节点（Vertex）和边（Edge）组成，节点之间会有边来连接以表示某种关系。逻辑上的形状会是这样子的：
<img src="https://www.thecrazyprogrammer.com/wp-content/uploads/2017/08/Graph-Data-Structure.png" alt="" /></p>

<p>图的节点通常用于表示物体或者数值，变化较少，图的复杂性主要就体现在边上面，比如有些是有向的，有些是无向的，还有指向自己的。</p>

<h3>路径 Path</h3>

<p>在一个图中，路径是一系列节点和边，其中的节点都由边连接</p>

<h3>路径长度 Path length</h3>

<p>两个节点之间的边的数量称为路径长度</p>

<h3>简单路径 Simple Path</h3>

<p>一个路径所经过的节点没有重复的，就称为简单路径</p>

<h3>根 Root</h3>

<p>如果一个节点，由它出发的路径可以连通到所有节点，那么这个节点称作图根</p>

<h3>环 Cycle</h3>

<p>存在路径起始节点相同，就形成了环</p>

<h3>度 Degrees</h3>

<p>针对 节点而言，经过一个节点的所有边的数量之和，称之为节点的度</p>

<h3>入度 In degress</h3>

<p>对于有向图而言，以节点为终点的边的数量，称这节点的入度。</p>

<h3>出度 Out degrees</h3>

<p>对于有向图而言，从一个节点出发的边的数量，称为节点的出度。</p>

<h2>图的分类</h2>

<h3>空图 Null graph</h3>

<p>也就是只有顶点，没有边的图，样子大概是这样：</br>
<img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.QifCHVxIx4myhHIXgxapLQAAAA?pid=ImgDet&amp;rs=1" alt="" /></p>

<h3>有限图 Finite graph</h3>

<p>顶点和边的数量是有限的，接触到的绝大多数图都是有限图。</p>

<h3>无限图 Infinite graph</h3>

<p>顶点和边的数量是无限的</br>
<img src="https://www.researchgate.net/profile/David-Evans-81/publication/225108378/figure/fig1/AS:393838129631243@1470909735860/The-infinite-graph-A-6.png" alt="" /></p>

<h3>完全图 Complete graph</h3>

<p>所有节点都是有路径连通的</br>
<img src="https://miro.medium.com/max/7954/1*q0tQ1svUWfN05kWsZ_Uo2g.jpeg" alt="" /></p>

<h3>权重图 Weighted graph</h3>

<p>每一条边都有一个数值表示的权重以代表两个节点之间的某种成本</p>

<p><img src="https://i1.wp.com/algorithms.tutorialhorizon.com/files/2018/03/Weighted-Graph.png?ssl=1" alt="" /></p>

<h3>无向图 Undirected graph</h3>

<p>连接节点之间的边是没有方向的，称之为无向图，它也是普通 的图</p>

<h3>有向图 Directed graph</h3>

<p>每条边都是有方向的，对于两个节点来说v[i]和v[j]来说，e[i,j]=(v[i],v[j])，它与e[j,i]=(v[j],v[i])是不一样的，有向图通常用于表示物体之间的依赖关系</p>

<p><img src="https://www.filepicker.io/api/file/1KMTR25HS2OzpZcpy0mJ" alt="" /></p>

<h3>连通图 Connected graph</h3>

<p>任意两节点都连通，称之为连通图也叫强连通图。</p>

<h3>非连通图 Disconnected graph</h3>

<p>有两个节点没有边连接，就称为非连通图。</p>

<h3>自环</h3>

<p>也就是某个节点有一条边是自己连接着自己，这个有向和无向图都可以有</p>

<h3>有环图 Cyclic graph</h3>

<p>起点和终点相同的路径，就形成了环。如果图中存在一个环，就是有环图。</p>

<p><img src="https://www.droidtechknow.com/programming/data-structure/an-introduction-to-graph-data-structure/images/graph-example.jpg" alt="" /></p>

<h3>无环图 Acyclic graph</h3>

<p>图中没有环就是无环图</p>

<h3>有向无环图 Directed Acyclic Graph</h3>

<p>有向图中不存在环就是DAG，这是比较重要的一种图，拓扑排序 可以验证DAG。</p>

<p><img src="https://wiki.swarma.org/images/c/cd/A_DAG_G.png" alt="" /></p>

<ul>
<li><a href="https://www.geeksforgeeks.org/introduction-to-graphs/">Introduction to Graphs</a></li>
</ul>


<h2>图的表示方法</h2>

<p>图的表示方法一般有邻接矩阵法和邻接表法。</p>

<h3>邻接矩阵 Adjacency Matrix</h3>

<p>对于有n个顶点的图来说要创建一个nxn的矩阵来表示此图，每一个格子[i,j]表示顶点v[i]到v[j]是连通的，有一条边存在，如果是有向图，则[j,i]表示v[j]到v[i]的边。另外，如果有权重，格子的值也可以表示边的权重。
<img src="https://educativesite.com/wp-content/uploads/2019/09/incidence-matrix.png" alt="" />
因为用矩阵一般比较浪费空间，比如顶点较多，但边较少时，就有点浪费空间。一般，矩阵通常就是一类单独的矩阵类搜索问题，直接应用图的搜索方法。</p>

<h3>邻接表 Adjacency List</h3>

<p>也就是列表的列表，先用一个链表代表所有的顶点，然后这个链表的元素是这个与这个顶点相连的所有顶点组成的列表。
<img src="https://cdn.programiz.com/sites/tutorial2program/files/adjacency-list.png" alt="" />
通常是用数组加链表的形式，主表用数组或者可变长数组，因为这些都是顶点，有可能会随时从某个顶点开始遍历，所以要用随机访问效率高一些的数组。与顶点相连的顶点列表一般用链表，因为它方便删除和插入，且遍历一般都是从顶点开始遍历。</p>

<p><img src="https://ts1.cn.mm.bing.net/th/id/R-C.4fe11a408a41fa5509274d85a4c09c1f?rik=YfKo9VJ94v7kxw&amp;riu=http%3a%2f%2fprogressivecoder.com%2fwp-content%2fuploads%2f2020%2f12%2fadjacency-list.png&amp;ehk=WAS3o3piPNsR6QCXSeDCVsjO%2fcuyO6KisgW5kv4uwYQ%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" /></p>

<p>但，也要看实际情况，有时候用哈希表也可以，键是每个顶点，值为顶点所连接的顶点列表，顶点列表可以用列表，也可以用Set等等。</p>

<p><img src="https://condor.depaul.edu/glancast/393class/docs/images/topsort7C++.gif" alt="" /></p>

<p>邻接表的实现方式比较自由，只要能从一个顶点出发，方便的找到与其相连的顶点，就可以。具体的，可以依据实际数据情况来灵活选择，比如说顶点如果是某一个范围内的整数，那么可能用数组就更方便一些，如果是字串或者其他的，可能用哈希表就更方便一些。</p>

<ul>
<li><a href="https://www.geeksforgeeks.org/graph-and-its-representations/">Graph and its representations</a></li>
</ul>


<h2>图与树的关系</h2>

<p>图是一个比较大的概念，只要是有节点与节点相连接就可以看作是图，数组（可视为下标与元素的连接），哈希表（键与值的连接），树，链表都可以看作是图。这些数据结构是一种特殊的图，强加了很多其他规则，就比如树，有一个根，有多个子节点。</p>

<p><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.sELEF-9VK_G1wwU413LUFgAAAA?pid=ImgDet&amp;rs=1" alt="" /></p>

<p>适用于图的很多算法也适用树，比如DFS和BFS对树也是适用的。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/">Graph Data Structure And Algorithms</a></li>
<li><a href="https://www.programiz.com/dsa/graph">Graph Data Stucture</a></li>
<li><a href="https://medium.com/data-structures-and-algorithms/graph-dd2b72c32f1f">Graph</a></li>
<li><a href="https://www.simplilearn.com/tutorials/data-structure-tutorial/graphs-in-data-structure">Your One-Stop Solution For Graphs In Data Structures</a></li>
<li><a href="https://www.runoob.com/data-structures/graph-theory.html">图论基础和表示</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/124259930">【朝夕的ACM笔记】图论-图论基础概念</a></li>
<li><a href="https://blog.csdn.net/Karen_Yu_/article/details/78776354">图论基础知识总结（一）</a></li>
<li><a href="https://cuigeg.github.io/2017/06/27/Graph-theory/">这一点点的图论基础</a></li>
<li><a href="https://labuladong.github.io/algo/2/22/50/">图论基础及遍历算法</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1922486">图论算法基础（修订版）</a></li>
<li><a href="https://www.cnblogs.com/BlairGrowing/p/13637688.html">图论&mdash;-基础知识 </a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解并运用并查集]]></title>
    <link href="http://toughcoder.net/blog/2022/09/08/disjoint-set-data-structure/"/>
    <updated>2022-09-08T17:27:05+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/08/disjoint-set-data-structure</id>
    <content type="html"><![CDATA[<p><a href="">并查集</a>（<a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">Disjoint-set Data Structure</a>）是一种树形的结构，用于处理<strong>不相交</strong>的集合的高效的查询(find)和合并(union)问题。主要有两种操作一是查询(find)，也就是查询某个元素是否属于某个集合；二是合并(union)，也即把某个加入到某个集合中，这里的集合都是无交集的。通过路径压缩，并查集的查询和合并都可以达到常数级别O(1)。</p>

<p><a href="http://toughcoder.net/blog/2022/09/08/disjoint-set-data-structure/"><img src="https://images.xiaozhuanlan.com/photo/2019/891afdf6961c0eab3d3aa28a3f355e12.png" title="auto auto" ></a></p>

<!-- more -->


<h2>朋友关系问题</h2>

<p>先来看一个问题，比如有一个朋友关系的问题，两个人可以成为朋友关系，两两是朋友的一群人就形成了一个朋友圈，那么如何快速判断某两个是不是朋友关系呢？又如何让两个人成为朋友呢？</p>

<p>一个可行的方法是用图的搜索，两个人的朋友关系可以视为图的一条边，一个朋友圈就是相互连通的一个图，查看两人是否是朋友关系，可以从一个人出发，不断遍历相连的边，看能否到达另一个人，但这样效率有点低，每次查询 都会是线性时间，因为都要遍历一遍图才知道。</p>

<p>我们换个思路，可以为一个朋友图指定一个『圈长』，把关系改成其他人都直接跟圈长相连，或者每个人都能找到自己的圈长，这时判断两个人是不是在同一个朋友圈内，就看它们的圈长是不是同一个人就可以了，这就是并查集。</p>

<p><img src="https://red-green-rewrite.github.io/images/maze/disjoint-set-merge-3+7.png" alt="" /></p>

<h2>并查集的概念与基本实现</h2>

<p>并查集用以表示不相交的集合，逻辑上它是一种扁平的树形结构，每一个树代表一个集合，树的根就是这个集合的『圈长』，或者叫做一个集合的代表（representative）。并查集支持两种操作，查询（find） 和合并（union），查询是看两个元素是否属于同一个集合，合并则是把两个集合合并成为一个集合。</p>

<p>并查集的精髓就在于它的『圈长』机制，我们不管具体某个元素它的路径与关系，每个元素都只关心自己的圈长，它能找到自己的圈长就可以，因此查询是否属于同一个集合就看元素的圈长是否是同一个；合并，也非常简单，两个集合合并，就是把其中一个圈长的圈长设置为另一个圈长就可以了。</p>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.ywrpxwo6g4mKItHNwrzyVgHaFU?pid=ImgDet&amp;rs=1" alt="" /></p>

<h3>具体实现</h3>

<p>需要注意，虽然并查集逻辑上是一种树形结构，但一般情况都用线性的数组来实现并查集。比如用一个长度为n的数组来表示并查集，实际上我们只关心圈长，所以下标为i的元素就是i的圈长，一般命名为parent，也就是说parent[i]就是i的圈长，或者顺着它就能找到圈长（树的根），而parent[i]=i则是一个集合的『圈长』（representative）。</p>

<p>初始时，每个元素都是独立的，每个元素都独立成团，自己就是圈长，也即parent[i]=i。当有元素合并了，就把它们指向同一个圈长，比如parent[8]=6，parent[1]=6，parent[2]=4，parent[3]=4，parent[9]=4，parent[7]=4，这样就知道一共有三个集合，其中5独自成一个集合，1和8还有6是同一个集合6是他们的圈长，2，3，9，7，4是同一个集合4是圈长，画出图来就是这样的：</p>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.aqoDLciI4xvo7AnTDg3KRQHaFI?pid=ImgDet&amp;rs=1" alt="" /></p>

<h3>查询与合并</h3>

<p>查询某两个元素是否属于同一个集合，就是归结来查找每个人所属集合的圈长（representative），然后判断是否是同一个元素，因此问题归结为圈长的查找。比如2的父节点是4，而parent[4]=4，它就是圈长，所以2的圈长是4；再看7，它的父节点是9，而9的父节点是4，4是圈长，因此2和7属于同一个集合。</p>

<p>合并，也是类似的，而且更加简单，先查询要合并是否属于同一个集合，如果属于那自然就不用合并了。如果不是，那就找到各自的圈长，然后把某一个圈长的圈长设为另一个即可。比如想把5和8合并，5独自成圈，而8的圈长是6，那么把5的圈长设置为6，parent[5]=6，就合并完成了。</p>

<p><strong>注意</strong>：并查集的具体实现要看实际数据类型，比如集合元素个休是一个0~n范围内的整数，那么自然用数据非常方便，或者能够方便的转化为数组的下标时，用数组也行。否则也可以用哈希表。因为元素只要能递归的向上找到它的圈长（树的根）就行。</p>

<h2>路径压缩</h2>

<p>从前面的例子来看，查询过程其实是O(n)的，因为某个元素的父节点不一定就是圈长，为了找到圈长要递归的找下去，直到找到圈长为止，即只有找到了parent[i]=i，才算找到了圈长。这样每次查询都是线性时间，就会导致并查集整体效率变成O(n<sup>2</sup>)的。</p>

<p>因为并查集是处理集合问题，也就是说我们只关系某两个元素是否属于同一个集合，至于它跟其他元素之间的关系并不重要，我们只希望快速的找到它的圈长就可以了，那么我们在查找圈长的过程中，就可以把元素都直接指向其圈长，比如前面的7，它的父节点是9，不是圈长，我们查找后发现圈长是4，那么在查询过程中就可以把parent[7]=4，让7的父节点变成圈长。这样做的好处是，下次再查询时就能直接找到圈长了，变成了O(1)，不用再线性去查找了，这便是路径压缩。路径压缩的复杂度是常数级别的，可以用摊还分析来证明。</p>

<p>最终树变成了扁平的，集合中的每一个元素都直接指向圈长：</p>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.v4afq3bNSl3SnFPKfVM3jwHaCO?pid=ImgDet&amp;rs=1" alt="" /></p>

<h2>按秩合并</h2>

<p>合并的时候是把一个集合的圈长的圈长设置为另一个集合的圈长，比如前面5和8要合并，5的圈长是5，8的圈长是6，这时其实有两种可行方法，可以把5的圈长设为6，即parent[5]=6，但也可以把6的圈长设置为5啊，即parent[6]=5，逻辑上都可行的，但应该用哪种呢？</p>

<p>逻辑上并无对错，要从效率上来比较哪个更好。前面提到了，常规查询是线性时间的，集合是树形的，树的高度越高，那么找到圈长的时间就越长，路径压缩后树才会变得扁平，因此，可以认为树的高度是越小越好的。由此来看，把5的圈长设置为6效率更高，6这个集合高度是2，如果把6的圈长设置为5，那么树的高度会变成3，需要一次路径压缩才可以；相反，如果把5的圈长设置为6，即parent[5]=6，那么树的高度还是2，不需要额外的路径压缩了。所以应该把高度小的集合并到高度大的集合中去。</p>

<p>那么，可以用另外一个数组rank来表示集合的秩，即rank[i]是i所属于集合的秩，也就是树的高度，当合并的时候就可以参考 rank来进行更高效的合并，总是把秩低的往秩高的上面的合并。只看圈长的秩就可以了，因为合并的时候是两个圈长在打架。</p>

<h2>实例</h2>

<p>还是来一个具体的实例，来演示并查集的思路和具体实现。把朋友圈关系进行抽象，用数字0~n来代表N个人，N=n+1，实现一个并查集，并进行查询和合并操作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DisjointSet</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">rank</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">DisjointSet</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="n">size</span><span class="o">;</span>
</span><span class='line'>        <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
</span><span class='line'>        <span class="n">rank</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
</span><span class='line'>        <span class="n">init</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">xRoot</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">yRoot</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">y</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">xRoot</span> <span class="o">==</span> <span class="n">yRoot</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">// In the same set already, do nothing</span>
</span><span class='line'>            <span class="k">return</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Union by rank, ruled by higher rank.</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">rank</span><span class="o">[</span><span class="n">xRoot</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">rank</span><span class="o">[</span><span class="n">yRoot</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">parent</span><span class="o">[</span><span class="n">xRoot</span><span class="o">]</span> <span class="o">=</span> <span class="n">yRoot</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">rank</span><span class="o">[</span><span class="n">xRoot</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">rank</span><span class="o">[</span><span class="n">yRoot</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">parent</span><span class="o">[</span><span class="n">yRoot</span><span class="o">]</span> <span class="o">=</span> <span class="n">xRoot</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">parent</span><span class="o">[</span><span class="n">xRoot</span><span class="o">]</span> <span class="o">=</span> <span class="n">yRoot</span><span class="o">;</span>
</span><span class='line'>            <span class="n">rank</span><span class="o">[</span><span class="n">yRoot</span><span class="o">]++;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">==</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Path compression</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">root</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]);</span>
</span><span class='line'>        <span class="c1">// Make each node point to its root</span>
</span><span class='line'>        <span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">DisjointSet</span> <span class="n">dset</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">DisjointSet</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
</span><span class='line'>        <span class="n">dset</span><span class="o">.</span><span class="na">union</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
</span><span class='line'>        <span class="n">dset</span><span class="o">.</span><span class="na">union</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
</span><span class='line'>        <span class="n">dset</span><span class="o">.</span><span class="na">union</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;True: &quot;</span> <span class="o">+</span> <span class="o">(</span><span class="n">dset</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span> <span class="o">==</span> <span class="n">dset</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="mi">0</span><span class="o">)));</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;False: &quot;</span> <span class="o">+</span> <span class="o">(</span><span class="n">dset</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">dset</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="mi">0</span><span class="o">)));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>并查集的应用</h2>

<p>可以发现并查集是一个<strong>很优雅</strong>的数据结构，它的实现很简单，效率却非常高。凡是涉及不相交集合的查找与合并问题，都可以使用并查集来解决问题。这里最为关键的是集合元素之间不能有交集，也就是说除以我们指定的圈长方式来划分集合以外，不能有其他的约束条件，否则并查集就失效了。比如说现实生活中的人，可以以工作所在的公司来划分集合，也可以以住的小区来划分，假如题目中两个约束条件都在，那就没有办法应用并查集了。</p>

<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-consecutive-sequence/solution/by-alexhilton-ip97/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/disjoint-set-data-structures/">Disjoint Set Data Structures</a></li>
<li><a href="https://cp-algorithms.com/data_structures/disjoint_set_union.html">Disjoint Set Union</a></li>
<li><a href="https://www.javatpoint.com/disjoint-set-data-structure">Disjoint set data structure</a></li>
<li><a href="https://www.techiedelight.com/disjoint-set-data-structure-union-find-algorithm/">Disjoint–Set Data Structure (Union–Find Algorithm)</a></li>
<li><a href="https://www.hackerearth.com/practice/notes/disjoint-set-union-union-find/">Disjoint Set Union (Union Find)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/93647900">算法学习笔记(1) : 并查集</a></li>
<li><a href="https://oi-wiki.org/ds/dsu/">并查集</a></li>
<li><a href="https://www.cnblogs.com/onlyblues/p/14668087.html">并查集算法 </a></li>
<li><a href="https://segmentfault.com/a/1190000022952886">图解并查集，附赠几道 Leetcode 练手题</a></li>
<li><a href="https://blog.csdn.net/weixin_44176696/article/details/106434770">简单并查集讲解（并+查）与代码实现</a></li>
<li><a href="https://zh-spike.github.io/studyRepo/Algorithm/Notes/AdvancedDataStructure/%E5%B9%B6%E6%9F%A5%E9%9B%86/">并查集</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解拓扑排序]]></title>
    <link href="http://toughcoder.net/blog/2022/09/08/topological-sorting/"/>
    <updated>2022-09-08T16:41:37+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/08/topological-sorting</id>
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/5223807">拓扑排序</a>（<a href="https://en.wikipedia.org/wiki/Topological_sorting">Topological Sorting</a>）是指将一个有向无环图（Directed Acyclic Graph）的所有顶点排成一个线性序列，使得图中的起始节点总是排在终止节点的前面，这是有向图每一个边都有起始节点和终止节点。这个名字有点容易混淆，它跟排序算法没有任何关系，拓扑排序仅是针对有向无环图，找到所有节点的一个可达的线性顺序。</p>

<p><a href="http://toughcoder.net/blog/2022/09/08/topological-sorting/"><img src="https://iq.opengenus.org/content/images/2020/03/topo1-1.png" title="auto auto" ></a></p>

<!-- more -->


<p>关于图的基本概念可以<a href="http://toughcoder.net/blog/2022/09/08/graph-data-structure-made-easy/">参阅这个文章</a>。</p>

<h2>理解拓扑排序</h2>

<p>拓扑排序是针对有向无环图才有意义，它是有向无环图所有顶点的一个线性序列，每个顶点只出现一次，所有顶点都要出现，如果有一条边是从顶点v[i]到v[j]的，那么在拓扑排序中v[i]一定要排在v[j]的前面。</p>

<p><img src="https://wiki.swarma.org/images/c/cd/A_DAG_G.png" alt="" /></p>

<p>有向无环图不一定存在拓扑排序，比如图不是全连通的，有些节点之间没有路径连接。但存在拓扑排序的一定是有向无环图，因此拓扑排序可以用来验证一个图是否是有向无环图。</p>

<h2>拓扑排序的意义</h2>

<p>拓扑排序通常代表着顶点之间的依赖关系，比如软件库的依赖关系，比如课程之间的依赖关系，比如任务调度中的依赖关系等，拓扑排序能够保证任务正确执行，被依赖的肯定 能先执行完，两个顶点（代表的任务）要么是有依赖关系的，要么是没有关系的，在拓扑排序中肯定 不会存在依赖错乱。</p>

<h2>拓扑排序的实现方法</h2>

<p>借助BFS可以实现拓扑排序。</p>

<p><img src="https://www.omegaxyz.com/wp-content/uploads/2019/02/topological2.jpg" alt="" /></p>

<h3>实现思路</h3>

<ol>
<li>先计算顶点的入度，入度是针对 有向图而言的，以顶点为终点的边的数量称为顶点的入度</li>
<li>从入度为为0的顶点开始，把它放入队列</li>
<li>每次从队列中取出顶点，打印出来。然后把这个节点所能直接连通的节点入度减1，并取出入度为0的顶点放入队列</li>
<li>重复第3步，直到没有入度为0的顶点，这时应该所有顶点都遍历到了，如果还有剩余顶点，说明有环</li>
</ol>


<p><img src="https://www.omegaxyz.com/wp-content/uploads/2019/02/topological.png" alt="" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>    <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
</span><span class='line'>    <span class="n">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">numCourses</span><span class="o">)</span>
</span><span class='line'>        <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">inDegrees</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>        <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nl">queue:</span><span class="o">:</span><span class="n">offer</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">from</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">from</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">inDegrees</span><span class="o">[</span><span class="n">v</span><span class="o">]--;</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">inDegrees</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/course-schedule/solution/by-alexhilton-r7hf/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/ur2n8P/">剑指 Offer II 115. 重建序列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/ur2n8P/solution/by-alexhilton-qc9l/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/topological-sorting/">Topological Sorting</a></li>
<li><a href="https://www.interviewcake.com/concept/java/topological-sort">Topological Sort</a></li>
<li><a href="https://www.hackerearth.com/practice/algorithms/graphs/topological-sort/tutorial/">Topological Sort</a></li>
<li><a href="https://www.scaler.com/topics/data-structures/topological-sort-algorithm/">Topological Sort Algorithm</a></li>
<li><a href="https://cp-algorithms.com/graph/topological-sort.html">Topological Sorting</a></li>
<li><a href="https://www.javatpoint.com/topological-sorting">Topological Sorting</a></li>
<li><a href="https://songlee24.github.io/2015/05/07/topological-sorting/">拓扑排序（Topological Sorting）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/135094687">图文详解面试常考算法 —— 拓扑排序</a></li>
<li><a href="https://oi-wiki.org/graph/topo/">拓扑排序</a></li>
<li><a href="https://www.cnblogs.com/bigsai/p/11489260.html">拓扑排序详解与实现</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记忆化搜索简介]]></title>
    <link href="http://toughcoder.net/blog/2022/09/08/memorization-search/"/>
    <updated>2022-09-08T16:03:31+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/08/memorization-search</id>
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/4275706">记忆化搜索</a>（Memorization Search），是指在做搜索过程中（比如DFS或者动态规划中）把重叠的子问题的解或者状态存储下来，以防止重复计算。最为常见的就是图搜索方法BFS和DFS时都要对已搜索过的节点进行标记以防止重复遍历，这就是一种记忆化搜索方法。再如动态规划的重复子问题，用数组进行缓存以防止重复计算，这也是一种记忆化搜索方法。</p>

<p><a href="http://toughcoder.net/blog/2022/09/08/memorization-search/"><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.3-yxYgu36IJsH2oONsdqFQHaEe?pid=ImgDet&rs=1" title="auto auto" ></a></p>

<!-- more -->


<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/memoization-1d-2d-and-3d/">Memoization (1D, 2D and 3D)</a></li>
<li><a href="https://oi-wiki.org/dp/memo/">记忆化搜索</a></li>
<li><a href="https://blog.csdn.net/hjf1201/article/details/78680814">记忆化搜索专题</a></li>
<li><a href="https://blog.csdn.net/u010700335/article/details/44136339">记忆化搜索（搜索+dp思想）</a></li>
<li><a href="https://www.cnblogs.com/jinkun113/p/12531918.html">[知识点] 4.1 记忆化搜索与动态规划</a></li>
<li><a href="https://www.zhihu.com/question/60730045">记忆化搜索与动态规划等价吗？</a></li>
<li><a href="http://yudaer.github.io/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/">记忆化搜索</a></li>
<li><a href="https://www.luogu.com.cn/blog/interestingLSY/memdfs-and-dp">聊聊动态规划与记忆化搜索</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/438406757">记忆化搜索 —— 搜索 or 动态规划 ？</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[动态规划从入门到放弃]]></title>
    <link href="http://toughcoder.net/blog/2022/09/08/introduction-to-dynamic-programming/"/>
    <updated>2022-09-08T11:26:06+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/08/introduction-to-dynamic-programming</id>
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408">动态规划</a>(<a href="https://en.wikipedia.org/wiki/Dynamic_programming">Dynamic Programming</a>)动态规划是用来求解具有最优子结构性质问题的一种方法。通俗的来说如果一个问题可以分成多个子问题或者分成多个步骤，每个子问题有多个解或者每个步骤有多个选择，最终求整体问题的一个最优解（最大值，最小值，方法总数，是否可行等等），这样的问题就适合用动态规划来求解。</p>

<p>动态规划一般可分为自顶而下式和自下而上式，自顶而下是通过递归，但因为涉及大量重复计算而导致时间复杂度过高，所以一般都是采用自下而上式，借助额外的空间来缓存子问题的解，减少重复计算从而降低时间复杂度，与<a href="https://baike.baidu.com/item/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/4275706">记忆化搜索</a>有点类似。</p>

<p><a href="http://toughcoder.net/blog/2022/09/08/introduction-to-dynamic-programming/"><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.1-yqbboBtUIUqcYV1V1p5gHaEK?pid=ImgDet&rs=1" title="auto auto" ></a></p>

<!-- more -->


<h2>动态规划的适用范围</h2>

<h3>最优子结构性质</h3>

<p><a href="https://blog.csdn.net/lanchunhui/article/details/52480106">最优子结构特性</a>（<a href="https://en.wikipedia.org/wiki/Optimal_substructure">Optimal Substructure</a>）是指一个问题可以分成多个子问题，每个问题的最优解凑成整个问题的最优解。</p>

<h3>重叠子问题性质</h3>

<p>重叠子问题(<a href="https://en.wikipedia.org/wiki/Overlapping_subproblems">Overlapping subproblems</a>)是指一个问题可以分成多个子问题，每个子问题的解会重复使用多次，也就说后一个子问题的解需要使用到前一个子问题的解。最为典型的就是Fibonacci数列，也就是常说的自上而下的方式来实现动态规划（递归式），因为子问题重复，所以为了提升效率必须把子问题的解存储下来以防止重复计算。</p>

<h2>寻找状态转移方程</h2>

<p>动态规划并不像排序或者二分查找那样有具体的形式，它更是一种策略而非具体的算法，发现一个题目可以用动态规划求解时，还远远不够，要想写出代码，必须推导出来状态转移方程，这才是动态规划的核心，而动态如何定义，又如何转移要视具体的问题而定变化万千，所以说动态规划是最难的一类题，没有之一。</p>

<p>一般而言状态转移方程要以结果为导向，也就是说用这个方程能得到问题的解，这依然是一句废话，要通过大量的练习才能掌握。</p>

<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.programiz.com/dsa/dynamic-programming">Dynamic Programming</a></li>
<li><a href="https://towardsdatascience.com/understanding-dynamic-programming-75238de0db0d">Understanding Dynamic Programming</a></li>
<li><a href="https://www.geeksforgeeks.org/dynamic-programming/">Dynamic Programming</a></li>
<li><a href="https://www.freecodecamp.org/news/demystifying-dynamic-programming-3efafb8d4296/">Demystifying Dynamic Programming</a></li>
<li><a href="http://web.mit.edu/15.053/www/AMP-Chapter-11.pdf">Dynamic Programming</a></li>
<li><a href="https://www.javatpoint.com/dynamic-programming">Dynamic Programming</a></li>
<li><a href="https://oi-wiki.org/dp/">动态规划部分</a></li>
<li><a href="https://juejin.cn/post/6951922898638471181">看一遍就理解：动态规划详解</a></li>
<li><a href="https://houbb.github.io/2020/01/23/data-struct-learn-07-base-dp">五大基本算法之动态规划算法 DP dynamic programming</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/137992855">一文搞定动态规划问题（附DP所有问题链接）</a></li>
<li><a href="https://www.zhihu.com/question/23995189">什么是动态规划（Dynamic Programming）？动态规划的意义是什么？</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1692068">动态规划一篇就够了 全网第二详细, 逐步理解, 万字总结</a></li>
<li><a href="https://blog.csdn.net/u013309870/article/details/75193592">算法-动态规划 Dynamic Programming&ndash;从菜鸟到老鸟</a></li>
<li><a href="https://www.javatpoint.com/optimal-substructure-property">Optimal Substructure Property</a></li>
<li><a href="https://stackoverflow.com/questions/33563230/optimal-substructure-in-dynamic-programing">Optimal substructure in Dynamic Programing</a></li>
<li><a href="https://afteracademy.com/blog/optimal-substructure-and-overlapping-subproblems">Optimal Substructure and Overlapping Subproblems</a></li>
<li><a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84.md">动态规划答疑篇</a></li>
<li><a href="https://www.zhihu.com/question/52165201">动态规划的最优子结构问题，有什么样的问题它不满足最优子结构？</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1695752">深入浅出理解动态规划（二） | 最优子结构</a></li>
<li><a href="https://blog.nowcoder.net/n/7390417560b54107b421b13b47adea88">动态规划（最优子结构、重叠子问题）——附代码示例</a></li>
<li><a href="https://www.geeksforgeeks.org/overlapping-subproblems-property-in-dynamic-programming-dp-1/">Overlapping Subproblems Property in Dynamic Programming | DP-1</a></li>
<li><a href="https://www.geeksforgeeks.org/optimal-substructure-property-in-dynamic-programming-dp-2/?ref=lbp">Optimal Substructure Property in Dynamic Programming | DP-2</a></li>
<li><a href="https://stackoverflow.com/questions/64499367/what-are-overlapping-subproblems-in-dynamic-programming-dp">What are overlapping subproblems in Dynamic Programming (DP)?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[彻底搞懂背包问题]]></title>
    <link href="http://toughcoder.net/blog/2022/09/07/knapsack-problems-made-easy/"/>
    <updated>2022-09-07T21:43:23+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/07/knapsack-problems-made-easy</id>
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/2416931">背包问题</a>（<a href="https://en.wikipedia.org/wiki/Knapsack_problem">Knapsack Problem</a>）是指给定一个容量固定为W的背包和一组数量为n的物品，每个物品的重量为wi，价值为vi，要求从物品中选择若干放入背包，使总物品重量不超过背包容量，并且使价值最大。这是动态规划的一类非常典型的问题。</p>

<p><a href="http://toughcoder.net/blog/2022/09/07/knapsack-problems-made-easy/"><img src="https://ts1.cn.mm.bing.net/th/id/R-C.6b090586ea607208aa7489afa2100875?rik=0hp8cDJSsKDtBw&riu=http%3a%2f%2ftheoptimizationexpert.com%2fwp-content%2fuploads%2f2017%2f01%2f2000px-Knapsack.svg_.png&ehk=Z7IOVN53Bwm0zCcsj9U6VW1sRRzdApmWIymc%2bxo4TSU%3d&risl=&pid=ImgRaw&r=0" title="auto auto" ></a></p>

<!-- more -->


<p>背包问题如果每种物品数量只有一个，那么每个物品只有两种状态『放入背包』和『不放入背包』，这个一般称作0-1背包问题；如果每种物品的数量无限又称完全背包。</p>

<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="http://masc.cs.gmu.edu/wiki/KnapsackProblems">Knapsack Problems</a></li>
<li><a href="https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/">0-1 Knapsack Problem | DP-10</a></li>
<li><a href="https://medium.com/@fabianterh/how-to-solve-the-knapsack-problem-with-dynamic-programming-eb88c706d3cf">How to solve the Knapsack Problem with dynamic programming</a></li>
<li><a href="https://www.interviewbit.com/blog/0-1-knapsack-problem/">0-1 Knapsack Problem</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/345364527">咱就把0-1背包问题讲个通透！</a></li>
<li><a href="https://blog.csdn.net/liangbopirates/article/details/9750463">背包问题详解</a></li>
<li><a href="https://blog.csdn.net/Iseno_V/article/details/100001133">01背包问题详解（浅显易懂）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/93857890">动态规划之背包问题系列</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/349054931">背包问题算法总结</a></li>
<li><a href="https://blog.csdn.net/na_beginning/article/details/62884939">背包问题详解：01背包、完全背包、多重背包</a></li>
<li><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.md">动态规划：关于01背包问题，你该了解这些！</a></li>
<li><a href="https://seramasumi.github.io/docs/Algorithms/mc-%E5%BE%AE%E8%AF%BE%E5%A0%82-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html">第一章 背包问题介绍</a></li>
<li><a href="https://oi-wiki.org/dp/knapsack/">背包 DP</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[贪心算法简介]]></title>
    <link href="http://toughcoder.net/blog/2022/09/07/introduction-to-greedy-algorithm/"/>
    <updated>2022-09-07T20:55:12+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/07/introduction-to-greedy-algorithm</id>
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/5411800">贪心算法</a>(<a href="https://en.wikipedia.org/wiki/Greedy_algorithm">Greedy Algorithm</a>)，又可称作贪婪算法，简称贪心，它是一指一种决策策略，依据统一的规则，在局部选择最优解，继而成为全局最优解。最经典的问题就是一类最短路径问题，从当前节点选择离它最近的节点，然后继续，到达目标节点后这一路径就是全局最短路径（这是<a href="http://toughcoder.net/blog/2022/09/12/understanding-dijkstra-algorithm/">Dijkstra算法</a>）；再如可分割的背包问题，物品有不同的重量和价值，但物品可分割，这也是贪心算法的经典应用案例。</p>

<p><a href="http://toughcoder.net/blog/2022/09/07/introduction-to-greedy-algorithm/"><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.avKovBqhy1bYjf6o2e81RgHaFj?pid=ImgDet&rs=1" title="auto auto" ></a></p>

<!-- more -->


<h2>贪心算法的适用范围</h2>

<p>贪心算法最重要的特点是子问题的局部最优解即是最后的全局最优解，每一个子问题相互独立，不相互影响，这样的问题贪心能得到最优解，但通常这类问题较少，经典的就是会议室调度问题。</p>

<p>更多的时候，贪心是一近似算法（<a href="https://en.wikipedia.org/wiki/Approximation_algorithm">Approximation aglorithm</a>），比如对于NP问题，贪心算法能得到一个近似解，虽然不是最优，但比较按近最优。比如像集合覆盖，地图着色，旅行商地图问题等，都是可以用贪心来求得一个近似解。</p>

<p>贪心算法就是，把问题分成多个子问题，设定一个贪心策略，针对每个子问题应用贪心策略，继而得到整个问题的解。比如会议室调度问题，每次都选择前一个会议结束后，最早开始最早结束；再如Dijkstra算法，每次从当前顶点出发，在其相邻的顶点中刷新较小的距离，并选择距离最短的顶点作为下一个当前顶点。</p>

<h2>贪心与动态规划的区别</h2>

<p>贪心和动态规划都是求解最优子结构问题，但贪心不考虑全局，只关注局部最优，而动态规划则要考虑整体最优解，局部可能选择最优也可能不选择。动态规划的应用范围更广，能用贪心解决的问题用动态规划一定可以，而能用动态规划解的，贪心不一定可以，应该说贪心是动态规划的一个子方法。</p>

<p>就比如0-1背包问题，如果物品不可分割，那么贪心是得不到解的，只考虑局部最优（每次选择最大能填满剩余空间的物品）是不可能得到全局最优解的，只能用动态规划来解。但假如物品是可以分割的，那么贪心就可解，并且是一个效率较高的解法。</p>

<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/solution/by-alexhilton-pv84/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://brilliant.org/wiki/greedy-algorithm/">Greedy Algorithms</a></li>
<li><a href="https://www.freecodecamp.org/news/what-is-a-greedy-algorithm/">Greedy Algorithms Explained with Examples</a></li>
<li><a href="https://www.programiz.com/dsa/greedy-algorithm">Greedy Algorithm</a></li>
<li><a href="https://www.guru99.com/greedy-algorithm.html">Greedy Algorithm with Example: What is, Method and Approach</a></li>
<li><a href="https://www.simplilearn.com/tutorials/data-structure-tutorial/greedy-algorithm">What is Greedy Algorithm: Example, Applications, Limitations and More</a></li>
<li><a href="https://www.hackerearth.com/practice/algorithms/greedy/basics-of-greedy-algorithms/tutorial/">Basics of Greedy Algorithms</a></li>
<li><a href="https://blog.csdn.net/effective_coder/article/details/8736718">贪心算法详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/53334049">小白带你学&mdash;贪心算法（Greedy Algorithm)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/180104885">贪心算法详解（附例题）</a></li>
<li><a href="https://houbb.github.io/2020/01/23/data-struct-learn-07-base-greedy">五大基本算法之贪心算法 Greedy</a></li>
<li><a href="https://blog.csdn.net/weixin_39799825/article/details/111391311">贪心策略取得最优解的条件_常用算法之贪心算法</a></li>
<li><a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2616926.html">贪心算法</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树状树组简介]]></title>
    <link href="http://toughcoder.net/blog/2022/09/06/intro-to-binary-indexed-tree/"/>
    <updated>2022-09-06T21:22:36+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/06/intro-to-binary-indexed-tree</id>
    <content type="html"><![CDATA[<p>树状数组，即Binary Indexed Tree，简单来理解就是用数组来表示一颗树，它的实际存储结构是数组，但元素之间的逻辑关系是树。通常用于解决区间问题和快速计算前缀和的问题。</p>

<p><a href="http://toughcoder.net/blog/2022/09/06/intro-to-binary-indexed-tree/"><img src="https://www.cdn.geeksforgeeks.org/wp-content/uploads/BITSum.png" title="auto auto" ></a></p>

<!-- more -->


<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://halfrost.com/binary_indexed_tree/">聊聊树状数组 Binary Indexed Tree</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/99167607">算法和数据结构 | 树状数组（Binary Indexed Tree）</a></li>
<li><a href="https://www.topcoder.com/thrive/articles/Binary%20Indexed%20Trees">BINARY INDEXED TREES</a></li>
<li><a href="https://blog.csdn.net/Yaokai_AssultMaster/article/details/79492190">树状数组（Binary Indexed Tree），看这一篇就够了</a></li>
<li><a href="https://blog.csdn.net/bestsort/article/details/80796531">树状数组 数据结构详解与模板(可能是最详细的了)</a></li>
<li><a href="https://www.cnblogs.com/Last--Whisper/p/13823614.html">树状数组（BIT）—— 一篇就够了</a></li>
<li><a href="https://blog.csdn.net/flushhip/article/details/79165701">树状数组简单易懂的详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/93795692">算法学习笔记(2) : 树状数组</a></li>
<li><a href="https://www.cnblogs.com/xenny/p/9739600.html">树状数组详解</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to Trie]]></title>
    <link href="http://toughcoder.net/blog/2022/09/06/introduction-to-trie/"/>
    <updated>2022-09-06T11:41:14+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/06/introduction-to-trie</id>
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209">字典树</a>，<a href="https://en.wikipedia.org/wiki/Trie">Trie</a>（发音与try一样），也叫前缀树，是在一个树状数据结构中存储一个字典中的所有单词，以快速的实现前缀搜索和单词搜索的数据结构。前缀树是一个多叉树，每个节点会有多个子节点，具体子节点 数量取决于字符集的大小，除了根节点以外，每个节点代表字典中的一个字符，从根节点开始的路径代表着一个前缀或者一个单词。</p>

<p><a href="http://toughcoder.net/blog/2022/09/06/introduction-to-trie/"><img src="https://pic2.zhimg.com/v2-cb9b476f3856b7ae68a00af6911c07a9_b.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>Trie通常用于解决单词搜索和前缀匹配一类的问题，特点是输入的字符集合有限（通常是仅有小写字母），给一组字符串作为输入字典（这就是字典），然后涉及前缀或者单词搜索，符合这几个条件的问题就可以考虑使用Trie来解决。</p>

<h2><a href="https://en.wikipedia.org/wiki/Trie">Trie</a>的标准实现</h2>

<p>标准的Trie是一个树形结构，其节点是TrieNode，有一个构建字典方法通常是插入一个字符串，以及查询方法search通常是一个完整单词，还有一个前缀查询方法startsWith。</p>

<p>节点的实现，对于大多数情况下依据字符集而定，通常情况下都是只有小写英文字符，所以用一个长度为26的数组即可，因为是树状，要能找到子节点，所以这个数组的类型仍是TrieNode，下标可以作为当前节点的字符。同时可以添加额外的字段 用以标记，到当前节点是否是一个完整单词。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">Trie</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">TrieNode</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">TrieNode</span><span class="o">[]</span> <span class="n">children</span><span class="o">;</span>
</span><span class='line'>        <span class="kt">boolean</span> <span class="n">isWord</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">TrieNode</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">children</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TrieNode</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
</span><span class='line'>            <span class="n">isWord</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="n">TrieNode</span> <span class="n">root</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Trie</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">TrieNode</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">word</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">TrieNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">ch</span> <span class="o">:</span> <span class="n">word</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">ch</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="o">;</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">TrieNode</span><span class="o">();</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">];</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">node</span><span class="o">.</span><span class="na">isWord</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">search</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">word</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">TrieNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">ch</span> <span class="o">:</span> <span class="n">word</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">ch</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="o">;</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">];</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="na">isWord</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">startsWith</span><span class="o">(</span><span class="n">String</span> <span class="n">prefix</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">prefix</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">prefix</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">TrieNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">ch</span> <span class="o">:</span> <span class="n">prefix</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">ch</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="o">;</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">];</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDE3MDk3OC1iZDdmYzQyZDFhODdmMTkxLnBuZw?x-oss-process=image/format,png" alt="" /></p>

<h2>解题技巧</h2>

<p>对于标准实现中，每个节点只有一个额外的字段用以标记到此节点时的路径是否是一个单词。</p>

<p>其实这里也可以加入更多的字段，比如输入字符串携带的其他信息，这样当搜索时遇到匹配，就可以直接提取出这些额外的信息，较复杂的问题必然有单词匹配或者前缀匹配以外的信息需要融合，这时节点就需要多定义一些字段。最为典型的就是题745。</p>

<h2>典型问题</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/implement-trie-prefix-tree/solution/by-alexhilton-8p2z/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/replace-words/">648. 单词替换</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/replace-words/solution/by-alexhilton-dr8k/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-common-prefix/">14. 最长公共前缀</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-common-prefix/solution/by-alexhilton-ajgh/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/implement-magic-dictionary/">676. 实现一个魔法字典</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/implement-magic-dictionary/solution/by-alexhilton-f3jt/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/prefix-and-suffix-search/">745. 前缀和后缀搜索</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/prefix-and-suffix-search/solution/by-alexhilton-qbjy/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://simpledevcode.wordpress.com/2018/12/04/trie-data-structure-from-scratch/">Trie data structure from scratch</a></li>
<li><a href="https://www.toptal.com/java/the-trie-a-neglected-data-structure">The Trie Data Structure: A Neglected Gem</a></li>
<li><a href="https://oi-wiki.org/string/trie/">字典树 (Trie)</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/trie-data-structure-in-c-plus-plus">Trie Data Structure in C/C++</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/28891541">数据结构与算法：字典树（前缀树）</a></li>
<li><a href="https://segmentfault.com/a/1190000040801084">一文搞懂字典树</a></li>
<li><a href="https://pdai.tech/md/algorithm/alg-basic-tree-trie.html">树 - 前缀树(Trie Tree)</a></li>
<li><a href="https://blog.csdn.net/yuzhiqiang666/article/details/80711441">数据结构与算法（十一）Trie字典树</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[回溯算法从入门到精通]]></title>
    <link href="http://toughcoder.net/blog/2022/09/04/backtracking-algorithm-explained/"/>
    <updated>2022-09-04T08:16:04+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/04/backtracking-algorithm-explained</id>
    <content type="html"><![CDATA[<p>回溯(Backtracking)是指在求解的过程中，不断的试探每一步的所有可能的解，如果发现不符合要求，就回退到最初的状态，尝试另外一种可能，直到所有的可能的解都找到。它与DFS的思想是一致的。</p>

<p><a href="http://toughcoder.net/blog/2022/09/04/backtracking-algorithm-explained/"><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.WZQpfmaWBboOu2d1G3ar0gHaE8?pid=ImgDet&rs=1" title="auto auto" ></a></p>

<!-- more -->


<p>回溯通常用来解决的问题是，问题会分成很多步骤，每一步面临多个选择，有多种可能性，需要一个一个的尝试，最终需要找到所有的可能的解。回溯通常用递归来实现，并且它的时间复杂度一般都比较高。它基本上就是穷举和暴力搜索一样，但通过各种奇技淫巧可以做剪枝以降低复杂度。</p>

<p><img src="https://image2.slideserve.com/4888360/backtracking1-l.jpg" alt="" /></p>

<p>最为经典的回溯算法问题就是迷宫问题，比如从一个格子a，出发，有二个方向，还不知道哪个是对的，那就分别向前走，一直走，直到撞墙了，或者到了死路了，才知道这个方向是错的；然后回退到a，按个方向继续走，这就是经典的回溯。</p>

<p><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.5sU8HuB5SNkBeZqVTYShqQHaFj?pid=ImgDet&amp;rs=1" alt="" /></p>

<h2>穷举问题</h2>

<p>穷举，也就是穷尽所有的可能性，最为代表性的问题就是组合排列问题，这是回溯的典型问题。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/permutations/solution/by-alexhilton-k4r5/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/combinations/">77. 组合</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/combinations/solution/by-alexhilton-hrj9/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/letter-case-permutation/">784. 字母大小写全排列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/letter-case-permutation/solution/by-alexhilton-c4lx/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/subsets/">78. 子集</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/subsets/solution/by-alexhilton-1ego/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://techwithkp.com/backtracking-algorithm-explained-with-examples/">Backtracking Algorithm Explained With Examples</a></li>
<li><a href="https://www.programiz.com/dsa/backtracking-algorithm">Backtracking Algorithm</a></li>
<li><a href="https://www.simplilearn.com/tutorials/data-structure-tutorial/backtracking-algorithm">What is Backtracking Algorithm? Types, Examples &amp; its Application</a></li>
<li><a href="https://www.freecodecamp.org/news/backtracking-algorithms-explained/">Backtracking Algorithms Explained</a></li>
<li><a href="https://blog.csdn.net/a1241692733/article/details/123029578">Leetcode 刷题笔记(二十) ——回溯算法篇之分割、子集、全排列问题</a></li>
<li><a href="http://c.biancheng.net/view/3400.html">回溯算法详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/165083789">回溯算法详细总结</a></li>
<li><a href="https://blog.csdn.net/weiyuefei/article/details/79316653">[回溯算法] 五大常用算法之回溯法</a></li>
<li><a href="https://www.jianshu.com/p/dd3c3f3e84c0">小白带你学&ndash;回溯算法</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/93530380">回溯算法套路详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/308282208">关于回溯算法，你该了解这些！</a></li>
<li><a href="https://blog.csdn.net/m0_52824954/article/details/123467217">彻底搞懂回溯算法（本文真的很详细）</a></li>
<li><a href="https://www.cnblogs.com/Curryxin/p/15139654.html">【算法】回溯</a></li>
<li><a href="https://blog.csdn.net/weixin_43208423/article/details/101081544">理解回溯算法——回溯算法的初学者指南</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BFS and DFS Made Easy]]></title>
    <link href="http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy/"/>
    <updated>2022-09-02T22:43:13+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy</id>
    <content type="html"><![CDATA[<p>深度优先搜索和广度优先搜索在二维数据结构中有着非常重要和广泛的应用，今天就来好好的学习和总结一下这两种遍历方法。</p>

<p><a href="http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy/"><img src="https://image1.slideserve.com/3266131/generic-dfs-and-bfs-n.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>基础概念和代码模板</h2>

<p>先来学习一下基础的概念，其实也并不复杂。</p>

<h3>广度优先搜索</h3>

<p>BFS（Breadth First Search）是指优先把与当前节点相连的节点遍历，然后再把相连的节点的所有相连节点遍历，直到所有节点都遍历完。看起来就是一层一层的遍历（树），或者一圈一圈的遍历，像水中的波浪一样从中心点不断向外扩散。</p>

<p>它的遍历特点是，能把最近的两个节点优先遍历到，换句话说，它能找到从某个节点开始到另一个节点的最短路径，这一点相当重要，因此在图相关的搜索中用的较多一些。
<img src="https://www.guru99.com/images/1/020820_0543_BreadthFirs1.png" alt="" />
<img src="https://image1.slideserve.com/1838814/breadth-first-search1-n.jpg" alt="" /></p>

<h3>深度优先搜索</h3>

<p>DFS（Depth First Search），顺着节点的一个方向，不断深入，专注于一个方向直到这个方向上没有节点了（到达了叶子，或者到达了边界，或者最后一个节点）；然后再回到最初的节点，换一个方向，继续前行，直到所有节点都遍历完成。它的特点是只认准一个方向，不撞南墙不回头。</p>

<p>DFS在树中应用是最多的，因为树只有两个方向，一个左子树一个右子树。通常DFS用来解决特定路径相关的问题。
<img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.ccpQCah8fvV1NBvExUtwPgHaFj?pid=ImgDet&amp;rs=1" alt="" />
<img src="https://totheinnovation.com/wp-content/uploads/2021/01/DFS.jpg" alt="" /></p>

<h2>在树中的应用</h2>

<p>树的遍历和路径相关的问题，一般用DFS较为方便，树是最方便用递归的，因此递归 式DFS是解决树的遍历和路径的最广泛的方法。比如，经典的树三种遍历方式（前，中后）如果用递归式DFS来写就相当的简洁。可以<a href="http://toughcoder.net/blog/2022/08/18/binary-tree-made-easy/">参考这篇文章</a>来学习更多关于树的知识。
<img src="https://ts1.cn.mm.bing.net/th/id/R-C.8ceefec538766c3ddf768cea06cc1e15?rik=rr1dG%2bcUB9lblw&amp;riu=http%3a%2f%2fwww.crazyforcode.com%2fwp-content%2fuploads%2f2016%2f04%2fDFS.png&amp;ehk=mijFhhVLUHbPmAS9hIQz8z2gIQG%2fH7pE5QgwSuDB%2bOA%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" /></p>

<p>DFS对于树的大多数问题都是较好的选择，但有一类题，就是层序遍历相关的问题，DFS可能没有优势，因为层序遍历就是用BFS最为直接，通常实践得知，对于树来说，通常BFS的效率要差于DFS。而且对于树来说，BFS能搞定的问题，DFS也一定可以。</p>

<p>那么如何用DFS解决与层有关的问题呢？要借助额外的数据来标记当前节点是在哪一层。树DFS的遍历特点是仍旧是从左下到右下的，而且也是从上到下的（前序而言），因此DFS最先遇到的节点，肯定 是这 一层的第一个节点。DFS也是知道当前节点是属于哪一层的，根节点是第1 层，下一层就是第2层，可以把这个作为参数在DFS过程中传递。额外的数据可以是哈希表，键值就是层序号，值可以节点，当某一层为空时，来的肯定是第一个节点，如果某一层已存在，就可以追加节点，或者依据条件做运算。这样最终也能实现关于层的操作。最为典型的就是<a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">题662. 二叉树最大宽度</a>。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">662. 二叉树最大宽度</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/solution/by-alexhilton-2be9/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>在图中的应用</h2>

<p>对于图来说，因为它可能有多个方向，像矩阵有四个，常规图可能有更多个与其相连的节点，而图的搜索通常是发生在相连的多个节点之间的，因此在图的搜索里面BFS的应用更为广泛。像求一些最短路径，最近距离，拓朴排序等都是用的BFS。</p>

<h3>矩阵表示的图</h3>

<h3>邻接表表示的图</h3>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-islands/solution/200-dao-yu-shu-liang-by-alexhilton-cexx/">题解</a> </td>
<td style="text-align:left;"> 基础 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/max-area-of-island/solution/by-alexhilton-9eby/">题解</a> </td>
<td style="text-align:left;"> 基础 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/flood-fill/">733. 图像渲染</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/flood-fill/solution/733-tu-xiang-xuan-ran-by-alexhilton-mem7/">题解</a> </td>
<td style="text-align:left;"> 单源BFS/DFS </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/01-matrix/">542. 01 矩阵</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/01-matrix/solution/by-alexhilton-ngwy/">题解</a> </td>
<td style="text-align:left;"> 多源BFS </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotting-oranges/">994. 腐烂的橘子</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotting-oranges/solution/994-fu-lan-de-ju-zi-by-alexhilton-6g10/">题解</a> </td>
<td style="text-align:left;"> 多源BFS </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://blog.csdn.net/g11d111/article/details/76169861">BFS——广度优先算法（Breadth First Search）</a></li>
<li><a href="https://samuel92.blog.csdn.net/article/details/75645970">DFS——深度优先算法（Depth First Search）</a></li>
<li><a href="https://www.guru99.com/difference-between-bfs-and-dfs.html">BFS Vs. DFS: Know the Difference with Example</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[双指针总结]]></title>
    <link href="http://toughcoder.net/blog/2022/08/25/summary-of-double-pointers/"/>
    <updated>2022-08-25T22:06:31+08:00</updated>
    <id>http://toughcoder.net/blog/2022/08/25/summary-of-double-pointers</id>
    <content type="html"><![CDATA[<p>双指针是指用两个引用或者索引，或者某种键为主的操作手段，在很多场景有重要的应用，比如链表。有些时候还能成为比较巧妙的解题手段。今天就来总结一下双指针的使用。</p>

<p><a href="http://toughcoder.net/blog/2022/08/25/summary-of-double-pointers/"><img src="https://ducmanhphan.github.io/img/Algorithm/two-pointer/two-pointers-in-two-sequences.png" title="auto auto" ></a></p>

<!-- more -->


<h2>双指针的套路</h2>

<p>根据不同的场合和用法，双指针可以分为<strong>同向双指针</strong>和<strong>对撞指针</strong>。</p>

<h3>同向双指针</h3>

<p>又可以细分为滑动窗口，以及快慢指针。</p>

<h4>滑动窗口</h4>

<p>两个指针，通常一个慢一个快，之间的子数组具有某种特质，快指针（也称右指针）正常向前遍历，新元素会加入，同时左指针也会向前移动，就像一个向前开动的公交车一样。</p>

<p>有些窗口大小是固定的，有些则是不固定的，看具体情况而定，新元素进入以及窗口中的元素移出窗口也要视题目中的具体条件而定。</p>

<h4>快慢指针</h4>

<p>最为经典的场景就是解决一坨单链表问题，比如找链表的中间节点，或者找环，以及归并等等。</p>

<p>此外，快慢指针也常用于数组，通常是涉及数组的元素移动，此类型的要点就是一个指针正常遍历原数组，此为快指针，一个指针用指向结果数组，快指针正常遍历，慢指针依据某些条件才向后移动。</p>

<h3>对撞指针</h3>

<p>就是一个从前往后遍历，一个从后往前遍历，循环中止条件是两指针相遇，通常用在二分查找，回文相关，反转数组列表，或者其他场合。</p>

<h2>双指针技巧</h2>

<p>双指针，除了以上几种比较典型之外啊，其实也挺宽泛的，只要用了两个以上的指针（下标）就算得上是双指针，也没啥固定的模式。</p>

<p>但有时，有两个常见的技巧能大幅优化效率和代码，一个就是<strong>逆向思维</strong>，比如一些涉及归并的题目中，如果用常规思路，从前往后，可能用额外空间才可以，但如果从后往前，或者从两头往中间，可能就打开了一片新天地。这里的正向和逆向视具体情况而定，比如有些归并类的是直觉上是从前往后，那这就是正向，从后往前则是逆向；再如一些中间分段的数组如山峰或者山谷形的，从间往往两头是正向，那从两头往中间则逆向。如题977。</p>

<p>还有一个技巧是，如果要求返回数组的顺序由原数组决定，但数据 的选择由计算规则确定，也就是说我们是在计算后的数组上应用双指针进行选择，但又要返回原数据中的数据顺序，这时呢，其实可以不必直接用双指针在计算后的数组中选择结果，可以先行移动指针到目标范围，然后再遍历去选择结果。典型的问题是题658。</p>

<h2>典型问题</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 要点说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/solution/by-alexhilton-a4qc/">题解</a> </td>
<td style="text-align:left;"> 经典对撞指针 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/find-k-closest-elements/">658. 找到 K 个最接近的元素</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/find-k-closest-elements/solution/by-alexhilton-ixrs/">题解</a> </td>
<td style="text-align:left;"> 先移指针到目标范围，再选择结果 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/squares-of-a-sorted-array/solution/977-you-xu-shu-zu-de-ping-fang-by-alexhi-hcu8/">题解</a> </td>
<td style="text-align:left;"> 逆向思维</td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/container-with-most-water/solution/by-alexhilton-1va8/">题解</a> </td>
<td style="text-align:left;"> 对撞指针 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reverse-words-in-a-string-iii/">557. 反转字符串中的单词 III</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reverse-words-in-a-string-iii/solution/by-alexhilton-qn2n/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotate-array/solution/189-lun-zhuan-shu-zu-by-alexhilton-1ih4/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/middle-of-the-linked-list/solution/by-alexhilton-0uz4/">题解</a> </td>
<td style="text-align:left;"> 经典快慢指针 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/19-shan-chu-lian-biao-de-dao-shu-di-n-ge-xa3i/">题解</a> </td>
<td style="text-align:left;"> 经典快慢指针 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/permutation-in-string/">567. 字符串的排列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/permutation-in-string/solution/by-alexhilton-80gu/">题解</a> </td>
<td style="text-align:left;"> 经典滑动窗口 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-by-alexhilton-ecxc/">题解</a> </td>
<td style="text-align:left;"> 滑动窗口 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Binary Search Made Easy]]></title>
    <link href="http://toughcoder.net/blog/2022/08/25/binary-search-made-easy/"/>
    <updated>2022-08-25T21:11:45+08:00</updated>
    <id>http://toughcoder.net/blog/2022/08/25/binary-search-made-easy</id>
    <content type="html"><![CDATA[<p>二分查找是效率特别高的一种算法，它能将线性复杂度O(n)降低到对数级别O(log<sup>n</sup>)。但它对输入数据有要求，比如对于数组来说必须是排序的，否则是不能应用二分的。今天就来理解一下二分查找，然后总结常见的题目和注意事项。</p>

<p><a href="http://toughcoder.net/blog/2022/08/25/binary-search-made-easy/"><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.eYVdL0QhR65_z_bxbevPWAHaE7?pid=ImgDet&rs=1" title="auto auto" ></a></p>

<!-- more -->


<h2>理解二分查找</h2>

<p>二分查找的特点是每次能把输入数据分成一半，这样不断的二分下去，直到只剩下一个。所以能应用二分查找的最重要的条件是要能够依据某种条件把输入数据分为两段，最常见的是排序数组查找，但并不限于这个，只要能依据某种条件把数据分成二份，就可以应用二分查找，比如数据是某种情况下的单调性？或者数据有明显的断崖，或者数据是山峰形状的，或者是山谷形状的都可以应用二分查找。二分查找博大精深，需要好好体会其<strong>二分</strong>的内涵。</p>

<p>对于升序排序数组查找的标准二分代码模板：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'><span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">((</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">mid</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="n">mid</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>注意事项</h2>

<p>注意事项就是，区间的开闭，以及中间索引的计算。循环的退出条件一般都是有等号的left &lt;= right时循环。</p>

<p>对于有些情况索引会特别的大，造成计算中间索引时会发生溢出，这时就要先减后加，以防溢出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">((</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外，这里的括号都不可省略，虽然移位符的优先级高于加法，但如果left等于right时，不加括号这个运算会出错。</p>

<h2>常见题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/solution/by-alexhilton-a4qc/">题解</a> </td>
<td style="text-align:left;"> 标准二分查找 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/find-k-closest-elements/">658. 找到 K 个最接近的元素</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/find-k-closest-elements/solution/by-alexhilton-ixrs/">题解</a> </td>
<td style="text-align:left;"> 找第一个小于等x的位置 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/squares-of-a-sorted-array/solution/977-you-xu-shu-zu-de-ping-fang-by-alexhi-hcu8/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/first-bad-version/">278. 第一个错误的版本</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/first-bad-version/solution/278-di-yi-ge-cuo-wu-de-ban-ben-by-alexhi-rs7n/">题解</a> </td>
<td style="text-align:left;"> 如何防范溢出 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/binary-search/solution/704-er-fen-cha-zhao-by-alexhilton-ts16/">题解</a> </td>
<td style="text-align:left;"> 标准二分查找 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/solution/by-alexhilton-ufe4/">题解</a> </td>
<td style="text-align:left;"> BST中的二分查找 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[线段树让你不再惧怕区间问题]]></title>
    <link href="http://toughcoder.net/blog/2022/08/23/rmq-made-easy/"/>
    <updated>2022-08-23T23:58:27+08:00</updated>
    <id>http://toughcoder.net/blog/2022/08/23/rmq-made-easy</id>
    <content type="html"><![CDATA[<p><a href="http://toughcoder.net/blog/2022/08/23/rmq-made-easy/"><img src="https://ts1.cn.mm.bing.net/th/id/R-C.c6c6bbd2b56e8b5c9ddc2dbf1e889309?rik=14ZVI1eUra2OGw&riu=http%3a%2f%2fmedianet.kent.edu%2fsurveys%2fIAD06S-p2psearch-alok%2fimages%2fmin_max_range.jpg&ehk=e1Pnkh9cs9629hf15dVM5nTmu9iDMqxP5Oo4iZy7jCc%3d&risl=&pid=ImgRaw&r=0)" title="auto auto" ></a></p>

<!-- more -->


<h2>典型问题</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/">1450. 在既定时间做作业的学生人数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/solution/by-alexhilton-60ye/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/my-calendar-ii/">731. 我的日程安排表 II</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/my-calendar-ii/solution/by-alexhilton-bggq/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/my-calendar-i/">729. 我的日程安排表 I</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/my-calendar-i/solution/by-alexhilton-ovl9/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-intervals/solution/by-alexhilton-a3ie/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://blog.csdn.net/huangzihaoal/article/details/81813454">【算法】线段树详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/106118909">算法学习笔记(14): 线段树</a></li>
<li><a href="https://oi-wiki.org/ds/seg/">线段树 OI Wiki</a></li>
<li><a href="https://www.cnblogs.com/AC-King/p/7789013.html">线段树详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/34150142">史上最详细的线段树教程</a></li>
<li><a href="https://www.cnblogs.com/RioTian/p/13409694.html">线段树 - 多组图带你从头到尾彻底理解线段树</a></li>
<li><a href="https://halfrost.com/segment_tree/">线段树 Segment Tree 实战</a></li>
<li><a href="https://blog.csdn.net/Yaokai_AssultMaster/article/details/79599809">线段树（segment tree)，看这一篇就够了</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247493262&amp;idx=1&amp;sn=2d8e192a5767b49b9a13a6192ab3b833">关于 RMQ 的若干解法</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编码常见技巧总结]]></title>
    <link href="http://toughcoder.net/blog/2022/08/23/most-used-tricks/"/>
    <updated>2022-08-23T11:04:45+08:00</updated>
    <id>http://toughcoder.net/blog/2022/08/23/most-used-tricks</id>
    <content type="html"><![CDATA[<p>在日常编码中有一些非常常用，但却很细节的小技巧，虽然有朴素的实现的方式，但如果能掌握一些高级技巧不但性能会更好，并且因为技巧比较流行，也不会影响可读性。最简单的例子就是除2和乘2，当然可以直接用乘法和除法，但如果用移位效果更好，也并不影响可读性，因为这是比较流行的做法。</p>

<p>这里就将总结一些常用的小技巧，以供日后查阅。</p>

<p><a href="http://toughcoder.net/blog/2022/08/23/most-used-tricks/"><img src="https://ts1.cn.mm.bing.net/th/id/R-C.3a082402d0c427749a5631fdbf6b98cc?rik=bx2gAAoi%2fUTUEw&riu=http%3a%2f%2fpetbehavior.org%2fwp-content%2fuploads%2f2010%2f11%2fUSEFUL-DOG-TRICKS.jpg&ehk=xPrkIcwPXM0ubFuXq9oLP96I0rTpkGU4RwClXsZbQpw%3d&risl=&pid=ImgRaw&r=0" title="auto auto" ></a></p>

<!-- more -->


<h2>整数相关技巧</h2>

<h3>判断奇偶</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">// 1. 朴素做法</span>
</span><span class='line'><span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>   <span class="c1">// even</span>
</span><span class='line'><span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// odd</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="c1">// 2. 用移位</span>
</span><span class='line'><span class="k">if</span> <span class="o">((</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="o">)</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>   <span class="c1">// even</span>
</span><span class='line'><span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>  <span class="c1">// odd</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>乘2</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">// 左移1位，相当于乘2</span>
</span><span class='line'><span class="n">n</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>除2</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">// 右移1位，相当于除2</span>
</span><span class='line'><span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span>
</span></code></pre></td></tr></table></div></figure>


<h3>求2的k次幂</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="c1">// 朴素做法</span>
</span><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span> <span class="n">Math</span><span class="o">.</span><span class="na">pow</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">k</span><span class="o">);</span>
</span><span class='line'><span class="c1">// 1左移k次，就是2的k次幂</span>
</span><span class='line'><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">k</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>有符号和无符号的右移</h3>

<p>常规右移是有符号的，它不会动最高位的符号位。而如果要实现『无符号』式右移，需要使用逻辑右移符>>>。</p>

<h3>异或</h3>

<p>一个数异或它自己结果会是0</p>

<h3>取数位</h3>

<p>与1与取，能获取某个数位bit，这就像印章一样，把bit印在提供的1上面，检查 结果如果是1，说明bit是1，如果是0，说明bit是0。</p>

<h3>放数位</h3>

<p>用0取或，可以放数位，就像印刷中的拓写一样，给源数位刷上颜色，可以把其复制到白布上面(0上面）。</p>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/power-of-two/">231. 2 的幂</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/power-of-two/solution/by-alexhilton-t5go/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/counting-bits/">338. 比特位计数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/counting-bits/solution/338-bi-te-wei-ji-shu-by-alexhilton-ft3h/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/single-number/solution/136-zhi-chu-xian-yi-ci-de-shu-zi-by-alex-1ta2/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/hamming-distance/">461. 汉明距离</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/hamming-distance/solution/by-alexhilton-0opr/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-1-bits/?envType=study-plan&amp;id=suan-fa-ru-men">191. 位1的个数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-1-bits/solution/by-alexhilton-iz5o/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reverse-bits/">190. 颠倒二进制位</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reverse-bits/solution/by-alexhilton-2h12/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>不要重复造轮子</h2>

<p>虽然刷题中尝尝遇到位运算的问题，但其实API中有大量写好的方法供我们调用，不可浪费，实际工作中，应该优先使用API。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> API </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#bitCount-int-">Integer.bitCount</a> </td>
<td style="text-align:left;"> 返回1的个数，与题191一样 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Integer.html#reverse-int-">Integer.reverse</a> </td>
<td style="text-align:left;"> 颠倒二进制bits，与题190一样 </td>
</tr>
</tbody>
</table>


<h2>边界</h2>

<h3>二分查找中间防溢出</h3>

<p>二分查找通常要计算区间的中间，比如这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'><span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
</span><span class='line'><span class="k">while</span> <span class="o">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>但这样计算有问题，当区间特别大时，比如超过了最大整数的一半时，那么用相加来计算就会整数溢出，从而出问题。更好的做法是用减法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="o">((</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="o">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外，这里的括号都是必要的，虽然移位运算符的优先级高，但是当right与left相等时，如果后半部分不加括号还是会出错。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.zhihu.com/question/38206659">位运算有什么奇技淫巧？</a></li>
<li><a href="https://blog.csdn.net/zmazon/article/details/8262185">优秀程序员不得不知道的20个位运算技巧</a></li>
<li><a href="https://www.cnblogs.com/blknemo/p/14470610.html">【算法】位运算技巧</a></li>
<li><a href="https://blog.51cto.com/JavaAlliance/2933742">位运算的奇“赢”技巧 </a></li>
<li><a href="https://codeforwin.org/2018/05/10-cool-bitwise-operator-hacks-and-tricks.html">10 cool bitwise operator hacks and tricks every programmer must know</a></li>
<li><a href="https://www.geeksforgeeks.org/bitwise-hacks-for-competitive-programming/">Bitwise Hacks for Competitive Programming</a></li>
<li><a href="https://levelup.gitconnected.com/bit-manipulation-tips-and-tricks-you-should-know-3848a9019139">Bit Manipulation Tips and Tricks You Should Know</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二叉树从入门到放弃]]></title>
    <link href="http://toughcoder.net/blog/2022/08/18/binary-tree-made-easy/"/>
    <updated>2022-08-18T21:59:41+08:00</updated>
    <id>http://toughcoder.net/blog/2022/08/18/binary-tree-made-easy</id>
    <content type="html"><![CDATA[<p>树是非常常见的一种数据结构，有着广泛的应用，而二叉树又是树中最最常见的树，值得好好的学习和总结。
树的定义可以<a href="https://www.programiz.com/dsa/trees">参考这里</a>，二叉树Binary Tree的定义<a href="http://cslibrary.stanford.edu/110/BinaryTrees.html#:~:text=A%20binary%20tree%20is%20made%20of%20nodes%2C%20where,binarytree%20with%20no%20elements%20--%20the%20empty%20tree.">在这里</a>，还有<a href="https://www.javatpoint.com/binary-search-tree">二叉搜索树Binar Search Tree</a>。</p>

<p><a href="http://toughcoder.net/blog/2022/08/18/binary-tree-made-easy/"><img src="https://ts1.cn.mm.bing.net/th/id/R-C.0443658c5d6fda4db7615ed681a39cca?rik=H4456L%2b5IJAkrg&riu=http%3a%2f%2f108.61.119.12%2fwp-content%2fuploads%2f2014%2f10%2fbinary-tree-1-pre-order.gif&ehk=d%2bxB8RQ0QrVVDnUp8Zeo2ICWUFYmxcqCWMc2WIGlzmY%3d&risl=&pid=ImgRaw&r=0" title="auto auto" ></a></p>

<!-- more -->


<h2>二叉树特点</h2>

<p>如果节点数量是n，那么高度或者说深度h，那么h至少是logn，节点的位置可以参考 <a href="https://leetcode.cn/problems/print-binary-tree/solution/by-alexhilton-81nh/">题 655. 输出二叉树 BFS/DFS
</a>，这题有树的高度和每个节点的详细信息。</p>

<p>另外一类问题是，对节点进行编号以方便进行某些计算，这时可以以存在的节点为准而，常见的办法是从父节点往子节点编号，比如父节点编号为i，那么其左子节点就是i*2，而右子节点就是i*2+1。从根节点自上而下，根节点肯定 是0，这样每一层都能从0开始做好编号，且不会重复。如<a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/solution/by-alexhilton-2be9/">题 662. 二叉树最大宽度</a></p>

<h2>二叉树的常规遍历</h2>

<p>二叉树的常规遍历，其实也是<strong>深度优先</strong>遍历，分为三种先序，中序和后序。这里的所谓的前中后，是指<strong>子节点相对于根节点而言的</strong>。对于一个最小的二叉树，也就是只有一个左子节点和右子节点的树来说，先序，就是左右子节点在根节点之后，也即根在最前面，中序就是根在左右中间，而后序则是根在最后。以这个『1, 2, 3』为倒的最小树来说，前序即是[1, 2, 3]，中序是[2, 1, 3]而后序 是[2, 3, 1]。</p>

<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--XWH6osdb--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/i/3072o3znskwf4wkbqshz.png" alt="" /></p>

<p>左子节点总是在右子节点前面，左子树总是在右子树前面的，且从整体树来看，遍历的顺序仍旧是<strong>从左下到右下</strong>，所以需要先找到最左下的一颗最小子树。</p>

<h3>递归式</h3>

<h3>迭代式</h3>

<h3>逆序遍历</h3>

<p>前面说了，二叉树的常规遍历仍旧是从左下向右下的，如果看成数组，那就相当于是从前往后的。但有些情况吧，逆序遍历会更方便，也跟数组一样，有时候从后向前遍历更为合适。逆序遍历并不难，只需要把左右子树的处理换个位置就行了，先找到最右下的最小子树，从右下往左下走。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/solution/114-er-cha-shu-zhan-kai-wei-lian-biao-by-3mke/">题解</a></td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/most-frequent-subtree-sum/">508. 出现次数最多的子树元素和</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/most-frequent-subtree-sum/solution/by-alexhilton-ab5a/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/solution/by-alexhilton-c8a0/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/by-alexhilton-q14h/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>二叉树的层序遍历</h2>

<p>也即是广度优先遍历，但普通的广度优先一般没啥用，实际题目中用的最多是层序遍历。</p>

<h3>基础广度优先遍历</h3>

<p>借助队列，先把根节点加入队列，利用队列的先进先出特性，从队首取出一个节点，并把它的子节点加入到队尾，直到队列为空为止，这样的遍历顺序 便是 基础的广度优先，但在实际中基本没啥用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">root</span><span class="o">);</span>
</span><span class='line'><span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
</span><span class='line'>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span><span class="o">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">quuee</span><span class="o">.</span><span class="na">right</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>层序遍历</h3>

<p>树的特点是一层是父节点，一层是子节点，知道了父节点层，就能找到子节点层，要想对子节点层做操作必须知道其父节点层。因此层序遍历在实际题目中应用很广泛。</p>

<p>如何能知道每一层呢？其实如果能知道一层，就能知道其下一层，它们是递进的关系，也就分开了。幸运的是我们知道第一层（或者说最上面一层）对，它就是根节点，从它开始，就能找出每一层。具体的做法可以用计数法，计算每层的节点数，用以分
开；也可以用双队列法，一层存放父节点，一层存放子节点，然后交换两个列表，个人喜欢使用双队列法。</p>

<p>具体可以参考以下文章，以及题目中的题解都比较详细，就不重复了。</p>

<ol>
<li><a href="https://leetcode.cn/leetbook/read/data-structure-binary-tree/xej9yc/">层序遍历 - 介绍</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-by-leetcode-solution/">二叉树的层序遍历</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/solution/die-dai-di-gui-duo-tu-yan-shi-102er-cha-shu-de-cen/">迭代+递归 多图演示 102.二叉树的层次遍历</a></li>
</ol>


<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/solution/by-alexhilton-iv95/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/solution/107-er-cha-shu-de-ceng-xu-bian-li-ii-by-2sibx/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/find-bottom-left-tree-value/solution/by-alexhilton-m79i/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515. 在每个树行中找最大值</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/solution/by-alexhilton-6j1a/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/complete-binary-tree-inserter/">919. 完全二叉树插入器</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/complete-binary-tree-inserter/solution/by-alexhilton-msqn/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/add-one-row-to-tree/">623. 在二叉树中增加一行</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/add-one-row-to-tree/solution/623-zai-er-cha-shu-zhong-zeng-jia-yi-xin-4hn1/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">662. 二叉树最大宽度</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/solution/by-alexhilton-2be9/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/">1161. 最大层内元素和</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/solution/by-alexhilton-anlb/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/deepest-leaves-sum/">1302. 层数最深叶子节点的和</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/deepest-leaves-sum/solution/1302-ceng-shu-zui-shen-xie-zi-jie-dian-d-o5my/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>路径相关问题</h2>

<p>路径定义不尽相同，有些路径是从根节点到叶子的算路径，有些则不必，前面说的都是竖着的路径，也就是从根节点出发到叶子节点，而有些则可以横着的，比如从左子节点经过根节点到右边节点的路径。路径相关的问题很多，且难度上升级一个量级，通常涉及动态规划。</p>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/binary-tree-paths/solution/by-alexhilton-xjyj/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/path-sum/solution/by-alexhilton-8y7e/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/solution/124-er-cha-shu-zhong-de-zui-da-lu-jing-h-deqd/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/diameter-of-binary-tree/solution/by-alexhilton-0ncn/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solution/by-alexhilton-l5q4/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>二叉搜索树</h2>

<p>二叉搜索树Binary Search Tree（常简称作BST），是一种特殊的二叉树，它保证左子树小于根节点小于右子树，如果以中序遍历BST得到的会是一个严格递增的序列。
<img src="https://leetcode.com/problems/binary-search-tree-iterator/Figures/173/appr_1.png" alt="" />
<strong>BST是一个严格递增的序列</strong>，这就是BST的本质，与BST有关的题都要应用<strong>二分查找</strong>：从根节点开始，目标值等于当前节点值，就找到目标了，小于节点值就向左找，大于就向右找。写成代码就是这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">TreeNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
</span><span class='line'><span class="k">while</span> <span class="o">(</span><span class="n">node</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">node</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">val</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">right</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">left</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这与<strong>二分查找</strong>是一样的，这就是BST的本质，深刻理解 了它的本质后，一切问题都会迎刃而解。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/solution/by-alexhilton-ufe4/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/solution/by-alexhilton-4nxa/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/validate-binary-search-tree/solution/by-alexhilton-eqbp/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/by-alexhilton-yvgi/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/">653. 两数之和 IV - 输入 BST</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/solution/by-alexhilton-o064/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://blog.csdn.net/Real_Fool_/article/details/113930623">数据结构：树(Tree)【详解】</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/90255760">数据结构中&#8221;树&#8221;的全面讲解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/443034942">数据结构&mdash;树（彻底理解递归算法）</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/solution/er-cha-shu-de-qian-xu-bian-li-by-leetcode-solution/">二叉树的前序遍历</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/">二叉树的中序遍历</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/dong-hua-yan-shi-94-er-cha-shu-de-zhong-xu-bian-li/">动画演示+三种实现 94. 二叉树的中序遍历</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/">二叉树的后序遍历</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/bang-ni-dui-er-cha-shu-bu-zai-mi-mang-che-di-chi-t/">「代码随想录」帮你对二叉树不再迷茫，彻底吃透前中后序递归法（递归三部曲）和迭代法（不统一写法与统一写法）
</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/solution/leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2/">史上最全遍历二叉树详解</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/solution/tu-jie-er-cha-shu-de-si-chong-bian-li-by-z1m/">图解 二叉树的四种遍历</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[表达式求值问题总结]]></title>
    <link href="http://toughcoder.net/blog/2022/08/18/solve-expression-evaluation/"/>
    <updated>2022-08-18T21:15:04+08:00</updated>
    <id>http://toughcoder.net/blog/2022/08/18/solve-expression-evaluation</id>
    <content type="html"><![CDATA[<p>在模拟范畴内表达式运算求值是比较典型的一类问题。</p>

<p><a href="http://toughcoder.net/blog/2022/08/18/solve-expression-evaluation/"><img src="https://www.wikihow.com/images/thumb/7/73/Evaluate-an-Algebraic-Expression-Step-9.jpg/aid3181794-v4-728px-Evaluate-an-Algebraic-Expression-Step-9.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>问题分类</h2>

<p>表达式类问题一般输入都是以字串形式，所以第一个要点就是把一个字符串按语义拆解为符号，操作符和操作数。</p>

<p>第二个要点就是表达式的运算。</p>

<p>形式上又可分为后缀式和中缀式（也即正常顺序）。</p>

<p>操作符有些是只有加减法，有些则四则运算都有，这个会让难度上一个层次。</p>

<p>最难搞的就是括号，如果有括号的话，会让难度直接上一个数量级。</p>

<p>绝大多数场景都要用到栈，对于复杂的运算（四则）和有括号，因为涉及优先级和嵌套，所以要用到双栈，一个栈存操作符，一个栈存操作数。</p>

<h2>要点分析</h2>

<p>第一步就是拆解字串，把其分解成为<strong>操作符，符号</strong>和<strong>操作数</strong>。在拆解的时候最重要的就是当遇到某一个类型分类时，要把它当成一个整体全都解析出来，直到遇到不同类别的字符。比如说『-234+5』这样一个字串，第一个是符号，它不能单独存在，必须与其后的数字组合起来，这一坨直到加号『+』为止，是一个整体操作数<em>-234</em>。</p>

<p><strong>符号</strong>一般只出现在字符串的开头，具体的就是整个字串的第1个字符，以及等号右边的第1个字符（如果有等号的话）。</p>

<h2>典型问题</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/solve-the-equation/">640. 求解方程</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/solve-the-equation/solution/640-qiu-jie-fang-cheng-by-alexhilton-39m8/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/fraction-addition-and-subtraction/">592. 分数加减运算</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/fraction-addition-and-subtraction/solution/by-alexhilton-u0c1/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://blog.csdn.net/dl962454/article/details/121533289">表达式求值、后缀表达式、计算器系列</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/115807632">LeetCode 题解 | 224.基本计算器</a></li>
<li><a href="https://blog.csdn.net/qq_44831907/article/details/115434570">leetcode 227 基本计算器：表达式通用解题模板</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1804025">(Leetcode 2021 刷题计划) 150. 逆波兰表达式求值</a></li>
<li><a href="https://segmentfault.com/a/1190000005659574">[Leetcode] Basic Calculator/Evaluate Expression 设计计算器/中缀表达式求值</a></li>
<li><a href="https://github.com/SharingSource/LogicStack-LeetCode/wiki/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97">表达式计算</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247492602&amp;idx=1&amp;sn=135fd5b530189f13e0395414a6b47893&amp;chksm=fd9f48e5cae8c1f3ee1fc83f3410ebb9b8fb24209bf6f08640ba3ddaf4db27d338b9d3fd3cbe&amp;mpshare=1&amp;scene=24&amp;srcid=0819WR88Erc5IACHu22b7lmp&amp;sharer_sharetime=1660874768212&amp;sharer_shareid=ce2ca9c02939976c423003e993c5a62c#rd">双栈 : 表达式计算问题的通用解法</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247492653&amp;idx=1&amp;sn=53db69e634307b64b5d8d1845fb7baf5&amp;chksm=fd9f4f32cae8c624a8a2eef50a6917bdd834edc9e1bb18e16014062346506b2a3df3d24adb0e&amp;mpshare=1&amp;scene=24&amp;srcid=08190KPPnjPE9sQfHNUAEBnJ&amp;sharer_sharetime=1660874752279&amp;sharer_shareid=ce2ca9c02939976c423003e993c5a62c#rd">表达式计算问题的通用解法</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[秘密武器之单调栈]]></title>
    <link href="http://toughcoder.net/blog/2022/08/15/secret-weapon-monotonic-stack/"/>
    <updated>2022-08-15T23:50:29+08:00</updated>
    <id>http://toughcoder.net/blog/2022/08/15/secret-weapon-monotonic-stack</id>
    <content type="html"><![CDATA[<p>除了在树的遍历，DFS等常规场景使用栈(Stack)以外，针对某些特定的问题，还能以栈为主要手段进行非常巧妙的解题，栈中数据（通常是整数）的存储以<strong>单调递增</strong>或者<strong>单调递减</strong>的形式，新的元素入栈前通常要把小于它的或者大于它的元素出栈，习惯称之为<strong>单调栈</strong>。</p>

<p><a href="http://toughcoder.net/blog/2022/08/15/secret-weapon-monotonic-stack/"><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.G8tf8vP5EZFKle0-aE0fIwHaE6?pid=ImgDet&rs=1" title="auto auto" ></a></p>

<p>问题的常规解的时间复杂度通常会达到O(n<sup>2</sup>)或者O(nlog<sup>n</sup>)，但使用单调栈可以达到O(n)，思路非常的巧妙。</p>

<!-- more -->


<h2>单调栈的特点</h2>

<p>单调栈使用的数据结构就是栈，通常存储整数，可以入栈元素的下标，也可以直接把元素入栈。一般当需要计算元素之间的跨度时，比如像求面积，或者求天数时，这需要用元素的下标来计算，所以这时把元素下标入栈更为方便；其他情况直接入栈元素就可以。</p>

<p>单调栈，有二个重要的特性，一是栈，也要<strong>后进先出（FILO）</strong>，二是单调性，栈中的元素要么是递增的要么是递 减的。具体就单调性而言分为两类：</p>

<ol>
<li>单调<strong>递增栈:</strong>元素在栈中从栈底到栈顶是由大到小的，由此，<strong>出栈的序列</strong>是由小到大的，是递增的</li>
<li>单调<strong>递减栈:</strong>元素在栈中从栈底到栈顶是由小到大的，由此，<strong>出栈的序列</strong>是由大到小的，是递减的</li>
</ol>


<p>为了保持单调性，在入栈的时候，需要把破坏单调性的元素出栈，直到能够保持单调性。</p>

<p>可能不同的文章对单调性定义不同，有些是以栈中的顺序为主，有些是以出栈的序列为主，但只是概念上的不同理解而已，本质上并不无差别。本文将以<strong>出栈序列</strong>来定义。</p>

<h2>单调栈的适用性及其代码流程</h2>

<p>单调栈利用<strong>后进先出</strong>和单调性能够在一个一维数组中选出一个『下一个更大元素』或者『下一个更小元素』的序列，从而实现某些问题的解。</p>

<h3>代码流程</h3>

<p>它的典型流程，以单调递增栈为例，是：</p>

<ol>
<li>遍历输入列表（或者数组）</li>
<li>如果栈为空，或者当前元素（以下标形式或者元素）大于栈顶，直接入栈</li>
<li>否则，进行<strong>清栈：</strong>依据题目中<strong>某些约束条件</strong>，需要把栈中小于当前元素的元素出栈，然后把当前元素入栈</li>
<li>遍历完后，可能还需要清栈，栈中剩余的肯定 是不直接满足某些约束条件的，通常是对栈中元素直接以某些边界条件去计算结果</li>
</ol>


<p>另外，在实战中，还可以使用『哨兵』来简化逻辑，通常作为栈底，比如把-1（具体的数值需要依题而定）放在栈底，那么判断栈是否为空时就需要检查 是否忆到了哨兵元素。</p>

<h3>适用性</h3>

<p>单调栈应用范围不算大，它仅适合解决<strong>NEG问题</strong>，即Next Greater Element，下一个<strong>更大</strong>元素。注意，这里也可以更小的元素，也可以是前一个。</p>

<p>以一个简单的例子来说明，比如，有一个数组<strong>nums = [2, 1, 2, 4, 3]</strong>，返回一个等长数组，每个元素是当前索引在原数组中的『下一个更大』元素，如果没有就存-1。比如输入<strong>[2,1,2,4,3]</strong>就返回<strong>[4,2,4,-1,-1]</strong>。</p>

<p>这是典型的<strong>NEG问题</strong>。暴力解法容易想到，二次遍历就能找到，但会达到O(n<sup>2</sup>)的复杂度。</p>

<p>单调栈就能派上用场：整体思路就是还没有找到『更大』元素的元素先入栈，<strong>约束条件</strong>就是『更大的元素』，<strong>清栈</strong>就是把栈中小于当前元素的元素都弹出，因为它们已找到了『更大』元素，具体的：</p>

<ol>
<li>从前往后遍历，因为需要修改对应索引的值，所以栈中存索引比较方便</li>
<li>栈为空，或者当前元素[i]小于栈顶，就直接入栈</li>
<li>否则，清栈，把栈中小于当前元素出栈，因为它们忆找到『更大』元素了，就是当前元素[i]</li>
<li>遍历完成后，栈中可能有剩余元素，需要清栈，这些元素都没有找到『更大』元素的，直接存-1即可</li>
</ol>


<p>明显，这里用的是单调递增栈。只遍历一次，所有元素最多只入栈一次，所以时间复杂度是O(n)。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span><span class="o">[]</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
</span><span class='line'><span class="n">Stack</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">stack</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="o">&lt;&gt;();</span>
</span><span class='line'><span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">||</span> <span class="n">nums</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">stack</span><span class="o">.</span><span class="na">push</span><span class="o">(</span><span class="n">i</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// 清栈</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">peek</span><span class="o">()]</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>             <span class="n">result</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="c1">// 清栈</span>
</span><span class='line'><span class="k">while</span> <span class="o">(!</span><span class="n">stack</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">result</span><span class="o">[</span><span class="n">stack</span><span class="o">.</span><span class="na">pop</span><span class="o">()]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>同一套路</h3>

<p>NEG是一类问题，用单调栈可解，但问题可能会被包装成各种问题，需要能够脱去外衣和内衣看到问题的本质。</p>

<p>比如，输入的是每日温度，找温度更高的一天，或者以身高为背景的问题，如只能看到比你矮的人的发型，如只能与比你矮的人交朋友等等。</p>

<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/next-greater-element-i/solution/by-alexhilton-z1m1/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/next-greater-element-ii/">503. 下一个更大元素 II</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/next-greater-element-ii/solution/by-alexhilton-m4xs/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/daily-temperatures/solution/by-alexhilton-vy0r/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/largest-rectangle-in-histogram">84. 柱状图中最大的矩形</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/solution/84-zhu-zhuang-tu-zhong-zui-da-de-ju-xing-nk72/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximal-rectangle">85. 最大矩形</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximal-rectangle/solution/by-alexhilton-zwd6/">题解</a>  </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/">768. 最多能完成排序的块 II</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/solution/768-zui-duo-neng-wan-cheng-pai-xu-de-kua-pp4l/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://liuzhenglaichn.gitbook.io/algorithm/monotonic-stack">Monotonic Stack</a></li>
<li><a href="https://x-czh.github.io/Algorithms-LeetCode/Topics/Monotonic-Stack-&amp;-Queue.html">Monotonic Stack &amp; Queue</a></li>
<li><a href="https://blog.csdn.net/lucky52529/article/details/89155694">[数据结构]——单调栈</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/346536592">算法学习笔记(67): 单调栈</a></li>
<li><a href="https://oi-wiki.org/ds/monotonous-stack/">单调栈</a></li>
<li><a href="https://www.cnblogs.com/liang24/p/14200734.html">单调栈技巧总结</a></li>
<li><a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88.md">单调栈</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26465701">刷题笔记6（浅谈单调栈）</a></li>
<li><a href="https://www.jianshu.com/p/6bbd3653a57f">单调栈和应用实践</a></li>
<li><a href="https://blog.csdn.net/nirendao/article/details/119065757">单调栈(monotonic stack)揭秘</a></li>
<li><a href="https://blog.csdn.net/Hanx09/article/details/108434955">单调栈与单调队列算法详解及LeetCode经典题目（Python）</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MarkDown之数学公式]]></title>
    <link href="http://toughcoder.net/blog/2022/07/13/math-symbols-in-markdown-made-easy/"/>
    <updated>2022-07-13T21:35:58+08:00</updated>
    <id>http://toughcoder.net/blog/2022/07/13/math-symbols-in-markdown-made-easy</id>
    <content type="html"><![CDATA[<p>有时候文档里面会涉及一些数学公式，用常规的格式都难以得到满意的效果。</p>

<p>数学公式方面<a href="https://www.latex-project.org/">Latex</a>是最为专业的，Markdown也是支持Latex的。</p>

<p><a href="http://toughcoder.net/blog/2022/07/13/math-symbols-in-markdown-made-easy/"><img src="https://img95.699pic.com/photo/40176/0613.gif_wh860.gif" title="auto auto" ></a></p>

<!-- more -->


<h2>在公式中加入空格</h2>

<p>可以参考 这几个文章:</p>

<ol>
<li><a href="https://www.overleaf.com/learn/latex/Spacing_in_math_mode">Spacing in math mode</a></li>
<li><a href="https://latex-tutorial.com/latex-space/">LaTeX Space Guide: vertical, horizontal, text and math modes, and much more!</a></li>
<li><a href="https://www.overleaf.com/learn/latex/Articles/How_to_change_paragraph_spacing_in_LaTeX">How to change paragraph spacing in LaTeX</a></li>
</ol>


<h2>各种Markdown编辑器的支持情况</h2>

<h3>LeetCode题解</h3>

<p>它是直接支持的，用\$\$来标识就好了。用双\$\$\$\$来居中。</p>

<p>比如$\vec{AB}$就是一个向量。</p>

<h3>MacDown编辑器</h3>

<p>不支持Latex，但支持<a href="https://en.wikipedia.org/wiki/TeX">TeX</a>和<a href="https://en.wikipedia.org/wiki/MathML">MathML</a></p>

<p>A_s<sup>T</sup> = B</p>

<h3>Octopress</h3>

<p>Latex和MathML貌似都不支持。如果要支持，可以引入三方插件。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.jianshu.com/p/4460692eece4">Markdown 数学公式语法</a></li>
<li><a href="https://blog.csdn.net/jyfu2_12/article/details/79207643">markdown最全数学公式速查</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/158156773">一篇文章教会你如何在Markdown文档中插入数学公式</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/441454622">MarkDown数学公式</a></li>
<li><a href="https://www.latexlive.com/home">LaTeX公式编辑器ver1.6.</a></li>
<li><a href="https://www.runoob.com/markdown/md-tutorial.html">Markdown 教程</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
