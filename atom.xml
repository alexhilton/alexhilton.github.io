<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[稀有猿诉]]></title>
  <link href="http://toughcoder.net/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2024-09-24T22:53:45+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[轻松解决Jetpack Compose中的一些痛点问题]]></title>
    <link href="http://toughcoder.net/blog/2024/09/21/compose-best-practices/"/>
    <updated>2024-09-21T10:59:35+08:00</updated>
    <id>http://toughcoder.net/blog/2024/09/21/compose-best-practices</id>
    <content type="html"><![CDATA[<p>暑去秋来，金桂飘香，不知不觉中我们已经练完了<a href="https://juejin.cn/column/7367555191338467337">『降Compose十八掌』</a>，相信通过这一系列文章能够对Jetpack Compose有足够的理解，并能在实际项目中进行运用。今天将继续Compose之旅，总结一下Compose使用过程中经常会遇到的一些痛点问题，并学会如何优雅的解决这些问题。</p>

<p><a href="http://toughcoder.net/blog/2024/09/21/compose-best-practices/"><img src="https://innovationm.co/wp-content/uploads/2021/05/Jetpack-compose.png" title="auto auto" ></a></p>

<!-- more -->


<h2>定义slot时要注明布局作用域</h2>

<p>先来看一个比较常规的问题，Compose开发过程中，非常鼓励开发者把可以复用的部分抽象成为一个函数，然后接收一个尾部lambda作为参数进行差异化的定制。这种范式叫做<a href="https://developer.android.com/develop/ui/compose/layouts/basics#slot-based-layouts">slot模式</a>，slot模式的好处在于能够大大加强代码复用，开发者在构建UI的时候，像搭积木那样把一个一个的slot叠在一起。Compose自己的API中都大量的采用了这种模式。</p>

<p>为了让slot更加的通用，我们需要<strong>明确传入的lambda与slot之间的约定</strong>，这就要求我们对lamdba的类型进行严格的限制。</p>

<p>首先要添加注解&#64;Composable，这个是显而易见的，因为slot是为了绘制一些自定义UI元素而准备的，所以肯定是要加上&#64;Composable，否则在lambda中无法写UI，因为非Composable不能调用Compose的方法。</p>

<p>另外，不是那么明显的就是这个lamdba的类型，要指定<a href="https://kotlinlang.org/docs/lambdas.html#function-literals-with-receiver">其Receiver</a>，以限定它所在的布局。比如说slot是用在一个Column里面的，那么要给lamdba指定ColumnScope作为receiver，这样在实现lambada的时候就知道是作为Column的一部分，并且可以使用Column布局的特有相关参数，如左右居中和垂直排列：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="n">MyLayout</span><span class="p">(</span>
</span><span class='line'>     <span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span><span class="p">,</span>
</span><span class='line'>     <span class="n">content</span><span class="p">:</span> <span class="n">@Composable</span> <span class="n">ColumnScope</span><span class="p">.()-&gt;</span><span class="n">Unit</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="n">Column</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>          <span class="c1">// 共用的一部分</span>
</span><span class='line'>
</span><span class='line'>          <span class="n">content</span><span class="p">()</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 调用的地方</span>
</span><span class='line'><span class="n">MyLayout</span> <span class="p">{</span> <span class="c1">// this = ColumnScope</span>
</span><span class='line'>     <span class="c1">// 隐式this指针指向一个ColumnScope对象，就像在一个Column中一样</span>
</span><span class='line'>     <span class="c1">// 定制的部分</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>UI元素很多都会涉及到居中，对齐的调整，以及内部元素的排列，而对齐和排列又会明确的受到所在父布局的影响，比如说Box与Column的对齐和排列方式就是不同的。所以在使用slot时一定要明确 标注它所在的布局，以让调用者能够明确地知道lambda所在的布局作用域。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://chrisbanes.me/posts/slotting-in-with-compose-ui/">Slotting in with Compose UI</a></li>
<li><a href="https://www.valueof.io/blog/compose-slot-api-example-composable-content-lambda">Practical Compose Slot API example</a></li>
<li><a href="https://proandroiddev.com/designing-slot-apis-in-jetpack-compose-4a981ddbc776">Designing Slot APIs in Jetpack Compose</a></li>
<li><a href="https://tech.pic-collage.com/%E5%88%9D%E6%8E%A2-jetpack-compose-slot-api-8d3f153f77e3">初探 Jetpack Compose — Slot API</a></li>
</ul>


<h2>如何在ViewModel中使用平台相关的资源</h2>

<p>我们在<a href="https://juejin.cn/post/7411812014047461387">降Compose十八掌之『神龙摆尾』| Architecture</a>中讨论过，ViewModel作为Domain层，目的是把逻辑尽可能的从UI层中抽出来，让UI尽可能的只做UI渲染。ViewModel也要做到平台独立，这样才方便移植和测试。ViewModel中吐出来的数据要是加工过的可以直接方便地在UI层展示的数据，如字符串或者图片。</p>

<p>但有一个问题，资源文件如何管理都是平台强相关的。对于要展示给用户的文案，也不可能直接把字符串传给UI，因为UI语言都要能够本地化以适应不同的国家和地区，当然了如果说不需要考虑多语言的问题，比如我的应用只给某一个语言使用，那当然也可以直接把处理好的字符串当作UiState传给UI层。</p>

<p>最为理想的解决方案就是ViewModel层定义一些<strong>状态码</strong>，对应着不同的提示语言，由UI负责一一对应的，把状态码再转成字符串。对于其他的资源也可以采用类似方式处理。这是从ViewModel输出到UI层的情况。</p>

<p>还会反过来，对于需要从UI层输入到ViewModel的资源，也是要<strong>去除平台的相关性</strong>，比如转成ViewModel中定义的状态码，或者转成原始数据类型String，或者转成平台无关的输入输出流等等。</p>

<h3>字符串资源</h3>

<p>对于Android平台来说，可以用一个简单的方式来解决字符串资源问题，因为资源的引用是一个整数，所以可以直接把资源的ID当作字段传给UI，Compose拿到后直接用函数stringResource取出来就可以了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">data</span> <span class="k">class</span> <span class="nc">UiState</span><span class="p">(</span>
</span><span class='line'>     <span class="k">val</span> <span class="py">loading</span><span class="p">:</span> <span class="n">Boolean</span> <span class="p">=</span> <span class="k">false</span><span class="p">,</span>
</span><span class='line'>     <span class="n">@StringRes</span> <span class="k">val</span> <span class="py">errorMsg</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">HomeViewModel</span> <span class="p">{</span>
</span><span class='line'>     <span class="k">val</span> <span class="py">timeout</span> <span class="p">=</span> <span class="n">UiState</span><span class="p">(</span><span class="k">false</span><span class="p">,</span> <span class="n">R</span><span class="p">.</span><span class="n">string</span><span class="p">.</span><span class="n">error_message_timeout</span><span class="p">)</span>
</span><span class='line'>     <span class="n">_state</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 在Compose中</span>
</span><span class='line'><span class="n">HomeScreen</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Text</span><span class="p">(</span><span class="n">stringResource</span><span class="p">(</span><span class="n">uiState</span><span class="p">.</span><span class="n">errorMsg</span><span class="p">))</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>虽然说这并不太通用，因为换成其他平台时可能不是用资源ID来获取资源，但转成状态码的方式也会很容易，所以问题不大。</p>

<p>如果是输入的话，在Compose中直接读取资源变成String传给ViewModel就好了。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://stackoverflow.com/questions/47628646/how-should-i-get-resourcesr-string-in-viewmodel-in-android-mvvm-and-databindi">How should I get Resources(R.string) in viewModel in Android (MVVM and databinding)</a></li>
<li><a href="https://medium.com/@margin555/using-string-resources-in-a-viewmodel-e334611b73da">Using String Resources in a ViewModel</a></li>
</ul>


<h3>图片资源</h3>

<p>图片资源一般来说都是UI自己指定，但有些时候可能会有逻辑，比如一些需要经过运算才能得到的复杂的状态，其代表的Icon，由ViewModel来直接指定要好一些。图片资源也可以直接使用资源ID，然后在Compose中使用painterResource来获取：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">data</span> <span class="k">class</span> <span class="nc">UiState</span><span class="p">(</span>
</span><span class='line'>     <span class="n">@DrawableRes</span> <span class="k">val</span> <span class="py">icon</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// in ViewModel</span>
</span><span class='line'><span class="k">val</span> <span class="py">state</span> <span class="p">=</span> <span class="n">UiState</span><span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">drawable</span><span class="p">.</span><span class="n">ic_windy</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// in Compose</span>
</span><span class='line'><span class="n">Icon</span><span class="p">(</span><span class="n">painterResource</span><span class="p">(</span><span class="n">uiState</span><span class="p">.</span><span class="n">icon</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果是输入的话，可以在Compose中把图片资源转成输入流传给ViewModel去处理。</p>

<h3>其他资源</h3>

<p>其他资源如dimen或者color，也可以如法炮制。</p>

<p>输入的话，对于普通的资源像字符串资源，dimen或者color等读出来转成基础数据类型String，Int或者Array传给ViewModel就好。而像比较麻烦的资源，如Assets中的资源，就转成输入流传给ViewModel处理。</p>

<h2>如何在常规函数中调用Composables</h2>

<p>在Compose的开发过程中最为令人不爽的地方在于Compose 的API，只能在被注解&#64;Composable标注的函数中调用，其他地方是无法调用的。一般来说，这个问题也不大，因为Compose的入口是肯定是一个composable啊，一坨坨的composables的调用最终<a href="https://juejin.cn/post/7407643004490956810">会生成UI树</a>。</p>

<p>但有些地方却跑出了Composable之外，比如像很多UI元素的事件响应，比如<a href="https://developer.android.com/develop/ui/compose/components/button">Button</a>，它的事件响应onClick接收的就是一个普通的lambda：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">MainContent</span><span class="p">(</span>
</span><span class='line'>    <span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">,</span>
</span><span class='line'>    <span class="n">serviceOn</span><span class="p">:</span> <span class="n">Boolean</span><span class="p">,</span>
</span><span class='line'>    <span class="n">context</span><span class="p">:</span> <span class="n">Context</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Column</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Button</span><span class="p">(</span>
</span><span class='line'>            <span class="n">onClick</span> <span class="p">=</span> <span class="p">{</span> <span class="n">AccessibilityHelper</span><span class="p">.</span><span class="n">gotoChronosSettings</span><span class="p">(</span><span class="n">context</span><span class="p">)</span> <span class="p">},</span>
</span><span class='line'>        <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">Text</span><span class="p">(</span><span class="n">stringResource</span><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">serviceOn</span><span class="p">)</span> <span class="n">R</span><span class="p">.</span><span class="n">string</span><span class="p">.</span><span class="n">turn_off_service</span> <span class="k">else</span> <span class="n">R</span><span class="p">.</span><span class="n">string</span><span class="p">.</span><span class="n">enable_service</span><span class="p">))</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在Button的onClick里面可以执行一些普通函数调用，比如调用ViewModel等，但是不可以调用Compose的API，因为它是非Composable的，已经跑到了Composable之外。有些场景，这会带来比较大的不方便。</p>

<p>响应点击按扭的方式可能有很多，有些是执行一些普通函数调用，但有些时候也会修改UI，大部分时候也会创建新UI，比如说会弹出对话框。对于修改UI，可以直接通过修改状态的值，状态的值发生改变会触发重组，进而UI状态就会改变（通过读取状态的值显示 不同的UI）。</p>

<p>对话框<a href="https://developer.android.com/develop/ui/compose/components/dialog">Dialog</a>也是一个Composable，它只能被Composable调用，无法在Button的onClick中直接调用Dialog。解决的办法依旧是借助状态，用一个Boolean型值的状态，当其为true时显示Dialog，在Button的onClick中更改此状态为true，状态变了触发重组，在重组时值为true就会显示Dialog了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">InputSettingsEntry</span><span class="p">(</span>
</span><span class='line'>    <span class="n">label</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span>
</span><span class='line'>    <span class="n">description</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span>
</span><span class='line'>    <span class="n">value</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span>
</span><span class='line'>    <span class="n">onChange</span><span class="p">:</span> <span class="p">(</span><span class="n">String</span><span class="p">)-&gt;</span><span class="n">Unit</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">showing</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="k">false</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>     <span class="n">Button</span><span class="p">(</span><span class="n">onClick</span> <span class="p">=</span> <span class="p">{</span> <span class="n">showing</span> <span class="p">=</span> <span class="k">true</span> <span class="p">})</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">Text</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">showing</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">InputDialog</span><span class="p">(</span>
</span><span class='line'>            <span class="n">title</span> <span class="p">=</span> <span class="n">label</span><span class="p">,</span>
</span><span class='line'>            <span class="n">message</span> <span class="p">=</span> <span class="n">description</span><span class="p">,</span>
</span><span class='line'>            <span class="n">value</span> <span class="p">=</span> <span class="n">value</span><span class="p">,</span>
</span><span class='line'>            <span class="n">onDismiss</span> <span class="p">=</span> <span class="p">{</span> <span class="n">showing</span> <span class="p">=</span> <span class="k">false</span> <span class="p">},</span>
</span><span class='line'>            <span class="n">onConfirm</span> <span class="p">=</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">onChange</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
</span><span class='line'>                <span class="n">showing</span> <span class="p">=</span> <span class="k">false</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外，其实Dialog本身的一些事件响应也都是非Composable的，都是通过状态来控制Dialog的显示与否。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://stackoverflow.com/questions/66952179/not-able-to-show-alertdialog-from-onclick-in-jetpack-compose">Not able to show AlertDialog from onClick in Jetpack Compose</a></li>
<li><a href="https://medium.com/@esthcarelle/alert-dialog-with-jetpack-compose-a-step-by-step-guide-04dc3e9dfc1d">Alert Dialog with Jetpack compose: A Step-by-Step Guide</a></li>
</ul>


<h2>总结</h2>

<p>Jetpack Compose博大精深，看似简单就是一坨函数，但在实际项目使用中会遇到各种细节问题。遇到问题也不用慌，用我们的<a href="https://juejin.cn/column/7367555191338467337">『降Compose十八掌』</a>都能解决，没事就多读一读，理解了Compose的思想与原理，做到心中无剑，很多问题都能迎刃而解。</p>

<h2>References</h2>

<ul>
<li><a href="https://climbtheladder.com/10-android-jetpack-compose-best-practices/">10 Android Jetpack Compose Best Practices</a></li>
<li><a href="https://getstream.io/blog/jetpack-compose-guidelines/">6 Jetpack Compose Best Practices for Optimizing Your App Performance</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sub Array and Seb Sequences Made Easy]]></title>
    <link href="http://toughcoder.net/blog/2024/09/18/sub-array-and-seb-sequences-made-easy/"/>
    <updated>2024-09-18T22:11:15+08:00</updated>
    <id>http://toughcoder.net/blog/2024/09/18/sub-array-and-seb-sequences-made-easy</id>
    <content type="html"><![CDATA[<p>子数组和子序列，特别是在一个区间内，或者一个窗口内的子数组个数或者子序列个数问题是非常常见的一类题目，与其他算法结合在一起，求子数组或者子序列数量是非常常见的题目，今天就来总结 一下。</p>

<p><a href="http://toughcoder.net/blog/2024/09/18/sub-array-and-seb-sequences-made-easy/"><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/20220620163127/subarray.png" title="auto auto" ></a></p>

<!-- more -->


<h2>如何统计区间内子数组数量</h2>

<p>子数组的数量只与区间长度有关系，对于一个区间长度为n的数组，其非空子数组数量为n * (n+1)/2。</p>

<p>具体计算过程，可以用子数组长度来递推：</p>

<p>1). 长度为1，这时子数组数量为n个
2). 长度为2时，这时子数组数量为n - 1个
3). 长度为n - 1时，这时子数组数量为2
4). 长度为n时，这时子数组数量只有一个1，为1</p>

<p>可以发现， 这是一个等差数列，求和之后就是n*(n+1)/2。</p>

<h2>如何统计区间内子序列数量</h2>

<p>子序列是子数组的特殊形式，它不要求保留在原数组中的顺序。一个长度为k的区间内所有子序列的个数就是一个幂集，每个元素都有「选」和「不选」，因此这个区间所有子序列个数是2<sup>k</sup>个，包括空子序列，如果要求非空，那就再减去一个1。</p>

<p>具体计算过程，需要用到组合数学：</p>

<p>1). 一个都不选C(n, 0) = 1
2). 一个一个的选，C(n, 1) = n
2). 两个选，C(n,2)
3). n - 1个，C(n, n - 1)
4). n个，C(n, n) = 1</p>

<p>求和就是2<sup>n</sup>，如果非空就是2<sup>n</sup> - 1。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/description/">1498. 满足条件的子序列数目</a> </td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>References</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/array-subarray-subsequence-and-subset/">Subarrays, Subsequences, and Subsets in Array</a></li>
<li><a href="https://www.geeksforgeeks.org/count-distinct-subsequences/">Count Distinct Subsequences</a></li>
<li><a href="https://www.geeksforgeeks.org/count-of-subarrays-in-an-array-containing-numbers-from-1-to-the-length-of-subarray/">Count of Subarrays in an array containing numbers from 1 to the length of subarray</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『神龙摆尾』| Architecture]]></title>
    <link href="http://toughcoder.net/blog/2024/09/12/architecture-in-compose/"/>
    <updated>2024-09-12T22:27:58+08:00</updated>
    <id>http://toughcoder.net/blog/2024/09/12/architecture-in-compose</id>
    <content type="html"><![CDATA[<p>通过前面的<a href="https://juejin.cn/column/7367555191338467337">一系列文章</a>，我们已经掌握了足够的Jetpack Compose的开发基础。为了更好的在实际项目中使用Compose，我们还需要了解一下现代应用开发的架构原则，以及使用Jetpack Compose时如何更好的遵循这些原则。这篇文章将聚焦于架构原则这一话题，进行一些探讨和总结。</p>

<p><a href="http://toughcoder.net/blog/2024/09/12/architecture-in-compose/"><img src="https://www.sixt.tech/assets/jetpack-compose/jetpack-compose.png" title="auto auto" ></a></p>

<!-- more -->


<h2>现代Android应用开发的架构方式</h2>

<p>Jetpack Compose是一个声明式的UI框架，用它来开发应用程序，因此根本上仍是在做应用程序开发，所以需要遵循现代应用程序的架构原则。</p>

<p>一提到架构自然会想到Bob大叔的<a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">The Clean Architecture</a>，这里面的最主要的核心思想就是分层，把不同的概念按照抽象的层次进行分离，层与层之间有特定的依赖规则，也即只能从控制层往业务逻辑依赖。分层最大的益处就是方便移植和替换，降低维护成本，这也是架构的意义所在。</p>

<p><img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg" alt="图1. The Clean Architecture" /></p>

<p>对于移动应用开发，谷歌也给出比较实用的<a href="https://developer.android.com/topic/architecture#common-principles">现代应用架构原则</a>，其中有四个核心原则：</p>

<ol>
<li>远离系统组件，系统组件（Activity，Service和Fragment等）仅能作为一个入口和必要的依赖对象，以及协调和连接不同的对象。深层次的原因是系统组件实例不可控，系统随时会重新创建实例，所以应该把对系统组件的依赖降到最低；</li>
<li>由数据来驱动UI，且数据最好是不可变的（Immutable data）。这个原则要求把逻辑尽可能的放在数据层而非UI层，UI层就是展示数据层，处理用户事件和UI自己的逻辑，但不应该做的业务逻辑处理。比如说新闻类应用，数据层把一坨列表传过来，UI就展示，如果列表为空，那显示加载错误，用户点击刷新就让数据层刷新数据。但不应该对列表中的数据做更新或者更改，比如说把不同的列表融合为一个，这些都是业务逻辑，应该由数据层来做。这样的好处是能让UI层尽可能的简单，方便移植，方便测试。而且这符合响应式的数据流，可以使用响应式编程范式（MVVM或者MVI）；</li>
<li>单一数据源（Single Source Of Truth），也就是说任何数据都应该只由它的生产者来修改，其他模块只是使用不能修改，因此每一层返回的数据都应该是不可修改类型（Immutable objects）;</li>
<li>单向数据流动（Unidirectional Data Flow），UI层展示数据，获得用户事件，调用业务逻辑层处理事件，业务逻辑层再去数据层请求新的数据，新的数据再来驱动刷新UI，而不可以业务逻辑层修改数据后一边去刷新UI，一边再去让数据层修改数据，这会导致难以调试的bug。</li>
</ol>


<p><img src="https://developer.android.com/static/topic/libraries/architecture/images/mad-arch-overview.png" alt="图2. 现代应用典型架构" /></p>

<p>下面我们围绕Jetpack Compose来深入探讨一下如何把这些架构原则落到实处。</p>

<h2>使用Jetpack Compose落实架构原则</h2>

<p>Jetpack Compose是声明式UI框架，所以它只能出现在UI层，用UI元素展示数据， 以及获取用户事件。其余的部分，如业务逻辑层（ViewModels）和数据层（Models and Data）都与Compose没有关系，也不应该受到Compose的影响。这就是架构分层带来的好处，不同层之间通过约定 的接口进行协作，每一层都可以用不同的技术栈去实现，不会对其他层造成影响。</p>

<p><img src="https://developer.android.com/static/topic/libraries/architecture/images/mad-arch-overview-ui.png" alt="图3. 应用架构中的UI层的角色" /></p>

<h3>典型的项目结构</h3>

<p>按照架构原则，一个典型的项目模块结构应该是酱紫的：</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/project_org.png" alt="图4. 典型项目模块结构" /></p>

<p>Activity（对应着Activity实例）和AndroidApp（对应着Application实例）是应用程序的入口，可能需要在里面做一些必要的初始化工作，比如有些三方的库可能需要在Application#onCreate中去做初始化工作。ui package对应着UI层，负责UI的展示；package model对应着Model层，里面定义着供UI层使用的数据类型，以及获取 这些数据的接口；package data对应着数据层（data layer），实现着model中的接口定义。当然也可以把model与data合并成一个package，不过，单独把数据的定义和数据层的接口拿出来放在一个包里，会更清晰一些，因为UI层只需关心有哪些接口可以获得什么数据，它只需要知道model就够了。</p>

<p>Jetpack Compose的入口应该用一个名字为App的函数，在这里做初始化工作，比如创建数据层的实例，进行弹窗，创建导航等等。此处作为一个桥接，用以把Android的组件与Compose连接起来，创建必要的实例并把各实例协调起来。当然也可以直接把这些事情放入Activity中，但独立出来更方便测试和移植，让系统组件变得更为简单。Activity直接调用App即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">MainActivity</span> <span class="p">:</span> <span class="n">AppCompatActivity</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="n">Bundle</span><span class="p">?)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">super</span><span class="p">.</span><span class="n">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">)</span>
</span><span class='line'>        <span class="n">setContent</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">AeolusApp</span><span class="p">(</span><span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxWidth</span><span class="p">())</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">AeolusApp</span><span class="p">(</span>
</span><span class='line'>    <span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">AeolusTheme</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// A surface container using the &#39;background&#39; color from the theme</span>
</span><span class='line'>        <span class="n">Surface</span><span class="p">(</span>
</span><span class='line'>            <span class="n">modifier</span> <span class="p">=</span> <span class="n">modifier</span><span class="p">,</span>
</span><span class='line'>            <span class="n">color</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">colorScheme</span><span class="p">.</span><span class="n">background</span>
</span><span class='line'>        <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">CurrentLocationPermission</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">val</span> <span class="py">dataContainer</span> <span class="p">=</span> <span class="n">DataContainerImpl</span><span class="p">(</span><span class="n">LocalContext</span><span class="p">.</span><span class="n">current</span><span class="p">)</span>
</span><span class='line'>                <span class="n">AeolusNavGraph</span><span class="p">(</span><span class="n">appContainer</span> <span class="p">=</span> <span class="n">dataContainer</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>创建导航</h3>

<p>导航是把所有的UI页面组织在一起形成一个逻辑清晰的交互整体，可以参照之前的文章<a href="https://juejin.cn/post/7398728505872908315">降Compose十八掌之『密云不雨』| Navigation</a>来创建导航。</p>

<p>需要注意的就是页面应该命名为Screen，其ViewModel应该作为参数传递给Screen，Screen和ViewModel的实例创建都在导航中来完成。</p>

<h3>ViewModel应该保持独立</h3>

<p>ViewModel作为UI层与数据层的中间层而存在，目的是让UI层专注于数据展示。为了更好的可移植性，ViewModel不应该有平台相关的依赖，比如<a href="https://juejin.cn/post/7409869765177147430">平台的生命周期</a>或者Context，它只应该依赖model层。并且为了方便依赖注入，应该把Model层的数据接口对象（通常是Repository）作为参数传递给ViewModel：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">FavoritesViewModel</span><span class="p">(</span>
</span><span class='line'>    <span class="k">private</span> <span class="k">val</span> <span class="py">locationRepo</span><span class="p">:</span> <span class="n">LocationRepository</span><span class="p">,</span>
</span><span class='line'>    <span class="k">private</span> <span class="k">val</span> <span class="py">weatherRepo</span><span class="p">:</span> <span class="n">WeatherRepository</span>
</span><span class='line'><span class="p">)</span> <span class="p">:</span> <span class="n">ViewModel</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>具体的Repository对象可以在导航创建ViewModel时创建，或者用依赖注入框架（如Hilt）来注入实例。</p>

<h3>并发原则</h3>

<p>现代的应用肯定都会用并发，无论是协程还是Flow，为了能让并发更加的结构化和可控，应该遵循以下原则：</p>

<ol>
<li>Model层的方法都应该是suspend，对于所有Model层公开出来的方法都应该用suspend来修饰。</li>
<li>Repository（即Data层）的每个方法的实现都要指定明确的Dispatcher，最好接收一个Dispatcher作为构造参数，以方便进行注入或者测试。</li>
<li>ViewModel要把所有对Model的方法调用包裹在协程作用域viewModelScope中。</li>
</ol>


<h3>层与层之间的交互要定义接口</h3>

<p>比如Model层提供给ViewModel的能力要定义为接口，然后在Data层中去实现这些接口。接口的最大好处是方便替换具体的实现，比如换个实现方式时，或者Mock测试时都能很方便的进行替换，甚至还可以使用动态代理在运行时进行替换。</p>

<h3>对外部的依赖要作为构造器参数传入</h3>

<p>作为构造参数传入外部依赖，而不是在内部直接创建，这样做的好处在于方便替换实例，无论是日后更换一种实现实例，还是Mock测试，都可以在不修改类本身的情况下进行实例替换。甚至可以使用依赖注入框架（如Hilt）做到让具体使用的实例可配置化。</p>

<h2>Compose与ViewModel的交互原则</h2>

<p>这部分我们具体谈一谈Compose与ViewModel在交互时的一些原则和建议。ViewModel暴露UiState给Compose展示，Compose则把事件（Event）给ViewModel去处理（可以是MVI式的把事件封装成Intent塞给ViewModel，也可以直接调用ViewModel的接口）。</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/state-unidirectional-flow.png" alt="图5. Compose与ViewModel的UDF" /></p>

<p>比如说一个典型的登录场景，其Composable和ViewModel应该像这样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">MyViewModel</span> <span class="p">:</span> <span class="n">ViewModel</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">private</span> <span class="k">val</span> <span class="py">_uiState</span> <span class="p">=</span> <span class="n">mutableStateOf</span><span class="p">&lt;</span><span class="n">UiState</span><span class="p">&gt;(</span><span class="n">UiState</span><span class="p">())</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">uiState</span><span class="p">:</span> <span class="n">State</span><span class="p">&lt;</span><span class="n">UiState</span><span class="p">&gt;</span>
</span><span class='line'>        <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="n">_uiState</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">data</span> <span class="k">class</span> <span class="nc">UiState</span><span class="p">(</span>
</span><span class='line'>    <span class="n">loading</span><span class="p">:</span> <span class="n">Boolean</span> <span class="p">=</span> <span class="k">false</span><span class="p">,</span>
</span><span class='line'>    <span class="n">signedIn</span><span class="p">:</span> <span class="n">Boolean</span> <span class="p">=</span> <span class="k">false</span><span class="p">,</span>
</span><span class='line'>    <span class="n">error</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="s">&quot;&quot;</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">MyComposable</span><span class="p">(</span><span class="n">viewModel</span><span class="p">:</span> <span class="n">MyViewModel</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">uiState</span> <span class="p">=</span> <span class="n">viewModel</span><span class="p">.</span><span class="n">uiState</span><span class="p">.</span><span class="n">collectAsStateWithLifecycle</span><span class="p">()</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">uiState</span><span class="p">.</span><span class="n">loading</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// show loading</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">uiState</span><span class="p">.</span><span class="n">signedIn</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// show signed in status</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// show uiState.error</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>一定要定义专用的UiState数据对象</h3>

<p>从ViewModel给UI的数据要封装成一个不可变的数据对象（data class）作为UiState，即使其数据与从Model处获得的数据没有变化，也应该定义并做基本转换。</p>

<p>原因就是让UI层和Model不会相互影响，假如直接把Model的数据传给UI，那假如以后Model层的数据有变动，这就会影响到UI。架构分层的目的就是要封装和隔离，每一层都应该定义自己的输出数据类型，把依赖和耦合降到最低。</p>

<h3>当数据特别多时，分成多个UiState对象</h3>

<p>如果页面较复杂，需要的字段特别多，这时应该把页面分成几个区域，同时UiState也应该分成几个不同的对象，而不是大一统的装在一个对象里面。</p>

<p>原因在于Compose会把从ViewModel处获得的UiState装在一个状态里面，从<a href="https://juejin.cn/post/7376094685495001139">前面的文章中</a>我们知道，状态是用于触发重组的，状态发生变化就会触发重组。因为数据多半部分变化的，甚至有些业务逻辑总是某几个字段在变化。因为字段都放在了一个对象中，那么即使只有一个字段变了，对于Compose来说，也是状态变化了，就要进行重组。</p>

<p>把字段按其变化的性质进行拆分，用几个UiState来表示，这样能把变化降到最低，只让真正有变化的UiState触发重组进而刷新UI。</p>

<h3>Compose中要尽可能拆解为无状态函数</h3>

<p>这里的意思是说我们应该把从ViewModel处获得的UiState拆解开来，变成具体的参数用无状态函数去展示，而不应该全都把UiState当成参数传给每一个composables。比如说对于一个新闻页面，对于标题元素就应该只接受两个String作为参数，而不应该把整个NewsUiState作为参数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">Header</span><span class="p">(</span><span class="n">title</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">subtitle</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 只有当title和subtitle发生变化时才会重组</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">Header</span><span class="p">(</span><span class="n">news</span><span class="p">:</span> <span class="n">NewsUiState</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 只要状态变了就会重组，哪怕有关的title和subtitle没有变化</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样做的目的也是为了尽可能减少重组。</p>

<h3>ViewModel塞给UI的数据要能够直接展示</h3>

<p>UI层负责数据展示，不应该有过多的逻辑，特别是不能有涉及非UI直接相关的逻辑。ViewModel存在的意义就是为了把非UI相关的业务逻辑全从UI中拿走，把UI做的尽可能薄一些，这里薄的意思是逻辑要少。背后的核心原因在于方便测试和移植，众所周知UI是与每个平台强相关的，每个平台的UI构建方式都不一样，并且UI是极难做单元测试的，依赖太多很难Mock。</p>

<p>UI层很薄，仅是数据的展示，逻辑都放在ViewModel中，但ViewModel依赖很少，没有对平台和依赖，它的依赖对象都是可以Mock的，那么ViewModel就很容易做测试，只要测试保证ViewModel没什么问题，那么就基本上可以认为UI也不会有问题，毕竟光做展示一般不会出问题。</p>

<p>这里的最重要的一点就是要保证ViewModel递给UI的数据要是经过逻辑处理后的，可以直接展示的数据。举个粟子，比如说展示时间间隔的字段，类似于『100 ms』，『10 seconds』，『2 mins 10ms』或者『1 hour 10 mins』 这种，那么就不可以直接把一个Int或者Long传给UI，让UI去换算，而是让ViewModel做换算，把结果String传给UI，UI用一个Text直接显示String。这样一来就可测试了，我们Mock几个不同的字段值给ViewModel，再检查它吐出来的UiState中的时长String字段是否符合预期，就能保证这段逻辑没有问题。对于UI可以不用测试了，一个Text显示一个String出错的可能性不大，可以忽略了。</p>

<h2>总结</h2>

<p>架构最难的地方在于它是<strong>形而上学（Metaphysics）</strong>的，不会像算法或者设计模式那样有非常明确的和具体的实施步骤，仅是有一些抽象的指导原则。在实际的项目中就要从实际的业务场景出发，使用可用的技术工具，把指导原则进行落地，要<strong>把『神似』而非『形似』</strong>作为目标。切忌生搬硬套网上一些所谓的应用架构框架，假如真的有通用的架构框架，那谷歌为啥不写在SDK里面？不同的业务，不同的规模，不同的技术栈，不同的版本策略都会影响架构的方式。比如像第一部分提到的四大原则，难道只有用MVVM或者MVI才能做到么？即使用了MVVM，你在ViewModel直接把未处理的数据丢给UI，UI中仍有大量的处理数据的if-else，ViewModel把数据改了后两头更新，这明显不符合架构原则，最后仍是维护一坨巨大的shi山难解的Bug满天飞。所以对于网上的各种架构框架看看就好，一定不能生搬硬套。</p>

<p>可以通过谷歌提供的一些非常好的<a href="https://github.com/android/architecture-samples/tree/main">案例</a>来学习架构，仔细研读这些案例的源码，以深刻理解架构指导原则的内在涵义。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/topic/architecture">Guide to app architecture</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/architecture">Architecting your Compose UI</a></li>
<li><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">The Clean Architecture</a></li>
<li><a href="https://www.geeksforgeeks.org/separation-of-concerns-soc/">Separation of Concerns (SoC)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『羝羊触蕃』| Handle Platform Lifecycles]]></title>
    <link href="http://toughcoder.net/blog/2024/09/06/compose-interact-with-platforms/"/>
    <updated>2024-09-06T22:21:49+08:00</updated>
    <id>http://toughcoder.net/blog/2024/09/06/compose-interact-with-platforms</id>
    <content type="html"><![CDATA[<p>Jetpack Compose是一个独立的声明式UI框架，它并不受限于任何操作系统平台，从框架定位的角度来讲，它是跨平台的，也应该要跨平台。但是我们的应用程序必然是为某些操作系统平台（后面简称平台Platform）构建的，也就是说要运行在某些平台上面。这就免不了要与平台进行打交道。这篇文章将以Android平台为例，学习在Compose中如何处理平台的生命周期事件。</p>

<p><a href="http://toughcoder.net/blog/2024/09/06/compose-interact-with-platforms/"><img src="https://www.ericthecoder.com/wp-content/uploads/2020/05/feature.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>感知平台生命周期事件</h2>

<p>对于移动应用程序来说，感知平台的生命周期是非常重要的，比如最为典型的场景，对于一个新闻消息类的应用来说，当首次进入页面的时候肯定 要刷新拉取最新的消息，当用户切换到另外一个应用时，比如接了个电话，或者分享，之后再回到你的应用页面，这时也应该主动刷新消息，而不是要等着用户手动的去点击刷新按扭；再比如说当使用了硬件资源（位置，Camera或者Sensors等）时，更是要当离开应用页面的时候就应该立即释放硬件，以停止对硬件资源的占用。</p>

<p>从前面的文章<a href="https://juejin.cn/post/7401358349877346338">降Compose十八掌之『损则有孚』| Lifecycle</a>中我们了解到Composable本身的生命周期与平台是无关的且非常不一致，光靠Compose自己的节奏是无法感知到在平台生命周期事件的。这就需要我们使用一些桥接工具来感知平台生命周期事件，以能让我们针对感兴趣的事件执行一些操作。</p>

<h3>生命周期事件副作用函数（LifecycleEffects）</h3>

<p>幸运的是Jetpack组件中的lifecycle已经添加了<a href="https://developer.android.com/topic/libraries/architecture/compose">对Compose的支持</a>，定义了一些<a href="https://developer.android.com/reference/kotlin/androidx/lifecycle/compose/package-summary#LifecycleEventEffect(androidx.lifecycle.Lifecycle.Event,androidx.lifecycle.LifecycleOwner,kotlin.Function0">生命周期副作用函数</a>)，在这些副作用函数中可以针对 不同的事件设置代码块，当相应的生命周期发生时就会执行这些代码块：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">LifecycleEventEffect</span><span class="p">(</span><span class="n">Lifecycle</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">ON_START</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// onStar时执行一些操作</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码就是指定要在onStart时做一些事情。需要<strong>注意</strong>的是，无法监听onDestroy（即事件Lifecycle.Event.ON_DESTROY），因为Compose的<strong>组合会在onDestroy之前就结束</strong>了。</p>

<p>除了上面的用法之外，还有更为为方便的<a href="https://developer.android.com/reference/kotlin/androidx/lifecycle/compose/package-summary#LifecycleStartEffect(kotlin.Any,androidx.lifecycle.LifecycleOwner,kotlin.Function1">LifecycleStartEffect</a>)和<a href="https://developer.android.com/reference/kotlin/androidx/lifecycle/compose/package-summary#LifecycleResumeEffect(kotlin.Any,androidx.lifecycle.LifecycleOwner,kotlin.Function1">LifecycleResumeEffect</a>)可以直接使用，它们是针对onStart/onStop和onResume/onPause两对事件的，因为生命周期中最为常用的就是这四个事件了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">LifecycleStartEffect</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// onStart中需要做的事情</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">onStopOrDispose</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// onStop需要做的事情</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">LifecycleResumeEffect</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// onResume需要做的事情</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">onPauseOrDispose</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// onPause需要做的事</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意，这两个副作用函数是针对事件对的，也就是说必须要带着后面的onStopOrDispose和onPauseOrDispose。如果仅对onStart感兴趣，而无须在onStop中做清理，那么应该直接使用LifecycleEventEffect(Lifecycle.Event.ON_START) {}（对于onResume也是同理）。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://medium.com/@nirazv/managing-lifecycles-events-on-jetpack-compose-bbecf804b43d">Managing Lifecycles Events on Jetpack Compose</a></li>
<li><a href="https://developer.android.com/topic/libraries/architecture/compose">Integrate Lifecycle with Compose</a></li>
</ul>


<h3>监听生命周期事件</h3>

<p>除了直接使用生命周期副作用函数以外，也可以用lifecycle原生的方式，直接向<a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner">LifecycleOwner</a>注册一个<a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleEventObserver">LifecycleEventObserver</a>来监听生命周期。通过Compose提供的LifeCycleOwner.current可以获得当前的LifecycleOwner，然后向其注册一个LifecycleEventObserver，当平台生命周期发生变化时，就会带着事件类型回调给监听者，监听者可以针对感兴趣的事件做操作。还需要注意的是，需要在组合结束（离开）时反注册observer，因此这里要用DisposableEffect。对于副作用函数不熟悉的同学可以去复习一下<a href="https://juejin.cn/post/7405158681078104127">降Compose十八掌之『龙战于野』| Side Effects</a>。</p>

<p>来看个简单的示例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">lifecycleOwner</span> <span class="p">=</span> <span class="n">LocalLifecycleOwner</span><span class="p">.</span><span class="n">current</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">DisposableEffect</span><span class="p">(</span><span class="n">lifecycleOwner</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">observer</span> <span class="p">=</span> <span class="n">LifecycleEventObserver</span> <span class="p">{</span> <span class="n">_</span><span class="p">,</span> <span class="n">event</span> <span class="p">-&gt;</span>
</span><span class='line'>            <span class="k">when</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">Lifecycle</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">ON_CREATE</span> <span class="p">-&gt;</span> <span class="p">{</span> <span class="cm">/* onCreate */</span> <span class="p">}</span>
</span><span class='line'>                <span class="n">Lifecycle</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">ON_START</span> <span class="p">-&gt;</span> <span class="p">{</span> <span class="cm">/* onStart */</span> <span class="p">}</span>
</span><span class='line'>                <span class="n">Lifecycle</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">ON_RESUME</span> <span class="p">-&gt;</span> <span class="p">{</span> <span class="cm">/* onResume */</span> <span class="p">}</span>
</span><span class='line'>                <span class="n">Lifecycle</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">ON_PAUSE</span> <span class="p">-&gt;</span> <span class="p">{</span> <span class="cm">/* onPause */</span> <span class="p">}</span>
</span><span class='line'>                <span class="n">Lifecycle</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">ON_STOP</span> <span class="p">-&gt;</span> <span class="p">{</span> <span class="cm">/* onStop */</span> <span class="p">}</span>
</span><span class='line'>                <span class="n">Lifecycle</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">ON_DESTROY</span> <span class="p">-&gt;</span> <span class="p">{</span> <span class="cm">/* onDestroy */</span> <span class="p">}</span>
</span><span class='line'>                <span class="n">Lifecycle</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">ON_ANY</span> <span class="p">-&gt;</span> <span class="p">{</span> <span class="cm">/* Any event */</span> <span class="p">}</span>
</span><span class='line'>                <span class="k">else</span> <span class="p">-&gt;</span> <span class="p">{}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">lifecycleOwner</span><span class="p">.</span><span class="n">lifecycle</span><span class="p">.</span><span class="n">addObserver</span><span class="p">(</span><span class="n">observer</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">onDispose</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">lifecycleOwner</span><span class="p">.</span><span class="n">lifecycle</span><span class="p">.</span><span class="n">removeObserver</span><span class="p">(</span><span class="n">observer</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样就可以监听到生命周期事件，然后针对不同的事件做相应的操作。</p>

<p>当然，如果事件不止做一件事情，或者说对事件的响应不光光是执行一些函数，可能还会有页面的修改，那么这时最好就是把事件保存为一个状态（State），更为方便：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">lifecycleOwner</span> <span class="p">=</span> <span class="n">LocalLifecycleOwner</span><span class="p">.</span><span class="n">current</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="py">lifecycleEvent</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="n">Lifecycle</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">ON_ANY</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">DisposableEffect</span><span class="p">(</span><span class="n">lifecycleOwner</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">observer</span> <span class="p">=</span> <span class="n">LifecycleEventObserver</span> <span class="p">{</span> <span class="n">_</span><span class="p">,</span> <span class="n">event</span> <span class="p">-&gt;</span>
</span><span class='line'>        <span class="n">lifecycleEvent</span> <span class="p">=</span> <span class="n">event</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">lifecycleOwner</span><span class="p">.</span><span class="n">lifecycle</span><span class="p">.</span><span class="n">addObserver</span><span class="p">(</span><span class="n">observer</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">onDispose</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">lifecycleOwner</span><span class="p">.</span><span class="n">lifecycle</span><span class="p">.</span><span class="n">removeObserver</span><span class="p">(</span><span class="n">observer</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">LaunchedEffect</span><span class="p">(</span><span class="n">lifecycleEvent</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">lifecycleEvent</span> <span class="p">==</span> <span class="n">Lifecycle</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">ON_RESUME</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">viewModel</span><span class="p">.</span><span class="n">refresh</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">Column</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">lifecycleEvent</span> <span class="p">==</span> <span class="n">Lifecycle</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">ON_RESUME</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span><span class="s">&quot;Welcome back&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>扩展阅读：</p>

<ul>
<li><a href="https://stackoverflow.com/questions/74780546/android-handle-lifecycle-event-on-jetpack-compose-screen">Android handle lifecycle event on Jetpack Compose Screen</a></li>
<li><a href="https://proandroiddev.com/jetpack-compose-making-composable-lifecycle-aware-bde67437d2d0">Jetpack Compose — Making Composable lifecycle-aware</a></li>
<li><a href="https://betterprogramming.pub/jetpack-compose-with-lifecycle-aware-composables-7bd5d6793e0">Jetpack Compose with Lifecycle-Aware Composables</a></li>
</ul>


<h3>以数据流的方式来处理生命周期事件</h3>

<p>生命周期是由系统控制，不时发生变化，每次变化会向监听者回调一个事件，如果以一定的时间跨度来看待，这些事件就形成了一个数据流。因此，Lifecycle还提供了一个Flow接口，用以发送Lifecycle事件。可以当作状态（State）来收集此Flow，这样事件的变化就能驱动Compose的重组，进而感知到最新的生命周期事件：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">lifecycleOwner</span> <span class="p">=</span> <span class="n">LocalLifecycleOwner</span><span class="p">.</span><span class="n">current</span>
</span><span class='line'><span class="k">val</span> <span class="py">stateFlow</span> <span class="p">=</span> <span class="n">lifecycleOwner</span><span class="p">.</span><span class="n">lifecycle</span><span class="p">.</span><span class="n">currentStateFlow</span>
</span><span class='line'><span class="k">val</span> <span class="py">currentLifecycleState</span> <span class="k">by</span> <span class="n">stateFlow</span><span class="p">.</span><span class="n">collectAsState</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 或者</span>
</span><span class='line'><span class="k">val</span> <span class="py">lifecycleOwner</span> <span class="p">=</span> <span class="n">LocalLifecycleOwner</span><span class="p">.</span><span class="n">current</span>
</span><span class='line'><span class="k">val</span> <span class="py">currentLifecycleState</span> <span class="p">=</span> <span class="n">lifecycleOwner</span><span class="p">.</span><span class="n">lifecycle</span><span class="p">.</span><span class="n">currentStateAsState</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>注意：</strong> 对于Flow不熟悉的同学可以复习一下<a href="https://juejin.cn/post/7336751931375648820">包教包会的Kotlin Flow教程</a>。</p>

<h3>不要在ViewModel中感知生命周期</h3>

<p>根据<a href="https://developer.android.com/topic/architecture">现代安卓开发架构原则</a>，ViewModel应该处理与UI相关的业务逻辑，它应该独立于平台，因此，千万不要在ViewModel去感知生命周期，事实上你也做不到，因为ViewModel是没任何对平台的依赖的，非常独立的一个类型，也即拿不到LifecycleOwner。</p>

<p>当然了，有同学说，我可以从Compose的Composable中把LifecycleOwner当作参数传给ViewModel，但仍然强烈不建议这样做。深层的原因在于，ViewModel是独立于平台的，它有自己的生命周周期，平台的组件（如Activity）是由系统控制的，但ViewModel是由我们自己控制的，它的生命周期要长于平台的组件，也就是说ViewModel的生命周期要长于它持有的LifecycleOwner，故LifecycleOwner可能会变得过时（非当前的Activity了），同时因为被更长生命的ViewModel持有，原LifecycleOwner可能无法被回收而引发内存泄漏。</p>

<p>ViewModel只应该负责业务逻辑相关的事情，在Composable中监听生命周期事件很方便，也很合适，然后调用ViewModel的相应的接口（如refresh()）即可。</p>

<h2>总结</h2>

<p>得益于Jetpack中的Lifecycle组件，在Compose中感知生命周期没有想像中的那样难。在实际项目中，推荐使用更符合Compose的方式，也即生命周期副作用函数以及事件数据流。如果仅是在某些生命周期事件发生时执行一些操作，那就用LifecycleEventEffect函数；如果不止一处需要使用事件，那就用事件数据流。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『履霜冰至』| Phases]]></title>
    <link href="http://toughcoder.net/blog/2024/08/30/jetpack-compose-phases/"/>
    <updated>2024-08-30T08:02:41+08:00</updated>
    <id>http://toughcoder.net/blog/2024/08/30/jetpack-compose-phases</id>
    <content type="html"><![CDATA[<blockquote><p>这篇文章译自<a href="https://developer.android.com/develop/ui/compose/phases">Jetpack Compose phases</a></p></blockquote>

<p>就像大多数其他的UI工具集一样，Compose渲染一帧也要经过几个不同的阶段。就比如说Android view系统，主要有三个阶段：测量（measure），版面编排（layout）和绘制（drawing）。Compose也非常的类似，但有一个特别重要的额外的阶段起始时的组合（composition）阶段。</p>

<p><a href="http://toughcoder.net/blog/2024/08/30/jetpack-compose-phases/"><img src="https://pbs.twimg.com/media/F3l9aWwWUAEDYxS.jpg:large" title="auto auto" ></a></p>

<!-- more -->


<p>组合在我们前面的文章中有详细的描述，包括<a href="https://juejin.cn/post/7379437165486112805">降Compose十八掌之『潜龙勿用』| Thinking in Compose</a>和<a href="https://juejin.cn/post/7376094685495001139">降Compose十八掌之『鸿渐于陆』| State</a>。</p>

<h2>每一帧的三个阶段</h2>

<p>Compose有三个主要的阶段：</p>

<ol>
<li>组合（Composition）：要显示什么。Compose运行composable函数并创建UI的一个描述。</li>
<li>版面编排（Layout）：在哪里显示。这个阶段包含两个步骤：测量（measurement）和放置（placement）。给布局树中的每个节点，在二维坐标中，布置元素的测量然后放置它们和它们的子元素。</li>
<li>绘制（Drawing）：如何渲染。把UI元素绘制进一个Canvas，也就是设备的屏幕上。</li>
</ol>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/compose-phases.png" alt="three_phases" /></p>

<blockquote><p>图1. Compose把数据转化为UI的三个阶段</p></blockquote>

<p>这三个阶段的执行顺序是相同的，能够让数据从组合到版面编排再到绘制沿着一个方向流动，以生成一帧（也就是<a href="https://developer.android.com/develop/ui/compose/architecture#udf">「单向数据流」</a>）。需要特别注意的例外是<a href="https://developer.android.com/develop/ui/compose/layouts/basics#constraints">BoxWithConstraints</a>，<a href="https://developer.android.com/develop/ui/compose/lists#lazy">LazyColumn</a>和<a href="https://developer.android.com/develop/ui/compose/lists#lazy">LazyRow</a>，它们子节点的组合依赖于父节点的排版阶段。</p>

<p>可以假定每一帧都会这三个阶段，但是基于性能的考量，在所有的阶段里，Compose会避免相同输入时计算结果相同的重复工作。如果一个composable函数能复用前一次的结果，Compose会跳过它的执行，并且如果没有必要，Compose UI并不会重新排版或者重新绘制整个UI树。Compose仅会做更新UI所必要的最少工作。因为Compose会在不同的阶段追踪状态读取，所以这种优化是可行的。</p>

<h3>理解不同的阶段</h3>

<p>这部分将详细的描述composables的三个渲染阶段是如何进行的。</p>

<h4>组合（Composition）</h4>

<p>在组合阶段，Compose运行时会执行composable函数然后输出一个能代表UI的树形结构。这个树形结构由包含着下一阶段所需要的信息的布局节点组成，如下面这个视频所示：</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/composition-ezgif.gif" alt="" /></p>

<blockquote><p>图2. 在组合阶段创建的代表着你的UI的树形结构。</p></blockquote>

<p>一小段代码和其树形会如下所示：</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/code-subsection.png" alt="ui_tree_vs_code" /></p>

<blockquote><p>图3. UI树的一部分与其对应的代码。</p></blockquote>

<p>在这些例子中，代码中的每个composable函数映射为一UI树中的一个布局节点。在更复杂的例子中，composables可包含逻辑和控制流程，在不同的状态下生成不同的树。</p>

<h4>排版（Layout）</h4>

<p>在排版阶段，Compose使用组合阶段生成的UI树作为输入。布局节点的集合包含了需要确定2D空间下每个节点大小和位置的所有需要的信息。</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/layout-ezgif.gif" alt="" /></p>

<blockquote><p>图4. 在排版阶段UI树中每个布局节点的测量和放置。</p></blockquote>

<p>在排版阶段，树用下面三步算法进行遍历：</p>

<ol>
<li>测量子节点：节点会测量其存在的子节点。</li>
<li>决定自身大小：基于前面的测量，一个节点能决定它自身的大小。</li>
<li>放置子节点：每个子节点以节点为参考进行放置。</li>
</ol>


<p>在这个阶段的最后，每个布局节点都有：</p>

<ul>
<li>一个确定的宽度（width）和高度（height）</li>
<li>一个绘制的位置坐标x，y</li>
</ul>


<p>对于前一部分提到的UI树：</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/code-subsection.png" alt="" /></p>

<p>对于这颗树，算法是这样工作的：</p>

<ol>
<li>Row测量它的子节点：Image和Column。</li>
<li>Image测量过后。因为它没有子节点，所它决定自己的大小并把其大小报告给Row。</li>
<li>接下来测量Column。它先测量它的两个子节点（两个Text函数）。</li>
<li>第一个Text被测量。它没有子节点，所以决定自己大小并告诉给Column

<ol type="a">
<li>第二个Text被测量。它也没有子节点，所以决定自己大小后告诉给Column。</li>
</ol>
</li>
<li>Column使用子节点的测量结果决定自己的大小。它用子节点的最大宽度（作为宽度）和高度之和（作为高度）。</li>
<li>Column相对于自己来放置子节点，把它们垂直地放在下面。</li>
<li>Row使用子节点的测量结果来决定自身大小。它使用子节点的最大高度作为高度，子节点宽度之和作为宽度。然后旋转子节点。</li>
</ol>


<p>注意每个节点仅访问一次。测量和放置所有节点时，Compose运行时仅需要访问一次UI树，这样做能提升性能。当树中的节点数量增加时，遍历所需要的时间仅线性增长。相反，如果每个节点访问多次，遍历时间将呈指数增长。</p>

<h4>绘制（Drawing）</h4>

<p>在绘制阶段，将从上到下的再次遍历树，每个节点依次的在屏幕上绘制其自身。</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/drawing-ezgif.gif" alt="" /></p>

<blockquote><p>图5. 绘制阶段在屏幕上绘制像素点。</p></blockquote>

<p>继续前面的例子，以如下方式绘制出树的内容：</p>

<ol>
<li>Row绘制它有的所有内容，如背景。</li>
<li>Image绘制它自己。</li>
<li>Column绘制它自己。</li>
<li>第一个和第二个Text各自绘制它们自己。</li>
</ol>


<p><img src="file:///Users/alexhilton/Downloads/compose_libs/drawing-ui-tree-ezgif.gif" alt="" /></p>

<blockquote><p>图6. UI树和它的渲染展示。</p></blockquote>

<h2>状态读取</h2>

<p>当你在上面列出的一个阶段中读取状态的值时，Compose会自动追踪值被读取时它在做的事情。这种追踪允许Compose在状态发生变化时重新执行读取者，这是Compose中状态的可观测性的基础。</p>

<p>状态通常都是由mutableStateOf来创建的然后通过两种方式访问：直接读取其属性value或者通过Kotlin的属性委托。可以在文章<a href="https://juejin.cn/post/7376094685495001139">降Compose十八掌之『鸿渐于陆』| State</a>中了解更多的细节。在本文中，「状态读取」通指两种方法中的任意一种。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="c1">// 直接读取状态的value</span>
</span><span class='line'><span class="k">val</span> <span class="py">paddingState</span><span class="p">:</span> <span class="n">MutableState</span><span class="p">&lt;</span><span class="n">Dp</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="m">8.</span><span class="n">dp</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="n">Text</span><span class="p">(</span>
</span><span class='line'>    <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;Hello&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="n">paddingState</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="c1">// 通过属性委托来读取</span>
</span><span class='line'><span class="k">var</span> <span class="py">padding</span><span class="p">:</span> <span class="n">Dp</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="m">8.</span><span class="n">dp</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="n">Text</span><span class="p">(</span>
</span><span class='line'>    <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;Hello&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>属性委托的背后，「getter」和「setter」函数用来访问和更新状态的value。这些getter和setter函数仅当你把属性当作一个值来引用时才会被调用，而不是委托被创建时，所以这就是上面两种方式是等价的原因。</p>

<p>当一个被读取状态发生变化时都会被重新执行的每一个代码块都是一个重启作用域（restart scope）。在不同的阶段，Compose会追踪状态值的变化然后重启作用域。</p>

<h2>分阶段的状态读取</h2>

<p>如上面所提及，Compose中有三个主要的阶段，在每个阶段中，Compose会追踪哪些状态被读取了。这让Compose能够仅通知针对UI中受影响的元素需要采取措施的特定阶段。</p>

<blockquote><p>注意：状态实例被创建和存储的地方对阶段几乎无影响，只有状态被读取的时间和地点才有重要影响。</p></blockquote>

<p>我们来仔细检查每一个阶段，然后描述一下在其中当状态被读取时所发生的事情。</p>

<h3>阶段一：组合</h3>

<p>在一个&#64;Composable标注的函数里或者lambda代码块里读取状态会影响组合和后续阶段。当状态值发生变化，重组器（recomposer）会安排所有读取状态的composable函数的重新运行。注意如果函数的输入没有变化，运行时可能会跳过一些甚至所有的composable函数。想了解更多可以看文章<a href="https://juejin.cn/post/7401358349877346338">降Compose十八掌之『损则有孚』| Lifecycle</a>。</p>

<p>取决于组合的结果，Compose UI在执行排版和绘制阶段，如果内容始终相同和大小以及布局未发生变化，它也许会跳过这些阶段。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">var</span> <span class="py">padding</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="m">8.</span><span class="n">dp</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="n">Text</span><span class="p">(</span>
</span><span class='line'>    <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;Hello&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="c1">// 当对象Modifier被构建时，状态`paddin`在组合阶段读取。</span>
</span><span class='line'>    <span class="c1">// 状态`padding`的变化会触发重组</span>
</span><span class='line'>    <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>阶段二：排版</h3>

<p>排版阶段由两个步骤组成：测量和放置。测量步骤运行传递给composable函数的测量lambda，也即诸如接口LayoutModifier的MeasureScope.measure方法等的代码。放置步骤运行layout函数的放置代码块，也即诸如Modifier.offset {&hellip;}的代码块。</p>

<p>这些步骤中的状态读取影响排版编排和后续的绘制阶段。当状态值发生变化，Compose UI会安排排版阶段。如果大小和位置发生变化，它也会执行绘制阶段。</p>

<p>更准确的说，测量步骤和放置步骤有不同的重启作用域（restart scope），也就是说放置步骤中的状态读取不会重新触发它前面测量步骤。然而，这些步骤经常绞在一起，所以放置步骤中的状态读取可能会影响属于测量步骤中的其他重启作用域。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">var</span> <span class="py">offsetX</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="m">8.</span><span class="n">dp</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="n">Text</span><span class="p">(</span>
</span><span class='line'>    <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;Hello&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">offset</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 当offset被计算时，状态`offsetX`在排版阶段中的放置步骤读取</span>
</span><span class='line'>        <span class="c1">// `offsetX`的变化会重启排版</span>
</span><span class='line'>        <span class="n">IntOffset</span><span class="p">(</span><span class="n">offsetX</span><span class="p">.</span><span class="n">roundToPx</span><span class="p">(),</span> <span class="m">0</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>阶段三：绘制</h3>

<p>绘制过程中的状态读取影响绘制阶段。常见的例子包括Canvas()，Modifier.drawBehind和Modifer.drawWithContent函数。当状态值发生变化，Compose UI仅执行绘制阶段。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">var</span> <span class="py">color</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Red</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="n">Canvas</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">modifier</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 当canvas被渲染时，状态`color`在绘制阶段读取</span>
</span><span class='line'>    <span class="c1">// 状态`color`变化重启绘制</span>
</span><span class='line'>    <span class="n">drawRect</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/phases-state-read-draw.svg" alt="phase_state_read_draw" /></p>

<h2>优化状态读取</h2>

<p>因为Compose进行本地化的状态读取追踪，我们可以通过在合适的阶段读取状态以最小化渲染工作量。</p>

<p>我们来看一下下面的例子。这里有一个Image，使用了offset modifier来作为最终布局位置的偏移，实现一个用户滑动时的平行视觉差的效果：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">Box</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">listState</span> <span class="p">=</span> <span class="n">rememberLazyListState</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Image</span><span class="p">(</span>
</span><span class='line'>        <span class="c1">// ...</span>
</span><span class='line'>        <span class="c1">// 这不是一个最优的实现方式</span>
</span><span class='line'>        <span class="n">Modifier</span><span class="p">.</span><span class="n">offset</span><span class="p">(</span>
</span><span class='line'>            <span class="n">with</span><span class="p">(</span><span class="n">LocalDensity</span><span class="p">.</span><span class="n">current</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">// 在组合中读取状态firstVisibleItemScrollOffset</span>
</span><span class='line'>                <span class="p">(</span><span class="n">listState</span><span class="p">.</span><span class="n">firstVisibleItemScrollOffset</span> <span class="p">/</span> <span class="m">2</span><span class="p">).</span><span class="n">toDp</span><span class="p">()</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">LazyColumn</span><span class="p">(</span><span class="n">state</span> <span class="p">=</span> <span class="n">listState</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// ...</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个代码能行，但性能并不是最优的。上面的代码读取状态firstVisibleItemScrollOffset然后把它传给函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary#(androidx.compose.ui.Modifier">Modifier.offset</a>.offset(androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp))。当用户滑动时firstVisibleItemScrollOffset的值会变化。我们知道，Compose会追踪任何状态读取以便它能重新执行进行读取的代码，也即例子中函数Box中的内容。</p>

<p>这是一个在组合阶段读取状态的例子。这也并不是一无事处，因为这是重组的基础，让数据变化刷新UI。</p>

<p>但这个例子不是最优做法，因为每次滚动都会导致整个composable函数被重新运行，也会重新测量，重新排版，然后最终重新绘制。尽管要显示的内容并没有真正变化，仅是要显示的位置在变化，但我们每个滚动都会触发Compose的所有阶段。我们可以优化状态读取以仅触发排版阶段。</p>

<p>有offset modifier另外一个版本：<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary#(androidx.compose.ui.Modifier">Modifier.offset(offset: Density.()-> IntOffset)</a>.offset(kotlin.Function1))。这个函数接收一个lambda作为参数，lambda代码块的返回结果作为最终的偏移量。我们来改一下前面的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">Box</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">listState</span> <span class="p">=</span> <span class="n">rememberLazyListState</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Image</span><span class="p">(</span>
</span><span class='line'>        <span class="c1">// ...</span>
</span><span class='line'>        <span class="n">Modifier</span><span class="p">.</span><span class="n">offset</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// 在排版阶段读取状态firstVisibleItemScrollOffset</span>
</span><span class='line'>            <span class="n">IntOffset</span><span class="p">(</span><span class="n">x</span> <span class="p">=</span> <span class="m">0</span><span class="p">,</span> <span class="n">y</span> <span class="p">=</span> <span class="n">listState</span><span class="p">.</span><span class="n">firstVisibleItemScrollOffset</span> <span class="p">/</span> <span class="m">2</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">LazyColumn</span><span class="p">(</span><span class="n">state</span> <span class="p">=</span> <span class="n">listState</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// ...</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>为何这样就性能更优呢？我们提供给modifier的lambda代码块仅在排版阶段调用（具体来说是在排版阶段中的放置步骤），也就是说在组合阶段状态firstVisibleItemScrollOffset不用再被读取了。因为Compose追踪状态什么时候被读取，这次改动意味着如果状态firstVisibleItemScrollOffset值发生变化，Compose仅会重启排版和绘制阶段。</p>

<blockquote><p><strong>注意：</strong> 你也许很好奇接收一个lambda作为参数与接收一个普通值参数相比是否有额外的开销。确实有。然而，在这个场景中，限制状态读取到排版阶段带来的收益要超过参数的开销。在滑动中firstVisibleItemScrollOffset的值每一帧都会发生变化，把状态读取延迟到排版阶段，能避免很多次重组。</p></blockquote>

<p>虽然这个例子靠有不同的offset modifiers可以用来优化最终代码，但思路是通用的：尽可能把状态读取限制到最少的阶段中，让Compose做最少量的渲染工作。</p>

<p>当然了，在组合阶段也常常绝对有必要读取状态。尽管如此，通过过滤状态变化，还是有可以最小化重组发生的场景。想要了解更多的这方面信息，可以读文章<a href="https://juejin.cn/post/7405158681078104127">降Compose十八掌之『龙战于野』| Side Effects</a>。</p>

<h2>重组循环（循环阶段依赖）</h2>

<p>早些时候我们提到过Compose的阶段总会以相同的顺序被调用，并且在一帧中是没有办法往回走的。然而，不同帧之间组合循环依然会发生。看这个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">Box</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">imageHeightPx</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="m">0</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Image</span><span class="p">(</span>
</span><span class='line'>        <span class="n">painter</span> <span class="p">=</span> <span class="n">painterResource</span><span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">drawable</span><span class="p">.</span><span class="n">rectangle</span><span class="p">),</span>
</span><span class='line'>        <span class="n">contentDescription</span> <span class="p">=</span> <span class="s">&quot;I&#39;m above the text&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>            <span class="p">.</span><span class="n">fillMaxWidth</span><span class="p">()</span>
</span><span class='line'>            <span class="p">.</span><span class="n">onSizeChanged</span> <span class="p">{</span> <span class="n">size</span> <span class="p">-&gt;</span>
</span><span class='line'>                <span class="c1">// 不要这样做</span>
</span><span class='line'>                <span class="n">imageHeightPx</span> <span class="p">=</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>        <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;I&#39;m below the image&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span>
</span><span class='line'>            <span class="n">top</span> <span class="p">=</span> <span class="n">with</span><span class="p">(</span><span class="n">LocalDensity</span><span class="p">.</span><span class="n">current</span><span class="p">)</span> <span class="p">{</span> <span class="n">imageHeightPx</span><span class="p">.</span><span class="n">toDp</span><span class="p">()</span> <span class="p">}</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里我们（以不好的方式）实现了一个垂直的列，图片在上面文字在其下面。使用Modifier.onSizeChanged感知图片的实际尺寸，然后通过Modifier.padding作用于文字以让其向下偏移。从Px到Dp的不自然转换已经表明了这段代码有问题。</p>

<p>这个例子的问题在于无法通过一帧就达到最终的排列布局。代码依赖于多帧的绘制，进行了不必要的工作，导致UI会在屏幕上跳跃。</p>

<p>让我们一帧帧的检查来看发生了什么：</p>

<p>在第1帧的组合阶段，imageHeightPx值为0，文字拿到的是Modifier.padding(top = 0)。然后，到了排版阶段，modifier的onSizeChanged回调会被调用。这时imageHeightPx会被更新成为图片的实际高度。Compose为下一帧安排重组。在绘制阶段，文字使用padding 0来渲染，因为这时状态的值还没有被更新。</p>

<p>然后Compose会启动因imageHeightPx的值变化而安排的第2帧渲染。状态是在Box内容代码块中读取，并且是在组合阶段调用的。这回，给到Text的padding是真实的图片的高度。在排版阶段，代码再次修改了imageHeightPx的值，但因为值没有发生变化，所以不会安排重组。</p>

<p>最终，我们得到的text的期望的padding，但是耗费额外的一帧来传递padding值到不同的阶段并不是最优的做法，这会导致带有重叠内容的一帧。</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/phases-recomp-loop.svg" alt="" /></p>

<p>这个例子也许显得有点做作，但要小心这种通用的模式：</p>

<ul>
<li>Modifier.onSizeChanged，onGloballyPositioned，或者一些其他的排版操作</li>
<li>更新一些状态</li>
<li>把状态当作排版modifier（padding(), height()或者类似的）的输入</li>
<li>潜在的重复</li>
</ul>


<p>上面示例的修复办法是使用合适的排版原语。上面例子可以用一个普通的Column()来实现，但你也许会有需要一些定制的更复杂的场景，这些场景可能需要写一些定制化的布局。可以看<a href="https://developer.android.com/develop/ui/compose/layouts/custom">定制布局</a>文档以了解更多。</p>

<p>这里通用的原则是对于需要相互之间测量和旋转的多个UI元素要保持单一数据来源。使用合适的排版原语或者创建一个定制化的布局就意味着最少化的共享父节点可以当作可以协调多个元素之间关联的单一数据源。而引入动态的状态会打破这一原则。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『龙战于野』| Side Effects]]></title>
    <link href="http://toughcoder.net/blog/2024/08/23/jetpack-compose-side-effects/"/>
    <updated>2024-08-23T07:56:53+08:00</updated>
    <id>http://toughcoder.net/blog/2024/08/23/jetpack-compose-side-effects</id>
    <content type="html"><![CDATA[<blockquote><p>主要翻译自官方文档<a href="https://developer.android.com/develop/ui/compose/side-effects">Side-effects in Compose</a>，并不是直译，有些细微调整。</p></blockquote>

<p>一个<strong>副作用</strong>是指发生在composable函数范围之外的应用状态的一个变化。由于composable函数的生命周期和诸如不可预测的重组，以不同的顺序执行composable的重组，或者重组可能会被跳过等性质，理论上composable应该<a href="https://juejin.cn/post/7379437165486112805">要是无副作用</a>的。</p>

<p><a href="http://toughcoder.net/blog/2024/08/23/jetpack-compose-side-effects/"><img src="https://ac.appcircle.io/wp-content/uploads/2022/10/compose-side-effects-state.png" title="auto auto" ></a></p>

<!-- more -->


<p>然而，有些时候副作用是必要的，例如，触发一些诸如显示一个非干扰性提示（snackbar）或者在一定状态条件下跳转到另一个页面，等的一次性的事件时。这些行为应该在一个能够感知composable生命周期的可控的环境中调用。在本文中，你将学习Jetpack Compose提供的几种不同的副作用函数（side effect APIs）。</p>

<h2>副作用的具体使用场景</h2>

<p>如在文章<a href="https://juejin.cn/post/7379437165486112805">降Compose十八掌之『潜龙勿用』| Thinking in Compose</a>中提到的，composables应该尽可能的做到无副作用。当需要对应用状态进行修改时，应该使用副作用API，以便副作用函数以可预测的方式运行。</p>

<blockquote><p><strong>关键点：</strong> 一个作用（effect）是指一个composable函数不会生成UI元素，而是当组合完成时生成副作用。</p></blockquote>

<p>由于Compose中有多种作用，很容易被滥用。要确保在副作用中做的事情是UI相关的并且没有违反『单一数据流原则』。</p>

<blockquote><p><strong>注意：</strong> 一个可响应的UI应该是异步的，Jetpack Compose解决异步的办法是在API级别结合协程而不是使用回调。想要了解更多的协程知识，可以参看<a href="https://juejin.cn/post/7329767824200826918">之前的文章</a>。</p></blockquote>

<h3>LaunchedEffect：在composable的作用域内运行挂起函数</h3>

<p>想要在一个composable的生命周期中执行操作并且需要调用挂起函数，就可以使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#LaunchedEffect(kotlin.Any,kotlin.coroutines.SuspendFunction1">LaunchedEffect</a>)。当LaunchedEffect进入组合时，它会使用作为参数传入的代码块来启动一个协程。如果LaucnhedEffect离开了组合协程会被取消。如果因不同的key LaunchedEffect被重组了（副作用的重启机制会在后面进行讲解），运行中的协程会被取消掉，一个新的协程会被启动以运行新的挂起函数。</p>

<p>例如，一个可调节延迟的脉冲式透明度的动画：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="c1">// 变化的速率可以调节，可以加快动画（减少间隔）</span>
</span><span class='line'><span class="k">var</span> <span class="py">pulseRateMs</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="m">3000L</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="k">val</span> <span class="py">alpha</span> <span class="p">=</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">Animatable</span><span class="p">(</span><span class="m">1f</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="n">LaunchedEffect</span><span class="p">(</span><span class="n">pulseRateMs</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 速度作为key，这样速度变化时，会重启副作用，动画也会重启</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="n">isActive</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="n">pulseRateMs</span><span class="p">)</span> <span class="c1">// 一定间隔之后显示脉冲动画</span>
</span><span class='line'>        <span class="n">alpha</span><span class="p">.</span><span class="n">animateTo</span><span class="p">(</span><span class="m">0f</span><span class="p">)</span>
</span><span class='line'>        <span class="n">alpha</span><span class="p">.</span><span class="n">animateTo</span><span class="p">(</span><span class="m">1f</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中，动画使用了挂起函数<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html">delay</a>来等待一定的时间。然后，它依次使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Animatable#animateTo(kotlin.Any,androidx.compose.animation.core.AnimationSpec,kotlin.Any,kotlin.Function1">animateTo</a>)展现动画到不可见，再到可见。并在composable的生命周期中不断重复。</p>

<h3>rememberCoroutineScope：获取一个可以在composable之外启动协程的可感知组合的协程作用域</h3>

<p>因为LaunchedEffect是一个composable函数，所以它只能在其他composable函数中调用。如果想要在composable作用域之外启动协程，但又希望限制协程在一定的范围内，以便能在离开组合时协程自动被取消，可以使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#rememberCoroutineScope(kotlin.Function0">rememberCoroutineScope</a>)。在任何需要手动操控一个或者多个协程的生命周期的时候都应该使用rememberCorountineScope，比如说当用户事件发生时需要取消动画。</p>

<p>rememberCoroutineScope是一个composable函数，返回一个协程作用域（CoroutineScope），这个作用域会被绑定到经组合中它被调用的地点。当离开组合时，这个协程作用域会被取消。</p>

<blockquote><p><strong>译注：</strong> 如果对协程作用域不太熟悉的同学，可以参看<a href="https://juejin.cn/post/7324351711660048411">之前的文章</a>。</p></blockquote>

<p>例如，可以用下面的代码，当点击按扭时显示一个Snackbar（译注：非干扰式提示，类似于Toast）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">MoviesScreen</span><span class="p">(</span><span class="n">snackbarHostState</span><span class="p">:</span> <span class="n">SnackbarHostState</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 创建一个绑定到MoviesScreen生命周期的协程作用域</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">scope</span> <span class="p">=</span> <span class="n">rememberCoroutineScope</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Scaffold</span><span class="p">(</span>
</span><span class='line'>        <span class="n">snackbarHost</span> <span class="p">=</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">SnackbarHost</span><span class="p">(</span><span class="n">hostState</span> <span class="p">=</span> <span class="n">snackbarHostState</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span> <span class="n">contentPadding</span> <span class="p">-&gt;</span>
</span><span class='line'>        <span class="n">Column</span><span class="p">(</span><span class="n">Modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="n">contentPadding</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">Button</span><span class="p">(</span>
</span><span class='line'>                <span class="n">onClick</span> <span class="p">=</span> <span class="p">{</span>
</span><span class='line'>                    <span class="c1">// 在作用域中创建一个协程来显示提示。</span>
</span><span class='line'>                    <span class="n">scope</span><span class="p">.</span><span class="n">launch</span> <span class="p">{</span>
</span><span class='line'>                        <span class="n">snackbarHostState</span><span class="p">.</span><span class="n">showSnackbar</span><span class="p">(</span><span class="s">&quot;Something happened!&quot;</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">}</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">Text</span><span class="p">(</span><span class="s">&quot;Press me&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>rememberUpdateState：指向即使值发生变化也不会重启的作用中的一个值</h3>

<p>当参数key中的任何一个发生变化时LaunchedEffect就会重启。然而，在有些情况下我们希望捕获这样作用中的一个值，这个作用不会随着值变化而重启。为了达到这样的效果，需要使用rememberUpdatedState创建一个能被捕获和更新的值的引用。这个方式对于那些含有长时间运行，且重新创建或者重启都非常昂贵之类的操作的副作用是很有用的。</p>

<p>例如，假设你的应用有一个一段时间内消失的加载页面（LandingScreen）。即使这个加载页面被重组了，等待时间副作用和通知已过去了多少时间副作用都不应该被重新启动：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">LandingScreen</span><span class="p">(</span><span class="n">onTimeout</span><span class="p">:</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 这个状态永远指向LandingScreen重组后最新的onTimeout函数</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">currentOnTimeout</span> <span class="k">by</span> <span class="n">rememberUpdatedState</span><span class="p">(</span><span class="n">onTimeout</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 创建一个与LandingScreen生命周期一致的副作用。即使LandingScreen被重组了，这里的延迟不应该重新开始.</span>
</span><span class='line'>    <span class="n">LaunchedEffect</span><span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="n">SplashWaitTimeMillis</span><span class="p">)</span>
</span><span class='line'>        <span class="n">currentOnTimeout</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* 加载页面的内容 */</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>想要创建一个与调用点生命周期一至的副作用，可以把像Unit或者true等永不会改变的常量当作参数。在上面的例子中，使用了LaunchedEffect(true)。为了保证lambda onTimeout中总是包含LandingScreen被重组后的最新值，onTimeout需要使用rememberUpdatedState来包装。返回值，就是代码中的currentOnTimeout应该在副作用中使用。</p>

<blockquote><p><strong>注意：</strong> LaunchedEffect(true)就像while(true)一样诡异。即使有具体的使用场景，也要三思后行，确保确实需要这样做。</p></blockquote>

<h3>DisposableEffect：需要清理工作的副作用</h3>

<p>对于当离开组合或者key发生变化时需要清朝工作的副作用，使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#DisposableEffect(kotlin.Any,kotlin.Function1">DisposableEffect</a>)。如果DisposableEffect的key发生变化，调用的composable需要进行清理副作用，并且重新调用。</p>

<p>作为一个示例，通过使用<a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleObserver">LifecycleObserver</a>，你也许想要发送基于平台生命周期事件（Lifecycle events）统计事件数据（译注：这里的生命周期是指Android平台组件的生命周期）。想要在Compose中监听这些事件，使用一个DisposableEffect来在需要时注册和反注册观察者：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">HomeScreen</span><span class="p">(</span>
</span><span class='line'>    <span class="n">lifecycleOwner</span><span class="p">:</span> <span class="n">LifecycleOwner</span> <span class="p">=</span> <span class="n">LocalLifecycleOwner</span><span class="p">.</span><span class="n">current</span><span class="p">,</span>
</span><span class='line'>    <span class="n">onStart</span><span class="p">:</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">,</span> <span class="c1">// 发送&#39;started&#39; 事件</span>
</span><span class='line'>    <span class="n">onStop</span><span class="p">:</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Unit</span> <span class="c1">// 发磅 &#39;stopped&#39; 事件</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 保证当前的lambda是最新的</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">currentOnStart</span> <span class="k">by</span> <span class="n">rememberUpdatedState</span><span class="p">(</span><span class="n">onStart</span><span class="p">)</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">currentOnStop</span> <span class="k">by</span> <span class="n">rememberUpdatedState</span><span class="p">(</span><span class="n">onStop</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 如果 `lifecycleOwner` 发生变化，清理并重置副作用函数</span>
</span><span class='line'>    <span class="n">DisposableEffect</span><span class="p">(</span><span class="n">lifecycleOwner</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 创建一个观察者以触发我们的事件发送回调lambda</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">observer</span> <span class="p">=</span> <span class="n">LifecycleEventObserver</span> <span class="p">{</span> <span class="n">_</span><span class="p">,</span> <span class="n">event</span> <span class="p">-&gt;</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="p">==</span> <span class="n">Lifecycle</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">ON_START</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">currentOnStart</span><span class="p">()</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="p">==</span> <span class="n">Lifecycle</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">ON_STOP</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">currentOnStop</span><span class="p">()</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 把观察者添加到生命周期观察者列表里</span>
</span><span class='line'>        <span class="n">lifecycleOwner</span><span class="p">.</span><span class="n">lifecycle</span><span class="p">.</span><span class="n">addObserver</span><span class="p">(</span><span class="n">observer</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 当离开组合时，进行清理工作，即把观察者从其列表中移除</span>
</span><span class='line'>        <span class="n">onDispose</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">lifecycleOwner</span><span class="p">.</span><span class="n">lifecycle</span><span class="p">.</span><span class="n">removeObserver</span><span class="p">(</span><span class="n">observer</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* Home screen content */</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中，副作用会添加一个观察者observer到lifecycleOwner上。如果lifecycleOwner有变动，副作用函数会被清理并且使用新的lifecycleOwner重启。</p>

<p>一个DispoableEffect必须要包含一个onDispose语句作为其代码块的最后一个语句。否则会有编译错误。</p>

<blockquote><p><strong>注意：</strong> 使用一个空的onDispose并不是一个好的做法。要多思考一下是否有更加符合使用场景的副作用函数。</p></blockquote>

<h3>SideEffect：向非Comopse代码发布Compose的状态</h3>

<p>要与非Compose管理的对象共享Compose状态时，使用composable <a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#SideEffect(kotlin.Function0">SideEffect</a>)。使用SideEffect能够保证副作用在每次成功重组后都能得到执行。另一方面，在一个重组保证成功之前执行一个副作用是不正确的，这种场景就会直接在composable中写入副作用。</p>

<p>例如，你的分析库也许允许你通过给后面的统计数据添加自定义的meta data（在此例中是『user properties』）的方式来给用户数据分段。为了建立当前用户的用户类型与统计库之间的联系，可以使用SideEffect来更新此值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">rememberFirebaseAnalytics</span><span class="p">(</span><span class="n">user</span><span class="p">:</span> <span class="n">User</span><span class="p">):</span> <span class="n">FirebaseAnalytics</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">analytics</span><span class="p">:</span> <span class="n">FirebaseAnalytics</span> <span class="p">=</span> <span class="n">remember</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">FirebaseAnalytics</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 每次成功组合，用当前用户的用户类型来更新 FirebaseAnalytics，保证</span>
</span><span class='line'>    <span class="c1">// 后面的统计事件能带上userType</span>
</span><span class='line'>    <span class="n">SideEffect</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">analytics</span><span class="p">.</span><span class="n">setUserProperty</span><span class="p">(</span><span class="s">&quot;userType&quot;</span><span class="p">,</span> <span class="n">user</span><span class="p">.</span><span class="n">userType</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">analytics</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>produceState：把非Compose状态转化为Compose状态</h3>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#produceState(kotlin.Any,kotlin.coroutines.SuspendFunction1">produceState</a>)启动一个受组合管控的协程作用域，其中可以把值转化为状态。用它可以把非Compose状态转化为Compose状态，例如把外部由订阅驱动 的值如Flow，LiveData或者RxJava转化到组合中。</p>

<p>当produceState进入组合时生产者就会被启动，然后当离开组合时被取消。返回的状态会合并：就是说相同的值不会再次触发重组。</p>

<p>尽管produceState会创建协程，它也能用来监听非挂起数据。想要移除对数据的订阅，使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/ProduceStateScope#awaitDispose(kotlin.Function0">awaitDispose</a>)函数。</p>

<p>下面的例子展示如何使用produceState来从网络加载图片。Composable函数loadNextworkImage返回一个可以用在其他composables中的状态：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">loadNetworkImage</span><span class="p">(</span>
</span><span class='line'>    <span class="n">url</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span>
</span><span class='line'>    <span class="n">imageRepository</span><span class="p">:</span> <span class="n">ImageRepository</span> <span class="p">=</span> <span class="n">ImageRepository</span><span class="p">()</span>
</span><span class='line'><span class="p">):</span> <span class="n">State</span><span class="p">&lt;</span><span class="n">Result</span><span class="p">&lt;</span><span class="n">Image</span><span class="p">&gt;&gt;</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 用 Result.Loading 作为初值，创建一个状态 State&lt;T&gt;</span>
</span><span class='line'>    <span class="c1">// 如果 「url」或者「imageRepository」任何一个发生变化，运行中的生产者会被取消</span>
</span><span class='line'>    <span class="c1">// 使用新的输入被重启。</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">produceState</span><span class="p">&lt;</span><span class="n">Result</span><span class="p">&lt;</span><span class="n">Image</span><span class="p">&gt;&gt;(</span><span class="n">initialValue</span> <span class="p">=</span> <span class="n">Result</span><span class="p">.</span><span class="n">Loading</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">imageRepository</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 在协程里，可以调用挂起函数</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">image</span> <span class="p">=</span> <span class="n">imageRepository</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 使用成功或者失败作为结果 来更新状态</span>
</span><span class='line'>        <span class="c1">// 这会触发读取此状态的composable的重组</span>
</span><span class='line'>        <span class="n">value</span> <span class="p">=</span> <span class="k">if</span> <span class="p">(</span><span class="n">image</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">Result</span><span class="p">.</span><span class="n">Error</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">Result</span><span class="p">.</span><span class="n">Success</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p><strong>注意：</strong> 带有返回值的composable函数应该以常规的Kotlin函数命名规范进行命名，以小写字符开头的驼峰式。</p></blockquote>

<p><br/></p>

<blockquote><p><strong>关键点：</strong> 进一步的了解，produceState使用了其他的副作用函数！它使用remember { mutableStateOf(initialValue) }来持有返回结果，然后在一个LaunchedEffect中触发生产者代码块。每当生产者代码块中更新了value的值，相应的状态也会被更新。
开发者也可以基于现有的API来创造想要的副作用函数</p></blockquote>

<h3>derivedStateOf：把一个或者多个状态对象转化为另一个状态</h3>

<p>在Compose中，每次当被观察的状态对象发生变化或者composable的输入有变化时重组就会发生。状态对象或者输入可能变化次数的超过了UI实际的需要，导致了不必要的重组。</p>

<p>当一个composable的输入变化超过了重组所需要时就应该使用函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#derivedStateOf(kotlin.Function0">deriveStateOf</a>)。比较觉的场景是当有些变量频繁的变动，比如滚动位置，但composable仅需要变动超过一定阈值时才需要对其响应。derivedStateOf创建一个新的仅在需要时更新的可观察Compose状态。这样，它就类似于Kotlin Flow中的操作符<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/distinct-until-changed.html">distinctUntilChanged</a>。</p>

<blockquote><p><strong>注意：</strong> derivedStateOf是比较昂贵的（也即性能开销比较大），应该仅用来减少结果未变化时的不必要的重组。</p></blockquote>

<h4>正确的使用</h4>

<p>下面的代码片段展示一个恰当的使用derivedStateOf的场景：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="c1">// 当参数 messages 变化时, MessageList会被重组. derivedStateOf不会影响这个重组</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">MessageList</span><span class="p">(</span><span class="n">messages</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Message</span><span class="p">&gt;)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Box</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">listState</span> <span class="p">=</span> <span class="n">rememberLazyListState</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">LazyColumn</span><span class="p">(</span><span class="n">state</span> <span class="p">=</span> <span class="n">listState</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// ...</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 当第一个可见的元素不是第一个元素时显示按扭。用一个被记忆的衍生状态来最小化不必要的重组</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">showButton</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">derivedStateOf</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">listState</span><span class="p">.</span><span class="n">firstVisibleItemIndex</span> <span class="p">&gt;</span> <span class="m">0</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">AnimatedVisibility</span><span class="p">(</span><span class="n">visible</span> <span class="p">=</span> <span class="n">showButton</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">ScrollToTopButton</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这个代码片段中，每次第一个可见的元素变化时firstVisibleItemIndex都会变化。当滚动时，它的值会变成0，1，2，3，4，5等等。然而，仅当值大于0时才需要重组。这个更新频次的不匹配意味着是一个使用derivedStateOf的好的场景。</p>

<h4>错误的使用</h4>

<p>一个常见的错误是想当然的认为当需要合并两个状态时，就需要使用derivedStateOf，因为在创建衍生状态。然而这完全是凭空想像的也不是必须的，如下面代码所展示：</p>

<blockquote><p><strong>注意：</strong> 下面的代码展示derivedStateOf不正确的用例。不要这样使用。</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="c1">// 不要这样用，不正确的derivedStateOf的用法</span>
</span><span class='line'><span class="k">var</span> <span class="py">firstName</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="k">var</span> <span class="py">lastName</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="py">fullNameBad</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">derivedStateOf</span> <span class="p">{</span> <span class="s">&quot;$firstName $lastName&quot;</span> <span class="p">}</span> <span class="p">}</span> <span class="c1">// 很糟糕</span>
</span><span class='line'><span class="k">val</span> <span class="py">fullNameCorrect</span> <span class="p">=</span> <span class="s">&quot;$firstName $lastName&quot;</span> <span class="c1">// 不正确</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码中，fullName的更新频次与firstName和lastName是一样的。因此，不会有不必要的重组发生，使用derivedStateOf是多余的。</p>

<h3>snapshotFlow</h3>

<p>使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#snapshotFlow(kotlin.Function0">snapshotFlow</a>)能把状态对象（<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/State">State<T></a> objects）转化为一个冷流（cold Flow）。当被订阅（collected）时snapshotFlow会运行代码块在其中发送它读取到的状态对象。当在snapshotFlow代码块中读取的状态对象发生变化时，Flow会发送新的数据给它的订阅者，如果这个新的数据没有被发送过（这个行为与<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/distinct-until-changed.html">Flow.distinctUntilChanged</a>是类似的）。</p>

<blockquote><p><strong>译注：</strong> 对Flow不熟悉的同学可以参看<a href="https://juejin.cn/post/7336751931375648820">之前的文章</a>。</p></blockquote>

<p>下面的例子展示一个副作用，用以记录当用户滑动超过列表中首个元素时的统计信息：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">listState</span> <span class="p">=</span> <span class="n">rememberLazyListState</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="n">LazyColumn</span><span class="p">(</span><span class="n">state</span> <span class="p">=</span> <span class="n">listState</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">LaunchedEffect</span><span class="p">(</span><span class="n">listState</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">snapshotFlow</span> <span class="p">{</span> <span class="n">listState</span><span class="p">.</span><span class="n">firstVisibleItemIndex</span> <span class="p">}</span>
</span><span class='line'>        <span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">index</span> <span class="p">-&gt;</span> <span class="n">index</span> <span class="p">&gt;</span> <span class="m">0</span> <span class="p">}</span>
</span><span class='line'>        <span class="p">.</span><span class="n">distinctUntilChanged</span><span class="p">()</span>
</span><span class='line'>        <span class="p">.</span><span class="n">filter</span> <span class="p">{</span> <span class="n">it</span> <span class="p">==</span> <span class="k">true</span> <span class="p">}</span>
</span><span class='line'>        <span class="p">.</span><span class="n">collect</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">MyAnalyticsService</span><span class="p">.</span><span class="n">sendScrolledPastFirstItemEvent</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中，listState.firstVisibleItemIndex会被转化为一个Flow，方便使用Flow操作符带来的便利。</p>

<h2>副作用的重启</h2>

<p>Compose中的一些副作用，像LaunchedEffect，produceState，DispoableEffect，接收不定数量的参数keys，这些参数用于取消正在进行中的副作用和使用新的参数启动新的副作用。</p>

<p>这些API的典型形式是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">EffectName</span><span class="p">(</span><span class="n">restartIfThisKeyChanges</span><span class="p">,</span> <span class="n">orThisKey</span><span class="p">,</span> <span class="n">orThisKey</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span> <span class="n">block</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>由于这个行为的细微性质，如果用于重启副作用的参数并不是正确的参数时，就会产生问题：</p>

<ul>
<li>副作用重启次数少于预期可能会产生bug</li>
<li>重启次数多于预期是冗余的，影响性能</li>
</ul>


<p>首要的原则是，在副作用代码块中使用的可变的和不可变的变量都应该当成composable函数的参数。此外，也可以添加更多的参数以强制重启副作用。如果一个变量的变化不应该导致重启副作用，那这个变量应该用rememberUpdateState包裹起来。如果一个变量因为包裹在remember时没有key而永远不会变化，那么这个变量就应该作为key传给副作用函数。</p>

<blockquote><p><strong>关键点：</strong> 在副作用函数中使用的变量应该添加为函数的参数，或者使用rememberUpdateState包裹起来。</p></blockquote>

<p>在上面展示的DisposbaleEffect代码中，在代码块中使用的变量lifecycleOwner作为副作用函数的一个参数，因为它们的任何变化都会引发重启副作用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">HomeScreen</span><span class="p">(</span>
</span><span class='line'>    <span class="n">lifecycleOwner</span><span class="p">:</span> <span class="n">LifecycleOwner</span> <span class="p">=</span> <span class="n">LocalLifecycleOwner</span><span class="p">.</span><span class="n">current</span><span class="p">,</span>
</span><span class='line'>    <span class="n">onStart</span><span class="p">:</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">,</span> <span class="c1">// Send the &#39;started&#39; analytics event</span>
</span><span class='line'>    <span class="n">onStop</span><span class="p">:</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Unit</span> <span class="c1">// Send the &#39;stopped&#39; analytics event</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 这些值在组合中永不会变化，因此用remember包裹起来，以免引发冗余重启</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">currentOnStart</span> <span class="k">by</span> <span class="n">rememberUpdatedState</span><span class="p">(</span><span class="n">onStart</span><span class="p">)</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">currentOnStop</span> <span class="k">by</span> <span class="n">rememberUpdatedState</span><span class="p">(</span><span class="n">onStop</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">DisposableEffect</span><span class="p">(</span><span class="n">lifecycleOwner</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">observer</span> <span class="p">=</span> <span class="n">LifecycleEventObserver</span> <span class="p">{</span> <span class="n">_</span><span class="p">,</span> <span class="n">event</span> <span class="p">-&gt;</span>
</span><span class='line'>            <span class="cm">/* ... */</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">lifecycleOwner</span><span class="p">.</span><span class="n">lifecycle</span><span class="p">.</span><span class="n">addObserver</span><span class="p">(</span><span class="n">observer</span><span class="p">)</span>
</span><span class='line'>        <span class="n">onDispose</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">lifecycleOwner</span><span class="p">.</span><span class="n">lifecycle</span><span class="p">.</span><span class="n">removeObserver</span><span class="p">(</span><span class="n">observer</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>currentOnState和currentOnStop不需要作为DisposableEffect的参数key，因为使用了rememberUpdateState它们在组合中始终不会变化。如果不把lifecycleOwner作为参数传递，然后它又发生了变化，HomeScreen会重组，但DisposableEffect不会被清理和重启。这会导致之后使用的都是错误的lifecyleOwner（译注：因为lifecycleOwner可能会发生变化）。</p>

<h3>常量作为key</h3>

<p>可以使用像true这样的常量当作副作用的key，以让它跟它所在的调用点有一样的生命周期。有一些场景适合这样用：比如前面例子中的LaunchedEffect。但是，在这样做之前还是要三思是否真的要这样。</p>

<h2>总结</h2>

<p>函数式编程的理想情况是每个函数都没有副作用，但实际情况副作用却是必须的。通过本文我们学习了如何使用Jetpack Compose提供的副作用函数以解决修改composable范围以外的状态的问题。副作用问题比较难以实现且容易产生难以debug的问题，要仔细分析问题的场景，根据场景选择合适的副作用函数。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[贡献法算法总结]]></title>
    <link href="http://toughcoder.net/blog/2024/08/18/credit-algorithm-made-easy/"/>
    <updated>2024-08-18T12:57:52+08:00</updated>
    <id>http://toughcoder.net/blog/2024/08/18/credit-algorithm-made-easy</id>
    <content type="html"><![CDATA[<p>贡献法是一种比较偏门的算法，与贪心类似，并没有固定的范式，思路也非常的清奇。用朴素的方式通常会超时，或者甚至整理不出来思路，无法实现编码。</p>

<p>这类算法题型，更多的还是要靠经验和思维，遇到类似的题目就往贡献法上想。</p>

<p><img src="https://www.investopedia.com/thmb/J33BG-Cf03bW8-O4kXJfuht3gHA=/1500x0/filters:no_upscale():max_bytes(150000):strip_icc()/algorithm-df9b57e8ea7c494b891da25987643fab.jpg" alt="banner" /></p>

<!-- more -->


<p>总的来说，贡献法就是不直接思考如何做运算，而是运算之后净增量或者净减少量，或者当前元素在运行过后对净增量或者净减量的贡献值是多少，从这个角度去思考。</p>

<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sum-of-subsequence-widths/description/">891. 子序列宽度之和</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sum-of-subsequence-widths/solutions/2809957/xi-you-yuan-su-891-zi-xu-lie-kuan-du-zhi-igda/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sum-of-subarray-minimums/description/">907. 子数组的最小值之和</a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/distribute-coins-in-binary-tree/description/">979. 在二叉树中分配硬币</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/distribute-coins-in-binary-tree/solutions/2770062/xi-you-yuan-su-979-zai-er-cha-shu-zhong-xg0ef/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-subarray-min-product/description/">1856. 子数组最小乘积的最大值</a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sum-of-subarray-ranges/description/">2104. 子数组范围和</a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sum-of-total-strength-of-wizards/description/">2281. 巫师的总力量和</a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/power-of-heroes/description/">2681. 英雄的力量</a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://blog.csdn.net/weixin_60033897/article/details/136580127">算法学习系列（四十）：贡献法</a></li>
<li><a href="https://blog.csdn.net/qq_43406895/article/details/131514319">【算法】贡献法相关题目练习</a></li>
<li><a href="https://juejin.cn/post/7350185416652275712">贡献法（总体之和等于个体贡献度之和）（蓝桥杯）</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『损则有孚』| Lifecycle]]></title>
    <link href="http://toughcoder.net/blog/2024/08/18/jetpack-compose-lifecycle/"/>
    <updated>2024-08-18T12:14:35+08:00</updated>
    <id>http://toughcoder.net/blog/2024/08/18/jetpack-compose-lifecycle</id>
    <content type="html"><![CDATA[<blockquote><p>这篇文章大部分是<a href="https://developer.android.com/develop/ui/compose/lifecycle">官方文档</a>的翻译，但并不是严格的翻译，同时也加入了笔者自己的理解。</p></blockquote>

<p>通过前面的一系列文章我们已经基本掌握了使用Jetpack Compose来构建UI的方法，在接下来的几篇文章中将重点转移到Compose本身，理解一下Compose是如何把一坨坨的函数（Composables）转化成为目标平台UI的。先从composable的生命周期开始。</p>

<p><a href="http://toughcoder.net/blog/2024/08/18/jetpack-compose-lifecycle/"><img src="https://koenig-media.raywenderlich.com/uploads/2022/05/LifecycleOfComposablesInJetpackCompose-twitter.png" title="auto auto" ></a></p>

<!-- more -->


<p><strong>注意：</strong> 这里的生命周期是指Compose中的基本单元composable函数的生命周期，与目标平台（如Android）的生命周期不是一个概念，没有关系。</p>

<h2>概述</h2>

<p>在前面<a href="https://juejin.cn/post/7376094685495001139">讲解状态（State）的文章</a>中提到过，composable函数是Jetpack Compose的基本单元，运行composables就是组合（Composition），组合将会变成应用的UI。</p>

<p>当Jetpack Compose首次运行composables时，也即首次组合（Initial composition），它会追踪在组合中用来描述UI的composables。之后，当有状态变化时，Jetpack Compose会安排重组。重组就是重新执行状态发生变化的composables以作为对状态变化的响应，然后再更新组合体现变更。</p>

<p>组合仅能在首次组合过程中生成然后在重组中更新。修改组合的唯一方式就是通过重组。</p>

<h2>生命周期定义</h2>

<p>一个composable的生命周期可以用三个事件来定义：进入组合，重组，离开组合。</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-composition.png" alt="lifecycle" /></p>

<blockquote><p>图1. 组合中的一个composable的生命周期：进入组合，没有重组或者重组多次，最后离开组合。</p></blockquote>

<p>重组通常都是由状态对象发生变化触发的。Compose会追踪这些状态然后执行在组合中读取这些状态的所有composables，以及被这些composables调用的且无法被跳过的composables。</p>

<p><strong>注意：</strong> Composable的生命周期较View系统和Android平台的Activity以及Fragment要相对简单一些。如果一个composable需要处理外部的资源或者管理更为复杂的生命周期，可以使用副作用（Side Effects）。</p>

<p>如果一个composable被调用了多次，就会有多个实例被放入到组合之中。每一次调用都有独立的属于它自己的生命周期。来看一个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">MyComposable</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Column</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span><span class="s">&quot;World&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-hierarchy.png" alt="composition" /></p>

<blockquote><p>图2. 在组合中MyComposable的可视化表示。如果一个composable被调用了多次，会在组合中生成多个实例。图中不同颜色的元素代表不同的实例。</p></blockquote>

<h2>剖析组合中的composables</h2>

<p>组合中一个composable实例是用其调用点来标识的。Compose编译器认为每个调用点都是不一样的。从多个调用点调用composables会在组合中创建多个实例。</p>

<p><strong>关键术语：</strong> 调用点指的是composable被调用的代码位置。调用点会影响组合，进而影响最终UI。</p>

<p>在重组过程中，如果一个composable调用了与其上一次重组中调用的不同的composables，Compose会标识出哪些composables已调用过，哪些还未被调用过，对于两次组合中都调用了的composables，如果它们的输入没有变化则Compose不会予以执行。</p>

<p>因此，给关联到composable的副作用（各种Side Effects）指定标识就显得龙为重要，这样它们能成功的执行完成，而不是每次重组时都重新启动。</p>

<p>对于下面这个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">LoginScreen</span><span class="p">(</span><span class="n">showError</span><span class="p">:</span> <span class="n">Boolean</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">showError</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">LoginError</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">LoginInput</span><span class="p">()</span> <span class="c1">// This call site affects where LoginInput is placed in Composition</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">LoginInput</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">LoginError</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码中，函数LoginScreen会在一定条件下调用函数LogginError，并且总是会调用函数LoginInput。每个调用都有一个独一无二的调用点和代码位置，编译器正是用这些信息来独一无二的标识每个composable。
<img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-showerror.png" alt="recomposition" /></p>

<blockquote><p>图3. 在组合中，当有状态变化和重组发生时，LoginScreen的可视化展示。相同的颜色元素代表没有被重组。</p></blockquote>

<p>尽管LoginInput从第一个被调用的函数变成了第二个被调用的函数，它的实例在重组中得以留存。并且，因为LoginInput并没有在重组之间发生变化的参数，Compose会跳过对LoginInput的再次调用。</p>

<h2>提供额外的信息以优化重组</h2>

<p>多次调用一个composable会在组合中添加多个实例。当在同一个调用点多次调用同一个composable时，因为Compose没有可用的信息来独一无二的标识每个调用，所以composable的执行顺序被用以区别这些composable实例。有些时候这也够用了，但有些时候这会导致一些非预期的行为。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">MoviesScreen</span><span class="p">(</span><span class="n">movies</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Movie</span><span class="p">&gt;)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Column</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">movie</span> <span class="k">in</span> <span class="n">movies</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// MovieOverview composables are placed in Composition given its</span>
</span><span class='line'>            <span class="c1">// index position in the for loop</span>
</span><span class='line'>            <span class="n">MovieOverview</span><span class="p">(</span><span class="n">movie</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中，Compose会用执行顺序来区别调用的composable实例。如果一个新的数据元素movie被添加到了列表的底部（最后面），Compose可以复用已经在组合中的实例，因为它们的位次没有变化，故而这些composable的输入数据元素movie并不会变化，也就是说因为只在最后添加，先前存在的实例与其数据还是能够对应得上的。</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-newelement-bottom.png" alt="no_key" /></p>

<blockquote><p>图4. 当一个新数据元素moviei添加到列表底部后时，组合中MovieScreen的可视化表示。组合中函数MovieOverview的实例会被复用。相同颜色的元素表示未被重组。</p></blockquote>

<p>然而，如果输入列表的变化是在其顶部添加新元素，或者在中间添加新元素，或者有移除，或者变化元素顺序时，就会对列表中位置发生变化的所有MovieOverview进行重组。如果有储如在MovieOverview中获取电影图片的副作用函数的话，这些仅因位置改变而发生的重组就特别重要了。因为重组会影响副作用函数，如果副作用正在进行中，会被取消然后重新启动。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">MovieOverview</span><span class="p">(</span><span class="n">movie</span><span class="p">:</span> <span class="n">Movie</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Column</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// Side effect explained later in the docs. If MovieOverview</span>
</span><span class='line'>        <span class="c1">// recomposes, while fetching the image is in progress,</span>
</span><span class='line'>        <span class="c1">// it is cancelled and restarted.</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">image</span> <span class="p">=</span> <span class="n">loadNetworkImage</span><span class="p">(</span><span class="n">movie</span><span class="p">.</span><span class="n">url</span><span class="p">)</span>
</span><span class='line'>        <span class="n">MovieHeader</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="cm">/* ... */</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-newelement-top-all-recompose.png" alt="side_effect" /></p>

<blockquote><p>图5. 新元素添加到列表中时组合中MovieScreen的可视化表示。MovieScreen实例无法复用，所有的副作用会重启。不同的颜色代表发生了重组。</p></blockquote>

<p>理想情况下，应该让函数MovieScreen的实例标识与其数据项的标识联系起来。如果列表数据项顺序有变化，最为想理的办法是也把组合树中的对应的函数实例进行次序调整，而不是进行重组（前面说了次序作为函数实例的标识，次序变了，就要使用新位置的数据项调用composable进行重组）。Compose给我们提供了一个方法用以标识组会树中的函数实例：即<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#key(kotlin.Array,kotlin.Function0">函数key</a>)。</p>

<p>把代码块放入函数key里面，再传给函数key一些数据，这些数据会被组合起来以标识组合中的函数实例。传给函数key的数据不必是全局唯一的，它只需要在key所在的调用点是唯一的就行。比如在前面例子中，每个数据项movie需要有一个唯一的标识，它能在这个列表中唯一标识一部电影就可以了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">MoviesScreenWithKey</span><span class="p">(</span><span class="n">movies</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Movie</span><span class="p">&gt;)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Column</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">movie</span> <span class="k">in</span> <span class="n">movies</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">key</span><span class="p">(</span><span class="n">movie</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Unique ID for this movie</span>
</span><span class='line'>                <span class="n">MovieOverview</span><span class="p">(</span><span class="n">movie</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>像上面用了key以后，无论列表怎么变化，Compose都能辩识出具体composable实例，然后加以复用：
<img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-newelement-top-keys.png" alt="key" /></p>

<blockquote><p>图6. 当新数据元素添加到列表时组合中MovieScreen的可视化展示。因为有了唯一标识，Compose能识别出哪些实例未发生变化，加以复用，它们附带的副作用会继续执行。</p></blockquote>

<p><strong>关键点：</strong> 适度的使用函数key来帮助Compose唯一标识函数实例。特别是针对在同一个调用点大量调用同一个composable时，比如在各种集合性布局中。</p>

<p>有些composable有更为友好的key支持方法。比如像LazyColumn它可以直接在其items DSL中传入一个lambda作为key：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">MoviesScreenLazy</span><span class="p">(</span><span class="n">movies</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Movie</span><span class="p">&gt;)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">LazyColumn</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">items</span><span class="p">(</span><span class="n">movies</span><span class="p">,</span> <span class="n">key</span> <span class="p">=</span> <span class="p">{</span> <span class="n">movie</span> <span class="p">-&gt;</span> <span class="n">movie</span><span class="p">.</span><span class="n">id</span> <span class="p">})</span> <span class="p">{</span> <span class="n">movie</span> <span class="p">-&gt;</span>
</span><span class='line'>            <span class="n">MovieOverview</span><span class="p">(</span><span class="n">movie</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>重组时跳过composable的策略</h2>

<p>在重组过程中，一些具备条件的composable函数可以让Compose跳过他们的执行，如果它们的输入参数较前一次组合时没有任何变化。
除了以下情况外，就可以说一个composable函数具备跳过条件：</p>

<ul>
<li>函数有返回值（non-Unit return type）</li>
<li>函数使用了注解&#64;NonRestartableComposable或者&#64;NonSkippableComposable修饰</li>
<li>必需的参数是一个非稳定类型（non-stable type）</li>
</ul>


<p>前两个都好理解，接下来重点看第三个情况。一个类型要想成为稳定的（stable），必须符合以下约定：</p>

<ul>
<li>对于两个相内实例来说，对其们使用equals方法的返回值必须永远相同</li>
<li>如果一个类型的公开属性发生变化，组合会得到通知</li>
<li>所有公开属性类型也必须是稳定的</li>
</ul>


<p>有一些重要的常见类型符合这个约定，Compose编译器会把它们当成稳定的类型，尽管他们并没有使用注解&#64;Stable显式地标注为稳定的：</p>

<ul>
<li>所有的基础数据类型：布尔（Boolean），整数（Int），长整数（Long），浮点（Float），字符（Char）等</li>
<li>字符串（String）</li>
<li>所有的函数类型（lambdas）</li>
</ul>


<p>所有这些类型都能符合稳定约定，因为他们都是不可变类型。因为不可变类型实例不会改变，它们不会通知组合说值有所改变，因此就能符合上述约定。</p>

<p><strong>注意：</strong> 所有的整体不可变类型都可以安全地当成稳定的类型。</p>

<p>一个值得注意的类型是可变状态类型（MutableState），虽然是稳定的但却可变可修改。如果MutableState中持有一个值，这个状态对象被认为是稳定的，因为State属性.value发生的任何变化都会通知给Compose。</p>

<p>当作为传递给一个composable函数参数的所有类型都是稳定的（stable）时，这些参数的值会基于它们在UI树中的函数位置进行等值比较（equality）。从前一次组合起如果值未变化就会跳过其重组。换句话说输入参数的类型是稳定的（stable）是一个大前提，只有稳定的类型比较等值才有意义。</p>

<p><strong>关键点：</strong> 如果一个composable的输入是稳定的且未有变化，Compose就会跳过它的重组。等值比较使用的是方法equals。</p>

<p>仅当Compose能够证明一个类型是稳定的时，才会把一个类型当作稳定的。例如，接口（interface）通常认为是不稳定的，拥有可变公开属性的类型，虽然这些属性的实现可以是不可变的，但这种类型也认为是不稳定的。</p>

<p>如果Compose无法推断出一个类型是不是稳定的，但是想强制它被当作稳定的类型，可以使用注解&#64;Stable来标注。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="c1">// Marking the type as stable to favor skipping and smart recompositions.</span>
</span><span class='line'><span class="n">@Stable</span>
</span><span class='line'><span class="n">interface</span> <span class="n">UiState</span><span class="p">&lt;</span><span class="n">T</span> <span class="p">:</span> <span class="n">Result</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">value</span><span class="p">:</span> <span class="n">T</span><span class="p">?</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">exception</span><span class="p">:</span> <span class="n">Throwable</span><span class="p">?</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">val</span> <span class="py">hasError</span><span class="p">:</span> <span class="n">Boolean</span>
</span><span class='line'>        <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="n">exception</span> <span class="p">!=</span> <span class="k">null</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码片段中，因为UiState是一个接口，会被当成不稳定的类型。通过添加注解&#64;Stable，告诉Compose它是稳定的，让Compose进行智能重组。这也意味着，当接口类型用于参数类型时，Compose会把接口的所有具体实现当成稳定的类型。</p>

<p><strong>关键点：</strong> 如果Compose无法推断出类型的稳定性，使用注解&#64;Stable来标注以让Compose进行智能重组。</p>

<h2>总结</h2>

<p>Composable函数是Compose的基本单元，通过此文我们理解了一个composable的生命周期，并对Compose的重组机制做了介绍，以及如何更好的让Compose做智能重组。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/lifecycle">Lifecycle of composables</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『密云不雨』| Navigation]]></title>
    <link href="http://toughcoder.net/blog/2024/08/12/navigation-with-compose/"/>
    <updated>2024-08-12T07:46:31+08:00</updated>
    <id>http://toughcoder.net/blog/2024/08/12/navigation-with-compose</id>
    <content type="html"><![CDATA[<p>除了一些玩具性的Demo以外，相信任何一个应用程序不可能只有一个页面，最为极简的应用也至少会有两个页面，一个主页和一个设置页。对于传统的View系统来说对于导航这块没有专门的API，一般都是自己写逻辑跳Activity，或者跳到Fragment，然后再反向的Back，所以有了很多三方的各种Router类库（如大阿里的ARouter，货拉拉的TheRouter）。其实谷歌已经提供了解决方案，在Jetpack中提供了<a href="https://developer.android.com/guide/navigation">Navigation组件</a>，专门用于解决应用内部各种页面之间跳转的问题。</p>

<p><a href="http://toughcoder.net/blog/2024/08/12/navigation-with-compose/"><img src="https://blog.mindorks.com/images/banner-jetpack-compose-navigation-657edc7b323cafdf.png" title="auto auto" ></a></p>

<!-- more -->


<p>对于Jetpack Compose来说，因为是全新的框架，在设计之初就考虑到了导航的问题，但也不是重新开发了一套新库，而是把Jetpack中的组件Navigation深度的结合了进来。换句话说，在Jetpack Compose中可以直接使用Navigation组件来进行页面之间的跳转，并且有非常符合Compose的粘合API，使用起来非常的丝滑顺手。</p>

<h2>基本概念</h2>

<p>在深入之前有必要先澄清Navigation中的一些概念，了解了一些基本的概念和术语之后，会有助于理解组件的设计理念，也会更容易上手使用。</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 术语 </th>
<th style="text-align:left;"> 用途 </th>
<th style="text-align:left;"> 具体的Composable </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> Host </td>
<td style="text-align:left;"> 包含了当前导航页面的容器。应该把它理解成为导航的容器，包含着当前的页面， 以及一个NavController。 </td>
<td style="text-align:left;"> <a href="https://developer.android.com/reference/kotlin/androidx/navigation/compose/package-summary#NavHost(androidx.navigation.NavHostController,androidx.navigation.NavGraph,androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1">NavHost</a>) </td>
</tr>
<tr>
<td style="text-align:center;"> Graph </td>
<td style="text-align:left;"> 静态的数组结构，定义着一个应用中的所有页面，以及它们之间应该如何跳转。 </td>
<td style="text-align:left;"> <a href="https://developer.android.com/reference/androidx/navigation/NavGraph">NavGraph</a> </td>
</tr>
<tr>
<td style="text-align:center;"> Controller </td>
<td style="text-align:left;"> 页面之间导航的核心管理者。它封装着如何在页面之间跳转的方法，处理链接的方法，以及返回堆栈的方法。 </td>
<td style="text-align:left;"> <a href="https://developer.android.com/reference/androidx/navigation/NavController">NavController</a> </td>
</tr>
<tr>
<td style="text-align:center;"> Destination </td>
<td style="text-align:left;"> 在Graph中的一个节点。当跳转到这个节点时，Host中就包含并展示它的页面。在实际项目中，往往是一个Fragment或者一个Composable，也就是一个页面。 </td>
<td style="text-align:left;"> <a href="https://developer.android.com/reference/androidx/navigation/NavDestination">NavDestination</a> </td>
</tr>
<tr>
<td style="text-align:center;"> Route </td>
<td style="text-align:left;"> Destination的全局唯一标识，包括其所需要的参数。大部分时候，特别是在Compose中，这就是一坨类似于Uri一样的String </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p>还需要说明一下的就是导航的基本的操作对象是一个页面，一个页面可以理解为一个全屏的，逻辑上内聚，内容上互相关联，自成一家的一个UI页面，比如说一个应用的主页是一个页面，文章列表是一个页面，文章详情是一个页面，设置是一个页面，用户页又是一个页面。当然，这里全屏并不是直观的全屏，意思是说（特别是对于Compose）一个页面的大小是受系统控制的，并不能像普通的Composable那样随意设置大小，对于手机就是全屏的，对于平板可能会一个占据三分之一（列表页），一个占据三分之二（详情页）。</p>

<h2>使用Navigation</h2>

<p>Jetpack Compose是声明式UI，是函数式编程，每一个Composable都是一个函数，所以在Compose中使用Navigation略微的有点不一样。核心原理和核心的规则肯定与Navigation是一样一样的，只是使用上的API略不一样，其实是更简单更方便了（这是声明式UI带来的收益）。</p>

<h3>添加依赖</h3>

<p>在使用之前先要添加Navigation库作为项目的依赖：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">dependencies</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">navVersion</span> <span class="p">=</span> <span class="s">&quot;2.7.7&quot;</span>
</span><span class='line'>    <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;androidx.navigation:navigation-runtime-ktx:$navVersion&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;androidx.navigation:navigation-compose:$navVersion&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>使用Navigation的方法</h3>

<p>可以通过以下步骤来使用Navigation：</p>

<ul>
<li>创建NavHost，并设置为应用的入口，通过Composable函数<a href="https://developer.android.com/reference/kotlin/androidx/navigation/compose/package-summary#NavHost(androidx.navigation.NavHostController,androidx.navigation.NavGraph,androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1">NavHost</a>)。</li>
<li>创建NavController，可以直接创建，但推荐的方式是使用Compose提供的状态构造函数<a href="https://developer.android.com/reference/kotlin/androidx/navigation/compose/package-summary#rememberNavController(kotlin.Array">rememberNavController</a>)，它的好处在于当前导航会提升为一个状态。</li>
<li>定义Destination和Route，其实对于Compose来说都是用类似于Uri的String来作为Destination，每一个Destition唯一对应着一个页面。</li>
<li>添加页面，通过函数NavHost的尾部lambda，它实际上是一个<a href="https://developer.android.com/reference/kotlin/androidx/navigation/NavGraphBuilder">NavGraphBuilder</a>的扩展函数，这里调用函数<a href="https://developer.android.com/reference/kotlin/androidx/navigation/compose/package-summary#(androidx.navigation.NavGraphBuilder">composable</a>.composable(kotlin.collections.Map,kotlin.collections.List,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function2))来添加页面。</li>
<li>配置跳转，通过前面创建的navController来实现跳转，用<a href="https://developer.android.com/reference/kotlin/androidx/navigation/NavController#navigate(android.net.Uri">navController.navigate</a>)来跳转到指定的Destination，用<a href="https://developer.android.com/reference/androidx/navigation/NavController#popBackStack(">navController.popBackStack</a>)来返回到前一个页面。而触发的入口肯定是在具体的页面之中，所以页面要把其跳转函数作为参数，在NavGraphBuilder时，再用NavController去实现，这样所有的跳转逻辑就都在NavGraph中，便于管理。</li>
</ul>


<h3>具体实例</h3>

<p>说了那么多貌似挺烦杂的，让我们看一个实例就会瞬间明白。</p>

<p>一个简单的应用有4个页面，先定义Destinations：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">object</span> <span class="nc">Destinations</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">const</span> <span class="k">val</span> <span class="py">APP_URI</span> <span class="p">=</span> <span class="s">&quot;http://toughcoder.net/chronos&quot;</span>
</span><span class='line'>    <span class="n">const</span> <span class="k">val</span> <span class="py">HOME_ROUTE</span> <span class="p">=</span> <span class="s">&quot;home&quot;</span> <span class="c1">// 主页</span>
</span><span class='line'>    <span class="n">const</span> <span class="k">val</span> <span class="py">HISTORY_ROUTE</span> <span class="p">=</span> <span class="s">&quot;history&quot;</span> <span class="c1">// 历史记录页面</span>
</span><span class='line'>    <span class="n">const</span> <span class="k">val</span> <span class="py">SETTINGS</span> <span class="p">=</span> <span class="s">&quot;settings&quot;</span> <span class="c1">// 设置页</span>
</span><span class='line'>    <span class="n">const</span> <span class="k">val</span> <span class="py">ARTICLES</span> <span class="p">=</span> <span class="s">&quot;articles&quot;</span> <span class="c1">// 文章页</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么就可以如此配置Navigation：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">ChronosNavGraph</span><span class="p">(</span>
</span><span class='line'>    <span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">,</span>
</span><span class='line'>    <span class="n">navController</span><span class="p">:</span> <span class="n">NavHostController</span> <span class="p">=</span> <span class="n">rememberNavController</span><span class="p">(),</span>
</span><span class='line'>    <span class="n">start</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="n">Destinations</span><span class="p">.</span><span class="n">HOME_ROUTE</span> <span class="c1">// 默认的初始页面为主页</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NavHost</span><span class="p">(</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">modifier</span><span class="p">,</span>
</span><span class='line'>        <span class="n">navController</span> <span class="p">=</span> <span class="n">navController</span><span class="p">,</span>
</span><span class='line'>        <span class="n">startDestination</span> <span class="p">=</span> <span class="n">start</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">composable</span><span class="p">(</span>
</span><span class='line'>            <span class="n">route</span> <span class="p">=</span> <span class="n">Destinations</span><span class="p">.</span><span class="n">HOME_ROUTE</span><span class="p">,</span>
</span><span class='line'>            <span class="n">deepLinks</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span>
</span><span class='line'>                <span class="n">navDeepLink</span> <span class="p">{</span> <span class="n">uriPattern</span> <span class="p">=</span> <span class="s">&quot;${Destinations.APP_URI}/${Destinations.HOME_ROUTE}&quot;</span> <span class="p">}</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>        <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">ChronosScreen</span><span class="p">(</span>
</span><span class='line'>                <span class="n">gotoSettings</span> <span class="p">=</span> <span class="p">{</span> <span class="n">navController</span><span class="p">.</span><span class="n">navigate</span><span class="p">(</span><span class="n">Destinations</span><span class="p">.</span><span class="n">SETTINGS</span><span class="p">)</span> <span class="p">},</span>
</span><span class='line'>                <span class="n">gotoHistory</span> <span class="p">=</span> <span class="p">{</span> <span class="n">navController</span><span class="p">.</span><span class="n">navigate</span><span class="p">(</span><span class="n">Destinations</span><span class="p">.</span><span class="n">HISTORY_ROUTE</span><span class="p">)</span> <span class="p">},</span>
</span><span class='line'>                <span class="n">gotoArticles</span> <span class="p">=</span> <span class="p">{</span> <span class="n">navController</span><span class="p">.</span><span class="n">navigate</span><span class="p">(</span><span class="n">Destinations</span><span class="p">.</span><span class="n">ARTICLES</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">composable</span><span class="p">(</span>
</span><span class='line'>            <span class="n">route</span> <span class="p">=</span> <span class="n">Destinations</span><span class="p">.</span><span class="n">HISTORY_ROUTE</span><span class="p">,</span>
</span><span class='line'>            <span class="n">deepLinks</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span>
</span><span class='line'>                <span class="n">navDeepLink</span> <span class="p">{</span> <span class="n">uriPattern</span> <span class="p">=</span> <span class="s">&quot;${Destinations.APP_URI}/${Destinations.HISTORY_ROUTE}&quot;</span> <span class="p">}</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>        <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">HistoryScreen</span><span class="p">(</span>
</span><span class='line'>                <span class="n">viewModel</span> <span class="p">=</span> <span class="n">viewModel</span><span class="p">()</span>
</span><span class='line'>            <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">navController</span><span class="p">.</span><span class="n">popBackStack</span><span class="p">()</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">composable</span><span class="p">(</span>
</span><span class='line'>            <span class="n">route</span> <span class="p">=</span> <span class="n">Destinations</span><span class="p">.</span><span class="n">SETTINGS</span><span class="p">,</span>
</span><span class='line'>            <span class="n">deepLinks</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span>
</span><span class='line'>                <span class="n">navDeepLink</span> <span class="p">{</span> <span class="n">uriPattern</span> <span class="p">=</span> <span class="s">&quot;${Destinations.APP_URI}/${Destinations.SETTINGS}&quot;</span> <span class="p">}</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>        <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">SettingsScreen</span><span class="p">(</span>
</span><span class='line'>                <span class="n">viewModel</span> <span class="p">=</span> <span class="n">viewModel</span><span class="p">()</span>
</span><span class='line'>            <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">navController</span><span class="p">.</span><span class="n">popBackStack</span><span class="p">()</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">composable</span><span class="p">(</span>
</span><span class='line'>            <span class="n">route</span> <span class="p">=</span> <span class="n">Destinations</span><span class="p">.</span><span class="n">ARTICLES</span><span class="p">,</span>
</span><span class='line'>            <span class="n">deepLinks</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span>
</span><span class='line'>                <span class="n">navDeepLink</span> <span class="p">{</span> <span class="n">uriPattern</span> <span class="p">=</span> <span class="s">&quot;${Destinations.APP_URI}/${Destinations.ARTICLES}&quot;</span> <span class="p">}</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>        <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">ArticlesScreen</span><span class="p">(</span>
</span><span class='line'>                <span class="n">viewModel</span> <span class="p">=</span> <span class="n">viewModel</span><span class="p">()</span>
</span><span class='line'>            <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">navController</span><span class="p">.</span><span class="n">popBackStack</span><span class="p">()</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到每一个composable函数用以创建一个导航页面，里面有其Route，具体的页面，以及跳转的入口函数。deepLinks是每个页面的Uri式的链接，后面会详细的讲解。</p>

<p>最后就是把这个NavGraph作为应用的入口页面：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="n">Bundle</span><span class="p">?)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">super</span><span class="p">.</span><span class="n">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">)</span>
</span><span class='line'>        <span class="n">setContent</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">ChronosTheme</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">Surface</span><span class="p">(</span>
</span><span class='line'>                    <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">(),</span>
</span><span class='line'>                    <span class="n">color</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">colorScheme</span><span class="p">.</span><span class="n">background</span>
</span><span class='line'>                <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">ChronosNavGraph</span><span class="p">()</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>在页面之间传递参数</h2>

<p>页面跳转还必然会涉及参数的传递，比如具有递进关系的两个页面，核心参数肯定要由前一个页传递过去，最为典型的场景就是列表类页面到详情页面的跳转，比如文章列表要把文章的Id传给详情页，这样详情页才知道去展示哪个文章，用户列表要把用户Id传给详情页，详情页才知道展示哪个用户。</p>

<p>Navigation提供了传递参数的方法，在创建导航页面时传入的Route可以加入占位符形参，然后在跳转navController.navigate时可以传入实参，只不过参数的类型有限制，只能是基础数据类型如字串或者数字。目标页面使用时通过backStackEntry.arguments来获得参数。来具体看一下，比如说传递用户Id的场景：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">NavHost</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">composable</span><span class="p">(</span>
</span><span class='line'>          <span class="s">&quot;profile/{userId}&quot;</span><span class="p">,</span>
</span><span class='line'>          <span class="n">arguments</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="n">navArgument</span><span class="p">(</span><span class="s">&quot;userId&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="k">type</span> <span class="p">=</span> <span class="n">NavType</span><span class="p">.</span><span class="n">StringType</span> <span class="p">}</span> <span class="c1">// 这句可以省略，因为默认类型都当成是字符串</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span> <span class="n">backStackEntry</span> <span class="p">-&gt;</span>
</span><span class='line'>          <span class="n">Profile</span><span class="p">(</span><span class="n">navController</span><span class="p">,</span> <span class="n">backStackEntry</span><span class="p">.</span><span class="n">arguments</span><span class="o">?.</span><span class="n">getString</span><span class="p">(</span><span class="s">&quot;userId&quot;</span><span class="p">))</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面参数类型的声明，其实可以省略，因为默认的类型都当成String来解析和处理，如果是其他类型则需要显式地声明。这样目标页面的参数就声明好了，我们在跳转的时候传入实参就可以了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">navController</span><span class="p">.</span><span class="n">navigate</span><span class="p">(</span><span class="s">&quot;profile/user1234&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>大部分时候参数都是<strong>必填参数</strong>，像上面这样写userId是必填的参数。但有些时候一些非核心的参数，可能不是每次跳转都会传，这就需要页面把参数声明为<strong>可选参数</strong>。可选参数在声明的时候Uri中必须使用查询式语句，如（&#8221;?argName={argName}&ldquo;），另外必须 设置默认值，或者类型是nullable的。这也意味着我们不能省略导航页面构建composable函数中的arguments参数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">composable</span><span class="p">(</span>
</span><span class='line'>    <span class="s">&quot;profile?userId={userId}&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="n">arguments</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="n">navArgument</span><span class="p">(</span><span class="s">&quot;userId&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="n">defaultValue</span> <span class="p">=</span> <span class="s">&quot;user1234&quot;</span> <span class="p">})</span> <span class="c1">// 注意这里的默认值，当调用navigate时如果不传userId就用这个默认值</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span> <span class="n">backStackEntry</span> <span class="p">-&gt;</span>
</span><span class='line'>    <span class="n">Profile</span><span class="p">(</span><span class="n">navController</span><span class="p">,</span> <span class="n">backStackEntry</span><span class="p">.</span><span class="n">arguments</span><span class="o">?.</span><span class="n">getString</span><span class="p">(</span><span class="s">&quot;userId&quot;</span><span class="p">))</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>注意：</strong> 要尽可能的使用基本的数据类型，如String，Int或者Long，而不传递复杂的数据。复杂的数据通常都是业务逻辑数据，而业务逻辑数据应该使用基本的参数，再从数据源处（通常是通过ViewModel从Repo处）去主动获取，这样才能保证数据的真实有效。这是设计原则中的『单一数据源原则Single Source of Truth』。复杂数据从Repo处获取后，可能会变得过时或者失真，而且在页面之间传递会有拷贝，效率也不高，因此要避免在页面之间传递复杂数据。</p>

<h2>处理DeepLinks</h2>

<p>DeepLinks是Uri式的链接跳转范式，能够以字符串形式的Uri精准的定位到某个应用的具体某个页面，就犹如互联网中的Uri一样。它的好处在于形成了一个统一的标准，形式简单方便，一个字符串就能定位到一个页面。</p>

<p>使用导航页面构建函数composable在构建页面的时候可以传入<a href="https://developer.android.com/reference/androidx/navigation/NavDeepLink">NavDeepLink</a>对象，更为方便的是使用其构建函数<a href="https://developer.android.com/reference/kotlin/androidx/navigation/package-summary#navDeepLink(kotlin.Function1">navDeepLink</a>)：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">uri</span> <span class="p">=</span> <span class="s">&quot;https://www.example.com&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">composable</span><span class="p">(</span>
</span><span class='line'>    <span class="s">&quot;profile?id={id}&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="n">deepLinks</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="n">navDeepLink</span> <span class="p">{</span> <span class="n">uriPattern</span> <span class="p">=</span> <span class="s">&quot;$uri/{id}&quot;</span> <span class="p">})</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span> <span class="n">backStackEntry</span> <span class="p">-&gt;</span>
</span><span class='line'>    <span class="n">Profile</span><span class="p">(</span><span class="n">navController</span><span class="p">,</span> <span class="n">backStackEntry</span><span class="p">.</span><span class="n">arguments</span><span class="o">?.</span><span class="n">getString</span><span class="p">(</span><span class="s">&quot;id&quot;</span><span class="p">))</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从示例中可以看出Uri中还可以带有参数，形参的声明，以及参数的获取与前面提到的页面参数是一样一样的，如果实际传过来的Uri是&#8221;<a href="https://www.example.com/user123">https://www.example.com/user123</a>&#8220;，到此页面后，就能解析出参数id为user123。</p>

<p>正常情况下这些DeepLinks只能在应用内部使用，如果要对应用外开放，则需要在应用的AndroidManifest文件中进行声明，声明为intent filter：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;activity</span> <span class="err">…</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;intent-filter&gt;</span>
</span><span class='line'>    ...
</span><span class='line'>    <span class="nt">&lt;data</span> <span class="na">android:scheme=</span><span class="s">&quot;https&quot;</span> <span class="na">android:host=</span><span class="s">&quot;www.example.com&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/intent-filter&gt;</span>
</span><span class='line'><span class="nt">&lt;/activity&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>页面跳转过渡动画</h2>

<p>页面跳转可以指定具体的过渡动画，具体的可以参考<a href="https://juejin.cn/post/7385758285960609831#heading-10">前面专门讲动画的那篇文章</a>，这里就不再重复了。</p>

<h2>Route的类型安全</h2>

<p>通常情况下Route都是使用Uri式的String，但这明显不够安全，因为调用navController#navigate的时候，可能会传一个不认识的页面Route，或者参数传错了（比如数字参数传了String），等等。轻则跳转失败，因为找不到Destination页面，重则会Crash。要想类型安全，就不能使用String式的Uri，需要把Ruote定义为类型（也即class），但要使用注解&#64;Serializeable标记一下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="c1">// 主页面，不带任何参数</span>
</span><span class='line'><span class="n">@Serializable</span>
</span><span class='line'><span class="k">object</span> <span class="nc">Home</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 用户页面，参数是用户Id，其类型是一个String</span>
</span><span class='line'><span class="n">@Serializable</span>
</span><span class='line'><span class="n">data</span> <span class="k">class</span> <span class="nc">Profile</span><span class="p">(</span><span class="k">val</span> <span class="py">id</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在构建导航页面的时候，函数composable其实是一个泛型函数，它可以指定Route的参数类型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">NavHost</span><span class="p">(</span><span class="n">navController</span><span class="p">,</span> <span class="n">startDestination</span> <span class="p">=</span> <span class="n">Home</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="n">composable</span><span class="p">&lt;</span><span class="n">Home</span><span class="p">&gt;</span> <span class="p">{</span> <span class="c1">// 泛型函数，可以指定参数类型</span>
</span><span class='line'>         <span class="n">HomeScreen</span><span class="p">(</span><span class="n">onNavigateToProfile</span> <span class="p">=</span> <span class="p">{</span> <span class="n">id</span> <span class="p">-&gt;</span>
</span><span class='line'>             <span class="n">navController</span><span class="p">.</span><span class="n">navigate</span><span class="p">(</span><span class="n">Profile</span><span class="p">(</span><span class="n">id</span><span class="p">))</span> <span class="c1">// 跳转的时候传入的实参是一个对象，类型就是上面定义的Route</span>
</span><span class='line'>         <span class="p">})</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>     <span class="n">composable</span><span class="p">&lt;</span><span class="n">Profile</span><span class="p">&gt;</span> <span class="p">{</span> <span class="n">backStackEntry</span> <span class="p">-&gt;</span>
</span><span class='line'>         <span class="k">val</span> <span class="py">profile</span><span class="p">:</span> <span class="n">Profile</span> <span class="p">=</span> <span class="n">backStackEntry</span><span class="p">.</span><span class="n">toRoute</span><span class="p">()</span>  <span class="c1">// 获取参数的时候，用toRoute来获得Route对象，类型就是我们定义的那个</span>
</span><span class='line'>         <span class="n">ProfileScreen</span><span class="p">(</span><span class="n">profile</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在跳转的时候就可以把Route对象作为实参传进去：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">navController</span><span class="p">.</span><span class="n">navigate</span><span class="p">(</span><span class="n">Profile</span><span class="p">(</span><span class="n">id</span> <span class="p">=</span> <span class="m">123</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样因为都是定义的类型，所以编译器会做编译时检查，虚拟机也会做运行时的类型检查，保证类型安全。</p>

<p><strong>注意：</strong> 不要混淆，这里Route虽然是自定义类型，但并不算是在页面之间传递复杂的业务数据，因为具体的参数仍是诸如String和Int之类的基础数值。把Route定义为类型（class），而不是直接使用String，是为了让编译器帮忙我们保证类型安全，减少出错。</p>

<h2>总结</h2>

<p>使用Navigation可以非常轻松的把应用的各个页面组织连接起来，形成一个完整的交互闭环。谷歌也提供了相应的<a href="https://developer.android.com/codelabs/jetpack-compose-navigation#0">CodeLab</a>可以学习一下。此外，谷歌的一些Sample app，像<a href="https://github.com/android/sunflower/tree/main">Sunflower</a>和<a href="https://github.com/android/compose-samples/tree/main/JetNews">JetNews</a>也是使用Navigation来实现导航的，是非常好的学习案例。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/navigation">Navigation with Compose</a></li>
<li><a href="https://developer.android.com/guide/navigation">Navigation</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『时乘六龙』| Advanced Gestures]]></title>
    <link href="http://toughcoder.net/blog/2024/08/02/advanced-gesture-in-compose/"/>
    <updated>2024-08-02T07:46:30+08:00</updated>
    <id>http://toughcoder.net/blog/2024/08/02/advanced-gesture-in-compose</id>
    <content type="html"><![CDATA[<p>通过<a href="https://juejin.cn/post/7395020728623480841">前面的一篇文章</a>我们学会了如何用各种高级别抽象的扩展函数来进行手势处理。像clickable，draggable，scrollable和anchoredDraggable都是类似于View系统中的各种回调（如onClick或者onScroll）是高级别的抽象，这里我们只能处理手势，大部分情况下这也够用了。</p>

<p><a href="http://toughcoder.net/blog/2024/08/02/advanced-gesture-in-compose/"><img src="file:///Users/alexhilton/Downloads/compose_libs/gesture/advanced_gesture.jpeg" title="auto auto" ></a></p>

<!-- more -->


<p>但是，对于一些复杂的交互 场景需要我们先识别手势，然后再处理手势，这时就不能再用封装好的扩展函数了，而必须要用到像View系统中的onTouchEvent那样的低级别的回调，直接拿到触点事件，然后再识别手势，最后再处理手势。这篇文章就学习一下如何使用Jetpack Compose中的低级别函数来识别和处理手势。</p>

<h2>处理原始触点事件</h2>

<p>除了使用一些封装好了的扩展函数来直接处理某个手势以外，还可以直接接收原始的事件输入。</p>

<p>Jetpack Compose在Modifier中提供了扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/package-summary#(androidx.compose.ui.Modifier">pointerInput</a>.pointerInput(kotlin.Any,kotlin.Any,kotlin.coroutines.SuspendFunction1))来接收原始的触点事件，与View系统中的<a href="https://developer.android.com/reference/android/view/View.OnTouchListener">onTouch</a>是类似的，这是触点事件的低级别的API。通过此API能获得触点事件，之后可以进行手势识别和手势处理，因为拿到的是原始的触点事件，所以很多逻辑要自己写，有些麻烦，但因为完全可控，所以可以实现一些更为复杂的手势识别和手势处理，比如任意方向的拖拽和滑动，长按后的拖拽，多点触控等等。</p>

<h3>接收触点事件</h3>

<p>扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/package-summary#(androidx.compose.ui.Modifier">pointerInput</a>.pointerInput(kotlin.Any,kotlin.Any,kotlin.coroutines.SuspendFunction1))接收三个参数，前两个都是作为<strong>事件处理回调的标识（keys）</strong>，第三个参数是<strong>事件处理回调</strong>，是一个尾部lambda，当某个key发生变化，这个lambda会重新执行，否则即使发生重组（Recomposition），这个lambda也会不会重新执行。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">Modifier</span><span class="p">.</span><span class="n">pointerInput</span><span class="p">(</span><span class="n">key1</span><span class="p">:</span> <span class="n">Any</span><span class="p">?,</span> <span class="n">key2</span><span class="p">:</span> <span class="n">Any</span><span class="p">?,</span> <span class="n">block</span><span class="p">:</span> <span class="n">suspend</span> <span class="n">PointerInputScope</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">):</span> <span class="n">Modifier</span>
</span></code></pre></td></tr></table></div></figure>


<p>第三参数就是我们要提供的事件处理回调，它是运行在<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/PointerInputScope">PointerInputScope</a>上下文中的lambda，这个上下文作用域里面有很多扩展函数可以直接使用。仔细看这个lambda是suspend的，这是因为输入事件可能不是即时的，可能会有等待的情况，也就是说lambda是在有事件的时候才会执行。PointerInputScope中的函数也都定义为suspend的，这些函数在lambda中可以直接调用，所以lambda本身也必须 是suspend的。</p>

<p>比如说想要打印触点事件，就可以这样写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">private</span> <span class="k">fun</span> <span class="nf">LogPointerEvents</span><span class="p">(</span><span class="n">filter</span><span class="p">:</span> <span class="n">PointerEventType</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">log</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">Column</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span><span class="n">log</span><span class="p">)</span>
</span><span class='line'>        <span class="n">Box</span><span class="p">(</span>
</span><span class='line'>            <span class="n">Modifier</span>
</span><span class='line'>                <span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="m">100.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Red</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">pointerInput</span><span class="p">(</span><span class="n">filter</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">awaitPointerEventScope</span> <span class="p">{</span>
</span><span class='line'>                        <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                            <span class="k">val</span> <span class="py">event</span> <span class="p">=</span> <span class="n">awaitPointerEvent</span><span class="p">()</span>
</span><span class='line'>                            <span class="c1">// handle pointer event</span>
</span><span class='line'>                            <span class="k">if</span> <span class="p">(</span><span class="n">filter</span> <span class="p">==</span> <span class="k">null</span> <span class="p">||</span> <span class="n">event</span><span class="p">.</span><span class="k">type</span> <span class="p">==</span> <span class="n">filter</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                                <span class="n">log</span> <span class="p">=</span> <span class="s">&quot;${event.type}, ${event.changes.first().position}&quot;</span>
</span><span class='line'>                            <span class="p">}</span>
</span><span class='line'>                        <span class="p">}</span>
</span><span class='line'>                    <span class="p">}</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>filter是一个事件的类型参数当作key，也当作过滤条件。在事件处理回调lambda中，用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/AwaitPointerEventScope#awaitPointerEvent(androidx.compose.ui.input.pointer.PointerEventPass">awaitPointerEvent</a>)获得每一个触点事件，然后打印出来，<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/AwaitPointerEventScope">awaitPoniterEventScope</a>函数是创建一个协程上下文作用域用以等待事件输入，在其内调用awaitPointerEvent来获得事件。</p>

<h3>识别手势</h3>

<p>虽然pointerInput是一个低级别的接口，但也并不意味着所有的逻辑都必须从头写，在<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/PointerInputScope">PointerInputScope</a>中已经定义了大量的函数可以识别大部分手势：</p>

<ul>
<li>非连续性手势如单击（tap），双击（double tap）和长按（long press）：<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.input.pointer.PointerInputScope">detectTapGestures</a>.detectTapGestures(kotlin.Function1,kotlin.Function1,kotlin.coroutines.SuspendFunction2,kotlin.Function1))</li>
<li>拖拽（drag）：<a href="">detectDragGestures</a>，<a href="">detectDragGesturesAfterLongPress</a>，以及固定方向拖拽<a href="">detectHorizontalDragGestures</a>和<a href="">detectVerticalDragGestures</a></li>
<li>多点触控变幻的手势识别（旋转，平移和缩放）：<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.input.pointer.PointerInputScope">detectTransformGestures</a>.detectTransformGestures(kotlin.Boolean,kotlin.Function4))</li>
</ul>


<p>比如像<a href="https://juejin.cn/post/7395020728623480841">前面文章中</a>提到的拖拽也可以用pointerInput实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">private</span> <span class="k">fun</span> <span class="nf">DraggableTextLowLevel</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Box</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">var</span> <span class="py">offsetX</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="m">0f</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>        <span class="k">var</span> <span class="py">offsetY</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="m">0f</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">Box</span><span class="p">(</span>
</span><span class='line'>            <span class="n">Modifier</span>
</span><span class='line'>                <span class="p">.</span><span class="n">offset</span> <span class="p">{</span> <span class="n">IntOffset</span><span class="p">(</span><span class="n">offsetX</span><span class="p">.</span><span class="n">roundToInt</span><span class="p">(),</span> <span class="n">offsetY</span><span class="p">.</span><span class="n">roundToInt</span><span class="p">())</span> <span class="p">}</span>
</span><span class='line'>                <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Blue</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="m">50.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">pointerInput</span><span class="p">(</span><span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">detectDragGestures</span> <span class="p">{</span> <span class="n">change</span><span class="p">,</span> <span class="n">dragAmount</span> <span class="p">-&gt;</span>
</span><span class='line'>                        <span class="n">change</span><span class="p">.</span><span class="n">consume</span><span class="p">()</span>
</span><span class='line'>                        <span class="n">offsetX</span> <span class="p">+=</span> <span class="n">dragAmount</span><span class="p">.</span><span class="n">x</span>
</span><span class='line'>                        <span class="n">offsetY</span> <span class="p">+=</span> <span class="n">dragAmount</span><span class="p">.</span><span class="n">y</span>
</span><span class='line'>                    <span class="p">}</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/gestures-drag.gif" alt="detect_drag_demo" /></p>

<p>前面提到了像detectTapGestures和detectDragGestures都是suspend的函数，所以在一个pointerInter的lambda中只能有一个，比如像下面这样写detectDragGestures不会得到执行：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">var</span> <span class="py">log</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="n">Column</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Text</span><span class="p">(</span><span class="n">log</span><span class="p">)</span>
</span><span class='line'>    <span class="n">Box</span><span class="p">(</span>
</span><span class='line'>        <span class="n">Modifier</span>
</span><span class='line'>            <span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="m">100.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Red</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">pointerInput</span><span class="p">(</span><span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">detectTapGestures</span> <span class="p">{</span> <span class="n">log</span> <span class="p">=</span> <span class="s">&quot;Tap!&quot;</span> <span class="p">}</span>
</span><span class='line'>                <span class="c1">// 不会得到执行，走不到这里，前面一个是suspend的</span>
</span><span class='line'>                <span class="n">detectDragGestures</span> <span class="p">{</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="p">-&gt;</span> <span class="n">log</span> <span class="p">=</span> <span class="s">&quot;Dragging&quot;</span> <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>一个可行的解决办法就是可以写多个pointerInput，每个ponterInput处理一种手势：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">var</span> <span class="py">log</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="n">Column</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Text</span><span class="p">(</span><span class="n">log</span><span class="p">)</span>
</span><span class='line'>    <span class="n">Box</span><span class="p">(</span>
</span><span class='line'>        <span class="n">Modifier</span>
</span><span class='line'>            <span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="m">100.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Red</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">pointerInput</span><span class="p">(</span><span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">detectTapGestures</span> <span class="p">{</span> <span class="n">log</span> <span class="p">=</span> <span class="s">&quot;Tap!&quot;</span> <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="p">.</span><span class="n">pointerInput</span><span class="p">(</span><span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">// These drag events will correctly be triggered</span>
</span><span class='line'>                <span class="n">detectDragGestures</span> <span class="p">{</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="p">-&gt;</span> <span class="n">log</span> <span class="p">=</span> <span class="s">&quot;Dragging&quot;</span> <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>直接处理事件</h3>

<p>遇到交互比较复杂的场景，或者当PointerInputScope中提供的识别函数不能解决问题时，或者需要把几种不同的手势组合在一起时，就需要直接处理事件。像View系统中的onTouch一样，我们需要知道不同的事件类型，比如pointer down，pointer move和pointer up等。PointerInputScope中提供了一个函数awaitEachGesture可以取代while (true)来获得每个事件；awaitFirstDown，是手势的开始相当于ACTION&#95;DOWN；waitForUpOrCancellation是事件结束，相当于ACTION&#95;UP和ACTION&#95;CANCEL；drag相当于ACTION&#95;MOVE。我们来看一个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">private</span> <span class="k">fun</span> <span class="nf">LogPointerEvents</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">log</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">Column</span><span class="p">(</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">(),</span>
</span><span class='line'>        <span class="n">horizontalAlignment</span> <span class="p">=</span> <span class="n">Alignment</span><span class="p">.</span><span class="n">CenterHorizontally</span><span class="p">,</span>
</span><span class='line'>        <span class="n">verticalArrangement</span> <span class="p">=</span> <span class="n">Arrangement</span><span class="p">.</span><span class="n">spacedBy</span><span class="p">(</span><span class="m">8.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span><span class="n">log</span><span class="p">)</span>
</span><span class='line'>        <span class="n">Box</span><span class="p">(</span>
</span><span class='line'>            <span class="n">Modifier</span>
</span><span class='line'>                <span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="m">240.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">DarkGray</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">pointerInput</span><span class="p">(</span><span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">awaitEachGesture</span> <span class="p">{</span>
</span><span class='line'>                        <span class="k">val</span> <span class="py">down</span> <span class="p">=</span> <span class="n">awaitFirstDown</span><span class="p">().</span><span class="n">also</span> <span class="p">{</span>
</span><span class='line'>                            <span class="n">log</span> <span class="p">=</span> <span class="s">&quot;Action Down&quot;</span>
</span><span class='line'>                        <span class="p">}</span>
</span><span class='line'>                        <span class="k">var</span> <span class="py">change</span> <span class="p">=</span> <span class="n">awaitTouchSlopOrCancellation</span><span class="p">(</span><span class="n">down</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span> <span class="n">ch</span><span class="p">,</span> <span class="n">_</span> <span class="p">-&gt;</span>
</span><span class='line'>                            <span class="n">ch</span><span class="p">.</span><span class="n">consume</span><span class="p">()</span>
</span><span class='line'>                        <span class="p">}</span>
</span><span class='line'>                        <span class="k">while</span> <span class="p">(</span><span class="n">change</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">change</span><span class="p">.</span><span class="n">pressed</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                            <span class="n">change</span> <span class="p">=</span> <span class="n">awaitDragOrCancellation</span><span class="p">(</span><span class="n">change</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
</span><span class='line'>                            <span class="k">if</span> <span class="p">(</span><span class="n">change</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">change</span><span class="p">.</span><span class="n">pressed</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                                <span class="n">log</span> <span class="p">=</span> <span class="s">&quot;Action Move ${change.type} ${change.position}&quot;</span>
</span><span class='line'>                            <span class="p">}</span>
</span><span class='line'>                        <span class="p">}</span>
</span><span class='line'>                        <span class="n">log</span> <span class="p">=</span> <span class="s">&quot;Action Up&quot;</span>
</span><span class='line'>                    <span class="p">}</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="file:///Users/alexhilton/Downloads/compose_libs/gesture/event.gif" alt="event_demo" /></p>

<p>需要注意的是这些函数都是suspend的，也就是说当预期的行为发生时才会带着结果返回，比如awaitFirstDown()当有第一个触点事件发生时结束suspend然后返回；awaitTouchSlopOrCancellation当有超过拖拽阈值时结束suspend然后返回；awaitDragOrCancellation当有拖拽发生时结束suspend返回。</p>

<h2>触点事件的派发流程</h2>

<p>为了更好的处理事件，需要了解一下Jetpack Compose的事件派发流程，与View系统是类似的，事件派发的过程也是沿着Composable的树形结构，从父Composable到子Composable，同一层级的顺序则是从上到下，从前到后（Z轴方向），依次做『Hit test』，直到事件被消费，就停止派发。</p>

<p>事件的消费过程则是反过来，子Composable如果未消费就返回给父Composable，前面的Composable未消费，就继续向下传递，直到事件被消费。</p>

<p>如果是自己在pointerInput中直接处理事件，就要特别注意手动的把事件给消费掉，否则可能会继续传递。像awaitPointerEvent，awaitFirstDown，awaitDragOrCancellation等返回的都是<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/PointerInputChange">PointerInputChange</a>对象，调用它的<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/PointerInputChange#consume(">consume()</a>)方法即可把事件消费掉。再比如像上面的例子awaitTouchSlopOrCancellation中，也需要手动的把事件给消费掉，如果把ch.consume()这句删除，就会发现awaitDragOrCancellation不会得到执行，这是因为awaitTouchSlopOrCancellation这个方法还在执行中，调用ch.consume()把事件消费掉，这个函数才会返回。</p>

<p>这也说明了，还是要尽量用系统封装好的手势识别和手势处理函数，不到万不得已不要直接处理原始事件，因为逻辑写起来肯定相当复杂。</p>

<h2>多点触控</h2>

<p>多点触控是超过一个触点同时在屏幕上操作，最为常见的手势就是旋转和缩放，可以使用扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">transformable</a>.transformable(androidx.compose.foundation.gestures.TransformableState,kotlin.Boolean,kotlin.Boolean))监听旋转，平移和缩放手势，其中平移单个触点也能触发，缩放和旋转则需要两个触点，当超过3个触点时这个函数不会回调，也即不会触发任何手势：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">private</span> <span class="k">fun</span> <span class="nf">TransformableSample</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// set up all transformation states</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">scale</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="m">1f</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">rotation</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="m">0f</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">offset</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="n">Offset</span><span class="p">.</span><span class="n">Zero</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">state</span> <span class="p">=</span> <span class="n">rememberTransformableState</span> <span class="p">{</span> <span class="n">zoomChange</span><span class="p">,</span> <span class="n">offsetChange</span><span class="p">,</span> <span class="n">rotationChange</span> <span class="p">-&gt;</span>
</span><span class='line'>        <span class="n">scale</span> <span class="p">*=</span> <span class="n">zoomChange</span>
</span><span class='line'>        <span class="n">rotation</span> <span class="p">+=</span> <span class="n">rotationChange</span>
</span><span class='line'>        <span class="n">offset</span> <span class="p">+=</span> <span class="n">offsetChange</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">Box</span><span class="p">(</span>
</span><span class='line'>        <span class="n">Modifier</span>
</span><span class='line'>            <span class="c1">// 把参数应用到图层去做变幻</span>
</span><span class='line'>            <span class="p">.</span><span class="n">graphicsLayer</span><span class="p">(</span>
</span><span class='line'>                <span class="n">scaleX</span> <span class="p">=</span> <span class="n">scale</span><span class="p">,</span>
</span><span class='line'>                <span class="n">scaleY</span> <span class="p">=</span> <span class="n">scale</span><span class="p">,</span>
</span><span class='line'>                <span class="n">rotationZ</span> <span class="p">=</span> <span class="n">rotation</span><span class="p">,</span>
</span><span class='line'>                <span class="n">translationX</span> <span class="p">=</span> <span class="n">offset</span><span class="p">.</span><span class="n">x</span><span class="p">,</span>
</span><span class='line'>                <span class="n">translationY</span> <span class="p">=</span> <span class="n">offset</span><span class="p">.</span><span class="n">y</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>            <span class="c1">// 接收变幻手势</span>
</span><span class='line'>            <span class="p">.</span><span class="n">transformable</span><span class="p">(</span><span class="n">state</span> <span class="p">=</span> <span class="n">state</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Blue</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">fillMaxSize</span><span class="p">()</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/gestures-multitouch.gif" alt="multi_touch_demo" /></p>

<p>除了直接使用Modifier.transformable以外，还可以用前面提到过的pointerInput中的<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.input.pointer.PointerInputScope">detectTransformGestures</a>.detectTransformGestures(kotlin.Boolean,kotlin.Function4))这个函数也能得到平移，旋转和缩放的变化数值，把这些数值应用到graphicsLayer去做变幻就可以了，使用detectTransformGestures的另一个好处是可以与其他的手势结合起来。</p>

<h2>总结</h2>

<p>通过本文我们学习如何得到原始的触点事件，以及如何识别手势，相信对触点事件以及手势识别有了更深入的理解，并且借助这些扩展函数就可以写出交互性更好的应用程序界面。即使遇到一些复杂的交互 场景，或者需要组合多种手势时，也都能从容应对。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/understand-gestures">Understand gestures</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/multi-touch">Multitouch: Panning, zooming, rotating</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/user-interactions/handling-interactions">Handling user interactions</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『鱼跃于渊』| Gesture Handling]]></title>
    <link href="http://toughcoder.net/blog/2024/07/29/pointer-event-in-compose/"/>
    <updated>2024-07-29T20:41:20+08:00</updated>
    <id>http://toughcoder.net/blog/2024/07/29/pointer-event-in-compose</id>
    <content type="html"><![CDATA[<p>UI是用户界面，一个最为基础的功能就是与用户进行交互，要具有可交互性。要想有可交互性就需要处理用户输入事件。手势是最为常见的一种用户输入，今天就来专门学习一下如何处理Jetpack Compose中最为常见的手势。</p>

<p><a href="http://toughcoder.net/blog/2024/07/29/pointer-event-in-compose/"><img src="https://koenig-media.raywenderlich.com/uploads/2022/10/GesturesInJetpackCompose-twitter.png" title="auto auto" ></a></p>

<!-- more -->


<h2>输入事件与手势概述</h2>

<p>在开始学习之前有必要先澄清一些概念，以免混淆。与View系统不太一样的是，触摸事件在Jetpack Compose中称之为触点事件（Pointer event），对应的主体称之为触点（Pointer），一连串的触点事件就形成了手势（Gesture）。之所以叫触点，是因为并不总是由触摸屏幕触发事件，也可以是手写笔，（外接）鼠标或者（外接）触摸板，这些都是触控类的输入主体，它的最主要的特点是发生在屏幕上的一个坐标点。其具体的类型称之为触点类型（Pointer type）。</p>

<p>事件处理最主要的是也就是要识别各种不同的触点手势，然后做出响应，以让UI具体可交互性。</p>

<h2>点击事件（Tap and Press）</h2>

<p>点击事件是最为常见，也是最为基础的一种手势了，可以简单的看成按下事件（pointer down）和抬起事件（pointer up）组成，但其实也会有移动（pointer move），只不过移动的位移特别小而已，这里我们不过多的纠结。点击事件分为单击，双击和长按，幸运的是在Compose中都有封装好的回调函数可以直接使用，我们一一来看一下。</p>

<h3>单击（Tap/Click）</h3>

<p>单击是最为常见的事件处理了，在之前的教程已经见过了，通过Modifier的扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier">Modifier.clickable</a>.clickable(kotlin.Boolean,kotlin.String,androidx.compose.ui.semantics.Role,kotlin.Function0))就可以为任意一个Composable设置单击事件处理函数。</p>

<h3>双击（Double tap/Double click）和长按（LongPress/Long click）</h3>

<p>对于双击和长按，并不像clickable那样常用，因此需要用到另外一个扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier">Modifier.combinedClickable</a>.combinedClickable(androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.foundation.Indication,kotlin.Boolean,kotlin.String,androidx.compose.ui.semantics.Role,kotlin.String,kotlin.Function0,kotlin.Function0,kotlin.Function0))，这个函数可以设置多个点击事件处理函数，单击双击和长按都可以通过它来设置：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">Box</span><span class="p">(</span>
</span><span class='line'>    <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>        <span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="m">100.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Yellow</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">combinedClickable</span><span class="p">(</span>
</span><span class='line'>            <span class="n">onClick</span> <span class="p">=</span> <span class="p">{</span> <span class="n">gotoDetail</span><span class="p">()</span> <span class="p">},</span>
</span><span class='line'>            <span class="n">onClickLabel</span> <span class="p">=</span> <span class="s">&quot;Go to details&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="n">onLongClick</span> <span class="p">=</span> <span class="p">{</span> <span class="n">showContextMneu</span><span class="p">()</span> <span class="p">},</span>
</span><span class='line'>            <span class="n">onLongClickLabel</span> <span class="p">=</span> <span class="s">&quot;Open context menu&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="n">onDoubleClick</span> <span class="p">=</span> <span class="p">{</span> <span class="n">shareContent</span><span class="p">()</span> <span class="p">}</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>滚动（Scroll）</h2>

<p>滚动手势是指朝着某一固定的方向慢速的滑动，多用于查看屏幕之外的内容。像集合性布局设计的目的就是为了显示大量的同一类型的数据集合，天生就支持滚动。对于滚动手势需要处理的就是常规布局支持滚动，以及滚动的嵌套。</p>

<h3>非集合性布局支持滚动</h3>

<p>对于常规的非集合性布局（Box，Row和Column）正常情况下是不可滚动的，是没有办法查看超出其尺寸大小范围的内容的。想让这几个布局可滚动也不难，用Modifier的扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier">verticalScroll</a>.verticalScroll(androidx.compose.foundation.ScrollState,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean))和<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier">horizontalScroll</a>.horizontalScroll(androidx.compose.foundation.ScrollState,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean))就可以让不可滚动布局（Box，Row和Column）支持垂直方向滚动和水平方向滚动：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">private</span> <span class="k">fun</span> <span class="nf">ScrollBoxes</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Column</span><span class="p">(</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>            <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">LightGray</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="m">100.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">verticalScroll</span><span class="p">(</span><span class="n">rememberScrollState</span><span class="p">())</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">repeat</span><span class="p">(</span><span class="m">10</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">Text</span><span class="p">(</span><span class="s">&quot;Item $it&quot;</span><span class="p">,</span> <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">2.</span><span class="n">dp</span><span class="p">))</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/gestures-simplescroll.gif" alt="scrollable_box" /></p>

<p>大部分情况下，如果只是想让布局可滚动就不需要处理<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/ScrollState">ScrollState</a>，但如果想要获取滚位置，或者改变滚动位置，比如说页面进入时（Initial composition）自动滚动到某一们位置，可以通过修改<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/ScrollState">SrollState</a>来实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">private</span> <span class="k">fun</span> <span class="nf">ScrollBoxesSmooth</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 进入页面时就自动的平滑的滚动</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">state</span> <span class="p">=</span> <span class="n">rememberScrollState</span><span class="p">()</span>
</span><span class='line'>    <span class="n">LaunchedEffect</span><span class="p">(</span><span class="n">Unit</span><span class="p">)</span> <span class="p">{</span> <span class="n">state</span><span class="p">.</span><span class="n">animateScrollTo</span><span class="p">(</span><span class="m">100</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Column</span><span class="p">(</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>            <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">LightGray</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="m">100.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="n">horizontal</span> <span class="p">=</span> <span class="m">8.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">verticalScroll</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// ...</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>滚动手势处理</h3>

<p>对于任意的Composable来文章，都可以通过Modifier的扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.Modifier">scrollable</a>.scrollable(androidx.compose.foundation.gestures.ScrollableState,androidx.compose.foundation.gestures.Orientation,kotlin.Boolean,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,androidx.compose.foundation.interaction.MutableInteractionSource))来监听并处理滚动手势。需要注意的是，scrollable仅会告诉你有滚动手势发生和当前的滚动距离，但并不会直接修改布局，需要开发者去使用滑动距离进行布局的修改：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">private</span> <span class="k">fun</span> <span class="nf">ScrollableSample</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// actual composable state</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">offset</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="m">0f</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">Box</span><span class="p">(</span>
</span><span class='line'>        <span class="n">Modifier</span>
</span><span class='line'>            <span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="m">150.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">scrollable</span><span class="p">(</span>
</span><span class='line'>                <span class="n">orientation</span> <span class="p">=</span> <span class="n">Orientation</span><span class="p">.</span><span class="n">Vertical</span><span class="p">,</span>
</span><span class='line'>                <span class="c1">// Scrollable state: describes how to consume</span>
</span><span class='line'>                <span class="c1">// scrolling delta and update offset</span>
</span><span class='line'>                <span class="n">state</span> <span class="p">=</span> <span class="n">rememberScrollableState</span> <span class="p">{</span> <span class="n">delta</span> <span class="p">-&gt;</span>
</span><span class='line'>                    <span class="n">offset</span> <span class="p">+=</span> <span class="n">delta</span>
</span><span class='line'>                    <span class="n">delta</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">LightGray</span><span class="p">),</span>
</span><span class='line'>        <span class="n">contentAlignment</span> <span class="p">=</span> <span class="n">Alignment</span><span class="p">.</span><span class="n">Center</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span><span class="n">offset</span><span class="p">.</span><span class="n">toString</span><span class="p">())</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/gestures-numeric-offset.gif" alt="handle_scrollable" /></p>

<p>如果让滚动对布局产生影响，可以用计算得到offset去改变布局的offset属性offset(y = offset.dp)就可以了。</p>

<h3>滚动嵌套</h3>

<p>手势处理最大的一个麻烦就是手势的嵌套，而又以滚动的嵌套最为麻烦，最为典型的就是同一方向的列表中套着列表，开发者必须手动处理滑动冲突。滚动冲突处理的策略并不难，优先由子View消费滚动事件，当子View还可以滚动时，就把事件消费掉；如果子View已到达边界，无法滚动时，视为事件未消费，把事件再传递给父View，由父View消费，这时父View会进行滚动；当然如果滑动事件没有发生在子View上面，那肯定 是父View滚动。</p>

<p>策略虽然简单，但有魔鬼细节，传统的View必须要在onTouch和onInterceptTouch里面写上大坨大坨的逻辑，还要定义很多个全局变量。幸运的是，针对 于同方向的可滚动布局嵌套，Jetpack Compose已经帮我们处理了。对于使用verticalScroll，horizontalScroll，scrollable，集合性布局（LazyRow，LazyColumn和LazyGrid）和TextField实现的同方向滚动嵌套，不用再特殊处理，Compose已经按照前面说的策略处理好了，这就是<strong>自动嵌套滚动机制（Automatic nested scrolling）</strong>。来看一个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">private</span> <span class="k">fun</span> <span class="nf">AutomaticNestedScroll</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">gradient</span> <span class="p">=</span> <span class="n">Brush</span><span class="p">.</span><span class="n">verticalGradient</span><span class="p">(</span><span class="m">0f</span> <span class="n">to</span> <span class="n">Color</span><span class="p">.</span><span class="n">Yellow</span><span class="p">,</span> <span class="m">1000f</span> <span class="n">to</span> <span class="n">Color</span><span class="p">.</span><span class="n">Red</span><span class="p">)</span>
</span><span class='line'>    <span class="n">Column</span><span class="p">(</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>            <span class="p">.</span><span class="n">fillMaxWidth</span><span class="p">()</span>
</span><span class='line'>            <span class="p">.</span><span class="n">height</span><span class="p">(</span><span class="m">400.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">LightGray</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">verticalScroll</span><span class="p">(</span><span class="n">rememberScrollState</span><span class="p">())</span>
</span><span class='line'>            <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">32.</span><span class="n">dp</span><span class="p">),</span>
</span><span class='line'>        <span class="n">horizontalAlignment</span> <span class="p">=</span> <span class="n">Alignment</span><span class="p">.</span><span class="n">CenterHorizontally</span><span class="p">,</span>
</span><span class='line'>        <span class="n">verticalArrangement</span> <span class="p">=</span> <span class="n">Arrangement</span><span class="p">.</span><span class="n">spacedBy</span><span class="p">(</span><span class="m">16.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">repeat</span><span class="p">(</span><span class="m">6</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">Box</span><span class="p">(</span>
</span><span class='line'>                <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>                    <span class="p">.</span><span class="n">height</span><span class="p">(</span><span class="m">128.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">.</span><span class="n">verticalScroll</span><span class="p">(</span><span class="n">rememberScrollState</span><span class="p">())</span>
</span><span class='line'>            <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>                    <span class="s">&quot;$it 滑动试试！&quot;</span><span class="p">,</span>
</span><span class='line'>                    <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>                        <span class="p">.</span><span class="n">align</span><span class="p">(</span><span class="n">Alignment</span><span class="p">.</span><span class="n">Center</span><span class="p">)</span>
</span><span class='line'>                        <span class="p">.</span><span class="n">border</span><span class="p">(</span><span class="m">12.</span><span class="n">dp</span><span class="p">,</span> <span class="n">Color</span><span class="p">.</span><span class="n">DarkGray</span><span class="p">)</span>
</span><span class='line'>                        <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">brush</span> <span class="p">=</span> <span class="n">gradient</span><span class="p">)</span>
</span><span class='line'>                        <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">24.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>                        <span class="p">.</span><span class="n">height</span><span class="p">(</span><span class="m">150.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>                <span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="file:///Users/alexhilton/Downloads/compose_libs/gesture/ascroll.gif" alt="nested_scrolling" />
这个例子中外层Column支持垂直滚动，里面的每个Box也支持垂直滚动，当里面的Box自己消费滚动时，外层 是不会动的，而当里面的Box无法滚动时（overscrolled）事件就到了外层的Column，即Column会滚动。</p>

<p><strong>注意：</strong>滚动嵌套并不是一个好的交互设计，尽管有技术手段解决，但用起来仍旧是怪怪的，操作起来也并不方便，误操作的可能性很大。不同方向的滚动嵌套在一起是比较好的方案，比如横向的Tab页代表不同的分类，竖向的内容页是一个分类中的具体内容，内容是竖向的，内容中仍旧可以有一些横向滑动的扩展内容，如图片库，tag标签等。</p>

<h2>拖拽（Drag）</h2>

<p>拖拽是指按住屏幕慢速移动，被点击到的UI元素应该跟随手势移动并停留在触点离开屏幕的地方。通过扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.Modifier">Modifier.draggable</a>.draggable(androidx.compose.foundation.gestures.DraggableState,androidx.compose.foundation.gestures.Orientation,kotlin.Boolean,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Boolean,kotlin.coroutines.SuspendFunction2,kotlin.coroutines.SuspendFunction2,kotlin.Boolean))可以处理单一方向的拖拽手势。在draggable中我们可以用状态记录移动的距离，然后把距离应用到Composable的offset以生成拖拽后的效果：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">private</span> <span class="k">fun</span> <span class="nf">DraggableText</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">offsetX</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="m">0f</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>            <span class="p">.</span><span class="n">offset</span> <span class="p">{</span> <span class="n">IntOffset</span><span class="p">(</span><span class="n">offsetX</span><span class="p">.</span><span class="n">roundToInt</span><span class="p">(),</span> <span class="m">0</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>            <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">LightGray</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">8.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">draggable</span><span class="p">(</span>
</span><span class='line'>                <span class="n">orientation</span> <span class="p">=</span> <span class="n">Orientation</span><span class="p">.</span><span class="n">Horizontal</span><span class="p">,</span>
</span><span class='line'>                <span class="n">state</span> <span class="p">=</span> <span class="n">rememberDraggableState</span> <span class="p">{</span> <span class="n">delta</span> <span class="p">-&gt;</span>
</span><span class='line'>                    <span class="n">offsetX</span> <span class="p">+=</span> <span class="n">delta</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">),</span>
</span><span class='line'>        <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;降Compose十八掌！&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="n">style</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">typography</span><span class="p">.</span><span class="n">headlineLarge</span><span class="p">,</span>
</span><span class='line'>        <span class="n">color</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">colorScheme</span><span class="p">.</span><span class="n">primary</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="file:///Users/alexhilton/Downloads/compose_libs/gesture/drag.gif" alt="drag_demo" /></p>

<h2>滑动（Swipe/Fling）</h2>

<p>滑动与拖拽的区别在于滑动是有速度的，滑动手势在触点离开屏幕后并不会立即停止，而且是会继续朝原方向减速直到速度变为0才停，最为常见的交互方式就是滑动删除（swipe-to-dismiss），以及像列表的Fling手势。</p>

<p>使用Modifier的扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.Modifier">anchoredDraggable</a>.anchoredDraggable(androidx.compose.foundation.gestures.AnchoredDraggableState,androidx.compose.foundation.gestures.Orientation,kotlin.Boolean,kotlin.Boolean,androidx.compose.foundation.interaction.MutableInteractionSource))来处理滑动事件，定义一些<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/DraggableAnchors">锚点（DraggableAnchors）</a>，视为一个手势操作中的不同状态，比如像滑动开关，就是开和关，像滑动删除就是正常和已删除，再用一个<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/AnchoredDraggableState">AnchoredDraggableState</a>来追踪滑动的状态，这里面可以定义初始锚点，锚点值，和终止状态的阈值（positionalThreshold超过一定位置就认为到达终点锚点，velocityThreshold速度小于这个时就认为到达终点锚点），以及手势过程中的动画（animationSpec）。然后，再把AnchoredDraggableState中的滑动距离offset设置到Composable中即可。</p>

<p>说的挺复杂，其实很直观，看一个例子就明了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">enum</span> <span class="k">class</span> <span class="nc">SwipeableSwitchState</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">SWITCH_ON</span><span class="p">,</span> <span class="n">SWITCH_OFF</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">@OptIn</span><span class="p">(</span><span class="n">ExperimentalFoundationApi</span><span class="o">::</span><span class="k">class</span><span class="p">)</span>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">private</span> <span class="k">fun</span> <span class="nf">SwipeableSample</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">width</span> <span class="p">=</span> <span class="m">128.</span><span class="n">dp</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">squareSize</span> <span class="p">=</span> <span class="m">64.</span><span class="n">dp</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">val</span> <span class="py">density</span> <span class="p">=</span> <span class="n">LocalDensity</span><span class="p">.</span><span class="n">current</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">sizePx</span> <span class="p">=</span> <span class="n">with</span><span class="p">(</span><span class="n">density</span><span class="p">)</span> <span class="p">{</span> <span class="n">squareSize</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">anchors</span> <span class="p">=</span> <span class="n">DraggableAnchors</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">SwipeableSwitchState</span><span class="p">.</span><span class="n">SWITCH_ON</span> <span class="n">at</span> <span class="n">sizePx</span>
</span><span class='line'>        <span class="n">SwipeableSwitchState</span><span class="p">.</span><span class="n">SWITCH_OFF</span> <span class="n">at</span> <span class="m">0f</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">swipeableState</span> <span class="p">=</span> <span class="n">remember</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">AnchoredDraggableState</span><span class="p">(</span>
</span><span class='line'>            <span class="n">initialValue</span> <span class="p">=</span> <span class="n">SwipeableSwitchState</span><span class="p">.</span><span class="n">SWITCH_OFF</span><span class="p">,</span>
</span><span class='line'>            <span class="n">anchors</span> <span class="p">=</span> <span class="n">anchors</span><span class="p">,</span>
</span><span class='line'>            <span class="n">positionalThreshold</span> <span class="p">=</span> <span class="p">{</span> <span class="n">d</span><span class="p">:</span> <span class="n">Float</span> <span class="p">-&gt;</span> <span class="n">d</span> <span class="p">*</span> <span class="m">0.4f</span> <span class="p">},</span>
</span><span class='line'>            <span class="n">velocityThreshold</span> <span class="p">=</span> <span class="p">{</span> <span class="n">with</span><span class="p">(</span><span class="n">density</span><span class="p">)</span> <span class="p">{</span> <span class="m">100.</span><span class="n">dp</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">}</span> <span class="p">},</span>
</span><span class='line'>            <span class="n">animationSpec</span> <span class="p">=</span> <span class="n">tween</span><span class="p">()</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">Box</span><span class="p">(</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>            <span class="p">.</span><span class="n">width</span><span class="p">(</span><span class="n">width</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">anchoredDraggable</span><span class="p">(</span>
</span><span class='line'>                <span class="n">state</span> <span class="p">=</span> <span class="n">swipeableState</span><span class="p">,</span>
</span><span class='line'>                <span class="n">orientation</span> <span class="p">=</span> <span class="n">Orientation</span><span class="p">.</span><span class="n">Horizontal</span><span class="p">,</span>
</span><span class='line'>                <span class="n">startDragImmediately</span> <span class="p">=</span> <span class="k">false</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">LightGray</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Box</span><span class="p">(</span>
</span><span class='line'>            <span class="n">Modifier</span>
</span><span class='line'>                <span class="p">.</span><span class="n">offset</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">IntOffset</span><span class="p">(</span>
</span><span class='line'>                        <span class="k">if</span> <span class="p">(</span><span class="n">swipeableState</span><span class="p">.</span><span class="n">offset</span><span class="p">.</span><span class="n">isNaN</span><span class="p">())</span> <span class="m">0</span> <span class="k">else</span> <span class="n">swipeableState</span><span class="p">.</span><span class="n">offset</span><span class="p">.</span><span class="n">roundToInt</span><span class="p">(),</span>
</span><span class='line'>                        <span class="m">0</span>
</span><span class='line'>                    <span class="p">)</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>                <span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="n">squareSize</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">DarkGray</span><span class="p">)</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="file:///Users/alexhilton/Downloads/compose_libs/gesture/swipe.gif" alt="swipe_demo" />
这个例子展示了一个滑动开关的手势处理，滑动距离超过整体长度0.4时，或者速度小于100时就认为到达另一锚点状态。可以明显的看出与拖拽的区别，滑动后手可以离开，但手势仍在继续直到达到终点锚点。</p>

<p><strong>注意：</strong>在Compose 1.6版本以前有另外一个扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#(androidx.compose.ui.Modifier">swipeable</a>.swipeable(androidx.compose.material.SwipeableState,kotlin.collections.Map,androidx.compose.foundation.gestures.Orientation,kotlin.Boolean,kotlin.Boolean,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Function2,androidx.compose.material.ResistanceConfig,androidx.compose.ui.unit.Dp))来处理滑动手势，但在1.6版本时已废弃，被anchoredDraggable取代，并且有一个<a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/migrate-swipeable">替换的教程</a>。</p>

<h2>未完待续</h2>

<p>事件处理对于UI来说是极其重要的，本篇重点讲述了Jetpack Compose中的最为基础和最为常见的事件处理方式，足以满足绝大多数应用场景。事件处理也是极其复杂的，对于交互极其复杂的页面来说，还需要进一步的了解更为底层的事件处理方法，以达到复杂交互的目的，将在后面的文章中继续深入探讨事件处理。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/tap-and-press">Tap and press</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/drag-swipe-fling">Drag, swipe, and fling</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/scroll">Scroll</a></li>
<li><a href="https://canopas.com/how-to-implement-swipe-to-action-using-anchoreddraggable-in-jetpack-compose-cccb22e44dff">How to Implement Swipe-to-Action using AnchoredDraggable in Jetpack Compose</a></li>
<li><a href="https://fvilarino.medium.com/exploring-jetpack-compose-anchored-draggable-modifier-5fdb21a0c64c">Exploring Jetpack Compose Anchored Draggable Modifier</a></li>
<li><a href="https://medium.com/@AungThiha3/jetpack-compose-anchored-draggable-item-in-motionlayout-part-1-8d5a1cde880f">Jetpack Compose: Anchored Draggable Item in MotionLayout Part 1</a></li>
<li><a href="https://medium.com/@AungThiha3/jetpack-compose-anchored-draggable-item-in-motionlayout-part-2-c1fd94188e56">Jetpack Compose: Anchored Draggable Item in MotionLayout Part 2</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『双龙取水』| Text Edit]]></title>
    <link href="http://toughcoder.net/blog/2024/07/24/text-edit-in-compose/"/>
    <updated>2024-07-24T08:28:55+08:00</updated>
    <id>http://toughcoder.net/blog/2024/07/24/text-edit-in-compose</id>
    <content type="html"><![CDATA[<p>文本是所有UI系统中非常重要的一个种元素，文本的输入在UI框架中的重要性也特别的高，因为这是最重要的一种用户输入。今天专注于文本的输入处理，包括文本输入框，以及文本的选择和富式点击处理。</p>

<p><a href="http://toughcoder.net/blog/2024/07/24/text-edit-in-compose/"><img src="https://static.wixstatic.com/media/0d004d_ea93b43aabf348cb8f96c0dc94f85365~mv2.jpg/v1/fit/w_1000%2Ch_600%2Cal_c%2Cq_80/file.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>文本输入</h2>

<p>Compose提供了符合<a href="https://material.io/components/text-fields">Material Design</a>的文本输入<a href="https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#TextField(androidx.compose.ui.text.input.TextFieldValue,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Boolean,androidx.compose.ui.text.TextStyle,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Boolean,androidx.compose.ui.text.input.VisualTransformation,androidx.compose.foundation.text.KeyboardOptions,androidx.compose.foundation.text.KeyboardActions,kotlin.Boolean,kotlin.Int,kotlin.Int,androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.ui.graphics.Shape,androidx.compose.material.TextFieldColors">TextField</a>)，默认的实现是全填充的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">SimpleFilledTextFieldSample</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">text</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">TextField</span><span class="p">(</span>
</span><span class='line'>        <span class="n">value</span> <span class="p">=</span> <span class="n">text</span><span class="p">,</span>
</span><span class='line'>        <span class="n">onValueChange</span> <span class="p">=</span> <span class="p">{</span> <span class="n">text</span> <span class="p">=</span> <span class="n">it</span> <span class="p">},</span>
</span><span class='line'>        <span class="n">label</span> <span class="p">=</span> <span class="p">{</span> <span class="n">Text</span><span class="p">(</span><span class="s">&quot;Label&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-textfield-hello.png" alt="textfield" />
还有一个边框式的<a href="https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#OutlinedTextField(kotlin.String,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Boolean,androidx.compose.ui.text.TextStyle,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Boolean,androidx.compose.ui.text.input.VisualTransformation,androidx.compose.foundation.text.KeyboardOptions,androidx.compose.foundation.text.KeyboardActions,kotlin.Boolean,kotlin.Int,kotlin.Int,androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.ui.graphics.Shape,androidx.compose.material.TextFieldColors">OutlinedTextField</a>)：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">SimpleOutlinedTextFieldSample</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">text</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">OutlinedTextField</span><span class="p">(</span>
</span><span class='line'>        <span class="n">value</span> <span class="p">=</span> <span class="n">text</span><span class="p">,</span>
</span><span class='line'>        <span class="n">onValueChange</span> <span class="p">=</span> <span class="p">{</span> <span class="n">text</span> <span class="p">=</span> <span class="n">it</span> <span class="p">},</span>
</span><span class='line'>        <span class="n">label</span> <span class="p">=</span> <span class="p">{</span> <span class="n">Text</span><span class="p">(</span><span class="s">&quot;Label&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-outlinedtextfield.png" alt="outlined_textfield" />
可以看到TextField函数最关键的有三个参数：文本框中的显示的文本text，文本变化回调onValueChange，提示标签label。需要注意传给text的变量要是状态（State），这样才会触发重组，否则TextField显示的文本不会发生变化。</p>

<h3>定制TextField</h3>

<p>可以通过其他的参数来控制输入框的行为，最为常用的就是行数限制singleLine和maxLines， 以及文本的样式控制textStyle，它可以控制文本颜色和字体：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">StyledTextField</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">value</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="s">&quot;Hello\nWorld\nInvisible&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">TextField</span><span class="p">(</span>
</span><span class='line'>        <span class="n">value</span> <span class="p">=</span> <span class="n">value</span><span class="p">,</span>
</span><span class='line'>        <span class="n">onValueChange</span> <span class="p">=</span> <span class="p">{</span> <span class="n">value</span> <span class="p">=</span> <span class="n">it</span> <span class="p">},</span>
</span><span class='line'>        <span class="n">label</span> <span class="p">=</span> <span class="p">{</span> <span class="n">Text</span><span class="p">(</span><span class="s">&quot;Enter text&quot;</span><span class="p">)</span> <span class="p">},</span>
</span><span class='line'>        <span class="n">maxLines</span> <span class="p">=</span> <span class="m">2</span><span class="p">,</span>
</span><span class='line'>        <span class="n">textStyle</span> <span class="p">=</span> <span class="n">TextStyle</span><span class="p">(</span><span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Blue</span><span class="p">,</span> <span class="n">fontWeight</span> <span class="p">=</span> <span class="n">FontWeight</span><span class="p">.</span><span class="n">Bold</span><span class="p">),</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">20.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-textfield-multiline.png" alt="textfield_customize" />
textStyle比较丰富，除了直接指定颜色以外，还可以用<a href="https://developer.android.com/develop/ui/compose/text/style-text#brush">Brush API</a>，以实现一些颜色渐变，渐变效果是针对整个输入框的，换言之不同的行效果是一样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">var</span> <span class="py">text</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="k">val</span> <span class="py">brush</span> <span class="p">=</span> <span class="n">remember</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Brush</span><span class="p">.</span><span class="n">linearGradient</span><span class="p">(</span>
</span><span class='line'>        <span class="n">colors</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">RED</span><span class="p">,</span> <span class="n">Color</span><span class="p">.</span><span class="n">YELLOW</span><span class="p">,</span> <span class="n">Color</span><span class="p">.</span><span class="n">GREEN</span><span class="p">,</span> <span class="n">Color</span><span class="p">.</span><span class="n">BLUE</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">TextField</span><span class="p">(</span>
</span><span class='line'>    <span class="n">value</span> <span class="p">=</span> <span class="n">text</span><span class="p">,</span> <span class="n">onValueChange</span> <span class="p">=</span> <span class="p">{</span> <span class="n">text</span> <span class="p">=</span> <span class="n">it</span> <span class="p">},</span> <span class="n">textStyle</span> <span class="p">=</span> <span class="n">TextStyle</span><span class="p">(</span><span class="n">brush</span> <span class="p">=</span> <span class="n">brush</span><span class="p">)</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-textfieldgradient.gif" alt="brush_textstyle" /></p>

<h3>与键盘联动</h3>

<p>TextField能够配置软件盘以实现特定输入样式，比如只输入数字，只有英文字符等等，通过TextField的keyboardOptions参数，传入一个<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/KeyboardOptions#KeyboardOptions(androidx.compose.ui.text.input.KeyboardCapitalization,kotlin.Boolean,androidx.compose.ui.text.input.KeyboardType,androidx.compose.ui.text.input.ImeAction">KeyboardOptions</a>)对象。常用的配置项有：</p>

<ul>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/KeyboardCapitalization">capitalization</a> 对于有大小写的语言来说，输入时词首自动大写</li>
<li>autoCorrect 自动更正</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/KeyboardType">keyboardType</a> 键盘类型，如纯字符，纯数字，E-mail地址，网址等等</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/ImeAction">imeAction</a> 让键盘的显示输入完成后的行为相关的按扭，比如<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/ImeAction#Search(">『搜索（Search）』</a>)，<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/ImeAction#Send(">『发送（Send）』</a>)等</li>
</ul>


<p>当输入完成后，用户点了imeAction指定的按扭后，可以指定回调函数以执行相关的操作，通过keyboardActions参数指定一个<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/KeyboardActions">KeyboardActions</a>对象，里面可以指定对应于imeAction中的各种回调，如onSearch会在imeAction指定为Search时，用户点击后触发；onSend会在imeAction是Send时，用户点击触发，等等。</p>

<h3>特殊形式的输入</h3>

<p>有些特殊的场景是不能够直接把用户的输入文本直接的展现在框里，比如输入密码时，再比如像输入电话号码时，可能会自动在3个数字后面加上短横线。这时就需要用到<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/VisualTransformation">VisualTransformation</a>来对文本进行转换处理：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">PasswordTextField</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">password</span> <span class="k">by</span> <span class="n">rememberSaveable</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">TextField</span><span class="p">(</span>
</span><span class='line'>        <span class="n">value</span> <span class="p">=</span> <span class="n">password</span><span class="p">,</span>
</span><span class='line'>        <span class="n">onValueChange</span> <span class="p">=</span> <span class="p">{</span> <span class="n">password</span> <span class="p">=</span> <span class="n">it</span> <span class="p">},</span>
</span><span class='line'>        <span class="n">label</span> <span class="p">=</span> <span class="p">{</span> <span class="n">Text</span><span class="p">(</span><span class="s">&quot;Enter password&quot;</span><span class="p">)</span> <span class="p">},</span>
</span><span class='line'>        <span class="n">visualTransformation</span> <span class="p">=</span> <span class="n">PasswordVisualTransformation</span><span class="p">(),</span>
</span><span class='line'>        <span class="n">keyboardOptions</span> <span class="p">=</span> <span class="n">KeyboardOptions</span><span class="p">(</span><span class="n">keyboardType</span> <span class="p">=</span> <span class="n">KeyboardType</span><span class="p">.</span><span class="n">Password</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-textfield-password.png" alt="password_textfield" /></p>

<h3>文本状态管理</h3>

<p>TextField的文本（text参数）是需要转换成状态的，这样才能更好的触发重组。基础的通用的TextField使用方式是，把文本转成状态，塞给TextField，然后在其onValueChange中再更新此状态：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="c1">// ...</span>
</span><span class='line'><span class="k">var</span> <span class="py">text</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">TextField</span><span class="p">(</span>
</span><span class='line'>    <span class="n">value</span> <span class="p">=</span> <span class="n">text</span><span class="p">,</span>
</span><span class='line'>    <span class="n">onValueChange</span> <span class="p">=</span> <span class="p">{</span> <span class="n">text</span> <span class="p">=</span> <span class="n">it</span> <span class="p">},</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'><span class="c1">// ...</span>
</span></code></pre></td></tr></table></div></figure>


<p>但现实的代码不可能这么简单，用户的输入必然会有业务逻辑去处理，所以onValueChange肯定会调用ViewModel去处理用户输入。那么自然也要从ViewModel处获得。但由于TextField的特殊性，仍然要把使用MutableState来定义状态，而不能用响应式的Reactive stream或者StateFlow：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">SignUpViewModel</span><span class="p">(</span><span class="k">private</span> <span class="k">val</span> <span class="py">userRepository</span><span class="p">:</span> <span class="n">UserRepository</span><span class="p">)</span> <span class="p">:</span> <span class="n">ViewModel</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">var</span> <span class="py">username</span> <span class="k">by</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="k">private</span> <span class="k">set</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">fun</span> <span class="nf">updateUsername</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">username</span> <span class="p">=</span> <span class="n">input</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// SignUpScreen.kt</span>
</span><span class='line'>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">SignUpScreen</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">OutlinedTextField</span><span class="p">(</span>
</span><span class='line'>        <span class="n">value</span> <span class="p">=</span> <span class="n">viewModel</span><span class="p">.</span><span class="n">username</span><span class="p">,</span>
</span><span class='line'>        <span class="n">onValueChange</span> <span class="p">=</span> <span class="p">{</span> <span class="n">username</span> <span class="p">-&gt;</span> <span class="n">viewModel</span><span class="p">.</span><span class="n">updateUsername</span><span class="p">(</span><span class="n">username</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>        <span class="cm">/*...*/</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>文本的选择</h2>

<p>除了文本输入以外，文本显示的选择也视为文字编辑的一种方式，因为选择之后就可以执行复制或者搜索等全局操作。Compose提供了细粒度的可交互式文本显示控制。Text本身是不支持选择的（Not Selectable），自然也就无法复制。可以使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/selection/package-summary#SelectionContainer(androidx.compose.ui.Modifier,kotlin.Function0">SelectableContainer</a>)来包裹Text以实现可选择（Selectable）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">SelectableText</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">SelectionContainer</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span><span class="s">&quot;This text is selectable&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-selected.png" alt="selectable_text" />
并且，可选择区域可以跨多个Text。与之相对的，还有不可选择函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/selection/package-summary#DisableSelection(kotlin.Function0">DisableSelection</a>)，比如一大片可选择文本中，想让某一小块文本不能被选择，这时DisableSelection就派上用场了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">PartiallySelectableText</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">SelectionContainer</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Column</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">Text</span><span class="p">(</span><span class="s">&quot;This text is selectable&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">Text</span><span class="p">(</span><span class="s">&quot;This one too&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">Text</span><span class="p">(</span><span class="s">&quot;This one as well&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">DisableSelection</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">Text</span><span class="p">(</span><span class="s">&quot;But not this one&quot;</span><span class="p">)</span>
</span><span class='line'>                <span class="n">Text</span><span class="p">(</span><span class="s">&quot;Neither this one&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="n">Text</span><span class="p">(</span><span class="s">&quot;But again, you can select this one&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">Text</span><span class="p">(</span><span class="s">&quot;And this one too&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-partially-selected.png" alt="disable_selection" /></p>

<p>可以看出对于文本的选择控制还是相当的灵活的（flexible）。</p>

<h2>富式文本点击</h2>

<p>对于针对 整个文本的点击事件可以用Modifier中的<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier">clickable</a>.clickable(kotlin.Boolean,kotlin.String,androidx.compose.ui.semantics.Role,kotlin.Function0))函数来处理，这跟常规的Composable没区别都一样的。但对于文本来说有更为细腻的点击事件处理，包括获取具体点击的光标位置，以及富式文本点击，也即针对 文本中不同部分的响应。</p>

<h3>获取点击的光标位置</h3>

<p>想要获取到文本中点击的光标位置，其实也就是点击的是第几个字符，可以用<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/package-summary#ClickableText(androidx.compose.ui.text.AnnotatedString,androidx.compose.ui.Modifier,androidx.compose.ui.text.TextStyle,kotlin.Boolean,androidx.compose.ui.text.style.TextOverflow,kotlin.Int,kotlin.Function1,kotlin.Function1">ClickableText</a>)，它有一个自己的onClick回调函数，里面的参数是一个offset表示被点击字符的索引：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">SimpleClickableText</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">ClickableText</span><span class="p">(</span><span class="n">text</span> <span class="p">=</span> <span class="n">AnnotatedString</span><span class="p">(</span><span class="s">&quot;Click Me&quot;</span><span class="p">),</span> <span class="n">onClick</span> <span class="p">=</span> <span class="p">{</span> <span class="n">offset</span> <span class="p">-&gt;</span>
</span><span class='line'>        <span class="n">Log</span><span class="p">.</span><span class="n">d</span><span class="p">(</span><span class="s">&quot;ClickableText&quot;</span><span class="p">,</span> <span class="s">&quot;$offset -th character is clicked.&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">})</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意onClick的参数是文本字符串的索引，从0开始。这个索引一般用来确定点击的富文本中的某一个标记（Annotation）。</p>

<h3>富文本的点击处理</h3>

<p>Text是支持富文本的（基于<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/AnnotatedString">AnnotatedString</a>）。通过ClickableText中onClick的索引参数，就能知道点击的具体是哪个Annotation。比如一个超链接标记，具体的URL对用户是不可见的，作为额外的Tag信息在Annotation中，通过索引判断当点击到了超链接上面时，可以跳转到此URL：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">AnnotatedClickableText</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">annotatedText</span> <span class="p">=</span> <span class="n">buildAnnotatedString</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">append</span><span class="p">(</span><span class="s">&quot;Click &quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// We attach this *URL* annotation to the following content</span>
</span><span class='line'>        <span class="c1">// until `pop()` is called</span>
</span><span class='line'>        <span class="n">pushStringAnnotation</span><span class="p">(</span>
</span><span class='line'>            <span class="n">tag</span> <span class="p">=</span> <span class="s">&quot;URL&quot;</span><span class="p">,</span> <span class="k">annotation</span> <span class="p">=</span> <span class="s">&quot;https://developer.android.com&quot;</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>        <span class="n">withStyle</span><span class="p">(</span>
</span><span class='line'>            <span class="n">style</span> <span class="p">=</span> <span class="n">SpanStyle</span><span class="p">(</span>
</span><span class='line'>                <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Blue</span><span class="p">,</span> <span class="n">fontWeight</span> <span class="p">=</span> <span class="n">FontWeight</span><span class="p">.</span><span class="n">Bold</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>        <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">append</span><span class="p">(</span><span class="s">&quot;here&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">pop</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">ClickableText</span><span class="p">(</span><span class="n">text</span> <span class="p">=</span> <span class="n">annotatedText</span><span class="p">,</span> <span class="n">onClick</span> <span class="p">=</span> <span class="p">{</span> <span class="n">offset</span> <span class="p">-&gt;</span>
</span><span class='line'>        <span class="c1">// We check if there is an *URL* annotation attached to the text</span>
</span><span class='line'>        <span class="c1">// at the clicked position</span>
</span><span class='line'>        <span class="n">annotatedText</span><span class="p">.</span><span class="n">getStringAnnotations</span><span class="p">(</span>
</span><span class='line'>            <span class="n">tag</span> <span class="p">=</span> <span class="s">&quot;URL&quot;</span><span class="p">,</span> <span class="n">start</span> <span class="p">=</span> <span class="n">offset</span><span class="p">,</span> <span class="n">end</span> <span class="p">=</span> <span class="n">offset</span>
</span><span class='line'>        <span class="p">).</span><span class="n">firstOrNull</span><span class="p">()</span><span class="o">?.</span><span class="n">let</span> <span class="p">{</span> <span class="k">annotation</span> <span class="p">-&gt;</span>
</span><span class='line'>            <span class="c1">// If yes, we log its value</span>
</span><span class='line'>            <span class="n">Log</span><span class="p">.</span><span class="n">d</span><span class="p">(</span><span class="s">&quot;Clicked URL&quot;</span><span class="p">,</span> <span class="k">annotation</span><span class="p">.</span><span class="n">item</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">})</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>总结</h2>

<p>本文介绍了两种最常规的文本编辑，一是文本输入，一个是文本的选择和点击，这些都是日常项目开发中的非常常见的需求。Jetpack Compose对文本的操作提供了非常友好的支持，能够应付绝大部分的需求场景。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/text/user-input">Handle user input</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/text/user-interactions">Enable user interactions</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『或跃在渊』| Advanced Animations]]></title>
    <link href="http://toughcoder.net/blog/2024/07/24/advanced-animations-in-compose/"/>
    <updated>2024-07-24T08:26:32+08:00</updated>
    <id>http://toughcoder.net/blog/2024/07/24/advanced-animations-in-compose</id>
    <content type="html"><![CDATA[<p>对于Jetpack Compose来说动画是一个很大的话题，对应的API也比较繁杂，我们在<a href="https://juejin.cn/post/7385758285960609831">前面一篇文章</a>中介绍了最为常用的创建动画的方式，在此基础之上来学习一些更为复杂的动画玩法。</p>

<p><a href="http://toughcoder.net/blog/2024/07/24/advanced-animations-in-compose/"><img src="https://static.wixstatic.com/media/0d004d_3306bc9db6214c459f675f2a417cc718~mv2.jpeg/v1/fit/w_1000%2Ch_600%2Cal_c%2Cq_80/file.jpeg" title="auto auto" ></a></p>

<!-- more -->


<h2>动画的本质：参数随时间变化</h2>

<p>前面的文章提到过属性驱动动画，比如<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/package-summary#animateFloatAsState(kotlin.Float,androidx.compose.animation.core.AnimationSpec,kotlin.Float,kotlin.String,kotlin.Function1">animateFloatAsState</a>)，本质上就是让数值随时间变化，数值再作为Composable的属性去驱动变幻，进而产生动画效果。那一坨animate&#42;AsState都是通过一个animateValueAsState函数来实现的，这个函数是一个泛型，它可以把任意的数据类型转成随时间变化的动画状态。所以当遇到自定义的数据类型时，就可以使用animateValueAsState来驱动动画。这些属性动画函数animate&#42;AsState是基于更底层的<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Animatable">Animatable</a>实现的。</p>

<h2>使用Transition来组合属性动画</h2>

<p>当动画比较复杂时，比如涉及多个属性的变化时，如果仍然使用animate&#42;AsState那一坨，虽然也是可以行的，但会让代码和逻辑都混乱不堪，特别是如果要协调多个属性动画时就更为困难。这样实现还有一个更大的问题，那就是无法复用，理论上来说动画与UI应该解耦，即使没有动效UI也是可用的，动效也应该可以应用于不同的UI。</p>

<p>这时就可以使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Transition">Transition</a>来管理和组合多个属性动画。但是Transition并不是像<a href="https://developer.android.com/reference/android/animation/AnimatorSet">AnimatorSet</a>那样的单纯的管理器，它其实是另一种概念的抽象，意为过渡，从一种状态过渡到另一种状态，状态变化的细节就是各种属性的变化。Transition支持泛型，也就是状态完全自定义，Transition定义了很多变更数值的方法如animateFloat，animateColor，animateDp等等可以用于更新不同的属性数值。前一篇文章中提到的所见即所得的动画函数（AnimatedVisibility，Crossfade和AnimatedContent）都是基于Transition来实现的。而Transition与属性动画函数animate&#42;AsState并不一样，是基于更底层的<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Animation">Animation</a>实现的。</p>

<h3>Transition创建动画的具体步骤</h3>

<p>Transition是对两个不同的状态之间过渡的封装，因此先要定义状态，基于动效的目标和特点定义状态即可，一般用枚举类型就行了，因为状态仅用于代表过渡中的一个时间点，并没有具体的意义。接下来，使用remember函数转成为Compose的State，以便能触发Recomposition，然后调用函数updateTransition来得到当前时刻的过渡状态：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">enum</span> <span class="k">class</span> <span class="nc">BoxState</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Collapsed</span><span class="p">,</span>
</span><span class='line'>    <span class="n">Expanded</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">var</span> <span class="py">currentState</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="n">BoxState</span><span class="p">.</span><span class="n">Collapsed</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="k">val</span> <span class="py">transition</span> <span class="p">=</span> <span class="n">updateTransition</span><span class="p">(</span><span class="n">currentState</span><span class="p">,</span> <span class="n">label</span> <span class="p">=</span> <span class="s">&quot;box state&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这三步是通用的，使用Transition时都一样。然后就是对于当前时刻过渡状态的去定义具体的属性数值，这步也是自定义的，看要实现的动效而定，可以使用扩展函数animate&#42;来得到的具体的数值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">rect</span> <span class="k">by</span> <span class="n">transition</span><span class="p">.</span><span class="n">animateRect</span><span class="p">(</span><span class="n">label</span> <span class="p">=</span> <span class="s">&quot;rectangle&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="n">state</span> <span class="p">-&gt;</span>
</span><span class='line'>    <span class="k">when</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">BoxState</span><span class="p">.</span><span class="n">Collapsed</span> <span class="p">-&gt;</span> <span class="n">Rect</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">0f</span><span class="p">,</span> <span class="m">100f</span><span class="p">,</span> <span class="m">100f</span><span class="p">)</span>
</span><span class='line'>        <span class="n">BoxState</span><span class="p">.</span><span class="n">Expanded</span> <span class="p">-&gt;</span> <span class="n">Rect</span><span class="p">(</span><span class="m">100f</span><span class="p">,</span> <span class="m">100f</span><span class="p">,</span> <span class="m">300f</span><span class="p">,</span> <span class="m">300f</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">val</span> <span class="py">borderWidth</span> <span class="k">by</span> <span class="n">transition</span><span class="p">.</span><span class="n">animateDp</span><span class="p">(</span><span class="n">label</span> <span class="p">=</span> <span class="s">&quot;border width&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="n">state</span> <span class="p">-&gt;</span>
</span><span class='line'>    <span class="k">when</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">BoxState</span><span class="p">.</span><span class="n">Collapsed</span> <span class="p">-&gt;</span> <span class="m">1.</span><span class="n">dp</span>
</span><span class='line'>        <span class="n">BoxState</span><span class="p">.</span><span class="n">Expanded</span> <span class="p">-&gt;</span> <span class="m">0.</span><span class="n">dp</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后，把得到的属性数值rect和borderWidth应用到Composable上即可。</p>

<h3>Transition是支持创建子Transition</h3>

<p>对于Composable结构复杂的情况时，还可以使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Transition#(androidx.compose.animation.core.Transition">createChildTransition</a>.createChildTransition(kotlin.String,kotlin.Function1))来为子布局创建Transition。这样就能够把Transition也按树形关系组织起来，以能让动效更加的协调。</p>

<h3>使用Transition来封装动画</h3>

<p>使用Transition最大的好处在于能够把动效封装起来以能复用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">enum</span> <span class="k">class</span> <span class="nc">BoxState</span> <span class="p">{</span> <span class="n">Collapsed</span><span class="p">,</span> <span class="n">Expanded</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Holds the animation values.</span>
</span><span class='line'><span class="k">private</span> <span class="k">class</span> <span class="nc">TransitionData</span><span class="p">(</span>
</span><span class='line'>    <span class="n">color</span><span class="p">:</span> <span class="n">State</span><span class="p">&lt;</span><span class="n">Color</span><span class="p">&gt;,</span>
</span><span class='line'>    <span class="n">size</span><span class="p">:</span> <span class="n">State</span><span class="p">&lt;</span><span class="n">Dp</span><span class="p">&gt;</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">color</span> <span class="k">by</span> <span class="n">color</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">size</span> <span class="k">by</span> <span class="n">size</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Create a Transition and return its animation values.</span>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">private</span> <span class="k">fun</span> <span class="nf">updateTransitionData</span><span class="p">(</span><span class="n">boxState</span><span class="p">:</span> <span class="n">BoxState</span><span class="p">):</span> <span class="n">TransitionData</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">transition</span> <span class="p">=</span> <span class="n">updateTransition</span><span class="p">(</span><span class="n">boxState</span><span class="p">,</span> <span class="n">label</span> <span class="p">=</span> <span class="s">&quot;box state&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">color</span> <span class="p">=</span> <span class="n">transition</span><span class="p">.</span><span class="n">animateColor</span><span class="p">(</span><span class="n">label</span> <span class="p">=</span> <span class="s">&quot;color&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="n">state</span> <span class="p">-&gt;</span>
</span><span class='line'>        <span class="k">when</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">BoxState</span><span class="p">.</span><span class="n">Collapsed</span> <span class="p">-&gt;</span> <span class="n">Color</span><span class="p">.</span><span class="n">Gray</span>
</span><span class='line'>            <span class="n">BoxState</span><span class="p">.</span><span class="n">Expanded</span> <span class="p">-&gt;</span> <span class="n">Color</span><span class="p">.</span><span class="n">Red</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">size</span> <span class="p">=</span> <span class="n">transition</span><span class="p">.</span><span class="n">animateDp</span><span class="p">(</span><span class="n">label</span> <span class="p">=</span> <span class="s">&quot;size&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="n">state</span> <span class="p">-&gt;</span>
</span><span class='line'>        <span class="k">when</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">BoxState</span><span class="p">.</span><span class="n">Collapsed</span> <span class="p">-&gt;</span> <span class="m">64.</span><span class="n">dp</span>
</span><span class='line'>            <span class="n">BoxState</span><span class="p">.</span><span class="n">Expanded</span> <span class="p">-&gt;</span> <span class="m">128.</span><span class="n">dp</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">remember</span><span class="p">(</span><span class="n">transition</span><span class="p">)</span> <span class="p">{</span> <span class="n">TransitionData</span><span class="p">(</span><span class="n">color</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>创建好的Transition可以用于任意的Composable：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">AnimatingBox</span><span class="p">(</span>
</span><span class='line'>    <span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">()</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">boxState</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="n">BoxState</span><span class="p">.</span><span class="n">Expanded</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">transitionData</span> <span class="p">=</span> <span class="n">updateTransitionData</span><span class="p">(</span><span class="n">boxState</span><span class="p">)</span>
</span><span class='line'>    <span class="c1">// UI tree</span>
</span><span class='line'>    <span class="n">Box</span><span class="p">(</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>            <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">transitionData</span><span class="p">.</span><span class="n">color</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="n">transitionData</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">clickable</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">boxState</span> <span class="p">=</span>
</span><span class='line'>                    <span class="k">if</span> <span class="p">(</span><span class="n">boxState</span> <span class="p">==</span> <span class="n">BoxState</span><span class="p">.</span><span class="n">Expanded</span><span class="p">)</span> <span class="n">BoxState</span><span class="p">.</span><span class="n">Collapsed</span> <span class="k">else</span> <span class="n">BoxState</span><span class="p">.</span><span class="n">Expanded</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">AnimatingColumn</span><span class="p">(</span>
</span><span class='line'>    <span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">()</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">boxState</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="n">BoxState</span><span class="p">.</span><span class="n">Collapsed</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">LaunchedEffect</span><span class="p">(</span><span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">boxState</span> <span class="p">=</span> <span class="n">BoxState</span><span class="p">.</span><span class="n">Expanded</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">val</span> <span class="py">transitionData</span> <span class="p">=</span> <span class="n">updateTransitionData</span><span class="p">(</span><span class="n">boxState</span><span class="p">)</span>
</span><span class='line'>    <span class="n">Column</span><span class="p">(</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>            <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">transitionData</span><span class="p">.</span><span class="n">color</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="n">transitionData</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span><span class="s">&quot;Apply to a column&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="file:///Users/alexhilton/Downloads/compose_libs/animation/anim_transition.gif" alt="transition_demo" /></p>

<p>可以看一看<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#AnimatedVisibility(kotlin.Boolean,androidx.compose.ui.Modifier,androidx.compose.animation.EnterTransition,androidx.compose.animation.ExitTransition,kotlin.Function1">AnimatedVisibility</a>)以及<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#Crossfade(kotlin.Any,androidx.compose.ui.Modifier,androidx.compose.animation.core.FiniteAnimationSpec,kotlin.String,kotlin.Function1">Crossfade</a>)和<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#AnimatedContent(kotlin.Any,androidx.compose.ui.Modifier,kotlin.Function1,androidx.compose.ui.Alignment,kotlin.Function2">AnimatedContent</a>)的实现，它们都是基于Transition实现的。</p>

<h2>动画的底层API</h2>

<p>到现在我们已经学习了很多创建动画的方式，从封装的层次来说，最上层是所见即所得动画函数如AnimatedVisibility，Crossfade和AnimatedContent，它们是基于<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Transition">Transition</a>实现的；属性动画函数animate&#42;AsState是基于Animatable实现的。这些函数都是Composables，也就是必须在Composition环境中才能使用。而Animatable和Transition都是基于最底层的Animation实现的，Animatable和Animation类似于View系统中的<a href="https://developer.android.com/reference/android/animation/Animator">Animator</a>，管理着某种值随时间在两个状态之间变化。它们两个只与值和时间有关，与Composition无关，因此可以在任意上下文中使用。可以用官方提供的一张图，来搞清楚API之间的关系：</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/animation-low-level.svg" alt="anim_api_level" /></p>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Animation">Animation</a>是最为底层的API，它只管理着值随时间的变化，其余的事情像动画是否已开始，是否已结束都需要调用者自己管理。它使用起来相当的麻烦，除非有必要否则一般不建议直接使用这个对象，本文也不再讨论它。</p>

<p>可以重点研究一下<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Animatable">Animatable</a>，它是基于Animation的，但是封装的较为完整。它是基于协程的单个数值变化动画，它能保证数值的变化是连续的，不过它的主要方法如<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Animatable#animateTo(kotlin.Any,androidx.compose.animation.core.AnimationSpec,kotlin.Any,kotlin.Function1">animateTo</a>)都是suspend的，意味着要在协程上下文中调用，比如启动动画就要用Animatable：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">color</span> <span class="p">=</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">Animatable</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Gray</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="n">LaunchedEffect</span><span class="p">(</span><span class="n">ok</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">color</span><span class="p">.</span><span class="n">animateTo</span><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">ok</span><span class="p">)</span> <span class="n">Color</span><span class="p">.</span><span class="n">Green</span> <span class="k">else</span> <span class="n">Color</span><span class="p">.</span><span class="n">Red</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">Box</span><span class="p">(</span><span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">().</span><span class="n">background</span><span class="p">(</span><span class="n">color</span><span class="p">.</span><span class="n">value</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用Animatable可以创建出很多富有创意的复杂动画，比如说多米诺式的顺次动画，以及并发动画。</p>

<h3>多个部件顺次动画</h3>

<p>多个部件的顺次动画也就是依次发生的动画，比如A，B，和C三个动画作用于不同的UI部件，A先启动，结束后B接着启动，结束后C再启动。比较常规的方式是使用动画回调，在前一个的结束回调中启动下一个，或者使用延时启动，B的启动延时设置为A的动画时长。</p>

<p>借助于Animatable，可以有更为优雅的方案，在同一个协程中依次调用不同的Animatable的animateTo函数就可以，让几个不同的Animatable依次启动了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">alphaAnimation</span> <span class="p">=</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">Animatable</span><span class="p">(</span><span class="m">0f</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="k">val</span> <span class="py">yAnimation</span> <span class="p">=</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">Animatable</span><span class="p">(</span><span class="m">0f</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">LaunchedEffect</span><span class="p">(</span><span class="s">&quot;animationKey&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">alphaAnimation</span><span class="p">.</span><span class="n">animateTo</span><span class="p">(</span><span class="m">1f</span><span class="p">)</span>
</span><span class='line'>    <span class="n">yAnimation</span><span class="p">.</span><span class="n">animateTo</span><span class="p">(</span><span class="m">100f</span><span class="p">)</span>
</span><span class='line'>    <span class="n">yAnimation</span><span class="p">.</span><span class="n">animateTo</span><span class="p">(</span><span class="m">500f</span><span class="p">,</span> <span class="n">animationSpec</span> <span class="p">=</span> <span class="n">tween</span><span class="p">(</span><span class="m">100</span><span class="p">))</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/animations/multiple_properties_sequential.gif" alt="anim_sequential_flow" />
注意，这个动图展示的是顺次动画的流程图，而非一个案例的效果。</p>

<h3>多个部件并发动画</h3>

<p>类似的还有并发动画，就是作用于多个不同的部件的动画同时启动，这个其实相较于顺次动画要容易一些，因为我们用Transition组合多个属性动画实际上就是并发动画。</p>

<p>除了Transition以外，用多个Animatable也可以，我们只需要启动多个协程去执行animateTo即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">alphaAnimation</span> <span class="p">=</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">Animatable</span><span class="p">(</span><span class="m">0f</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="k">val</span> <span class="py">yAnimation</span> <span class="p">=</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">Animatable</span><span class="p">(</span><span class="m">0f</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">LaunchedEffect</span><span class="p">(</span><span class="s">&quot;animationKey&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">launch</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">alphaAnimation</span><span class="p">.</span><span class="n">animateTo</span><span class="p">(</span><span class="m">1f</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">launch</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">yAnimation</span><span class="p">.</span><span class="n">animateTo</span><span class="p">(</span><span class="m">100f</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/animations/multiple_properties.gif" alt="anim_concurrent_flow" />
注意，这个是并发动画的流程图，而非动画效果。</p>

<h2>集合性布局中的元素项动画</h2>

<p>对于集合性布局来说，当其元素项发生变化时，会触发相应的动画效果，这就是<a href="https://developer.android.com/develop/ui/compose/lists#item-animations">item animations</a>。我们只需要1）为每个子元素项定义一个集合中唯一标识的key；2）然后再调用扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/lazy/LazyItemScope#(androidx.compose.ui.Modifier">Modifier.aniamteItem</a>.animateItem(androidx.compose.animation.core.FiniteAnimationSpec,androidx.compose.animation.core.FiniteAnimationSpec,androidx.compose.animation.core.FiniteAnimationSpec))；即可以在元素项变化时触发动画，它会子元素项出现，消失和发生替换时触发动画效果。</p>

<h2>动画最佳实践</h2>

<p>我们学习了这么多创建动画的方式，在实际项目中要遵守几个原则：1）尽可能优先使用Compose封装好的动画函数，不要重复造轮子；2）第二个就是要为每个动画设置一个label，所有的动画API都会有一个label参数，要尽可能为每个动画设置一个唯一的label，这个是用于Android Studio调试动画时的唯一标识。</p>

<p>再有就是动画会触发Recomposition，re-layout和re-draw，为了尽可能的避免减少re-layout和re-draw，要尽可能的使用已封装好的函数来修改属性，比如使用Modifier的扩展函数（如<a href="https://developer.android.com/develop/ui/compose/graphics/draw/modifiers">Modifier.graphicsLayer {}</a>），而不是直接去改size或者padding。</p>

<h2>References</h2>

<ul>
<li><a href="https://proandroiddev.com/animating-inside-and-outside-the-box-with-jetpack-compose-a56eba1b6af6">Animating Inside and Outside the Box with Jetpack Compose</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/value-based">Value-based animations</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/vectors">Animated vector images in Compose</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/advanced">Advanced animation example: Gestures</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『震惊百里』| Animations]]></title>
    <link href="http://toughcoder.net/blog/2024/07/24/compose-animation-basics/"/>
    <updated>2024-07-24T07:59:35+08:00</updated>
    <id>http://toughcoder.net/blog/2024/07/24/compose-animation-basics</id>
    <content type="html"><![CDATA[<p>动画对于UI来说无疑是最重要的核心功能，它能够让UI变得生动有吸引力。适当的使用动画可以提升UI的流畅性，让UI体验更为顺滑。在Jetpack Compose中有丰富的函数可以用来实现动画，今天就从一些最为常用的学起，闲话就说这么多，赶紧开工。</p>

<p><a href="http://toughcoder.net/blog/2024/07/24/compose-animation-basics/"><img src="https://koenig-media.raywenderlich.com/uploads/2020/09/JetpackComposeAnimations-twitter.png" title="auto auto" ></a></p>

<!-- more -->


<h2>所见即所得的动画函数</h2>

<p>最为方便和快速上手的就是使用封装的最好的动画函数（Animation Composables）。</p>

<h3>给Composable出现和隐藏加上动画</h3>

<p>UI元素的出现和隐藏是动画最为常用的场景，让视觉体验平滑过度，不那么的突兀。使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#AnimatedVisibility(androidx.compose.animation.core.MutableTransitionState,androidx.compose.ui.Modifier,androidx.compose.animation.EnterTransition,androidx.compose.animation.ExitTransition,kotlin.String,kotlin.Function1">函数AnimatedVisibility</a>)就可以方便的给单个部件的出现和隐藏加上动画：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'>    <span class="k">var</span> <span class="py">visible</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">mutableStateOf</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">AnimatedVisibility</span><span class="p">(</span><span class="n">visible</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Box</span><span class="p">(</span>
</span><span class='line'>            <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>                <span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="m">200.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">clip</span><span class="p">(</span><span class="n">RoundedCornerShape</span><span class="p">(</span><span class="m">8.</span><span class="n">dp</span><span class="p">))</span>
</span><span class='line'>                <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">colorGreen</span><span class="p">)</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Button</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">align</span><span class="p">(</span><span class="n">Alignment</span><span class="p">.</span><span class="n">BottomCenter</span><span class="p">),</span> <span class="n">onClick</span> <span class="p">=</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">visible</span> <span class="p">=</span> <span class="p">!</span><span class="n">visible</span>
</span><span class='line'>    <span class="p">})</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span><span class="s">&quot;Toggle Show/Hide&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/animations/animated_visibility_column.gif" alt="anim_visibility" /></p>

<p><strong>注意：</strong>AnimatedVisibility做完淡出动画时，会把其子布局从渲染树中移除。</p>

<p>AnimatedVisibility默认会使用淡入（fadeIn）/淡出（fadeOut）+缩放（shrinking）作为内容的出现/隐藏动画，如果要指定不同的动画，可以通过参数enter和参数exit来指定。<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/EnterTransition">EnterTransition</a>和<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/ExitTransition">ExitTransition</a>有很多<a href="https://developer.android.com/develop/ui/compose/animation/composables-modifiers#enter-exit-transition">预定义的动画</a>可以使用，并且可以通过+进行组合：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">var</span> <span class="py">visible</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="k">val</span> <span class="py">density</span> <span class="p">=</span> <span class="n">LocalDensity</span><span class="p">.</span><span class="n">current</span>
</span><span class='line'><span class="n">AnimatedVisibility</span><span class="p">(</span>
</span><span class='line'>    <span class="n">visible</span> <span class="p">=</span> <span class="n">visible</span><span class="p">,</span>
</span><span class='line'>    <span class="n">enter</span> <span class="p">=</span> <span class="n">slideInVertically</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// Slide in from 40 dp from the top.</span>
</span><span class='line'>        <span class="n">with</span><span class="p">(</span><span class="n">density</span><span class="p">)</span> <span class="p">{</span> <span class="p">-</span><span class="m">40.</span><span class="n">dp</span><span class="p">.</span><span class="n">roundToPx</span><span class="p">()</span> <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span> <span class="p">+</span> <span class="n">expandVertically</span><span class="p">(</span>
</span><span class='line'>        <span class="c1">// Expand from the top.</span>
</span><span class='line'>        <span class="n">expandFrom</span> <span class="p">=</span> <span class="n">Alignment</span><span class="p">.</span><span class="n">Top</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">+</span> <span class="n">fadeIn</span><span class="p">(</span>
</span><span class='line'>        <span class="c1">// Fade in with the initial alpha of 0.3f.</span>
</span><span class='line'>        <span class="n">initialAlpha</span> <span class="p">=</span> <span class="m">0.3f</span>
</span><span class='line'>    <span class="p">),</span>
</span><span class='line'>    <span class="n">exit</span> <span class="p">=</span> <span class="n">slideOutVertically</span><span class="p">()</span> <span class="p">+</span> <span class="n">shrinkVertically</span><span class="p">()</span> <span class="p">+</span> <span class="n">fadeOut</span><span class="p">()</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Text</span><span class="p">(</span><span class="s">&quot;降Compose十八掌&quot;</span><span class="p">,</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxWidth</span><span class="p">().</span><span class="n">height</span><span class="p">(</span><span class="m">200.</span><span class="n">dp</span><span class="p">))</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>仔细看AnimatedVisibility的实现，不难发现，它其实相当于是一个Column，可以当成一个Column来使用，动画是加在此布局上面的。它还支持对其子布局设置单独的动画。可以使用这个扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/AnimatedVisibilityScope#(androidx.compose.ui.Modifier">animateEnterExit</a>.animateEnterExit(androidx.compose.animation.EnterTransition,androidx.compose.animation.ExitTransition,kotlin.String))来对子布局的出现/隐藏加上特定的动画：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">CustomForChildren</span><span class="p">(</span><span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Column</span><span class="p">(</span>
</span><span class='line'>        <span class="n">horizontalAlignment</span> <span class="p">=</span> <span class="n">Alignment</span><span class="p">.</span><span class="n">CenterHorizontally</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">var</span> <span class="py">visible</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">AnimatedVisibility</span><span class="p">(</span>
</span><span class='line'>            <span class="n">visible</span> <span class="p">=</span> <span class="n">visible</span><span class="p">,</span>
</span><span class='line'>            <span class="n">enter</span> <span class="p">=</span> <span class="n">fadeIn</span><span class="p">(),</span>
</span><span class='line'>            <span class="n">exit</span> <span class="p">=</span> <span class="n">fadeOut</span><span class="p">()</span>
</span><span class='line'>        <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// Fade in/out the background and the foreground.</span>
</span><span class='line'>            <span class="n">Box</span><span class="p">(</span>
</span><span class='line'>                <span class="n">Modifier</span>
</span><span class='line'>                    <span class="p">.</span><span class="n">fillMaxWidth</span><span class="p">()</span>
</span><span class='line'>                    <span class="p">.</span><span class="n">height</span><span class="p">(</span><span class="m">200.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">LightGray</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">Box</span><span class="p">(</span>
</span><span class='line'>                    <span class="n">Modifier</span>
</span><span class='line'>                        <span class="p">.</span><span class="n">align</span><span class="p">(</span><span class="n">Alignment</span><span class="p">.</span><span class="n">Center</span><span class="p">)</span>
</span><span class='line'>                        <span class="p">.</span><span class="n">animateEnterExit</span><span class="p">(</span>
</span><span class='line'>                            <span class="c1">// Slide in/out the inner box.</span>
</span><span class='line'>                            <span class="n">enter</span> <span class="p">=</span> <span class="n">slideInHorizontally</span><span class="p">(),</span>
</span><span class='line'>                            <span class="n">exit</span> <span class="p">=</span> <span class="n">slideOutHorizontally</span><span class="p">()</span>
</span><span class='line'>                        <span class="p">)</span>
</span><span class='line'>                        <span class="p">.</span><span class="n">sizeIn</span><span class="p">(</span><span class="n">minWidth</span> <span class="p">=</span> <span class="m">256.</span><span class="n">dp</span><span class="p">,</span> <span class="n">minHeight</span> <span class="p">=</span> <span class="m">64.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>                        <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Magenta</span><span class="p">)</span>
</span><span class='line'>                <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>                        <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;你会看到不同的风景！&quot;</span><span class="p">,</span>
</span><span class='line'>                        <span class="n">style</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">typography</span><span class="p">.</span><span class="n">headlineLarge</span><span class="p">,</span>
</span><span class='line'>                        <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>                            <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">16.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>                            <span class="p">.</span><span class="n">align</span><span class="p">(</span><span class="n">Alignment</span><span class="p">.</span><span class="n">Center</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">)</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">Button</span><span class="p">(</span>
</span><span class='line'>            <span class="n">onClick</span> <span class="p">=</span> <span class="p">{</span> <span class="n">visible</span> <span class="p">=</span> <span class="p">!</span><span class="n">visible</span> <span class="p">},</span>
</span><span class='line'>            <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">16.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>        <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">Text</span><span class="p">(</span><span class="s">&quot;点击有惊喜！！！&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="file:///Users/alexhilton/Downloads/compose_libs/animation/custom_for_children.gif" alt="children_enter_exit" /></p>

<h3>两个布局之间淡入淡出</h3>

<p>AnimatedVisibility只能用于单个部件或者单个布局的出现隐藏。但有时会涉及两个部件之间的切换，虽然也是一个出现，前一个隐藏，但它们是有联动的，这时就需要使用专门的切换动画函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#(androidx.compose.animation.core.Transition">Crossfade</a>.Crossfade(androidx.compose.ui.Modifier,androidx.compose.animation.core.FiniteAnimationSpec,kotlin.Function1,kotlin.Function1))，最为典型的场景就是加载内容，先是显示加载进度，有数据可显示时就把进度隐藏，让内容显示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">CrossfadeDemo</span><span class="p">(</span><span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">done</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="k">false</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">LaunchedEffect</span><span class="p">(</span><span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="m">5000</span><span class="p">)</span>
</span><span class='line'>        <span class="n">done</span> <span class="p">=</span> <span class="k">true</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Crossfade</span><span class="p">(</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">modifier</span><span class="p">,</span>
</span><span class='line'>        <span class="n">targetState</span> <span class="p">=</span> <span class="p">!</span><span class="n">done</span><span class="p">,</span>
</span><span class='line'>        <span class="n">label</span> <span class="p">=</span> <span class="s">&quot;crossfade&quot;</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span> <span class="n">loading</span> <span class="p">-&gt;</span>
</span><span class='line'>        <span class="n">Box</span><span class="p">(</span>
</span><span class='line'>            <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">(),</span>
</span><span class='line'>            <span class="n">contentAlignment</span> <span class="p">=</span> <span class="k">if</span> <span class="p">(</span><span class="n">loading</span><span class="p">)</span> <span class="n">Alignment</span><span class="p">.</span><span class="n">Center</span> <span class="k">else</span> <span class="n">Alignment</span><span class="p">.</span><span class="n">TopStart</span>
</span><span class='line'>        <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">loading</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">Column</span><span class="p">(</span><span class="n">horizontalAlignment</span> <span class="p">=</span> <span class="n">Alignment</span><span class="p">.</span><span class="n">CenterHorizontally</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">CircularProgressIndicator</span><span class="p">(</span><span class="n">Modifier</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="m">66.</span><span class="n">dp</span><span class="p">))</span>
</span><span class='line'>                    <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>                        <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;玩命加载中...&quot;</span><span class="p">,</span>
</span><span class='line'>                        <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">16.</span><span class="n">dp</span><span class="p">),</span>
</span><span class='line'>                        <span class="n">style</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">typography</span><span class="p">.</span><span class="n">headlineMedium</span>
</span><span class='line'>                    <span class="p">)</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>                    <span class="n">text</span> <span class="p">=</span>
</span><span class='line'>                    <span class="s">&quot;&quot;&quot;</span>
</span><span class='line'>                       <span class="err">“降龙十八掌可说是【武学中的巅峰绝诣】，当真是无坚不摧、无固不破。虽招数有限，但每一招均具绝大威力。</span>
</span><span class='line'>                        <span class="err">北宋年间，丐帮帮主萧峰以此邀斗天下英雄，极少有人能挡得他三招两式，气盖当世，群豪束手。</span>
</span><span class='line'>                        <span class="err">当时共有“降龙廿八掌”，后经萧峰及他义弟虚竹子删繁就简，取精用宏，改为降龙十八掌，掌力更厚。</span>
</span><span class='line'>                        <span class="err">这掌法传到洪七公手上，在华山绝顶与王重阳、黄药师等人论剑时施展出来，王重阳等尽皆称道。”</span>
</span><span class='line'>                    <span class="s">&quot;&quot;&quot;.trimIndent(),</span>
</span><span class='line'>                    <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">16.</span><span class="n">dp</span><span class="p">),</span>
</span><span class='line'>                    <span class="n">style</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">typography</span><span class="p">.</span><span class="n">headlineMedium</span>
</span><span class='line'>                <span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="file:///Users/alexhilton/Downloads/compose_libs/animation/crossfade.gif" alt="crossfade" /></p>

<h3>通用的布局切换动画</h3>

<p>如果变幻不止有淡入淡出，或者说布局不只有两个，这时就要用更为通用也更为强大的切换动画函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#AnimatedContent(kotlin.Any,androidx.compose.ui.Modifier,kotlin.Function1,androidx.compose.ui.Alignment,kotlin.Function2">AnimatedContent</a>)，它可以用来定制多个布局之间两两切换的动画：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">var</span> <span class="py">state</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">mutableStateOf</span><span class="p">(</span><span class="n">UiState</span><span class="p">.</span><span class="n">Loading</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">AnimatedContent</span><span class="p">(</span>
</span><span class='line'>    <span class="n">state</span><span class="p">,</span>
</span><span class='line'>    <span class="n">transitionSpec</span> <span class="p">=</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">fadeIn</span><span class="p">(</span>
</span><span class='line'>            <span class="n">animationSpec</span> <span class="p">=</span> <span class="n">tween</span><span class="p">(</span><span class="m">3000</span><span class="p">)</span>
</span><span class='line'>        <span class="p">)</span> <span class="n">togetherWith</span> <span class="n">fadeOut</span><span class="p">(</span><span class="n">animationSpec</span> <span class="p">=</span> <span class="n">tween</span><span class="p">(</span><span class="m">3000</span><span class="p">))</span>
</span><span class='line'>    <span class="p">},</span>
</span><span class='line'>    <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">clickable</span><span class="p">(</span>
</span><span class='line'>        <span class="n">interactionSource</span> <span class="p">=</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">MutableInteractionSource</span><span class="p">()</span> <span class="p">},</span>
</span><span class='line'>        <span class="n">indication</span> <span class="p">=</span> <span class="k">null</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">state</span> <span class="p">=</span> <span class="k">when</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">UiState</span><span class="p">.</span><span class="n">Loading</span> <span class="p">-&gt;</span> <span class="n">UiState</span><span class="p">.</span><span class="n">Loaded</span>
</span><span class='line'>            <span class="n">UiState</span><span class="p">.</span><span class="n">Loaded</span> <span class="p">-&gt;</span> <span class="n">UiState</span><span class="p">.</span><span class="n">Error</span>
</span><span class='line'>            <span class="n">UiState</span><span class="p">.</span><span class="n">Error</span> <span class="p">-&gt;</span> <span class="n">UiState</span><span class="p">.</span><span class="n">Loading</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">},</span>
</span><span class='line'>    <span class="n">label</span> <span class="p">=</span> <span class="s">&quot;Animated Content&quot;</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span> <span class="n">targetState</span> <span class="p">-&gt;</span>
</span><span class='line'>    <span class="k">when</span> <span class="p">(</span><span class="n">targetState</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">UiState</span><span class="p">.</span><span class="n">Loading</span> <span class="p">-&gt;</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">LoadingScreen</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">UiState</span><span class="p">.</span><span class="n">Loaded</span> <span class="p">-&gt;</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">LoadedScreen</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">UiState</span><span class="p">.</span><span class="n">Error</span> <span class="p">-&gt;</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">ErrorScreen</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/animations/animated_content_slower.gif" alt="animated_content" /></p>

<h2>尺寸改变动画</h2>

<p>UI元素的尺寸变化也是非常常用的一类动画，通常作为出场和入场比较合适。对于尺寸的改变可以通过<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#(androidx.compose.ui.Modifier">Modifier.animateContentSize</a>.animateContentSize(androidx.compose.animation.core.FiniteAnimationSpec,kotlin.Function2))来实现。它会自己感知尺寸的变化，然后触发动画。可以设置一个参数finishedListener以接收动画做完了的通知。需要特别注意的是，<strong>调用的顺序很重要，animateContentSize必须在任何的尺寸设置之前</strong>，还要注意的是尺寸必须根据不同的条件有所变化，要不然动画没机会展示：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">var</span> <span class="py">expanded</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="k">false</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="n">Box</span><span class="p">(</span>
</span><span class='line'>    <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>        <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">colorBlue</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">animateContentSize</span><span class="p">()</span>
</span><span class='line'>        <span class="p">.</span><span class="n">height</span><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">expanded</span><span class="p">)</span> <span class="m">400.</span><span class="n">dp</span> <span class="k">else</span> <span class="m">200.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">fillMaxWidth</span><span class="p">()</span>
</span><span class='line'>        <span class="p">.</span><span class="n">clickable</span><span class="p">(</span>
</span><span class='line'>            <span class="n">interactionSource</span> <span class="p">=</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">MutableInteractionSource</span><span class="p">()</span> <span class="p">},</span>
</span><span class='line'>            <span class="n">indication</span> <span class="p">=</span> <span class="k">null</span>
</span><span class='line'>        <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">expanded</span> <span class="p">=</span> <span class="p">!</span><span class="n">expanded</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/animations/animated_content_size.gif" alt="" /></p>

<h2>属性状态驱动动画</h2>

<p>一般来说，动画的本质是让参数随时间变化，然后再让UI元素响应这些参数的变化，通过重新渲染，或者做渲染图层的变幻。在Compose中参数变化想影响部件的渲染，就必须把其封装成状态（State），这样参数变化就能被Compose感知到并做Recomposition。然后我们把状态的变化再通过属性设置给Composables，让其做渲染或者变幻，就形成了动画效果。这就是属性动画。</p>

<p>Compose定义了很多方法可以把参数转变成为状态，不同的参数可以通过不同的函数作用于不同的属性：</p>

<h3><a href="https://developer.android.com/develop/ui/compose/animation/value-based#animate-as-state">animateFloatAsState</a></h3>

<p>可以把值的类型为浮点数的属性变为状态驱动动画，比如透明度（alpha），尺寸（size），间隔（padding/offset），字体大小（textSize）以及像旋转/缩放/位移等等。只要是浮点类型就可以用这个来转成状态，然后再通过相应的属性设置给Composable即可。</p>

<p>最为常用的就是结合graphicsLayer图层做变幻：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">PropertyAnimation</span><span class="p">(</span><span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">showing</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="k">false</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">val</span> <span class="py">scale</span> <span class="k">by</span> <span class="n">animateFloatAsState</span><span class="p">(</span>
</span><span class='line'>        <span class="n">targetValue</span> <span class="p">=</span> <span class="k">if</span> <span class="p">(</span><span class="n">showing</span><span class="p">)</span> <span class="m">0f</span> <span class="k">else</span> <span class="m">1f</span><span class="p">,</span>
</span><span class='line'>        <span class="n">label</span> <span class="p">=</span> <span class="s">&quot;property&quot;</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">alpha</span> <span class="k">by</span> <span class="n">animateFloatAsState</span><span class="p">(</span>
</span><span class='line'>        <span class="n">targetValue</span> <span class="p">=</span> <span class="k">if</span> <span class="p">(</span><span class="n">showing</span><span class="p">)</span> <span class="m">0f</span> <span class="k">else</span> <span class="m">1f</span><span class="p">,</span>
</span><span class='line'>        <span class="n">label</span> <span class="p">=</span> <span class="s">&quot;property&quot;</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>    <span class="n">Column</span><span class="p">(</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">20.</span><span class="n">dp</span><span class="p">),</span>
</span><span class='line'>        <span class="n">horizontalAlignment</span> <span class="p">=</span> <span class="n">Alignment</span><span class="p">.</span><span class="n">CenterHorizontally</span><span class="p">,</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>            <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;降Compose十八掌&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>                <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">20.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">graphicsLayer</span> <span class="p">{</span>
</span><span class='line'>                    <span class="k">this</span><span class="p">.</span><span class="n">alpha</span> <span class="p">=</span> <span class="n">alpha</span>
</span><span class='line'>                    <span class="n">scaleX</span> <span class="p">=</span> <span class="n">scale</span>
</span><span class='line'>                    <span class="n">scaleY</span> <span class="p">=</span> <span class="n">scale</span>
</span><span class='line'>                <span class="p">},</span>
</span><span class='line'>            <span class="n">style</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">typography</span><span class="p">.</span><span class="n">headlineLarge</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>        <span class="n">Spacer</span><span class="p">(</span><span class="n">Modifier</span><span class="p">.</span><span class="n">height</span><span class="p">(</span><span class="m">50.</span><span class="n">dp</span><span class="p">))</span>
</span><span class='line'>        <span class="n">Button</span><span class="p">(</span><span class="n">onClick</span> <span class="p">=</span> <span class="p">{</span> <span class="n">showing</span> <span class="p">=</span> <span class="p">!</span><span class="n">showing</span><span class="p">})</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">Text</span><span class="p">(</span><span class="s">&quot;再点一下试试！（试试就试试！）&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="file:///Users/alexhilton/Downloads/compose_libs/animation/property.gif" alt="property_state" /></p>

<p>至于其他的像尺寸和间隔，虽然也可以，但因为像padding和offset会直接用dp或者Offset作为值，有更为舒适的API可以直接用（尽管浮点值也可以转换成为dp或者Offset）。</p>

<h3>animateColorAsState</h3>

<p>专门用于颜色值变化，指定两个值后，会在它们中间进行的插值作为动画的帧，能让颜色变化更为平滑和细腻。</p>

<h3>animateIntOffsetAsState</h3>

<p>用于把值Offset的变化变成动画，适合于使用Offset的地方，如Modifier.offset，Modifier.layout等。</p>

<h3>animateDpAsState</h3>

<p>把类型为Dp的值变为动画，适合所有能使用Dp作为参数值的地方，如padding，shadowElavation等。</p>

<p>小结：可以发现由属性状态驱动的动画使用起来比较麻烦，先是要把参数转化为状态，要管理好不同状态下参数的值，还要使用正确的函数把状态作用于Composable的属性。复杂的同时意味着强大，它能实现一些更为复杂的动画。推荐优先使用动画函数，如果无法满足再考虑用属性状态动画。</p>

<h2>页面切换转场动画</h2>

<p>页面是应用中较为完整的一屏UI，比如说新闻应用，列表页是一个页面，点开进入单篇新闻又是一个页面，用户中心是一个页面，设置又是一个页面。不同的页面之间的跳转称之为导航，用的是Jetpack中的库navigation，在Compose中通过navigation-compose做了桥接，所以在Compose中可以直接使用navigation，可以通过创建NavHost时通过参数enterTransition和exitTransition来为页面设置转场动画。可以为每个页面设置单独的转场，也可以设置一个统一的默认的转场动画：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">navController</span> <span class="p">=</span> <span class="n">rememberNavController</span><span class="p">()</span>
</span><span class='line'><span class="n">NavHost</span><span class="p">(</span>
</span><span class='line'>    <span class="n">navController</span> <span class="p">=</span> <span class="n">navController</span><span class="p">,</span> <span class="n">startDestination</span> <span class="p">=</span> <span class="s">&quot;landing&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="n">enterTransition</span> <span class="p">=</span> <span class="p">{</span> <span class="n">EnterTransition</span><span class="p">.</span><span class="n">None</span> <span class="p">},</span>
</span><span class='line'>    <span class="n">exitTransition</span> <span class="p">=</span> <span class="p">{</span> <span class="n">ExitTransition</span><span class="p">.</span><span class="n">None</span> <span class="p">}</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">composable</span><span class="p">(</span><span class="s">&quot;landing&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">ScreenLanding</span><span class="p">(</span>
</span><span class='line'>            <span class="c1">// ...</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">composable</span><span class="p">(</span>
</span><span class='line'>        <span class="s">&quot;detail/{photoUrl}&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="n">arguments</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="n">navArgument</span><span class="p">(</span><span class="s">&quot;photoUrl&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="k">type</span> <span class="p">=</span> <span class="n">NavType</span><span class="p">.</span><span class="n">StringType</span> <span class="p">}),</span>
</span><span class='line'>        <span class="n">enterTransition</span> <span class="p">=</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">fadeIn</span><span class="p">(</span>
</span><span class='line'>                <span class="n">animationSpec</span> <span class="p">=</span> <span class="n">tween</span><span class="p">(</span>
</span><span class='line'>                    <span class="m">300</span><span class="p">,</span> <span class="n">easing</span> <span class="p">=</span> <span class="n">LinearEasing</span>
</span><span class='line'>                <span class="p">)</span>
</span><span class='line'>            <span class="p">)</span> <span class="p">+</span> <span class="n">slideIntoContainer</span><span class="p">(</span>
</span><span class='line'>                <span class="n">animationSpec</span> <span class="p">=</span> <span class="n">tween</span><span class="p">(</span><span class="m">300</span><span class="p">,</span> <span class="n">easing</span> <span class="p">=</span> <span class="n">EaseIn</span><span class="p">),</span>
</span><span class='line'>                <span class="n">towards</span> <span class="p">=</span> <span class="n">AnimatedContentTransitionScope</span><span class="p">.</span><span class="n">SlideDirection</span><span class="p">.</span><span class="n">Start</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>        <span class="p">},</span>
</span><span class='line'>        <span class="n">exitTransition</span> <span class="p">=</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">fadeOut</span><span class="p">(</span>
</span><span class='line'>                <span class="n">animationSpec</span> <span class="p">=</span> <span class="n">tween</span><span class="p">(</span>
</span><span class='line'>                    <span class="m">300</span><span class="p">,</span> <span class="n">easing</span> <span class="p">=</span> <span class="n">LinearEasing</span>
</span><span class='line'>                <span class="p">)</span>
</span><span class='line'>            <span class="p">)</span> <span class="p">+</span> <span class="n">slideOutOfContainer</span><span class="p">(</span>
</span><span class='line'>                <span class="n">animationSpec</span> <span class="p">=</span> <span class="n">tween</span><span class="p">(</span><span class="m">300</span><span class="p">,</span> <span class="n">easing</span> <span class="p">=</span> <span class="n">EaseOut</span><span class="p">),</span>
</span><span class='line'>                <span class="n">towards</span> <span class="p">=</span> <span class="n">AnimatedContentTransitionScope</span><span class="p">.</span><span class="n">SlideDirection</span><span class="p">.</span><span class="n">End</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span> <span class="n">backStackEntry</span> <span class="p">-&gt;</span>
</span><span class='line'>        <span class="n">ScreenDetails</span><span class="p">(</span>
</span><span class='line'>            <span class="c1">// ...</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/animations/navigation_compose_animation.gif" alt="navigation_transition" /></p>

<h2>组合首次运行时动画</h2>

<p>对于像AnimatedVisibility以及使用animate&42;AsState属性状态动画来说，可以发现它们都是在组合发生之后才能生效，这是因为状态是为了重组而设置的，状态只会在组合之后部件渲染完了，响应事件由事件触发状态变化。组合首次运行的时候，状态仅是初始值，但不会变化，也就不会触发动画。</p>

<p>所以需要一个能在首次组合时就能运行的事件来触发动画依赖的状态，<a href="https://developer.android.com/develop/ui/compose/side-effects#launchedeffect">LaunchedEffect</a>正合适。LaunchedEffect会在首次组合时运行，可以在里面执行一些「副作用」也就是Compose组合之外的行为。可以在这里触发动画的状态，就能够让动画在首次组合时生效了。这一般用作部件的出场动画：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">LaunchAnimation</span><span class="p">(</span><span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">alphaAnimation</span> <span class="p">=</span> <span class="n">remember</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Animatable</span><span class="p">(</span><span class="m">0f</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">LaunchedEffect</span><span class="p">(</span><span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">alphaAnimation</span><span class="p">.</span><span class="n">animateTo</span><span class="p">(</span>
</span><span class='line'>            <span class="n">targetValue</span> <span class="p">=</span> <span class="m">1f</span><span class="p">,</span>
</span><span class='line'>            <span class="n">animationSpec</span> <span class="p">=</span> <span class="n">tween</span><span class="p">(</span><span class="n">durationMillis</span> <span class="p">=</span> <span class="m">30000</span><span class="p">)</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">Box</span><span class="p">(</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>            <span class="p">.</span><span class="n">offset</span><span class="p">(</span><span class="m">16.</span><span class="n">dp</span><span class="p">,</span> <span class="m">16.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="m">200.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">graphicsLayer</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">alpha</span> <span class="p">=</span> <span class="n">alphaAnimation</span><span class="p">.</span><span class="n">value</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Magenta</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="file:///Users/alexhilton/Downloads/compose_libs/animation/launch_anim.gif" alt="launch_anim" />
<strong>需要注意</strong>，LaunchedEffect的参数用作标识，参数有变化时，会再次运行，因此对于出场动画，LaunchedEffect的参数要设置为不可变的常量，如Unit。还需要注意的是，LaunchedEffect会在首次组合时运行，对于像集合性布局，会重复的使用子布局来展示元素项，所以每次元素项进入屏幕可视范围时，LaunchedEffect都会运行，动画都会触发，这并不是想要的结果，因为我们只想列表首次加载时触发动画。一个解决办法就是把状态和LaunchedEffect提高到列表的上一级Composable中。</p>

<h2>调整动画参数进行定制</h2>

<p>动画除了具体的形式以外，还有一些共性的参数可以设置，像时长，速度和是否重复，有过View动画经验的同学对此一定不会陌生。可以通过<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/AnimationSpec">AnimationSpec</a>对象来对动画参数进行定制，所有的动画API都能接受一个animationSpec参数。Compose提供了很多AnimationSpec的构造函数可以直接使用：</p>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/animation/customize#spring">spring</a> 刚性动画（或者叫做弹性动画）是模拟物理中刚性物体运动和碰撞的动画，与生活中的体验类似，所以这是默认的动画参数。可以通过调整硬度（stiffness）和阻尼系数（dampingRatio）来改变动画效果。</li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/customize#tween">tween</a> 补间动画，有一定时长，在两个值之间通过Easing函数插值形成的动画。</li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/customize#keyframes">keyframes</a> 关键帧动画，指定一定的关键节点作为动画中的帧。</li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/customize#repeatable">repeatable</a> 可重复一定次数的动画，通过RepeatMode指定重复方式（简单重复，或者反向播放）。</li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/customize#infiniterepeatable">infiniteRepeatable</a> 无限重复动画，通过RepeatMode指定重复方式。</li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/customize#snap">snap</a> 猛跳到目标值，无动画。</li>
</ul>


<p>根据不同的动画参数，可以进一步的做更细致的参数调整，比如像时长和速度。</p>

<h3>修改动画的时长和延时</h3>

<p>动画肯定都有时长，即使无限重复的动画，其每一次也是有时长的。大部分AnimationSpec函数都能接受一个durationMillis参数来调整动画的时长。</p>

<p>动画被触发后，也不一定立马播放，参数本身有一个延时可以控制，大部分都能接受一个delayMilis参数来控制播放的延时。</p>

<p>注意，刚性动画（spring）比较特殊，它不能直接控制时长和延时，刚性动画是通过硬度和阻尼来调整，时长是根据它们计算出来的，而物理世界的刚硬碰撞哪有延时？</p>

<h3>修改动画的播放速度</h3>

<p>对于补间动画和关键帧动画，还可以通过Easing函数来改变动画的播放速度，比如匀速，先快后慢，先慢后快，匀速等等。Easing函数与View动画中的<a href="https://developer.android.com/reference/android/graphics/Interpolator">Interpolator</a>是同样的东西。它是一个简单的数学函数，一个浮点数输入代表当前的时间点，一个浮点数输出代表动画应该到达的位置，取值都是0到1之间。可以理解为物理题，输入参数是时间t，输出则是位移s。</p>

<p>有很多定义好的<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/package-summary#Ease(">Easing函数</a>)可以使用，当然也可以自定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">CustomEasing</span> <span class="p">=</span> <span class="n">Easing</span> <span class="p">{</span> <span class="n">fraction</span> <span class="p">-&gt;</span> <span class="n">fraction</span> <span class="p">*</span> <span class="n">fraction</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">EasingUsage</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">value</span> <span class="k">by</span> <span class="n">animateFloatAsState</span><span class="p">(</span>
</span><span class='line'>        <span class="n">targetValue</span> <span class="p">=</span> <span class="m">1f</span><span class="p">,</span>
</span><span class='line'>        <span class="n">animationSpec</span> <span class="p">=</span> <span class="n">tween</span><span class="p">(</span>
</span><span class='line'>            <span class="n">durationMillis</span> <span class="p">=</span> <span class="m">300</span><span class="p">,</span>
</span><span class='line'>            <span class="n">easing</span> <span class="p">=</span> <span class="n">CustomEasing</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>    <span class="c1">// ……</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>未完待续</h2>

<p>动画是UI中比较复杂的话题，在Compose中更是如此，动画的本质是把参数转成状态随时间变化，状态再去驱动部件做渲染或者做变幻。本文总结了最常用的和封装层次较为高级的创建动画的方法，足以应付较为常见的动画需求场景。但涉及动画的内容还有很多，比如像与手势交互相关的动画，多个不同的部件联动的动画，以及像动画的性能调优等一些较复杂的话题，将在后续的文章中讲解。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/animation/quick-guide">Quick guide to Animations in Compose</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/composables-modifiers">Animation modifiers and composables</a></li>
<li><a href="https://medium.com/@silaelijah/animations-in-jetpack-compose-60d90a322ca3">Animations In Jetpack Compose</a></li>
<li><a href="https://medium.com/@android-world/jetpack-compose-animation-for-beginners-a-step-by-step-guide-58f1215b7c2c">Jetpack Compose Animation for Beginners: A Step-by-Step Guide</a></li>
<li><a href="https://www.jetpackcompose.net/jetpack-compose-animations">Jetpack Compose Animations</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/customize">Customize animations</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『突如其来』| Graphics Modifiers]]></title>
    <link href="http://toughcoder.net/blog/2024/06/26/graphics-with-modifiers/"/>
    <updated>2024-06-26T22:14:14+08:00</updated>
    <id>http://toughcoder.net/blog/2024/06/26/graphics-with-modifiers</id>
    <content type="html"><![CDATA[<p>在Jetpack Compose中创建自定义绘制内容的方式不止一种，除了前面提到的<a href="https://juejin.cn/post/7381826917086920742">通过Canvas函数的方式</a>以外，还可以通过Modifier的几个扩展函数更为灵活实现一些的自定义内容。今天就来学习一下如何使用Modifier的扩展函数来绘制自定义内容。</p>

<p><a href="http://toughcoder.net/blog/2024/06/26/graphics-with-modifiers/"><img src="https://files.koenig.kodeco.com/uploads/2023/11/GraphicsJetpackCompose-twitter.png" title="auto auto" ></a></p>

<!-- more -->


<h2>使用Modifier来叠加自定义内容</h2>

<p>先用一个简单的实例来看一下，如何用Modifier来实现一个自定义内容：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">textMeasurer</span> <span class="p">=</span> <span class="n">rememberTextMeasurer</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="n">Box</span><span class="p">(</span>
</span><span class='line'>    <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">()</span>
</span><span class='line'>        <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">16.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">drawWithContent</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">drawRect</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">LightGray</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">drawText</span><span class="p">(</span>
</span><span class='line'>                <span class="n">textMeasurer</span> <span class="p">=</span> <span class="n">textMeasurer</span><span class="p">,</span>
</span><span class='line'>                <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;降Compose十八掌&quot;</span><span class="p">,</span>
</span><span class='line'>                <span class="n">topLeft</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">4f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">2.2f</span><span class="p">)</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">drawCircle</span><span class="p">(</span>
</span><span class='line'>                <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Magenta</span><span class="p">,</span>
</span><span class='line'>                <span class="n">radius</span> <span class="p">=</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">10f</span><span class="p">,</span>
</span><span class='line'>                <span class="n">center</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">1.8f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">3f</span><span class="p">)</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>            <span class="n">drawCircle</span><span class="p">(</span>
</span><span class='line'>                <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Yellow</span><span class="p">,</span>
</span><span class='line'>                <span class="n">radius</span> <span class="p">=</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">12f</span><span class="p">,</span>
</span><span class='line'>                <span class="n">center</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">1.6f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">4.5f</span><span class="p">)</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>            <span class="n">drawCircle</span><span class="p">(</span>
</span><span class='line'>                <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Green</span><span class="p">,</span>
</span><span class='line'>                <span class="n">radius</span> <span class="p">=</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">14f</span><span class="p">,</span>
</span><span class='line'>                <span class="n">center</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">1.46f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">7f</span><span class="p">)</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="file:///Users/alexhilton/Desktop/hello_graphics_modifer.png" alt="hello_graphics_modifier" /></p>

<p>可以看到使用Modifier方式与Canvas略不一样，它要应用到其他的Composable上面，所以Modifier方式主要用于<strong>修改或者增强</strong>现有的Composable以达到想要的效果。仍是提供了一个带有<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/drawscope/DrawScope">DrawScope</a>指针的lambda，在这里写绘制指令。</p>

<p>Modifier提供的自定义绘制方式有四种：drawWithContent，drawBehind，drawWithCache和graphicsLayer。前面三种是是针对绘制的扩展，也就是影响绘制的内容；最后一个是图形的扩展，也就是主要用于已经绘制好了的内容的变幻。</p>

<h2>覆写式绘制</h2>

<p>最核心的扩展函数就是<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/draw/package-summary#(androidx.compose.ui.Modifier">Modifier.drawWithContent</a>.drawWithContent(kotlin.Function1))，它可以让你在目标Composable的内容绘制前或者绘制后，执行一些DrawScope的绘制命令来进行自定义的绘制。也就是说，这个扩展函数可以你让自由的决定在目标Composable绘制之前前或者绘制之后，执行自己想要的绘制命令，以实现一些额外的自定义效果。不过，要记得调用drawContent函数，这个函数是目标Composable的内容绘制函数，当然也可以不调用，那样就变成纯的自定义Composable了。</p>

<p>来看一个猫眼效果：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">DrawContentDemo</span><span class="p">(</span><span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">pointerOffset</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">mutableStateOf</span><span class="p">(</span><span class="n">Offset</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">0f</span><span class="p">))</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">Column</span><span class="p">(</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>            <span class="p">.</span><span class="n">fillMaxSize</span><span class="p">()</span>
</span><span class='line'>            <span class="p">.</span><span class="n">pointerInput</span><span class="p">(</span><span class="s">&quot;dragging&quot;</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">detectDragGestures</span> <span class="p">{</span> <span class="n">change</span><span class="p">,</span> <span class="n">dragAmount</span> <span class="p">-&gt;</span>
</span><span class='line'>                    <span class="n">pointerOffset</span> <span class="p">+=</span> <span class="n">dragAmount</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="p">.</span><span class="n">onSizeChanged</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">pointerOffset</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">2f</span><span class="p">,</span> <span class="n">it</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">2f</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="p">.</span><span class="n">drawWithContent</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">drawContent</span><span class="p">()</span>
</span><span class='line'>                <span class="c1">// draws a fully black area with a small keyhole at pointerOffset that’ll show part of the UI.</span>
</span><span class='line'>                <span class="n">drawRect</span><span class="p">(</span>
</span><span class='line'>                    <span class="n">Brush</span><span class="p">.</span><span class="n">radialGradient</span><span class="p">(</span>
</span><span class='line'>                        <span class="n">listOf</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Transparent</span><span class="p">,</span> <span class="n">Color</span><span class="p">.</span><span class="n">Black</span><span class="p">),</span>
</span><span class='line'>                        <span class="n">center</span> <span class="p">=</span> <span class="n">pointerOffset</span><span class="p">,</span>
</span><span class='line'>                        <span class="n">radius</span> <span class="p">=</span> <span class="m">100.</span><span class="n">dp</span><span class="p">.</span><span class="n">toPx</span><span class="p">(),</span>
</span><span class='line'>                    <span class="p">)</span>
</span><span class='line'>                <span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>            <span class="n">text</span> <span class="p">=</span>
</span><span class='line'>            <span class="s">&quot;&quot;&quot;</span>
</span><span class='line'>                <span class="err">“降龙十八掌可说是【武学中的巅峰绝诣】，当真是无坚不摧、无固不破。虽招数有限，但每一招均具绝大威力。</span>
</span><span class='line'>                <span class="err">北宋年间，丐帮帮主萧峰以此邀斗天下英雄，极少有人能挡得他三招两式，气盖当世，群豪束手。</span>
</span><span class='line'>                <span class="err">当时共有“降龙廿八掌”，后经萧峰及他义弟虚竹子删繁就简，取精用宏，改为降龙十八掌，掌力更厚。</span>
</span><span class='line'>                <span class="err">这掌法传到洪七公手上，在华山绝顶与王重阳、黄药师等人论剑时施展出来，王重阳等尽皆称道。”</span>
</span><span class='line'>            <span class="s">&quot;&quot;&quot;.trimIndent(),</span>
</span><span class='line'>            <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>                <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">16.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">drawWithCache</span> <span class="p">{</span>
</span><span class='line'>                    <span class="k">val</span> <span class="py">brush</span> <span class="p">=</span> <span class="n">Brush</span><span class="p">.</span><span class="n">linearGradient</span><span class="p">(</span>
</span><span class='line'>                        <span class="n">listOf</span><span class="p">(</span>
</span><span class='line'>                            <span class="n">Color</span><span class="p">(</span><span class="m">0</span><span class="n">xFF9E8240</span><span class="p">),</span>
</span><span class='line'>                            <span class="n">Color</span><span class="p">(</span><span class="m">0</span><span class="n">xFF42A565</span><span class="p">),</span>
</span><span class='line'>                            <span class="n">Color</span><span class="p">(</span><span class="m">0</span><span class="n">xFFE2E575</span><span class="p">)</span>
</span><span class='line'>                        <span class="p">)</span>
</span><span class='line'>                    <span class="p">)</span>
</span><span class='line'>                    <span class="n">onDrawBehind</span> <span class="p">{</span>
</span><span class='line'>                        <span class="n">drawRoundRect</span><span class="p">(</span>
</span><span class='line'>                            <span class="n">brush</span><span class="p">,</span>
</span><span class='line'>                            <span class="n">cornerRadius</span> <span class="p">=</span> <span class="n">CornerRadius</span><span class="p">(</span><span class="m">10.</span><span class="n">dp</span><span class="p">.</span><span class="n">toPx</span><span class="p">())</span>
</span><span class='line'>                        <span class="p">)</span>
</span><span class='line'>                    <span class="p">}</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>                <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">16.</span><span class="n">dp</span><span class="p">),</span>
</span><span class='line'>            <span class="n">style</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">typography</span><span class="p">.</span><span class="n">headlineMedium</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="file:///Users/alexhilton/Desktop/draw_content.gif" alt="cat_eye" /></p>

<h2>背景式绘制</h2>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/draw/package-summary#(androidx.compose.ui.Modifier">Modifier.drawBehind</a>.drawBehind(kotlin.Function1))是在目标Composable内容的下面一层（更远离用户的方向）执行绘制命令，所以方便添加一些背景：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">Box</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>            <span class="s">&quot;降Compose十八掌!&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>                <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">16.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">drawBehind</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">drawRoundRect</span><span class="p">(</span>
</span><span class='line'>                        <span class="n">Color</span><span class="p">(</span><span class="m">0</span><span class="n">xFFBBAAEE</span><span class="p">),</span>
</span><span class='line'>                        <span class="n">cornerRadius</span> <span class="p">=</span> <span class="n">CornerRadius</span><span class="p">(</span><span class="m">10.</span><span class="n">dp</span><span class="p">.</span><span class="n">toPx</span><span class="p">())</span>
</span><span class='line'>                    <span class="p">)</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>                <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">8.</span><span class="n">dp</span><span class="p">),</span>
</span><span class='line'>            <span class="n">style</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">typography</span><span class="p">.</span><span class="n">headlineLarge</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="file:///Users/alexhilton/Desktop/draw_behind.png" alt="" /></p>

<h2>缓存式绘制</h2>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/draw/package-summary#(androidx.compose.ui.Modifier">Modifier.drawWithCache</a>.drawWithCache(kotlin.Function1))能够缓存在lambda内部创建的一些对象，这主要是为了提升性能的。有过View经验的同学一定知道在自定义View的时候不能在onDraw里面创建对象，因为这会影响性能。这个函数的用途也在于此，把一些对象缓存起来，避免多次创建，以提升渲染性能。</p>

<p>需要注意的是，这些缓存对象的生命周期是画面尺寸未改变，以及创建对象依赖的状态没有变化，也就是说一旦画面有改变，或者依赖的状态有变化，那么缓存失效，对象要被重新创建。</p>

<p>注意，这个函数主要用于与绘制命令强相关的，或者说仅在绘制命令范围内使用的对象，如颜色啊，画刷（Brush），着色器（Shader）啊，路径（Path）啊之类的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">Box</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>            <span class="s">&quot;降Compose十八掌!&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>                <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">16.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">drawWithCache</span> <span class="p">{</span>
</span><span class='line'>                    <span class="k">val</span> <span class="py">brush</span> <span class="p">=</span> <span class="n">Brush</span><span class="p">.</span><span class="n">linearGradient</span><span class="p">(</span>
</span><span class='line'>                        <span class="n">listOf</span><span class="p">(</span>
</span><span class='line'>                            <span class="n">Color</span><span class="p">(</span><span class="m">0</span><span class="n">xFF9E82F0</span><span class="p">),</span>
</span><span class='line'>                            <span class="n">Color</span><span class="p">(</span><span class="m">0</span><span class="n">xFF42A5F5</span><span class="p">),</span>
</span><span class='line'>                            <span class="n">Color</span><span class="p">(</span><span class="m">0</span><span class="n">xFFE2E575</span><span class="p">)</span>
</span><span class='line'>                        <span class="p">)</span>
</span><span class='line'>                    <span class="p">)</span>
</span><span class='line'>                    <span class="n">onDrawBehind</span> <span class="p">{</span>
</span><span class='line'>                        <span class="n">drawRoundRect</span><span class="p">(</span>
</span><span class='line'>                            <span class="n">brush</span><span class="p">,</span>
</span><span class='line'>                            <span class="n">cornerRadius</span> <span class="p">=</span> <span class="n">CornerRadius</span><span class="p">(</span><span class="m">10.</span><span class="n">dp</span><span class="p">.</span><span class="n">toPx</span><span class="p">())</span>
</span><span class='line'>                        <span class="p">)</span>
</span><span class='line'>                    <span class="p">}</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>                <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">16.</span><span class="n">dp</span><span class="p">),</span>
</span><span class='line'>            <span class="n">style</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">typography</span><span class="p">.</span><span class="n">headlineLarge</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="file:///Users/alexhilton/Desktop/drawcache_demo.png" alt="caceh_demo" /></p>

<p>还要注意与状态（State）的区别，使用remember函数可以创建状态，这些状态的生命周期也是能跨越函数的，这也相当于是缓存。但状态的目的是让Compose感知数据变化，进面进行重组（ReComposition）。把与绘制强相关的对象放在状态里面（即用remember转成状态）并不合适。因为与绘制强相关的对象如Brush，Color和Shader等，它并不是自变量，而是因变量，这些对象依赖其底层的数据变化而需要重新创建。所以，最恰当的方式是，是把自变量如底层的颜色数值，或者图片放到状态里面，而Brush和Shader放在drawWithCache里面。</p>

<h2>图形变幻</h2>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/package-summary#(androidx.compose.ui.Modifier.graphicsLayer(kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,androidx.compose.ui.graphics.TransformOrigin,androidx.compose.ui.graphics.Shape,kotlin.Boolean,androidx.compose.ui.graphics.RenderEffect,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.CompositingStrategy">Modifier.graphicsLayer</a>))是一个图形的扩展函数，它能够把目标Composable的内容绘制到一个图层（layer）上面，然后提供了一些针对图层进行操作的函数，进而能实现一些变幻。这相当于是把绘制指令做了隔离，先把绘制结果放到一个图层上面，除了变幻，图层还能做很多事情：</p>

<ul>
<li>做类似于<a href="https://developer.android.com/reference/android/graphics/RenderNode">RenderNode</a>那样的渲染管线化（render pipeline），把图层用作管理线中的一个节点，而不用每次都重新绘制。</li>
<li>光栅化（Rasterization），图层可以光栅化，甚至离屏渲染（offscreen drawing），这可以优化动画的帧率和流畅度。</li>
</ul>


<p>不过，最主要的仍是做变幻，进而实现动画（Animation）。但要注意，图形变幻，仅是针对绘制过程做的变幻，并不影响Composable的真实的属性。</p>

<p>graphicsLayer也是一个扩展函数，它的lambda参数是GraphicsLayerScope的一个扩展函数，所以lambda中有指向GraphicsLayerScope的隐式指针。变幻，只需要指定一些参数的值即可，通过一些例子，一看就能懂。</p>

<h3>缩放/位移/旋转/透明度</h3>

<p>通过在graphicsLayer的lambda中指定相应的参数即可以实现这些变幻。对于旋转和缩放，还可以指定中心点（Origin），特别注意旋转，它是三维的有x，y，z三个参数，通过一个例子来感受这些变幻效果：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">Box</span><span class="p">(</span>
</span><span class='line'>    <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>        <span class="p">.</span><span class="n">graphicsLayer</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">scaleX</span> <span class="p">=</span> <span class="m">1.1f</span>
</span><span class='line'>            <span class="n">scaleY</span> <span class="p">=</span> <span class="m">1.6f</span>
</span><span class='line'>            <span class="n">translationX</span> <span class="p">=</span> <span class="m">30.</span><span class="n">dp</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span>
</span><span class='line'>            <span class="n">translationY</span> <span class="p">=</span> <span class="m">50.</span><span class="n">dp</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span>
</span><span class='line'>            <span class="n">alpha</span> <span class="p">=</span> <span class="m">0.7f</span>
</span><span class='line'>            <span class="n">rotationX</span> <span class="p">=</span> <span class="m">10f</span>
</span><span class='line'>            <span class="n">rotationY</span> <span class="p">=</span> <span class="m">5f</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>        <span class="s">&quot;降Compose十八掌!&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>            <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">16.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">drawWithCache</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">val</span> <span class="py">brush</span> <span class="p">=</span> <span class="n">Brush</span><span class="p">.</span><span class="n">linearGradient</span><span class="p">(</span>
</span><span class='line'>                    <span class="n">listOf</span><span class="p">(</span>
</span><span class='line'>                        <span class="n">Color</span><span class="p">(</span><span class="m">0</span><span class="n">xFF9E82F0</span><span class="p">),</span>
</span><span class='line'>                        <span class="n">Color</span><span class="p">(</span><span class="m">0</span><span class="n">xFF42A5F5</span><span class="p">),</span>
</span><span class='line'>                        <span class="n">Color</span><span class="p">(</span><span class="m">0</span><span class="n">xFFE2E575</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">)</span>
</span><span class='line'>                <span class="p">)</span>
</span><span class='line'>                <span class="n">onDrawBehind</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">drawRoundRect</span><span class="p">(</span>
</span><span class='line'>                        <span class="n">brush</span><span class="p">,</span>
</span><span class='line'>                        <span class="n">cornerRadius</span> <span class="p">=</span> <span class="n">CornerRadius</span><span class="p">(</span><span class="m">10.</span><span class="n">dp</span><span class="p">.</span><span class="n">toPx</span><span class="p">())</span>
</span><span class='line'>                    <span class="p">)</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">16.</span><span class="n">dp</span><span class="p">),</span>
</span><span class='line'>        <span class="n">style</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">typography</span><span class="p">.</span><span class="n">headlineLarge</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="file:///Users/alexhilton/Desktop/graphics_layer_transform.png" alt="transformation" /></p>

<h3>剪辑与形状</h3>

<p>剪辑（clip）是把绘制好的图层进行裁剪，裁剪的效果由形状（shape）来指定。这里可以尽情的发挥想像力，做出非常炫酷的视觉效果。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'>   <span class="n">Box</span><span class="p">(</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>            <span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="m">200.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">graphicsLayer</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">clip</span> <span class="p">=</span> <span class="k">true</span>
</span><span class='line'>                <span class="n">shape</span> <span class="p">=</span> <span class="n">CircleShape</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">(</span><span class="m">0</span><span class="n">xFFF06292</span><span class="p">))</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>            <span class="s">&quot;降Compose十八掌&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="n">style</span> <span class="p">=</span> <span class="n">TextStyle</span><span class="p">(</span><span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Black</span><span class="p">,</span> <span class="n">fontSize</span> <span class="p">=</span> <span class="m">36.</span><span class="n">sp</span><span class="p">),</span>
</span><span class='line'>            <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">align</span><span class="p">(</span><span class="n">Alignment</span><span class="p">.</span><span class="n">Center</span><span class="p">)</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="file:///Users/alexhilton/Desktop/clip_shape.png" alt="clip_shape" /></p>

<h3>图层的变幻仅对绘制生效</h3>

<p>需要注意的是，对图层做的变幻仅是对渲染结果生效，它并不影响Composable本身的属性（如大小和位置）。比如说，通过剪辑和位移，图层可能会超出Composable本身的区域，也就是说在View树中，这个元素的位置和大小还是原来的样子。</p>

<p>通过Modifier中其他的函数能对Composable本身进行剪辑这才会真正影响它自身的大小，超出边界的内容会被裁剪掉：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">Column</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">().</span><span class="n">padding</span><span class="p">(</span><span class="m">16.</span><span class="n">dp</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Box</span><span class="p">(</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>            <span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="m">200.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">clip</span><span class="p">(</span><span class="n">RectangleShape</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">border</span><span class="p">(</span><span class="m">2.</span><span class="n">dp</span><span class="p">,</span> <span class="n">Color</span><span class="p">.</span><span class="n">Black</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">graphicsLayer</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">clip</span> <span class="p">=</span> <span class="k">true</span>
</span><span class='line'>                <span class="n">shape</span> <span class="p">=</span> <span class="n">CircleShape</span>
</span><span class='line'>                <span class="n">translationX</span> <span class="p">=</span> <span class="m">50.</span><span class="n">dp</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span>
</span><span class='line'>                <span class="n">translationY</span> <span class="p">=</span> <span class="m">50.</span><span class="n">dp</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">(</span><span class="m">0</span><span class="n">xFFF06292</span><span class="p">))</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>            <span class="s">&quot;降Compose十八掌&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="n">style</span> <span class="p">=</span> <span class="n">TextStyle</span><span class="p">(</span><span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Black</span><span class="p">,</span> <span class="n">fontSize</span> <span class="p">=</span> <span class="m">36.</span><span class="n">sp</span><span class="p">),</span>
</span><span class='line'>            <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">align</span><span class="p">(</span><span class="n">Alignment</span><span class="p">.</span><span class="n">Center</span><span class="p">)</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Box</span><span class="p">(</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>            <span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="m">200.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">(</span><span class="m">0</span><span class="n">xFF4DB6AC</span><span class="p">))</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="file:///Users/alexhilton/Desktop/clip_modifier.png" alt="clip_modifier" /></p>

<h2>创建Composable的快照</h2>

<p>就像截屏一样，可以给Composable拍照，即把Composable的绘制结果转成一个Bitmap，进而可以保存成图片文件，或者分享到其他应用。主要是通过graphicsLayer的record函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">coroutineScope</span> <span class="p">=</span> <span class="n">rememberCoroutineScope</span><span class="p">()</span>
</span><span class='line'><span class="k">val</span> <span class="py">graphicsLayer</span> <span class="p">=</span> <span class="n">rememberGraphicsLayer</span><span class="p">()</span>
</span><span class='line'><span class="n">Box</span><span class="p">(</span>
</span><span class='line'>    <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>        <span class="p">.</span><span class="n">drawWithContent</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// 用record函数来录制图层</span>
</span><span class='line'>            <span class="n">graphicsLayer</span><span class="p">.</span><span class="n">record</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">// 把内容绘制到图层上面</span>
</span><span class='line'>                <span class="k">this</span><span class="n">@drawWithContent</span><span class="p">.</span><span class="n">drawContent</span><span class="p">()</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="c1">// 把图层再绘制到画布上面，以让内容能正常显示</span>
</span><span class='line'>            <span class="n">drawLayer</span><span class="p">(</span><span class="n">graphicsLayer</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="p">.</span><span class="n">clickable</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">coroutineScope</span><span class="p">.</span><span class="n">launch</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">val</span> <span class="py">bitmap</span> <span class="p">=</span> <span class="n">graphicsLayer</span><span class="p">.</span><span class="n">toImageBitmap</span><span class="p">()</span>
</span><span class='line'>                <span class="c1">// 快照Bitmap已准备好了，可以使用此Bitmap了</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">White</span><span class="p">)</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Text</span><span class="p">(</span><span class="s">&quot;Hello Android&quot;</span><span class="p">,</span> <span class="n">fontSize</span> <span class="p">=</span> <span class="m">26.</span><span class="n">sp</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p>注意：函数rememberGraphicsLayer只在compose的1.7.0-alpha07以后的版本才支持，在稳定版本中是不支持的。以BOM方式指定的依赖都是稳定版。可以单独给compose-ui:ui指定版本，如implementation(&ldquo;androidx.compose.ui:ui:1.7.0-beta03&rdquo;)</p></blockquote>

<p><img src="file:///Users/alexhilton/Desktop/graphics_to_bitmap.png" alt="bitmap_share" /></p>

<h2>如何选择恰当的方式</h2>

<p>自定义绘制有两种，一种纯的自已绘制内容，类似于直接继承View，在onDraw中绘制自己想要的效果；另外一种就是基于现有的部件进行改进和增强，类似于子例化TextView或者子例化ImageView，基于原View的内容，再进行变幻，改进或者增强。</p>

<p>视具体的问题而定，如果是第一种，就用Canvas函数，否则的话就用上面讲的Modifier的扩展函数。</p>

<p>其实如果仔细看API的实现，就可以发现Canvas函数其实是Modifier.drawBehind的一层包装：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">Canvas</span><span class="p">(</span><span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span><span class="p">,</span> <span class="n">onDraw</span><span class="p">:</span> <span class="n">DrawScope</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">=</span>
</span><span class='line'>    <span class="n">Spacer</span><span class="p">(</span><span class="n">modifier</span><span class="p">.</span><span class="n">drawBehind</span><span class="p">(</span><span class="n">onDraw</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为Spacer是一个空白的占位符，本身的内容就是空的（只有大小，没有内容），所以整体效果就相当于是一个纯的自定义绘制内容了。</p>

<p>不过本质上都是使用DrawScope对象来进行具体的绘制，上面提到的Modifier的扩展函数也都是对DrawScope的封装。Modifier的强大之处在于它可以应用于所有其他的Composables，可以让开发者非常方便的对现有的Composables进行扩展和增强。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/graphics/draw/modifiers">Graphics modifiers</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『利涉大川』| Canvas]]></title>
    <link href="http://toughcoder.net/blog/2024/06/24/canvas-in-compose/"/>
    <updated>2024-06-24T20:22:49+08:00</updated>
    <id>http://toughcoder.net/blog/2024/06/24/canvas-in-compose</id>
    <content type="html"><![CDATA[<p>任何一个GUI框架都会提供大量的预定义的UI部件，让开发者构建UI页面，但有些时候预定义的部件无法满足需求，这时就需要定制，甚至是自定义绘制的内容。对于Android开发者来说，这已经是家常便饭了，因为肯定有过用自定义View来实现一些特殊设计需求的经验。在Jetpack Compose中也有同样的方法来实现自定义绘制内容，今天就来学习一下。</p>

<p><a href="http://toughcoder.net/blog/2024/06/24/canvas-in-compose/"><img src="https://apptractor.ru/wp-content/uploads/2021/03/1_r_ly2xx-jo8vixat0xh7qa.png" title="auto auto" ></a></p>

<!-- more -->


<h2>使用Canvas来自定义内容</h2>

<p>在Compose中， 我们用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/package-summary#Canvas(android.graphics.Canvas">Canvas函数</a>)来绘制自定义内容，可以把它理解成为自定义View，但，它是一个函数，把绘制指令传给它就可以了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">textMeasurer</span> <span class="p">=</span> <span class="n">rememberTextMeasurer</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="n">Canvas</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">drawRect</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">LightGray</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">drawText</span><span class="p">(</span>
</span><span class='line'>        <span class="n">textMeasurer</span> <span class="p">=</span> <span class="n">textMeasurer</span><span class="p">,</span>
</span><span class='line'>        <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;降Compose十八掌&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="n">topLeft</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">4f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">2.2f</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">drawCircle</span><span class="p">(</span>
</span><span class='line'>        <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Magenta</span><span class="p">,</span>
</span><span class='line'>        <span class="n">radius</span> <span class="p">=</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">10f</span><span class="p">,</span>
</span><span class='line'>        <span class="n">center</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">1.8f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">3f</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>    <span class="n">drawCircle</span><span class="p">(</span>
</span><span class='line'>        <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Yellow</span><span class="p">,</span>
</span><span class='line'>        <span class="n">radius</span> <span class="p">=</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">12f</span><span class="p">,</span>
</span><span class='line'>        <span class="n">center</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">1.6f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">4.5f</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>    <span class="n">drawCircle</span><span class="p">(</span>
</span><span class='line'>        <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Green</span><span class="p">,</span>
</span><span class='line'>        <span class="n">radius</span> <span class="p">=</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">14f</span><span class="p">,</span>
</span><span class='line'>        <span class="n">center</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">1.46f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">7f</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7c77abcb2b34e0683201294f4926082~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1220&amp;h=1436&amp;s=75585&amp;e=png&amp;b=cccccc" alt="hello_canvas" /></p>

<h2>坐标系统</h2>

<p>坐标系统，与常见的GUI坐标系统，以及View的坐标系统都是一样的，左上角是原点（0，0），x轴向右，y轴向下。</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/graphics/introduction/compose_coordinate_system_drawing.png" alt="" /></p>

<h2>绘图上下文DrawScope</h2>

<p>仔细看Canvas函数，可以发现，写绘制指令的地方是一个尾部lambda，这是Compose中非常常见的一种设计方式。这个lambda被定义为DrawScope对象的一个扩展函数，所以在这个lambda中可以隐式的访问DrawScope对象。我们所使用的绘制指令，以及很多参数其实都是在通过this指针隐式的调用DrawScope。对于扩展函数不熟悉的同学可以去复习一下<a href="https://juejin.cn/post/7327478228188594202">Kotlin中函数的一些高级用法</a>。</p>

<p>通过AndroidStudio的提示，也能看到隐式的this指针是一个DrawScope对象。</p>

<p>所以呢，当查找API文档时记得要去找<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/drawscope/DrawScope">DrawScope</a>，而不是Canvas函数。其实Canvas就是一个封装的函数，也没啥东西。但还有一个略微底层一些的作为Graphics接口的<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/Canvas">对象Canvas</a>，它与Android SDK中的Canvas对象是差不多的概念。</p>

<p>接下来我们重点看看如何使用绘制指令绘制出我们需要的内容。</p>

<h2>画图形</h2>

<p>图形（Shape）是最为常见的一类绘制目标，比如圆，椭圆，矩形，线，扇形等等。不难，看一眼就会用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">Canvas</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">drawRect</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">LightGray</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">drawOval</span><span class="p">(</span>
</span><span class='line'>        <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Green</span><span class="p">,</span>
</span><span class='line'>        <span class="n">topLeft</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="m">50f</span><span class="p">,</span> <span class="m">50f</span><span class="p">),</span>
</span><span class='line'>        <span class="n">size</span><span class="p">=</span>  <span class="n">Size</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">10f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">12f</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">drawLine</span><span class="p">(</span>
</span><span class='line'>        <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Yellow</span><span class="p">,</span>
</span><span class='line'>        <span class="n">start</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="m">50</span> <span class="p">+</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">20f</span><span class="p">,</span> <span class="m">50f</span> <span class="p">+</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">24f</span><span class="p">),</span>
</span><span class='line'>        <span class="n">end</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">1.8f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">3f</span><span class="p">),</span>
</span><span class='line'>        <span class="n">strokeWidth</span> <span class="p">=</span> <span class="n">Stroke</span><span class="p">.</span><span class="n">DefaultMiter</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">drawCircle</span><span class="p">(</span>
</span><span class='line'>        <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Magenta</span><span class="p">,</span>
</span><span class='line'>        <span class="n">radius</span> <span class="p">=</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">5f</span><span class="p">,</span>
</span><span class='line'>        <span class="n">center</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">1.8f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">3f</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">drawPoints</span><span class="p">(</span>
</span><span class='line'>        <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">DarkGray</span><span class="p">,</span>
</span><span class='line'>        <span class="n">pointMode</span> <span class="p">=</span> <span class="n">PointMode</span><span class="p">.</span><span class="n">Points</span><span class="p">,</span>
</span><span class='line'>        <span class="n">strokeWidth</span> <span class="p">=</span> <span class="m">50f</span><span class="p">,</span>
</span><span class='line'>        <span class="n">points</span> <span class="p">=</span> <span class="n">genPoints</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">2f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">3f</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6b042b2c41f4899aeb3245baa99f591~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1219&amp;h=1447&amp;s=77422&amp;e=png&amp;b=cccccc" alt="shapes" /></p>

<h2>画路径</h2>

<p>路径（Path）是把一系列的数学指令转化为绘制命令，可以更为灵活的画一些曲线和图形，比如说画一个三角函数曲线：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">PathDemo</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">tm</span> <span class="p">=</span> <span class="n">rememberTextMeasurer</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Canvas</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">drawRect</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">LightGray</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">drawText</span><span class="p">(</span><span class="n">tm</span><span class="p">,</span> <span class="s">&quot;cosine of [-PI, PI]&quot;</span><span class="p">,</span> <span class="n">Offset</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">3f</span><span class="p">,</span> <span class="m">60f</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">drawLine</span><span class="p">(</span>
</span><span class='line'>            <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">DarkGray</span><span class="p">,</span>
</span><span class='line'>            <span class="n">start</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">2f</span><span class="p">),</span>
</span><span class='line'>            <span class="n">end</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">2f</span><span class="p">),</span>
</span><span class='line'>            <span class="n">strokeWidth</span> <span class="p">=</span> <span class="m">3f</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">drawLine</span><span class="p">(</span>
</span><span class='line'>            <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">DarkGray</span><span class="p">,</span>
</span><span class='line'>            <span class="n">start</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">2f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">3f</span><span class="p">),</span>
</span><span class='line'>            <span class="n">end</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">2f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">*</span> <span class="m">2</span><span class="p">/</span> <span class="m">3f</span><span class="p">),</span>
</span><span class='line'>            <span class="n">strokeWidth</span> <span class="p">=</span> <span class="m">3f</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">drawPath</span><span class="p">(</span><span class="n">genPath</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">),</span> <span class="n">Color</span><span class="p">.</span><span class="n">Magenta</span><span class="p">,</span> <span class="n">style</span> <span class="p">=</span> <span class="n">Stroke</span><span class="p">(</span><span class="n">width</span> <span class="p">=</span> <span class="m">10f</span><span class="p">))</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="nf">genPath</span><span class="p">(</span><span class="n">width</span><span class="p">:</span> <span class="n">Float</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="n">Float</span><span class="p">):</span> <span class="n">Path</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">slices</span> <span class="p">=</span> <span class="m">60</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">path</span> <span class="p">=</span> <span class="n">Path</span><span class="p">();</span>
</span><span class='line'>    <span class="n">path</span><span class="p">.</span><span class="n">moveTo</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">height</span> <span class="p">/</span> <span class="m">3f</span><span class="p">)</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">1.</span><span class="p">.</span><span class="n">slices</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">x0</span> <span class="p">=</span> <span class="m">2f</span> <span class="p">*</span> <span class="n">i</span><span class="p">.</span><span class="n">toFloat</span><span class="p">()</span> <span class="p">*</span> <span class="n">PI</span><span class="p">.</span><span class="n">toFloat</span><span class="p">()</span> <span class="p">/</span>  <span class="n">slices</span><span class="p">.</span><span class="n">toFloat</span><span class="p">()</span> <span class="p">-</span> <span class="n">PI</span><span class="p">.</span><span class="n">toFloat</span><span class="p">()</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">y0</span> <span class="p">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span> <span class="p">*</span> <span class="n">height</span> <span class="p">/</span> <span class="m">6f</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">x</span> <span class="p">=</span> <span class="n">i</span><span class="p">.</span><span class="n">toFloat</span><span class="p">()</span> <span class="p">/</span> <span class="n">slices</span><span class="p">.</span><span class="n">toFloat</span><span class="p">()</span> <span class="p">*</span> <span class="n">width</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">y</span> <span class="p">=</span> <span class="n">y0</span> <span class="p">+</span> <span class="n">height</span> <span class="p">/</span> <span class="m">2f</span>
</span><span class='line'>        <span class="n">path</span><span class="p">.</span><span class="n">lineTo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</span><span class='line'>        <span class="n">path</span><span class="p">.</span><span class="n">moveTo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">path</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">path</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd5a91eab8a34a8fae51874ec21d989d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1217&amp;h=1994&amp;s=104973&amp;e=png&amp;b=cccccc" alt="path" />
路径在绘制中是非常强大的功能，可以实现非常炫酷的动画效果。</p>

<h2>画文字</h2>

<p>文字是特别重要的UI元素，通常情况下我们都是过Text来展示文字，再与其他部件进行组合就能满足需求。一般来说不需要在自定义内容也使用文字，因为文字绘制一般来说比较复杂，因为像基线对齐，字体样式，字体大小等等，都需要考虑。文字部件Text内容其实也是用与自定义一样的更低层的API来实现的，但它把像对齐，样式，富文本等等都封装好了。</p>

<p>DrawScope也提供了绘制文字的函数，不过呢使用起来比较麻烦，需要详细计算文字所占用的区域大小，而文字的measure通常是非常麻烦的，因为像文字的字体以及文字大小都会影响到measure，因此measure要保存成为一个状态，这样当有影响到文字绘制的因素发生变化时，measure就会发生变化，进而触发Re-Composition：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">TextDemo</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">textMeasure</span> <span class="p">=</span> <span class="n">rememberTextMeasurer</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Canvas</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">measuredText</span> <span class="p">=</span>
</span><span class='line'>            <span class="n">textMeasure</span><span class="p">.</span><span class="n">measure</span><span class="p">(</span>
</span><span class='line'>                <span class="n">AnnotatedString</span><span class="p">(</span>
</span><span class='line'>                    <span class="n">text</span> <span class="p">=</span>
</span><span class='line'>                    <span class="s">&quot;&quot;&quot;</span>
</span><span class='line'>                        <span class="err">“降龙十八掌可说是【武学中的巅峰绝诣】，当真是无坚不摧、无固不破。虽招数有限，但每一招均具绝大威力。</span>
</span><span class='line'>                        <span class="err">北宋年间，丐帮帮主萧峰以此邀斗天下英雄，极少有人能挡得他三招两式，气盖当世，群豪束手。</span>
</span><span class='line'>                        <span class="err">当时共有“降龙廿八掌”，后经萧峰及他义弟虚竹子删繁就简，取精用宏，改为降龙十八掌，掌力更厚。</span>
</span><span class='line'>                        <span class="err">这掌法传到洪七公手上，在华山绝顶与王重阳、黄药师等人论剑时施展出来，王重阳等尽皆称道。”</span>
</span><span class='line'>                    <span class="s">&quot;&quot;&quot;.trimIndent(),</span>
</span><span class='line'>                    <span class="n">spanStyle</span> <span class="p">=</span> <span class="n">SpanStyle</span><span class="p">(</span>
</span><span class='line'>                        <span class="n">fontSize</span> <span class="p">=</span> <span class="m">20.</span><span class="n">sp</span><span class="p">,</span>
</span><span class='line'>                        <span class="n">fontWeight</span> <span class="p">=</span> <span class="n">FontWeight</span><span class="p">.</span><span class="n">ExtraBold</span><span class="p">,</span>
</span><span class='line'>                        <span class="n">brush</span> <span class="p">=</span> <span class="n">Brush</span><span class="p">.</span><span class="n">verticalGradient</span><span class="p">(</span><span class="n">listOf</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Magenta</span><span class="p">,</span> <span class="n">Color</span><span class="p">.</span><span class="n">Cyan</span><span class="p">,</span> <span class="n">Color</span><span class="p">.</span><span class="n">Blue</span><span class="p">))</span>
</span><span class='line'>                    <span class="p">)</span>
</span><span class='line'>                <span class="p">),</span>
</span><span class='line'>                <span class="n">constraints</span> <span class="p">=</span> <span class="n">Constraints</span><span class="p">.</span><span class="n">fixed</span><span class="p">(</span>
</span><span class='line'>                    <span class="n">width</span> <span class="p">=</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">1.6f</span><span class="p">).</span><span class="n">toInt</span><span class="p">(),</span>
</span><span class='line'>                    <span class="n">height</span> <span class="p">=</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">2f</span><span class="p">).</span><span class="n">toInt</span><span class="p">()</span>
</span><span class='line'>                <span class="p">),</span>
</span><span class='line'>                <span class="n">overflow</span> <span class="p">=</span> <span class="n">TextOverflow</span><span class="p">.</span><span class="n">Ellipsis</span><span class="p">,</span>
</span><span class='line'>                <span class="n">style</span> <span class="p">=</span> <span class="n">TextStyle</span><span class="p">(</span><span class="n">fontSize</span> <span class="p">=</span> <span class="m">18.</span><span class="n">sp</span><span class="p">)</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">drawText</span><span class="p">(</span>
</span><span class='line'>            <span class="n">textLayoutResult</span> <span class="p">=</span> <span class="n">measuredText</span><span class="p">,</span>
</span><span class='line'>            <span class="n">topLeft</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="m">60f</span><span class="p">,</span> <span class="m">60f</span><span class="p">)</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2aaf95cc9fff45dc9c963065098b0faa~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1220&amp;h=1774&amp;s=275925&amp;e=png&amp;b=fefbff" alt="text" /></p>

<h2>画图片</h2>

<p>图片（Image）是与文字类似的非常重要的UI元素，像图标，头像，表情，背景图，Banner图，以及内容中的图像都属于图片元素，一般情况下用Image函数可以用来展示图片。</p>

<p>对于自定义绘制内容也可以使用图片，DrawScope中有提供绘制图片的方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">dogImage</span> <span class="p">=</span> <span class="n">ImageBitmap</span><span class="p">.</span><span class="n">imageResource</span><span class="p">(</span><span class="n">id</span> <span class="p">=</span> <span class="n">R</span><span class="p">.</span><span class="n">drawable</span><span class="p">.</span><span class="n">dog</span><span class="p">)</span>
</span><span class='line'><span class="n">Canvas</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">(),</span> <span class="n">onDraw</span> <span class="p">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">drawImage</span><span class="p">(</span><span class="n">dogImage</span><span class="p">)</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_image.png" alt="" /></p>

<h2>变幻</h2>

<p>除了绘制以外，DrawScope还提供了一系列做变幻的函数。包括缩放，位移，旋转这些变幻直接作用于绘制指令上面。</p>

<h3>缩放</h3>

<p>使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/drawscope/DrawScope#(androidx.compose.ui.graphics.drawscope.DrawScope">DrawScope.scale</a>.scale(kotlin.Float,kotlin.Float,androidx.compose.ui.geometry.Offset,kotlin.Function1))函数来对绘制指令进行缩放，参数是x轴方向和y轴方向的缩放倍数（大于1放大，小于1缩小），还可以指定中心坐标，默认是几何中心。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">Canvas</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">scale</span><span class="p">(</span><span class="n">scaleX</span> <span class="p">=</span> <span class="m">10f</span><span class="p">,</span> <span class="n">scaleY</span> <span class="p">=</span> <span class="m">15f</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">drawCircle</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Blue</span><span class="p">,</span> <span class="n">radius</span> <span class="p">=</span> <span class="m">20.</span><span class="n">dp</span><span class="p">.</span><span class="n">toPx</span><span class="p">())</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_scale.png" alt="" /></p>

<h3>位移</h3>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/drawscope/DrawScope#(androidx.compose.ui.graphics.drawscope.DrawScope">DrawScope.translate</a>.translate(kotlin.Float,kotlin.Float,kotlin.Function1))可以实现位移，参数是x方向或者y方向的距离。参数为正，是沿着坐标轴正向，为负就是反向。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">Canvas</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">translate</span><span class="p">(</span><span class="n">left</span> <span class="p">=</span> <span class="m">100f</span><span class="p">,</span> <span class="n">top</span> <span class="p">=</span> <span class="p">-</span><span class="m">300f</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">drawCircle</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Blue</span><span class="p">,</span> <span class="n">radius</span> <span class="p">=</span> <span class="m">200.</span><span class="n">dp</span><span class="p">.</span><span class="n">toPx</span><span class="p">())</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_translate.png" alt="" /></p>

<h3>旋转</h3>

<p>用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/drawscope/DrawScope#(androidx.compose.ui.graphics.drawscope.DrawScope">DrawScope.rotate</a>.rotate(kotlin.Float,androidx.compose.ui.geometry.Offset,kotlin.Function1))函数实现旋转，参数为正时是顺时针的角度，为负就是逆时针，可以指定中心点，默认是几何中心。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">Canvas</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">rotate</span><span class="p">(</span><span class="n">degrees</span> <span class="p">=</span> <span class="m">45F</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">drawRect</span><span class="p">(</span>
</span><span class='line'>            <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Gray</span><span class="p">,</span>
</span><span class='line'>            <span class="n">topLeft</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">x</span> <span class="p">=</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">3F</span><span class="p">,</span> <span class="n">y</span> <span class="p">=</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">3F</span><span class="p">),</span>
</span><span class='line'>            <span class="n">size</span> <span class="p">=</span> <span class="n">size</span> <span class="p">/</span> <span class="m">3F</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_rotate.png" alt="" /></p>

<h3>画布尺寸调整</h3>

<p>用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/drawscope/package-summary#(androidx.compose.ui.graphics.drawscope.DrawScope">DrawScope.inset</a>.inset(kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Function1))函数来对DrawScope的画布进行调整，参数是周围四个方向的边距偏移量。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">Canvas</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">canvasQuadrantSize</span> <span class="p">=</span> <span class="n">size</span> <span class="p">/</span> <span class="m">2F</span>
</span><span class='line'>    <span class="n">inset</span><span class="p">(</span><span class="n">horizontal</span> <span class="p">=</span> <span class="m">50f</span><span class="p">,</span> <span class="n">vertical</span> <span class="p">=</span> <span class="m">30f</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">drawRect</span><span class="p">(</span><span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Green</span><span class="p">,</span> <span class="n">size</span> <span class="p">=</span> <span class="n">canvasQuadrantSize</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样调整后，inset内部的lambda中的绘制指令的尺寸size会受影响，size.width = width - 2 * horizontal，size.height = height - 2 * vertical，相当于是加了padding。</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_inset.png" alt="" /></p>

<h3>组合变幻</h3>

<p>变幻除了可以单独使用，还可以组合起来使用，能更简便的实现变幻效果。使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/drawscope/package-summary#(androidx.compose.ui.graphics.drawscope.DrawScope">DrawScope.withTransform</a>.withTransform(kotlin.Function1,kotlin.Function1))来组合变幻：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">Canvas</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">withTransform</span><span class="p">({</span>
</span><span class='line'>        <span class="n">translate</span><span class="p">(</span><span class="n">left</span> <span class="p">=</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">5F</span><span class="p">)</span>
</span><span class='line'>        <span class="n">rotate</span><span class="p">(</span><span class="n">degrees</span> <span class="p">=</span> <span class="m">45F</span><span class="p">)</span>
</span><span class='line'>    <span class="p">})</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">drawRect</span><span class="p">(</span>
</span><span class='line'>            <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Gray</span><span class="p">,</span>
</span><span class='line'>            <span class="n">topLeft</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">x</span> <span class="p">=</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">3F</span><span class="p">,</span> <span class="n">y</span> <span class="p">=</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">3F</span><span class="p">),</span>
</span><span class='line'>            <span class="n">size</span> <span class="p">=</span> <span class="n">size</span> <span class="p">/</span> <span class="m">3F</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/graphics/introduction/compose_graphics_multiple_transforms.png" alt="" /></p>

<h2>总结</h2>

<p>今天主要学习了如何通过Canvas函数来实现自定义绘制内容，Canvas给我们了封装了一个包含有DrawScope的lambda，通过DrawScope提供的各种绘制指令可以实现我们的想要的自定义内容。可以自由的通过绘制图形，文字和图像，并且可以做变幻，以实现一些特效。相信通过今天的学习，足可以应付常见的自定义绘制需求。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/graphics/draw/overview">Graphics in Compose</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『潜龙勿用』| Thinking in Compose]]></title>
    <link href="http://toughcoder.net/blog/2024/06/15/thinking-in-compose/"/>
    <updated>2024-06-15T20:12:15+08:00</updated>
    <id>http://toughcoder.net/blog/2024/06/15/thinking-in-compose</id>
    <content type="html"><![CDATA[<p>Jetpack Compose是Android平台的现代化的声明式UI框架。它提供了一套声明式API，可以不必再机械式的操作View就能构建 出UI，从而更容易的构建出应用的UI，并且易于维护，易于扩展。今天我们重点理解一下Jetpack Compose背后的思想，学会以声明式思维来思考，进而写出更加专业的声明式UI代码。</p>

<p><a href="http://toughcoder.net/blog/2024/06/15/thinking-in-compose/"><img src="https://anahisalgado.com/wp-content/uploads/2022/05/jetpack-compose-anncode-anahi-salgado.png" title="auto auto" ></a></p>

<!-- more -->


<h2>从过程式UI到声明式UI</h2>

<p>通过前面的学习，我们已经知道声明式UI的特点了，它是一坨一坨的函数。状态（要显示给用户的数据）作为参数，再写出使用这些状态的函数，然后Compose会运行这些函数最终生成UI。不必关心函数具体的执行，以及执行的结果，我们只需要描述好需要显示什么就可以了，简言之就是定义好如何使用数据的函数即可。这就是声明式UI的核心思想，它让开发者把精力放在你想要展示什么，而非繁杂的如何展示。</p>

<p><img src="https://s3-eu-west-2.amazonaws.com/wolfpack-digital-attachments-production/ckeditor_assets/pictures/374/content_Building_apps_with_declarative_UI_5.png" alt="" /></p>

<p>实际上这是函数式编程范式的一种，时刻记着我们都是在定义函数就可以了。</p>

<h2>Compose的工作原理</h2>

<p>传统的过程式UI（比如Android中的View和XML）是基于OO（面向对象）的，每个元素都是一个对象，它有一些属性，要构建出一颗View tree，然后当有事件变化或者有数据更新时，我们会具体的刷新具体的View。但像声明式UI，比如Compose，工作方式并不是这样的，开发者写出的并不是View tree，而是一系列描述着要展示数据的函数，其余的事情都是Comose负责。</p>

<p>Compose会执行这些函数，收集它们的结果，生成一颗<a href="https://www.geeksforgeeks.org/difference-between-virtual-dom-and-real-dom/">虚拟的View tree</a>，这一步要叫做Compositon；然后再把虚拟的View tree，生成真实的与平台相关的View tree，这一步叫做渲染。当有状态变化的时候，代表数据有更新，需要刷新UI，这时Compose会重新执行一遍函数，这就叫做重组Recomposition。因为重组会发生很多次，如果每次重组都直接去更新目标平台View tree开销太大了，因此就有了虚拟View tree这一层，每次重新会重新生成一颗虚拟View tree，然后比较两颗虚拟View tree，只当差异时，再用差异去更新目标平台的View tree。</p>

<p>有同学举手了，说这费二遍事，性能肯定会变得更差吧？这位同学先坐下。确实多费了一道工序，但随着CPU性能越来越高，以及像<a href="https://www.infoq.cn/article/react-dom-diff">virtual dom diff技术</a>的应用，Compose本身性能的差异已经追上传统方式了。但它的优势，比如开发效率以及可扩展性却无限放大，总的来说收益还是很大的。</p>

<p>说到底这是函数式编程方式，那么就会有函数式编程的特点，比如说这些函数的执行顺序不一定就是开发者写的那样，再比如说这些函数可能会并行的执行，甚至有些函数会被跳过。并且呢，重组可能随时发生，而且发生的很频繁。Compose这样做是为了保证底层UI能够及时得到刷新。</p>

<p>那么，在使用Compose时，就有一些注意事项，比如尽可能的使用Stateless的函数，尽可能的减少副作用。以及千万不要依赖函数的执行顺序。</p>

<h2>拆分为细粒度的函数，加强复用</h2>

<p>Compose是以函数来搭建UI，这相比于xml方式的一个最大的好处就是这非常方便的复用，因为可以像重构代码那样，把重复的代码抽成可复用函数。要以「自上而下」函数调用的方式来构建UI。</p>

<p>推荐的方式是，先把整个页面划分为不同的区域，每个区域是一个函数（Composable）；再把每个区域细分成为更为细节的函数；这些细节函数如果是共性的就复用。这样做的方式，不但能够做到代码结构清晰，可读性很强，且易于维护，方便扩展。非常容易找到与UI的对应，而且容易复用，如果有新的页面，把不同的细节函数组合起来就可以了。</p>

<p>其实以前用XML也应该这样，但毕竟XML不像代码这样方便的管理和复用，拆成过多的XML文件不但难以管理，也会影响编译速度。</p>

<p>可以做一下<a href="https://developer.android.com/codelabs/jetpack-compose-layouts#0">Basic layouts in Compose</a>，这个CodeLab非常好的演示了如何「自顶而下」的用Compose来构建UI。</p>

<h2>Preview局部而非整体</h2>

<p>Compose的一个强大功能就是即时Preview，不必非要到设备上运行就可以看到UI效果。不过呢Preview需要数据，而且要是静态的数据，也就是需要Mock。这对于复杂的数据来说是致命的缺点。比如说像字段非常之多的列表，或者有很多特殊字段的对象，Mock起来相当的麻烦。</p>

<p>一个可行的办法就是要尽可能的Preview局部，数据复杂，必然对应着复杂的页面，把复杂的页面拆开，变成一系列的简单的Composable的组合，这时每个Composable对应的数据都是相对简单的，只有几个参数，这时就是可Preview的了，Mock起来就容易得多了。</p>

<p>具体的来说，对于像集合性UI，我们只需要预览它的一个单元项就可以了，只要一个单元项没啥问题，组合起来看集合地无非就是重复很多个；再比如对于复杂的多字段对象，划分成为几个不同的子区域，每个子区域对应一个函数，这个函数经过Preview后没啥问题，那把这些组合起来成为一个整体后也不会有太大的问题。</p>

<p>Preview的作用是快速预览，减少编译运行的次数，毕竟编译运行一次要慢得多，所以要以简单快捷方便为主。而并不是真的当成运行结果，最终肯定要以在手机上运行结果为准，并进行最终的调试。</p>

<h2>总结</h2>

<p>对于习惯了View和XML方式的同学来说，开始用Compose肯定会略有不习惯，就需要理解一下它的原理，转变成声明式UI的思维，以函数为核心来思考问题，这样才能写出比较专业的Compose代码。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/mental-model">Thinking in Compose</a></li>
<li><a href="https://proandroiddev.com/why-we-adopted-jetpack-compose-b66bfd3dbde5">Why We Adopted Jetpack Compose</a></li>
<li><a href="https://medium.com/israeli-tech-radar/declarative-ui-what-how-and-why-13e092a7516f">Declarative UI — What, How, and Why?</a></li>
<li><a href="https://www.rootstrap.com/blog/imperative-v-declarative-ui-design-is-declarative-programming-the-future">Imperative v Declarative UI Design - Is Declarative Programming the future?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Principle of Inclusion Exclusion Made Easy]]></title>
    <link href="http://toughcoder.net/blog/2024/06/13/inclusion-exclusion-principle/"/>
    <updated>2024-06-13T20:45:29+08:00</updated>
    <id>http://toughcoder.net/blog/2024/06/13/inclusion-exclusion-principle</id>
    <content type="html"><![CDATA[<p><a href="https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/">容斥原理</a>，是指在计数的时候，先不考虑重复问题，先把包含某种对象的统计出来，再把重复的排除掉。</p>

<p><a href="http://toughcoder.net/blog/2024/06/13/inclusion-exclusion-principle/"><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.oW-5-IkJnUeOjVM7ZBtMAwAAAA?rs=1&pid=ImgDetMain" title="auto auto" ></a></p>

<!-- more -->


<p>比如说，考试，15人数学满分，12人语文满分，并且有4人语文和数学都满分，求至少有一个人满分的同学有多少个？</p>

<p>答案是15 + 12 - 4。</p>

<p>理解起来就是，重复的部分被多加了一次，最后再减去重复的人即可。</p>

<p>再如小于某个数x中，能被3或者5整除的数有多少？答案是 x/3 + x / 5 - x /3x5。同样是重复的计算了两次，减去一次即可。</p>

<p>容斥原理，不复杂，也不能单独用来求解问题，一般都是用于统计计数。</p>

<h3>相关问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/nth-magical-number/description/">878. 第 N 个神奇数字</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/nth-magical-number/solutions/2808476/xi-you-yuan-su-878-di-n-ge-shen-qi-shu-z-udgp/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/ugly-number-iii/description/">1201. 丑数 III</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/ugly-number-iii/solutions/2808790/xi-you-yuan-su-1201-chou-shu-iiishu-xue-wha7w/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>References</h2>

<ul>
<li><a href="https://brilliant.org/wiki/principle-of-inclusion-and-exclusion-pie/">Principle of Inclusion and Exclusion (PIE)</a></li>
<li><a href="https://mathworld.wolfram.com/Inclusion-ExclusionPrinciple.html">Inclusion-Exclusion Principle</a></li>
<li><a href="https://www.geeksforgeeks.org/inclusion-exclusion-various-applications/">Inclusion-Exclusion and its various Applications</a></li>
<li><a href="https://www.cut-the-knot.org/arithmetic/combinatorics/InclusionExclusion.shtml">The Inclusion-Exclusion Principle</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tree in Graph]]></title>
    <link href="http://toughcoder.net/blog/2024/06/06/tree-in-graph/"/>
    <updated>2024-06-06T22:02:26+08:00</updated>
    <id>http://toughcoder.net/blog/2024/06/06/tree-in-graph</id>
    <content type="html"><![CDATA[<p>树是图的一种特殊形式，图中的树也是比较难的一类问题。</p>

<p><a href="http://toughcoder.net/blog/2024/06/06/tree-in-graph/"><img src="https://vivadifferences.com/wp-content/uploads/2019/11/Tree-In-Programming.png" title="auto auto" ></a></p>

<!-- more -->


<h2>树形图</h2>

<p>有一类特殊的图，本质上是树，但是以图的形式给出，通常涉及不同子树的特征值计算。这种图本质上是树，无环。通常顶点是n个，边的个数是n-1个，无环，每个顶点都可以成为树的根，边有权重。通常是求解与顶点连通的子树的特征值。</p>

<p>通常需要用到乘法原理。</p>

<p>第一步，把问题分解为根和子树的问题，需要以每个顶点为根，子树就是与其相邻的顶点为根的子树，这种根+子树的组合就是一个子问题；</p>

<p>第二步，乘法原理。每个「子树」会得到一个数量，子问题的结果就用到乘法原理来求得：</p>

<p><img src="https://pic.leetcode.cn/1709427910-nOCIAc-b125C.png" alt="" /></p>

<p>第三步，对于每个子树，用其他方法得到需要的「数量」值。这个不同的问题不一样。但本质上，要么是连通分量问题（可用并查集），要么是路径问题。因为这是在一个子树上面的问题，相当于树的问题，通常DFS可求得结果。</p>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/count-valid-paths-in-a-tree/description/">2867. 统计树中的合法路径数目</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/count-valid-paths-in-a-tree/solutions/2777173/xi-you-yuan-su-zhi-shu-ai-shai-fa-bing-c-2rdn/">题解</a> </td>
<td style="text-align:left;"> 并查集 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/count-pairs-of-connectable-servers-in-a-weighted-tree-network/description/">3067. 在带权树网络中统计可连接服务器对数目</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/count-pairs-of-connectable-servers-in-a-weighted-tree-network/solutions/2802677/xi-you-yuan-su-3067-zai-dai-quan-shu-wan-7ioe/">题解</a> </td>
<td style="text-align:left;"> DFS </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/description/">1466. 重新规划路线</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/solutions/2301538/xi-you-yuan-su-1466-zhong-xin-gui-hua-lu-juiu/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『鸿渐于陆』| State]]></title>
    <link href="http://toughcoder.net/blog/2024/06/04/jetpack-compose-state/"/>
    <updated>2024-06-04T21:05:02+08:00</updated>
    <id>http://toughcoder.net/blog/2024/06/04/jetpack-compose-state</id>
    <content type="html"><![CDATA[<p>Jetpack Compose是一种声明式的UI框架，用以构建GUI应用程序。通过前面的文章我们学会了<a href="https://juejin.cn/post/7371239685702844454">如何使用元素来填充页面</a>，也学会了<a href="https://juejin.cn/post/7373867360020480038">如何装饰元素</a>，但这还不够。UI还必须处理与页面直接相关的数据，因为这是对用户有价值的东西。今天就来学习一下Compose如何处理数据。</p>

<p><a href="http://toughcoder.net/blog/2024/06/04/jetpack-compose-state/"><img src="https://alexzh.com/content/images/size/w2000/2021/02/logo-1.65-1980-4.png" title="auto auto" ></a></p>

<!-- more -->


<h2>什么是状态</h2>

<p>状态（State）其实就是数据，Compose是一种UI框架，UI要显示数据才会有价值。但是呢，Compose毕竟是一种UI框架，它应该只处理需要展示给用户的那部分数据，所以，这里说的数据应该是经过业务逻辑处理过的，需要展示给用户的那部分数据。也就是说只需要处理从ViewModel推送过来的数据即可。</p>

<p>此外，还有一部分只需要在UI内部处理的数据，比如像一些控件的状态，动画中的参数变化等等，这些数据需要完全在UI部分处理掉，都不应该暴露给ViewModel。</p>

<p>因此，对于Compose来说的状态（State），就包括两部分，一部分是从ViewModel推过来的需要展示的数据（具体叫做UiState），以及UI内部逻辑中的状态。</p>

<h2>状态与重组</h2>

<p>本质上来说Compose就是坨函数，更新UI的方式就变成了用新的参数来重新调用这些函数。这些参数便是状态了。任何时候状态发生变化就会发生重组（re-Composition），结果就是UI刷新了，最新的数据呈现给了用户。感知状态变化如何影响着UI的刷新就是状态管理。</p>

<p>有些术语需要说明一下：组合（Composition）描述着UI的生成过程，也即当Compose执行我们所声明的一坨坨函数的时候；初始组合（Initial Composition）首次执行这一坨函数的过程；重组（re-Composition）当状态有更新，重新运行某些函数的过程。</p>

<p>UI要想刷新，呈现最新的数据，这就需要Compose进行重组，而重组是由状态更新触发的，也就是说我们需要用新的数据来重新执行这一坨函数。对于业务逻辑数据，这很好办，可以通过ViewModel推送新的数据，然后重新调用UI函数即可。但这并没有看起来那么容易，因为ViewModel与UI的关系通常不是ViewModel直接持有着UI的对象或者函数，更多的时候是Compose的函数（Composable）中创建持有ViewModel对象，一个函数是没有办法直接调用自身的，这会陷入死循环的（StackOverFlow）。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">WellnessScreen</span><span class="p">(</span>
</span><span class='line'>    <span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">,</span>
</span><span class='line'>    <span class="n">wellnessViewModel</span><span class="p">:</span> <span class="n">WellnessViewModel</span> <span class="p">=</span> <span class="n">viewModel</span><span class="p">()</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Column</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">modifier</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">WellnessTasksList</span><span class="p">(</span>
</span><span class='line'>            <span class="n">list</span> <span class="p">=</span> <span class="n">wellnessViewModel</span><span class="p">.</span><span class="n">tasks</span><span class="p">,</span>
</span><span class='line'>            <span class="n">onCheckedTask</span> <span class="p">=</span> <span class="p">{</span> <span class="p">},</span>
</span><span class='line'>            <span class="n">onCloseTask</span> <span class="p">=</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于UI逻辑中的数据也是如此，比如说，一个很简单的按扭计数，按照常规的理解，似乎可以这样写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">WaterCounter</span><span class="p">(</span><span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">count</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Column</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">16.</span><span class="n">dp</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>            <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;You have had $count glasses.&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="n">modifier</span> <span class="p">=</span> <span class="n">modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">16.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>        <span class="n">Row</span><span class="p">(</span>
</span><span class='line'>            <span class="n">modifier</span> <span class="p">=</span> <span class="n">modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="n">top</span> <span class="p">=</span> <span class="m">8.</span><span class="n">dp</span><span class="p">),</span>
</span><span class='line'>            <span class="n">horizontalArrangement</span> <span class="p">=</span> <span class="n">Arrangement</span><span class="p">.</span><span class="n">SpaceEvenly</span><span class="p">,</span>
</span><span class='line'>            <span class="n">verticalAlignment</span> <span class="p">=</span> <span class="n">Alignment</span><span class="p">.</span><span class="n">CenterVertically</span>
</span><span class='line'>        <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">Button</span><span class="p">(</span><span class="n">onClick</span> <span class="p">=</span> <span class="p">{</span> <span class="n">count</span><span class="p">++</span> <span class="p">},</span> <span class="n">enabled</span> <span class="p">=</span> <span class="n">count</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">Text</span><span class="p">(</span><span class="s">&quot;Add one&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="n">Button</span><span class="p">(</span><span class="n">onClick</span> <span class="p">=</span> <span class="p">{</span> <span class="n">count</span> <span class="p">=</span> <span class="m">0</span> <span class="p">},</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="n">start</span> <span class="p">=</span> <span class="m">8.</span><span class="n">dp</span><span class="p">),</span> <span class="n">enabled</span> <span class="p">=</span> <span class="n">count</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">Text</span><span class="p">(</span><span class="s">&quot;Clear water count&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>但这样写文本中的数字不会变化。</p>

<p>重组要想发生，就必须重新调用Compose的『根函数』，这就需要用到专门的数据结构<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/MutableState">MutableState</a>，Compose会识别并跟踪这些State，当其变化时，会触发重组，并使用State中的最新值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">interface</span> <span class="n">MutableState</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">State</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">override</span> <span class="k">var</span> <span class="py">value</span><span class="p">:</span> <span class="n">T</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>管理UI状态</h2>

<p>要想让Compose识别到数据变化，就需要使用状态State，这样当数据变化时会触发重组，Compose会用State中的最新数值来重新运行函数，以刷新UI。比如上面的计数的例子，可以这样修改：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">WaterCounter</span><span class="p">(</span><span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">count</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="m">0</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="c1">// Other codes not changed</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这次，能得到期望的行为：</p>

<p><img src="https://pic2.zhimg.com/v2-d26bd68593ea22ef777f42f83aee37f5_b.webp" alt="state demo" /></p>

<p>有三种方式声明一个状态MutableState：</p>

<ul>
<li>val state = remember { mutableStateOf(default) }</li>
<li>var value by remember { mutableStateOf(default) }</li>
<li>val (vale, setValue) = remember { mutableStateOf(default) }</li>
</ul>


<p>基本上无差别，一般委托方式用的稍多一些。这里<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#remember(kotlin.Function0">remember</a>)的作用是让Compose记住并追踪状态的变化。如果想要让状态能够跨Activity的实例（比如遇到屏幕旋转，语言变化等配置变化导致Activity重启）就需要用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/saveable/package-summary#rememberSaveable(kotlin.Array,androidx.compose.runtime.saveable.Saver,kotlin.String,kotlin.Function0">remeberSaveable</a>)。</p>

<p>这些主要是针对Composable中内部的状态。对于像从ViewModel过来的业务数据，一般都用<a href="https://developer.android.com/reference/kotlin/androidx/lifecycle/compose/package-summary#(androidx.lifecycle.Lifecycle">collectAsState</a>.currentStateAsState())系列方法。</p>

<h2>有状态（Stateful）和无状态（Stateless）</h2>

<p>对于包含了创建State的函数就称作有状态的Composable，而不包含创建状态就是Stateless的。</p>

<p>无状态的Composable是幂等的，调用时直接传入数据，不会产生副作用，也不会触发重组，显然这对开发者来说是最高效的，因为很纯粹，使用起来相当简单，并且完全可复用，<strong>应该尽可能的创建并使用无状态Composables</strong>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">CustomButton</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">onClick</span><span class="p">:</span> <span class="p">()-&gt;</span><span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="n">Button</span><span class="p">(</span><span class="n">onClick</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>         <span class="n">Text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>状态提升</h2>

<p>因为State是有额外的成本的，因此应该尽可能的减少State的创建，那么就要尽可能的复用State。这就需要把状态提升到使用此State的所有子函数的最小公共函数里面。比如前面的例子，状态count在Text和两个Button中都有使用，那么count至少要提升到它们的公共函数里面。假如，这个count在其他Composable中也有使用，那么就提升到WaterCounter的更上一层，甚至是整个Screen级别。</p>

<p>一般情况下，除了一些仅在局部使用的状态外，放在页面级别的根函数里面是比较好的选择，这样的话只有页面的根函数是Stateful的，其余函数都是Stateless的。</p>

<h2>实战</h2>

<p>纸上来行终觉浅，要想掌握还是要亲手撸。状态管理对于UI框架是相当重要的，因为这是UI发挥作用和产生价值的地方。对于状态管理有一些非常好的CodeLab，可以亲手撸一下，感受一下状态管理到底是啥。</p>

<ul>
<li><a href="https://developer.android.com/codelabs/jetpack-compose-state#0">State in Jetpack Compose</a></li>
</ul>


<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/state">State and Jetpack Compose</a></li>
<li><a href="https://decode.agency/article/jetpack-compose-state/">How to handle state in Jetpack Compose</a></li>
<li><a href="https://www.composables.com/tutorials/state">Everything you need to know about State in Jetpack Compose with examples</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
