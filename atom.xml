<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[稀有猿诉]]></title>
  <link href="http://toughcoder.net/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2024-06-24T20:32:18+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『利涉大川』| Canvas]]></title>
    <link href="http://toughcoder.net/blog/2024/06/24/canvas-in-compose/"/>
    <updated>2024-06-24T20:22:49+08:00</updated>
    <id>http://toughcoder.net/blog/2024/06/24/canvas-in-compose</id>
    <content type="html"><![CDATA[<p>任何一个GUI框架都会提供大量的预定义的UI部件，让开发者构建UI页面，但有些时候预定义的部件无法满足需求，这时就需要定制，甚至是自定义绘制的内容。对于Android开发者来说，这已经是家常便饭了，因为肯定有过用自定义View来实现一些特殊设计需求的经验。在Jetpack Compose中也有同样的方法来实现自定义绘制内容，今天就来学习一下。</p>

<p><a href="http://toughcoder.net/blog/2024/06/24/canvas-in-compose/"><img src="https://apptractor.ru/wp-content/uploads/2021/03/1_r_ly2xx-jo8vixat0xh7qa.png" title="auto auto" ></a></p>

<!-- more -->


<h2>使用Canvas来自定义内容</h2>

<p>在Compose中， 我们用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/package-summary#Canvas(android.graphics.Canvas">Canvas函数</a>)来绘制自定义内容，可以把它理解成为自定义View，但，它是一个函数，把绘制指令传给它就可以了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">textMeasurer</span> <span class="p">=</span> <span class="n">rememberTextMeasurer</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="n">Canvas</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">drawRect</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">LightGray</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">drawText</span><span class="p">(</span>
</span><span class='line'>        <span class="n">textMeasurer</span> <span class="p">=</span> <span class="n">textMeasurer</span><span class="p">,</span>
</span><span class='line'>        <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;降Compose十八掌&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="n">topLeft</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">4f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">2.2f</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">drawCircle</span><span class="p">(</span>
</span><span class='line'>        <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Magenta</span><span class="p">,</span>
</span><span class='line'>        <span class="n">radius</span> <span class="p">=</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">10f</span><span class="p">,</span>
</span><span class='line'>        <span class="n">center</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">1.8f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">3f</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>    <span class="n">drawCircle</span><span class="p">(</span>
</span><span class='line'>        <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Yellow</span><span class="p">,</span>
</span><span class='line'>        <span class="n">radius</span> <span class="p">=</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">12f</span><span class="p">,</span>
</span><span class='line'>        <span class="n">center</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">1.6f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">4.5f</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>    <span class="n">drawCircle</span><span class="p">(</span>
</span><span class='line'>        <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Green</span><span class="p">,</span>
</span><span class='line'>        <span class="n">radius</span> <span class="p">=</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">14f</span><span class="p">,</span>
</span><span class='line'>        <span class="n">center</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">1.46f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">7f</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7c77abcb2b34e0683201294f4926082~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1220&amp;h=1436&amp;s=75585&amp;e=png&amp;b=cccccc" alt="hello_canvas" /></p>

<h2>坐标系统</h2>

<p>坐标系统，与常见的GUI坐标系统，以及View的坐标系统都是一样的，左上角是原点（0，0），x轴向右，y轴向下。</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/graphics/introduction/compose_coordinate_system_drawing.png" alt="" /></p>

<h2>绘图上下文DrawScope</h2>

<p>仔细看Canvas函数，可以发现，写绘制指令的地方是一个尾部lambda，这是Compose中非常常见的一种设计方式。这个lambda被定义为DrawScope对象的一个扩展函数，所以在这个lambda中可以隐式的访问DrawScope对象。我们所使用的绘制指令，以及很多参数其实都是在通过this指针隐式的调用DrawScope。对于扩展函数不熟悉的同学可以去复习一下<a href="https://juejin.cn/post/7327478228188594202">Kotlin中函数的一些高级用法</a>。</p>

<p>通过AndroidStudio的提示，也能看到隐式的this指针是一个DrawScope对象。</p>

<p>所以呢，当查找API文档时记得要去找<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/drawscope/DrawScope">DrawScope</a>，而不是Canvas函数。其实Canvas就是一个封装的函数，也没啥东西。但还有一个略微底层一些的作为Graphics接口的<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/Canvas">对象Canvas</a>，它与Android SDK中的Canvas对象是差不多的概念。</p>

<p>接下来我们重点看看如何使用绘制指令绘制出我们需要的内容。</p>

<h2>画图形</h2>

<p>图形（Shape）是最为常见的一类绘制目标，比如圆，椭圆，矩形，线，扇形等等。不难，看一眼就会用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">Canvas</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">drawRect</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">LightGray</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">drawOval</span><span class="p">(</span>
</span><span class='line'>        <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Green</span><span class="p">,</span>
</span><span class='line'>        <span class="n">topLeft</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="m">50f</span><span class="p">,</span> <span class="m">50f</span><span class="p">),</span>
</span><span class='line'>        <span class="n">size</span><span class="p">=</span>  <span class="n">Size</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">10f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">12f</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">drawLine</span><span class="p">(</span>
</span><span class='line'>        <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Yellow</span><span class="p">,</span>
</span><span class='line'>        <span class="n">start</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="m">50</span> <span class="p">+</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">20f</span><span class="p">,</span> <span class="m">50f</span> <span class="p">+</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">24f</span><span class="p">),</span>
</span><span class='line'>        <span class="n">end</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">1.8f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">3f</span><span class="p">),</span>
</span><span class='line'>        <span class="n">strokeWidth</span> <span class="p">=</span> <span class="n">Stroke</span><span class="p">.</span><span class="n">DefaultMiter</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">drawCircle</span><span class="p">(</span>
</span><span class='line'>        <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Magenta</span><span class="p">,</span>
</span><span class='line'>        <span class="n">radius</span> <span class="p">=</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">5f</span><span class="p">,</span>
</span><span class='line'>        <span class="n">center</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">1.8f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">3f</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">drawPoints</span><span class="p">(</span>
</span><span class='line'>        <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">DarkGray</span><span class="p">,</span>
</span><span class='line'>        <span class="n">pointMode</span> <span class="p">=</span> <span class="n">PointMode</span><span class="p">.</span><span class="n">Points</span><span class="p">,</span>
</span><span class='line'>        <span class="n">strokeWidth</span> <span class="p">=</span> <span class="m">50f</span><span class="p">,</span>
</span><span class='line'>        <span class="n">points</span> <span class="p">=</span> <span class="n">genPoints</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">2f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">3f</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6b042b2c41f4899aeb3245baa99f591~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1219&amp;h=1447&amp;s=77422&amp;e=png&amp;b=cccccc" alt="shapes" /></p>

<h2>画路径</h2>

<p>路径（Path）是把一系列的数学指令转化为绘制命令，可以更为灵活的画一些曲线和图形，比如说画一个三角函数曲线：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">PathDemo</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">tm</span> <span class="p">=</span> <span class="n">rememberTextMeasurer</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Canvas</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">drawRect</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">LightGray</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">drawText</span><span class="p">(</span><span class="n">tm</span><span class="p">,</span> <span class="s">&quot;cosine of [-PI, PI]&quot;</span><span class="p">,</span> <span class="n">Offset</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">3f</span><span class="p">,</span> <span class="m">60f</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">drawLine</span><span class="p">(</span>
</span><span class='line'>            <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">DarkGray</span><span class="p">,</span>
</span><span class='line'>            <span class="n">start</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">2f</span><span class="p">),</span>
</span><span class='line'>            <span class="n">end</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">2f</span><span class="p">),</span>
</span><span class='line'>            <span class="n">strokeWidth</span> <span class="p">=</span> <span class="m">3f</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">drawLine</span><span class="p">(</span>
</span><span class='line'>            <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">DarkGray</span><span class="p">,</span>
</span><span class='line'>            <span class="n">start</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">2f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">3f</span><span class="p">),</span>
</span><span class='line'>            <span class="n">end</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">2f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">*</span> <span class="m">2</span><span class="p">/</span> <span class="m">3f</span><span class="p">),</span>
</span><span class='line'>            <span class="n">strokeWidth</span> <span class="p">=</span> <span class="m">3f</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">drawPath</span><span class="p">(</span><span class="n">genPath</span><span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">),</span> <span class="n">Color</span><span class="p">.</span><span class="n">Magenta</span><span class="p">,</span> <span class="n">style</span> <span class="p">=</span> <span class="n">Stroke</span><span class="p">(</span><span class="n">width</span> <span class="p">=</span> <span class="m">10f</span><span class="p">))</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="nf">genPath</span><span class="p">(</span><span class="n">width</span><span class="p">:</span> <span class="n">Float</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="n">Float</span><span class="p">):</span> <span class="n">Path</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">slices</span> <span class="p">=</span> <span class="m">60</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">path</span> <span class="p">=</span> <span class="n">Path</span><span class="p">();</span>
</span><span class='line'>    <span class="n">path</span><span class="p">.</span><span class="n">moveTo</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="n">height</span> <span class="p">/</span> <span class="m">3f</span><span class="p">)</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">1.</span><span class="p">.</span><span class="n">slices</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">x0</span> <span class="p">=</span> <span class="m">2f</span> <span class="p">*</span> <span class="n">i</span><span class="p">.</span><span class="n">toFloat</span><span class="p">()</span> <span class="p">*</span> <span class="n">PI</span><span class="p">.</span><span class="n">toFloat</span><span class="p">()</span> <span class="p">/</span>  <span class="n">slices</span><span class="p">.</span><span class="n">toFloat</span><span class="p">()</span> <span class="p">-</span> <span class="n">PI</span><span class="p">.</span><span class="n">toFloat</span><span class="p">()</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">y0</span> <span class="p">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span> <span class="p">*</span> <span class="n">height</span> <span class="p">/</span> <span class="m">6f</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">x</span> <span class="p">=</span> <span class="n">i</span><span class="p">.</span><span class="n">toFloat</span><span class="p">()</span> <span class="p">/</span> <span class="n">slices</span><span class="p">.</span><span class="n">toFloat</span><span class="p">()</span> <span class="p">*</span> <span class="n">width</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">y</span> <span class="p">=</span> <span class="n">y0</span> <span class="p">+</span> <span class="n">height</span> <span class="p">/</span> <span class="m">2f</span>
</span><span class='line'>        <span class="n">path</span><span class="p">.</span><span class="n">lineTo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</span><span class='line'>        <span class="n">path</span><span class="p">.</span><span class="n">moveTo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">path</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">path</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd5a91eab8a34a8fae51874ec21d989d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1217&amp;h=1994&amp;s=104973&amp;e=png&amp;b=cccccc" alt="path" />
路径在绘制中是非常强大的功能，可以实现非常炫酷的动画效果。</p>

<h2>画文字</h2>

<p>文字是特别重要的UI元素，通常情况下我们都是过Text来展示文字，再与其他部件进行组合就能满足需求。一般来说不需要在自定义内容也使用文字，因为文字绘制一般来说比较复杂，因为像基线对齐，字体样式，字体大小等等，都需要考虑。文字部件Text内容其实也是用与自定义一样的更低层的API来实现的，但它把像对齐，样式，富文本等等都封装好了。</p>

<p>DrawScope也提供了绘制文字的函数，不过呢使用起来比较麻烦，需要详细计算文字所占用的区域大小，而文字的measure通常是非常麻烦的，因为像文字的字体以及文字大小都会影响到measure，因此measure要保存成为一个状态，这样当有影响到文字绘制的因素发生变化时，measure就会发生变化，进而触发Re-Composition：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">TextDemo</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">textMeasure</span> <span class="p">=</span> <span class="n">rememberTextMeasurer</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Canvas</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">measuredText</span> <span class="p">=</span>
</span><span class='line'>            <span class="n">textMeasure</span><span class="p">.</span><span class="n">measure</span><span class="p">(</span>
</span><span class='line'>                <span class="n">AnnotatedString</span><span class="p">(</span>
</span><span class='line'>                    <span class="n">text</span> <span class="p">=</span>
</span><span class='line'>                    <span class="s">&quot;&quot;&quot;</span>
</span><span class='line'>                        <span class="err">“降龙十八掌可说是【武学中的巅峰绝诣】，当真是无坚不摧、无固不破。虽招数有限，但每一招均具绝大威力。</span>
</span><span class='line'>                        <span class="err">北宋年间，丐帮帮主萧峰以此邀斗天下英雄，极少有人能挡得他三招两式，气盖当世，群豪束手。</span>
</span><span class='line'>                        <span class="err">当时共有“降龙廿八掌”，后经萧峰及他义弟虚竹子删繁就简，取精用宏，改为降龙十八掌，掌力更厚。</span>
</span><span class='line'>                        <span class="err">这掌法传到洪七公手上，在华山绝顶与王重阳、黄药师等人论剑时施展出来，王重阳等尽皆称道。”</span>
</span><span class='line'>                    <span class="s">&quot;&quot;&quot;.trimIndent(),</span>
</span><span class='line'>                    <span class="n">spanStyle</span> <span class="p">=</span> <span class="n">SpanStyle</span><span class="p">(</span>
</span><span class='line'>                        <span class="n">fontSize</span> <span class="p">=</span> <span class="m">20.</span><span class="n">sp</span><span class="p">,</span>
</span><span class='line'>                        <span class="n">fontWeight</span> <span class="p">=</span> <span class="n">FontWeight</span><span class="p">.</span><span class="n">ExtraBold</span><span class="p">,</span>
</span><span class='line'>                        <span class="n">brush</span> <span class="p">=</span> <span class="n">Brush</span><span class="p">.</span><span class="n">verticalGradient</span><span class="p">(</span><span class="n">listOf</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Magenta</span><span class="p">,</span> <span class="n">Color</span><span class="p">.</span><span class="n">Cyan</span><span class="p">,</span> <span class="n">Color</span><span class="p">.</span><span class="n">Blue</span><span class="p">))</span>
</span><span class='line'>                    <span class="p">)</span>
</span><span class='line'>                <span class="p">),</span>
</span><span class='line'>                <span class="n">constraints</span> <span class="p">=</span> <span class="n">Constraints</span><span class="p">.</span><span class="n">fixed</span><span class="p">(</span>
</span><span class='line'>                    <span class="n">width</span> <span class="p">=</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">1.6f</span><span class="p">).</span><span class="n">toInt</span><span class="p">(),</span>
</span><span class='line'>                    <span class="n">height</span> <span class="p">=</span> <span class="p">(</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">2f</span><span class="p">).</span><span class="n">toInt</span><span class="p">()</span>
</span><span class='line'>                <span class="p">),</span>
</span><span class='line'>                <span class="n">overflow</span> <span class="p">=</span> <span class="n">TextOverflow</span><span class="p">.</span><span class="n">Ellipsis</span><span class="p">,</span>
</span><span class='line'>                <span class="n">style</span> <span class="p">=</span> <span class="n">TextStyle</span><span class="p">(</span><span class="n">fontSize</span> <span class="p">=</span> <span class="m">18.</span><span class="n">sp</span><span class="p">)</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">drawText</span><span class="p">(</span>
</span><span class='line'>            <span class="n">textLayoutResult</span> <span class="p">=</span> <span class="n">measuredText</span><span class="p">,</span>
</span><span class='line'>            <span class="n">topLeft</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="m">60f</span><span class="p">,</span> <span class="m">60f</span><span class="p">)</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2aaf95cc9fff45dc9c963065098b0faa~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1220&amp;h=1774&amp;s=275925&amp;e=png&amp;b=fefbff" alt="text" /></p>

<h2>画图片</h2>

<p>图片（Image）是与文字类似的非常重要的UI元素，像图标，头像，表情，背景图，Banner图，以及内容中的图像都属于图片元素，一般情况下用Image函数可以用来展示图片。</p>

<p>对于自定义绘制内容也可以使用图片，DrawScope中有提供绘制图片的方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">dogImage</span> <span class="p">=</span> <span class="n">ImageBitmap</span><span class="p">.</span><span class="n">imageResource</span><span class="p">(</span><span class="n">id</span> <span class="p">=</span> <span class="n">R</span><span class="p">.</span><span class="n">drawable</span><span class="p">.</span><span class="n">dog</span><span class="p">)</span>
</span><span class='line'><span class="n">Canvas</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">(),</span> <span class="n">onDraw</span> <span class="p">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">drawImage</span><span class="p">(</span><span class="n">dogImage</span><span class="p">)</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_image.png" alt="" /></p>

<h2>变幻</h2>

<p>除了绘制以外，DrawScope还提供了一系列做变幻的函数。包括缩放，位移，旋转这些变幻直接作用于绘制指令上面。</p>

<h3>缩放</h3>

<p>使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/drawscope/DrawScope#(androidx.compose.ui.graphics.drawscope.DrawScope">DrawScope.scale</a>.scale(kotlin.Float,kotlin.Float,androidx.compose.ui.geometry.Offset,kotlin.Function1))函数来对绘制指令进行缩放，参数是x轴方向和y轴方向的缩放倍数（大于1放大，小于1缩小），还可以指定中心坐标，默认是几何中心。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">Canvas</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">scale</span><span class="p">(</span><span class="n">scaleX</span> <span class="p">=</span> <span class="m">10f</span><span class="p">,</span> <span class="n">scaleY</span> <span class="p">=</span> <span class="m">15f</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">drawCircle</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Blue</span><span class="p">,</span> <span class="n">radius</span> <span class="p">=</span> <span class="m">20.</span><span class="n">dp</span><span class="p">.</span><span class="n">toPx</span><span class="p">())</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_scale.png" alt="" /></p>

<h3>位移</h3>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/drawscope/DrawScope#(androidx.compose.ui.graphics.drawscope.DrawScope">DrawScope.translate</a>.translate(kotlin.Float,kotlin.Float,kotlin.Function1))可以实现位移，参数是x方向或者y方向的距离。参数为正，是沿着坐标轴正向，为负就是反向。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">Canvas</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">translate</span><span class="p">(</span><span class="n">left</span> <span class="p">=</span> <span class="m">100f</span><span class="p">,</span> <span class="n">top</span> <span class="p">=</span> <span class="p">-</span><span class="m">300f</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">drawCircle</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Blue</span><span class="p">,</span> <span class="n">radius</span> <span class="p">=</span> <span class="m">200.</span><span class="n">dp</span><span class="p">.</span><span class="n">toPx</span><span class="p">())</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_translate.png" alt="" /></p>

<h3>旋转</h3>

<p>用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/drawscope/DrawScope#(androidx.compose.ui.graphics.drawscope.DrawScope">DrawScope.rotate</a>.rotate(kotlin.Float,androidx.compose.ui.geometry.Offset,kotlin.Function1))函数实现旋转，参数为正时是顺时针的角度，为负就是逆时针，可以指定中心点，默认是几何中心。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">Canvas</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">rotate</span><span class="p">(</span><span class="n">degrees</span> <span class="p">=</span> <span class="m">45F</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">drawRect</span><span class="p">(</span>
</span><span class='line'>            <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Gray</span><span class="p">,</span>
</span><span class='line'>            <span class="n">topLeft</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">x</span> <span class="p">=</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">3F</span><span class="p">,</span> <span class="n">y</span> <span class="p">=</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">3F</span><span class="p">),</span>
</span><span class='line'>            <span class="n">size</span> <span class="p">=</span> <span class="n">size</span> <span class="p">/</span> <span class="m">3F</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_rotate.png" alt="" /></p>

<h3>画布尺寸调整</h3>

<p>用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/drawscope/package-summary#(androidx.compose.ui.graphics.drawscope.DrawScope">DrawScope.inset</a>.inset(kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Function1))函数来对DrawScope的画布进行调整，参数是周围四个方向的边距偏移量。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">Canvas</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">canvasQuadrantSize</span> <span class="p">=</span> <span class="n">size</span> <span class="p">/</span> <span class="m">2F</span>
</span><span class='line'>    <span class="n">inset</span><span class="p">(</span><span class="n">horizontal</span> <span class="p">=</span> <span class="m">50f</span><span class="p">,</span> <span class="n">vertical</span> <span class="p">=</span> <span class="m">30f</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">drawRect</span><span class="p">(</span><span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Green</span><span class="p">,</span> <span class="n">size</span> <span class="p">=</span> <span class="n">canvasQuadrantSize</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样调整后，inset内部的lambda中的绘制指令的尺寸size会受影响，size.width = width - 2 * horizontal，size.height = height - 2 * vertical，相当于是加了padding。</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_inset.png" alt="" /></p>

<h3>组合变幻</h3>

<p>变幻除了可以单独使用，还可以组合起来使用，能更简便的实现变幻效果。使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/drawscope/package-summary#(androidx.compose.ui.graphics.drawscope.DrawScope">DrawScope.withTransform</a>.withTransform(kotlin.Function1,kotlin.Function1))来组合变幻：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">Canvas</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">withTransform</span><span class="p">({</span>
</span><span class='line'>        <span class="n">translate</span><span class="p">(</span><span class="n">left</span> <span class="p">=</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">5F</span><span class="p">)</span>
</span><span class='line'>        <span class="n">rotate</span><span class="p">(</span><span class="n">degrees</span> <span class="p">=</span> <span class="m">45F</span><span class="p">)</span>
</span><span class='line'>    <span class="p">})</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">drawRect</span><span class="p">(</span>
</span><span class='line'>            <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Gray</span><span class="p">,</span>
</span><span class='line'>            <span class="n">topLeft</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">x</span> <span class="p">=</span> <span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">3F</span><span class="p">,</span> <span class="n">y</span> <span class="p">=</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">3F</span><span class="p">),</span>
</span><span class='line'>            <span class="n">size</span> <span class="p">=</span> <span class="n">size</span> <span class="p">/</span> <span class="m">3F</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/graphics/introduction/compose_graphics_multiple_transforms.png" alt="" /></p>

<h2>总结</h2>

<p>今天主要学习了如何通过Canvas函数来实现自定义绘制内容，Canvas给我们了封装了一个包含有DrawScope的lambda，通过DrawScope提供的各种绘制指令可以实现我们的想要的自定义内容。可以自由的通过绘制图形，文字和图像，并且可以做变幻，以实现一些特效。相信通过今天的学习，足可以应付常见的自定义绘制需求。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/graphics/draw/overview">Graphics in Compose</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『潜龙勿用』| Thinking in Compose]]></title>
    <link href="http://toughcoder.net/blog/2024/06/15/thinking-in-compose/"/>
    <updated>2024-06-15T20:12:15+08:00</updated>
    <id>http://toughcoder.net/blog/2024/06/15/thinking-in-compose</id>
    <content type="html"><![CDATA[<p>Jetpack Compose是Android平台的现代化的声明式UI框架。它提供了一套声明式API，可以不必再机械式的操作View就能构建 出UI，从而更容易的构建出应用的UI，并且易于维护，易于扩展。今天我们重点理解一下Jetpack Compose背后的思想，学会以声明式思维来思考，进而写出更加专业的声明式UI代码。</p>

<p><a href="http://toughcoder.net/blog/2024/06/15/thinking-in-compose/"><img src="https://anahisalgado.com/wp-content/uploads/2022/05/jetpack-compose-anncode-anahi-salgado.png" title="auto auto" ></a></p>

<!-- more -->


<h2>从过程式UI到声明式UI</h2>

<p>通过前面的学习，我们已经知道声明式UI的特点了，它是一坨一坨的函数。状态（要显示给用户的数据）作为参数，再写出使用这些状态的函数，然后Compose会运行这些函数最终生成UI。不必关心函数具体的执行，以及执行的结果，我们只需要描述好需要显示什么就可以了，简言之就是定义好如何使用数据的函数即可。这就是声明式UI的核心思想，它让开发者把精力放在你想要展示什么，而非繁杂的如何展示。</p>

<p><img src="https://s3-eu-west-2.amazonaws.com/wolfpack-digital-attachments-production/ckeditor_assets/pictures/374/content_Building_apps_with_declarative_UI_5.png" alt="" /></p>

<p>实际上这是函数式编程范式的一种，时刻记着我们都是在定义函数就可以了。</p>

<h2>Compose的工作原理</h2>

<p>传统的过程式UI（比如Android中的View和XML）是基于OO（面向对象）的，每个元素都是一个对象，它有一些属性，要构建出一颗View tree，然后当有事件变化或者有数据更新时，我们会具体的刷新具体的View。但像声明式UI，比如Compose，工作方式并不是这样的，开发者写出的并不是View tree，而是一系列描述着要展示数据的函数，其余的事情都是Comose负责。</p>

<p>Compose会执行这些函数，收集它们的结果，生成一颗<a href="https://www.geeksforgeeks.org/difference-between-virtual-dom-and-real-dom/">虚拟的View tree</a>，这一步要叫做Compositon；然后再把虚拟的View tree，生成真实的与平台相关的View tree，这一步叫做渲染。当有状态变化的时候，代表数据有更新，需要刷新UI，这时Compose会重新执行一遍函数，这就叫做重组Recomposition。因为重组会发生很多次，如果每次重组都直接去更新目标平台View tree开销太大了，因此就有了虚拟View tree这一层，每次重新会重新生成一颗虚拟View tree，然后比较两颗虚拟View tree，只当差异时，再用差异去更新目标平台的View tree。</p>

<p>有同学举手了，说这费二遍事，性能肯定会变得更差吧？这位同学先坐下。确实多费了一道工序，但随着CPU性能越来越高，以及像<a href="https://www.infoq.cn/article/react-dom-diff">virtual dom diff技术</a>的应用，Compose本身性能的差异已经追上传统方式了。但它的优势，比如开发效率以及可扩展性却无限放大，总的来说收益还是很大的。</p>

<p>说到底这是函数式编程方式，那么就会有函数式编程的特点，比如说这些函数的执行顺序不一定就是开发者写的那样，再比如说这些函数可能会并行的执行，甚至有些函数会被跳过。并且呢，重组可能随时发生，而且发生的很频繁。Compose这样做是为了保证底层UI能够及时得到刷新。</p>

<p>那么，在使用Compose时，就有一些注意事项，比如尽可能的使用Stateless的函数，尽可能的减少副作用。以及千万不要依赖函数的执行顺序。</p>

<h2>拆分为细粒度的函数，加强复用</h2>

<p>Compose是以函数来搭建UI，这相比于xml方式的一个最大的好处就是这非常方便的复用，因为可以像重构代码那样，把重复的代码抽成可复用函数。要以「自上而下」函数调用的方式来构建UI。</p>

<p>推荐的方式是，先把整个页面划分为不同的区域，每个区域是一个函数（Composable）；再把每个区域细分成为更为细节的函数；这些细节函数如果是共性的就复用。这样做的方式，不但能够做到代码结构清晰，可读性很强，且易于维护，方便扩展。非常容易找到与UI的对应，而且容易复用，如果有新的页面，把不同的细节函数组合起来就可以了。</p>

<p>其实以前用XML也应该这样，但毕竟XML不像代码这样方便的管理和复用，拆成过多的XML文件不但难以管理，也会影响编译速度。</p>

<p>可以做一下<a href="https://developer.android.com/codelabs/jetpack-compose-layouts#0">Basic layouts in Compose</a>，这个CodeLab非常好的演示了如何「自顶而下」的用Compose来构建UI。</p>

<h2>Preview局部而非整体</h2>

<p>Compose的一个强大功能就是即时Preview，不必非要到设备上运行就可以看到UI效果。不过呢Preview需要数据，而且要是静态的数据，也就是需要Mock。这对于复杂的数据来说是致命的缺点。比如说像字段非常之多的列表，或者有很多特殊字段的对象，Mock起来相当的麻烦。</p>

<p>一个可行的办法就是要尽可能的Preview局部，数据复杂，必然对应着复杂的页面，把复杂的页面拆开，变成一系列的简单的Composable的组合，这时每个Composable对应的数据都是相对简单的，只有几个参数，这时就是可Preview的了，Mock起来就容易得多了。</p>

<p>具体的来说，对于像集合性UI，我们只需要预览它的一个单元项就可以了，只要一个单元项没啥问题，组合起来看集合地无非就是重复很多个；再比如对于复杂的多字段对象，划分成为几个不同的子区域，每个子区域对应一个函数，这个函数经过Preview后没啥问题，那把这些组合起来成为一个整体后也不会有太大的问题。</p>

<p>Preview的作用是快速预览，减少编译运行的次数，毕竟编译运行一次要慢得多，所以要以简单快捷方便为主。而并不是真的当成运行结果，最终肯定要以在手机上运行结果为准，并进行最终的调试。</p>

<h2>总结</h2>

<p>对于习惯了View和XML方式的同学来说，开始用Compose肯定会略有不习惯，就需要理解一下它的原理，转变成声明式UI的思维，以函数为核心来思考问题，这样才能写出比较专业的Compose代码。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/mental-model">Thinking in Compose</a></li>
<li><a href="https://proandroiddev.com/why-we-adopted-jetpack-compose-b66bfd3dbde5">Why We Adopted Jetpack Compose</a></li>
<li><a href="https://medium.com/israeli-tech-radar/declarative-ui-what-how-and-why-13e092a7516f">Declarative UI — What, How, and Why?</a></li>
<li><a href="https://www.rootstrap.com/blog/imperative-v-declarative-ui-design-is-declarative-programming-the-future">Imperative v Declarative UI Design - Is Declarative Programming the future?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Principle of Inclusion Exclusion Made Easy]]></title>
    <link href="http://toughcoder.net/blog/2024/06/13/inclusion-exclusion-principle/"/>
    <updated>2024-06-13T20:45:29+08:00</updated>
    <id>http://toughcoder.net/blog/2024/06/13/inclusion-exclusion-principle</id>
    <content type="html"><![CDATA[<p><a href="https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/">容斥原理</a>，是指在计数的时候，先不考虑重复问题，先把包含某种对象的统计出来，再把重复的排除掉。</p>

<p><a href="http://toughcoder.net/blog/2024/06/13/inclusion-exclusion-principle/"><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.oW-5-IkJnUeOjVM7ZBtMAwAAAA?rs=1&pid=ImgDetMain" title="auto auto" ></a></p>

<!-- more -->


<p>比如说，考试，15人数学满分，12人语文满分，并且有4人语文和数学都满分，求至少有一个人满分的同学有多少个？</p>

<p>答案是15 + 12 - 4。</p>

<p>理解起来就是，重复的部分被多加了一次，最后再减去重复的人即可。</p>

<p>再如小于某个数x中，能被3或者5整除的数有多少？答案是 x/3 + x / 5 - x /3x5。同样是重复的计算了两次，减去一次即可。</p>

<p>容斥原理，不复杂，也不能单独用来求解问题，一般都是用于统计计数。</p>

<h3>相关问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/nth-magical-number/description/">878. 第 N 个神奇数字</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/nth-magical-number/solutions/2808476/xi-you-yuan-su-878-di-n-ge-shen-qi-shu-z-udgp/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/ugly-number-iii/description/">1201. 丑数 III</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/ugly-number-iii/solutions/2808790/xi-you-yuan-su-1201-chou-shu-iiishu-xue-wha7w/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>References</h2>

<ul>
<li><a href="https://brilliant.org/wiki/principle-of-inclusion-and-exclusion-pie/">Principle of Inclusion and Exclusion (PIE)</a></li>
<li><a href="https://mathworld.wolfram.com/Inclusion-ExclusionPrinciple.html">Inclusion-Exclusion Principle</a></li>
<li><a href="https://www.geeksforgeeks.org/inclusion-exclusion-various-applications/">Inclusion-Exclusion and its various Applications</a></li>
<li><a href="https://www.cut-the-knot.org/arithmetic/combinatorics/InclusionExclusion.shtml">The Inclusion-Exclusion Principle</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tree in Graph]]></title>
    <link href="http://toughcoder.net/blog/2024/06/06/tree-in-graph/"/>
    <updated>2024-06-06T22:02:26+08:00</updated>
    <id>http://toughcoder.net/blog/2024/06/06/tree-in-graph</id>
    <content type="html"><![CDATA[<p>树是图的一种特殊形式，图中的树也是比较难的一类问题。</p>

<p><a href="http://toughcoder.net/blog/2024/06/06/tree-in-graph/"><img src="https://vivadifferences.com/wp-content/uploads/2019/11/Tree-In-Programming.png" title="auto auto" ></a></p>

<!-- more -->


<h2>树形图</h2>

<p>有一类特殊的图，本质上是树，但是以图的形式给出，通常涉及不同子树的特征值计算。这种图本质上是树，无环。通常顶点是n个，边的个数是n-1个，无环，每个顶点都可以成为树的根，边有权重。通常是求解与顶点连通的子树的特征值。</p>

<p>通常需要用到乘法原理。</p>

<p>第一步，把问题分解为根和子树的问题，需要以每个顶点为根，子树就是与其相邻的顶点为根的子树，这种根+子树的组合就是一个子问题；</p>

<p>第二步，乘法原理。每个「子树」会得到一个数量，子问题的结果就用到乘法原理来求得：</p>

<p><img src="https://pic.leetcode.cn/1709427910-nOCIAc-b125C.png" alt="" /></p>

<p>第三步，对于每个子树，用其他方法得到需要的「数量」值。这个不同的问题不一样。但本质上，要么是连通分量问题（可用并查集），要么是路径问题。因为这是在一个子树上面的问题，相当于树的问题，通常DFS可求得结果。</p>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/count-valid-paths-in-a-tree/description/">2867. 统计树中的合法路径数目</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/count-valid-paths-in-a-tree/solutions/2777173/xi-you-yuan-su-zhi-shu-ai-shai-fa-bing-c-2rdn/">题解</a> </td>
<td style="text-align:left;"> 并查集 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/count-pairs-of-connectable-servers-in-a-weighted-tree-network/description/">3067. 在带权树网络中统计可连接服务器对数目</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/count-pairs-of-connectable-servers-in-a-weighted-tree-network/solutions/2802677/xi-you-yuan-su-3067-zai-dai-quan-shu-wan-7ioe/">题解</a> </td>
<td style="text-align:left;"> DFS </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/description/">1466. 重新规划路线</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/solutions/2301538/xi-you-yuan-su-1466-zhong-xin-gui-hua-lu-juiu/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『鸿渐于陆』| State]]></title>
    <link href="http://toughcoder.net/blog/2024/06/04/jetpack-compose-state/"/>
    <updated>2024-06-04T21:05:02+08:00</updated>
    <id>http://toughcoder.net/blog/2024/06/04/jetpack-compose-state</id>
    <content type="html"><![CDATA[<p>Jetpack Compose是一种声明式的UI框架，用以构建GUI应用程序。通过前面的文章我们学会了<a href="https://juejin.cn/post/7371239685702844454">如何使用元素来填充页面</a>，也学会了<a href="https://juejin.cn/post/7373867360020480038">如何装饰元素</a>，但这还不够。UI还必须处理与页面直接相关的数据，因为这是对用户有价值的东西。今天就来学习一下Compose如何处理数据。</p>

<p><a href="http://toughcoder.net/blog/2024/06/04/jetpack-compose-state/"><img src="https://alexzh.com/content/images/size/w2000/2021/02/logo-1.65-1980-4.png" title="auto auto" ></a></p>

<!-- more -->


<h2>什么是状态</h2>

<p>状态（State）其实就是数据，Compose是一种UI框架，UI要显示数据才会有价值。但是呢，Compose毕竟是一种UI框架，它应该只处理需要展示给用户的那部分数据，所以，这里说的数据应该是经过业务逻辑处理过的，需要展示给用户的那部分数据。也就是说只需要处理从ViewModel推送过来的数据即可。</p>

<p>此外，还有一部分只需要在UI内部处理的数据，比如像一些控件的状态，动画中的参数变化等等，这些数据需要完全在UI部分处理掉，都不应该暴露给ViewModel。</p>

<p>因此，对于Compose来说的状态（State），就包括两部分，一部分是从ViewModel推过来的需要展示的数据（具体叫做UiState），以及UI内部逻辑中的状态。</p>

<h2>状态与重组</h2>

<p>本质上来说Compose就是坨函数，更新UI的方式就变成了用新的参数来重新调用这些函数。这些参数便是状态了。任何时候状态发生变化就会发生重组（re-Composition），结果就是UI刷新了，最新的数据呈现给了用户。感知状态变化如何影响着UI的刷新就是状态管理。</p>

<p>有些术语需要说明一下：组合（Composition）描述着UI的生成过程，也即当Compose执行我们所声明的一坨坨函数的时候；初始组合（Initial Composition）首次执行这一坨函数的过程；重组（re-Composition）当状态有更新，重新运行某些函数的过程。</p>

<p>UI要想刷新，呈现最新的数据，这就需要Compose进行重组，而重组是由状态更新触发的，也就是说我们需要用新的数据来重新执行这一坨函数。对于业务逻辑数据，这很好办，可以通过ViewModel推送新的数据，然后重新调用UI函数即可。但这并没有看起来那么容易，因为ViewModel与UI的关系通常不是ViewModel直接持有着UI的对象或者函数，更多的时候是Compose的函数（Composable）中创建持有ViewModel对象，一个函数是没有办法直接调用自身的，这会陷入死循环的（StackOverFlow）。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">WellnessScreen</span><span class="p">(</span>
</span><span class='line'>    <span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">,</span>
</span><span class='line'>    <span class="n">wellnessViewModel</span><span class="p">:</span> <span class="n">WellnessViewModel</span> <span class="p">=</span> <span class="n">viewModel</span><span class="p">()</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Column</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">modifier</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">WellnessTasksList</span><span class="p">(</span>
</span><span class='line'>            <span class="n">list</span> <span class="p">=</span> <span class="n">wellnessViewModel</span><span class="p">.</span><span class="n">tasks</span><span class="p">,</span>
</span><span class='line'>            <span class="n">onCheckedTask</span> <span class="p">=</span> <span class="p">{</span> <span class="p">},</span>
</span><span class='line'>            <span class="n">onCloseTask</span> <span class="p">=</span> <span class="p">{</span> <span class="p">}</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于UI逻辑中的数据也是如此，比如说，一个很简单的按扭计数，按照常规的理解，似乎可以这样写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">WaterCounter</span><span class="p">(</span><span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">count</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Column</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">16.</span><span class="n">dp</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>            <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;You have had $count glasses.&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="n">modifier</span> <span class="p">=</span> <span class="n">modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">16.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>        <span class="n">Row</span><span class="p">(</span>
</span><span class='line'>            <span class="n">modifier</span> <span class="p">=</span> <span class="n">modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="n">top</span> <span class="p">=</span> <span class="m">8.</span><span class="n">dp</span><span class="p">),</span>
</span><span class='line'>            <span class="n">horizontalArrangement</span> <span class="p">=</span> <span class="n">Arrangement</span><span class="p">.</span><span class="n">SpaceEvenly</span><span class="p">,</span>
</span><span class='line'>            <span class="n">verticalAlignment</span> <span class="p">=</span> <span class="n">Alignment</span><span class="p">.</span><span class="n">CenterVertically</span>
</span><span class='line'>        <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">Button</span><span class="p">(</span><span class="n">onClick</span> <span class="p">=</span> <span class="p">{</span> <span class="n">count</span><span class="p">++</span> <span class="p">},</span> <span class="n">enabled</span> <span class="p">=</span> <span class="n">count</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">Text</span><span class="p">(</span><span class="s">&quot;Add one&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="n">Button</span><span class="p">(</span><span class="n">onClick</span> <span class="p">=</span> <span class="p">{</span> <span class="n">count</span> <span class="p">=</span> <span class="m">0</span> <span class="p">},</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="n">start</span> <span class="p">=</span> <span class="m">8.</span><span class="n">dp</span><span class="p">),</span> <span class="n">enabled</span> <span class="p">=</span> <span class="n">count</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">Text</span><span class="p">(</span><span class="s">&quot;Clear water count&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>但这样写文本中的数字不会变化。</p>

<p>重组要想发生，就必须重新调用Compose的『根函数』，这就需要用到专门的数据结构<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/MutableState">MutableState</a>，Compose会识别并跟踪这些State，当其变化时，会触发重组，并使用State中的最新值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">interface</span> <span class="n">MutableState</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">State</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">override</span> <span class="k">var</span> <span class="py">value</span><span class="p">:</span> <span class="n">T</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>管理UI状态</h2>

<p>要想让Compose识别到数据变化，就需要使用状态State，这样当数据变化时会触发重组，Compose会用State中的最新数值来重新运行函数，以刷新UI。比如上面的计数的例子，可以这样修改：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">WaterCounter</span><span class="p">(</span><span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">count</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="m">0</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="c1">// Other codes not changed</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这次，能得到期望的行为：</p>

<p><img src="https://pic2.zhimg.com/v2-d26bd68593ea22ef777f42f83aee37f5_b.webp" alt="state demo" /></p>

<p>有三种方式声明一个状态MutableState：</p>

<ul>
<li>val state = remember { mutableStateOf(default) }</li>
<li>var value by remember { mutableStateOf(default) }</li>
<li>val (vale, setValue) = remember { mutableStateOf(default) }</li>
</ul>


<p>基本上无差别，一般委托方式用的稍多一些。这里<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#remember(kotlin.Function0">remember</a>)的作用是让Compose记住并追踪状态的变化。如果想要让状态能够跨Activity的实例（比如遇到屏幕旋转，语言变化等配置变化导致Activity重启）就需要用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/saveable/package-summary#rememberSaveable(kotlin.Array,androidx.compose.runtime.saveable.Saver,kotlin.String,kotlin.Function0">remeberSaveable</a>)。</p>

<p>这些主要是针对Composable中内部的状态。对于像从ViewModel过来的业务数据，一般都用<a href="https://developer.android.com/reference/kotlin/androidx/lifecycle/compose/package-summary#(androidx.lifecycle.Lifecycle">collectAsState</a>.currentStateAsState())系列方法。</p>

<h2>有状态（Stateful）和无状态（Stateless）</h2>

<p>对于包含了创建State的函数就称作有状态的Composable，而不包含创建状态就是Stateless的。</p>

<p>无状态的Composable是幂等的，调用时直接传入数据，不会产生副作用，也不会触发重组，显然这对开发者来说是最高效的，因为很纯粹，使用起来相当简单，并且完全可复用，<strong>应该尽可能的创建并使用无状态Composables</strong>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">CustomButton</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">onClick</span><span class="p">:</span> <span class="p">()-&gt;</span><span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="n">Button</span><span class="p">(</span><span class="n">onClick</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>         <span class="n">Text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>状态提升</h2>

<p>因为State是有额外的成本的，因此应该尽可能的减少State的创建，那么就要尽可能的复用State。这就需要把状态提升到使用此State的所有子函数的最小公共函数里面。比如前面的例子，状态count在Text和两个Button中都有使用，那么count至少要提升到它们的公共函数里面。假如，这个count在其他Composable中也有使用，那么就提升到WaterCounter的更上一层，甚至是整个Screen级别。</p>

<p>一般情况下，除了一些仅在局部使用的状态外，放在页面级别的根函数里面是比较好的选择，这样的话只有页面的根函数是Stateful的，其余函数都是Stateless的。</p>

<h2>实战</h2>

<p>纸上来行终觉浅，要想掌握还是要亲手撸。状态管理对于UI框架是相当重要的，因为这是UI发挥作用和产生价值的地方。对于状态管理有一些非常好的CodeLab，可以亲手撸一下，感受一下状态管理到底是啥。</p>

<ul>
<li><a href="https://developer.android.com/codelabs/jetpack-compose-state#0">State in Jetpack Compose</a></li>
</ul>


<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/state">State and Jetpack Compose</a></li>
<li><a href="https://decode.agency/article/jetpack-compose-state/">How to handle state in Jetpack Compose</a></li>
<li><a href="https://www.composables.com/tutorials/state">Everything you need to know about State in Jetpack Compose with examples</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『见龙在田』| Modifier]]></title>
    <link href="http://toughcoder.net/blog/2024/05/30/modifier-made-easy/"/>
    <updated>2024-05-30T20:51:52+08:00</updated>
    <id>http://toughcoder.net/blog/2024/05/30/modifier-made-easy</id>
    <content type="html"><![CDATA[<p>通过<a href="https://juejin.cn/post/7371239685702844454">前面的文章</a>我们学会了如何使用元素来构建和填充我们的UI页面，但这只完成了一半，元素还需要装饰，以及进行动画和事件响应，这才能生成完整的UI。这就要用到Modifier，Jetpack Compose中的灵魂，它被用来装饰和增强Composables，让一个个平凡的元素变成鲜活的，好看的，可交互UI。我们来具体的看一下Modifier的使用方法。</p>

<p><a href="http://toughcoder.net/blog/2024/05/30/modifier-made-easy/"><img src="https://static.wixstatic.com/media/0d004d_2c19a3d66d7c4007a2f08ce17be24959~mv2.jpg/v1/fill/w_1000,h_500,al_c,q_85,usm_0.66_1.00_0.01/0d004d_2c19a3d66d7c4007a2f08ce17be24959~mv2.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>对于Compose来说，每一个元素叫做Composable，它是一个函数，比如前面学过的布局（如Row）和小部件（如Text）等都是一个Composable，可以把它理解成为一个元素。</p>

<h2>概念和基本使用方法</h2>

<p>Modifier之于元素，犹如CSS之于HTML，但能做的更多，因为除了样式装饰以外，Modifier还能做很多事情，比如响应用户输入。</p>

<p>每一个Composable都可以接收一个Modifier参数，准确地说第一个参数都是Modifier，可以把一个Modifier对象作为第一个参数传给元素；也可以用命名参数如modifier = Modifier.padding(8.dp)。Modifier支持链式调用，它的每个方法都会把当前对象返回：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">private</span> <span class="k">fun</span> <span class="nf">Greeting</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Column</span><span class="p">(</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>            <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">24.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">fillMaxWidth</span><span class="p">()</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span><span class="n">text</span> <span class="p">=</span> <span class="s">&quot;Hello,&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span><span class="n">text</span> <span class="p">=</span> <span class="n">name</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>装饰元素的样式</h2>

<p>重点来看一下如何用Modifier装饰元素的样式。需要注意的是Modifier是装饰元素的共性样式如尺寸，背景，边框和位移等等，而像具体元素特性，如Text中的文本样式，是无法用Modifier来修改的。</p>

<h3>尺寸Size</h3>

<p>尺寸对于一个UI元素来说是必要的，就是渲染之后的视觉上的宽度和高度。可以通过Modifier的下列函数来进行尺寸约束：</p>

<ul>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">width</a>.width(androidx.compose.ui.unit.Dp))/<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">height</a>.height(androidx.compose.ui.unit.Dp)) - 指定固定的偏好宽度和偏好高度，参数传入具体的数值如Modifier.width(320.dp).height(480.dp)，就是指定某个元素的宽度是320dp，高度是480dp。偏好（preferred）的意思是可能会被其他约束条件覆盖，而最终值可能会不一样。</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">size</a>.size(androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp)) - 同时指定宽度和高度为某一偏好的数值，只传一个参数就是一个正方形，如Modifier.size(100.dp)，等同于Modifier.width(100.dp).height(100.dp)；传两个参数时分别指定宽和高，如Modifier.size(320.dp, 480.dp)等同于Modifier.width(320.dp).height(480.dp)。</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">wrapContentWidth</a>.wrapContentWidth(androidx.compose.ui.Alignment.Horizontal,kotlin.Boolean))/<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">wrapContentHeight</a>.wrapContentHeight(androidx.compose.ui.Alignment.Vertical,kotlin.Boolean))/<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">wrapContentSize</a>.wrapContentSize(androidx.compose.ui.Alignment,kotlin.Boolean)) - 让元素自己决定尺寸，无视最小尺寸限制（minimum_wdith/minimum_height），类似于XML中的wrap_content，这是比较严格的限制。</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">requiredWidth</a>.requiredWidth(androidx.compose.ui.unit.Dp))/<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">requiredHeight</a>.requiredHeight(androidx.compose.ui.unit.Dp)) - 指定宽度和高度必须为某一数值，不可以被其他限制约束覆盖。带有In的函数可以指定一个范围。</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">requiredSize</a>.requiredSize(androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp)) - 指定宽度和高度必须为某一数值，带有In的函数可以指定范围。</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">widthIn</a>.widthIn(androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp))/<a href="">heightIn</a>/<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">sizeIn</a>.sizeIn(androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp)) - 带有in的函数，可以指定一个范围而非具体数值，比如Modifier.widthIn(10.dp, 100.dp)，就是说限制此元素的宽度为10dp到100dp之间。</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">fillMaxWidth</a>.fillMaxWidth(kotlin.Float))/<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">fillMaxHeight</a>.fillMaxHeight(kotlin.Float)) - 不固定具体的数值，按比例填充最大可用空间，比例为1.0时填满，类似于XML中的match_parent。</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">fillMaxSize</a>.fillMaxSize(kotlin.Float)) - 按比例填充满可用空间。</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/RowScope#(androidx.compose.ui.Modifier">weight</a>.weight(kotlin.Float,kotlin.Boolean)) - 权重比例，仅在父布局是Row或者Column时，且尺寸与父布局约束一致时有效，比如在Row中，对width生效，在Column中对height生效。最终的占比是『权重比例 x 可用空间』，不指定weight则weight是0，比如一个Row中，有三个元素，其中两个元素A和B指定了weight为1和2，另一个没指定，那么A将占Row中剩余可用宽度的1/3，B将占2/3。与View中的LinearLayout中的权重是差不多的。</li>
</ul>


<p>Modifier修饰尺寸的函数比较多，容易学杂了，需要梳理一下：size相当于快捷方式，可以同时约束宽和高；带有In的函数可以为某个约束指定范围。宽高是一种限制性约束，不同的函数的限制严格性是不一样的，带有required是最严格的限制约束，优先级最高，如有冲突，以它为准；wrapContentWidth/wrapContentHeight/wrapContentSize是较严格的限制，仅次于required；width/height/size是中等严格，较wrapContent再次之；weight再次之；fillMax则是最弱的限制。</p>

<h3>间隔</h3>

<p>间隔（padding）是在元素与其边界之间添加的额外的空白空间，<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">Modifier.padding</a>.padding(androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp))不影响元素的尺寸，它是在测量之前就应用生效。</p>

<p>对于有XML经验的同学来说，以往的间隔有两个，一个是margin控制着元素边界之外的间隔，padding控制着边界与元素本身内容间隔。对于Modifier来说，只有一个函数，在不同的位置调用padding函数会有不同的效果，<strong>如果在尺寸之后调用padding，则是调整边界与内容之间的间隔，如果是在尺寸之前调用，则是调整边界与外部的间隔</strong>。另外，就是padding不可以传负值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">PaddingDemo</span><span class="p">(</span><span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Box</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>        <span class="p">.</span><span class="n">fillMaxSize</span><span class="p">()</span>
</span><span class='line'>        <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">LightGray</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>            <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;降龙十八掌&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="n">style</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">typography</span><span class="p">.</span><span class="n">headlineLarge</span><span class="p">,</span>
</span><span class='line'>            <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>                <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">16.</span><span class="n">dp</span><span class="p">)</span> <span class="c1">// As margin: outside space beyond border</span>
</span><span class='line'>                <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Cyan</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="m">360.</span><span class="n">dp</span><span class="p">,</span> <span class="m">120.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">10.</span><span class="n">dp</span><span class="p">)</span> <span class="c1">// As padding: space between border and content</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://pic2.zhimg.com/80/v2-2e631702c0ecb3e9197b78bcca795781_1440w.webp" alt="padding demo" /></p>

<h3>位移Offset</h3>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">函数Modifier.offset</a>.offset(kotlin.Function1))用来给水平和垂直方向加一个位移，数值可正可负，注意仅是增加位移，并不会改变元素的尺寸。与View中的translateX和translateY是类似的。它有两个函数，只有一个参数时是水平和垂直方向都加上相同的位移；两个参数时是分别指定水平方向和垂直方向。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">ModifierDemo</span><span class="p">(</span><span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">offset</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="m">0</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">Column</span><span class="p">(</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">modifier</span>
</span><span class='line'>            <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">8.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">clickable</span> <span class="p">{</span> <span class="n">offset</span> <span class="p">+=</span> <span class="m">8</span> <span class="p">}</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>            <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;降龙十八掌&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="n">style</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">typography</span><span class="p">.</span><span class="n">headlineLarge</span><span class="p">,</span>
</span><span class='line'>            <span class="n">color</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">colorScheme</span><span class="p">.</span><span class="n">primary</span><span class="p">,</span>
</span><span class='line'>            <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>                <span class="p">.</span><span class="n">offset</span><span class="p">(</span><span class="n">offset</span><span class="p">.</span><span class="n">dp</span><span class="p">,</span> <span class="n">offset</span><span class="p">.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Cyan</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">16.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://pic2.zhimg.com/80/v2-89bf155dba60d2811a2fd164cde81d89_1440w.webp" alt="offset demo" /></p>

<p>因为offset并不改变元素的尺寸，仅是在原位置上进行偏移，所以多用于点击效果，或者点击动画。</p>

<h3>背景Background</h3>

<p>使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">Modifier.background</a>.background(androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Shape))函数来修改元素的背景颜色，唯一需要注意的是padding的影响，background是给尺寸所指定的区域加背景色，所以padding调用的位置会有影响。</p>

<h3>边框Border</h3>

<p>用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">Modifier.bodrer</a>.border(androidx.compose.foundation.BorderStroke,androidx.compose.ui.graphics.Shape))函数可以指定边框的样式，如形状，粗细，线条和颜色。需要注意的是它也是跟尺寸一样的，受padding的影响：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">BorderWithShape</span><span class="p">(</span><span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Box</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>            <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;降龙十八掌&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="n">style</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">typography</span><span class="p">.</span><span class="n">headlineLarge</span><span class="p">,</span>
</span><span class='line'>            <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>                <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">10.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">border</span><span class="p">(</span><span class="m">2.</span><span class="n">dp</span><span class="p">,</span> <span class="n">SolidColor</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Green</span><span class="p">),</span> <span class="n">RoundedCornerShape</span><span class="p">(</span><span class="m">20.</span><span class="n">dp</span><span class="p">))</span>
</span><span class='line'>                <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">10.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://pic4.zhimg.com/80/v2-59bd2c586c1a0124d178c1bf84f49feb_1440w.webp" alt="border demo" /></p>

<h3>变幻</h3>

<p>Modifier还能对元素进行一些变幻，如透明度（Alpha），旋转（Rotate）和缩放（Scale）。通常用来实现一些非动画的静态特效。</p>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">Modifier.alpha</a>.alpha(kotlin.Float))指定透明度，0是透明，1是完全不透明，默认值是1.0。</p>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">Modifier.rotate</a>.rotate(kotlin.Float))实现旋转，参数是一个角度，顺时针旋转为正值，逆时针旋转为负值，默认值是0度。</p>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">Modifier.scale</a>.scale(kotlin.Float,kotlin.Float))是以元素的几何中心为中心点进行缩放负值会进行水平和垂直方向翻转：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">TransformationDemo</span><span class="p">(</span><span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Box</span><span class="p">(</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">()</span>
</span><span class='line'>            <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">LightGray</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>            <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;降龙十八掌&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="n">style</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">typography</span><span class="p">.</span><span class="n">headlineLarge</span><span class="p">,</span>
</span><span class='line'>            <span class="n">color</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">colorScheme</span><span class="p">.</span><span class="n">primary</span><span class="p">,</span>
</span><span class='line'>            <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>                <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">16.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">alpha</span><span class="p">(</span><span class="m">0.618f</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">rotate</span><span class="p">(</span><span class="m">11.8f</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">scale</span><span class="p">(</span><span class="m">0.618f</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Cyan</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="m">360.</span><span class="n">dp</span><span class="p">,</span> <span class="m">120.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">offset</span><span class="p">(</span><span class="m">10.</span><span class="n">dp</span><span class="p">,</span> <span class="m">10.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://pic4.zhimg.com/80/v2-7c306b043b33f57d6eae20fcf59a1303_1440w.webp" alt="transformation demo" /></p>

<h2>事件监听</h2>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">Modifier.clickable</a>.clickable(kotlin.Boolean,kotlin.String,androidx.compose.ui.semantics.Role,kotlin.Function0))函数用来指定点击事件响应。此外，还可以用于指定元素是否可以点击。</p>

<p>另外，还可以通过<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">Modifier.scrollable</a>.scrollable(androidx.compose.foundation.gestures.ScrollableState,androidx.compose.foundation.gestures.Orientation,kotlin.Boolean,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,androidx.compose.foundation.interaction.MutableInteractionSource))来指定元素是否可以滑动。</p>

<h2>最佳实践</h2>

<p>Modifier是非常强大的，也是非常复杂的，前面列出的都是最为常用的一些函数。接下再来学习一下使用Modifier时需要注意的事项。</p>

<h3>顺序很重要</h3>

<p>Modifier有很多很多函数，修改着同一个对象实例，有些函数会相互影响，因此这些<strong>函数的调用顺序</strong>就变得相当重要，特别是涉及尺寸强相关的装饰特性时，如background和border，它们会受到padding以及变幻的影响。比如前面变幻小节的例子，可以试着修改函数的调用顺序，就会发现结果会不一样。在实例使用时，如果出现与预期不一致的结果时，就尝试调整一下Modifiier函数的顺序，看是否是顺序 导致的。</p>

<h3>留意上下文</h3>

<p>在Compose中，有一些Modifier函数只能在特定的元素中使用，这就涉及了Compose上下文（Scope）。比如说像<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/BoxScope#(androidx.compose.ui.Modifier">Modifier.align</a>.align(androidx.compose.ui.Alignment))只能在<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/BoxScope">BoxScope</a>中使用，也就是说只能在Box的子元素中使用。对其他任何布局来说都是不能用的，所以在使用的时候也要注意元素所在的父布局。</p>

<h3>尽可能的复用</h3>

<p>每个元素在渲染的时候都需要一个Modifier对象，通常情况下都是通过Modifier的函数进行对象创建。但对于一些循环的场景，且Modifier对象没啥变化 时，这时就应该复用对象，而非每次都创建。比如说动画，以及像集合性布局的子布局，这时都应该在其父布局缓存Modifier对象，直接传给子元素，而不是让其每次都创建新对象：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>        <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">12.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">background</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Gray</span><span class="p">)</span>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">LoadingWheelAnimation</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">animatedState</span> <span class="p">=</span> <span class="n">animateFloatAsState</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">LoadingWheel</span><span class="p">(</span>
</span><span class='line'>        <span class="c1">// 把Modifier对象缓存到上一级的父布局中，以免每帧动画都创建一个Modifier对象</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">reusableModifier</span><span class="p">,</span>
</span><span class='line'>        <span class="n">animatedState</span> <span class="p">=</span> <span class="n">animatedState</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于集合性布局也最好是能复用Modifier对象：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">reusableItemModifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>    <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="n">bottom</span> <span class="p">=</span> <span class="m">12.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>    <span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="m">216.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>    <span class="p">.</span><span class="n">clip</span><span class="p">(</span><span class="n">CircleShape</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">private</span> <span class="k">fun</span> <span class="nf">AuthorList</span><span class="p">(</span><span class="n">authors</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Author</span><span class="p">&gt;)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">LazyColumn</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">items</span><span class="p">(</span><span class="n">authors</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">AsyncImage</span><span class="p">(</span>
</span><span class='line'>                <span class="c1">// 提升到上一级中时进行缓存，而不是每次都创建</span>
</span><span class='line'>                <span class="n">modifier</span> <span class="p">=</span> <span class="n">reusableItemModifier</span><span class="p">,</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>保持一致性</h3>

<p>一致性对于代码的可维护性和可扩展性是非常重要的，因为每个元素都需要Modifier对象，在Compose中到处都可以看到Modifier，在实际使用中保持一致性就非常重要。比如说Modifier要作为Composable的第一个参数，参数的命名应该是modifier，并且最好要有默认值，可以查阅Compose本身的代码，可以发现其所有的元素都遵循此约定。另外，就是对于共性的装饰要提升到父布局中进行统一设定，比如说根布局统一设定padding，而不是每个子布局进行分别设定，等等。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/modifiers">Compose modifiers</a></li>
<li><a href="https://www.jetpackcompose.net/jetpack-compose-modifiers">6. Jetpack Compose Modifiers</a></li>
<li><a href="https://www.kodeco.com/books/jetpack-compose-by-tutorials/v1.0/chapters/6-using-compose-modifiers">6. Using Compose Modifiers</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『飞龙在天』| Layout]]></title>
    <link href="http://toughcoder.net/blog/2024/05/23/compose-layouts-and-widgets/"/>
    <updated>2024-05-23T20:47:29+08:00</updated>
    <id>http://toughcoder.net/blog/2024/05/23/compose-layouts-and-widgets</id>
    <content type="html"><![CDATA[<p>页面布局是GUI应用开发的核心，决定着一个UI具体如何实现。今天将延着路线图来练习『降Compose十八掌』的第二招式，学习一下如何使用Compose中的布局来构建页面。</p>

<p><a href="http://toughcoder.net/blog/2024/05/23/compose-layouts-and-widgets/"><img src="https://pdfhost.io/api/preview/0d8ea218-1cc8-4b68-a63b-30f534689371" title="auto auto" ></a></p>

<!-- more -->


<h2>基础骨架</h2>

<p>基础骨架是一个应用页面的最关键结构，可以视为一种基础结构，有了基础结构以后，再补充其他具体的细节就能拼凑出来整体页面。<a href="https://developer.android.com/develop/ui/compose/components/scaffold">Scaffold</a>就属于这样的一种基础骨架。</p>

<p>Scaffold并不是Compose设计出来的，它是<a href="https://m3.material.io/">Material Design</a>中的一个基础结构，为复杂的用户界面提供了标准化的平台。它可以把诸如标题栏，内容区域，浮动按扭等不同的UI功能部分组合在一起，形成一个整体连惯的页面。Compose是完全符合Material Design的，因此这里的Scaffold是符合Material Design设计标准的一个实现。</p>

<p>Scaffold主要有四个部分：</p>

<ul>
<li>topBar - 在最顶部的标题栏，可以显示标题，导航按扭，以及菜单。对Android熟悉的同学把它当成ActionBar就可以了。</li>
<li>bottomBar - 在最底部的工具栏，一般用来显示页面内部的下一级的Tab导航，或者当成工具栏放一些实用性操作。</li>
<li>floatingActionButton - 在右下角悬浮的操作按扭。因为右下角空间有限，所以一般把当前页面最主要的操作放在这里。比如说对于文档类，创建『+』按扭就可以放在这里。</li>
<li>content - 内容区域，就是用于显示页面主要内容的地方，无具体形式，需要开发者自己提供其他布局作为内容。唯一需要注意的是，内容Composable lambda有一个参数叫做innerPadding，这个参数的作用是Scaffold对其content区域加的padding，纯大多数情况下，是需要使用此参数的。</li>
</ul>


<p>Scaffold并不难，很好用，看一个&#127792;就知道了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@OptIn</span><span class="p">(</span><span class="n">ExperimentalMaterial3Api</span><span class="o">::</span><span class="k">class</span><span class="p">)</span>
</span><span class='line'><span class="n">@Preview</span>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">ScaffoldExample</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">presses</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableIntStateOf</span><span class="p">(</span><span class="m">0</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Scaffold</span><span class="p">(</span>
</span><span class='line'>        <span class="n">topBar</span> <span class="p">=</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">TopAppBar</span><span class="p">(</span>
</span><span class='line'>                <span class="n">colors</span> <span class="p">=</span> <span class="n">mediumTopAppBarColors</span><span class="p">(</span>
</span><span class='line'>                    <span class="n">containerColor</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">colorScheme</span><span class="p">.</span><span class="n">primaryContainer</span><span class="p">,</span>
</span><span class='line'>                    <span class="n">titleContentColor</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">colorScheme</span><span class="p">.</span><span class="n">primary</span><span class="p">,</span>
</span><span class='line'>                <span class="p">),</span>
</span><span class='line'>                <span class="n">title</span> <span class="p">=</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">Text</span><span class="p">(</span><span class="s">&quot;降Compose十八掌&quot;</span><span class="p">)</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>        <span class="p">},</span>
</span><span class='line'>        <span class="n">bottomBar</span> <span class="p">=</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">BottomAppBar</span><span class="p">(</span>
</span><span class='line'>                <span class="n">containerColor</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">colorScheme</span><span class="p">.</span><span class="n">primaryContainer</span><span class="p">,</span>
</span><span class='line'>                <span class="n">contentColor</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">colorScheme</span><span class="p">.</span><span class="n">primary</span><span class="p">,</span>
</span><span class='line'>            <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>                    <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxWidth</span><span class="p">(),</span>
</span><span class='line'>                    <span class="n">textAlign</span> <span class="p">=</span> <span class="n">TextAlign</span><span class="p">.</span><span class="n">Center</span><span class="p">,</span>
</span><span class='line'>                    <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;掌式要义&quot;</span><span class="p">,</span>
</span><span class='line'>                <span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">},</span>
</span><span class='line'>        <span class="n">floatingActionButton</span> <span class="p">=</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">FloatingActionButton</span><span class="p">(</span><span class="n">onClick</span> <span class="p">=</span> <span class="p">{</span> <span class="n">presses</span><span class="p">++</span> <span class="p">})</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">Icon</span><span class="p">(</span><span class="n">Icons</span><span class="p">.</span><span class="n">Default</span><span class="p">.</span><span class="n">Add</span><span class="p">,</span> <span class="n">contentDescription</span> <span class="p">=</span> <span class="s">&quot;Add&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span> <span class="n">innerPadding</span> <span class="p">-&gt;</span>
</span><span class='line'>        <span class="n">Column</span><span class="p">(</span>
</span><span class='line'>            <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="n">innerPadding</span><span class="p">),</span>
</span><span class='line'>            <span class="n">verticalArrangement</span> <span class="p">=</span> <span class="n">Arrangement</span><span class="p">.</span><span class="n">spacedBy</span><span class="p">(</span><span class="m">16.</span><span class="n">dp</span><span class="p">),</span>
</span><span class='line'>        <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>                <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">8.</span><span class="n">dp</span><span class="p">),</span>
</span><span class='line'>                <span class="n">text</span> <span class="p">=</span>
</span><span class='line'>                <span class="s">&quot;&quot;&quot;</span>
</span><span class='line'>                    <span class="err">“降龙十八掌可说是【武学中的巅峰绝诣】，当真是无坚不摧、无固不破。虽招数有限，但每一招均具绝大威力。</span>
</span><span class='line'>                    <span class="err">北宋年间，丐帮帮主萧峰以此邀斗天下英雄，极少有人能挡得他三招两式，气盖当世，群豪束手。</span>
</span><span class='line'>                    <span class="err">当时共有“降龙廿八掌”，后经萧峰及他义弟虚竹子删繁就简，取精用宏，改为降龙十八掌，掌力更厚。</span>
</span><span class='line'>                    <span class="err">这掌法传到洪七公手上，在华山绝顶与王重阳、黄药师等人论剑时施展出来，王重阳等尽皆称道。”</span>
</span><span class='line'>                <span class="s">&quot;&quot;&quot;.trimIndent(),</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>是一个非常标准的Material Design页面。</p>

<p><img src="https://pic4.zhimg.com/80/v2-702cd12966ec61fe985a3d0020114567_1440w.webp" alt="Scaffold Demo" /></p>

<p><strong>注意：</strong>如果仔细看Scaffold函数可以发现，前面提到的四大部分，并不是传入数据，而是传入函数。这是声明式代码与传统方式的最大的区别，也是声明式代码的精髓所在，只是声明一个可以用于产生数据的函数作为参数，而非直接把数据当作参数传过去。这样做的好处在于，框架代码可以在真正需要数据的时候通过调用函数来生成数据，避免了数据提前生成。</p>

<p>小结一下，Scaffold是一个非常强大的基础骨架，适用当作页面基础结构来使用，也就是说只能用它来实现一级页面。</p>

<h2>布局管理器</h2>

<p>有了页面的基础骨架后，就可以往里面填内容了，布局器管理器就是用于组织和管理其他布局和基础部件的约束器，方便对页面元素进行归类和整理。包括三个分类，一是基础布局，是最为基础也最为常用的管理器；二是高级布局，用于一些复杂场景的管理器；三是集合性布局，用于显示数据集合。我们分别来学习。</p>

<h3>基础布局</h3>

<p>最为基础的布局管理器就三个：Row（行式，水平方向依次排列）Column（列式，垂直方向依次排列）和Box（层叠式，在屏幕上层叠）。用一张图就明了：</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/layout-column-row-box.svg" alt="Basic layouts" /></p>

<p>如果有Android基础的同学可以进行类比，Row和Column就相当于LinearLayout，而Box相当于FrameLayout。</p>

<h3>高级布局</h3>

<p>一般情况下通过基础布局的组合能够实现绝大部分的UI页面，如果遇到更复杂的声明，那就要用更为强大的工具。</p>

<h4>约束式布局（ConstraintLayout in Compose）</h4>

<p>ConstraintLayout是谷歌推出的一个更为强大的布局，用约束（constraint）统一了概念，可以任意排列子布局。Compose中也是可以<a href="https://developer.android.com/develop/ui/compose/layouts/constraintlayout">使用ConstraintLayout的</a>，并且它可以替代Row，Column和Box。需要注意它并不是Compose的一部分，需要额外添加依赖：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Groovy'><span class='line'><span class="n">implementation</span> <span class="s2">&quot;androidx.constraintlayout:constraintlayout-compose:1.0.1&quot;</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">ConstraintLayoutContent</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">ConstraintLayout</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// Create references for the composables to constrain</span>
</span><span class='line'>        <span class="k">val</span> <span class="err">(</span><span class="py">button</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span> <span class="p">=</span> <span class="n">createRefs</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">Button</span><span class="p">(</span>
</span><span class='line'>            <span class="n">onClick</span> <span class="p">=</span> <span class="p">{</span> <span class="cm">/* Do something */</span> <span class="p">},</span>
</span><span class='line'>            <span class="c1">// Assign reference &quot;button&quot; to the Button composable</span>
</span><span class='line'>            <span class="c1">// and constrain it to the top of the ConstraintLayout</span>
</span><span class='line'>            <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">constrainAs</span><span class="p">(</span><span class="n">button</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">top</span><span class="p">.</span><span class="n">linkTo</span><span class="p">(</span><span class="n">parent</span><span class="p">.</span><span class="n">top</span><span class="p">,</span> <span class="n">margin</span> <span class="p">=</span> <span class="m">16.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">Text</span><span class="p">(</span><span class="s">&quot;Button&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Assign reference &quot;text&quot; to the Text composable</span>
</span><span class='line'>        <span class="c1">// and constrain it to the bottom of the Button composable</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>            <span class="s">&quot;Text&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="n">Modifier</span><span class="p">.</span><span class="n">constrainAs</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">top</span><span class="p">.</span><span class="n">linkTo</span><span class="p">(</span><span class="n">button</span><span class="p">.</span><span class="n">bottom</span><span class="p">,</span> <span class="n">margin</span> <span class="p">=</span> <span class="m">16.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/layout-button-text.png" alt="ConstraintLayout demo" /></p>

<p>ConstraintLayout是非常强大的，可以<a href="https://juejin.cn/post/7259659776459620411">参考前面的一篇文章</a>来了解它的使用方法，在Compose中使用与在View和XML中使用是一样的。</p>

<h4>流式布局（Flow layouts）</h4>

<p><a href="https://developer.android.com/develop/ui/compose/layouts/flow">流式布局</a>非常强大，也非常常用，它们能够自动折成多行或者多列。Row和Column只能一行或者一列，超出了父布局的宽度和高度后，就看不见了。但FlowRow和FlowColumn则可以自动折叠，变为多行或者多列。并且是智能折叠，不会让子元素只显示一半。这个有非常实用的场景，像显示一些新闻的标签时，就可以用FlowRow。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">private</span> <span class="k">fun</span> <span class="nf">FlowRowSimpleUsageExample</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">FlowRow</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">8.</span><span class="n">dp</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">ChipItem</span><span class="p">(</span><span class="s">&quot;Price: High to Low&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">ChipItem</span><span class="p">(</span><span class="s">&quot;Avg rating: 4+&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">ChipItem</span><span class="p">(</span><span class="s">&quot;Free breakfast&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">ChipItem</span><span class="p">(</span><span class="s">&quot;Free cancellation&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">ChipItem</span><span class="p">(</span><span class="s">&quot;£50 pn&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/layouts/flow/flow_row_simple.png" alt="FlowRow demo" /></p>

<h3>集合性布局</h3>

<p><a href="https://developer.android.com/develop/ui/compose/lists">集合性布局</a>用于显示数据集合，通常都是数量比较多。因为集合数据比较多，远超一个屏幕所能显示得完，因此集合性布局的优势在于用少量的子布局，以复用的方式来把集合数据展示出来。主要有三类水平方向的<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/lazy/package-summary#LazyRow(androidx.compose.ui.Modifier,androidx.compose.foundation.lazy.LazyListState,androidx.compose.foundation.layout.PaddingValues,kotlin.Boolean,androidx.compose.foundation.layout.Arrangement.Horizontal,androidx.compose.ui.Alignment.Vertical,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean,kotlin.Function1">LazyRow</a>)，垂直方向的<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/lazy/package-summary#LazyColumn(androidx.compose.ui.Modifier,androidx.compose.foundation.lazy.LazyListState,androidx.compose.foundation.layout.PaddingValues,kotlin.Boolean,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.ui.Alignment.Horizontal,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean,kotlin.Function1">LazyColumn</a>)以及格子式的LazyGrid。使用起来也非常的直观，在其<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/lazy/LazyListScope">LazyListScope</a>中为子元素生成布局就可以了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">LazyColumn</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">items</span><span class="p">(</span>
</span><span class='line'>        <span class="n">items</span> <span class="p">=</span> <span class="n">messages</span><span class="p">,</span> <span class="c1">// 这是集合</span>
</span><span class='line'>        <span class="n">key</span> <span class="p">=</span> <span class="p">{</span> <span class="n">message</span> <span class="p">-&gt;</span>
</span><span class='line'>            <span class="c1">// 指定一个用于唯一标记集合中每个元素的id</span>
</span><span class='line'>            <span class="n">message</span><span class="p">.</span><span class="n">id</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span> <span class="n">message</span> <span class="p">-&gt;</span>
</span><span class='line'>        <span class="c1">// 这里生成集合元素对应的布局</span>
</span><span class='line'>        <span class="n">MessageRow</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意的地方就是有很多个扩展函数items，每个集合性布局都有一个，在import的时候一定要选择与布局对应的那个。另外就是为了能让Compose区别不同的数据元素，一定要给集合元素指定一个可以在此范围内唯一标记元素的id。要不然在编辑的时候可能会有问题。</p>

<h2>常见基础部件</h2>

<p>最为常用的就是<a href="https://developer.android.com/develop/ui/compose/text">文本（Text）</a>，<a href="https://developer.android.com/develop/ui/compose/graphics/images/loading">图像（Image）</a>和<a href="https://developer.android.com/develop/ui/compose/graphics/images/material">图标（Icon）</a>了，都不复杂，看个例子就能明白怎么使用。需要说明一下的就是Image是用于显示的图片；而Icon是用于显示小的图标，一般都是矢量图标资源。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">ArtistCard</span><span class="p">(</span><span class="n">artist</span><span class="p">:</span> <span class="n">Artist</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Row</span><span class="p">(</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">16.</span><span class="n">dp</span><span class="p">),</span>
</span><span class='line'>        <span class="n">verticalAlignment</span> <span class="p">=</span> <span class="n">Alignment</span><span class="p">.</span><span class="n">CenterVertically</span><span class="p">,</span>
</span><span class='line'>        <span class="n">horizontalArrangement</span> <span class="p">=</span> <span class="n">Arrangement</span><span class="p">.</span><span class="n">spacedBy</span><span class="p">(</span><span class="m">16.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Box</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">Image</span><span class="p">(</span><span class="n">painter</span> <span class="p">=</span> <span class="n">painterResource</span><span class="p">(</span><span class="n">id</span> <span class="p">=</span> <span class="n">artist</span><span class="p">.</span><span class="n">image</span><span class="p">),</span> <span class="n">contentDescription</span> <span class="p">=</span> <span class="s">&quot;Artist image&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">Icon</span><span class="p">(</span>
</span><span class='line'>                <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">align</span><span class="p">(</span><span class="n">Alignment</span><span class="p">.</span><span class="n">BottomEnd</span><span class="p">),</span>
</span><span class='line'>                <span class="n">imageVector</span> <span class="p">=</span> <span class="n">Icons</span><span class="p">.</span><span class="n">Filled</span><span class="p">.</span><span class="n">Check</span><span class="p">,</span> <span class="n">contentDescription</span> <span class="p">=</span> <span class="s">&quot;Check mark&quot;</span><span class="p">,</span>
</span><span class='line'>                <span class="n">tint</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">colorScheme</span><span class="p">.</span><span class="n">surfaceTint</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">Column</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>                <span class="n">text</span> <span class="p">=</span> <span class="n">artist</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
</span><span class='line'>                <span class="n">style</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">typography</span><span class="p">.</span><span class="n">titleMedium</span><span class="p">,</span>
</span><span class='line'>                <span class="n">color</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">colorScheme</span><span class="p">.</span><span class="n">primary</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>            <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>                <span class="n">text</span> <span class="p">=</span> <span class="n">artist</span><span class="p">.</span><span class="n">status</span><span class="p">,</span>
</span><span class='line'>                <span class="n">style</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">typography</span><span class="p">.</span><span class="n">titleSmall</span><span class="p">,</span>
</span><span class='line'>                <span class="n">color</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">colorScheme</span><span class="p">.</span><span class="n">secondary</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://pic1.zhimg.com/80/v2-5cbb58f28d1ef31f076bcbb3c0565ab8_1440w.webp" alt="Widgets" /></p>

<h2>实战练习</h2>

<p>今天学习的内容比较多，Compose的<a href="https://developer.android.com/develop/ui/compose/components">布局非常之多</a>，今天的内容只是深入浅出式的学习了一些基础。另外，强烈建议亲手操练一下，推荐官方出品的实战教程<a href="https://developer.android.com/codelabs/jetpack-compose-basics#0">Jetpack Compose basics</a>和<a href="https://developer.android.com/codelabs/jetpack-compose-layouts#0">Basic layouts in Compose</a>。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/layouts/basics">Compose layout basics</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为安卓猿准备的Google I/O 2024省流版本]]></title>
    <link href="http://toughcoder.net/blog/2024/05/20/google-io-2024-recap/"/>
    <updated>2024-05-20T22:51:35+08:00</updated>
    <id>http://toughcoder.net/blog/2024/05/20/google-io-2024-recap</id>
    <content type="html"><![CDATA[<p>前两天一年一度的谷歌开发者大会Google I/O 2024在大洋彼岸如期举行，在会上谷歌发布了一系列最新的技术。本文将以Android开发为核心来汇总一下大会的内容。</p>

<p><a href="http://toughcoder.net/blog/2024/05/20/google-io-2024-recap/"><img src="https://io.google/2024/app/images/og-image.jpeg" title="auto auto" ></a></p>

<!-- more -->


<h2>Android 15 Beta 2来了</h2>

<p>自从Android站稳了脚跟以后（大概是在Android 4.3之后）基本上就是每年一个大版本的节奏，一般是在春季有预览版本，在秋季正式发布。为了抢在水果的前面，也都会在Google I/O时进行重点的宣传，所以每年的Google I/O一大看点就是新一代的Android。当然了，从去年开始AI变成了焦点，但是回到前几年时Android是绝对的焦点。</p>

<p>今年也不例外，在Google I/O上面也宣传了一下Android 15，并正式发布了第2个Beta版本，从功能和Feature角度来说，这个就非常接近于正式版本了。不过就如我在<a href="https://juejin.cn/post/7359900973991493669">前面一篇文章</a>中提到的那样，Android 15其实没啥亮点，主要集中在安全和隐私方面的加强，其余的改进也都非常的小。</p>

<p>关于Android 15具体的改动，可以看一下<a href="https://juejin.cn/post/7369178977473478693">前排大佬的总结</a>，总结的比较详细，就不重复了。</p>

<p>想体验Android 15 Beta 2的话，如果是谷歌的设备如Pixel系列，应该就有推送了。另外就是现在谷歌都会与厂商联动一起<a href="https://developer.android.com/about/versions/15/devices">发布新版Android的Beta版本</a>，这已经是好几年的传统了。就比如像小米，在15号大半夜（准确地说是16号凌晨）发布了<a href="https://web.vip.miui.com/page/info/mio/mio/detail?postId=44582045&amp;fromPathname=mioHomePage&amp;app_version=dev.240425&amp;ref=share">四款机型的Android 15 Beta OTA包</a>，手头有设备的可以体验一下。</p>

<p><img src="https://cdn.cnbj1.fds.api.mi-img.com/vip/e3f85e4bf27da33a47a6c343532c8f180555ebf855d77401c957163e1b1b2cac?thumb=1&amp;w=5040" alt="" /></p>

<p>再说一下Android 15（targetSdk 35）的适配，如前所述这一版本较上一代没啥变化，如果本身就已经<a href="https://juejin.cn/post/7359900973991493669">适配到了Android 14（targetSdk 34）</a>，就不用再特殊适配了。</p>

<h2>AI霸屏</h2>

<p>从去年开始AI就是巨头们的焦点，今年更是霸屏，整个Keynote全是关于AI的，唯一提到Android的地方，也是说在Android手机上如何使用AI。在大模型这条赛道上Google是追随者，就在Google I/O前两天还被Open AI给抢了热度给恶心了一把，劈柴大叔今年略忧伤，讲Keynote的时候有点无精打彩，完全没了前几年那种激情四射。</p>

<p>今年Google发布了Gemini 1.5 Pro，支持1M的上下文Token，大约可以记得1500份PDF，并且演示了很多大模型的具体应用场景，像搜索，图片处理以及文字和代码生成助手。</p>

<p>当然，Android开发者更应该关注的是在端侧部署的大模型。时至今日，大模型已经进入了平稳提升期，大家都是在做出更强大的模型，比如参数更多，上下文更长等等。但大模型仍有一个短板就是无法在端侧的部署，特别是移动设备，如手机，平板，车机，甚至手表等，因受制于性能。目前来说，端侧使用大模型都还是使用网络API的方式，一方面这会依赖于网络，但更重要的是，这会受制于安全和隐私。端侧大部分的数据，是不能直接，也不太可能全都上传到服务器。因此端则部署大模型还是有价值可挖的，比如说对于设备的运行数据，以及像用户一些不愿分享的数据，就可以直接用端侧的大模型来直接处理。</p>

<p>Google发布了端侧的大模型Gemini Nano，将会集成在Android 15之中，并且它支持多模态，还是值得期待的。不过呢，目前Gemini Nano也没有具体的API，谷歌也只给了一个空头支票，在手机上选择文字，然后端侧大模型就可以求解其中的数学题。说实话，这个举例场景的不够好，写作业的场景，作业题怎么可能出现在手机里，然后还是现成的文字？也说明美帝的学生不够卷，在我朝，早就有了作业帮，猿辅导之类的拍一下题目就能给出详细求解过程。</p>

<p><img src="https://duet-cdn.vox-cdn.com/thumbor/0x0:720x720/1440x1440/filters:focal(360x360:361x361):no_upscale():format(webp)/cdn.vox-cdn.com/uploads/chorus_asset/file/25446163/google_io_cts_720.gif" alt="" /></p>

<p>不过Android生态一向受制于厂商，谷歌能做的事情并不多，估计只在谷歌的官方设备（Pixel）中可以用，其他的还是要靠厂商。这点就比不上水果，相信在6月份，水果应该会拿出更为接地气（有实际场景应用和开放API）的端侧大模型集成方案。</p>

<h2>Android开发工具</h2>

<p>这次谷歌把其大模型Gemini应用到了很多具体的场景中，Android开发官方IDE Android Studio新版本<a href="https://developer.android.com/studio/preview">Koala</a>中就深度绑定了Gemini，可以用来生成代码，分析代码和帮助解决其他编程问题。</p>

<p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjijLoXfb-dz3Mur_G_lCCPvgbTr-b_Fvc6sigTPPlRJbA_0IhNepgqPW9a4UACplpEHc2llUMxOeEFBjxHOINVoHYBMWRJ3FA9B1L4MlEv0lxEg5YFuzv0pvuY47b0466pQeDgwtiPZSiivgr9iZ9GVWL0xxj5pzLysnq6ShNi7hn0LorpNBVa4enXsq4/s1600/code_transforms.gif" alt="" /></p>

<p>除了代码，此外Gemini还能帮忙分析错误报告，以及生成集成有Gemini API代码的项目，可见Gemini已经深度融合进了Android Studio之中。详细的可以<a href="https://android-developers.googleblog.com/2024/05/google-io-2024-whats-new-in-android-development-tools.html">看一看官文档</a>。看着都挺美好 的，但其实最想知道的问题是，是否会对我们东方大国开放使用？</p>

<p>其他的都是一些常规的小的提升，如可穿待设备的不同模式下的预览，Compose的实时编辑以及Compose Glance（桌面小部件）预览， 以及Android Studio Profiler的改进等等。</p>

<h2>Android开发套件</h2>

<p>对于Android相关的开发套件，唯一提到的都是与<a href="https://juejin.cn/post/7367390293812035610">Jetpack Compose</a>相关的，可见谷歌对它的重视。新东西也都中规中矩，主要是在动画上面，如分享页过渡，可复用列表（Lazy list）元素的动画；文本控件支持HTML了；一个新的布局ContextualFlowRow，用以实现复杂的可复用流式布局，这个还是挺有用的；以及性能提升。详细内容可以<a href="https://android-developers.googleblog.com/2024/05/whats-new-in-jetpack-compose-at-io-24.html">看官方博客</a>。</p>

<p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjbUo5RnrBoOsutrYVGiLIWZ16yIsll5cxnaSo9Gm4mXwl29MA_fVpwM0wH_RhRrehS9kJRnRISkEVW3yoTkhyT0GUEWg8kGCByRD2Gf0FOIJj9dyLD6NJYtOt4l-Vd_FEkJVj4DRNeu_G5fzwU34Dhq_Gv3dKozTq3iAcOrcHvS4o2WDHGDchZC-zhZL8/s600/image7.gif" alt="" /></p>

<p>Jetpack Compose对于常规的UI来说已经没有问题，但是对于一些专业领域的UI还是无法胜任，比如像相机，视频和图像的预览和渲染还是无法在Compose中使用。好消息是，现在Google已经着手处理了，这次就基于<a href="https://developer.android.com/jetpack/androidx/releases/camera">CameraX</a>搞了一个<a href="https://developer.android.com/jetpack/androidx/releases/camera#camera_viewfinder_compose_version_10_2">camera-viewfinder-compose</a>，能够在Compose中显示相机预览。</p>

<p>再有就是<a href="https://www.jetbrains.com/kotlin-multiplatform/">Kotlin Multiplatform</a>，这个是Jetbrains在主要搞的东西，谷歌也加大了配合力度（First class support），比如已经把一些Jetpack中的库添加了对KMM的支持。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://juejin.cn/post/73687573358034289020">2024 Google I/O Android 相关内容汇总</a></li>
<li><a href="https://9to5google.com/2024/05/14/google-io-2024-developer-recap/">What’s new for developers at Google I/O 2024</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『亢龙有悔』]]></title>
    <link href="http://toughcoder.net/blog/2024/05/15/compose-made-easy/"/>
    <updated>2024-05-15T20:26:06+08:00</updated>
    <id>http://toughcoder.net/blog/2024/05/15/compose-made-easy</id>
    <content type="html"><![CDATA[<p><a href="https://developer.android.com/develop/ui/compose">Jetpack Compose</a>是新一代的声明式的UI开发框架，由Google在2019年推出，最初是作为Android的新式UI开发框架，但它本质是一个声明式UI开发框架，并不受制于底层的平台，现在的Compose已有跨平台开发能力，但Android上的UI开发仍是最主要的使用领域，深受Android开发者喜爱。计划将用一系列文章，并开辟专栏来学习Compose，此为开篇。</p>

<p><a href="http://toughcoder.net/blog/2024/05/15/compose-made-easy/"><img src="https://alexzh.com/content/images/2021/02/logo-1.65-1980-compressed-4.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>注意：最初是叫做Jetpack Compose，作为Jetpack套件中的一个，后来与Jetpack独立开来了，现在Compose发展成为一个独立的声明式的UI开发框架，与Jetpack中其他组件并不是同一个概念，也并不在Jetpack套件里面。所以现在更多的称为Compose，为了方便后续统一称为Compose。</p>

<h2>Hello, Compose!</h2>

<p>老规矩，先来个简单的『Hello, world!』，以快速上手体验：</p>

<p>首先，用Android Studio创建一个新的项目，选择『Phone and Tablet』，选择『Empty Activity』，然后Next。</p>

<p><img src="https://pic2.zhimg.com/80/v2-f1df667c79bf94aa44fe00bccdfbbb65_1440w.webp" alt="create project" /></p>

<p>在项目配置页面填入项目名字和包名等信息，其余的用默认就好。</p>

<p><img src="https://pic3.zhimg.com/80/v2-b76564a9cd826d2dfcc949105eb4bb5a_1440w.webp" alt="config project" /></p>

<p>等一会儿后，项目就创建好了，与常规的Android项目一样的，也有AndroidManifest，是项目运行时的主要配置，以及一个系统组件MainActivity作为入口。打开MainActivity.kt，可以发现里面已经默认用了Compose，并且有东西，我们稍改一下，改成下面的样子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">MainActivity</span> <span class="p">:</span> <span class="n">ComponentActivity</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="n">Bundle</span><span class="p">?)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">super</span><span class="p">.</span><span class="n">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">)</span>
</span><span class='line'>        <span class="n">setContent</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">HelloComposeTheme</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">// A surface container using the &#39;background&#39; color from the theme</span>
</span><span class='line'>                <span class="n">Surface</span><span class="p">(</span>
</span><span class='line'>                    <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">(),</span>
</span><span class='line'>                    <span class="n">color</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">colorScheme</span><span class="p">.</span><span class="n">background</span>
</span><span class='line'>                <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">Greeting</span><span class="p">(</span><span class="s">&quot;Android with Compose!&quot;</span><span class="p">)</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">Greeting</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>        <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;Hello, $name&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">modifier</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">@Preview</span><span class="p">(</span><span class="n">showBackground</span> <span class="p">=</span> <span class="k">true</span><span class="p">)</span>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">GreetingPreview</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">HelloComposeTheme</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Greeting</span><span class="p">(</span><span class="s">&quot;Android&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后构建并运行项目，就能得到一个『Hello, Android with Compose!』：</p>

<p><img src="https://pic1.zhimg.com/80/v2-4325b9d9a0a3f1ebb8380dcdc7fe2bec_1440w.webp" height="480" width="320" alt="HelloCompose" /></p>

<p>样子略丑，我们来优化一下，修改Greeting函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">Greeting</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Box</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>            <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;Hello, $name&quot;</span><span class="p">,</span>
</span><span class='line'>            <span class="n">modifier</span> <span class="p">=</span> <span class="n">modifier</span>
</span><span class='line'>                <span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="m">16.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">align</span><span class="p">(</span><span class="n">Alignment</span><span class="p">.</span><span class="n">Center</span><span class="p">),</span>
</span><span class='line'>            <span class="n">style</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">typography</span><span class="p">.</span><span class="n">headlineLarge</span><span class="p">,</span>
</span><span class='line'>            <span class="n">color</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">colorScheme</span><span class="p">.</span><span class="n">inverseSurface</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这下好了一丢丢！</p>

<p><img src="https://pic4.zhimg.com/80/v2-efc8c9e62e38c02e6f18665d71862c97_1440w.webp" height="480" width="320" alt="HelloCompose v2" /></p>

<p>除了在手机或者模拟器运行应用以外，还可以直接用Android Studio进行预览（用&#64;Preview标记的函数才会被预览），不过这不算新功能，因为很久以前打开一个XML文件（如布局），也可以直接在AS里预览的：</p>

<p><img src="https://pic1.zhimg.com/80/v2-aa68d4eb84bf1bd130ca896c05371990_1440w.webp" alt="preview" /></p>

<p>好了，现在我们已经成功学会用Compose来撸安卓UI了。如果有时间还可以试试<a href="https://developer.android.com/develop/ui/compose/tutorial">官方的入门Demo</a>。</p>

<p>注意：不同版本的Android Studio可能会略不一样。详见下节『开发环境配置』。</p>

<h2>配置开发环境</h2>

<p>新一点的Android Studio如Giraffe，如果是新建的项目，默认就是用Compose了，不用再怎么搞（如果是上古时代的AS估计还是View的，建议直接升级AS吧都4202年了）。</p>

<p>如果是现有的项目，想要添加Compose支持，可以这样做，先给android的buildFeatures中添加compose为true，并指定kotlin compiler extension的版本，注意这个并不是kotlin的版本，跟它没关系：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">android</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">buildFeatures</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">compose</span> <span class="p">=</span> <span class="k">true</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">composeOptions</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">kotlinCompilerExtensionVersion</span> <span class="p">=</span> <span class="s">&quot;1.5.13&quot;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后再配置一坨依赖：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">dependencies</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">composeBom</span> <span class="p">=</span> <span class="n">platform</span><span class="p">(</span><span class="s">&quot;androidx.compose:compose-bom:2024.05.00&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">implementation</span><span class="p">(</span><span class="n">composeBom</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;androidx.compose.ui:ui&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;androidx.compose.ui:ui-graphics&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Material Design 3</span>
</span><span class='line'>    <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;androidx.compose.material3:material3&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Android Studio Preview support</span>
</span><span class='line'>    <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;androidx.compose.ui:ui-tooling-preview&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">debugImplementation</span><span class="p">(</span><span class="s">&quot;androidx.compose.ui:ui-tooling&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了方便管理Compose依赖的版本，谷歌搞了一个叫做『物料清单』（Bill of Materials BOM），简单来说就是把Compose所有library的版本放到一个叫做BOM的library中，我们只需要指定一个BOM，这样，就能指定一坨Compose libraries的版本。详细的内容以及困难解决可以<a href="https://developer.android.com/develop/ui/compose/setup#kotlin">参考官方文档</a>。</p>

<h2>理解Compose的基本原理</h2>

<p>从我们的『HelloCompose』中可以看出Compose的特点，它是纯代码，Compose就是一个坨函数声明，不用再撸XML了；它是声明式的，也就是说你只是告诉框架需要什么，期望的样子是什么；它是响应式的，也就是说拿到最新的数据和状态，然后用相应的UI元素进行展示。这与以往用XML写UI是完全不同的，用XML是命令式的，你要拿到View，设置具体的细节。</p>

<p>用Compose撸UI主要分为两部分，一是元素，如布局和具体的渲染元素如文字图片；另一个则是样式控制，所有元素都能接受一个Modifier对象来控制元素的样式，如大小，位置，偏移，对齐等等。会在后面的文章中对这些概念进行详细的讨论。</p>

<p>另外需要注意，Compose就是一坨函数，上面例子中看到的『setContent』，『HelloComposeTheme』，『Suface』，『 Greeting』，『GreetingPreview』，『Box』，『Text』都是函数，虽然它们不符合Kotlin的函数命令规范。这里面套娃式的结构如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">setContent</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">HelloComposeTheme</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// A surface container using the &#39;background&#39; color from the theme</span>
</span><span class='line'>        <span class="n">Surface</span><span class="p">(</span>
</span><span class='line'>            <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">(),</span>
</span><span class='line'>            <span class="n">color</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">colorScheme</span><span class="p">.</span><span class="n">background</span>
</span><span class='line'>        <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>             <span class="n">Greeting</span><span class="p">(</span><span class="s">&quot;Android with Compose!&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>是借助于尾部lambda实现的内部DSL，本质上也都是函数调用，视为函数调用就好了。感觉不熟悉的同学可以看看<a href="https://juejin.cn/post/7321550265610108979">前面的文章</a>以加深理解。</p>

<h2>为啥要使用Compose</h2>

<p>就Android开发来说明明已经有比较完善的View和XML来撸UI，为啥还要搞一个Compose呢？</p>

<p>首先，声明式编程范式是最新式的UI构建方式，较原始方式（View和XML）它更加接近于人的思维。开发者只需要告诉架构『我要什么』以及『该如何响应』就可以了，其他事情都交给框架。像Flutter， React， SwiftUI等都是声明式的。一旦我们熟悉了以后，就会发现声明式UI可以极大的提高开发效率，最重要的是它能提高可扩展性（Scalability）。</p>

<p>再有，Compose与各种最新的libraries粘合的特别好，像<a href="https://developer.android.com/jetpack">Jetpack</a>，<a href="https://m3.material.io/">MaterialDesign</a>等等，都可以直接在Compose中使用，非常的方便。</p>

<p>最后，最重要的原因是Google在大力的布道Compose，已经把Compose设置为默认的UI开发方式，作为<a href="https://developer.android.com/modern-android-development">MAD（Modern Android Development）</a>的一块拼盘，新推出的有关于UI的文章都是基于Compose的。并且Google还在不断大力开发Compose，推出新功能以及提升渲染性能。从前面的例子也可以看出，现在默认新建一个项目就是用的Compose，相反，如果想要弄一个只用View的项目，还比较麻烦，要去除一系列配置参数。</p>

<p>作为开发者，肯定要顺应潮流，迎头敢上（对的，是敢而不是赶）。</p>

<h2>迁移建议</h2>

<p>Compose虽然新式且好用，但我们在做迁移的时候要谨慎。对于新的技术（无论是新的编程语言，新的框架，还是新的编程范式）切忌不要一刀切或者搞大跃进。对于，纯新的功能，或者说纯新的项目，当然可以直接就用Compose来开发；但是对于现有的功能，暂时不要去动它，万不可上来就想着用Compose重写一遍。等到对Compose比较熟悉了，人力较富余时，以及现在功能仍会有新的较大的改动时才考虑去重写。对于比较成熟且稳定的功能，建议就不要去折腾它了，因为不会带来价值和收益。</p>

<p><a href="https://developer.android.com/develop/ui/compose/migrate">官方也有迁移建议</a>，可以看一看。</p>

<h2>优质教程与实例</h2>

<p>Google对Compose还是很上心的，写了<a href="https://developer.android.com/develop/ui/compose/documentation">大量的文档</a>，此外还有<a href="https://developer.android.com/courses/jetpack-compose/course">很多教程（CodeLabs）</a>，以及<a href="https://developer.android.com/samples">很多Demo app</a>。并且Compose作为MAD的一块拼盘，也融合进了MAD里面，特别是<a href="https://developer.android.com/develop/ui/compose/architecture">架构层面</a>的文章中用的都是Compose。</p>

<h2>未完，待续</h2>

<p>本文从快速上手的Demo开始，解释一些核心概念，并给出一些有用的资源链接。相信通过此文，能对Compose有一个很好的了解。后续会继续深入探讨各个话题，以练成降Compose十八掌！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[优雅的训服大模型：深入浅出Prompt技巧]]></title>
    <link href="http://toughcoder.net/blog/2024/05/07/prompt-made-easy/"/>
    <updated>2024-05-07T22:30:17+08:00</updated>
    <id>http://toughcoder.net/blog/2024/05/07/prompt-made-easy</id>
    <content type="html"><![CDATA[<p>ChatGPT以降，彻底引爆了AI，大模型进入了公众视野，每个人都可以享受AI带来的乐趣。大语言模型（Large Language Model LLM）虽然可以达到「类人」的水平，但仍需要以「大模型角度」去思考和对话才能最大限度的利用大模型的威力。这便是Prompt Engineer需要做的事情。今天就让我们学习总结一些Prompt技巧，以能优雅的训服大模型。</p>

<p><a href="http://toughcoder.net/blog/2024/05/07/prompt-made-easy/"><img src="https://japanesetarheel.com/wp-content/uploads/2023/04/prompt-engineering.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>说起来挺吓人的，但其实也没那么复杂，只要稍学习一下，厘清LLM的本质，就能掌握到Prompt的精髓，从而就能大大提高使用LLM的效率。</p>

<h2>本质是提问的技巧</h2>

<p>大模型第一次达到了「类人」水平，用户可以用自然语言与计算机进行交流了。那么为了达到事半功倍的效果，我们就要精进提问的技巧，这便是Prompt Engineering。如何做呢？要把大模型视为精通某一领域的专业顾问，要以与专业顾问（比如导游，咨询师）对话的角度来看待问题。</p>

<p>比如说马上五一假期了，想要去上海玩，你问大模型『五一假期去上海玩，推荐一些行程』，大模型肯定会给你一个中规中矩的万能日程。这不能怪大模型，如果你如此问一个导游，负责的导游会直接反问你一大堆细节问题，因为这是行程所必须的；或者也是随便推荐一些大家都知道的地方。但肯定 是没有参考价值的。</p>

<p><img src="https://leadingwithquestions.com/wp-content/uploads/2021/09/ArtOfAskingPowerfulQuestions-e1630504910641.jpg" alt="" /></p>

<p>为了达到最好的「沟通」效果，避免「Garbage In, Garbage Out」，就需要：</p>

<ul>
<li>视为在与专业人士对话，也就是要拟定大模型的角色</li>
<li>一次对话尽可能的专注于一个问题或者一个主题</li>
<li>把问题描述清楚，需要的关键要素都列清楚，比如时间，地点人物，关键事件等等</li>
<li>限定问题，也就是说要尽可能多的补充问题细节，限定问题需要的回答，比如说可以做什么，不可以做什么，需要什么是时间点</li>
<li>恰当的分隔，要多多使用标点符号对提问进行分隔，这样更有利于大模型抓住重点</li>
</ul>


<p>可以发现，这其实是沟通的技巧，抛开大模型，我们与正常的人沟通时，不也应该这样做吗？平时里的闲聊除外，正式的与人沟通时也应该使用这些技巧以达到最好的沟通效果。所以，最先需要掌握就是沟通技巧中的提问技巧。</p>

<p>继续我们上面的问题，使用上面的方法来优化提示：『五一假期，从南京出发，坐高铁，目的地上海，亲子3日游，不去迪士尼，不去动物园，安排详细行程』。这回得到的回答肯定有更大的参考价值。</p>

<h2>及时补充上下文</h2>

<p>大语言模型较以往的AI最大的进步在于超长的上下文记忆能力，这是它能达到「类人」水平的最主要的原因。那么在与大模型进行对话的时候，就要及时的补充上下文信息。一方面，你不可能一次性的把提问信息全都写全写对，那么一旦想到新的提示，就要及时的给到大模型；另外一方面，大模型有时候会胡编乱造，甚至胡言乱语（大模型都有一个叫做温度temperature的参数以控制这方面的行为），这并不是bug，而是语言创造力的一个体现。那么，一旦发现大模型跑偏了，就需要及时提供新的提示，补充上下文信息，对大模型进行纠正。</p>

<p>另外，就是如果感觉问题不太好理解，或者对输出有特殊的要求，还有一个补充上下文的办法就是给一个输出的示例，大模型是能够很好的捕获这一点的，并且这个对让大模型输出优质的回答非常有帮助。</p>

<p>不用担心溢出哈（就是输入字数太多，导致大模型理解不了），都4202年了，现在的大模型的上下文能力至少在4096个Token以上，对于大部分的常规问题来说足够了。</p>

<h2>掌握常见的命令和特殊标记</h2>

<p>大模型的输入是自然语言，但计算机毕竟是程序化的机器，那么就会有一些特殊的命令和标记以代表一些常用的功能。这个其实不是大模型所特有的，凡是接收字符串输入的地方，都会有一些特殊的命令和标记，如搜索引挚，如一些聊天应用。</p>

<p>特殊命令和特殊标记的作用在于简化输入，提升效率，特别是对于一些复杂的问题，比如像专业领域的问题，标准化的标记能大大的加强共识程度。这也跟大模型关系不大，就比如说数学和物理学上的符号，能达到一符号胜千言。</p>

<p>命令就是简洁，清晰和无歧义的动词：如描述，拟定，写出，规划等等。</p>

<p>而特殊标记则像方括号[]，三个引号&#8221;&ldquo;&#8221;，三个&#35;&#35;&#35;等等。</p>

<h2>理解专业领域知识</h2>

<p>前面的几点都是一些通用的提示优化小技巧，适用于常规的通用的小问题。如果是专业领域的问题，光有以上的技巧明显是不够的。这时就需要领域知识了，对领域要有深刻的理解，并熟悉领域的专业术语，把抽象的，泛化的问题或者需求，用专业术语进行描述，甚至对领域进行建模，转化为详细的，具体的提示词。然后输入到大模型，由大模型进行求解或者实现。最为典型的两个领域就是代码生成和图像生成，这是两个专业性比较强的领域，对结果的要求也比较高，因此对提示词的要求也更高。</p>

<h3>Code prompts</h3>

<p>要想让大模型写出更好的代码，就必须尽可能详细的给出代码要素，例如：编程语言必须指明，输出输出的参数或者格式必须指明，把限制说清楚，比如不能用什么，比如时间空间复杂度的限制，最重要的就是把需求写清楚，也就是要实现什么功能的代码。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://www.rtcdeveloper.cn/cn/community/blog/26205">GitHub Copilot 教程：提示词、技巧和用例</a></li>
<li><a href="https://github.blog/2023-06-20-how-to-write-better-prompts-for-github-copilot/">How to use GitHub Copilot: Prompts, tips, and use cases</a></li>
<li><a href="https://code.tutsplus.com/tips-for-effective-code-generating-chatgpt-prompts-prompt-design--cms-107346t">Tips for Effective Code-Generating ChatGPT Prompt Design</a></li>
</ul>


<h3>图像生成</h3>

<p>对于像Stable Diffusion的AIGC，更是需要一些特定领域的专业知识，才能写出比较好的提示词，达到预期的效果。比如提示词中要包含艺术风格，尺寸，比例，色彩，线条等等，而且要是关键词式的。所以，已经有<a href="https://github.com/lllyasviel/ControlNet">一些工具</a>，直接给出各种领域参数的可选择的具体值，以代替文本输入框，只需要在众多的参数的值中选择后，即可生成图片，确实方便很多。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://juejin.cn/post/7273025863989755956">Stable Diffusion 提示词入门指南</a></li>
<li><a href="https://docs.midjourney.com/docs/explore-prompting">Explore Prompting</a></li>
</ul>


<h2>优质的资源</h2>

<p>Prompting是有固定的套路可循的，就好比写代码，不用重复造轮子，已经有很多优质的prompt模板了。学会坐在现成的轮子上面，不但可以提高效率事半功倍，且能走的更稳更远。</p>

<ul>
<li><a href="https://github.com/PlexPt/awesome-chatgpt-prompts-zh">ChatGPT 中文调教指南</a></li>
<li><a href="https://github.com/logikon-ai/awesome-deliberative-prompting">Awesome Deliberative Prompting</a></li>
<li><a href="https://github.com/f/awesome-chatgpt-prompts">Awesome ChatGPT Prompts</a></li>
</ul>


<p>GitHub是个座金矿，每当需要什么资源的时候就去搜索「awesome xxx」就能得到非常优质的相关资源合集，这比自己一个一个的去找要方便太多了。</p>

<h2>Prompt Engineer工具</h2>

<p>提示工程Prompt Engineering已经成为了一个新的专业，有专职的职位叫做提示工程师Prompt Engineer，它们需要对领域有深刻理解，把抽象的，泛化的需求，描述为具体的提示词以让大模型去求解或者实现。除了提示工程师外，也有专门的提示工具，用以生成提示词，或者帮助做提示优化，当不知道如何提示时，或者想优化提示词时，就可以使用这些工具来帮忙：</p>

<ul>
<li><a href="https://prompt.com/">prompt.com</a></li>
<li><a href="https://promptmetheus.com/">Prompt Engineering IDE</a></li>
<li><a href="https://github.com/microsoft/promptbench">PromptBench</a></li>
</ul>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.promptingguide.ai/">Prompt Engineering Guide</a></li>
<li><a href="https://gptpmt.com/">GPT Prompt</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[教你用最优雅的方式把玩大模型]]></title>
    <link href="http://toughcoder.net/blog/2024/05/01/run-llm-locally/"/>
    <updated>2024-05-01T23:04:34+08:00</updated>
    <id>http://toughcoder.net/blog/2024/05/01/run-llm-locally</id>
    <content type="html"><![CDATA[<p><a href="https://www.cloudflare.com/learning/ai/what-is-artificial-intelligence/">人工智能（Artificial Intelligence）</a>几乎与计算机科学一样古老，在二十世纪50年代被首次提出，在60年代就已经形成比较成熟的理论。但受制于算力和数据，直到二十一世纪第一个10年后才有了重大突破（深度学习和CNN），并在第二个10年正式爆发（大模型）。2022年秋OpenAI的ChatGPT 3横空出世，让AI第一次达到「类人」层次，大语言模型（Large Language Model, LLM）也正式进入了公众的视野。自此，大模型开始刷屏和霸榜，人们言必之大模型。如果不折腾折腾大模型，似乎就是原始人，跟别人聊天都插不上话。痛定思痛，今天就来好好研究下大模型以跟上步伐。</p>

<p><a href="http://toughcoder.net/blog/2024/05/01/run-llm-locally/"><img src="https://researchworld.com/uploads/attachments/clr4q0wj95yyf8otdekmzjfy0-large-language-models-for-aspect-based-sentiment-analysis.max.png" title="auto auto" ></a></p>

<!-- more -->


<p>注意：常说的大模型是大语言模型的一种不严谨的简称，更为好的说法是<a href="https://www.cloudflare.com/learning/ai/what-is-large-language-model/">大语言模型（Large Langauge Model）</a>或者用其英文简写LLM，本文可能会混着用。</p>

<p>要了解一个东西最好的方式就先学会使用它，所以我们先从使用大模型开始。</p>

<h2>在本地部署LLM</h2>

<p>体验大模型的方式有很多种，最方便的就是直接使用各大AI大厂提供的聊天机器人如ChatGPT或者ChatGLM。确实很有趣，可以发现LLM与以往的人工智障非常不同的地方在于，它能听懂人话了，并且说的也像人话，也就是说它真的达到了『类人』层次了。</p>

<p>身为开发人猿，光这么把玩太无聊了，最适合开发人猿的玩法就是自己折腾，对的，我们要在本地部署LLM，这样玩起来才更过瘾。省流点说在本地部署有如下好处：</p>

<ul>
<li>可以深入了解LLM的技术栈，亲自折腾一遍才能知道到底有啥，需要啥。</li>
<li>更加安全，且能保护个人隐私。不用多说，直接用Chat服务或者API确实方便，但都是把数据传到别人的服务器上。有些不方便说的话，不适合别人看的，那肯定就不能用了。但使用部署在本地的LLM就不用担心了。</li>
<li>定制LLM以打造个人的知识库或者知识助手。</li>
<li>进行模型微调和深入学习。</li>
<li>积累经验，后续如果上云，有经验了就可以快速部署。</li>
</ul>


<p>在本地部署LLM好处简直不要太多，唯一的缺点就是LLM这玩意儿很费硬件，跑起来比较费钱，要跑的顺畅一些更是大把费钱。</p>

<h2>开源LLM托管平台</h2>

<p>很明显要想本地部署LLM，模型本身必须是开源的，因此只有开源的LLM才能在本地部部署，闭源的模型，只能通过其API使用。</p>

<p>那么，在折腾之前必须要搞懂的事情就是到哪里去找开源的LLM。幸运的是不但现在有很多开源LLM，也有非常方便的LLM托管平台。LLM托管平台就像GitHub之于开源代码一样，各大公司研发和测试完成后就会把LLM发布到托管平台上面，以供人使用。</p>

<p>最为著名的当属<a href="https://huggingface.co/models">HuggingFace</a>了，它不但提供LLM的托管，还有一个几乎成为业界标准的<a href="https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard">LLM评估系统</a>，定期发布最新模型的评估，以帮助大家选择合适的LLM。而且还提供了下载和使用LLM的Python库，即<a href="https://pypi.org/project/transformers/">著名的transformers</a>。但很可惜，我们无法访问（你懂得）。</p>

<p>莫慌，对于无法访问的技术网站，一定有<a href="https://hf-mirror.com/">国内的镜像</a>的，非常的好用，而且访问速度很快。</p>

<p><a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学</a>也曾有镜像，不过后来不能用了。</p>

<h2>如何在本地运行LLM</h2>

<p>下面介绍几种非常方便的，五分钟就能学会的本地部署和运行LLM的方式。</p>

<h3>Ollama</h3>

<p><img src="https://guidady.com/wp-content/uploads/2023/07/Ollama.png" alt="" /></p>

<p>最为方便的方式就是使用<a href="https://ollama.com/">Ollama</a>，它使用起来特别的方便，<a href="https://github.com/ollama/ollama">安装好以后</a>，直接一句就能运行并使用LLM了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>ollama run llama3
</span></code></pre></td></tr></table></div></figure>


<p>这就能运行Meta的最新的LLaMA3模型。当然了，运行具体模型前最好先读一读其文档，确认一下硬件配置是否满足模型要求。像家庭比较贫困的笔者用的是乞丐版的MBP（16G RAM+4G GPU）只能选择8B以内的模型，家庭条件比较好的可以上13B的模型，而33B的最好不要试了。</p>

<p>Ollama非常的好用，它本身是C/S式的，也就是说它会启一个小型的HTTP server以运行LLM，除了直接使用Ollama自己的终端以外，也可以充当模型API给其他工具使用，比如像<a href="https://python.langchain.com/docs/get_started/introduction">LangChain</a>就可以无缝对接Ollama。</p>

<p>它的缺点就是它是源于Mac，对Mac最为友好，其他系统如Windows和Linux是后来才支持的。另外就是使用起来比较简陋，仅有一个命令行终端，所以比较好的方式是使用Ollama来管理和运行LLM，但是再用其他工具来构建比较好用的终端。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://www.freecodecamp.org/news/how-to-run-open-source-llms-locally-using-ollama/">How to Run Open Source LLMs Locally Using Ollama</a></li>
<li><a href="https://klu.ai/glossary/ollama">Ollama: Easily run LLMs locally</a></li>
<li><a href="https://www.theregister.com/2024/03/17/ai_pc_local_llm/">How to run an LLM on your PC, not in the cloud, in less than 10 minutes</a></li>
</ul>


<h3>LM Studio</h3>

<p><img src="https://lmstudio.ai/static/media/demo2.9df5a0e5a9f1d72715e0.gif" alt="" /></p>

<p><a href="https://lmstudio.ai/">LM Studio</a>是一个集成化的，用户友好的，界面漂亮的开源LLM应用程序，它集LLM下载运行和使用于一体，且有着非常好用的图形化的终端。缺点就是对硬件要求较高，且不能当成API来使用，无法与其他工具对接。</p>

<ul>
<li><a href="https://www.kdnuggets.com/run-an-llm-locally-with-lm-studio">Run an LLM Locally with LM Studio</a></li>
<li><a href="https://digitaconnect.com/how-to-locally-run-a-llm-on-your-pc/">How to Locally Run a LLM on Your PC</a></li>
</ul>


<h3>GPT4All</h3>

<p><img src="https://img-blog.csdnimg.cn/img_convert/96470331467440dec2951abcac0dd195.png" alt="" /></p>

<p><a href="https://gpt4all.io/index.html">GPT4All</a>是一个与LM Studio类似的集成化的用户友好的工具。除了方便下载外，它也提供了好用的图形化终端来使用LLM。它除了可以使用下载的LLM以外，也支持API，并且除了正常的Chat以外，还能直接处理文档，也就是把文档当作LLM的输入。它对硬件的要求不像LM Studio那样高，缺点是对Mac似乎不太友好，因为它要求必须是最新版本的MacOS。</p>

<h2>总结</h2>

<p>本文介绍了几种使用起来非常方便的在本地运行LLM的方式，根据工具的特点，如果您使用的是Mac，或者想要与其他工具结合使用，那建议最好使用Ollama，毕竟它是对Mac最为友好的；如果硬件比较好就用LM Studio，否则的话就用GTP4ALL。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://semaphoreci.com/blog/local-llm">6 Ways For Running A Local LLM (how to use HuggingFace)</a></li>
<li><a href="https://www.infoworld.com/article/3705035/5-easy-ways-to-run-an-llm-locally.html">5 easy ways to run an LLM locally</a></li>
<li><a href="https://python.langchain.com/docs/guides/development/local_llms/">Run LLMs locally</a></li>
<li><a href="https://hackernoon.com/how-to-run-your-own-local-llm-updated-for-2024">How to Run Your Own Local LLM (Updated for 2024)</a></li>
<li><a href="https://kleiber.me/blog/2024/01/07/six-ways-running-llm-locally/">Six Ways of Running Large Language Models (LLMs) Locally (January 2024)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实战技巧：Android 14适配从挂号到出院]]></title>
    <link href="http://toughcoder.net/blog/2024/04/23/upgrade-to-targetsdk-34/"/>
    <updated>2024-04-23T21:30:23+08:00</updated>
    <id>http://toughcoder.net/blog/2024/04/23/upgrade-to-targetsdk-34</id>
    <content type="html"><![CDATA[<p>啥？这都4202年了，你的应用还没有升级到targetSDK 34？莫慌，本文就带着你全面的了解升级targetSDK 34的方法以及避坑指南。</p>

<p><a href="http://toughcoder.net/blog/2024/04/23/upgrade-to-targetsdk-34/"><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/25/1c33d2fabbc44e53b64b6dbbc84fd0ae.png" title="auto auto" ></a></p>

<!-- more -->


<p>注意，<a href="https://apilevels.com/">Android版本与其API level或者targetSDK是一一对应的</a>，只不过一个是外在的说法，一个是具体要做的事情，对于开发者来说适配Android 14，就等同于升级targetSDK到34，这个34称作API level。本文会混着用，但说的都是同一个意思。</p>

<p>等下，有同学举手了，这<a href="https://developer.android.com/about/versions/15">眼看着Android 15（API 35）都</a>要出来，您才教我们升级到targetSDK 34？您 是不是写错了，还是在这里浪费时间呢？</p>

<p>这位同学你先坐下，没写错今天要讲的就是适配Android 14的。至于Android 15还处于预览（Preview）状态呢，它要至少等到10月份左右才会正式发布，属于下半年的KPI了。不过如果 我们把targetSDK 34搞定了，那么年底升级targetSDK 35就会非常的顺畅。</p>

<h2>为啥要升级targetSDK</h2>

<p>在折腾之前要先要搞明白为啥要折腾升级SDK，因为毕竟配置开发环境是软件开发中的排名第二的麻烦事儿（排名第一的是折腾操作系统）项目跑的好好的，何必自找麻烦？</p>

<p>省流点的说，就是你<strong>不得不升级</strong>。众所周知，Android生态最麻烦的事情就是碎片化，也就是用户手机的版本远远小于最新的版本，而且主流的版本升级较慢，通常会比最新的慢3个版本以上，对面的水果则能保持在2个版本以内。这对应用开发生态来说是十分不友好的，因为开发者不愿意升级到最新的SDK，使用平台的最新特性，核心原因在于升级了也没用，因为用户手上的版本仍是3代开外的。</p>

<ul>
<li><a href="https://www.composables.com/tools/distribution-chart">Android Distribution Chart</a></li>
<li><a href="https://developer.android.com/about/dashboards">Distribution dashboard</a></li>
<li><a href="https://gs.statcounter.com/android-version-market-share/mobile/worldwide/">Mobile Android Version Market Share Worldwide</a></li>
</ul>


<p>最心急的当然是谷歌，辛苦花大价钱开发的最新特性竟然没人用，这能忍？于是谷歌对<a href="https://developer.android.com/google/play/requirements/target-sdk">升级targetSDK要求</a>越来越严，对于<strong>谷歌能管得到的地方</strong>，如<a href="https://developer.android.com/distribute/console">Google Play Store</a>和厂商的<a href="https://source.android.com/docs/security/safety-center/test-requirements">GTS测试</a>，都要求至少升级targetSDK到前一代的版本，比如2023年发布了Android 14，那就必须到targetSDK 33（Android 13）；今年将发布Android 15（API 35）那到快要发布时约在2024年秋，应用必须升级到targetSDK 34。</p>

<p>如果不是强制要求升级targetSDK，比如我既不上线到Play Store也不用过GTS，那确实也没必要折腾。因为最近几年Android的新特性其实也都挺鸡肋的，犯不着折腾。</p>

<h2>Android 14的新特性与变化</h2>

<p>具体折腾前还是要先了解一下平台的变化，以评估影响，省流点说，Android 14有以下变化：</p>

<ul>
<li><a href="https://developer.android.com/develop/background-work/services/foreground-services">FOREGROUND&#95;SERVICE</a>必须要指定一个<a href="https://developer.android.com/about/versions/14/changes/fgs-types-required">类型</a>。</li>
<li>调用<a href="https://developer.android.com/reference/android/bluetooth/BluetoothAdapter#getProfileConnectionState(int">BluetoothAdapter#getProfileConnectionState</a>)时必須在Manifest中声明<a href="https://developer.android.com/reference/android/Manifest.permission#BLUETOOTH_CONNECT">BLUETOOTH&#95;CONNECT</a>权限。</li>
<li>支持JDK17，可以使用Java 17了。</li>
<li>动态广播接收器必须指明<a href="https://developer.android.com/reference/androidx/core/content/ContextCompat#RECEIVER_NOT_EXPORTED(">export flag</a>)，这个其实targetSDK 33时就有了。</li>
<li>动态加载的代码（Jar 或者Dex）文件必须标记为只读。这个对插件化和Hotfix等影响较大。</li>
<li>Zip文件处理时，如果有路径越界（如&#8221;..&ldquo;或者以&rdquo;/&ldquo;开头的绝对路径）<a href="https://developer.android.com/reference/java/util/zip/ZipException">会抛异常</a>。</li>
</ul>


<p>总的来说变化不大，主要还是<strong>权限收紧和安全加强</strong>。可以查看<a href="https://developer.android.com/about/versions/14/behavior-changes-14">官方文档</a>来看具体的。不喜欢看原文的同学，还有<a href="https://developer.android.com/about/versions/14/behavior-changes-14?hl=zh-cn">翻译的版本</a>。啥？官方无法访问，莫慌还有<a href="https://developer.android.google.cn/about/versions/14/behavior-changes-14">官方的镜像</a>。</p>

<h2>如何升级</h2>

<h3>做好准备</h3>

<p>折腾开发环境是比较烦的，所以最好找一个相对轻松的时间（比如产品汪休假时），以及心情还不错时。另外一定要把手头的事情做好备份并切到新的分支，以防不测。这真不是把33改到34就能完事儿的，会有各种意想不到的事情。</p>

<h3>修改build.gradle文件</h3>

<p>升级targetSDK的第一步是修改应用的build.gradle文件。找到defaultConfig部分，将targetSdkVersion的值修改为34。例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='Groovy'><span class='line'><span class="n">android</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">compileSdkVersion</span> <span class="mi">34</span>
</span><span class='line'>    <span class="n">defaultConfig</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">targetSdkVersion</span> <span class="mi">34</span>
</span><span class='line'>        <span class="c1">// 其他配置...</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">// 其他构建配置...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>同时，确保compileSdkVersion也设置为34，以确保使用最新的编译工具。</p>

<p>注意，建议手动改配置，而不要用所谓的<a href="https://developer.android.com/build/sdk-upgrade-assistant">SDK Upgrade Assistant</a>，因为你不晓得它都会干啥，有可能把项目的配置改的面目全非。</p>

<h3>适配SDK的变化</h3>

<p>就是针对平台的新变化做对应的修改。如何修改？其实<a href="https://developer.android.com/about/versions/14/behavior-changes-14">官方文档</a>里面都有具体的指导，或者<a href="https://blog.csdn.net/lbs458499563/article/details/132928217">这篇文章讲的</a>也非常详细，这里就不重复了。</p>

<h2>避坑指南</h2>

<p>Android 14的变化并不大，没有Android 13带来的变化多，这几年最大的影响是Android 11到Android 13，主要体现在<strong>存储读写</strong>的变化上面，可以看<a href="http://toughcoder.net/blog/2023/05/03/android-scope-storage-puzzles/">之前的一篇文章</a>。</p>

<p><img src="https://s3.eu-west-2.amazonaws.com/uploads.3alampro.com/2021/September/GUKIJS1LwonmLnjJY0Wq5lkZTv78fAukV2SbTSui.jpeg" alt="" /></p>

<p>所以升级到targetSDK 34的难度有多大，有啥坑？这要取决于升级前的基础是什么。如果之前已经升级到了targetSDK 33，那么不会有坑，前面那几点稍弄下，就没有问题了。但如果还在API 30或者31，那麻烦会比较多，因为要先过targetSDK 33这一关，它的坑是最多的，可以<a href="https://juejin.cn/post/7260913522962956347">参考这篇文章</a>。</p>

<h2>做好对平台的封装与隔离</h2>

<p>最近几年Android版本的最大变化就是存储权限的收紧，以前可以直接用File到处读写，现在只有极少数文件夹可读可写，且像媒体文件要用<a href="https://developer.android.com/training/data-storage/shared/media">MediaStore API</a>。如果你的项目代码中到处都是File，甚至在JNI的so中也到处都是绝对路径，那么升级targetSDK会相当痛苦。</p>

<p>这就要求我们在开发过程中多留一个心眼儿。一个伟大的计算机科学家说过「计算机科学中的任何问题都能通过增加一个层来解决」。解决这种平台的硬性依赖的最好方法就是多加一层封装以进行隔离：</p>

<ul>
<li>用一个模块来封装所有的涉及存储的I/O操作，这样即使遇到平台的重大变化，也<strong>只需要改这一个模块，风险大大减小</strong>。</li>
<li>对于JNI，要尽可能的传递数据，而非直接让其操作文件。如果确实要操作文件，那么也要<strong>把根文件夹从Java层传入，不能让so使用绝对路径</strong>。</li>
</ul>


<p>对平台做好<strong>封装和隔离</strong>，会大大加强项目的兼容性，在升级平台SDK时起码能做到<strong>风险可控</strong>。</p>

<h2>未来Android的发展趋势</h2>

<p>Android（其实智能手机操作系统也一样）诞生于21世纪的第一个10年，在第二个10年达到了顶峰，移动互联网让科技巨头吃尽了红利，巨头们的市值更是超过了全球GDP总值。但回首最近两年的Google I/O和水果的WWDC，可以发现，Android和水果越来越像，也在相互抄袭，已经很久没有见到让人感到惊艳的东西了（乔帮主在天上估计都要看不下去了）。</p>

<p>对于Android来说，<strong>系统安全（包括权限收紧和数据安全）</strong>和<strong>隐私保护</strong>（安全和隐私曾经是Android的弱项，现在已追上来了），以及<strong>互联互通</strong>这三个方面还有点新东西，其他的已经没有什么变化了。智能手机已经到了比较明显的瓶颈期，巨头的注意力已经全都转移到了AI上面了。可以看一看<a href="https://developer.android.com/about/versions/15/behavior-changes-15">Android 15的变化</a>，基本上没啥变化，以后的升级会越来越简单了，可能下次只是把34改成35就完事儿了。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/about/versions/14/behavior-changes-14">Behavior changes: Apps targeting Android 14 or higher </a></li>
<li><a href="https://developer.android.com/build/sdk-upgrade-assistant">Use the Android SDK Upgrade Assistant</a></li>
<li><a href="https://developer.android.com/about/versions/14/setup-sdk">Set up the Android 14 SDK</a></li>
<li><a href="https://swiftspeed.app/sdk-target-android-api-level/">How To Update Your App SDK To Target Android API Level 34</a></li>
<li><a href="https://blog.csdn.net/lbs458499563/article/details/132928217">Android14 适配之——targetSdkVersion 升级到 34 需要注意些什么？</a></li>
<li><a href="https://juejin.cn/post/7260913522962956347">升级targetSDK为33后的十来个坑 (工具篇)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/628752923">Android 14 快速适配要点</a></li>
<li><a href="https://juejin.cn/post/7302348032544866316">Android 14 正式版适配笔记（二）— 针对Android14或更高版本应用的变更</a></li>
<li><a href="https://juejin.cn/post/7299834584375869474">Android 14 正式版适配笔记（一）— 针对所有应用的变更</a></li>
<li><a href="https://www.cnblogs.com/joy99/p/17809113.html">记一个 Android 14 适配引发的Android 存储权限问题</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一文搞懂Kotlin符号处理接口KSP]]></title>
    <link href="http://toughcoder.net/blog/2024/04/16/kotlin-ksp-made-easy/"/>
    <updated>2024-04-16T21:17:43+08:00</updated>
    <id>http://toughcoder.net/blog/2024/04/16/kotlin-ksp-made-easy</id>
    <content type="html"><![CDATA[<p>Kotlin符号处理（Kotlin Symbol Processing）即KSP是可以用于开发轻量级编译器插件的一套API。是Kotlin原生的，Kotlin语法友好的编译器插件。使用简单且易于上手，可以实现一些非常强大的编译时代码处理功能，如代码生成和代码检查。今天就来学习一下KSP的基本原理，以及如何使用KSP API。</p>

<p><a href="http://toughcoder.net/blog/2024/04/16/kotlin-ksp-made-easy/"><img src="https://androiddeepdive.github.io/Team-Blog/images/cover_ksp.png" title="auto auto" ></a></p>

<!-- more -->


<p><strong>注意</strong>，本文是Kotlin中较为高级的话题，适合有一定的Kotlin基础的同学，否则理解起来可能有难度，可以事先<a href="https://juejin.cn/column/7351592055908892723">阅读前面的文章</a>。</p>

<h2>什么是KSP</h2>

<p>与前文提到的注解处理器kapt类似，KSP也是一种编译时的插件，能够在编译前处理Kotlin语言的符号。KSP API能地道地处理Kotlin的源码，因为它是专门为Kotlin而设计的，能够完全的理解和识别Kotlin的语言符号，以及Kotlin专属的特性：如扩展函数，声明点泛型变化以及本地函数。KSP API基于Kotlin的语法，把Kotlin程序拆解为各种静态的符号，可以处理如类，成员，函数，参数 以及注解等等。但它并不是运行时的（那是反射做的事情），因此像逻辑如循环和条件语句是没有办法进行处理，以及也无法得到表达式的结果。</p>

<p>虽然KSP是编译器插件，但它是运行在最终编译之前，也就是说在编译器编译全部代码之前，事先会运行KSP插件。所以KSP API最适合做的事情是：</p>

<ol>
<li>读取代码和各种资源文件，并进行分析</li>
<li>生成代码</li>
</ol>


<p>接下来看如何具体使用KSP API。</p>

<h2>配置KSP</h2>

<p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcStf17qaB5JSFveiBVlA6ljiI0OgI3kN4hnQkBKtuFnSw&amp;s" alt="" /></p>

<p>KSP是由谷歌开发的一套工具，包括两部分一个是Kotlin plugin，另一个是依赖库。所以需要在项目的根build.gradle里面，先把plugin添加到项目里：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Groovy'><span class='line'><span class="c1">// The root build.gradle of your project</span>
</span><span class='line'><span class="n">plugins</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">id</span> <span class="s1">&#39;org.jetbrains.kotlin.jvm&#39;</span> <span class="n">version</span> <span class="s1">&#39;1.9.23&#39;</span> <span class="n">apply</span> <span class="kc">false</span>
</span><span class='line'>    <span class="n">id</span> <span class="s1">&#39;com.google.devtools.ksp&#39;</span> <span class="n">version</span> <span class="s1">&#39;1.9.23-1.0.20&#39;</span> <span class="n">apply</span> <span class="kc">false</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然，这一步其实并不是必须的，也可以在每个模块中再配置plugin。</p>

<p>接下来，在使用KSP的模块里面添加plugin，添加依赖以及指明KSP processor，这是最为关键的配置：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='Groovy'><span class='line'><span class="c1">// module build.gradle</span>
</span><span class='line'><span class="n">plugins</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">id</span> <span class="s1">&#39;org.jetbrains.kotlin.jvm&#39;</span>
</span><span class='line'>    <span class="n">id</span> <span class="s1">&#39;com.google.devtools.ksp&#39;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">dependencies</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">implementation</span> <span class="nf">project</span><span class="o">(</span><span class="s1">&#39;:kspannotation&#39;</span><span class="o">)</span>
</span><span class='line'>    <span class="n">ksp</span> <span class="nf">project</span><span class="o">(</span><span class="s1">&#39;:kspprocessor&#39;</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果项目顶层指定了plugin的版本，那么到了module这里，就不必再指定版本了。另外就是要注意版本的匹配，ksp的版本前半段『1.9.23』指明 的是最低的Kotlin版本要求。最好是让ksp要求的版本与指定的Kotlin版本匹配或者差距较小，否则可能会有问题。dependencies中的ksp指定的是KSP processor，对于有些库可能注解和定义和KSP的processor可能会在同一个包里，那么写一句就够了，如Room的，就一句：ksp &lsquo;androidx.room:room-compiler:2.6.1&#8217;。</p>

<p>如果是自定义的processor，需要为processor单独建一个library module，配置ksp库为依赖即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='Groovy'><span class='line'><span class="c1">// KSP processor module build.gradle</span>
</span><span class='line'><span class="n">plugins</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">id</span> <span class="s1">&#39;org.jetbrains.kotlin.jvm&#39;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">dependencies</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">implementation</span> <span class="nf">project</span><span class="o">(</span><span class="s1">&#39;:kspannotation&#39;</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">implementation</span> <span class="s1">&#39;com.google.devtools.ksp:symbol-processing-api:1.9.23-1.0.20&#39;</span>
</span><span class='line'>    <span class="n">implementation</span> <span class="s1">&#39;com.squareup:kotlinpoet-ksp:1.16.0&#39;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>典型的KSP procesor（包括网上大部分的例子）都是分了三个module，一个是定义注解的module，一个是实现processor的，一个是使用注解和processor的。但这并不是必须的，为了方便，其实把注解的定义和processor放在一个module就可以了。只要把processor与使用它的module分开来了，就可以。</p>

<p><strong>注意：</strong>对于processor module来说它的类型要是library，并且要是Java library或者Kotlin library，因为这是Kotlin语言层面的东西。对于Android同学来说在新建module时一定要选择『Java or Kotlin Library』。</p>

<h2>实现KSP Processor</h2>

<p>配置好了模块后，剩下的就是要实现一个KSP processor了。</p>

<h3>实现Processor</h3>

<p>大部分工作plugin已经做好了，我们需要做的就是实现一些接口。有两个需要实现，一个是<a href="https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/processing/SymbolProcessorProvider.kt">SymbolProcessorProvider</a>，另一个则是<a href="https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/processing/SymbolProcessor.kt">SymbolProcessor</a>。</p>

<p>SymbolProcessorProvider相当于是processor的一个工厂方法，我们实现它的create方法，返回一个SymbolProcessor实例，一个典型的实现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">MyProcessorProvider</span> <span class="p">:</span> <span class="n">SymbolProcessorProvider</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">override</span> <span class="k">fun</span> <span class="nf">create</span><span class="p">(</span><span class="n">environment</span><span class="p">:</span> <span class="n">SymbolProcessorEnvironment</span><span class="p">):</span> <span class="n">SymbolProcessor</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">MyProcessor</span><span class="p">(</span><span class="n">environment</span><span class="p">.</span><span class="n">codeGenerator</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>它就相当于一个工厂方法，把上下文环境传给processor，SymbolProcessor是重点，我们需要实现它的process方法，针对感兴趣的符号进行处理，比如用<a href="https://square.github.io/kotlinpoet/">KotlinPoet</a>生成代码，这里是发挥创造力的地方：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">MyProcessor</span><span class="p">(</span><span class="k">private</span> <span class="k">val</span> <span class="py">generator</span><span class="p">:</span> <span class="n">CodeGenerator</span><span class="p">)</span> <span class="p">:</span> <span class="n">SymbolProcessor</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">override</span> <span class="k">fun</span> <span class="nf">process</span><span class="p">(</span><span class="n">resolver</span><span class="p">:</span> <span class="n">Resolver</span><span class="p">):</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">KSAnnotated</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">annotatedClasses</span> <span class="p">=</span> <span class="n">resolver</span>
</span><span class='line'>            <span class="p">.</span><span class="n">getSymbolsWithAnnotation</span><span class="p">(</span><span class="n">MyAnnotation</span><span class="o">::</span><span class="k">class</span><span class="p">.</span><span class="n">java</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">filterIsInstance</span><span class="p">&lt;</span><span class="n">KSClassDeclaration</span><span class="p">&gt;()</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">aclass</span> <span class="k">in</span> <span class="n">annotatedClasses</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">val</span> <span class="py">packageName</span> <span class="p">=</span> <span class="n">aclass</span><span class="p">.</span><span class="n">packageName</span><span class="p">.</span><span class="n">asString</span><span class="p">()</span>
</span><span class='line'>            <span class="k">val</span> <span class="py">className</span> <span class="p">=</span> <span class="n">aclass</span><span class="p">.</span><span class="n">simpleName</span><span class="p">.</span><span class="n">asString</span><span class="p">()</span>
</span><span class='line'>            <span class="k">val</span> <span class="py">methods</span> <span class="p">=</span> <span class="n">aclass</span><span class="p">.</span><span class="n">getDeclaredFunctions</span><span class="p">())</span>
</span><span class='line'>            <span class="c1">// ...</span>
</span><span class='line'>         <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">emptyList</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>注册Processor</h3>

<p>实现了process后还需要把process注册一下，否则ksp plugin无法找到这个processor。在processor module与代码同级文件夹下新建文件『resources/META-INF/services/com.google.devtools.ksp.processing.SymbolProcessorProvider』，然后把刚才实现的provider的完整类名，写在文件里，如果是使用IDE一般都会有提示的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="c1">// myprocessor/src/main/</span>
</span><span class='line'><span class="c1">//    |-- kotlin/net/toughcoder/</span>
</span><span class='line'><span class="c1">//              |-- MyProcessorProvider.kt</span>
</span><span class='line'><span class="c1">//              |-- MyProcessor.kt</span>
</span><span class='line'><span class="c1">//    |-- resources/META-INF/services/</span>
</span><span class='line'><span class="c1">//              |-- com.google.devtools.ksp.processing.SymbolProcessorProvider</span>
</span><span class='line'><span class="c1">// file: resources/META-INF/services/com.google.devtools.ksp.processing.SymbolProcessorProvider</span>
</span><span class='line'><span class="n">net</span><span class="p">.</span><span class="n">toughcoder</span><span class="p">.</span><span class="n">MyProcessorProvider</span>
</span></code></pre></td></tr></table></div></figure>


<h2>为啥要用KSP</h2>

<p>目前来说KSP最主要应用仍然 是注解的处理，以及配合注解进行代码生成。通过前面一篇<a href="https://juejin.cn/post/7355024828262334501">关于注解的文章</a>中我们知道，注解的处理已经有了一个专门的工具了叫做kapt，就目前来说KSP能做的事情kapt也都能做，它们都是用于编译时代码处理以及代码生成，都能处理注解。那么，在已经有了kapt的前提下，为啥还要搞KSP呢？</p>

<p>kapt虽然是Kotlin的注解处理器，但是它保持Java的兼容性，它直接复用了Java的<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/AbstractProcessor.html">AbstractProcessor</a>，要依赖于Java的annotation procssor以及javac，只适用于Kotlin/JVM，其他target用不起来，因此它并不能算是Kotlin原生的工具，对Kotlin的特性支持不友好。再有就是，为了保持与javac的兼容性，它的处理速度很慢，必须先把Kotlin代码转成javac能认识的标准Java代码，这肯定会有不必要的性能开销。基于这些限制，kapt已经停止开发了，处于维护状态了，不会再添加新功能了。<strong>省流点来说，kapt是以Java角度来看待输入代码的（即也要处理的源码），而KSP是以Kotlin角度</strong>。</p>

<p>KSP则是Kotlin原生的，基于Kotlin开发的，且是为了Kotlin开发的，并不受限于javac，因此所有的Kotlin目标平台都能用。并且对Kotlin的特性支持的很友好。它的处理速度也较kapt有提升，因为不必要做编码转换了，省了一道工序。从官方给出的数据看至少能省25%的编译时间。另外，KSP的API使用起来更加的Kotlin友好一些SymbolProcessor传递过来的<a href="https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/processing/Resolver.kt">Resolver</a>有很方便的接口可以取得被标的类，而且符号对象是<a href="https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/symbol/KSClassDeclaration.kt">KSClassDeclaration</a>，它可以方便的取一个Kotlin类的相关的其他符号，如包名，类名，方法等。</p>

<h2>总结</h2>

<p>通过本文我们理解了KSP的概念，并学会了如何在项目中配置KSP， 以及如何实现一个KSP processor。KSP视Kotlin代码为一系列的静态符号，对Kotlin语言特性支持友好，处于活跃的开发状态且被官方大力支持，因此应该尽早转向KSP。并且相信KSP能做的事情会越来越多。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/ksp-overview.html">Kotlin Symbol Processing API</a></li>
<li><a href="https://developer.android.com/build/migrate-to-ksp">Migrate from kapt to KSP</a></li>
<li><a href="https://www.kodeco.com/33148161-write-a-symbol-processor-with-kotlin-symbol-processing">Write a Symbol Processor with Kotlin Symbol Processing</a></li>
<li><a href="https://www.codecentric.de/wissens-hub/blog/kotlin-symbol-processing-introduction">An Introduction to Kotlin Symbol Processing</a></li>
<li><a href="https://kt.academy/article/ak-ksp">Kotlin Symbol Processing</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin Annotation Made Easy]]></title>
    <link href="http://toughcoder.net/blog/2024/04/09/kotlin-annotation-made-easy/"/>
    <updated>2024-04-09T22:14:10+08:00</updated>
    <id>http://toughcoder.net/blog/2024/04/09/kotlin-annotation-made-easy</id>
    <content type="html"><![CDATA[<p>注解（Annotations）允许我们在代码中添加元数据（Meta data），提供代码以外的信息，这些元数据可以在编译时被编译器或其他工具读取和处理。 Kotlin作为一种功能强大且易于使用的多范式通用编程语言，注解（Annotations）是其核心特性之一。在Kotlin中，注解的使用非常广泛，可以用于框架设计、代码生成、测试、依赖注入等多个方面。今天就来学习一下Kotlin中注解的使用方法。</p>

<p><a href="http://toughcoder.net/blog/2024/04/09/kotlin-annotation-made-easy/"><img src="https://appmaster.dev/wp-content/uploads/2023/03/Understan-Kotlin-Annotations-1024x536.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>Kotlin是基于JVM的编程语言，并且可以与Java互通使用，因此事先了解一下Java的注解对于学习Kotlin的注解是非常有帮助的。可以阅读一下前面的文章来<a href="https://juejin.cn/post/7353138889458319412">回顾Java语言的注解</a>。</p>

<h2>什么是注解</h2>

<p>注解是元编程的一种实现方式，它并不直接改变代码，而是为代码提供额外的数据。注解不能单独存在，必须与代码中的其他元素一起使用。在Kotlin中，注解要使用符号『@』后面加一个已定义的注解名字，如『@Deprecated』。注解在Kotlin中的使用非常广泛的，相信有过代码经验的同学都至少看过大量的注解。</p>

<h2>注解的使用方法</h2>

<p>注解的使用是非常的直观的，在需要的代码元素（类，变量，属性，函数，参数等等）加上想要使用的注解就可以了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Fancy</span> <span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">@Fancy</span> <span class="k">fun</span> <span class="nf">baz</span><span class="p">(</span><span class="n">@Fancy</span> <span class="n">foo</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="p">(</span><span class="n">@Fancy</span> <span class="m">1</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Kotlin的注解也可以用在lambda上面，这实际上相当于应用于lambda函数生成的函数实例的invoke()上面：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">annotation</span> <span class="k">class</span> <span class="nc">Suspendable</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="py">f</span> <span class="p">=</span> <span class="n">@Suspendable</span> <span class="p">{</span> <span class="n">Fiber</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="m">10</span><span class="p">)</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>注解的使用点目标</h3>

<p>由于Kotlin最终要编译成为字节码，运行在JVM上，所以它必须符合Java的规范。但语法上Kotlin与Java还是不一样的，比如一句Kotlin代码可能会相当于Java的好几句，换句话说一个Kotlin语句中的元素可能会对应着Java中的好几个。这可能会带来问题。</p>

<p>注解并不能单独出现，它必须作用到某一个语法上的元素，因为Kotlin语法元素可能会对应着几个Java语法元素，那么注解可能会被用在多个目标元素上面。为了能精确的指定注解的作用目标，可以使用『使用点目标』（use-site targets）来标记具体的目标元素：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">Example</span><span class="p">(</span><span class="n">@field</span><span class="p">:</span><span class="n">Ann</span> <span class="k">val</span> <span class="py">foo</span><span class="p">,</span>    <span class="c1">// annotate Java field</span>
</span><span class='line'>              <span class="n">@get</span><span class="p">:</span><span class="n">Ann</span> <span class="k">val</span> <span class="py">bar</span><span class="p">,</span>      <span class="c1">// annotate Java getter</span>
</span><span class='line'>              <span class="n">@param</span><span class="p">:</span><span class="n">Ann</span> <span class="k">val</span> <span class="py">quux</span><span class="p">)</span>   <span class="c1">// annotate Java constructor parameter</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里面『Ann』是一个注解，其前面的『field/get/param』就用以指定具体的注解目标元素。可用的使用点目标有这些：</p>

<ul>
<li>file</li>
<li>property</li>
<li>field</li>
<li>get 属性的getter</li>
<li>set 属性的setter</li>
<li>receiver 扩展函数或者扩展属性的底层对象</li>
<li>param 构造函数的参数</li>
<li>setparam 属性setter的参数</li>
<li>delegate 指存储着受托对象实例的域成员</li>
</ul>


<p>『receiver』指的是扩展函数发生作用的实例，比如说：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">@receiver</span><span class="p">:</span><span class="n">Fancy</span> <span class="n">String</span><span class="p">.</span><span class="n">myExtension</span><span class="p">()</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么，这个注解『Fancy』将作用于具体调用这个扩展方法myExtension的String实例上面。</p>

<p>这些具体的使用点目标可以精确的指定JVM认识的元素上面，可以发现，它们远比定义注解时的<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/">@Target</a>要丰富。如果不指定具体的使用点目标，那么就会按照@Target指定的目标，如果有多个目标，会按如下顺序选择：</p>

<ul>
<li>param</li>
<li>property</li>
<li>field</li>
</ul>


<h3>兼容Java注解</h3>

<p>Kotlin是完全兼容Java注解，也就是说Java中定义的注解，在Kotlin中都可以直接使用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="c1">// Java</span>
</span><span class='line'><span class="kd">public</span> <span class="nd">@interface</span> <span class="n">Ann</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="nf">intValue</span><span class="o">();</span>
</span><span class='line'>    <span class="n">String</span> <span class="nf">stringValue</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="c1">// Kotlin</span>
</span><span class='line'><span class="n">@Ann</span><span class="p">(</span><span class="n">intValue</span> <span class="p">=</span> <span class="m">1</span><span class="p">,</span> <span class="n">stringValue</span> <span class="p">=</span> <span class="s">&quot;abc&quot;</span><span class="p">)</span> <span class="k">class</span> <span class="nc">C</span>
</span></code></pre></td></tr></table></div></figure>


<p>虽然可以直接用，但毕竟Kotlin的语法要丰富得多，所以为了避免歧义，要使用前面介绍的使用点目标来精确指定注解的作用目标。</p>

<h2>自定义注解</h2>

<p>使用关键字『annotation』来声明自定义注解，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">annotation</span> <span class="k">class</span> <span class="nc">Fancy</span>
</span></code></pre></td></tr></table></div></figure>


<p>之后就可以使用注解了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Fancy</span> <span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">@Fancy</span> <span class="k">fun</span> <span class="nf">baz</span><span class="p">(</span><span class="n">@Fancy</span> <span class="n">foo</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="p">(</span><span class="n">@Fancy</span> <span class="m">1</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>光这样声明还不够，还需要定义注解具体的内容，如可修饰的目标和行为特点，这就需要用到元注解（Meta annotations），也即定义注解时所需要的注解。</p>

<h3>元注解（Meta annotations）</h3>

<h4>@MustBeDocumented</h4>

<p>用于指定此注解是公开API的一部分，必须包含在文档中。</p>

<h4>@Repeatable</h4>

<p>允许在同一个地方多次使用注解。</p>

<h4><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-target/">@Target</a></h4>

<p>用于指定此注解可以应用到哪些程序元素上面，如类和接口，函数，属性和表达式。</p>

<ul>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-c-l-a-s-s.html#kotlin.annotation.AnnotationTarget.CLASS">AnnotationTarget.CLASS</a> - 类型，包括类型原型（classes），接口，对象，注解类型</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-p-r-o-p-e-r-t-y.html#kotlin.annotation.AnnotationTarget.PROPERTY">AnnotationTarget.PROPERTY</a> - 属性</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-f-i-e-l-d.html#kotlin.annotation.AnnotationTarget.FIELD">AnnotationTarget.FIELD</a> - 域变量</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-l-o-c-a-l_-v-a-r-i-a-b-l-e.html#kotlin.annotation.AnnotationTarget.LOCAL_VARIABLE">AnnotationTarget.LOCAL_VARIABLE</a> - 局部变量（本地变量）</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-v-a-l-u-e_-p-a-r-a-m-e-t-e-r.html#kotlin.annotation.AnnotationTarget.VALUE_PARAMETER">AnnotationTarget.VALUE_PARAMETER</a> - 参数</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-c-o-n-s-t-r-u-c-t-o-r.html#kotlin.annotation.AnnotationTarget.CONSTRUCTOR">AnnotationTarget.CONSTRUCTOR</a> - 构造函数</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-f-u-n-c-t-i-o-n.html#kotlin.annotation.AnnotationTarget.FUNCTION">AnnotationTarget.FUNCTION</a> - 函数</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-p-r-o-p-e-r-t-y_-g-e-t-t-e-r.html#kotlin.annotation.AnnotationTarget.PROPERTY_GETTER">AnnotationTarget.PROPERTY_GETTER</a> - 属性的getter</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-p-r-o-p-e-r-t-y_-s-e-t-t-e-r.html#kotlin.annotation.AnnotationTarget.PROPERTY_SETTER">AnnotationTarget.PROPERTY_SETTER</a> - 属性的setter</li>
</ul>


<h4>@Retention</h4>

<p>指定注解信息保存到代码生命周期的哪一阶段，编译前，编译时还是运行时。默认值是运行时，也即在运行时注解是可见的。</p>

<ul>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-retention/-s-o-u-r-c-e.html">AnnotationRetention.SOURCE</a> - 只在源码过程中保留，并不会出现在编译后的class中（二进制文件中）。</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-retention/-b-i-n-a-r-y.html">AnnotationRetention.BINARY</a> - 会在class中保留，但对于运行时并不可见，也就是通过反射无法得到注解。</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-retention/-r-u-n-t-i-m-e.html">AnnotationRetention.RUNTIME</a> - 注解会保留到运行时，运行时的操作如反射可以解析注解，这是默认的@Rentention值。</li>
</ul>


<h3>构造方法（Constructors）</h3>

<p>与Java很不同的是Kotlin的注解更加的像常规的类（class），注解也可以有构造函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">annotation</span> <span class="k">class</span> <span class="nc">Special</span><span class="p">(</span><span class="k">val</span> <span class="py">why</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">@Special</span><span class="p">(</span><span class="s">&quot;example&quot;</span><span class="p">)</span> <span class="k">class</span> <span class="nc">Foo</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<p>构造函数可以使用的参数包括：</p>

<ul>
<li>基础数据类型Int，Long，Float和String等</li>
<li>类型原型（即class，如Foo::class）</li>
<li>枚举类型</li>
<li>其他注解类型</li>
<li>由以上类型组成的数组</li>
</ul>


<p>注意不能有可能为空（如String?）的类型，当然也不可以传递null给注解的构造函数。还有，如果用其他注解作为参数时，注解名字前就不用再加『@』了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">annotation</span> <span class="k">class</span> <span class="nc">ReplaceWith</span><span class="p">(</span><span class="k">val</span> <span class="py">expression</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">annotation</span> <span class="k">class</span> <span class="nc">Deprecated</span><span class="p">(</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">message</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">replaceWith</span><span class="p">:</span> <span class="n">ReplaceWith</span> <span class="p">=</span> <span class="n">ReplaceWith</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<h3>注解的实例化（Instantiation）</h3>

<p>在Kotlin中可以通过调用注解的构造函数来实例化一个注解来使用。而不必非要像Java那样用反射接口去获取。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">annotation</span> <span class="k">class</span> <span class="nc">InfoMarker</span><span class="p">(</span><span class="k">val</span> <span class="py">info</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="nf">processInfo</span><span class="p">(</span><span class="n">marker</span><span class="p">:</span> <span class="n">InfoMarker</span><span class="p">):</span> <span class="n">Unit</span> <span class="p">=</span> <span class="n">TODO</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">isNotEmpty</span><span class="p">())</span>
</span><span class='line'>        <span class="n">processInfo</span><span class="p">(</span><span class="n">getAnnotationReflective</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>        <span class="n">processInfo</span><span class="p">(</span><span class="n">InfoMarker</span><span class="p">(</span><span class="s">&quot;default&quot;</span><span class="p">))</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>注解解析</h2>

<p>Kotlin是基于JVM的编程语言，最终要编译成为字节码运行在JVM上面，所以注解的解析与Java语言注解解析是一样的，可以在运行时用反射API来解析注解。关于Java注解解析可以<a href="http://toughcoder.net/blog/2024/03/24/java-annotations-made-easy/">参考另一篇文章</a>，因为运行时注解解析用处并不大，并且也不复杂，看一个简单&#127792;就可以了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">Item</span><span class="p">(</span>
</span><span class='line'>  <span class="n">@Positive</span> <span class="k">val</span> <span class="py">amount</span><span class="p">:</span> <span class="n">Float</span><span class="p">,</span>
</span><span class='line'>  <span class="n">@AllowedNames</span><span class="p">([</span><span class="s">&quot;Alice&quot;</span><span class="p">,</span> <span class="s">&quot;Bob&quot;</span><span class="p">])</span> <span class="k">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="py">fields</span> <span class="p">=</span> <span class="n">item</span><span class="o">::</span><span class="k">class</span><span class="p">.</span><span class="n">java</span><span class="p">.</span><span class="n">declaredFields</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">field</span> <span class="k">in</span> <span class="n">fields</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="k">annotation</span> <span class="k">in</span> <span class="n">field</span><span class="p">.</span><span class="n">annotations</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">field</span><span class="p">.</span><span class="n">isAnnotationPresent</span><span class="p">(</span><span class="n">AllowedNames</span><span class="o">::</span><span class="k">class</span><span class="p">.</span><span class="n">java</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">val</span> <span class="py">allowedNames</span> <span class="p">=</span> <span class="n">field</span><span class="p">.</span><span class="n">getAnnotation</span><span class="p">(</span><span class="n">AllowedNames</span><span class="o">::</span><span class="k">class</span><span class="p">.</span><span class="n">java</span><span class="p">)</span><span class="o">?.</span><span class="n">names</span>
</span><span class='line'>         <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>注解处理器</h2>

<p>注解是元编程的一种方式，它最大的威力是在编译前进行代码处理和代码生成。除了注解的定义和使用外，更为关键的注解的处理需要用到注解处理器（Annotation Processor），并且要配合编译器插件<a href="https://kotlinlang.org/docs/kapt.html">kapt</a>和<a href="https://kotlinlang.org/docs/ksp-overview.html">KSP</a>来使用。</p>

<p>需要注意，因为注解是JVM支持的特性，在编译时需要借助javac编译器，所以只有运行目标是JVM时注解才有效。因为Kotlin是支持编译为不同运行目标的，除了JVM外，还有JavaScript和Native。</p>

<h3>实现注解处理器</h3>

<p>与Java的注解处理器类似，在定义好注解后，还需要实现一个注解处理器，以对注解进行处理。一般情况下实现AbstractProcessor就可以了。在其process方法中过滤出来想要处理的注解进行处理，比如使用<a href="https://github.com/square/kotlinpoet">KotlinPoet</a>生成代码。</p>

<p>另外，还要注意，注解处理器必须在一个单独的module中，然后添加为使用此注解module的依赖，这是因为注解的处理是在编译前，所以处理器需要在正式编译前就已经编译好。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">package</span> <span class="nn">net.toughcoder</span>
</span><span class='line'>
</span><span class='line'><span class="k">import</span> <span class="nn">javax.annotation.processing.*</span>
</span><span class='line'><span class="k">import</span> <span class="nn">javax.lang.model.element.*</span>
</span><span class='line'><span class="k">import</span> <span class="nn">javax.tools.Diagnostic</span>
</span><span class='line'>
</span><span class='line'><span class="n">@SupportedAnnotationTypes</span><span class="p">(</span><span class="s">&quot;com.example.MyAnnotation&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">@SupportedSourceVersion</span><span class="p">(</span><span class="n">SourceVersion</span><span class="p">.</span><span class="n">RELEASE_8</span><span class="p">)</span>
</span><span class='line'><span class="k">class</span> <span class="nc">MyAnnotationProcessor</span> <span class="p">:</span> <span class="n">AbstractProcessor</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">override</span> <span class="k">fun</span> <span class="nf">process</span><span class="p">(</span><span class="n">annotations</span><span class="p">:</span> <span class="n">MutableSet</span><span class="p">&lt;</span><span class="k">out</span> <span class="n">TypeElement</span><span class="p">&gt;,</span> <span class="n">roundEnv</span><span class="p">:</span> <span class="n">RoundEnvironment</span><span class="p">):</span> <span class="n">Boolean</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="k">annotation</span> <span class="p">:</span> <span class="n">annotations</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">for</span> <span class="p">(</span><span class="n">element</span> <span class="p">:</span> <span class="n">roundEnv</span><span class="p">.</span><span class="n">getElementsAnnotatedWith</span><span class="p">(</span><span class="k">annotation</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">val</span> <span class="py">myAnnotation</span> <span class="p">=</span> <span class="n">element</span><span class="p">.</span><span class="n">getAnnotation</span><span class="p">(</span><span class="n">MyAnnotation</span><span class="o">::</span><span class="k">class</span><span class="p">.</span><span class="n">java</span><span class="p">)</span>
</span><span class='line'>                <span class="k">val</span> <span class="py">message</span> <span class="p">=</span> <span class="s">&quot;Processing element with annotation MyAnnotation(value = ${myAnnotation.value})&quot;</span>
</span><span class='line'>                <span class="n">processingEnv</span><span class="p">.</span><span class="n">getMessager</span><span class="p">().</span><span class="n">printMessage</span><span class="p">(</span><span class="n">Diagnostic</span><span class="p">.</span><span class="n">Kind</span><span class="p">.</span><span class="n">NOTE</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">true</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从例子中可以看到，其实Kotlin中的注解处理器（Processor）直接就是用的Java的，所以在用的时候最好加上Java语言的版本。</p>

<h3>注册注解处理器</h3>

<p>为能正常使用注解处理器，需要把注解处理器放在一个单独的Module里，并作为其他module的依赖，这样能确保它在编译被依赖项时正常使用，被依赖项也即注解使用的地方。</p>

<p>需要在处理器module中与代码平级的文件夹创建resources文件夹，创建一个子文件夹META-INF，再在META-INF创建一个子文件services，在里面创建一个文件名为『javax.annotation.processing.Processor』，然后把实现的注解处理器的完整类名，写在这个文件的第一行：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="c1">// file: resources/META-INF/services/javax.annotation.processing.Processor</span>
</span><span class='line'><span class="n">net</span><span class="p">.</span><span class="n">toughcoder</span><span class="p">.</span><span class="n">MyAnnotationProcessor</span>
</span></code></pre></td></tr></table></div></figure>


<h3>使用注解处理器</h3>

<p><img src="https://bigknol.com/wp-content/uploads/2023/07/android-ksp-kapt-768x439.png" alt="" /></p>

<p>需要做两个事情，一个是把注解处理器添加为其他项目或者module的依赖。然后再用<a href="https://kotlinlang.org/docs/kapt.html">专门处理注解处理器的编译器插件</a>使用注解处理器。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Groovy'><span class='line'><span class="n">dependencies</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">implementation</span><span class="o">(</span><span class="n">kotlin</span><span class="o">(</span><span class="s1">&#39;stdlib&#39;</span><span class="o">))</span>
</span><span class='line'>    <span class="n">kapt</span> <span class="s1">&#39;net.toughcoder:my-annotation-processor:1.0.0&#39;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">kapt</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">useBuildCache</span> <span class="o">=</span> <span class="kc">true</span>
</span><span class='line'>    <span class="n">annotationProcessors</span> <span class="o">=</span> <span class="o">[</span><span class="s1">&#39;net.toughcoder:my-annotation-processor:1.0.0&#39;</span><span class="o">]</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>总结</h2>

<p>本文介绍了Kotlin中注解的基本语法、使用方法和处理过程。通过自定义注解处理器，我们可以在编译时处理注解并生成相应的代码或执行其他任务。注解是Kotlin编程中的核心特性，它可以帮助我们提高代码的可读性、可维护性和可扩展性。大部分的注解都在编译时，也不会对性能产生影响，所以可以放心大胆的用注解来提升开发效率。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/annotations.html">Annotations</a></li>
<li><a href="https://www.baeldung.com/kotlin/annotations">Kotlin Annotations</a></li>
<li><a href="https://kt.academy/article/ak-annotation-processing">Annotation Processing</a></li>
<li><a href="https://www.kodeco.com/8574679-annotation-processing-supercharge-your-development">Annotation Processing: Supercharge Your Development</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java Annotations Made Easy]]></title>
    <link href="http://toughcoder.net/blog/2024/03/24/java-annotations-made-easy/"/>
    <updated>2024-03-24T22:48:07+08:00</updated>
    <id>http://toughcoder.net/blog/2024/03/24/java-annotations-made-easy</id>
    <content type="html"><![CDATA[<p>在Java编程语言中，注解Annotations是一种元数据，能提供代码以外的信息，是元编程的一种体现形式。注解的引入极大的增强了Java语言的元编程能力，能在编译时生成代码，大大减少了重复代码，让Java具有了相当高的动态特性，让一些高级技术如依赖注入，AOP等成为可能。今天将从基础使用，核心概念理解和创建自定义注解三个角度来彻底学会注解，并学会使用注解来提升开发效率。</p>

<p><a href="http://toughcoder.net/blog/2024/03/24/java-annotations-made-easy/"><img src="https://developersjournal.in/wp-content/uploads/2017/06/java-annotations.png" title="auto auto" ></a></p>

<!-- more -->


<h2>基础知识</h2>

<p>注解在代码中使用是非常常见的，相信只要有编程经验的同学都对注解非常的熟悉。</p>

<h3>什么是注解</h3>

<p>Java 注解（Annotation）是JDK5.0及以后版本引入的，它可以用于创建文档，代码分析，编译检查以及编译时生成代码。Java 注解是接口的一种特殊实现，程序可以通过反射来获取指定程序元素的Annotion对象，然后使用该对象来获取注解里面的元数据。</p>

<h3>注解的用法</h3>

<p>注解的使用是非常简洁明了的，Java 注解的基本语法是使用“@”符号来定义一个注解，然后在这个符号后面跟上注解的名字，并在这个名字的后面添加一个括号，括号中是这个注解所需要的参数列表。Java 注解是接口的一种特殊实现，因此注解的定义方式类似于接口的定义方式。Java 注解可以分为三种类型：标记注解、单值注解和完整注解。标记注解没有成员变量，只有一个标记作用；单值注解有一个成员变量；完整注解有多个成员变量。</p>

<h3>内置注解</h3>

<p>Java内置了一些注解，相信写过代码或者看过代码的人都对此非常的了解，因为在代码中是非常非常的常见的。</p>

<ul>
<li>@Override - 用于类的方法上，标记该方法要覆写基类（包括接口）的方法。编译器会对标记的方法作签名检查是否符合覆写规则。</li>
<li>@Deprecated - 可以标记类，成员变量和成员方法为过时的方法，编译器会对调用这些类，成员或者方法给出警告（Compile warnings）。</li>
<li>@SuppressWarnings - 可以用在类和方法上，强制忽略编译警告，即阻止编译器发出编译警告。后面需要加括号，里面传入字符串或者字符串数组代表要忽略的警告类型。</li>
<li>@FunctionalInterface - 这是在Java 8版本中引入的，用在接口上，标记接口是一个函数式接口（即只有一个方法的接口，可以直接用一个lambda来作为接口的实例）。</li>
<li>＠SafeVarargs - 用于方法和构造方法上，断言varargs参数（即可变长参数）会被安全地使用。比如涉及泛型的可变长参数会有『unchecked』警告，加了@SafeVarargs时编译器不会再给出『unchecked』警告。</li>
</ul>


<p>通过这些内置注解可以了解注解的类型和特点，并掌握注解的使用方法，这是学习自定义注解，即注解高级玩法的基础。</p>

<h2>理解注解</h2>

<p>可以发现注解并不直接对其修饰的代码产生影响，它是为代码提供额外的信息，它是代码的元数据，注解与代码一起构成了编译器的完整输入，编译器借助注解可以生成并得到最终完整的代码。</p>

<p>注解本身无论是使用还是定义都相对直观和简洁，非常容易理解，因为注解本身就是一种元数据，提供一种标记或者额外的数据。重点在于注解的处理，这是注解功能发挥作用的地方也就是注解功能逻辑实现的地方。</p>

<h3>元编程</h3>

<p>注解是程序的元数据，所以这属于元编程范畴。<a href="https://en.wikipedia.org/wiki/Metaprogramming">元编程Metaprogramming</a>也即是以代码为操作目标和目标输出的编程范式，元编程是生产力工具，可以减少重复代码，大大的提高代码开发效率。大多数通用编程语言都支持元编程，像C/C++语言中的宏，Java中的注解，反射和动态代理，大Python中的装饰器（Decorators装饰器是高阶函数对函数进行操作）和元类（Metaclasses，对类进行操作可理解为类的模板）等等都是元编程。</p>

<p>优秀的框架（Spring）和领域驱动开发（DDD）都是元编程的典型应用。</p>

<p>关于Java的元编程，推荐这两篇文章：</p>

<ul>
<li><a href="https://jyjsjd.github.io/java/java-meta-programming/">Java元编程和热更新技术总结</a></li>
<li><a href="https://tech.youzan.com/java-metaprograming/">Java元编程及其应用</a></li>
</ul>


<h2>注解的分类</h2>

<p>注解是向编译器提供额外信息的一种元编程机制，那么依据机制的简单到复杂，可以把注解分为5个类型：</p>

<h3>标记注解（Marker Annotations）</h3>

<p>最简单的注解，对于某个<strong>声明进行标记</strong>，编译器会对被标记的声明进行检查和处理。如@Override和@Deprecated。</p>

<h3>单值注解（Single Value Annotations）</h3>

<p>需要给注解传递<strong>一个参数且只有一个参数</strong>，如@SuppressWarnings(&ldquo;unchecked&rdquo;)。</p>

<h3>全值注解（Full Annotations）</h3>

<p>需要给注解传递很多参数（多个键值对），如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="nd">@Test</span><span class="o">(</span><span class="n">owner</span><span class="o">=</span><span class="s">&quot;Paul&quot;</span><span class="o">,</span> <span class="n">values</span><span class="o">=</span><span class="s">&quot;Class Greeks&quot;</span><span class="o">)</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">testSomeMethod</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>类型注解（Type Annotations）</h3>

<p>可以用在<strong>类型被声明</strong>的地方，比如方法返回值，方法的参数声明等，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">public</span> <span class="nd">@NonNull</span> <span class="n">String</span> <span class="nf">transform</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="n">String</span> <span class="n">source</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>重复注解（Repeating Annotations）</h3>

<p>常规的注解在同一个地方只能出现一次，但重复注解可以在同一个地方出现多次，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="nd">@Words</span><span class="o">(</span><span class="n">word</span><span class="o">=</span><span class="s">&quot;Hello&quot;</span><span class="o">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="o">)</span>
</span><span class='line'><span class="nd">@Words</span><span class="o">(</span><span class="n">word</span><span class="o">=</span><span class="s">&quot;World&quot;</span><span class="o">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">2</span><span class="o">)</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">method</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>自定义注解</h2>

<p>注解的使用是非常的直观和简洁的，无论是内置注解还是各种框架定义好了的注解，使用起来那是相当的香。但这远远不够，因为注解最大的威力在于元编程，比如代码操作和代码生成，这是减少重复劳动（重复代码）和提供开发效率的大杀器。所以我们必须学会高级玩法，即自定义注解。</p>

<h3>元注解</h3>

<p>元注解，也即定义注解时所需要的注解。这有点类似于<a href="https://www.geeksforgeeks.org/bootstrapping-in-compiler-design/">编译器自举</a>，语言本身定义了一个最基础的注解，在其基础之上可以扩展出更多的注解，而注解的处理是通过反射，只要知道一些特殊的标记就可以了，其余的都是逻辑。</p>

<h4>@Inherited</h4>

<p>默认情况下，在基类中使用的注解是不会被子类继承的，如果注解本身标记有@Inherited，那么注解就会出现在被使用的继承体系中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="nd">@Inherited</span>
</span><span class='line'><span class="nd">@Target</span><span class="o">(</span><span class="n">ElementType</span><span class="o">.</span><span class="na">TYPE</span><span class="o">)</span>
</span><span class='line'><span class="nd">@Retention</span><span class="o">(</span><span class="n">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
</span><span class='line'><span class="kd">public</span> <span class="nd">@interface</span> <span class="n">Company</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">String</span> <span class="nf">name</span><span class="o">()</span> <span class="k">default</span> <span class="s">&quot;ABC&quot;</span><span class="o">;</span>
</span><span class='line'>    <span class="n">String</span> <span class="nf">city</span><span class="o">()</span> <span class="k">default</span> <span class="s">&quot;xyz&quot;</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@Company</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Employee</span> <span class="o">{</span> <span class="o">..</span> <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Manager</span> <span class="kd">extends</span> <span class="n">Employee</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个&#127792;中，如果把@Inherited从注解Company中去掉，那么给类Employee加的注解在其子类Manager中就不会得到继承。大部分时候定义注解时都要加上@Inherited标记。</p>

<h4>@Documented</h4>

<p>使用了@Documented标记的注解可以出现在文档中（JavaDocs）。</p>

<h4>@Repeatable</h4>

<p>对应着可重复的注解，指定着可以在哪些标识符上面重复注解。</p>

<h4>@Target</h4>

<p>指定注解可以作用于<strong>何种标识符</strong>，如果不指定则可以使用于<strong>任何标识符即任何程序元素</strong>。可选的选项有：</p>

<ul>
<li>ElementType.ANNOTATION&#95;TYPE - 可以用于其他的注解上面</li>
<li>ElementType.CONSTRUCTOR - 可以用于构造方法上面</li>
<li>ElementType.FIELD - 可以用于成员变量上面</li>
<li>ElementType.LOCAL&#95;VARIABLE - 可以用于方法的本地变量（栈内变量）</li>
<li>ElementType.METHOD - 可以用于方法上面</li>
<li>ElementType.PACKAGE - 可以用于包（package）上面。</li>
<li>ElementType.PARAMETER - 可以用于方法的参数上面。</li>
<li>ElementType.TYPE - 可以用于类型声明的地方（即类，接口和枚举的声明）。</li>
</ul>


<p>可以指定一个@Target(ElementType.METHOD)或者多个目标@Target({ElementType.FIELD, ElementType.LOCAL&#95;VARIABLE})。</p>

<h4>@Retention</h4>

<p>元注解@Retention用于指定注解保留的生命周期。注解是一种元数据，目标是代码，而代码是有生命周期的：编辑或者说源码时；编译时；运行时。这是程序代码的典型生命周期。而@Retention的作用就是指明注解保留到哪个生命周期。</p>

<ul>
<li>RetentionPolicy.SOURCE - 在源码时保留，编译时就被丢弃，也就是说在编译时并不使用。一般用于编译前的源码处理工具使用，如javadoc，以及代码生成。</li>
<li>RetentionPolicy.CLASS - 编译后仍会保留在class文件中，但在运行时（就是JVM加载class时）被丢弃。主要是在编译时使用（比如生成代码）。</li>
<li>RetentionPolicy.RUNTIME - 保留到运行时，在运行时可以被使用。</li>
</ul>


<h3>自定义注解</h3>

<p>注解可以视为一个特殊的接口，注解的定义就是定义一个接口，而每个接口就是其实现。注解的处理器利用反射获取注解接口的类型信息，再结合注解提供的数据就生成接口的实现代码。这就是注解的工作机制。</p>

<p>用@interface就可以声明一个自定义注解，通用的格式是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="o">[</span><span class="n">Access</span> <span class="n">Modifier</span><span class="o">]</span> <span class="nd">@interface</span> <span class="o">&lt;</span><span class="n">Annotation</span> <span class="n">name</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="n">Type</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">Method</span> <span class="n">name</span><span class="o">&gt;()</span> <span class="o">[</span><span class="k">default</span> <span class="n">value</span><span class="o">];</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到注解本质上是一种接口，但它有一些具体的限制规则：</p>

<ul>
<li>注解的方法不能有参数和异常签名（throws）</li>
<li>方法的返回值不受限制，可以是任意类型</li>
<li>方法的默认返回值是可选的（即可以有，也可以没有）</li>
<li>定义注解时可以使用元注解，这种套娃机制可以实现更为复杂和更为强大的注解</li>
</ul>


<p>看一个完整自定义注解的&#127792;</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="nd">@Documented</span>
</span><span class='line'><span class="nd">@Inherited</span>
</span><span class='line'><span class="nd">@Target</span><span class="o">(</span><span class="n">ElementType</span><span class="o">.</span><span class="na">METHOD</span><span class="o">)</span>
</span><span class='line'><span class="nd">@Retention</span><span class="o">(</span><span class="n">RetentionPolicy</span><span class="o">.</span><span class="na">RUNTIME</span><span class="o">)</span>
</span><span class='line'><span class="kd">public</span> <span class="nd">@interface</span> <span class="n">MethodInfo</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">String</span> <span class="nf">author</span><span class="o">()</span> <span class="k">default</span> <span class="s">&quot;Kevin&quot;</span><span class="o">;</span>
</span><span class='line'>    <span class="n">String</span> <span class="nf">date</span><span class="o">();</span>
</span><span class='line'>    <span class="kt">int</span> <span class="nf">revision</span><span class="o">()</span> <span class="n">dfeault</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>    <span class="n">String</span> <span class="nf">comments</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>运行时注解解析</h2>

<p>定义了注解后，就可以在代码中使用了，但这还没完，还需要对注解进行解析和处理。在运行时需要用到反射来解析注解，反射API中有专门用于处理注解的API：</p>

<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AnnotatedElement.html">AnnotatedElement</a> - 这是反射接口处理注解的核心类型，它是反射类型Method，Field和Constructor的基类，通过它的方法来获取注解<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Annotation.html">Annotation</a>实例。</li>
<li>用<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Annotation.html">Annotation</a>来处理具体的注解</li>
</ul>


<p>注意注意，注解的解析和处理用的是反射，所以注解定义时要用RententionPolicy.RUNTIME，否则用反射是拿不到注解信息的，因为反射是在运行时（Runtime）。下面我们会用一个完整的实例来学习如何处理自定义注解。</p>

<h3>完整示&#127792;</h3>

<p>至此注解的概念的原理都清楚了，融会贯通一下，用一个完整的&#127792;来展示自定义注解。</p>

<h4>Step 1：定义注解</h4>

<p>直接复用前面定义的@MethodInfo。</p>

<h4>Step 2：使用注解</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MethodInfoExample</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="nd">@MethodInfo</span><span class="o">(</span><span class="n">author</span> <span class="o">=</span> <span class="s">&quot;Alex&quot;</span><span class="o">,</span> <span class="n">comments</span> <span class="o">=</span> <span class="s">&quot;Main method&quot;</span><span class="o">,</span> <span class="n">date</span> <span class="o">=</span> <span class="s">&quot;Mar 29 2024&quot;</span><span class="o">,</span> <span class="n">revision</span> <span class="o">=</span> <span class="mi">2</span><span class="o">)</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="s">&quot;toString method Overridden&quot;</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Deprecated</span>
</span><span class='line'>    <span class="nd">@MethodInfo</span><span class="o">(</span><span class="n">comments</span> <span class="o">=</span> <span class="s">&quot;Deprecated method&quot;</span><span class="o">,</span> <span class="n">date</span> <span class="o">=</span> <span class="s">&quot;Mar 30, 2024&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">oldMethod</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Old method out!&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@SuppressWarnings</span><span class="o">({</span><span class="s">&quot;unchecked&quot;</span><span class="o">,</span> <span class="s">&quot;deprecation&quot;</span><span class="o">})</span>
</span><span class='line'>    <span class="nd">@MethodInfo</span><span class="o">(</span><span class="n">author</span> <span class="o">=</span> <span class="s">&quot;Paul&quot;</span><span class="o">,</span> <span class="n">comments</span> <span class="o">=</span> <span class="s">&quot;Main method&quot;</span><span class="o">,</span> <span class="n">date</span> <span class="o">=</span> <span class="s">&quot;Mar 31 2024&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">genericsMethod</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">FileNotFoundException</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">List</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ArrayList</span><span class="o">();</span>
</span><span class='line'>        <span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;Xyz&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="n">oldMethod</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Step 3：解析注解</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MethodInfoParsing</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">Method</span><span class="o">[]</span> <span class="n">methods</span> <span class="o">=</span> <span class="n">MethodInfoParsing</span><span class="o">.</span><span class="na">class</span>
</span><span class='line'>                    <span class="o">.</span><span class="na">getClassLoader</span><span class="o">().</span><span class="na">loadClass</span><span class="o">(</span><span class="s">&quot;MethodInfoExample&quot;</span><span class="o">).</span><span class="na">getDeclaredMethods</span><span class="o">();</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="n">Method</span> <span class="n">method</span> <span class="o">:</span> <span class="n">methods</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(!</span><span class="n">method</span><span class="o">.</span><span class="na">isAnnotationPresent</span><span class="o">(</span><span class="n">MethodInfo</span><span class="o">.</span><span class="na">class</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>                    <span class="k">continue</span><span class="o">;</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>                <span class="k">for</span> <span class="o">(</span><span class="n">Annotation</span> <span class="n">annotation</span> <span class="o">:</span> <span class="n">method</span><span class="o">.</span><span class="na">getDeclaredAnnotations</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Annotation &quot;</span> <span class="o">+</span> <span class="n">annotation</span> <span class="o">+</span> <span class="s">&quot; on method &quot;</span> <span class="o">+</span> <span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>                <span class="n">MethodInfo</span> <span class="n">info</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="na">getAnnotation</span><span class="o">(</span><span class="n">MethodInfo</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="s">&quot;Paul&quot;</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">info</span><span class="o">.</span><span class="na">author</span><span class="o">()))</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;From Pauls: &quot;</span> <span class="o">+</span> <span class="n">method</span><span class="o">.</span><span class="na">getName</span><span class="o">());</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ClassNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>注解处理器</h2>

<p>在运行时解析注解比较简单，较麻烦的是在编译时（Compile time）处理注解，这时的处理又特别的关键，因为像代码生成是在这一阶段做的。编译时处理注解需要用到<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Processor.html">Annotation Processor</a>。</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2020/03/AnnotationProcessor-twitter.png" alt="" /></p>

<p>一个典型的Annotation processor实现过程：</p>

<ul>
<li>实现一个Processor，通常通过继承<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/AbstractProcessor.html">AbstractProcess</a>。</li>
<li>覆写方法process来处理注解，这里面过滤出想要处理的注解，然后用<a href="https://github.com/square/javapoet">JavaWriter</a>来生成Java文件（或者粗暴的用PrintWriter也可以）。</li>
<li>注册实现好的Processor给编译器：可以通过编译命令javac -processor来指定处理器；也可以把处理器打成jar包然后当成库添加到项目中，因为编译器在开始编译前会自动的去搜索注解和注解处理器。</li>
</ul>


<p>可以参考如下文章来详细了解Annotation processor的实现过程：</p>

<ul>
<li><a href="https://www.baeldung.com/java-annotation-processing-builder">Java Annotation Processing and Creating a Builder</a></li>
<li><a href="https://hannesdorfmann.com/annotation-processing/annotationprocessing101/">Annotation Processing 101</a></li>
<li><a href="https://www.race604.com/annotation-processing/">Java注解处理器</a></li>
<li><a href="https://tomgregory.com/gradle/annotation-processors-in-gradle-with-the-annotationprocessor-dependency-configuration/">Annotation Processors in Gradle with the annotationProcessor Dependency Configuration</a></li>
<li><a href="https://kdrozd.pl/custom-annotation-processor/">Custom Annotation Processor</a></li>
</ul>


<p>这里是一系列<a href="https://github.com/gunnarmorling/awesome-annotation-processing">优秀的Annotation processor案例</a>。</p>

<h2>为什么用注解</h2>

<p>注解是非常优雅的元编程方式，可以生成代码（减少重复），降低耦合。比如著名的单元测试框架JUnit，在其4.0时（即JUnit4）就用注解替代了继承。在JUnit3要这样写测试：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="c1">// Using JUnit 3.0</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClassTest</span> <span class="kd">extends</span> <span class="n">TestCase</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">MyClass</span> <span class="n">instance</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">setup</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">super</span><span class="o">.</span><span class="na">setup</span><span class="o">();</span>
</span><span class='line'>        <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">MyClass</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">tearDown</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">super</span><span class="o">.</span><span class="na">tearDown</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testSomeMethod</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">assertNotNull</span><span class="o">(</span><span class="n">instance</span><span class="o">);</span>
</span><span class='line'>        <span class="n">assertEquals</span><span class="o">(</span><span class="s">&quot;Hello, world&quot;</span><span class="o">,</span> <span class="n">instance</span><span class="o">.</span><span class="na">say</span><span class="o">());</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是类MyClass的一个简单的测试用例。在JUnit4使用了注解后，就可以这样写了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="c1">// Using JUnit 4.0</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyClassTest</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">MyClass</span> <span class="n">instance</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Before</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">setup</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">MyClass</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@After</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">tearDown</span><span class="o">()</span> <span class="o">{}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Test</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">testSomeMethod</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">assertNotNull</span><span class="o">(</span><span class="n">instance</span><span class="o">);</span>
</span><span class='line'>        <span class="n">assertEquals</span><span class="o">(</span><span class="s">&quot;Hello, world&quot;</span><span class="o">,</span> <span class="n">instance</span><span class="o">.</span><span class="na">say</span><span class="o">());</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过注解@Before标记测试前准备和@After测试后清理，用@Test标记测试用例，也不用继承TestCase了，整体测试代码非常的优雅。这就是注解的作用。</p>

<h2>什么时候用注解</h2>

<p>注解的本质是程序的元数据，为编译器提供的代码以外的额外的数据。注解是优雅的元编程的一种方式，可以减少重复的代码，提升开发效率。所以每当需要减少重复代码，生成代码，提供元数据时就要用注解来实现。特别是特定领域的问题，非常适合大量使用注解，如数据库（Room），网络请求（Retrofit），单元测试（JUnit）等等。并且注解的大部分应用都是在编译时生成代码，也不影响性能，所以可劲造儿，尽可能的使用注解吧。</p>

<h2>总结</h2>

<p>本文从注解的基础用法出发，再到核心概念的阐述，最后用一个自定义注解的例子展示如何用注解来实现元编程，全方位的阐述了注解。相信通过此文对注解的理解会更上一个层次。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/annotations/index.html">Lesson: Annotations</a></li>
<li><a href="https://www.geeksforgeeks.org/annotations-in-java/">Annotations in Java</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/java-annotations">Java Annotations</a></li>
<li><a href="https://www.baeldung.com/java-custom-annotation">Creating a Custom Annotation in Java</a></li>
<li><a href="https://reflectoring.io/java-annotation-processing/">An Introduction to Annotations and Annotation Processing in Java</a></li>
<li><a href="https://www.cnblogs.com/ziph/p/13056092.html">教科书级讲解，秒懂最详细Java的注解</a></li>
<li><a href="https://pdai.tech/md/java/basic/java-basic-x-annotation.html#google_vignette">Java 基础 - 注解机制详解</a></li>
<li><a href="https://blog.csdn.net/qq_20009015/article/details/106038023">java注解的本质以及注解的底层实现原理</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Deep Dive Into Kotlin Generics Runtime]]></title>
    <link href="http://toughcoder.net/blog/2024/03/16/deep-dive-into-kotlin-generics-runtime/"/>
    <updated>2024-03-16T19:16:00+08:00</updated>
    <id>http://toughcoder.net/blog/2024/03/16/deep-dive-into-kotlin-generics-runtime</id>
    <content type="html"><![CDATA[<p>通过前面的学习，对Kotlin的泛型已经有了比较全面的了解了，泛型的目的是让通用的代码更加的类型安全。现在我们离写出类型安全的泛型代码还差最后一块拼图，那就是泛型的类型擦除，今天就来深入地学习一下运行时的泛型，彻底的弄懂类型擦除的前因后果，并学会如何在运行时做类型检查和类型转换，以期完成拼图掌握泛型，写出类型安全的通用代码。</p>

<p><a href="http://toughcoder.net/blog/2024/03/16/deep-dive-into-kotlin-generics-runtime/"><img src="https://global-uploads.webflow.com/618fa90c201104b94458e1fb/61978c1b9e0bf52082dabe92_Kotlin-Generics.png" title="auto auto" ></a></p>

<!-- more -->


<p>关于泛型话题的一系列文章：</p>

<ul>
<li><a href="http://toughcoder.net/blog/2024/03/04/kotlin-generics-made-easy/">这回就好好聊聊Kotlin的泛型</a></li>
<li><a href="http://toughcoder.net/blog/2024/03/10/java-generics-made-easy/">深入浅出Java泛型</a></li>
<li><a href="http://toughcoder.net/blog/2024/03/13/kotlin-generics-revisited/">Kotlin Generics Revisited</a></li>
<li><a href="http://toughcoder.net/blog/2024/03/16/deep-dive-into-kotlin-generics-runtime/">Dive deep into Kotlin type erasure</a></li>
</ul>


<h2>泛型类型擦除（Type erasure）</h2>

<p>泛型的类型安全性（包括类型检查type check，和类型转换type casting）都是由编译器在编译时做的，为了保持在JVM上的兼容性，编译器在保障完类型安全性后会对泛型类型进行<a href="https://en.wikipedia.org/wiki/Type_erasure">擦除（Type erasure）</a>。在运行时泛型类型的实例并不包含其类型信息，也就是说它不知道具体的类型参数，比如Foo&lt;Bar&gt;和Foo&lt;Baz?&gt;都被擦除成了Foo&lt;&#42;&gt;，在虚拟机（JVM）来看，它们的类型是一样的。</p>

<p>因为泛型Foo&lt;T&gt;的类型参数T会<strong>被擦除（erased）</strong>，所以与类型参数相关的类型操作（类型检查is T和类型转换as T）都是不允许的。</p>

<h2>可行的类型检查和转换</h2>

<p>虽然类型参数会被擦除，但并不是说对泛型完全不能进行类型操作。</p>

<h3>星号类型操作</h3>

<p>因为所有泛型会被擦除成为星号无界通配Foo&lt;&#42;&gt;，它相当于Foo&lt;Any?&gt;，是所有Foo泛型的基类，类型参数Any?是根基类，所以可以进行类型检查和类型转换：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">something</span> <span class="k">is</span> <span class="n">List</span><span class="p">&lt;*&gt;)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">something</span><span class="p">.</span><span class="n">forEach</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span> <span class="c1">// 元素被视为Any?类型</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>针对星号通配做类型操作，类型参数会被视为Any?。但其实这种类型操作没有任何意义，毕竟Any是根基类，任何类当成Any都是没有问题的。</p>

<h3>完全已知具体的类型参数时</h3>

<p>另外一种情况就是，整个方法的上下文中已经完全知道了具体的类型参数时，不涉及泛型类型时，也是可以进行类型操作的，说的比较绕，我们来看一个&#127792;：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">handleStrings</span><span class="p">(</span><span class="n">list</span><span class="p">:</span> <span class="n">MutableList</span><span class="p">&lt;</span><span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">list</span> <span class="k">is</span> <span class="n">ArrayList</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// list is smart-cast to ArrayList&lt;String&gt;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个方法并不涉及泛型类型，已经知道了具体的类型参数是String，所以类型操作也是可行的，因为编译器知道具体的类型，能对类型进行检查 保证是类型安全的。并且因为具体类型参数String可以推断出来，所以&lt;String&gt;是可以省略的。</p>

<h2>未检查的转换</h2>

<p>当编译器能推断出具体的类型时，进行类型转换就是安全的，这就是被检查的转型（checked cast），如上面的&#127792;。</p>

<p>如果无法推断出类型时，比如涉及泛型类型T时，因为类型会被擦除，编译器不知道具体的类型，这时as T或者as List&lt;T&gt;都是不安全的，编译器会报错，这就是未检查转型（unchecked cast）。</p>

<p>但如果能确信是类型转换是安全的，可以用注解&#64;Suppress(&ldquo;UNCHECKED_CAST&rdquo;)来忽略。</p>

<h2>用关键reified修饰inline泛型函数</h2>

<p><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.Y0Gq_pPe6TUb1g0oEN_51wHaEb?rs=1&amp;pid=ImgDetMain" alt="" /></p>

<p>要想能够对泛型类型参数T做类型操作，只能是在用关键字reified修饰了的inline泛型函数，在这种函数体内可以对泛型类型参数T做类型操作，&#127792;如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">inline</span> <span class="k">fun</span> <span class="err">&lt;</span><span class="nf">reified</span> <span class="n">A</span><span class="p">,</span> <span class="k">reified</span> <span class="n">B</span><span class="p">&gt;</span> <span class="n">Pair</span><span class="p">&lt;*,</span> <span class="p">*&gt;.</span><span class="n">asPairOf</span><span class="p">():</span> <span class="n">Pair</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">&gt;?</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="p">!</span><span class="k">is</span> <span class="n">A</span> <span class="p">||</span> <span class="n">second</span> <span class="p">!</span><span class="k">is</span> <span class="n">B</span><span class="p">)</span> <span class="k">return</span> <span class="k">null</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">first</span> <span class="k">as</span> <span class="n">A</span> <span class="n">to</span> <span class="n">second</span> <span class="k">as</span> <span class="n">B</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="py">somePair</span><span class="p">:</span> <span class="n">Pair</span><span class="p">&lt;</span><span class="n">Any</span><span class="p">?,</span> <span class="n">Any</span><span class="p">?&gt;</span> <span class="p">=</span> <span class="s">&quot;items&quot;</span> <span class="n">to</span> <span class="n">listOf</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="py">stringToSomething</span> <span class="p">=</span> <span class="n">somePair</span><span class="p">.</span><span class="n">asPairOf</span><span class="p">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Any</span><span class="p">&gt;()</span>
</span><span class='line'><span class="k">val</span> <span class="py">stringToInt</span> <span class="p">=</span> <span class="n">somePair</span><span class="p">.</span><span class="n">asPairOf</span><span class="p">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Int</span><span class="p">&gt;()</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是关键字reified能够让针对类型参数T的操作得到编译器的检查，保证安全，是允许的。但是对于泛型仍是不允许的，&#127792;如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">inline</span> <span class="k">fun</span> <span class="err">&lt;</span><span class="nf">reified</span> <span class="n">T</span><span class="p">&gt;</span> <span class="n">List</span><span class="p">&lt;*&gt;.</span><span class="n">asListOfType</span><span class="p">():</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;?</span> <span class="p">=</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">all</span> <span class="p">{</span> <span class="n">it</span> <span class="k">is</span> <span class="n">T</span> <span class="p">})</span>
</span><span class='line'>        <span class="n">@Suppress</span><span class="p">(</span><span class="s">&quot;UNCHECKED_CAST&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="k">this</span> <span class="k">as</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="k">else</span>
</span><span class='line'>        <span class="k">null</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个inline泛型函数用关键字reified修饰了，因此针对类型参数T是允许类型检查类型转换，如第2行是允许的。但泛型仍是不合法，如第4行，这时可以用上一小节提到的注解&#64;Suppress(&ldquo;UNCHECKED_CAST&rdquo;)来忽略未检查类型转换。</p>

<h2>inline和reified的原理</h2>

<p>对于一些泛型工厂方法，就非常适合使用inline和reified，以保证转换为类型参数（因为工厂方法最终肯定要as T）是允许的且是安全的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">inline</span> <span class="k">fun</span> <span class="err">&lt;</span><span class="nf">reified</span> <span class="n">T</span><span class="p">&gt;</span> <span class="n">logger</span><span class="p">():</span> <span class="n">Logger</span> <span class="p">=</span> <span class="n">LoggerFactory</span><span class="p">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">T</span><span class="o">::</span><span class="k">class</span><span class="p">.</span><span class="n">java</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">User</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">private</span> <span class="k">val</span> <span class="py">log</span> <span class="p">=</span> <span class="n">logger</span><span class="p">&lt;</span><span class="n">User</span><span class="p">&gt;()</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>关键字reified其实也没有什么神秘的，因为这是inline函数，这种函数是会把函数体嵌入到任何调用它的地方（call site），而每个调用泛型函数的地方必然会有明确的具体类型参数，那么编译器就知道了具体的类型能保证类型安全（checked cast）。上面的工厂方法在调用时就会大概变成酱紫：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">User</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">private</span> <span class="k">val</span> <span class="py">log</span> <span class="p">=</span> <span class="n">LoggerFactory</span><span class="p">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">User</span><span class="p">.</span><span class="k">class</span><span class="p">.</span><span class="n">java</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这时其实在函数体内已经知道了具体的类型参数User，编译器能够进行类型检查，所以是安全的。</p>

<h2>总结</h2>

<p>本文深入的讨论一下运行时泛型的一些特性，泛型类型在运行时会被擦除，无法做泛型相关的类型操作，因为编译器无法保证其类型安全。例外就是在用reified修饰的inline函数中可以对类型参数T做类型操作，但泛型类型（带尖括号的&lt;T&gt;）仍是会被擦除，可以用注解&#64;Suppress(&ldquo;UNCHECKED_CAST&rdquo;)来忽略unchecked cast。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/generics.html#type-erasure">Type erasure</a></li>
<li><a href="https://www.baeldung.com/kotlin/generics#generics-at-runtime">6. Generics at Runtime</a></li>
<li><a href="https://www.baeldung.com/kotlin/type-erased-list-array-conversion">How to Convert a Type-Erased List to an Array in Kotlin</a></li>
<li><a href="https://discuss.kotlinlang.org/t/type-erasure/14519">Discussion about Type Erasure</a></li>
<li><a href="https://stackoverflow.com/questions/42916801/how-does-erasure-work-in-kotlin">How does erasure work in Kotlin?</a></li>
<li><a href="https://workingdev.net/2018/09/reified-generics-in-kotlin.html">Reified Generics in Kotlin</a></li>
<li><a href="https://duongnt.com/type-erasure-reified/">Type erasure and reified in Kotlin</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin Generics Revisited]]></title>
    <link href="http://toughcoder.net/blog/2024/03/13/kotlin-generics-revisited/"/>
    <updated>2024-03-13T22:33:20+08:00</updated>
    <id>http://toughcoder.net/blog/2024/03/13/kotlin-generics-revisited</id>
    <content type="html"><![CDATA[<p>在前面的文章中学习Kotlin泛型的基本知识，并且又用了一篇文章来复习了一下Java语言的泛型，有了这些基础我们就可以继续深入的学习Kotlin的泛型了。看它是如何解决Java泛型的遗留问题，再学习一下它的高级特性，最后再总结泛型的最佳实践。</p>

<p><a href="http://toughcoder.net/blog/2024/03/13/kotlin-generics-revisited/"><img src="https://koenig-media.raywenderlich.com/uploads/2019/09/Generics-feature.png" width="480" height="480"></a></p>

<!-- more -->


<p>本文是作为前面文章的延续和深化，为了更好的阅读效果，建议先回顾一下<a href="http://toughcoder.net/blog/2024/03/10/java-generics-made-easy/">Java泛型基础</a>，和<a href="http://toughcoder.net/blog/2024/03/04/kotlin-generics-made-easy/">Kotlin泛型基础</a>。</p>

<h2>泛型类型参数界限（Upper bounds）</h2>

<p>我们在前面讲解<a href="http://toughcoder.net/blog/2024/03/10/java-generics-made-easy/">Java泛型基础</a>时提到了在声明泛型的时候是可以指定类型参数的界限的，比如用Caculator&lt;T extends Number&gt;可以指定在使用时可以传入的类型参数要是Number或者Number的子类。</p>

<p>在Kotlin中也是可以指定泛型类型参数的界限的，也是用<strong>继承符号:来表示</strong>，&#127792;如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">Calculator</span><span class="p">&lt;</span><span class="n">T</span> <span class="p">:</span> <span class="n">Number</span><span class="p">&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>与Java一样，也可以指定多个界限，要<strong>使用where关键字</strong>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">Calculator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">Number</span><span class="p">,</span> <span class="n">T</span> <span class="p">:</span> <span class="n">Runnable</span><span class="p">,</span> <span class="n">T</span> <span class="p">:</span> <span class="n">Closable</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="err">&lt;</span><span class="nf">T</span><span class="p">&gt;</span> <span class="n">copyWhenGreater</span><span class="p">(</span><span class="n">list</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;,</span> <span class="n">threshold</span><span class="p">:</span> <span class="n">T</span><span class="p">):</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span>
</span><span class='line'>    <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">CharSequence</span><span class="p">,</span>
</span><span class='line'>          <span class="n">T</span> <span class="p">:</span> <span class="n">Comparable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">list</span><span class="p">.</span><span class="n">filter</span> <span class="p">{</span> <span class="n">it</span> <span class="p">&gt;</span> <span class="n">threshold</span> <span class="p">}.</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">toString</span><span class="p">()</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意：面向对象的继承体系是基类在上面，子类在下面，所以上界的意思是以某个类A为根的继承树，这颗树都可以当成A来使用；下界的意思是从根A到以某个类C为止的一个路径，这个路径上都是C的基类，C都可以当成它们来用。</p>

<p><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/20221025185149/Hierarchical-Inheritance-in-Java.jpg" alt="" /></p>

<h2>更优雅的泛型变化(Variance)</h2>

<p>与Java一样，Kotlin的泛型也是不可变的Invariant，比如虽然String是Any的子类，但List&lt;String&gt;并不是List&lt;Any&gt;的子类。泛型变化Variance的目的就是让两个泛型产生与类型参数协同的变化，比如类型C是类A的子类，那么使用它的泛型&lt;C&gt;也应该是&lt;A&gt;的子类，能使用&lt;A&gt;的方，传入&lt;C&gt;一定要是允许的，并要能够是安全的。</p>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.HRZ3CHxJfgk_hG9T11siDQHaD4?rs=1&amp;pid=ImgDetMain" alt="" /></p>

<h3>使用点变化（Use-site variance）</h3>

<p>基于面向对象的基本特性，只有向上转型(Upcasting)是安全的。具体就分为两种场景，从一个生产者中读取对象时，只要生产者的输出声明的T是基类（T是一个上限），无论生产者输出的是T还是它的子类，对于使用者来说（当T来用）就是安全的。这时生产者的泛型要能够进行协变，在Java中用上界界限通配符&lt;? extends T&gt;来进行协变，具体使用时传入T的子类的泛型也是合法的；同理，向一个消费者中写数据时，消费者声明为T的某个基类（这时T是一个下限），向其传入T，对于使用者来说就是安全的。这时消费者的泛型要能进行逆变，在Java中使用下界界限通配符&lt;? super T&gt;来进行逆变，具体使用时传T的基类的泛型也是合法的。</p>

<p>Kotlin中提供了非常容易理解和使用的<strong>关键字out来进行协变（covariance）和in进行逆变（contravariance）</strong>，可以实现Java中的界限通配符一样的功效。Java界限通配符的规则是<strong>PECS（Producer Extends Consumer Super）</strong>，out正好可以更形象的描述一个生产者，而in可以更形象的描述一个消费者，所以Kotlin的关键字更容易理解和记忆。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">open</span> <span class="k">class</span> <span class="nc">Animal</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Dog</span> <span class="p">:</span> <span class="n">Animal</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">MyList</span><span class="p">&lt;</span><span class="n">E</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">fun</span> <span class="nf">addAll</span><span class="p">(</span><span class="n">from</span><span class="p">:</span> <span class="n">MyList</span><span class="p">&lt;</span><span class="k">out</span> <span class="n">E</span><span class="p">&gt;)</span> <span class="p">{}</span>
</span><span class='line'>    <span class="k">fun</span> <span class="nf">getAll</span><span class="p">(</span><span class="n">to</span><span class="p">:</span> <span class="n">MyList</span><span class="p">&lt;</span><span class="k">in</span> <span class="n">E</span><span class="p">&gt;)</span> <span class="p">{}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">animals</span> <span class="p">=</span> <span class="n">MyList</span><span class="p">&lt;</span><span class="n">Animal</span><span class="p">&gt;()</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">dogs</span> <span class="p">=</span> <span class="n">MyList</span><span class="p">&lt;</span><span class="n">Dog</span><span class="p">&gt;()</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">animals</span><span class="p">.</span><span class="n">addAll</span><span class="p">(</span><span class="n">dogs</span><span class="p">)</span>
</span><span class='line'>    <span class="n">dogs</span><span class="p">.</span><span class="n">getAll</span><span class="p">(</span><span class="n">animals</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这种泛型变化是发生在调用者调用时，因此也叫做『使用点变化』(Use-site variance)。在Kotlin中也被称作<strong>类型映射</strong>，因为相当于是用&lt;out T&gt;把T给映射成了一个T的生产者，只能调用其get方法；用&lt;in T&gt;映射成一个T的消费者，只能调用set方法。并且呢，对于同一个函数中既有生产者和消费者时，in和out只写一个就行了，&#127792;如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">copy</span><span class="p">(</span><span class="n">from</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="k">out</span> <span class="n">Any</span><span class="p">&gt;,</span> <span class="n">to</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">Any</span><span class="p">&gt;)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>声明点变化（Declaration-site variance）</h3>

<p>Java界限通配符的一个大问题是只能用于方法的参数但不能是返回值，也就是只能是『Use-site variance』。但in和out没有这个限制，因此它们可以用于返回值。只要给类和接口的泛型声明为out或者in就能让类型参数在其所有的方法产生variance，这就是『declaration-site variance』。</p>

<p>但是要遵守out进行协变，也就是<strong>说out是用于生产者</strong>的，只能作为方法的返回值，或者保证不能set，&#127792;如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">interface</span> <span class="n">Source</span><span class="p">&lt;</span><span class="k">out</span> <span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">fun</span> <span class="nf">nextT</span><span class="p">():</span> <span class="n">T</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="nf">demo</span><span class="p">(</span><span class="n">strs</span><span class="p">:</span> <span class="n">Source</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">objects</span><span class="p">:</span> <span class="n">Source</span><span class="p">&lt;</span><span class="n">Any</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">strs</span> <span class="c1">// This is OK, since T is an out-parameter</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>同理，<strong>用in进行逆变，只能用于消费者</strong>，只能作为方法的参数，或者保证不get，&#127792;如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">interface</span> <span class="n">Comparable</span><span class="p">&lt;</span><span class="k">in</span> <span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">operator</span> <span class="k">fun</span> <span class="nf">compareTo</span><span class="p">(</span><span class="n">other</span><span class="p">:</span> <span class="n">T</span><span class="p">):</span> <span class="n">Int</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="nf">demo</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Comparable</span><span class="p">&lt;</span><span class="n">Number</span><span class="p">&gt;)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">x</span><span class="p">.</span><span class="n">compareTo</span><span class="p">(</span><span class="m">1.0</span><span class="p">)</span> <span class="c1">// 1.0 has type Double, which is a subtype of Number</span>
</span><span class='line'>    <span class="c1">// Thus, you can assign x to a variable of type Comparable&lt;Double&gt;</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">y</span><span class="p">:</span> <span class="n">Comparable</span><span class="p">&lt;</span><span class="n">Double</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">x</span> <span class="c1">// OK!</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>小结一下，Kotlin使用关键字in和out让泛型的协变和逆变变得容易理解得多了，因为它们能够非常清楚的表达出消费者和生产者，只需要记住一个泛型的生产者要用out来修饰，而一个泛型的消费者要用in来修饰就不会出错，这比Java中的界限通配符简单太多了。</p>

<h2>星号映射(Star projections)</h2>

<p>除了use-site variance是一种类型映射外，还有星号映射。首先来说<strong>星号是无界泛型</strong>，也就是说不指定具体的类型参数，意思是任意类型的泛型，换句话说Foo&lt;&#42;&gt;是任何其他泛型的基类（Foo&lt;String&gt;, Foo&lt;Number&gt;等）。但根据不同的上下文，Foo&lt;&#42;&gt;会映射为不同的具体意义的泛型类型：</p>

<ul>
<li>对于Foo&lt;out T : TUpper&gt;，这里的T是一个受上界TUpper限制的协变类型参数，那么Foo&lt;&#42;&gt;就等同于Foo&lt;out TUpper&gt;。</li>
<li>对于Foo&lt;in T&gt;，这里T是逆变类型参数，Foo&lt;&#42;&gt;等同于Foo&lt;in Nothing&gt;。这意思是无法向Foo&lt;&#42;&gt;中写。</li>
<li>对于Foot&lt;T : TUpper&gt;，这里T是一个被上界TUpper限定的不可变类型参数，那么Foo&lt;&#42;&gt;，在读时（作为生产者）等同于Foo&lt;out TUpper&gt;，在写时（作为消费者）等同于Foo&lt;in Nothing&gt;。</li>
</ul>


<p>如果泛型是多元的，那么每个类型参数可以进行不同的映射。比如说如果一个类型是这样声明的interface Function&lt;in T, out U&gt;，那么会有这样的映射：</p>

<ul>
<li>Function&lt;&#42;, String&gt; 意思是Function&lt;in Nothing, String&gt;</li>
<li>Function&lt;Int, &#42;&gt; 意思是Function&lt;Int, out Any?&gt;</li>
<li>Function&lt;&#42;, &#42;&gt; 意思是Function&lt;in Nothing, out Any?&gt;</li>
</ul>


<p>换句话来理解，就是当不指定具体的类型参数，用星星就代表着不知道具体的类型参数，那么视具体的上下文不同星号会被解释不同的意思。不过这玩意儿可读性较差，除非必不得已，否则还是能不用就用它。</p>

<p>注意：在Kotlin中，<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/">根基类是Any</a>它是所有其他类的基类（the root of Kotlin class hierarchy）。而<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-nothing.html">Nothing</a>是不能有实例的类，可以用它来表示不存在的对象（a value that never exists）。比如说，如果 一个函数返回值类型声明为Nothing，那它就不会返回（always throws an exception），注意是<strong>不会返回（never returns）</strong>，并不是没有返回值，没有返回值要<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/">声明为类型Unit</a>。</p>

<h2>绝不为空类型（Definitely non-null type）</h2>

<p>为了保持对Java的互通性，Kotlin还支持把泛型类型参数声明为『绝不为空类型』definitely non-null type。可以<strong>用&amp; Any来声明</strong>，如&lt;T &amp; Any&gt;来声明T是『绝不为空类型』。</p>

<p>这是为了保持与Java的相互调用，有些Java的类和接口是用<strong>注解&#64;NonNull修饰的</strong>，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Game</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">T</span> <span class="nf">save</span><span class="o">(</span><span class="n">T</span> <span class="n">x</span><span class="o">)</span> <span class="o">{}</span>
</span><span class='line'>    <span class="nd">@NotNull</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">T</span> <span class="nf">load</span><span class="o">(</span><span class="nd">@NotNull</span> <span class="n">T</span> <span class="n">x</span><span class="o">)</span> <span class="o">{}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这时在Kotlin里面就要用到<strong>『绝不为空类型』&amp; Any来声明泛型</strong>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">interface</span> <span class="n">ArcadeGame</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">Game</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">override</span> <span class="k">fun</span> <span class="nf">save</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T1</span><span class="p">):</span> <span class="n">T1</span>
</span><span class='line'>    <span class="c1">// T1 is definitely non-nullable</span>
</span><span class='line'>    <span class="k">override</span> <span class="k">fun</span> <span class="nf">load</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T1</span> <span class="p">&amp;</span> <span class="n">Any</span><span class="p">):</span> <span class="n">T1</span> <span class="p">&amp;</span> <span class="n">Any</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，在纯Kotlin代码中是用不到这个特性的。只有当涉及Java的&#64; NonNull时才需要『绝不为空类型』。</p>

<h2>下划线操作符</h2>

<p>当编译器能推断出泛型的类型参数时是可以省略掉类型参数的，比如val names = listOf(&ldquo;James&rdquo;, &ldquo;Kevin&rdquo;)，这里得到的类型是List&lt;String&gt;，但我们并没有显示的指定类型参数，这是因为编译器从listOf的参数中就能推断出类型参数是String，所以listOf的返回就是List&lt;String&gt;。</p>

<p>但有些时候，泛型类型太复杂了，没有办法推断出所有的类型，比如有多元泛型参数时。但根据指定的某一个参数，可以推断出剩余的参数时，这时就没有办法完全省略类型参数，剩余的参数却又可以推断出来，写了又浪费。这时就可以用下划线操作符来代表那些可以推断出来的参数。这里的下划线用法跟在lambda中，用下划线替代不使用的参数是一样的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">abstract</span> <span class="k">class</span> <span class="nc">SomeClass</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">abstract</span> <span class="k">fun</span> <span class="nf">execute</span><span class="p">()</span> <span class="p">:</span> <span class="n">T</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">SomeImplementation</span> <span class="p">:</span> <span class="n">SomeClass</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">override</span> <span class="k">fun</span> <span class="nf">execute</span><span class="p">():</span> <span class="n">String</span> <span class="p">=</span> <span class="s">&quot;Test&quot;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">OtherImplementation</span> <span class="p">:</span> <span class="n">SomeClass</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">override</span> <span class="k">fun</span> <span class="nf">execute</span><span class="p">():</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">42</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">object</span> <span class="nc">Runner</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">inline</span> <span class="k">fun</span> <span class="err">&lt;</span><span class="nf">reified</span> <span class="n">S</span><span class="p">:</span> <span class="n">SomeClass</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;,</span> <span class="n">T</span><span class="p">&gt;</span> <span class="n">run</span><span class="p">()</span> <span class="p">:</span> <span class="n">T</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">S</span><span class="o">::</span><span class="k">class</span><span class="p">.</span><span class="n">java</span><span class="p">.</span><span class="n">getDeclaredConstructor</span><span class="p">().</span><span class="n">newInstance</span><span class="p">().</span><span class="n">execute</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// T is inferred as String because SomeImplementation derives from SomeClass&lt;String&gt;</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">s</span> <span class="p">=</span> <span class="n">Runner</span><span class="p">.</span><span class="n">run</span><span class="p">&lt;</span><span class="n">SomeImplementation</span><span class="p">,</span> <span class="n">_</span><span class="p">&gt;()</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="n">s</span> <span class="p">==</span> <span class="s">&quot;Test&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// T is inferred as Int because OtherImplementation derives from SomeClass&lt;Int&gt;</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">n</span> <span class="p">=</span> <span class="n">Runner</span><span class="p">.</span><span class="n">run</span><span class="p">&lt;</span><span class="n">OtherImplementation</span><span class="p">,</span> <span class="n">_</span><span class="p">&gt;()</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="p">==</span> <span class="m">42</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/generics.html">Generics: in, out, where</a></li>
<li><a href="https://www.gyata.ai/kotlin/kotlin-generics/">Kotlin Generics</a></li>
<li><a href="https://blog.logrocket.com/understanding-kotlin-generics/">Understanding Kotlin generics</a></li>
<li><a href="https://sebhastian.com/kotlin-generics/#google_vignette">Kotlin generics explained with code examples</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/143380842">深入解析Kotlin 泛型</a></li>
<li><a href="https://juejin.cn/post/6959859571242303495">Kotlin（六）深入理解Kotlin泛型</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入浅出Java泛型]]></title>
    <link href="http://toughcoder.net/blog/2024/03/10/java-generics-made-easy/"/>
    <updated>2024-03-10T20:43:03+08:00</updated>
    <id>http://toughcoder.net/blog/2024/03/10/java-generics-made-easy</id>
    <content type="html"><![CDATA[<blockquote><p>温故而知新，可以为师矣！</p></blockquote>

<p>在<a href="http://toughcoder.net/blog/2024/03/04/kotlin-generics-made-easy/">前面的一篇文章</a>中学习了Kotlin的泛型知识，但总感觉还不够深入，因为一些深入的话题和高级的特性并未有讲清楚。但在继续深入之前还是有必要重温一下Java的泛型知识，这是因为Kotlin是基于JVM的语言，并且与Java关系暧昧，它可以与Java混合使用，可以相互调用，在某种程度上讲Kotlin可以视为Java的一种『方言』。所以，我们先回顾Java的泛型，夯实基础，并弄清楚Java泛型遗留了哪些问题，然后再看看Kotlin是如何解决这些问题的。</p>

<p><a href="http://toughcoder.net/blog/2024/03/10/java-generics-made-easy/"><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.wupG3f0_pqm_144x4Zw6ZwHaD4?rs=1&pid=ImgDetMain" title="auto auto" ></a></p>

<!-- more -->


<h2>基础使用方法</h2>

<p>还是要从基本的使用方法来谈起。</p>

<p><a href="https://docs.oracle.com/javase/tutorial/java/generics/index.html">泛型（Generics）</a>就是在类或者方法定义的时候并不指定其操作数据的具体类型，而是用一个虚拟的名字<strong>&lt;T&gt;</strong>代替，类的使用者或者方法的调用在使用时提供具体的类型，以达到类和方法能对所有的类型都能使用的目录。可以把泛型理解为参数化，也就是说定义的时候把其操作的数据类型视为一种参数，由使用者在使用时具体指定（创建对象时或者调用方法时），因此泛型也可以称为<strong>参数化类型</strong>。有3个地方可以使用泛型，<strong>类，接口和方法</strong>，接下分别来看一下具体如何使用。</p>

<h3>泛型类</h3>

<p>泛型类，也即参数化类型的类，是最为常见的一种泛型的使用方式。这些类可以视为<a href="https://en.wikipedia.org/wiki/Metaclass">元类</a>，它会操作另一个类型，比如存储或者加工，类本身的实现重点在于如何操作，而对于这个『另一个类型』具体是什么，并不关心。这时就可以用泛型，在定义类的时候并不指定具体的类型，而是用一个虚拟的类型来代替，由类的使用者在使用的时候来指定具体的类型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">class</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">E</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里ArrayList是一个容器，可以以线性的方式来存储任意其他类型，具体是啥其实ArrayList并不关心，所以这里用泛型，E就是参数化类型，代指某一个类型。使用时需要提供具体的类型，可以Integer，String，或者定义好了的任何一种类型(Class)：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">players</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span><span class='line'><span class="n">players</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;James&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">players</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;Kevin&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;#1 is &quot;</span> <span class="o">+</span> <span class="n">players</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
</span><span class='line'><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;#2 is &quot;</span> <span class="o">+</span> <span class="n">players</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
</span><span class='line'><span class="c1">// #1 is James</span>
</span><span class='line'><span class="c1">// #2 is Kevin</span>
</span></code></pre></td></tr></table></div></figure>


<p>小结 一下，泛型是为了增强代码的复用，定义时用<strong>尖括号&lt;&gt;表示的参数化类型Parameterized type</strong>，拼接在类名字的后面，使用时再指定具体的类型。并且，当编译器能推断出参数类型时，可以用<strong>钻石符号(Diamond operator)&lt;&gt;来</strong>省略参数类型名字。</p>

<h3>泛型接口</h3>

<p>泛型可以用于接口的声明，与类一样，把类型参数化即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">interface</span> <span class="nc">Consumer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">consume</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>泛型方法</h3>

<p>除了类和接口，<a href="https://docs.oracle.com/javase/tutorial/extra/generics/methods.html">方法也可以使用泛型</a>，把用<strong>尖括号表示的参数化类型&lt;T&gt;放</strong>在方法的返回类型之前就可以了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">fromArrayToList</span><span class="o">(</span><span class="n">T</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">String</span><span class="o">[]</span> <span class="n">names</span> <span class="o">=</span> <span class="o">{</span><span class="s">&quot;James&quot;</span><span class="o">,</span> <span class="s">&quot;Kevin&quot;</span><span class="o">,</span> <span class="s">&quot;Harden&quot;</span><span class="o">};</span>
</span><span class='line'><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">players</span> <span class="o">=</span> <span class="n">fromArrayToList</span><span class="o">(</span><span class="n">names</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是，因为Java的方法必须声明在类里面，但这并不意味着方法的泛型一定要与类的类型参数一致，当然了，方法可以直接使用类的类型参数，也可以自己再定义一个另外的类型参数，注意这是方法自定义的泛型与其所在的类的泛型没啥关系，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">class</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">transfer</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，为了可读性方法自定义的泛型最好不要与其所在类使用的泛型一样，比如类用T，方法也用T，虽然这是可以的，因为这个替代类型名字随便取为啥非要弄的容易混淆呢？</p>

<h3>多元类型参数</h3>

<p>类型参数可以有多个，用不同的代号名字并用逗号隔开就可以了，就比如哈希表：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">class</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>就是一个使用二元类型参数的类。</p>

<p>以上就是泛型的基础使用方法。</p>

<h2>理解泛型的本质</h2>

<p>通过以上的介绍可以得出泛型的根本目的是加强复用，让类和方法不受类型的限制，可以应用于任何类型，并且是以一种安全的方式，受到编译器的支持。</p>

<h3>泛型的优势</h3>

<p>如果不用泛型，想要让类或者方法通用，即对任何对象都能生效，那只能把其参数的类型声明为顶层基类Object，然后在某些地方做手动类型转换（type casting）。很明显，这非常容易出错，并且非常的不安全， 一旦某些地方忘记了检查，就会有运行时的类型转换异常（ClassCastException）。</p>

<p>使用了泛型后，编译器会帮助我们对类型对待检查和自动转换，在完成代码复用的同时，又能保证运行时的类型安全，减少运行时的类型转换错误，所以我们应该尽可能多的使用泛型。</p>

<h3>命名规范</h3>

<p>虽然说参数化类型可以用任何名字，但为了可读性还是要遵从比较流行的规范：</p>

<ul>
<li>T 类型</li>
<li>E 集合里面元素的类型</li>
<li>K 哈希表，或者其他有键值的键的类型</li>
<li>V 哈希表中值的类型</li>
<li>N 数字类型</li>
<li>S, U, V等多元参数类型时使用</li>
</ul>


<h2>泛型高级特性</h2>

<h3>指定参数类型的界限</h3>

<p>泛型在定义的时候用虚拟的类型表示参数化的类型，使用的时候传入具体的类型，但有些时候需要<strong>对可以传入的具体类型做限制</strong>，这时可以用类似&lt;T extends Number&gt;来<strong>限定可以使用的类型参数的界限（上界）</strong>，这里的Number可以是任意已知的类型。并且与类的多继承规则一样，这里可以指定多个类型上限，但只能有一个类且要放在最前面后面的只能是接口，用&amp;来连接，如&lt;T extends ClassA &amp; IfaceB &amp; IfaceC&gt;，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">class</span> <span class="nc">Calculator</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">Number</span> <span class="o">&amp;</span> <span class="n">Runnable</span> <span class="o">&amp;</span> <span class="n">Closeable</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">T</span> <span class="n">operand</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">S</span> <span class="kd">extends</span> <span class="n">Number</span> <span class="o">&amp;</span> <span class="n">Runnable</span> <span class="o">&amp;</span> <span class="n">Comparable</span><span class="o">&gt;</span> <span class="n">S</span> <span class="nf">plus</span><span class="o">(</span><span class="n">S</span> <span class="n">a</span><span class="o">,</span> <span class="n">S</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>指定泛型中参数型的限制在实际项目中是很有用的，它可以加强代码复用，把一些公共的代码从子类中抽出来，比如像一个列表中的Item有不同的数据类型和不同的布局样式，常规的多态是说让每个子类去实现自己的布局样式，但如果共性太多，这时就可以在创建一个泛型的类或者方法来做，而这个类或者方法就可以指定基类作为泛型类型界限。这样可以加强代码的类型安全，避免调用者传入代码不认识和不能处理的参数类型。</p>

<h3>界限通配符来实现协变与逆变</h3>

<p><a href="https://www.howtogeek.com/devops/what-is-covariance-and-contravariance-in-programming/">协变与逆变</a>是用来描述对象的继承关系在使用这些对象为类型参数的泛型中的联系。比如说Dog是Animal的子类，那么使用这两个类型为参数的泛型对象之间的关系应该是会么呢？如List&lt;Dog&gt;是否也是List&lt;Animal&gt;的子类？Java中的泛型是不可变的Invariant，即泛型对象之间的关系与它们的类型参数之间的关系是没有联系的，即List&lt;Dog&gt;与List&lt;Animal&gt;之间没关系。</p>

<p><img src="https://i1.wp.com/techvidvan.com/tutorials/wp-content/uploads/sites/2/2020/05/Types-of-Java-Wildcards.jpg?fit=802%2C420&amp;ssl=1" alt="" /></p>

<p>不可变Invariant是为了类型安全，编译器检查泛型类型参数必须严格匹配，但在有些时候会带来极大的不方便，因为面向对象的两大基本特性继承和多态保证了子类对象可以当作其基类使用，换句话说能用Animal的地方，放一个Dog对象应该完全合法。但因为泛型不可变，一个声明为addAll(List&lt;Animal&gt;)的方法，是没有办法传入List&lt;Dog&gt;的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{}</span>
</span><span class='line'><span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="n">Animal</span> <span class="o">{}</span>
</span><span class='line'><span class="kd">class</span> <span class="nc">List</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="n">E</span><span class="o">[]</span> <span class="n">items</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addAll</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="n">E</span> <span class="n">x</span> <span class="o">:</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">items</span><span class="o">[</span><span class="n">size</span><span class="o">++]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">getAll</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="n">E</span> <span class="n">e</span> <span class="o">:</span> <span class="n">items</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">b</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span> <span class="n">animals</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="o">&lt;&gt;();</span>
</span><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span> <span class="n">dogs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="o">&lt;&gt;();</span>
</span><span class='line'><span class="n">animals</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">dogs</span><span class="o">);</span> <span class="c1">// compile error</span>
</span><span class='line'><span class="n">dogs</span><span class="o">.</span><span class="na">getAll</span><span class="o">(</span><span class="n">animals</span><span class="o">);</span> <span class="c1">// compile error</span>
</span></code></pre></td></tr></table></div></figure>


<p>但这其实是很安全的，因为我们把Dog从列表中取出，然后当作Animal使用，这是向上转型(Upcasting)是完全安全的。但因为泛型是不可变的，编译器必须要保证泛型的类型参数必须完全一致，因此会给出编译错误，但这显然不方便，会让泛型的作用大打折扣。再比如Object是所有对象的基类，但是当把Object作为类型参数时，这个泛型并不是其他泛型的父类，如List&lt;String&gt;并不是List&lt;Object&gt;的子类。</p>

<p>实际上这里需要的是协变(Covariance)与逆变(Contravariance)，也就是让使用类型参数的泛型具有其类型参数一致的继承关系，就要用到界限通配符(Bounded Wildcards)。一共有三种：</p>

<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/generics/upperBounded.html">上界进行协变Covariant</a>，参数化类型&lt;? extends T&gt;表示可以是以T为基类的任意子类类型，当然也包括T本身，泛型&lt;S&gt;会变成&lt;? extends T&gt;的子类，如果S是T的子类。</li>
<li><a href="https://docs.oracle.com/javase/tutorial/java/generics/lowerBounded.html">下界进行逆变Contravariant</a>，参数化类型&lt;? super T&gt;表示可以是T或者T的基类类型泛型&lt;B&gt;会变成&lt;? super T&gt;的基类，如果B是T的基类。</li>
<li><a href="https://docs.oracle.com/javase/tutorial/java/generics/unboundedWildcards.html">无界</a>，参数化类型&lt;?&gt;表示可以是任何类型，可以理解为泛型里的顶层基类（就像Object之于其他对象一样）。</li>
</ul>


<p>使用界限通配符来修改上述&#127792;：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">class</span> <span class="nc">List</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addAll</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">getAll</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span> <span class="n">animals</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="o">&lt;&gt;();</span>
</span><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span> <span class="n">dogs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="o">&lt;&gt;();</span>
</span><span class='line'><span class="n">animals</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">dogs</span><span class="o">);</span> <span class="c1">// 0 warnings, 0 errors!</span>
</span><span class='line'><span class="n">dogs</span><span class="o">.</span><span class="na">getAll</span><span class="o">(</span><span class="n">animals</span><span class="o">);</span> <span class="c1">// 0 warnings, 0 errors!</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要特别注意的是<strong>界限通配符解决的问题是协变与逆变</strong>，也即<strong>让两个泛型之间的关系与其参数类型保持一致</strong>，但具体的这一对类型参数仍可以是任何类型。这与前一小节讨论的参数类型界限是完全不同的概念，不是同一码事儿，参数类型界限是限制使用泛型时可以传入的类型的限制。</p>

<p>界限通配符解决的是泛型之间的关系，每当<strong>需要进行<a href="https://docs.oracle.com/javase/tutorial/java/generics/wildcardGuidelines.html">协变与逆变的时候</a>就需要用到通配符</strong>，以让代码更通用更合理。还需要特别注意的<strong>界限通配符只能用于方法的参数</strong>，大神Joshua Bloch在《Effective Java》中<a href="https://stackoverflow.com/questions/2723397/what-is-pecs-producer-extends-consumer-super">给出的建议</a>是<strong>通配符要用于方法的输入泛型参数，如果参数是生产者用extends（即从里面读取对象），如果是消费者用super（即往里面写数据）</strong>。</p>

<h2>运行时的<a href="https://docs.oracle.com/javase/tutorial/java/generics/genTypes.html">泛型擦除</a></h2>

<p>泛型是为了以类型安全的方式实现代码复用，但是在Java 1.5版本时引入的，为了保持向后兼容性，编译器会对泛型的类型信息进行擦除(type erasure)，使其变成常规的对象，这样运行时（JVM）就不用处理新增加的类型了，保持了字节码的兼容性。比如List&lt;String&gt;与List&lt;Integer&gt;在运行时都变成了List对象，JVM并不知道它们的参数类型。泛型的类型参数检查，以及类型的转换都是发生在编译时，是编译器做的事情。</p>

<p>泛型擦除带来的一个问题就是泛型不能使用类型判断符(instanceof)，以及不能进行强制类型转换，比如这样写是不合法的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="c1">// Compile error: Illegal   generic type for instanceof</span>
</span><span class='line'><span class="k">if</span> <span class="o">(</span><span class="n">list</span> <span class="k">instanceof</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">List</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span> <span class="n">ld</span> <span class="o">=</span> <span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;)</span> <span class="n">list</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>很显然，反射(Reflect)是完全没有办法用泛型的，因为反射是在运行时，这时泛型都被擦除了。如果非要使用泛型，必须要把其类型参数的Class传入作为参数（也即把T的具体参数的class对象传入如String.class），以此来区分不同的泛型，可以参考<a href="https://www.baeldung.com/java-factory-pattern-generics">泛型工厂方法的实现</a>。</p>

<h2>Java泛型的问题</h2>

<h3>泛型不支持基础类型</h3>

<p>Java为了效率和兼容性保留了基础数据类型，如int, boolean, float，但它们并不是对象。而泛型的类型参数必须是对象，因此基础类型是不能用在泛型上面的，比如不能用List&lt;int&gt;，而只能用List&lt;Integer&gt;，好在有自动装箱autoboxinng和拆箱unboxing，所以List&lt;Integer&gt;也可以可以直接用于整数类型的。</p>

<h3>泛型不支持数组</h3>

<p>这里的意思是指不能用泛型去声明数组，比如List&lt;String&gt;[]，这是不允许的。（不要搞混混淆了，数组当作泛型的类型参数是完全可以的，如List&lt;int[]&gt;，因为数组是一个类型。）</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.codetab.org/tutorial/java-generics/introduction/">Java Generics Tutorial</a></li>
<li><a href="https://www.baeldung.com/java-generics">The Basics of Java Generics</a></li>
<li><a href="https://blogs.oracle.com/javamagazine/post/understanding-java-generics-part-1-principles-and-fundamentals">Understanding Java generics, Part 1: Principles and fundamentals</a></li>
<li><a href="https://blogs.oracle.com/javamagazine/post/understanding-java-generics-part-2-the-hard-part">Understanding Java generics, Part 2: The hard part</a></li>
<li><a href="https://www.geeksforgeeks.org/generics-in-java/">Generics in Java</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/java-generics-example-method-class-interface">Java Generics Example Tutorial - Generic Method, Class, Interface</a></li>
<li><a href="https://pdai.tech/md/java/basic/java-basic-x-generic.html">Java 基础 - 泛型机制详解</a></li>
<li><a href="https://juejin.cn/post/7249913673215836218">一文搞懂 java 泛型，也有可能搞不懂，毕竟讲得太全面了</a></li>
<li><a href="https://www.cnblogs.com/coprince/p/8603492.html">java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一</a></li>
<li><a href="https://betterprogramming.pub/a-deep-dive-into-java-wildcards-covariance-4d807a65f02">A Deep Dive Into Java Wildcards — Covariance</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[这回就好好聊聊Kotlin的泛型]]></title>
    <link href="http://toughcoder.net/blog/2024/03/04/kotlin-generics-made-easy/"/>
    <updated>2024-03-04T22:51:58+08:00</updated>
    <id>http://toughcoder.net/blog/2024/03/04/kotlin-generics-made-easy</id>
    <content type="html"><![CDATA[<p>泛型(Generics)是静态强类型编程语言中非常强大的特性，可以极大的加强代码的复用，并增强类型安全，减少运行时的类型转换错误。在这篇文章就来详细的学习一下Kotlin中对泛型的支持情况，并学会写出类型安全的可复用代码。</p>

<p><a href="http://toughcoder.net/blog/2024/03/04/kotlin-generics-made-easy/"><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.bl_F0aycuia6QRYMt4AOfQHaFc?rs=1&pid=ImgDetMain" title="auto auto" ></a></p>

<!-- more -->


<h2>泛型基础</h2>

<p>泛型的本质就是能够创建参数化的对象和函数，以实现复用。比如说，我们最熟悉的集合List，它是<strong>与具体类型无关</strong>的数据结构，或者叫做对象容器。列表List的重点在于可扩展长度，但里面具体的对象类型并不是重点，只要是一个对象就可以了。假如没有泛型，可能就要写很多重复的代码，比如字符串列表StringList，数字列表NumberList，等等。用泛型，只<strong>用一个参数化</strong>的List就可以了，用尖括号<strong>&lt;&gt;</strong>来表示参数化。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">names</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="s">&quot;James&quot;</span><span class="p">,</span> <span class="s">&quot;Kevin&quot;</span><span class="p">,</span> <span class="s">&quot;Harden&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">val</span> <span class="py">rebounds</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">14</span><span class="p">,</span> <span class="m">7</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>泛型有两种形式，一种是对类进行参数化如List<String>，一种是对函数进行参数化，如max<Int>()。</p>

<h3>参数化的类</h3>

<p>声明方式就是在声明类的时候在类的名字后面用尖括号<strong>&lt;&gt;</strong>来带上一个类型参数，然后在内部就可以当成一个类型来使用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">Box</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">t</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">var</span> <span class="py">value</span> <span class="p">=</span> <span class="n">t</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这就创建了一个参数化的容器，它可以持有任何指定类型的对象：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">box</span><span class="p">:</span> <span class="n">Box</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Box</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;(</span><span class="m">1</span><span class="p">)</span>
</span><span class='line'><span class="k">val</span> <span class="py">case</span><span class="p">:</span> <span class="n">Box</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Box</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;(</span><span class="s">&quot;Coat&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>参数化的函数</h3>

<p>除了参数化的类以外，还可以创建参数化的函数，在函数名字的前面用尖括号<strong>&lt;&gt;</strong>来声明泛型，然后在参数列表以及函数体内就可以当作类型来使用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="err">&lt;</span><span class="nf">T</span><span class="p">&gt;</span> <span class="n">singleTonList</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">T</span><span class="p">):</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>调用的时候指定一下具体的类型就可以了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">l</span> <span class="p">=</span> <span class="n">singletonList</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;(</span><span class="m">3</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>注意：</strong>Kotlin语言有强大的类型推断能力，但凡编译器能够推断出类型时，类型的声明都可以省略掉。对于泛型更是如此，比如说，这样写都是合法的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">names</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="s">&quot;James&quot;</span><span class="p">,</span> <span class="s">&quot;Kevin&quot;</span><span class="p">,</span> <span class="s">&quot;Harden&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">val</span> <span class="py">rebounds</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">14</span><span class="p">,</span> <span class="m">7</span><span class="p">)</span>
</span><span class='line'><span class="k">val</span> <span class="py">l</span> <span class="p">=</span> <span class="n">singletonList</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>通常情况下，<strong>声明</strong>，<strong>定义</strong>和<strong>赋值</strong>三个地方，只要有一个地方能够让编译器知道具体的类型就够了，其他地方都可以把类型的声明省略掉。</p>

<h2>泛型的本质与优点</h2>

<p>假如不使用泛型，又想写出比较通用的类和函数，唯一可行的方法就是使用通用基类Any当作参数，在Kotlin中Any是所有对象的基类，比如，说想实现一个列表：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">AnyList</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">fun</span> <span class="nf">add</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span>
</span><span class='line'>  <span class="k">fun</span> <span class="nf">get</span><span class="p">(</span><span class="n">idx</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Any</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样写可以，但它有很大的问题，就是不能保证类型安全：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">list</span> <span class="p">=</span> <span class="n">AnyList</span><span class="p">()</span>
</span><span class='line'><span class="n">list</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;James&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">list</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="m">13</span><span class="p">)</span>
</span><span class='line'><span class="k">val</span> <span class="py">e</span> <span class="p">=</span> <span class="p">(</span><span class="n">Int</span><span class="p">)</span> <span class="n">list</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>一方面我们需要自己进行强行类型转换，但也无法保证你取出来的对象类型与期望的是一致的，更无法保证调用者往里面添加什么对象，因为任何Any的子类都可以让代码通过编译，但在运行时极容易发生类型转换异常ClassCastException。</p>

<p>但用泛型就能很好的解决这个问题，可以得出泛型的优点：</p>

<ol>
<li>不需要做类型转换，编译器会根据指定的具体类型自动做类型转换</li>
<li>类型安全，编译器会帮助做检查，传给泛型的对象必须具有一致的类型，且是指定的类型</li>
<li>保障了运行时的类型安全，因为编译器在编译时做好了检查，所以不会发生运行时的类型错误</li>
</ol>


<p>因此，凡是有需要针对 类型复用的地方，都应该用泛型来实现类型参数化。</p>

<h2>关键字out和关键字in</h2>

<p>大部分情况下，只要给类型和函数加上参数化的类型就够了，但有时候有些复杂情况需要处理。</p>

<h3>协变与逆变</h3>

<p><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98">协变与逆变Covariance and Contravariance</a>是用来描述具有父子继承关系的简单类型，在通过参数化的方法构造出来的更复杂的类型之间是否能保持父子关系的术语。</p>

<p>比如Dog是Animal的子类，根据继承和多态，Dog可以用在任何声明为Animal的语句和表达式中。<strong>变型Variance</strong>指的就是根据已知的父子关系Dog和Animal，如何来确定由它们构成的更复杂类型如List&lt;Dog&gt;和List&lt;Animal&gt;之间的关系？</p>

<p>常规泛型是<strong>不可变的Invariant</strong>，也就是说复杂类型之间的关系与它们具体的参数化类型之间是没有关系的，如List&lt;Dog&gt;并不是List&lt;Animal&gt;，它们之间没有任何关系，不能把List&lt;Dog&gt;当成是List&lt;Animal&gt;，虽然Dog可以被当作Animal。</p>

<p>不可变Invariant有时候会带来不方便，比如说，集合通常都有addAll方法来批量的把对象加入到集合中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">fun</span> <span class="nf">addAll</span><span class="p">(</span><span class="n">from</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="k">in</span> <span class="n">from</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">val</span> <span class="py">objs</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Any</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">emptyList</span><span class="p">()</span>
</span><span class='line'><span class="k">val</span> <span class="py">names</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="s">&quot;James&quot;</span><span class="p">,</span> <span class="s">&quot;Kevin&quot;</span><span class="p">,</span> <span class="s">&quot;Harden&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">objs</span><span class="p">.</span><span class="n">addAll</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="c1">// No go, compile error</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是参数化列表集合，先创建一个具体类型为Any的列表，然后尝试把一个String列表添加到Any列表中，其实这么做是完全安全的，因为String对象是完全可以当作其基类Any来使用的，但泛型的不可变性阻止了我们这么做。</p>

<p>这时就需要<strong>协变</strong>与<strong>逆变</strong>了，也就是通过一定的方法让复杂类型的行为与其参数化类型之间进行协同。</p>

<p><img src="https://phpstan.org/covariance-contravariance.4483af19.png" alt="" /></p>

<h3>关键字out进行协变</h3>

<p>使用out关键能够让泛型进行协变。比如上面例子理想的情况应该是，只要能当作T的类型，都应该能用在addAll中，换句话说把T的子类的列表也应该能够支持，即objs.addAll(names)应该能正常编译并正常运行。使用关键out即可达到这样的效果：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">List</span><span class="p">&lt;</span><span class="k">out</span> <span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">fun</span> <span class="nf">addAll</span><span class="p">(</span><span class="n">from</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="k">in</span> <span class="n">from</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">val</span> <span class="py">objs</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Any</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">emptyList</span><span class="p">()</span>
</span><span class='line'><span class="k">val</span> <span class="py">names</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="s">&quot;James&quot;</span><span class="p">,</span> <span class="s">&quot;Kevin&quot;</span><span class="p">,</span> <span class="s">&quot;Harden&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">objs</span><span class="p">.</span><span class="n">addAll</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="c1">// Okay</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的泛型参数from: List<out T>其实是一个生产者，它生产类型为T的对象，所以这里用out来修饰，产出的对象是T或者是T的子类都是会是合法的。或者说当我们想把一个子类的泛型赋给父类的泛型时，就需要对泛型声明为out，以进行协变。</p>

<p><strong>注意：</strong>关键字out与Java泛型中的extend通配符的作用是一样的，指定参数的上限，生产者产生的对象都会向上转型(upcast)为基类，所以需要指定一个上限。</p>

<p>与之相对的，还有in逆变。</p>

<h3>关键字in进行逆变</h3>

<p>有时候情况是相反的，也就是说我们持有的是父类的泛型，但 我们想把它赋给其子类的泛型，这时就可以用in进行逆变。而且必须注意in只能用在消费者中，也就是说是在真实消费对象，为什么呢？其实这里真实发生的是向下转型(downcast)&ndash;把父类的对象赋给子类的引用上面，而向下转型不一定保证是安全的。所以，必须是在真实消费这个对象的地方，只有是期望的真实对象才能被消费。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">ParameterizedConsumer</span><span class="p">&lt;</span><span class="k">in</span> <span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">fun</span> <span class="nf">toString</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">):</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">value</span><span class="p">.</span><span class="n">toString</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="py">parameterizedConsumer</span> <span class="p">=</span> <span class="n">ParameterizedConsumer</span><span class="p">&lt;</span><span class="n">Number</span><span class="p">&gt;()</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="py">ref</span><span class="p">:</span> <span class="n">ParameterizedConsumer</span><span class="p">&lt;</span><span class="n">Double</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">parameterizedConsumer</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>注意：</strong>关键字in与Java泛型中的super是一样的，指定一个下限，因为在消费对象时会转成T，用T来限制成为下限，那么向下转型(downcast)就是安全的。</p>

<h2>任意类型的泛型</h2>

<p>有些比较简单粗暴的场景，就是单纯的想让任意类型的泛型都可以使用，这时关键字out和关键字in可能都不太合适，因为它们只能用于生产者和消费者场景，用以指定类型上限和类型下限。这时可以用<strong>星号&#42;</strong>来当用泛型参数，以表示任意具体类型的泛型都可以使用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">printArray</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;*&gt;)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">array</span><span class="p">.</span><span class="n">forEach</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="py">array</span> <span class="p">=</span> <span class="n">arrayOf</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">)</span>
</span><span class='line'><span class="n">printArray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>关键字reified</h2>

<h3>运行时泛型擦除</h3>

<p>需要注意的是泛型类型在运行时会被擦除(erased)，也就是说在运行时任何对象都是不带有其泛型类型的，具体点的，就是List&lt;String&gt;和List&lt;Int&gt;在运行时，它们的对象实例是一样的，无法知道它们的具体的泛型参数类型。前面讲的各种规则都是发生在编译时间，编译器帮助检查传入的泛型对象是否符合规划，并进行类型转换。到了运行时，泛型类型会被擦除。(为啥会被擦除呢？因为JVM要保持向后兼容，早期的Java没有泛型，只有原始的类型对象(raw type)，所以后来1.5版本后加入的泛型只有擦除掉变成raw type才能保持兼容。)</p>

<h3>关键字reified</h3>

<p>泛型类型擦除会带来一个问题，就是对于泛型类型对象，无法做类型检查(is T)，无法做类型转换(as T)，因为运行时的对象根本不知道它的泛型类型是什么，这会带来极大的不方便，特别是工厂方法就无法使用泛型了，因为无法做类型检查 和转换。</p>

<p>这时inline再加上关键字reified就能完美的解决问题，它们两个配合起来运行时就能保留泛型类型了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">inline</span> <span class="k">fun</span> <span class="err">&lt;</span><span class="nf">reified</span> <span class="n">T</span><span class="p">&gt;</span> <span class="n">Iterable</span><span class="p">&lt;*&gt;.</span><span class="n">filterIsInstance</span><span class="p">()</span> <span class="p">=</span> <span class="n">filter</span> <span class="p">{</span> <span class="n">it</span> <span class="k">is</span> <span class="n">T</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">&gt;&gt;</span> <span class="k">val</span> <span class="py">set</span> <span class="p">=</span> <span class="n">setOf</span><span class="p">(</span><span class="s">&quot;1984&quot;</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="s">&quot;Brave new world&quot;</span><span class="p">,</span> <span class="m">11</span><span class="p">)</span>
</span><span class='line'><span class="p">&gt;&gt;</span> <span class="n">println</span><span class="p">(</span><span class="k">set</span><span class="p">.</span><span class="n">filterIsInstance</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;())</span>
</span><span class='line'><span class="na">[2, 3, 11]</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到类型判断起来作用了。再看一个泛型工厂方法的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">inline</span> <span class="k">fun</span> <span class="err">&lt;</span><span class="nf">reified</span> <span class="n">T</span><span class="p">&gt;</span> <span class="n">logger</span><span class="p">():</span> <span class="n">Logger</span> <span class="p">=</span> <span class="n">LoggerFactory</span><span class="p">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">T</span><span class="o">::</span><span class="k">class</span><span class="p">.</span><span class="n">java</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">User</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">private</span> <span class="k">val</span> <span class="py">log</span> <span class="p">=</span> <span class="n">logger</span><span class="p">&lt;</span><span class="n">User</span><span class="p">&gt;()</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>练习</h2>

<p>这里强烈推荐谷歌官方给出的关于Kotlin语言中的<a href="https://developer.android.com/codelabs/basic-android-kotlin-compose-generics#0">类型相关的小练习</a>，可以用来巩固加强一下所学的知识。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/generics.html">Generics: in, out, where</a></li>
<li><a href="https://www.geeksforgeeks.org/kotlin-generics/">Kotlin generics</a></li>
<li><a href="https://www.baeldung.com/kotlin/generics">Generics in Kotlin</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32583310">Kotlin 泛型中的 in 和 out</a></li>
<li><a href="https://blog.csdn.net/u011897062/article/details/130832411">Kotlin泛型＜in, out, where＞概念及示例</a></li>
<li><a href="https://rengwuxian.com/kotlin-generics/">Kotlin 的泛型</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一文带你吃透Kotlin类与对象]]></title>
    <link href="http://toughcoder.net/blog/2024/02/26/kotlin-class-made-easy/"/>
    <updated>2024-02-26T21:22:39+08:00</updated>
    <id>http://toughcoder.net/blog/2024/02/26/kotlin-class-made-easy</id>
    <content type="html"><![CDATA[<p>Kotlin是多范式通用编程语言，对面向对象编程(OOP)自然也提供了全方位的支持。通过<a href="http://toughcoder.net/blog/2018/05/17/introduction-to-kotlin-programming-language/">先前一篇文章</a>，学习了使用Kotlin进行基本面向对象编程的方法，本文将在前文基础之上继续深入的学习面向对象编程的高级特性，以能够写出更加符合OO的代码，并能够从容应对一些复杂的OOP场景。</p>

<p><a href="http://toughcoder.net/blog/2024/02/26/kotlin-class-made-easy/"><img src="https://bigknol.com/wp-content/uploads/2023/07/kotlin_class_objects.png" title="auto auto" ></a></p>

<!-- more -->


<h2>注意构造的顺序</h2>

<p>在构造对象过程中，有三个地方可以对成员进行初始化：1）是在<strong>首构造方法（Primary constructor）</strong>；2）是在声明成员的同时进行初始化，或者是在<strong>初始化代码块(init {&hellip;})</strong>中；3）是在<strong>次要构造方法(Secondary constructor)</strong>中。</p>

<p>要注意它们之间的<strong>区别和执行顺序</strong>，首构造方法是最先执行的，但它不能运行代码，只能进行赋值；成员声明和初始化代码块(init {&hellip;})是首构造方法的一部分，因此要先于次要构造方法。次要构造方法是最后执行，并且次要构造方法一定要委托到首构造方法。成员声明和初始化代码块之间则依赖于书写的顺序，从上到下执行。</p>

<p>虽然编译器有它的规则来保障顺序，但为了可读性和可维护性，我们不应该完全依赖编译器。这里建议的方式是：</p>

<ul>
<li>把类的最核心的成员放在首构造方法，如必须要依赖的参数，公开的成员，类型体系中的核心成员等，这些应该直接放在首构造方法中，并按重要的顺序进行声明，这样也能方便进行依赖注入和测试Mock对象替换。</li>
<li>私有成员应该在类中声明，并且在声明时进行初始化，如果无法初始化就标记为延迟初始(late init)。</li>
<li>初始化代码块，应该做一些复杂的初始化过程，或者成员之间有关联的初始化，或者做一些构造完成之后的操作。比如像在ViewModel中，构造之后，可能执行拉取数据，这就非常适合放在init {&hellip;}之中。</li>
<li>不建议使用次要构造方法，可以用<strong>给首构造方法的参数设置默认值</strong>的方式来进行成员参数上的重载。</li>
<li>初始化代码块要放在所有成员声明之后，以保障执行顺序。</li>
</ul>


<p>扩展阅读<a href="https://kotlinlang.org/docs/classes.html">Classes﻿</a>和<a href="https://kotlinlang.org/docs/properties.html">Properties﻿</a>。</p>

<h2>妙用late init</h2>

<p>通常成员的初始化可以在声明时完成，比如像集合或者一些简单的原始类型对象（Int, Float, String等）。但如果初始化过程比较复杂，或者初始值较难获得，这种情况下，就适合标记为<strong>延迟初始化late init</strong>，然后在合适的时机对成员进行初始化（比如系统框架层的回调中，或者依赖注入等等）。使用一个未初始化的late init成员时会抛出一个叫做<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-uninitialized-property-access-exception/">UninitializedPropertyAccessException</a>的异常，可以在使用成员变量前用<a href="https://kotlinlang.org/docs/reflection.html#property-references">.isInitialized</a>来判断成员变量是否初始化过：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="p">.</span><span class="n">isInitialized</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="n">foo</span><span class="p">.</span><span class="n">bar</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以发现，对于Android 开发来说<strong>late init</strong>绝对非常有用，因为对于系统组件，我们无法在其构造方法中进行成员初始化，通常都是在第一个回调(如onCreate)中进行初始化，而这些变量全都应该用late init来标记。</p>

<p>另外，需要注意的是，成员是否有被初始化与成员是否是非法值(如null)并不是同一回事，初始化是第一次对成员对象赋值，赋的什么值(正常对象or null)虚拟机并不关心，但只要有过赋值后变量就初始化过了。因此，<strong>用late init可以帮助减少null检查</strong>。</p>

<p>还需要注意的是，延迟初始化late init与属性委托也不是同一回事，late init通常用于内部私有的成员变量，而属性委托通常用于对外开放的公开成员。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/properties.html">Properties</a>。</p>

<h2>函数式接口</h2>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.aCUdGlN1mIUaSZQXKdceSgHaD4?rs=1&amp;pid=ImgDetMain" alt="" /></p>

<p>接口(interfaces)是更高级别的抽象，专注于行为的抽象，用以实现对象间契约式行为交互。这一部分不打算详细讲解interface的使用，而是重点关注函数式接口(function interface)。Kotlin中的接口与Java 8中的接口是一样的，不再全是抽象方法了，可以有默认方法，也就是对接口的方法添加默认的实现，没有默认实现的方法就是抽象方法了（Abstract method）。只有一个抽象方法的接口称之为函数式接口(functional interface)，或者单个抽象方法接口(Single Abstract Method interface)。用fun interface来声明，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">interface</span> <span class="n">IntPredict</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">fun</span> <span class="nf">accept</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Boolean</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>函数式接口的最大优势在于，实现接口时可以简化到只用一个lambda，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">isEnv</span> <span class="p">=</span> <span class="n">IntPredict</span> <span class="p">{</span> <span class="n">it</span> <span class="p">%</span> <span class="m">2</span> <span class="p">==</span> <span class="m">0</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，只有用fun interface声明的含有一个抽象方法的接口才是函数式接口，才能用lambda。对于普通接口，如果它仅含有一个抽象方法，可以转化为函数式接口，比如原接口是酱紫的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">interface</span> <span class="n">Printer</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">fun</span> <span class="nf">print</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么，可以直接定义一个fun interface Printer就可以了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">interface</span> <span class="n">Printer</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">fun</span> <span class="nf">print</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>编译器会帮忙做转化。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/fun-interfaces.html">Functional (SAM) interfaces</a>。</p>

<h2>关键字object的妙用</h2>

<p>关键字object用以方便创建匿名对象的场景，如匿名对象，单例以及静态内部类。</p>

<h3>使用匿名对象</h3>

<p>有些时候我们会实现一些接口，或者继承某个基类，但仅是在本地一次性使用(One shot)，这时匿名对象就派上用场了，类似于Java中的匿名内部类。用<strong>object : </strong>后面跟要实现的接口或者要继承的类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">window</span><span class="p">.</span><span class="n">addMouseListener</span><span class="p">(</span><span class="k">object</span> <span class="err">: </span><span class="nc">MouseAdapter</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">override</span> <span class="k">fun</span> <span class="nf">mouseClicked</span><span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">MouseEvent</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">override</span> <span class="k">fun</span> <span class="nf">mouseEntered</span><span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">MouseEvent</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<h3>单例对象</h3>

<p>用object可以非常方便的实现单例模式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">object</span> <span class="nc">DataProviderManager</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">fun</span> <span class="nf">registerDataProvider</span><span class="p">(</span><span class="n">provider</span><span class="p">:</span> <span class="n">DataProvider</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">val</span> <span class="py">allDataProviders</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">DataProvider</span><span class="p">&gt;</span>
</span><span class='line'>      <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用时就直接用类名就可以了：DataProviderManager.registerDataProvider(&hellip;)。</p>

<h3>静态成员和方法</h3>

<p><img src="https://ts1.cn.mm.bing.net/th/id/R-C.b4723d86a22037c40298fff12e484b19?rik=tyTmLVbaHs9Mpw&amp;pid=ImgRaw&amp;r=0" alt="" /></p>

<p>在Java中有静态的成员和方法，用以实现一些属于类的成员和方法，在Kotlin中就需要用companion object来实现同样的功能。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">companion</span> <span class="k">object</span> <span class="nc">Factory</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">fun</span> <span class="nf">create</span><span class="p">():</span> <span class="n">MyClass</span> <span class="p">=</span> <span class="n">MyClass</span><span class="p">()</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用时就是用类+方法：MyClass.create()。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/object-declarations.html">Object expressions and declarations</a>。</p>

<h2>纯数据类型</h2>

<p><img src="https://qwebtechnologies.com/blog/wp-content/uploads/2023/03/Kotlin-Data-Class.png" alt="" /></p>

<p>对于函数式编程，通常要写大量的<a href="https://en.wikipedia.org/wiki/Plain_old_Java_object">PoJo</a>用以在函数之间传递数据，这些对象最大的特点就是仅是数据，且不可变(Immutable)，通常的实现方式就是把成员变量全用final修饰（只读read only）。在Kotlin中，可以非常方便的定义这要的类型，即data class。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">data</span> <span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="k">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="k">val</span> <span class="py">age</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>针对data class，编译器会自动生成equals, hashCode, toString, copy和componentN方法。注意，虽然成员可以标记为var，但不建议这样做，最好还是都标记为只读val，因为data class就是要Immutable。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/data-classes.html">Data classes</a>。</p>

<h2>密封类和接口</h2>

<p>密封类和接口是指用<strong>关键字sealed</strong>修饰的类和接口。它的作用是限制类的层次结构，用sealed修饰的类和接口，它们的所有子类必须在编译的时候就已知，一旦编译完成，不允许再被继承。</p>

<p>密封类型特别适用于库的设计，能够保证库的完整性。通常用于修饰库中的一些关键的有明确类型要求的类型，如<strong>消息类型，错误类型</strong>等等。因为，库会预定义一些消息类型，以及处理消息的接口，假如调用者扩展了某一消息类型，加了很多自定义的东西，这时再用库中的接口来处理的时候，可能会产生未预期的行为，因为库可能不认识这个新的新的消息类型，但因为是子类继承，语法上是合法的。这时密封类型就能派上用场，把消息类型用sealed修饰，就能保证库的完备性，它提供的错误处理接口一定可以正确处理它定义的消息类型。但注意不能滥用，没有必要为库的每一个类和接口都用sealed修饰，其实大部分时候我们是用不到sealed的。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/sealed-classes.html">Sealed classes and interfaces</a>。</p>

<h2>类型别名</h2>

<p>一个非常有意思的特性是类型别名，并不是定义一个新类型，而是取个别名。一般情况下，是为了方便，比如目标类型名字太长时，或者有大量的泛型参数时，就可以为它定义一个别名，图个省流。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">typealias</span> <span class="n">NodeSet</span> <span class="p">=</span> <span class="n">Set</span><span class="p">&lt;</span><span class="n">Network</span><span class="p">.</span><span class="n">Node</span><span class="p">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">typealias</span> <span class="n">MyHandler</span> <span class="p">=</span> <span class="p">(</span><span class="n">Int</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">Any</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Unit</span>
</span></code></pre></td></tr></table></div></figure>


<p>扩展阅读<a href="https://kotlinlang.org/docs/type-aliases.html">Type aliases</a>。</p>
]]></content>
  </entry>
  
</feed>
