<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[稀有猿诉]]></title>
  <link href="http://toughcoder.net/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2024-03-24T22:34:56+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Deep Dive Into Kotlin Generics Runtime]]></title>
    <link href="http://toughcoder.net/blog/2024/03/16/deep-dive-into-kotlin-generics-runtime/"/>
    <updated>2024-03-16T19:16:00+08:00</updated>
    <id>http://toughcoder.net/blog/2024/03/16/deep-dive-into-kotlin-generics-runtime</id>
    <content type="html"><![CDATA[<p>通过前面的学习，对Kotlin的泛型已经有了比较全面的了解了，泛型的目的是让通用的代码更加的类型安全。现在我们离写出类型安全的泛型代码还差最后一块拼图，那就是泛型的类型擦除，今天就来深入地学习一下运行时的泛型，彻底的弄懂类型擦除的前因后果，并学会如何在运行时做类型检查和类型转换，以期完成拼图掌握泛型，写出类型安全的通用代码。</p>

<p><a href="http://toughcoder.net/blog/2024/03/16/deep-dive-into-kotlin-generics-runtime/"><img src="https://global-uploads.webflow.com/618fa90c201104b94458e1fb/61978c1b9e0bf52082dabe92_Kotlin-Generics.png" title="auto auto" ></a></p>

<!-- more -->


<p>关于泛型话题的一系列文章：</p>

<ul>
<li><a href="http://toughcoder.net/blog/2024/03/04/kotlin-generics-made-easy/">这回就好好聊聊Kotlin的泛型</a></li>
<li><a href="http://toughcoder.net/blog/2024/03/10/java-generics-made-easy/">深入浅出Java泛型</a></li>
<li><a href="http://toughcoder.net/blog/2024/03/13/kotlin-generics-revisited/">Kotlin Generics Revisited</a></li>
<li><a href="http://toughcoder.net/blog/2024/03/16/deep-dive-into-kotlin-generics-runtime/">Dive deep into Kotlin type erasure</a></li>
</ul>


<h2>泛型类型擦除（Type erasure）</h2>

<p>泛型的类型安全性（包括类型检查type check，和类型转换type casting）都是由编译器在编译时做的，为了保持在JVM上的兼容性，编译器在保障完类型安全性后会对泛型类型进行<a href="https://en.wikipedia.org/wiki/Type_erasure">擦除（Type erasure）</a>。在运行时泛型类型的实例并不包含其类型信息，也就是说它不知道具体的类型参数，比如Foo&lt;Bar&gt;和Foo&lt;Baz?&gt;都被擦除成了Foo&lt;&#42;&gt;，在虚拟机（JVM）来看，它们的类型是一样的。</p>

<p>因为泛型Foo&lt;T&gt;的类型参数T会<strong>被擦除（erased）</strong>，所以与类型参数相关的类型操作（类型检查is T和类型转换as T）都是不允许的。</p>

<h2>可行的类型检查和转换</h2>

<p>虽然类型参数会被擦除，但并不是说对泛型完全不能进行类型操作。</p>

<h3>星号类型操作</h3>

<p>因为所有泛型会被擦除成为星号无界通配Foo&lt;&#42;&gt;，它相当于Foo&lt;Any?&gt;，是所有Foo泛型的基类，类型参数Any?是根基类，所以可以进行类型检查和类型转换：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">something</span> <span class="k">is</span> <span class="n">List</span><span class="p">&lt;*&gt;)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">something</span><span class="p">.</span><span class="n">forEach</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span> <span class="c1">// 元素被视为Any?类型</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>针对星号通配做类型操作，类型参数会被视为Any?。但其实这种类型操作没有任何意义，毕竟Any是根基类，任何类当成Any都是没有问题的。</p>

<h3>完全已知具体的类型参数时</h3>

<p>另外一种情况就是，整个方法的上下文中已经完全知道了具体的类型参数时，不涉及泛型类型时，也是可以进行类型操作的，说的比较绕，我们来看一个&#127792;：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">handleStrings</span><span class="p">(</span><span class="n">list</span><span class="p">:</span> <span class="n">MutableList</span><span class="p">&lt;</span><span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="p">(</span><span class="n">list</span> <span class="k">is</span> <span class="n">ArrayList</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// list is smart-cast to ArrayList&lt;String&gt;</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个方法并不涉及泛型类型，已经知道了具体的类型参数是String，所以类型操作也是可行的，因为编译器知道具体的类型，能对类型进行检查 保证是类型安全的。并且因为具体类型参数String可以推断出来，所以&lt;String&gt;是可以省略的。</p>

<h2>未检查的转换</h2>

<p>当编译器能推断出具体的类型时，进行类型转换就是安全的，这就是被检查的转型（checked cast），如上面的&#127792;。</p>

<p>如果无法推断出类型时，比如涉及泛型类型T时，因为类型会被擦除，编译器不知道具体的类型，这时as T或者as List&lt;T&gt;都是不安全的，编译器会报错，这就是未检查转型（unchecked cast）。</p>

<p>但如果能确信是类型转换是安全的，可以用注解&#64;Suppress(&ldquo;UNCHECKED_CAST&rdquo;)来忽略。</p>

<h2>用关键reified修饰inline泛型函数</h2>

<p><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.Y0Gq_pPe6TUb1g0oEN_51wHaEb?rs=1&amp;pid=ImgDetMain" alt="" /></p>

<p>要想能够对泛型类型参数T做类型操作，只能是在用关键字reified修饰了的inline泛型函数，在这种函数体内可以对泛型类型参数T做类型操作，&#127792;如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">inline</span> <span class="k">fun</span> <span class="err">&lt;</span><span class="nf">reified</span> <span class="n">A</span><span class="p">,</span> <span class="k">reified</span> <span class="n">B</span><span class="p">&gt;</span> <span class="n">Pair</span><span class="p">&lt;*,</span> <span class="p">*&gt;.</span><span class="n">asPairOf</span><span class="p">():</span> <span class="n">Pair</span><span class="p">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">&gt;?</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="p">!</span><span class="k">is</span> <span class="n">A</span> <span class="p">||</span> <span class="n">second</span> <span class="p">!</span><span class="k">is</span> <span class="n">B</span><span class="p">)</span> <span class="k">return</span> <span class="k">null</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">first</span> <span class="k">as</span> <span class="n">A</span> <span class="n">to</span> <span class="n">second</span> <span class="k">as</span> <span class="n">B</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="py">somePair</span><span class="p">:</span> <span class="n">Pair</span><span class="p">&lt;</span><span class="n">Any</span><span class="p">?,</span> <span class="n">Any</span><span class="p">?&gt;</span> <span class="p">=</span> <span class="s">&quot;items&quot;</span> <span class="n">to</span> <span class="n">listOf</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="py">stringToSomething</span> <span class="p">=</span> <span class="n">somePair</span><span class="p">.</span><span class="n">asPairOf</span><span class="p">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Any</span><span class="p">&gt;()</span>
</span><span class='line'><span class="k">val</span> <span class="py">stringToInt</span> <span class="p">=</span> <span class="n">somePair</span><span class="p">.</span><span class="n">asPairOf</span><span class="p">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Int</span><span class="p">&gt;()</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是关键字reified能够让针对类型参数T的操作得到编译器的检查，保证安全，是允许的。但是对于泛型仍是不允许的，&#127792;如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">inline</span> <span class="k">fun</span> <span class="err">&lt;</span><span class="nf">reified</span> <span class="n">T</span><span class="p">&gt;</span> <span class="n">List</span><span class="p">&lt;*&gt;.</span><span class="n">asListOfType</span><span class="p">():</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;?</span> <span class="p">=</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">all</span> <span class="p">{</span> <span class="n">it</span> <span class="k">is</span> <span class="n">T</span> <span class="p">})</span>
</span><span class='line'>        <span class="n">@Suppress</span><span class="p">(</span><span class="s">&quot;UNCHECKED_CAST&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="k">this</span> <span class="k">as</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="k">else</span>
</span><span class='line'>        <span class="k">null</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个inline泛型函数用关键字reified修饰了，因此针对类型参数T是允许类型检查类型转换，如第2行是允许的。但泛型仍是不合法，如第4行，这时可以用上一小节提到的注解&#64;Suppress(&ldquo;UNCHECKED_CAST&rdquo;)来忽略未检查类型转换。</p>

<h2>inline和reified的原理</h2>

<p>对于一些泛型工厂方法，就非常适合使用inline和reified，以保证转换为类型参数（因为工厂方法最终肯定要as T）是允许的且是安全的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">inline</span> <span class="k">fun</span> <span class="err">&lt;</span><span class="nf">reified</span> <span class="n">T</span><span class="p">&gt;</span> <span class="n">logger</span><span class="p">():</span> <span class="n">Logger</span> <span class="p">=</span> <span class="n">LoggerFactory</span><span class="p">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">T</span><span class="o">::</span><span class="k">class</span><span class="p">.</span><span class="n">java</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">User</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">private</span> <span class="k">val</span> <span class="py">log</span> <span class="p">=</span> <span class="n">logger</span><span class="p">&lt;</span><span class="n">User</span><span class="p">&gt;()</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>关键字reified其实也没有什么神秘的，因为这是inline函数，这种函数是会把函数体嵌入到任何调用它的地方（call site），而每个调用泛型函数的地方必然会有明确的具体类型参数，那么编译器就知道了具体的类型能保证类型安全（checked cast）。上面的工厂方法在调用时就会大概变成酱紫：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">User</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">private</span> <span class="k">val</span> <span class="py">log</span> <span class="p">=</span> <span class="n">LoggerFactory</span><span class="p">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">User</span><span class="p">.</span><span class="k">class</span><span class="p">.</span><span class="n">java</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这时其实在函数体内已经知道了具体的类型参数User，编译器能够进行类型检查，所以是安全的。</p>

<h2>总结</h2>

<p>本文深入的讨论一下运行时泛型的一些特性，泛型类型在运行时会被擦除，无法做泛型相关的类型操作，因为编译器无法保证其类型安全。例外就是在用reified修饰的inline函数中可以对类型参数T做类型操作，但泛型类型（带尖括号的&lt;T&gt;）仍是会被擦除，可以用注解&#64;Suppress(&ldquo;UNCHECKED_CAST&rdquo;)来忽略unchecked cast。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/generics.html#type-erasure">Type erasure</a></li>
<li><a href="https://www.baeldung.com/kotlin/generics#generics-at-runtime">6. Generics at Runtime</a></li>
<li><a href="https://www.baeldung.com/kotlin/type-erased-list-array-conversion">How to Convert a Type-Erased List to an Array in Kotlin</a></li>
<li><a href="https://discuss.kotlinlang.org/t/type-erasure/14519">Discussion about Type Erasure</a></li>
<li><a href="https://stackoverflow.com/questions/42916801/how-does-erasure-work-in-kotlin">How does erasure work in Kotlin?</a></li>
<li><a href="https://workingdev.net/2018/09/reified-generics-in-kotlin.html">Reified Generics in Kotlin</a></li>
<li><a href="https://duongnt.com/type-erasure-reified/">Type erasure and reified in Kotlin</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin Generics Revisited]]></title>
    <link href="http://toughcoder.net/blog/2024/03/13/kotlin-generics-revisited/"/>
    <updated>2024-03-13T22:33:20+08:00</updated>
    <id>http://toughcoder.net/blog/2024/03/13/kotlin-generics-revisited</id>
    <content type="html"><![CDATA[<p>在前面的文章中学习Kotlin泛型的基本知识，并且又用了一篇文章来复习了一下Java语言的泛型，有了这些基础我们就可以继续深入的学习Kotlin的泛型了。看它是如何解决Java泛型的遗留问题，再学习一下它的高级特性，最后再总结泛型的最佳实践。</p>

<p><a href="http://toughcoder.net/blog/2024/03/13/kotlin-generics-revisited/"><img src="https://koenig-media.raywenderlich.com/uploads/2019/09/Generics-feature.png" width="480" height="480"></a></p>

<!-- more -->


<p>本文是作为前面文章的延续和深化，为了更好的阅读效果，建议先回顾一下<a href="http://toughcoder.net/blog/2024/03/10/java-generics-made-easy/">Java泛型基础</a>，和<a href="http://toughcoder.net/blog/2024/03/04/kotlin-generics-made-easy/">Kotlin泛型基础</a>。</p>

<h2>泛型类型参数界限（Upper bounds）</h2>

<p>我们在前面讲解<a href="http://toughcoder.net/blog/2024/03/10/java-generics-made-easy/">Java泛型基础</a>时提到了在声明泛型的时候是可以指定类型参数的界限的，比如用Caculator&lt;T extends Number&gt;可以指定在使用时可以传入的类型参数要是Number或者Number的子类。</p>

<p>在Kotlin中也是可以指定泛型类型参数的界限的，也是用<strong>继承符号:来表示</strong>，&#127792;如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">Calculator</span><span class="p">&lt;</span><span class="n">T</span> <span class="p">:</span> <span class="n">Number</span><span class="p">&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>与Java一样，也可以指定多个界限，要<strong>使用where关键字</strong>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">Calculator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">Number</span><span class="p">,</span> <span class="n">T</span> <span class="p">:</span> <span class="n">Runnable</span><span class="p">,</span> <span class="n">T</span> <span class="p">:</span> <span class="n">Closable</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="err">&lt;</span><span class="nf">T</span><span class="p">&gt;</span> <span class="n">copyWhenGreater</span><span class="p">(</span><span class="n">list</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;,</span> <span class="n">threshold</span><span class="p">:</span> <span class="n">T</span><span class="p">):</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span>
</span><span class='line'>    <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">CharSequence</span><span class="p">,</span>
</span><span class='line'>          <span class="n">T</span> <span class="p">:</span> <span class="n">Comparable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">list</span><span class="p">.</span><span class="n">filter</span> <span class="p">{</span> <span class="n">it</span> <span class="p">&gt;</span> <span class="n">threshold</span> <span class="p">}.</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">toString</span><span class="p">()</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意：面向对象的继承体系是基类在上面，子类在下面，所以上界的意思是以某个类A为根的继承树，这颗树都可以当成A来使用；下界的意思是从根A到以某个类C为止的一个路径，这个路径上都是C的基类，C都可以当成它们来用。</p>

<p><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/20221025185149/Hierarchical-Inheritance-in-Java.jpg" alt="" /></p>

<h2>更优雅的泛型变化(Variance)</h2>

<p>与Java一样，Kotlin的泛型也是不可变的Invariant，比如虽然String是Any的子类，但List&lt;String&gt;并不是List&lt;Any&gt;的子类。泛型变化Variance的目的就是让两个泛型产生与类型参数协同的变化，比如类型C是类A的子类，那么使用它的泛型&lt;C&gt;也应该是&lt;A&gt;的子类，能使用&lt;A&gt;的方，传入&lt;C&gt;一定要是允许的，并要能够是安全的。</p>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.HRZ3CHxJfgk_hG9T11siDQHaD4?rs=1&amp;pid=ImgDetMain" alt="" /></p>

<h3>使用点变化（Use-site variance）</h3>

<p>基于面向对象的基本特性，只有向上转型(Upcasting)是安全的。具体就分为两种场景，从一个生产者中读取对象时，只要生产者的输出声明的T是基类（T是一个上限），无论生产者输出的是T还是它的子类，对于使用者来说（当T来用）就是安全的。这时生产者的泛型要能够进行协变，在Java中用上界界限通配符&lt;? extends T&gt;来进行协变，具体使用时传入T的子类的泛型也是合法的；同理，向一个消费者中写数据时，消费者声明为T的某个基类（这时T是一个下限），向其传入T，对于使用者来说就是安全的。这时消费者的泛型要能进行逆变，在Java中使用下界界限通配符&lt;? super T&gt;来进行逆变，具体使用时传T的基类的泛型也是合法的。</p>

<p>Kotlin中提供了非常容易理解和使用的<strong>关键字out来进行协变（covariance）和in进行逆变（contravariance）</strong>，可以实现Java中的界限通配符一样的功效。Java界限通配符的规则是<strong>PECS（Producer Extends Consumer Super）</strong>，out正好可以更形象的描述一个生产者，而in可以更形象的描述一个消费者，所以Kotlin的关键字更容易理解和记忆。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">open</span> <span class="k">class</span> <span class="nc">Animal</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Dog</span> <span class="p">:</span> <span class="n">Animal</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">MyList</span><span class="p">&lt;</span><span class="n">E</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">fun</span> <span class="nf">addAll</span><span class="p">(</span><span class="n">from</span><span class="p">:</span> <span class="n">MyList</span><span class="p">&lt;</span><span class="k">out</span> <span class="n">E</span><span class="p">&gt;)</span> <span class="p">{}</span>
</span><span class='line'>    <span class="k">fun</span> <span class="nf">getAll</span><span class="p">(</span><span class="n">to</span><span class="p">:</span> <span class="n">MyList</span><span class="p">&lt;</span><span class="k">in</span> <span class="n">E</span><span class="p">&gt;)</span> <span class="p">{}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">animals</span> <span class="p">=</span> <span class="n">MyList</span><span class="p">&lt;</span><span class="n">Animal</span><span class="p">&gt;()</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">dogs</span> <span class="p">=</span> <span class="n">MyList</span><span class="p">&lt;</span><span class="n">Dog</span><span class="p">&gt;()</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">animals</span><span class="p">.</span><span class="n">addAll</span><span class="p">(</span><span class="n">dogs</span><span class="p">)</span>
</span><span class='line'>    <span class="n">dogs</span><span class="p">.</span><span class="n">getAll</span><span class="p">(</span><span class="n">animals</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这种泛型变化是发生在调用者调用时，因此也叫做『使用点变化』(Use-site variance)。在Kotlin中也被称作<strong>类型映射</strong>，因为相当于是用&lt;out T&gt;把T给映射成了一个T的生产者，只能调用其get方法；用&lt;in T&gt;映射成一个T的消费者，只能调用set方法。并且呢，对于同一个函数中既有生产者和消费者时，in和out只写一个就行了，&#127792;如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">copy</span><span class="p">(</span><span class="n">from</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="k">out</span> <span class="n">Any</span><span class="p">&gt;,</span> <span class="n">to</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">Any</span><span class="p">&gt;)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>声明点变化（Declaration-site variance）</h3>

<p>Java界限通配符的一个大问题是只能用于方法的参数但不能是返回值，也就是只能是『Use-site variance』。但in和out没有这个限制，因此它们可以用于返回值。只要给类和接口的泛型声明为out或者in就能让类型参数在其所有的方法产生variance，这就是『declaration-site variance』。</p>

<p>但是要遵守out进行协变，也就是<strong>说out是用于生产者</strong>的，只能作为方法的返回值，或者保证不能set，&#127792;如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">interface</span> <span class="n">Source</span><span class="p">&lt;</span><span class="k">out</span> <span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">fun</span> <span class="nf">nextT</span><span class="p">():</span> <span class="n">T</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="nf">demo</span><span class="p">(</span><span class="n">strs</span><span class="p">:</span> <span class="n">Source</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">objects</span><span class="p">:</span> <span class="n">Source</span><span class="p">&lt;</span><span class="n">Any</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">strs</span> <span class="c1">// This is OK, since T is an out-parameter</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>同理，<strong>用in进行逆变，只能用于消费者</strong>，只能作为方法的参数，或者保证不get，&#127792;如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">interface</span> <span class="n">Comparable</span><span class="p">&lt;</span><span class="k">in</span> <span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">operator</span> <span class="k">fun</span> <span class="nf">compareTo</span><span class="p">(</span><span class="n">other</span><span class="p">:</span> <span class="n">T</span><span class="p">):</span> <span class="n">Int</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="nf">demo</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Comparable</span><span class="p">&lt;</span><span class="n">Number</span><span class="p">&gt;)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">x</span><span class="p">.</span><span class="n">compareTo</span><span class="p">(</span><span class="m">1.0</span><span class="p">)</span> <span class="c1">// 1.0 has type Double, which is a subtype of Number</span>
</span><span class='line'>    <span class="c1">// Thus, you can assign x to a variable of type Comparable&lt;Double&gt;</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">y</span><span class="p">:</span> <span class="n">Comparable</span><span class="p">&lt;</span><span class="n">Double</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">x</span> <span class="c1">// OK!</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>小结一下，Kotlin使用关键字in和out让泛型的协变和逆变变得容易理解得多了，因为它们能够非常清楚的表达出消费者和生产者，只需要记住一个泛型的生产者要用out来修饰，而一个泛型的消费者要用in来修饰就不会出错，这比Java中的界限通配符简单太多了。</p>

<h2>星号映射(Star projections)</h2>

<p>除了use-site variance是一种类型映射外，还有星号映射。首先来说<strong>星号是无界泛型</strong>，也就是说不指定具体的类型参数，意思是任意类型的泛型，换句话说Foo&lt;&#42;&gt;是任何其他泛型的基类（Foo&lt;String&gt;, Foo&lt;Number&gt;等）。但根据不同的上下文，Foo&lt;&#42;&gt;会映射为不同的具体意义的泛型类型：</p>

<ul>
<li>对于Foo&lt;out T : TUpper&gt;，这里的T是一个受上界TUpper限制的协变类型参数，那么Foo&lt;&#42;&gt;就等同于Foo&lt;out TUpper&gt;。</li>
<li>对于Foo&lt;in T&gt;，这里T是逆变类型参数，Foo&lt;&#42;&gt;等同于Foo&lt;in Nothing&gt;。这意思是无法向Foo&lt;&#42;&gt;中写。</li>
<li>对于Foot&lt;T : TUpper&gt;，这里T是一个被上界TUpper限定的不可变类型参数，那么Foo&lt;&#42;&gt;，在读时（作为生产者）等同于Foo&lt;out TUpper&gt;，在写时（作为消费者）等同于Foo&lt;in Nothing&gt;。</li>
</ul>


<p>如果泛型是多元的，那么每个类型参数可以进行不同的映射。比如说如果一个类型是这样声明的interface Function&lt;in T, out U&gt;，那么会有这样的映射：</p>

<ul>
<li>Function&lt;&#42;, String&gt; 意思是Function&lt;in Nothing, String&gt;</li>
<li>Function&lt;Int, &#42;&gt; 意思是Function&lt;Int, out Any?&gt;</li>
<li>Function&lt;&#42;, &#42;&gt; 意思是Function&lt;in Nothing, out Any?&gt;</li>
</ul>


<p>换句话来理解，就是当不指定具体的类型参数，用星星就代表着不知道具体的类型参数，那么视具体的上下文不同星号会被解释不同的意思。不过这玩意儿可读性较差，除非必不得已，否则还是能不用就用它。</p>

<p>注意：在Kotlin中，<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/">根基类是Any</a>它是所有其他类的基类（the root of Kotlin class hierarchy）。而<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-nothing.html">Nothing</a>是不能有实例的类，可以用它来表示不存在的对象（a value that never exists）。比如说，如果 一个函数返回值类型声明为Nothing，那它就不会返回（always throws an exception），注意是<strong>不会返回（never returns）</strong>，并不是没有返回值，没有返回值要<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/">声明为类型Unit</a>。</p>

<h2>绝不为空类型（Definitely non-null type）</h2>

<p>为了保持对Java的互通性，Kotlin还支持把泛型类型参数声明为『绝不为空类型』definitely non-null type。可以<strong>用&amp; Any来声明</strong>，如&lt;T &amp; Any&gt;来声明T是『绝不为空类型』。</p>

<p>这是为了保持与Java的相互调用，有些Java的类和接口是用<strong>注解&#64;NonNull修饰的</strong>，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Game</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">T</span> <span class="nf">save</span><span class="o">(</span><span class="n">T</span> <span class="n">x</span><span class="o">)</span> <span class="o">{}</span>
</span><span class='line'>    <span class="nd">@NotNull</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">T</span> <span class="nf">load</span><span class="o">(</span><span class="nd">@NotNull</span> <span class="n">T</span> <span class="n">x</span><span class="o">)</span> <span class="o">{}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这时在Kotlin里面就要用到<strong>『绝不为空类型』&amp; Any来声明泛型</strong>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">interface</span> <span class="n">ArcadeGame</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">Game</span><span class="p">&lt;</span><span class="n">T1</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">override</span> <span class="k">fun</span> <span class="nf">save</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T1</span><span class="p">):</span> <span class="n">T1</span>
</span><span class='line'>    <span class="c1">// T1 is definitely non-nullable</span>
</span><span class='line'>    <span class="k">override</span> <span class="k">fun</span> <span class="nf">load</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T1</span> <span class="p">&amp;</span> <span class="n">Any</span><span class="p">):</span> <span class="n">T1</span> <span class="p">&amp;</span> <span class="n">Any</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，在纯Kotlin代码中是用不到这个特性的。只有当涉及Java的&#64; NonNull时才需要『绝不为空类型』。</p>

<h2>下划线操作符</h2>

<p>当编译器能推断出泛型的类型参数时是可以省略掉类型参数的，比如val names = listOf(&ldquo;James&rdquo;, &ldquo;Kevin&rdquo;)，这里得到的类型是List&lt;String&gt;，但我们并没有显示的指定类型参数，这是因为编译器从listOf的参数中就能推断出类型参数是String，所以listOf的返回就是List&lt;String&gt;。</p>

<p>但有些时候，泛型类型太复杂了，没有办法推断出所有的类型，比如有多元泛型参数时。但根据指定的某一个参数，可以推断出剩余的参数时，这时就没有办法完全省略类型参数，剩余的参数却又可以推断出来，写了又浪费。这时就可以用下划线操作符来代表那些可以推断出来的参数。这里的下划线用法跟在lambda中，用下划线替代不使用的参数是一样的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">abstract</span> <span class="k">class</span> <span class="nc">SomeClass</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">abstract</span> <span class="k">fun</span> <span class="nf">execute</span><span class="p">()</span> <span class="p">:</span> <span class="n">T</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">SomeImplementation</span> <span class="p">:</span> <span class="n">SomeClass</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">override</span> <span class="k">fun</span> <span class="nf">execute</span><span class="p">():</span> <span class="n">String</span> <span class="p">=</span> <span class="s">&quot;Test&quot;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">OtherImplementation</span> <span class="p">:</span> <span class="n">SomeClass</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">override</span> <span class="k">fun</span> <span class="nf">execute</span><span class="p">():</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">42</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">object</span> <span class="nc">Runner</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">inline</span> <span class="k">fun</span> <span class="err">&lt;</span><span class="nf">reified</span> <span class="n">S</span><span class="p">:</span> <span class="n">SomeClass</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;,</span> <span class="n">T</span><span class="p">&gt;</span> <span class="n">run</span><span class="p">()</span> <span class="p">:</span> <span class="n">T</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">S</span><span class="o">::</span><span class="k">class</span><span class="p">.</span><span class="n">java</span><span class="p">.</span><span class="n">getDeclaredConstructor</span><span class="p">().</span><span class="n">newInstance</span><span class="p">().</span><span class="n">execute</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// T is inferred as String because SomeImplementation derives from SomeClass&lt;String&gt;</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">s</span> <span class="p">=</span> <span class="n">Runner</span><span class="p">.</span><span class="n">run</span><span class="p">&lt;</span><span class="n">SomeImplementation</span><span class="p">,</span> <span class="n">_</span><span class="p">&gt;()</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="n">s</span> <span class="p">==</span> <span class="s">&quot;Test&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// T is inferred as Int because OtherImplementation derives from SomeClass&lt;Int&gt;</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">n</span> <span class="p">=</span> <span class="n">Runner</span><span class="p">.</span><span class="n">run</span><span class="p">&lt;</span><span class="n">OtherImplementation</span><span class="p">,</span> <span class="n">_</span><span class="p">&gt;()</span>
</span><span class='line'>    <span class="n">assert</span><span class="p">(</span><span class="n">n</span> <span class="p">==</span> <span class="m">42</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/generics.html">Generics: in, out, where</a></li>
<li><a href="https://www.gyata.ai/kotlin/kotlin-generics/">Kotlin Generics</a></li>
<li><a href="https://blog.logrocket.com/understanding-kotlin-generics/">Understanding Kotlin generics</a></li>
<li><a href="https://sebhastian.com/kotlin-generics/#google_vignette">Kotlin generics explained with code examples</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/143380842">深入解析Kotlin 泛型</a></li>
<li><a href="https://juejin.cn/post/6959859571242303495">Kotlin（六）深入理解Kotlin泛型</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入浅出Java泛型]]></title>
    <link href="http://toughcoder.net/blog/2024/03/10/java-generics-made-easy/"/>
    <updated>2024-03-10T20:43:03+08:00</updated>
    <id>http://toughcoder.net/blog/2024/03/10/java-generics-made-easy</id>
    <content type="html"><![CDATA[<blockquote><p>温故而知新，可以为师矣！</p></blockquote>

<p>在<a href="http://toughcoder.net/blog/2024/03/04/kotlin-generics-made-easy/">前面的一篇文章</a>中学习了Kotlin的泛型知识，但总感觉还不够深入，因为一些深入的话题和高级的特性并未有讲清楚。但在继续深入之前还是有必要重温一下Java的泛型知识，这是因为Kotlin是基于JVM的语言，并且与Java关系暧昧，它可以与Java混合使用，可以相互调用，在某种程度上讲Kotlin可以视为Java的一种『方言』。所以，我们先回顾Java的泛型，夯实基础，并弄清楚Java泛型遗留了哪些问题，然后再看看Kotlin是如何解决这些问题的。</p>

<p><a href="http://toughcoder.net/blog/2024/03/10/java-generics-made-easy/"><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.wupG3f0_pqm_144x4Zw6ZwHaD4?rs=1&pid=ImgDetMain" title="auto auto" ></a></p>

<!-- more -->


<h2>基础使用方法</h2>

<p>还是要从基本的使用方法来谈起。</p>

<p><a href="https://docs.oracle.com/javase/tutorial/java/generics/index.html">泛型（Generics）</a>就是在类或者方法定义的时候并不指定其操作数据的具体类型，而是用一个虚拟的名字<strong>&lt;T&gt;</strong>代替，类的使用者或者方法的调用在使用时提供具体的类型，以达到类和方法能对所有的类型都能使用的目录。可以把泛型理解为参数化，也就是说定义的时候把其操作的数据类型视为一种参数，由使用者在使用时具体指定（创建对象时或者调用方法时），因此泛型也可以称为<strong>参数化类型</strong>。有3个地方可以使用泛型，<strong>类，接口和方法</strong>，接下分别来看一下具体如何使用。</p>

<h3>泛型类</h3>

<p>泛型类，也即参数化类型的类，是最为常见的一种泛型的使用方式。这些类可以视为<a href="https://en.wikipedia.org/wiki/Metaclass">元类</a>，它会操作另一个类型，比如存储或者加工，类本身的实现重点在于如何操作，而对于这个『另一个类型』具体是什么，并不关心。这时就可以用泛型，在定义类的时候并不指定具体的类型，而是用一个虚拟的类型来代替，由类的使用者在使用的时候来指定具体的类型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">class</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">E</span> <span class="nf">get</span><span class="o">(</span><span class="kt">int</span> <span class="n">index</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里ArrayList是一个容器，可以以线性的方式来存储任意其他类型，具体是啥其实ArrayList并不关心，所以这里用泛型，E就是参数化类型，代指某一个类型。使用时需要提供具体的类型，可以Integer，String，或者定义好了的任何一种类型(Class)：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">players</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;();</span>
</span><span class='line'><span class="n">players</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;James&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">players</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="s">&quot;Kevin&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;#1 is &quot;</span> <span class="o">+</span> <span class="n">players</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
</span><span class='line'><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;#2 is &quot;</span> <span class="o">+</span> <span class="n">players</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
</span><span class='line'><span class="c1">// #1 is James</span>
</span><span class='line'><span class="c1">// #2 is Kevin</span>
</span></code></pre></td></tr></table></div></figure>


<p>小结 一下，泛型是为了增强代码的复用，定义时用<strong>尖括号&lt;&gt;表示的参数化类型Parameterized type</strong>，拼接在类名字的后面，使用时再指定具体的类型。并且，当编译器能推断出参数类型时，可以用<strong>钻石符号(Diamond operator)&lt;&gt;来</strong>省略参数类型名字。</p>

<h3>泛型接口</h3>

<p>泛型可以用于接口的声明，与类一样，把类型参数化即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">interface</span> <span class="nc">Consumer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">void</span> <span class="nf">consume</span><span class="o">(</span><span class="n">T</span> <span class="n">t</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>泛型方法</h3>

<p>除了类和接口，<a href="https://docs.oracle.com/javase/tutorial/extra/generics/methods.html">方法也可以使用泛型</a>，把用<strong>尖括号表示的参数化类型&lt;T&gt;放</strong>在方法的返回类型之前就可以了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">fromArrayToList</span><span class="o">(</span><span class="n">T</span><span class="o">[]</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">String</span><span class="o">[]</span> <span class="n">names</span> <span class="o">=</span> <span class="o">{</span><span class="s">&quot;James&quot;</span><span class="o">,</span> <span class="s">&quot;Kevin&quot;</span><span class="o">,</span> <span class="s">&quot;Harden&quot;</span><span class="o">};</span>
</span><span class='line'><span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">players</span> <span class="o">=</span> <span class="n">fromArrayToList</span><span class="o">(</span><span class="n">names</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是，因为Java的方法必须声明在类里面，但这并不意味着方法的泛型一定要与类的类型参数一致，当然了，方法可以直接使用类的类型参数，也可以自己再定义一个另外的类型参数，注意这是方法自定义的泛型与其所在的类的泛型没啥关系，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">class</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">transfer</span><span class="o">(</span><span class="n">E</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，为了可读性方法自定义的泛型最好不要与其所在类使用的泛型一样，比如类用T，方法也用T，虽然这是可以的，因为这个替代类型名字随便取为啥非要弄的容易混淆呢？</p>

<h3>多元类型参数</h3>

<p>类型参数可以有多个，用不同的代号名字并用逗号隔开就可以了，就比如哈希表：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">class</span> <span class="nc">HashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="o">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>就是一个使用二元类型参数的类。</p>

<p>以上就是泛型的基础使用方法。</p>

<h2>理解泛型的本质</h2>

<p>通过以上的介绍可以得出泛型的根本目的是加强复用，让类和方法不受类型的限制，可以应用于任何类型，并且是以一种安全的方式，受到编译器的支持。</p>

<h3>泛型的优势</h3>

<p>如果不用泛型，想要让类或者方法通用，即对任何对象都能生效，那只能把其参数的类型声明为顶层基类Object，然后在某些地方做手动类型转换（type casting）。很明显，这非常容易出错，并且非常的不安全， 一旦某些地方忘记了检查，就会有运行时的类型转换异常（ClassCastException）。</p>

<p>使用了泛型后，编译器会帮助我们对类型对待检查和自动转换，在完成代码复用的同时，又能保证运行时的类型安全，减少运行时的类型转换错误，所以我们应该尽可能多的使用泛型。</p>

<h3>命名规范</h3>

<p>虽然说参数化类型可以用任何名字，但为了可读性还是要遵从比较流行的规范：</p>

<ul>
<li>T 类型</li>
<li>E 集合里面元素的类型</li>
<li>K 哈希表，或者其他有键值的键的类型</li>
<li>V 哈希表中值的类型</li>
<li>N 数字类型</li>
<li>S, U, V等多元参数类型时使用</li>
</ul>


<h2>泛型高级特性</h2>

<h3>指定参数类型的界限</h3>

<p>泛型在定义的时候用虚拟的类型表示参数化的类型，使用的时候传入具体的类型，但有些时候需要<strong>对可以传入的具体类型做限制</strong>，这时可以用类似&lt;T extends Number&gt;来<strong>限定可以使用的类型参数的界限（上界）</strong>，这里的Number可以是任意已知的类型。并且与类的多继承规则一样，这里可以指定多个类型上限，但只能有一个类且要放在最前面后面的只能是接口，用&amp;来连接，如&lt;T extends ClassA &amp; IfaceB &amp; IfaceC&gt;，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">class</span> <span class="nc">Calculator</span><span class="o">&lt;</span><span class="n">T</span> <span class="kd">extends</span> <span class="n">Number</span> <span class="o">&amp;</span> <span class="n">Runnable</span> <span class="o">&amp;</span> <span class="n">Closeable</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">T</span> <span class="n">operand</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="n">S</span> <span class="kd">extends</span> <span class="n">Number</span> <span class="o">&amp;</span> <span class="n">Runnable</span> <span class="o">&amp;</span> <span class="n">Comparable</span><span class="o">&gt;</span> <span class="n">S</span> <span class="nf">plus</span><span class="o">(</span><span class="n">S</span> <span class="n">a</span><span class="o">,</span> <span class="n">S</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">//</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>指定泛型中参数型的限制在实际项目中是很有用的，它可以加强代码复用，把一些公共的代码从子类中抽出来，比如像一个列表中的Item有不同的数据类型和不同的布局样式，常规的多态是说让每个子类去实现自己的布局样式，但如果共性太多，这时就可以在创建一个泛型的类或者方法来做，而这个类或者方法就可以指定基类作为泛型类型界限。这样可以加强代码的类型安全，避免调用者传入代码不认识和不能处理的参数类型。</p>

<h3>界限通配符来实现协变与逆变</h3>

<p><a href="https://www.howtogeek.com/devops/what-is-covariance-and-contravariance-in-programming/">协变与逆变</a>是用来描述对象的继承关系在使用这些对象为类型参数的泛型中的联系。比如说Dog是Animal的子类，那么使用这两个类型为参数的泛型对象之间的关系应该是会么呢？如List&lt;Dog&gt;是否也是List&lt;Animal&gt;的子类？Java中的泛型是不可变的Invariant，即泛型对象之间的关系与它们的类型参数之间的关系是没有联系的，即List&lt;Dog&gt;与List&lt;Animal&gt;之间没关系。</p>

<p><img src="https://i1.wp.com/techvidvan.com/tutorials/wp-content/uploads/sites/2/2020/05/Types-of-Java-Wildcards.jpg?fit=802%2C420&amp;ssl=1" alt="" /></p>

<p>不可变Invariant是为了类型安全，编译器检查泛型类型参数必须严格匹配，但在有些时候会带来极大的不方便，因为面向对象的两大基本特性继承和多态保证了子类对象可以当作其基类使用，换句话说能用Animal的地方，放一个Dog对象应该完全合法。但因为泛型不可变，一个声明为addAll(List&lt;Animal&gt;)的方法，是没有办法传入List&lt;Dog&gt;的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{}</span>
</span><span class='line'><span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="n">Animal</span> <span class="o">{}</span>
</span><span class='line'><span class="kd">class</span> <span class="nc">List</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="n">E</span><span class="o">[]</span> <span class="n">items</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addAll</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="n">E</span> <span class="n">x</span> <span class="o">:</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">items</span><span class="o">[</span><span class="n">size</span><span class="o">++]</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">getAll</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="n">E</span> <span class="n">e</span> <span class="o">:</span> <span class="n">items</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">b</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span> <span class="n">animals</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="o">&lt;&gt;();</span>
</span><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span> <span class="n">dogs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="o">&lt;&gt;();</span>
</span><span class='line'><span class="n">animals</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">dogs</span><span class="o">);</span> <span class="c1">// compile error</span>
</span><span class='line'><span class="n">dogs</span><span class="o">.</span><span class="na">getAll</span><span class="o">(</span><span class="n">animals</span><span class="o">);</span> <span class="c1">// compile error</span>
</span></code></pre></td></tr></table></div></figure>


<p>但这其实是很安全的，因为我们把Dog从列表中取出，然后当作Animal使用，这是向上转型(Upcasting)是完全安全的。但因为泛型是不可变的，编译器必须要保证泛型的类型参数必须完全一致，因此会给出编译错误，但这显然不方便，会让泛型的作用大打折扣。再比如Object是所有对象的基类，但是当把Object作为类型参数时，这个泛型并不是其他泛型的父类，如List&lt;String&gt;并不是List&lt;Object&gt;的子类。</p>

<p>实际上这里需要的是协变(Covariance)与逆变(Contravariance)，也就是让使用类型参数的泛型具有其类型参数一致的继承关系，就要用到界限通配符(Bounded Wildcards)。一共有三种：</p>

<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/generics/upperBounded.html">上界进行协变Covariant</a>，参数化类型&lt;? extends T&gt;表示可以是以T为基类的任意子类类型，当然也包括T本身，泛型&lt;S&gt;会变成&lt;? extends T&gt;的子类，如果S是T的子类。</li>
<li><a href="https://docs.oracle.com/javase/tutorial/java/generics/lowerBounded.html">下界进行逆变Contravariant</a>，参数化类型&lt;? super T&gt;表示可以是T或者T的基类类型泛型&lt;B&gt;会变成&lt;? super T&gt;的基类，如果B是T的基类。</li>
<li><a href="https://docs.oracle.com/javase/tutorial/java/generics/unboundedWildcards.html">无界</a>，参数化类型&lt;?&gt;表示可以是任何类型，可以理解为泛型里的顶层基类（就像Object之于其他对象一样）。</li>
</ul>


<p>使用界限通配符来修改上述&#127792;：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kd">class</span> <span class="nc">List</span><span class="o">&lt;</span><span class="n">E</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addAll</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span><span class='line'>  
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">getAll</span><span class="o">(</span><span class="n">List</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="n">E</span><span class="o">&gt;</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">Animal</span><span class="o">&gt;</span> <span class="n">animals</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="o">&lt;&gt;();</span>
</span><span class='line'><span class="n">List</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span> <span class="n">dogs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">List</span><span class="o">&lt;&gt;();</span>
</span><span class='line'><span class="n">animals</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">dogs</span><span class="o">);</span> <span class="c1">// 0 warnings, 0 errors!</span>
</span><span class='line'><span class="n">dogs</span><span class="o">.</span><span class="na">getAll</span><span class="o">(</span><span class="n">animals</span><span class="o">);</span> <span class="c1">// 0 warnings, 0 errors!</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要特别注意的是<strong>界限通配符解决的问题是协变与逆变</strong>，也即<strong>让两个泛型之间的关系与其参数类型保持一致</strong>，但具体的这一对类型参数仍可以是任何类型。这与前一小节讨论的参数类型界限是完全不同的概念，不是同一码事儿，参数类型界限是限制使用泛型时可以传入的类型的限制。</p>

<p>界限通配符解决的是泛型之间的关系，每当<strong>需要进行<a href="https://docs.oracle.com/javase/tutorial/java/generics/wildcardGuidelines.html">协变与逆变的时候</a>就需要用到通配符</strong>，以让代码更通用更合理。还需要特别注意的<strong>界限通配符只能用于方法的参数</strong>，大神Joshua Bloch在《Effective Java》中<a href="https://stackoverflow.com/questions/2723397/what-is-pecs-producer-extends-consumer-super">给出的建议</a>是<strong>通配符要用于方法的输入泛型参数，如果参数是生产者用extends（即从里面读取对象），如果是消费者用super（即往里面写数据）</strong>。</p>

<h2>运行时的<a href="https://docs.oracle.com/javase/tutorial/java/generics/genTypes.html">泛型擦除</a></h2>

<p>泛型是为了以类型安全的方式实现代码复用，但是在Java 1.5版本时引入的，为了保持向后兼容性，编译器会对泛型的类型信息进行擦除(type erasure)，使其变成常规的对象，这样运行时（JVM）就不用处理新增加的类型了，保持了字节码的兼容性。比如List&lt;String&gt;与List&lt;Integer&gt;在运行时都变成了List对象，JVM并不知道它们的参数类型。泛型的类型参数检查，以及类型的转换都是发生在编译时，是编译器做的事情。</p>

<p>泛型擦除带来的一个问题就是泛型不能使用类型判断符(instanceof)，以及不能进行强制类型转换，比如这样写是不合法的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="c1">// Compile error: Illegal   generic type for instanceof</span>
</span><span class='line'><span class="k">if</span> <span class="o">(</span><span class="n">list</span> <span class="k">instanceof</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">List</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;</span> <span class="n">ld</span> <span class="o">=</span> <span class="o">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Dog</span><span class="o">&gt;)</span> <span class="n">list</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>很显然，反射(Reflect)是完全没有办法用泛型的，因为反射是在运行时，这时泛型都被擦除了。如果非要使用泛型，必须要把其类型参数的Class传入作为参数（也即把T的具体参数的class对象传入如String.class），以此来区分不同的泛型，可以参考<a href="https://www.baeldung.com/java-factory-pattern-generics">泛型工厂方法的实现</a>。</p>

<h2>Java泛型的问题</h2>

<h3>泛型不支持基础类型</h3>

<p>Java为了效率和兼容性保留了基础数据类型，如int, boolean, float，但它们并不是对象。而泛型的类型参数必须是对象，因此基础类型是不能用在泛型上面的，比如不能用List&lt;int&gt;，而只能用List&lt;Integer&gt;，好在有自动装箱autoboxinng和拆箱unboxing，所以List&lt;Integer&gt;也可以可以直接用于整数类型的。</p>

<h3>泛型不支持数组</h3>

<p>这里的意思是指不能用泛型去声明数组，比如List&lt;String&gt;[]，这是不允许的。（不要搞混混淆了，数组当作泛型的类型参数是完全可以的，如List&lt;int[]&gt;，因为数组是一个类型。）</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.codetab.org/tutorial/java-generics/introduction/">Java Generics Tutorial</a></li>
<li><a href="https://www.baeldung.com/java-generics">The Basics of Java Generics</a></li>
<li><a href="https://blogs.oracle.com/javamagazine/post/understanding-java-generics-part-1-principles-and-fundamentals">Understanding Java generics, Part 1: Principles and fundamentals</a></li>
<li><a href="https://blogs.oracle.com/javamagazine/post/understanding-java-generics-part-2-the-hard-part">Understanding Java generics, Part 2: The hard part</a></li>
<li><a href="https://www.geeksforgeeks.org/generics-in-java/">Generics in Java</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/java-generics-example-method-class-interface">Java Generics Example Tutorial - Generic Method, Class, Interface</a></li>
<li><a href="https://pdai.tech/md/java/basic/java-basic-x-generic.html">Java 基础 - 泛型机制详解</a></li>
<li><a href="https://juejin.cn/post/7249913673215836218">一文搞懂 java 泛型，也有可能搞不懂，毕竟讲得太全面了</a></li>
<li><a href="https://www.cnblogs.com/coprince/p/8603492.html">java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一</a></li>
<li><a href="https://betterprogramming.pub/a-deep-dive-into-java-wildcards-covariance-4d807a65f02">A Deep Dive Into Java Wildcards — Covariance</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[这回就好好聊聊Kotlin的泛型]]></title>
    <link href="http://toughcoder.net/blog/2024/03/04/kotlin-generics-made-easy/"/>
    <updated>2024-03-04T22:51:58+08:00</updated>
    <id>http://toughcoder.net/blog/2024/03/04/kotlin-generics-made-easy</id>
    <content type="html"><![CDATA[<p>泛型(Generics)是静态强类型编程语言中非常强大的特性，可以极大的加强代码的复用，并增强类型安全，减少运行时的类型转换错误。在这篇文章就来详细的学习一下Kotlin中对泛型的支持情况，并学会写出类型安全的可复用代码。</p>

<p><a href="http://toughcoder.net/blog/2024/03/04/kotlin-generics-made-easy/"><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.bl_F0aycuia6QRYMt4AOfQHaFc?rs=1&pid=ImgDetMain" title="auto auto" ></a></p>

<!-- more -->


<h2>泛型基础</h2>

<p>泛型的本质就是能够创建参数化的对象和函数，以实现复用。比如说，我们最熟悉的集合List，它是<strong>与具体类型无关</strong>的数据结构，或者叫做对象容器。列表List的重点在于可扩展长度，但里面具体的对象类型并不是重点，只要是一个对象就可以了。假如没有泛型，可能就要写很多重复的代码，比如字符串列表StringList，数字列表NumberList，等等。用泛型，只<strong>用一个参数化</strong>的List就可以了，用尖括号<strong>&lt;&gt;</strong>来表示参数化。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">names</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="s">&quot;James&quot;</span><span class="p">,</span> <span class="s">&quot;Kevin&quot;</span><span class="p">,</span> <span class="s">&quot;Harden&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">val</span> <span class="py">rebounds</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">14</span><span class="p">,</span> <span class="m">7</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>泛型有两种形式，一种是对类进行参数化如List<String>，一种是对函数进行参数化，如max<Int>()。</p>

<h3>参数化的类</h3>

<p>声明方式就是在声明类的时候在类的名字后面用尖括号<strong>&lt;&gt;</strong>来带上一个类型参数，然后在内部就可以当成一个类型来使用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">Box</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">t</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">var</span> <span class="py">value</span> <span class="p">=</span> <span class="n">t</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这就创建了一个参数化的容器，它可以持有任何指定类型的对象：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">box</span><span class="p">:</span> <span class="n">Box</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Box</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;(</span><span class="m">1</span><span class="p">)</span>
</span><span class='line'><span class="k">val</span> <span class="py">case</span><span class="p">:</span> <span class="n">Box</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Box</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;(</span><span class="s">&quot;Coat&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>参数化的函数</h3>

<p>除了参数化的类以外，还可以创建参数化的函数，在函数名字的前面用尖括号<strong>&lt;&gt;</strong>来声明泛型，然后在参数列表以及函数体内就可以当作类型来使用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="err">&lt;</span><span class="nf">T</span><span class="p">&gt;</span> <span class="n">singleTonList</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">T</span><span class="p">):</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>调用的时候指定一下具体的类型就可以了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">l</span> <span class="p">=</span> <span class="n">singletonList</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;(</span><span class="m">3</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>注意：</strong>Kotlin语言有强大的类型推断能力，但凡编译器能够推断出类型时，类型的声明都可以省略掉。对于泛型更是如此，比如说，这样写都是合法的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">names</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="s">&quot;James&quot;</span><span class="p">,</span> <span class="s">&quot;Kevin&quot;</span><span class="p">,</span> <span class="s">&quot;Harden&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">val</span> <span class="py">rebounds</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">14</span><span class="p">,</span> <span class="m">7</span><span class="p">)</span>
</span><span class='line'><span class="k">val</span> <span class="py">l</span> <span class="p">=</span> <span class="n">singletonList</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>通常情况下，<strong>声明</strong>，<strong>定义</strong>和<strong>赋值</strong>三个地方，只要有一个地方能够让编译器知道具体的类型就够了，其他地方都可以把类型的声明省略掉。</p>

<h2>泛型的本质与优点</h2>

<p>假如不使用泛型，又想写出比较通用的类和函数，唯一可行的方法就是使用通用基类Any当作参数，在Kotlin中Any是所有对象的基类，比如，说想实现一个列表：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">AnyList</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">fun</span> <span class="nf">add</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span>
</span><span class='line'>  <span class="k">fun</span> <span class="nf">get</span><span class="p">(</span><span class="n">idx</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Any</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样写可以，但它有很大的问题，就是不能保证类型安全：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">list</span> <span class="p">=</span> <span class="n">AnyList</span><span class="p">()</span>
</span><span class='line'><span class="n">list</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;James&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">list</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="m">13</span><span class="p">)</span>
</span><span class='line'><span class="k">val</span> <span class="py">e</span> <span class="p">=</span> <span class="p">(</span><span class="n">Int</span><span class="p">)</span> <span class="n">list</span><span class="p">.</span><span class="k">get</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>一方面我们需要自己进行强行类型转换，但也无法保证你取出来的对象类型与期望的是一致的，更无法保证调用者往里面添加什么对象，因为任何Any的子类都可以让代码通过编译，但在运行时极容易发生类型转换异常ClassCastException。</p>

<p>但用泛型就能很好的解决这个问题，可以得出泛型的优点：</p>

<ol>
<li>不需要做类型转换，编译器会根据指定的具体类型自动做类型转换</li>
<li>类型安全，编译器会帮助做检查，传给泛型的对象必须具有一致的类型，且是指定的类型</li>
<li>保障了运行时的类型安全，因为编译器在编译时做好了检查，所以不会发生运行时的类型错误</li>
</ol>


<p>因此，凡是有需要针对 类型复用的地方，都应该用泛型来实现类型参数化。</p>

<h2>关键字out和关键字in</h2>

<p>大部分情况下，只要给类型和函数加上参数化的类型就够了，但有时候有些复杂情况需要处理。</p>

<h3>协变与逆变</h3>

<p><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98">协变与逆变Covariance and Contravariance</a>是用来描述具有父子继承关系的简单类型，在通过参数化的方法构造出来的更复杂的类型之间是否能保持父子关系的术语。</p>

<p>比如Dog是Animal的子类，根据继承和多态，Dog可以用在任何声明为Animal的语句和表达式中。<strong>变型Variance</strong>指的就是根据已知的父子关系Dog和Animal，如何来确定由它们构成的更复杂类型如List&lt;Dog&gt;和List&lt;Animal&gt;之间的关系？</p>

<p>常规泛型是<strong>不可变的Invariant</strong>，也就是说复杂类型之间的关系与它们具体的参数化类型之间是没有关系的，如List&lt;Dog&gt;并不是List&lt;Animal&gt;，它们之间没有任何关系，不能把List&lt;Dog&gt;当成是List&lt;Animal&gt;，虽然Dog可以被当作Animal。</p>

<p>不可变Invariant有时候会带来不方便，比如说，集合通常都有addAll方法来批量的把对象加入到集合中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">fun</span> <span class="nf">addAll</span><span class="p">(</span><span class="n">from</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="k">in</span> <span class="n">from</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">val</span> <span class="py">objs</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Any</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">emptyList</span><span class="p">()</span>
</span><span class='line'><span class="k">val</span> <span class="py">names</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="s">&quot;James&quot;</span><span class="p">,</span> <span class="s">&quot;Kevin&quot;</span><span class="p">,</span> <span class="s">&quot;Harden&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">objs</span><span class="p">.</span><span class="n">addAll</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="c1">// No go, compile error</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是参数化列表集合，先创建一个具体类型为Any的列表，然后尝试把一个String列表添加到Any列表中，其实这么做是完全安全的，因为String对象是完全可以当作其基类Any来使用的，但泛型的不可变性阻止了我们这么做。</p>

<p>这时就需要<strong>协变</strong>与<strong>逆变</strong>了，也就是通过一定的方法让复杂类型的行为与其参数化类型之间进行协同。</p>

<p><img src="https://phpstan.org/covariance-contravariance.4483af19.png" alt="" /></p>

<h3>关键字out进行协变</h3>

<p>使用out关键能够让泛型进行协变。比如上面例子理想的情况应该是，只要能当作T的类型，都应该能用在addAll中，换句话说把T的子类的列表也应该能够支持，即objs.addAll(names)应该能正常编译并正常运行。使用关键out即可达到这样的效果：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">List</span><span class="p">&lt;</span><span class="k">out</span> <span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">fun</span> <span class="nf">addAll</span><span class="p">(</span><span class="n">from</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">for</span> <span class="p">(</span><span class="n">x</span> <span class="k">in</span> <span class="n">from</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">val</span> <span class="py">objs</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Any</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">emptyList</span><span class="p">()</span>
</span><span class='line'><span class="k">val</span> <span class="py">names</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="s">&quot;James&quot;</span><span class="p">,</span> <span class="s">&quot;Kevin&quot;</span><span class="p">,</span> <span class="s">&quot;Harden&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">objs</span><span class="p">.</span><span class="n">addAll</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="c1">// Okay</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的泛型参数from: List<out T>其实是一个生产者，它生产类型为T的对象，所以这里用out来修饰，产出的对象是T或者是T的子类都是会是合法的。或者说当我们想把一个子类的泛型赋给父类的泛型时，就需要对泛型声明为out，以进行协变。</p>

<p><strong>注意：</strong>关键字out与Java泛型中的extend通配符的作用是一样的，指定参数的上限，生产者产生的对象都会向上转型(upcast)为基类，所以需要指定一个上限。</p>

<p>与之相对的，还有in逆变。</p>

<h3>关键字in进行逆变</h3>

<p>有时候情况是相反的，也就是说我们持有的是父类的泛型，但 我们想把它赋给其子类的泛型，这时就可以用in进行逆变。而且必须注意in只能用在消费者中，也就是说是在真实消费对象，为什么呢？其实这里真实发生的是向下转型(downcast)&ndash;把父类的对象赋给子类的引用上面，而向下转型不一定保证是安全的。所以，必须是在真实消费这个对象的地方，只有是期望的真实对象才能被消费。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">ParameterizedConsumer</span><span class="p">&lt;</span><span class="k">in</span> <span class="n">T</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">fun</span> <span class="nf">toString</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">):</span> <span class="n">String</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">value</span><span class="p">.</span><span class="n">toString</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="py">parameterizedConsumer</span> <span class="p">=</span> <span class="n">ParameterizedConsumer</span><span class="p">&lt;</span><span class="n">Number</span><span class="p">&gt;()</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="py">ref</span><span class="p">:</span> <span class="n">ParameterizedConsumer</span><span class="p">&lt;</span><span class="n">Double</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">parameterizedConsumer</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>注意：</strong>关键字in与Java泛型中的super是一样的，指定一个下限，因为在消费对象时会转成T，用T来限制成为下限，那么向下转型(downcast)就是安全的。</p>

<h2>任意类型的泛型</h2>

<p>有些比较简单粗暴的场景，就是单纯的想让任意类型的泛型都可以使用，这时关键字out和关键字in可能都不太合适，因为它们只能用于生产者和消费者场景，用以指定类型上限和类型下限。这时可以用<strong>星号&#42;</strong>来当用泛型参数，以表示任意具体类型的泛型都可以使用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">printArray</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;*&gt;)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">array</span><span class="p">.</span><span class="n">forEach</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="py">array</span> <span class="p">=</span> <span class="n">arrayOf</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">2</span><span class="p">,</span><span class="m">3</span><span class="p">)</span>
</span><span class='line'><span class="n">printArray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>关键字reified</h2>

<h3>运行时泛型擦除</h3>

<p>需要注意的是泛型类型在运行时会被擦除(erased)，也就是说在运行时任何对象都是不带有其泛型类型的，具体点的，就是List&lt;String&gt;和List&lt;Int&gt;在运行时，它们的对象实例是一样的，无法知道它们的具体的泛型参数类型。前面讲的各种规则都是发生在编译时间，编译器帮助检查传入的泛型对象是否符合规划，并进行类型转换。到了运行时，泛型类型会被擦除。(为啥会被擦除呢？因为JVM要保持向后兼容，早期的Java没有泛型，只有原始的类型对象(raw type)，所以后来1.5版本后加入的泛型只有擦除掉变成raw type才能保持兼容。)</p>

<h3>关键字reified</h3>

<p>泛型类型擦除会带来一个问题，就是对于泛型类型对象，无法做类型检查(is T)，无法做类型转换(as T)，因为运行时的对象根本不知道它的泛型类型是什么，这会带来极大的不方便，特别是工厂方法就无法使用泛型了，因为无法做类型检查 和转换。</p>

<p>这时inline再加上关键字reified就能完美的解决问题，它们两个配合起来运行时就能保留泛型类型了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">inline</span> <span class="k">fun</span> <span class="err">&lt;</span><span class="nf">reified</span> <span class="n">T</span><span class="p">&gt;</span> <span class="n">Iterable</span><span class="p">&lt;*&gt;.</span><span class="n">filterIsInstance</span><span class="p">()</span> <span class="p">=</span> <span class="n">filter</span> <span class="p">{</span> <span class="n">it</span> <span class="k">is</span> <span class="n">T</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">&gt;&gt;</span> <span class="k">val</span> <span class="py">set</span> <span class="p">=</span> <span class="n">setOf</span><span class="p">(</span><span class="s">&quot;1984&quot;</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="s">&quot;Brave new world&quot;</span><span class="p">,</span> <span class="m">11</span><span class="p">)</span>
</span><span class='line'><span class="p">&gt;&gt;</span> <span class="n">println</span><span class="p">(</span><span class="k">set</span><span class="p">.</span><span class="n">filterIsInstance</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;())</span>
</span><span class='line'><span class="na">[2, 3, 11]</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到类型判断起来作用了。再看一个泛型工厂方法的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">inline</span> <span class="k">fun</span> <span class="err">&lt;</span><span class="nf">reified</span> <span class="n">T</span><span class="p">&gt;</span> <span class="n">logger</span><span class="p">():</span> <span class="n">Logger</span> <span class="p">=</span> <span class="n">LoggerFactory</span><span class="p">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">T</span><span class="o">::</span><span class="k">class</span><span class="p">.</span><span class="n">java</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">User</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">private</span> <span class="k">val</span> <span class="py">log</span> <span class="p">=</span> <span class="n">logger</span><span class="p">&lt;</span><span class="n">User</span><span class="p">&gt;()</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>练习</h2>

<p>这里强烈推荐谷歌官方给出的关于Kotlin语言中的<a href="https://developer.android.com/codelabs/basic-android-kotlin-compose-generics#0">类型相关的小练习</a>，可以用来巩固加强一下所学的知识。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/generics.html">Generics: in, out, where</a></li>
<li><a href="https://www.geeksforgeeks.org/kotlin-generics/">Kotlin generics</a></li>
<li><a href="https://www.baeldung.com/kotlin/generics">Generics in Kotlin</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32583310">Kotlin 泛型中的 in 和 out</a></li>
<li><a href="https://blog.csdn.net/u011897062/article/details/130832411">Kotlin泛型＜in, out, where＞概念及示例</a></li>
<li><a href="https://rengwuxian.com/kotlin-generics/">Kotlin 的泛型</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一文带你吃透Kotlin类与对象]]></title>
    <link href="http://toughcoder.net/blog/2024/02/26/kotlin-class-made-easy/"/>
    <updated>2024-02-26T21:22:39+08:00</updated>
    <id>http://toughcoder.net/blog/2024/02/26/kotlin-class-made-easy</id>
    <content type="html"><![CDATA[<p>Kotlin是多范式通用编程语言，对面向对象编程(OOP)自然也提供了全方位的支持。通过<a href="http://toughcoder.net/blog/2018/05/17/introduction-to-kotlin-programming-language/">先前一篇文章</a>，学习了使用Kotlin进行基本面向对象编程的方法，本文将在前文基础之上继续深入的学习面向对象编程的高级特性，以能够写出更加符合OO的代码，并能够从容应对一些复杂的OOP场景。</p>

<p><a href="http://toughcoder.net/blog/2024/02/26/kotlin-class-made-easy/"><img src="https://bigknol.com/wp-content/uploads/2023/07/kotlin_class_objects.png" title="auto auto" ></a></p>

<!-- more -->


<h2>注意构造的顺序</h2>

<p>在构造对象过程中，有三个地方可以对成员进行初始化：1）是在<strong>首构造方法（Primary constructor）</strong>；2）是在声明成员的同时进行初始化，或者是在<strong>初始化代码块(init {&hellip;})</strong>中；3）是在<strong>次要构造方法(Secondary constructor)</strong>中。</p>

<p>要注意它们之间的<strong>区别和执行顺序</strong>，首构造方法是最先执行的，但它不能运行代码，只能进行赋值；成员声明和初始化代码块(init {&hellip;})是首构造方法的一部分，因此要先于次要构造方法。次要构造方法是最后执行，并且次要构造方法一定要委托到首构造方法。成员声明和初始化代码块之间则依赖于书写的顺序，从上到下执行。</p>

<p>虽然编译器有它的规则来保障顺序，但为了可读性和可维护性，我们不应该完全依赖编译器。这里建议的方式是：</p>

<ul>
<li>把类的最核心的成员放在首构造方法，如必须要依赖的参数，公开的成员，类型体系中的核心成员等，这些应该直接放在首构造方法中，并按重要的顺序进行声明，这样也能方便进行依赖注入和测试Mock对象替换。</li>
<li>私有成员应该在类中声明，并且在声明时进行初始化，如果无法初始化就标记为延迟初始(late init)。</li>
<li>初始化代码块，应该做一些复杂的初始化过程，或者成员之间有关联的初始化，或者做一些构造完成之后的操作。比如像在ViewModel中，构造之后，可能执行拉取数据，这就非常适合放在init {&hellip;}之中。</li>
<li>不建议使用次要构造方法，可以用<strong>给首构造方法的参数设置默认值</strong>的方式来进行成员参数上的重载。</li>
<li>初始化代码块要放在所有成员声明之后，以保障执行顺序。</li>
</ul>


<p>扩展阅读<a href="https://kotlinlang.org/docs/classes.html">Classes﻿</a>和<a href="https://kotlinlang.org/docs/properties.html">Properties﻿</a>。</p>

<h2>妙用late init</h2>

<p>通常成员的初始化可以在声明时完成，比如像集合或者一些简单的原始类型对象（Int, Float, String等）。但如果初始化过程比较复杂，或者初始值较难获得，这种情况下，就适合标记为<strong>延迟初始化late init</strong>，然后在合适的时机对成员进行初始化（比如系统框架层的回调中，或者依赖注入等等）。使用一个未初始化的late init成员时会抛出一个叫做<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-uninitialized-property-access-exception/">UninitializedPropertyAccessException</a>的异常，可以在使用成员变量前用<a href="https://kotlinlang.org/docs/reflection.html#property-references">.isInitialized</a>来判断成员变量是否初始化过：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="p">.</span><span class="n">isInitialized</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="n">foo</span><span class="p">.</span><span class="n">bar</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以发现，对于Android 开发来说<strong>late init</strong>绝对非常有用，因为对于系统组件，我们无法在其构造方法中进行成员初始化，通常都是在第一个回调(如onCreate)中进行初始化，而这些变量全都应该用late init来标记。</p>

<p>另外，需要注意的是，成员是否有被初始化与成员是否是非法值(如null)并不是同一回事，初始化是第一次对成员对象赋值，赋的什么值(正常对象or null)虚拟机并不关心，但只要有过赋值后变量就初始化过了。因此，<strong>用late init可以帮助减少null检查</strong>。</p>

<p>还需要注意的是，延迟初始化late init与属性委托也不是同一回事，late init通常用于内部私有的成员变量，而属性委托通常用于对外开放的公开成员。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/properties.html">Properties</a>。</p>

<h2>函数式接口</h2>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.aCUdGlN1mIUaSZQXKdceSgHaD4?rs=1&amp;pid=ImgDetMain" alt="" /></p>

<p>接口(interfaces)是更高级别的抽象，专注于行为的抽象，用以实现对象间契约式行为交互。这一部分不打算详细讲解interface的使用，而是重点关注函数式接口(function interface)。Kotlin中的接口与Java 8中的接口是一样的，不再全是抽象方法了，可以有默认方法，也就是对接口的方法添加默认的实现，没有默认实现的方法就是抽象方法了（Abstract method）。只有一个抽象方法的接口称之为函数式接口(functional interface)，或者单个抽象方法接口(Single Abstract Method interface)。用fun interface来声明，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">interface</span> <span class="n">IntPredict</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">fun</span> <span class="nf">accept</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Boolean</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>函数式接口的最大优势在于，实现接口时可以简化到只用一个lambda，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">isEnv</span> <span class="p">=</span> <span class="n">IntPredict</span> <span class="p">{</span> <span class="n">it</span> <span class="p">%</span> <span class="m">2</span> <span class="p">==</span> <span class="m">0</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，只有用fun interface声明的含有一个抽象方法的接口才是函数式接口，才能用lambda。对于普通接口，如果它仅含有一个抽象方法，可以转化为函数式接口，比如原接口是酱紫的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">interface</span> <span class="n">Printer</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">fun</span> <span class="nf">print</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么，可以直接定义一个fun interface Printer就可以了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">interface</span> <span class="n">Printer</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">fun</span> <span class="nf">print</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>编译器会帮忙做转化。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/fun-interfaces.html">Functional (SAM) interfaces</a>。</p>

<h2>关键字object的妙用</h2>

<p>关键字object用以方便创建匿名对象的场景，如匿名对象，单例以及静态内部类。</p>

<h3>使用匿名对象</h3>

<p>有些时候我们会实现一些接口，或者继承某个基类，但仅是在本地一次性使用(One shot)，这时匿名对象就派上用场了，类似于Java中的匿名内部类。用<strong>object : </strong>后面跟要实现的接口或者要继承的类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">window</span><span class="p">.</span><span class="n">addMouseListener</span><span class="p">(</span><span class="k">object</span> <span class="err">: </span><span class="nc">MouseAdapter</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">override</span> <span class="k">fun</span> <span class="nf">mouseClicked</span><span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">MouseEvent</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">override</span> <span class="k">fun</span> <span class="nf">mouseEntered</span><span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">MouseEvent</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class='line'><span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<h3>单例对象</h3>

<p>用object可以非常方便的实现单例模式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">object</span> <span class="nc">DataProviderManager</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">fun</span> <span class="nf">registerDataProvider</span><span class="p">(</span><span class="n">provider</span><span class="p">:</span> <span class="n">DataProvider</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">val</span> <span class="py">allDataProviders</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">DataProvider</span><span class="p">&gt;</span>
</span><span class='line'>      <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用时就直接用类名就可以了：DataProviderManager.registerDataProvider(&hellip;)。</p>

<h3>静态成员和方法</h3>

<p><img src="https://ts1.cn.mm.bing.net/th/id/R-C.b4723d86a22037c40298fff12e484b19?rik=tyTmLVbaHs9Mpw&amp;pid=ImgRaw&amp;r=0" alt="" /></p>

<p>在Java中有静态的成员和方法，用以实现一些属于类的成员和方法，在Kotlin中就需要用companion object来实现同样的功能。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">companion</span> <span class="k">object</span> <span class="nc">Factory</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">fun</span> <span class="nf">create</span><span class="p">():</span> <span class="n">MyClass</span> <span class="p">=</span> <span class="n">MyClass</span><span class="p">()</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>使用时就是用类+方法：MyClass.create()。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/object-declarations.html">Object expressions and declarations</a>。</p>

<h2>纯数据类型</h2>

<p><img src="https://qwebtechnologies.com/blog/wp-content/uploads/2023/03/Kotlin-Data-Class.png" alt="" /></p>

<p>对于函数式编程，通常要写大量的<a href="https://en.wikipedia.org/wiki/Plain_old_Java_object">PoJo</a>用以在函数之间传递数据，这些对象最大的特点就是仅是数据，且不可变(Immutable)，通常的实现方式就是把成员变量全用final修饰（只读read only）。在Kotlin中，可以非常方便的定义这要的类型，即data class。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">data</span> <span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="k">val</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="k">val</span> <span class="py">age</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>针对data class，编译器会自动生成equals, hashCode, toString, copy和componentN方法。注意，虽然成员可以标记为var，但不建议这样做，最好还是都标记为只读val，因为data class就是要Immutable。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/data-classes.html">Data classes</a>。</p>

<h2>密封类和接口</h2>

<p>密封类和接口是指用<strong>关键字sealed</strong>修饰的类和接口。它的作用是限制类的层次结构，用sealed修饰的类和接口，它们的所有子类必须在编译的时候就已知，一旦编译完成，不允许再被继承。</p>

<p>密封类型特别适用于库的设计，能够保证库的完整性。通常用于修饰库中的一些关键的有明确类型要求的类型，如<strong>消息类型，错误类型</strong>等等。因为，库会预定义一些消息类型，以及处理消息的接口，假如调用者扩展了某一消息类型，加了很多自定义的东西，这时再用库中的接口来处理的时候，可能会产生未预期的行为，因为库可能不认识这个新的新的消息类型，但因为是子类继承，语法上是合法的。这时密封类型就能派上用场，把消息类型用sealed修饰，就能保证库的完备性，它提供的错误处理接口一定可以正确处理它定义的消息类型。但注意不能滥用，没有必要为库的每一个类和接口都用sealed修饰，其实大部分时候我们是用不到sealed的。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/sealed-classes.html">Sealed classes and interfaces</a>。</p>

<h2>类型别名</h2>

<p>一个非常有意思的特性是类型别名，并不是定义一个新类型，而是取个别名。一般情况下，是为了方便，比如目标类型名字太长时，或者有大量的泛型参数时，就可以为它定义一个别名，图个省流。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">typealias</span> <span class="n">NodeSet</span> <span class="p">=</span> <span class="n">Set</span><span class="p">&lt;</span><span class="n">Network</span><span class="p">.</span><span class="n">Node</span><span class="p">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="n">typealias</span> <span class="n">MyHandler</span> <span class="p">=</span> <span class="p">(</span><span class="n">Int</span><span class="p">,</span> <span class="n">String</span><span class="p">,</span> <span class="n">Any</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">Unit</span>
</span></code></pre></td></tr></table></div></figure>


<p>扩展阅读<a href="https://kotlinlang.org/docs/type-aliases.html">Type aliases</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[专家之路上的Flow高级秘籍]]></title>
    <link href="http://toughcoder.net/blog/2024/01/27/an-advanced-guide-to-kotlin-flow/"/>
    <updated>2024-01-27T20:59:38+08:00</updated>
    <id>http://toughcoder.net/blog/2024/01/27/an-advanced-guide-to-kotlin-flow</id>
    <content type="html"><![CDATA[<blockquote><p>『君不见，黄河之水天上来，奔流到海不复回。』</p></blockquote>

<p>学习与河流一样，一方面学无止境，又是逆水行舟，不进则退，因为其他人都在卷。<a href="http://toughcoder.net/blog/2024/01/25/kotlin-flow-made-easy/">前文一篇文章</a>讲了Flow的基础，大多数情况下够用了，但是不能停止卷，因为你不卷，就会被别人卷。一旦涉及到复杂的应用场景，就需要用到一些高级的API。今天就来学习一下Flow的高级特性，当遇到问题时也能更从容的应对。</p>

<p><a href="http://toughcoder.net/blog/2024/01/27/an-advanced-guide-to-kotlin-flow/"><img src="https://amitshekhar.me/static/images/blog/flow-api-in-kotlin.png" title="auto auto" ></a></p>

<!-- more -->


<h2>上下文切换</h2>

<p>Flow是基于协程的，是用协程来实现并发，前面也提到过像<a href="">flow {&hellip;}</a>，在上游生产数据，以及中游做变幻时，都是可以直接调用suspend，耗时甚至是阻塞的函数的。而终端操作符如<a href="">collect</a>则是suspend的，调用者（也就是消费者）需要负责确保collect是在协程中调用。我们还知道Flow是是冷流，消费者终端才会触发上游生产者生产，所以对于flow {&hellip;}来说，它的上游和中游运行的上下文来自于终端调用者的上下文，这个叫做『上下文保留』（context preservation），我们可以用一个&#127792; 来验证一下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Should be main by default</span>
</span><span class='line'>    <span class="n">simple</span><span class="p">().</span><span class="n">collect</span> <span class="p">{</span> <span class="n">log</span><span class="p">(</span><span class="s">&quot;Got: $it&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Collect in a specified context</span>
</span><span class='line'>    <span class="n">withContext</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">Default</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">simple</span><span class="p">().</span><span class="n">collect</span> <span class="p">{</span> <span class="n">log</span><span class="p">(</span><span class="s">&quot;Now got: $it&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span> <span class="k">fun</span> <span class="nf">simple</span><span class="p">():</span> <span class="n">Flow</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">flow</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">log</span><span class="p">(</span><span class="s">&quot;Started the simple flow&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">1.</span><span class="p">.</span><span class="m">3</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="m">100</span><span class="p">)</span>
</span><span class='line'>        <span class="n">log</span><span class="p">(</span><span class="s">&quot;Producing $i&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">emit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='Bash'><span class='line'><span class="o">[</span>main @coroutine#1<span class="o">]</span> Started the simple flow
</span><span class='line'><span class="o">[</span>main @coroutine#1<span class="o">]</span> Producing 1
</span><span class='line'><span class="o">[</span>main @coroutine#1<span class="o">]</span> Got: 1
</span><span class='line'><span class="o">[</span>main @coroutine#1<span class="o">]</span> Producing 2
</span><span class='line'><span class="o">[</span>main @coroutine#1<span class="o">]</span> Got: 2
</span><span class='line'><span class="o">[</span>main @coroutine#1<span class="o">]</span> Producing 3
</span><span class='line'><span class="o">[</span>main @coroutine#1<span class="o">]</span> Got: 3
</span><span class='line'><span class="o">[</span>DefaultDispatcher-worker-1 @coroutine#1<span class="o">]</span> Started the simple flow
</span><span class='line'><span class="o">[</span>DefaultDispatcher-worker-1 @coroutine#1<span class="o">]</span> Producing 1
</span><span class='line'><span class="o">[</span>DefaultDispatcher-worker-1 @coroutine#1<span class="o">]</span> Now got: 1
</span><span class='line'><span class="o">[</span>DefaultDispatcher-worker-1 @coroutine#1<span class="o">]</span> Producing 2
</span><span class='line'><span class="o">[</span>DefaultDispatcher-worker-1 @coroutine#1<span class="o">]</span> Now got: 2
</span><span class='line'><span class="o">[</span>DefaultDispatcher-worker-1 @coroutine#1<span class="o">]</span> Producing 3
</span><span class='line'><span class="o">[</span>DefaultDispatcher-worker-1 @coroutine#1<span class="o">]</span> Now got: 3
</span></code></pre></td></tr></table></div></figure>


<p>从这个&#127792; 可以清楚的看到，Flow的context是来自于终端调用者的。</p>

<h3>用flowOn来指定上下文</h3>

<p>有时候使用终端调用者的上下文可能不太方便，因为生产者与消费者的模式其实是解耦的，它们不应该相互受制于对方，对于关键的并发的上下文更是如此。比如说在GUI的应用中，明显应该在工作线程中生产数据，在UI线程中消费数据，从上面的例子来看，由终端调用者来决定上游上下文明显不可取。有同学举手了，欺负我没学过协程是吧？我可以在Flow内部使用withContext来指定上下文啊，我们来试试：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Should be main by default</span>
</span><span class='line'>    <span class="n">simple</span><span class="p">().</span><span class="n">collect</span> <span class="p">{</span> <span class="n">log</span><span class="p">(</span><span class="s">&quot;Got: $it&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span> <span class="k">fun</span> <span class="nf">simple</span><span class="p">():</span> <span class="n">Flow</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">flow</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">withContext</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">Default</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">log</span><span class="p">(</span><span class="s">&quot;Started the simple flow&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">1.</span><span class="p">.</span><span class="m">3</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">delay</span><span class="p">(</span><span class="m">100</span><span class="p">)</span>
</span><span class='line'>            <span class="n">log</span><span class="p">(</span><span class="s">&quot;Producing $i&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">emit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这位同学可以直接出去了，因为你的代码crash 了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Bash'><span class='line'><span class="o">[</span>DefaultDispatcher-worker-1 @coroutine#1<span class="o">]</span> Started the simple flow
</span><span class='line'><span class="o">[</span>DefaultDispatcher-worker-1 @coroutine#1<span class="o">]</span> Producing 1
</span><span class='line'>Exception in thread <span class="s2">&quot;main&quot;</span> java.lang.IllegalStateException: Flow invariant is violated:
</span><span class='line'>      Flow was collected in <span class="o">[</span>CoroutineId<span class="o">(</span>1<span class="o">)</span>, <span class="s2">&quot;coroutine#1&quot;</span>:BlockingCoroutine<span class="o">{</span>Active<span class="o">}</span>@545486c7, BlockingEventLoop@13bfcf14<span class="o">]</span>,
</span><span class='line'>      but emission happened in <span class="o">[</span>CoroutineId<span class="o">(</span>1<span class="o">)</span>, <span class="s2">&quot;coroutine#1&quot;</span>:DispatchedCoroutine<span class="o">{</span>Active<span class="o">}</span>@27015c5a, Dispatchers.Default<span class="o">]</span>.
</span><span class='line'>      Please refer to <span class="s1">&#39;flow&#39;</span> documentation or use <span class="s1">&#39;flowOn&#39;</span> instead
</span></code></pre></td></tr></table></div></figure>


<p>意思大概是说Flow内部不让直接用withContext来切上下文，破坏了Flow的不变式，想切上下文要用flowOn。而且仔细看，异常是由emit函数抛出来的。</p>

<p>其实Flow的设计者已经考虑到了这个问题，并且给出了优雅的方式，如果想切换Flow内部（也即上游和中游）的运行上下文，要用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html">flowOn</a>函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Should be main by default</span>
</span><span class='line'>    <span class="n">simple</span><span class="p">().</span><span class="n">collect</span> <span class="p">{</span> <span class="n">log</span><span class="p">(</span><span class="s">&quot;Got: $it&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span> <span class="k">fun</span> <span class="nf">simple</span><span class="p">():</span> <span class="n">Flow</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">flow</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">log</span><span class="p">(</span><span class="s">&quot;Started the simple flow&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">1.</span><span class="p">.</span><span class="m">3</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="m">100</span><span class="p">)</span>
</span><span class='line'>        <span class="n">log</span><span class="p">(</span><span class="s">&quot;Producing $i&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">emit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>        <span class="n">Thread</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="m">50</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}.</span><span class="n">flowOn</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">Default</span><span class="p">)</span>
</span><span class='line'><span class="c1">//[DefaultDispatcher-worker-1 @coroutine#2] Started the simple flow</span>
</span><span class='line'><span class="c1">//[DefaultDispatcher-worker-1 @coroutine#2] Producing 1</span>
</span><span class='line'><span class="c1">//[main @coroutine#1] Got: 1</span>
</span><span class='line'><span class="c1">//[DefaultDispatcher-worker-1 @coroutine#2] Producing 2</span>
</span><span class='line'><span class="c1">//[main @coroutine#1] Got: 2</span>
</span><span class='line'><span class="c1">//[DefaultDispatcher-worker-1 @coroutine#2] Producing 3</span>
</span><span class='line'><span class="c1">//[main @coroutine#1] Got: 3</span>
</span></code></pre></td></tr></table></div></figure>


<p>这回就和谐多了，后台搞生产，UI只展示，完美！还需要特别注意的是<strong>函数flowOn只影响它的上游，不影响它的下游，更不会影响终端</strong>，终端永远都在<strong>其调用者的上下文</strong>中，来看一个&#127792; ：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">withContext</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">Main</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">singleValue</span> <span class="p">=</span> <span class="n">intFlow</span> <span class="c1">// will be executed on IO if context wasn&#39;t specified before</span>
</span><span class='line'>        <span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// Will be executed in IO</span>
</span><span class='line'>        <span class="p">.</span><span class="n">flowOn</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">IO</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">filter</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// Will be executed in Default</span>
</span><span class='line'>        <span class="p">.</span><span class="n">flowOn</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">Default</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">single</span><span class="p">()</span> <span class="c1">// Will be executed in the Main</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>第一个flowOn切到<em>IO</em>，只影响到它前面的创建和map，第二次切换到<em>Default</em>，只影响filter。single是终端，是在<em>Main</em>，因为它的调用者是在<em>Main</em>里面。</p>

<p><strong>注意，注意：</strong> Flow是一个数据流，保持其数据流的特点是相当重要的，无论是正常数据，异常数据，还是出错都是一种数据，应该让其自上而下的流动，在<strong>中游变幻时或者终端时通过操作符来处理</strong>。所以，像硬性的上下文切换，或者异常的try/catch都是不允许的。这就是所谓的流的不变性（Flow invariant）。后面讲异常时还会提到这点。</p>

<h2>任意上下文的Flow builders</h2>

<p>从前面的学习我们知道了，下下文保留的特性，终端会决定上游生产者的上下文，当然也可以通过flowOn来改变上下文。Flow builder其实就是一个生产者，异步的emit数据。但有些时候生产数据时的上下文，也就是调用emit时的上下文，是不确定的。比如说安卓 上面的各种回调（callback）有些是回调在调用者的线程里，有些则不是。<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow.html">flow {&hellip;}</a>中的emit就不能在异步的回调里面调用，这时就要用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/callback-flow.html">callbackFlow {&hellip;}</a>。callbackFlow专门适用于把现有的一些回调转为Flow，最典型的应用就是位置信息：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">locationFlow</span><span class="p">():</span> <span class="n">Flow</span><span class="p">&lt;</span><span class="n">Location</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">callbackFlow</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">val</span> <span class="py">listener</span> <span class="p">=</span> <span class="k">object</span> <span class="err">: </span><span class="nc">LocationListener</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">override</span> <span class="k">fun</span> <span class="nf">onLocationUpdate</span><span class="p">(</span><span class="n">loc</span><span class="p">:</span> <span class="n">Location</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">trySend</span><span class="p">(</span><span class="n">location</span><span class="p">)</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'>  <span class="n">locationManager</span><span class="p">.</span><span class="n">reqisterLocaitonUpdates</span><span class="p">(</span><span class="n">listener</span><span class="p">)</span>
</span><span class='line'>  
</span><span class='line'>  <span class="n">awaitClose</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">locationManager</span><span class="p">.</span><span class="n">unregisterLocationUpdates</span><span class="p">(</span><span class="n">listener</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果这个Flow，用flow {}去创建会抛异常，因为emit没法在回调中使用。callbackFlow会在回调中发射数据，并在<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/await-close.html">awaitClose</a>代码块中反注册回调以清理资源。awaitClose会在这个流结束时（完成或者被取消）被回调到，以有机会进行资源清理。</p>

<p>其实，无论是flow {}还是callbackFlow {}都是<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/channel-flow.html">channelFlow {}</a>的简单化，channelFlow非常复杂，也超级强大，它可以自带buffer，自带并发，适用于创建一些非常复杂的Flow。在多数时候flow {}和callbackFlow {}就够我们用了。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://stackoverflow.com/questions/61865744/android-kotlin-coroutines-what-is-the-difference-between-flow-callbackflow-ch">Android Kotlin Coroutines: what is the difference between flow, callbackFlow, channelFlow,&hellip; other flow constructors</a></li>
<li><a href="https://www.cnblogs.com/joy99/p/15805962.html">Kotlin 协程四 —— Flow 和 Channel 的应用 </a></li>
<li><a href="https://juejin.cn/post/7220593395420627004">[译]轻松学习Kotlin的Flow、ChannelFlow和CallbackFlow</a></li>
<li><a href="https://juejin.cn/post/7202265125540659259">轻松搞定Kotlin的Flow, ChannelFlow和CallbackFlow - 2</a></li>
</ul>


<h2>副作用函数</h2>

<p>Flow是一个数据流，核心思想是把数据的生产和处理和最终消费分开，上游只负责生产数据，各种操作都应该由中游操作符来做，最终数据由终端消费掉。需要加强数据的封装性，和流的不变性，不破坏管道，用各种转换器来对数据进行操作。那么，对于流何时开始，每个数据何时产生，流什么时候终止，这些事件对于调试来说是很有帮助的。Flow的设计者给出了一系列副作用函数来做之些事情。副作用的意思就是这些函数不会对流本身产生影响。</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-start.html">onStart</a> Flow开始生产之前会调用此函数。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html">onEach</a> 在生产(emit)每个数据之前调用此函数，这个函数最常用被用来打日志，以查看每个产生的数据。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-completion.html">onCompletion</a> 当Flow终止时或者被取消后会调用此函数。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-subscription.html">onSubscritpion</a> 有消费者了时调用此函数（也就是有人collect了此Flow时）。</li>
</ul>


<h2>异常，取消和错误处理</h2>

<p>这一小节重点来看看非正常代码逻辑的处理。先来看看异常处理（Exception handling）。</p>

<h3>用catch函数来处理Flow过程中的异常</h3>

<p>代码随时都可能抛出异常，所以异常处理是一个必须要考虑的事情。当然可以在Flow的各个节点如上游生产，中游变幻和下游终端的代码块里面各种try/catch。一来是不够优雅，再者这会破坏Flow的不变性或者说一致性，它就是管道，数据在里面流动，不应该加以过多的干扰，想要对数据处理应该用操作符。也就是说要让异常（包括其他错误也是如此）对Flow是透明的，意思是说Flow并不关心是否有异常。所以提供了一个<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html">catch函数</a>，它的作用是捕获并处理上游操作中发生的异常：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">simple</span><span class="p">()</span>
</span><span class='line'>    <span class="p">.</span><span class="k">catch</span> <span class="p">{</span> <span class="n">e</span> <span class="p">-&gt;</span> <span class="n">emit</span><span class="p">(</span><span class="s">&quot;Caught $e&quot;</span><span class="p">)</span> <span class="p">}</span> <span class="c1">// emit on exception</span>
</span><span class='line'>    <span class="p">.</span><span class="n">collect</span> <span class="p">{</span> <span class="n">value</span> <span class="p">-&gt;</span> <span class="n">println</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意catch与flowOn一样，只影响上游发生的异常，管不了下游：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">flow</span> <span class="p">{</span> <span class="n">emitData</span><span class="p">()</span> <span class="p">}</span>
</span><span class='line'>    <span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">computeOne</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="p">.</span><span class="k">catch</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// catches exceptions in emitData and computeOne</span>
</span><span class='line'>    <span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">computeTwo</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="p">.</span><span class="n">collect</span> <span class="p">{</span> <span class="n">process</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span> <span class="c1">// throws exceptions from process and computeTwo</span>
</span></code></pre></td></tr></table></div></figure>


<h3>取消Flow</h3>

<p>Flow没有显式的取消函数。Flow是冷流，有消费者时才会去生产数据，消费者停止消费了，Flow自然也就被取消了。终端操作都是suspend的，也就是要在协程中调用，因此<strong>取消终端调用的协程，就会取消Flow。</strong></p>

<h3>错误处理</h3>

<p>其实没有特别的错误处理函数，前面的异常算是一个，如果上游没有抛出异常，就不会有其他错误了，因为错误也是数据的一种类型，并且是由我们自己根据场景来定义的。比如说从网络获取新闻列表，正常时的数据当然是一个个的新闻条目。出错了，比如无网络，或者服务器无响应，这时可能返回一个空的条目，里面有错误的具体信息。但这都是由业务逻辑决定的，是业务逻辑层面的东西。对于Flow而言，都还是有数据的，都是一种数据，具体数据的解读，那是消费者终端的事情，Flow并不关心。</p>

<p>唯一算得上错误处理的函数就是<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-empty.html">onEmpty</a>，它会在Flow是空的时候，也就是不生产任何数据的时候被回调。可以在onEmpty里面生产emit数据，比如产生一个带有错误信息的数据，或者产生一个默认值。因为Flow为空，不产生emit任何数据时，管子是空的数据没有流动，Flow的整个链路，特别是终端collect是不会被执行的，这时可能会有问题，比如UI根本无法做出任何react，除非你设置过了默认UI状态，否则可能会不对。这个时候如果用onEmpty去产生一些默认值或者错误信息的话，就能激活整个Flow，终端能做出预期的响应。</p>

<h3>重试机制</h3>

<p>另一个非常有用的函数就是<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/retry.html">retry</a>，它可以预设一个条件，当条件满足时就会触发重新collect。Flow是冷流，有消费者collect时才会触发生产者emit数据，因此重新collect就能让Flow重新emit数据流。</p>

<h2>背压</h2>

<p>Flow是异步数据流，响应式编程范式，上游生产数据，下游终端消费数据。有时候可能会遇到这样一种情况，就是上游数据生产的速度超过了下游终端的消费速度，这会造成数据流积压在管道中，终端无法及时响应。这种情况称为『背压（Back pressure）』。想像一下一个水管，如果进水速度大于水龙头流出的速度，水就会积压在水管里，如果水管是比较薄弱的（如气球），那么它会膨胀，最后爆掉。</p>

<p>通常情况下，当上游是较为可控的生产者时，不会产生背压，但如果是一些不是开发人员可控的，如硬件（触摸事件，位置信息，传感器，摄像头），其他系统（系统框架的回调，或者服务器的Push）等等，就会产生背压，这时必须进行相应的处理。所有的FRP式异步数据流API都必须处理『背压』，Flow也有相应的API来处理：</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html">buffer</a> 把生产者的emit的数据缓存，然后用Channel以并发的方式流向中游和下游，可以简单理解为并发地调用collect。正常情况下Flow是顺序的（Sequentially），就是数据从上游到中游再到终端，按顺序流动，先生产的数据先流到collect，这就是顺序的数据流sequentially。用上buffer后，就是会是并发的流，先emit的数据不一定先到collect，这就是concurrently。明显，能用buffer的前提是终端处理数据时没有对数据顺序的依赖。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html">conflate</a> 也会像buffer一样启动并发式emit数据，但未能及时被终端消费掉的数据会被丢弃，终端只处理最新数据。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect-latest.html">collectLatest</a> 当有新的数据流出来时，终端只处理最新的数据，此之的终端处理会被取消掉（如果还没有处理完）。</li>
</ul>


<h2>转为热流</h2>

<p>常规的Flow都是冷的(cold flow)，但有时热流(hot flow)也有它的应用场景，Flow API中也有创建热流的方法。
<img src="https://koenig-media.raywenderlich.com/uploads/2021/05/StateFlowAndSharedFlow-twitter.png" alt="" /></p>

<h3>StateFlow</h3>

<p><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/">StateFlow</a>是一个『状态持有』流，它仅包含一个当前元素<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/value.html">value</a>，可以用过<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/update.html">update</a>来更新此状态。它是一个热流，可以有多个终端colloctor，每次更新都会把当前的值emit给所有的终端。</p>

<p>可以用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-state-flow.html">构造方法MutableStateFlow</a>创建一个StateFlow，或者通过函数<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/state-in.html">stateIn</a>来把一个冷流转化为一个StateFlow。</p>

<p>StateFlow是比较常用的，在安卓开发中，几乎所有的ViewModel都会用StateFlow来暂存UI状态数据。</p>

<h3>SharedFlow</h3>

<p>比StateFlow更为通用的便是通用的热流<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-shared-flow/">SharedFlow</a>。可以通过构造方法<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-shared-flow.html">MutableSharedFlow</a>来创建SharedFlow，或者通过函数<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/share-in.html">sharedIn</a>把一个冷流转为SharedFlow。</p>

<p>SharedFlow可以有多个终端collector，所以可以实现一对多的通知，如实现<a href="https://en.wikipedia.org/wiki/Observer_pattern">观察者模式</a>，或者像设置/配置更新，或者广播等等就可以考虑用SharedFlow来实现。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://developer.android.com/kotlin/flow/stateflow-and-sharedflow">StateFlow and SharedFlow</a></li>
<li><a href="https://juejin.cn/post/7314159614065131554">SharedFlow vs StateFlow，一篇看懂选择和使用技巧</a></li>
<li><a href="https://juejin.cn/post/7195569817940164668">Kotlin SharedFlow&amp;StateFlow 热流到底有多热？</a></li>
<li><a href="https://juejin.cn/post/7271832299339169844">ShareFlow与StateFlow实战</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[包教包会的Kotlin Flow教程]]></title>
    <link href="http://toughcoder.net/blog/2024/01/25/kotlin-flow-made-easy/"/>
    <updated>2024-01-25T23:17:51+08:00</updated>
    <id>http://toughcoder.net/blog/2024/01/25/kotlin-flow-made-easy</id>
    <content type="html"><![CDATA[<p>Kotlin中的<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/">Flow</a>是专门用于处理异步数据流的API，是<a href="https://en.wikipedia.org/wiki/Functional_reactive_programming">函数响应式编程范式(Functional Reactive Programming FRP)</a>在Kotlin上的一个实现，并且深度融合了Kotlin的协程。是Kotlin中处理异步数据流问题的首先方案。今天就来认识一下Flow并学会如何使用它。</p>

<p><a href="http://toughcoder.net/blog/2024/01/25/kotlin-flow-made-easy/"><img src="https://blog.mindorks.com/images/kotlin-flow-banner-image.png" title="auto auto" ></a></p>

<!-- more -->


<h2>Hello, Flow!</h2>

<p>老规矩，新学习一个新东西的时候，总是要从一个基础的『Hello, world』开始，快速上手体验，有个第一印象。我们就从一个简单的『Hello, Flow!』开始Flow之旅：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">simple</span> <span class="p">=</span> <span class="n">flow</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">listOf</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">,</span> <span class="s">&quot;world&quot;</span><span class="p">,</span> <span class="s">&quot;of&quot;</span><span class="p">,</span> <span class="s">&quot;flows!&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">forEach</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">delay</span><span class="p">(</span><span class="m">100</span><span class="p">)</span>
</span><span class='line'>                <span class="n">emit</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">simple</span><span class="p">.</span><span class="n">collect</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//Hello</span>
</span><span class='line'><span class="c1">//world</span>
</span><span class='line'><span class="c1">//of</span>
</span><span class='line'><span class="c1">//flows!</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里创建了一个异步产生String的数据流Flow&lt;String&gt;，会不定时的产生一个String，然后收集此数据流产生的数据，把流出的String对象消费掉。</p>

<p>可以看出Flow本质上是一个<strong>生产者消费者模式</strong>，流出的数据是由生产者产生的，且最终被消费者消费掉。可以把Flow想像成为一个<strong>生产线中的传送带</strong>，产品（数据）在上面不停的流动，经过各个站点的加工，最终成型，由消费者消费掉。从这个小例子中可以看出Flow API的三要素：数据流的<strong>上游</strong>是创建Flow（生产者）；<strong>中游</strong>是变幻操作（数据的处理和加工）；<strong>下游</strong>是收集数据（消费者），我们一一的详细来学习。</p>

<h2>创建Flow</h2>

<p>Flow是一个生产者，创建Flow也就是把数据放到传送带上。数据可以是基础数据或者集合，也可以是其他方式生成的数据，如网络或者回调或者硬件。创建Flow的API称作flow builder函数。</p>

<h3>用集合创建Flow</h3>

<p>这是创建Flow的最简单的方式，有两个，一个是<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-of.html">flowOf</a>用于从固定数量的元素创建，多用于示例，实际中基本上用不到：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">simple</span> <span class="p">=</span> <span class="n">flowOf</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">,</span> <span class="s">&quot;world&quot;</span><span class="p">,</span> <span class="s">&quot;of&quot;</span><span class="p">,</span> <span class="s">&quot;flows!&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">simple</span><span class="p">.</span><span class="n">collect</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者，通过<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/as-flow.html">asFlow</a>把现有的集合转为Flow，这个还是比较实用的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">listOf</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">,</span> <span class="s">&quot;world&quot;</span><span class="p">,</span> <span class="s">&quot;of&quot;</span><span class="p">,</span> <span class="s">&quot;flows!&quot;</span><span class="p">).</span><span class="n">asFlow</span><span class="p">()</span>
</span><span class='line'>  <span class="p">.</span><span class="n">collect</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="p">(</span><span class="m">1.</span><span class="p">.</span><span class="m">5</span><span class="p">).</span><span class="n">asFlow</span><span class="p">().</span><span class="n">collect</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>通用flow builder</h3>

<p>最为通用的flow builder就是<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow.html">flow {&hellip;}</a>了，这是最为通用，也是最为常用的构造器。在代码块中调用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html">emit</a>就可以了，这个代码块会运行在协程之中，所以在这个代码里可以调用suspend函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">simple</span> <span class="p">=</span> <span class="n">flow</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">1.</span><span class="p">.</span><span class="m">3</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">delay</span><span class="p">(</span><span class="m">100</span><span class="p">)</span>
</span><span class='line'>            <span class="n">println</span><span class="p">(</span><span class="s">&quot;Emitting: $i&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">emit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">simple</span><span class="p">.</span><span class="n">collect</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//Emitting: 1</span>
</span><span class='line'><span class="c1">//1</span>
</span><span class='line'><span class="c1">//Emitting: 2</span>
</span><span class='line'><span class="c1">//2</span>
</span><span class='line'><span class="c1">//Emitting: 3</span>
</span><span class='line'><span class="c1">//3</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是一个代码块，只要调用了emit产生数据即可，又可调用suspend函数，因此非常的实用，比如可以执行网络请求，请求回来后emit等等。</p>

<h2>终端操作符</h2>

<p>数据从生产者流出，直到消费者把数据收集起来进行消费，而只有数据被消费了才有意义。因此，还需要终端操作（Terminal flow operators）。需要注意的是终端操作符是Flow的终点，并不算是Flow传送带内部，因此终端操作都是suspend函数，调用者需要负责创建协程以正常调用这些suspending terminal operators。</p>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.WAtR3lx1-6aO3Cnsl3s3YgHaB7?rs=1&amp;pid=ImgDetMain" alt="" /></p>

<p>常见的终端操作有三个：</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html">collect</a> 最为通用的，可执行一个代码块，参数就是Flow流出的数据</li>
<li>转换为<a href="https://kotlinlang.org/docs/collections-overview.html">集合Collections</a>，如<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/to-list.html">toList</a>和<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/to-set.html">toSet</a>等，可以方便把收集到的数据转换为集合</li>
<li>取特定的值，如<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/first.html">first()</a>只取第一个，<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/last.html">last</a>只取最后一个, <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/single.html">single</a>只要一个数据（无数据和超过一个数据时都会抛异常。</li>
<li>降维（或者叫作聚合accumulate）操作，如折叠<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/fold.html">fold</a>和化约<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/reduce.html">reduce</a>，折叠和化约可以对数据流进行降维，如求和，求积，求最大值最小值等等。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/count.html">count</a> 其实也是降维的一种，返回数据流中的数据个数，它还可以结合过滤以计算某种过滤条件后的数据数量。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">simple</span> <span class="p">=</span> <span class="n">flow</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">1.</span><span class="p">.</span><span class="m">3</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">delay</span><span class="p">(</span><span class="m">100</span><span class="p">)</span>
</span><span class='line'>            <span class="n">println</span><span class="p">(</span><span class="s">&quot;Emitting: $i&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">emit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">simple</span><span class="p">.</span><span class="n">collect</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;toList: ${simple.toList()}&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;first: ${simple.first()}&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;sum by fold: ${simple.fold(0) { s, a -&gt; s + a }}&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='Bash'><span class='line'>Emitting: 1
</span><span class='line'>1
</span><span class='line'>Emitting: 2
</span><span class='line'>2
</span><span class='line'>Emitting: 3
</span><span class='line'>3
</span><span class='line'>Emitting: 1
</span><span class='line'>Emitting: 2
</span><span class='line'>Emitting: 3
</span><span class='line'>toList: <span class="o">[</span>1, 2, 3<span class="o">]</span>
</span><span class='line'>Emitting: 1
</span><span class='line'>first: 1
</span><span class='line'>Emitting: 1
</span><span class='line'>Emitting: 2
</span><span class='line'>Emitting: 3
</span><span class='line'>sum by fold: 6
</span></code></pre></td></tr></table></div></figure>


<p>这些终端操作符都简单，比较好理解，看一眼示例就知道怎么用了。需要注意的就是first()和single()，first是只接收数据流中的第一个，而single则要求数据流只能有一个数据（没有或者超过一个都会抛异常）。比较有意思就是last()，数据流是一个流，一个产品传送带，通常情况下都是指无限或者说不确定数据 数量时才叫数据流，那又何来最后一个数据呢？通常情况下last都是无意义的。只有当我们知道流的生产者只生产有限数量数据时，或者采用了一些限制性的变幻操作符时，last才能派上用场。</p>

<p>再有就是注意fold和reduce的区别，这里它们的区别跟集合上的操作是一样的，fold可以提供初始值，流为空时返回初始值；而reduce没初始值，流为空时会抛异常。</p>

<h2>变幻操作符</h2>

<p>数据在流动的过程中可以对数据进行转化操作，从一种数据类型变别另外一种，这就是变幻(Transformation)，这是数据流最为灵活和强大的一个方面。这跟<a href="https://kotlinlang.org/docs/collection-transformations.html">集合的变幻</a>是类似的。</p>

<p><img src="https://cdn-media-1.freecodecamp.org/images/1*ju5YD8bRZhdCGmptRQdmlw.png" alt="" /></p>

<h3>转换</h3>

<p>最常见的变幻就是转换，也就是把从一种数据类型转换为另一种数据类型，用的最多当然是<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html">map</a>，还有更为通用的<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/transform.html">transform</a>。它们都能把数据流中的数据从一种类型转换为另一种类型，比如把Flow<String>转为Flow<Int>。区别在于，map是死板的转换，一个对象进去，另一个对象作为返回值出来；但transform更为灵活，它并不是把新类型作为返回值，它可以像上游生产者那样产生(emit)新数据，甚至可以产生(emit)多个新数据，它是非常强大的，所有其他的变幻操作符，都是基于transform实现的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">simple</span> <span class="p">=</span> <span class="n">flow</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">1.</span><span class="p">.</span><span class="m">3</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">delay</span><span class="p">(</span><span class="m">100</span><span class="p">)</span>
</span><span class='line'>            <span class="n">println</span><span class="p">(</span><span class="s">&quot;Emitting: $i&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">emit</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">simple</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="s">&quot; Mapping to ${it * it}&quot;</span> <span class="p">}</span>
</span><span class='line'>        <span class="p">.</span><span class="n">collect</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">simple</span><span class="p">.</span><span class="n">transform</span> <span class="p">{</span> <span class="n">req</span> <span class="p">-&gt;</span>
</span><span class='line'>        <span class="n">emit</span><span class="p">(</span><span class="s">&quot; Making request $req&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">emit</span><span class="p">(</span><span class="n">performRequest</span><span class="p">(</span><span class="n">req</span><span class="p">))</span>
</span><span class='line'>    <span class="p">}.</span><span class="n">collect</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="nf">performRequest</span><span class="p">(</span><span class="n">req</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">=</span> <span class="s">&quot;Response for $req&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出是:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='Bash'><span class='line'>Emitting: 1
</span><span class='line'> Mapping to 1
</span><span class='line'>Emitting: 2
</span><span class='line'> Mapping to 4
</span><span class='line'>Emitting: 3
</span><span class='line'> Mapping to 9
</span><span class='line'>Emitting: 1
</span><span class='line'> Making request 1
</span><span class='line'>Response <span class="k">for</span> 1
</span><span class='line'>Emitting: 2
</span><span class='line'> Making request 2
</span><span class='line'>Response <span class="k">for</span> 2
</span><span class='line'>Emitting: 3
</span><span class='line'> Making request 3
</span><span class='line'>Response <span class="k">for</span> 3
</span></code></pre></td></tr></table></div></figure>


<p>还有一个操作符<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/with-index.html">withIndex</a>它与集合中的<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/map-indexed.html">mapIndexed</a>是类似的，它的作用是把元素变成IndexedValue，这样在后面就可以得到元素和元素的索引 了，在某些场景下还是比较方便的。</p>

<h3>限制</h3>

<p>数据流里面的数据不一定都是需要的，所以通常需要对数据元素进行过滤，这就是限制性操作符，最常见的就是<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/filter.html">filter</a>，这里与集合的限制操作也是类似的：</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/filter.html">filter</a> 把数据转为布尔型，从而对数据流进行过滤。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/distinct-until-changed.html">distinctUntilChanged</a> 过滤数据流中重复的元素。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/drop.html">drop</a> 丢弃前面一定数量的元素。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/take.html">take</a> 只返回流中前面一定数量的元素，当数量达到时流将被取消，注意take与drop是相反的。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/debounce.html">debounce</a> 仅保留流中一定超时间隔内的元素，比如超时时间是1秒，那只返回到达1秒时最新的元素，这个元素前面的将被丢弃。这个在秒杀场景拦截疯狂点击，或者一个服务中拦截疯狂请求时非常有用。只取一定时间间隔内的最新的元素，拦截掉无效数据。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/sample.html">sample</a> 以一定的时间间隔取元素，与debounce差不多，区别在于debounce会返回最后一个元素，而sample不一定，要看间隔最后一个元素能否落在一个时间间隔内。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@OptIn</span><span class="p">(</span><span class="n">FlowPreview</span><span class="o">::</span><span class="k">class</span><span class="p">)</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">constraint</span> <span class="p">=</span> <span class="n">flow</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">emit</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="m">90</span><span class="p">)</span>
</span><span class='line'>        <span class="n">emit</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="m">90</span><span class="p">)</span>
</span><span class='line'>        <span class="n">emit</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="m">1010</span><span class="p">)</span>
</span><span class='line'>        <span class="n">emit</span><span class="p">(</span><span class="m">4</span><span class="p">)</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="m">1010</span><span class="p">)</span>
</span><span class='line'>        <span class="n">emit</span><span class="p">(</span><span class="m">5</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">constraint</span><span class="p">.</span><span class="n">filter</span> <span class="p">{</span> <span class="n">it</span> <span class="p">%</span> <span class="m">2</span> <span class="p">==</span> <span class="m">0</span> <span class="p">}</span>
</span><span class='line'>        <span class="p">.</span><span class="n">collect</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;filter: $it&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">constraint</span><span class="p">.</span><span class="n">drop</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">collect</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;drop(3): $it&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">constraint</span><span class="p">.</span><span class="n">take</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">collect</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;take(3): $it&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">constraint</span><span class="p">.</span><span class="n">debounce</span><span class="p">(</span><span class="m">1000</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">collect</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;debounce(1000): $it&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">constraint</span><span class="p">.</span><span class="n">sample</span><span class="p">(</span><span class="m">1000</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">collect</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;sample(1000): $it&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>仔细看它们的输出，以理解它们的作用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='Bash'><span class='line'>filter: 2
</span><span class='line'>filter: 4
</span><span class='line'>drop<span class="o">(</span>3<span class="o">)</span>: 4
</span><span class='line'>drop<span class="o">(</span>3<span class="o">)</span>: 5
</span><span class='line'>take<span class="o">(</span>3<span class="o">)</span>: 1
</span><span class='line'>take<span class="o">(</span>3<span class="o">)</span>: 2
</span><span class='line'>take<span class="o">(</span>3<span class="o">)</span>: 3
</span><span class='line'>debounce<span class="o">(</span>1000<span class="o">)</span>: 3
</span><span class='line'>debounce<span class="o">(</span>1000<span class="o">)</span>: 4
</span><span class='line'>debounce<span class="o">(</span>1000<span class="o">)</span>: 5
</span><span class='line'>sample<span class="o">(</span>1000<span class="o">)</span>: 3
</span><span class='line'>sample<span class="o">(</span>1000<span class="o">)</span>: 4
</span></code></pre></td></tr></table></div></figure>


<p>需要留意，debounce和sample是Preview的API，需要<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-flow-preview/">加上Preview注解</a>。</p>

<p>中游的变幻操作符仍属于流的一部分，它们都仍运行在Flow的上下文中，因此，这些操作符内，与流的builder一样，都可以直接调用其他的supsend函数，甚至是其他的耗时的，阻塞的函数都可以调用。并不需要特别的为上游和中游创建上下文。</p>

<p>Flow的操作符特别多，我们需要留意区别中游操作符和下游终端。看这些函数的返回类型就可以了，返回类型是具体数据的，一定是下游终端操作符；而对于上游生产者和中游变幻操作符，其返回值一定是一个Flow。</p>

<h2>高级操作符</h2>

<p>前面讲的操作符都是针对 某一个流本身的，但大多数场景一个流明显不够用啊，我们需要操作多个流，这时就需要用到一些高级操作符了。</p>

<h3>合并多路流</h3>

<p>多路流不可能一个一个的处理，合并成为一路流更加的方便，有以下合并方法：</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/merge.html">归并merge</a>把<strong>数据类型相同的多路流归并为一路</strong>，注意一定是数据类型相同的才可以归并，并且归并后的元素顺序是未知的，也即不会保留原各路流的元素顺序。归并流的数量没有限制。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/zip.html">粘合zip</a> 当想要<strong>把两路流的元素对齐后粘合为一个元素</strong>时，就可以使用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/zip.html">zip</a>，当任何一个流结束或者被取消时，zip也就结束了。只能两个两个的粘合。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/combine.html">组合combine</a>把多路流中的每个流的最新元素粘合成新数据，形成一个新的流，其元素是把<strong>每个元素</strong>都用<strong>每路流的最新元素</strong>来转换生成。最少需要2路流，最多支持5路流。</li>
</ul>


<p>用一个&#127792;来感受一下它们的作用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">one</span> <span class="p">=</span> <span class="n">flowOf</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="n">Int</span><span class="o">::</span><span class="n">toString</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">onEach</span> <span class="p">{</span> <span class="n">delay</span><span class="p">(</span><span class="m">10</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">two</span> <span class="p">=</span> <span class="n">flowOf</span><span class="p">(</span><span class="s">&quot;a&quot;</span><span class="p">,</span> <span class="s">&quot;b&quot;</span><span class="p">,</span> <span class="s">&quot;c&quot;</span><span class="p">,</span> <span class="s">&quot;d&quot;</span><span class="p">)</span>
</span><span class='line'>                <span class="p">.</span><span class="n">onEach</span> <span class="p">{</span> <span class="n">delay</span><span class="p">(</span><span class="m">25</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">merge</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">collect</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;Merge: $it&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">one</span><span class="p">.</span><span class="n">zip</span><span class="p">(</span><span class="n">two</span><span class="p">)</span> <span class="p">{</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="p">-&gt;</span> <span class="s">&quot;Zip: $i. $s&quot;</span> <span class="p">}</span>
</span><span class='line'>        <span class="p">.</span><span class="n">collect</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">combine</span><span class="p">(</span><span class="n">one</span><span class="p">,</span> <span class="n">two</span><span class="p">)</span> <span class="p">{</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="p">-&gt;</span> <span class="s">&quot;Combine $i with $s&quot;</span> <span class="p">}</span>
</span><span class='line'>        <span class="p">.</span><span class="n">collect</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里是输出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='Bash'><span class='line'>Merge: 1
</span><span class='line'>Merge: 2
</span><span class='line'>Merge: a
</span><span class='line'>Merge: 3
</span><span class='line'>Merge: b
</span><span class='line'>Merge: c
</span><span class='line'>Merge: d
</span><span class='line'>Zip: 1. a
</span><span class='line'>Zip: 2. b
</span><span class='line'>Zip: 3. c
</span><span class='line'>Combine <span class="m">2</span> with a
</span><span class='line'>Combine <span class="m">3</span> with a
</span><span class='line'>Combine <span class="m">3</span> with b
</span><span class='line'>Combine <span class="m">3</span> with c
</span><span class='line'>Combine <span class="m">3</span> with d
</span></code></pre></td></tr></table></div></figure>


<p>通过它们的输出可以看到它们的区别：merge就像把两个水管接到一样，简单没有多余加工，适合数据类型一样的流（比如都是水）；zip会对齐两路流，让能对齐的元素两两结合，对不齐时就结束了。</p>

<p>而combine要等到<strong>集齐每路流的最新元素，才能转换成新数据</strong>，two是较one慢的，看到two的元素『a』时，one最新的元素是『2』，之后one的『3』来了，这时two最新的元素还是『a』，之后one停在了『3』，后续two的元素都与『3』组合。有同学可能会有疑问，为啥one的『1』丢弃了，没找到组合呢？因为它来的太早了，one的『1』来了时，two还没有元素，它肯定会等，但当two的第一个元素『a』来了时，这时one的最新元素已是『2』了，one是10发一个元素，two是隔25发一个元素，所以two的第1个元素到了时，one的第2个元素已经来了，它是最新的，所以组合时会用它。combine要集齐每路流的最新元素才能合成。</p>

<p>总结起来就是，<strong>zip会按顺序对齐元素</strong>；而combine要<strong>集齐每路流的最新元素</strong>，先要<strong>集齐</strong>，齐了时还要<strong>取每个流的最新元素</strong>。可以动手运行示例，修改delay的时间，看输出有啥不一样的，以加深理解。</p>

<h3>展平(Flatten)</h3>

<p>一个Flow就是一个异步数据流，它相当于一个传送带或者管道，货物（具体的数据）在其上面或者里面流动。正常情况下Flow内部都是常规数据（对象）在流动，但Flow本身也是一个对象，因此也可以嵌套，把流当成另一个流的数据，比如Flow&lt;Flow&lt;Int&gt;&gt;，这就是Flow of Flows of Int。Flow是数据流，最终消费者需要的是具体的数据，所以对于嵌套的Flow of Flows，通常都需要在传给终端操作符之前进行展平(flatten)，得到一个faltterned Flow（即从Flow&lt;Flow&lt;Int&gt;&gt;转成Flow&lt;Int&gt;），就可以被终端消费了。操作符中以flat开头的函数都是用于展平的，主要是两类，一类是<strong>展平flatten系</strong>，一类是<strong>先变幻再展平flatMap系</strong>。</p>

<h4>直接展平</h4>

<p>最直观的展平莫过于对于已经是嵌套的Flow of Flows做展平处理，以能让终端操作符正常的消费Flow里面的数据，有两个API可以做展平：</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flatten-concat.html">flattenConcat</a> 把嵌套的Flow of Flows展平为一个Flow，内层的每个流都是按顺序拼接在一起的，串行拼接。比如Flow of 4 Flows，内层有四个管道，那就就变成了『内层1』->『内层2』->『内层3』->『内层4』。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flatten-merge.html">flattenMerge</a> 把Flow of Flows展平为一个Flow，内层的所有Flow是以并发的方式将元素混合流入新管道，是并发式混合，相当于四个管道同时往另一个管道倒水，原流中的顺序会错乱掉。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@OptIn</span><span class="p">(</span><span class="n">ExperimentalCoroutinesApi</span><span class="o">::</span><span class="k">class</span><span class="p">)</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">flow2D</span> <span class="p">=</span> <span class="n">flowOf</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">,</span> <span class="s">&quot;world&quot;</span><span class="p">,</span> <span class="s">&quot;of&quot;</span><span class="p">,</span> <span class="s">&quot;flow!&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">toCharArray</span><span class="p">().</span><span class="n">map</span> <span class="p">{</span> <span class="n">c</span> <span class="p">-&gt;</span> <span class="s">&quot; &#39;$c&#39; &quot;</span> <span class="p">}.</span><span class="n">asFlow</span><span class="p">()</span> <span class="p">}</span>
</span><span class='line'>        <span class="p">.</span><span class="n">flowOn</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">Default</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">flow2D</span><span class="p">.</span><span class="n">collect</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;Flow object before flatten: $it&quot;</span><span class="p">)</span> <span class="p">}</span> <span class="c1">// Data in flow are Flow objects</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;With flattenConcat:&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">flow2D</span><span class="p">.</span><span class="n">flattenConcat</span><span class="p">()</span>
</span><span class='line'>        <span class="p">.</span><span class="n">collect</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;\nWith flattenMerge:&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">flow2D</span><span class="p">.</span><span class="n">flattenMerge</span><span class="p">()</span>
</span><span class='line'>        <span class="p">.</span><span class="n">collect</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//Flow object before flatten: kotlinx.coroutines.flow.FlowKt__BuildersKt$asFlow$$inlined$unsafeFlow$3@1b0375b3</span>
</span><span class='line'><span class="c1">//Flow object before flatten: kotlinx.coroutines.flow.FlowKt__BuildersKt$asFlow$$inlined$unsafeFlow$3@e580929</span>
</span><span class='line'><span class="c1">//Flow object before flatten: kotlinx.coroutines.flow.FlowKt__BuildersKt$asFlow$$inlined$unsafeFlow$3@1cd072a9</span>
</span><span class='line'><span class="c1">//Flow object before flatten: kotlinx.coroutines.flow.FlowKt__BuildersKt$asFlow$$inlined$unsafeFlow$3@7c75222b</span>
</span><span class='line'><span class="c1">//With flattenConcat:</span>
</span><span class='line'> <span class="c1">//&#39;H&#39;  &#39;e&#39;  &#39;l&#39;  &#39;l&#39;  &#39;o&#39;  &#39;w&#39;  &#39;o&#39;  &#39;r&#39;  &#39;l&#39;  &#39;d&#39;  &#39;o&#39;  &#39;f&#39;  &#39;f&#39;  &#39;l&#39;  &#39;o&#39;  &#39;w&#39;  &#39;!&#39; </span>
</span><span class='line'><span class="c1">//With flattenMerge:</span>
</span><span class='line'><span class="c1">// &#39;H&#39;  &#39;e&#39;  &#39;l&#39;  &#39;l&#39;  &#39;o&#39;  &#39;w&#39;  &#39;o&#39;  &#39;r&#39;  &#39;l&#39;  &#39;d&#39;  &#39;o&#39;  &#39;f&#39;  &#39;f&#39;  &#39;l&#39;  &#39;o&#39;  &#39;w&#39;  &#39;!&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<p>从输出中可以看出，如果不展平Flow里面是Flow对象，没法用。flattenConcat是把内层的流串行的接在一起。但flattenMerge的输出似乎与文档描述不太一致，并没有并发式的混合。</p>

<h4>先转换再展平</h4>

<p><img src="https://velog.velcdn.com/images/morning-la/post/59271fa7-8768-43f7-bebf-1387e77d8013/image.png" alt="" /></p>

<p>大多数时候并没有现成的嵌套好的Flow of Flows给你展平，更多的时候是我们需要自己把元素转换为一个Flow，先生成Flow of Flows，然后再展平，且有定义好的API可以直接用：</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-concat.html">flatMapConcat</a> 先把Flow中的数据做变幻，这个变幻必须从元素变成另一个Flow，这时就变成了嵌套式的Flow of Flows，然后再串行式展平为一个Flow。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html">flatMapLatest</a> 先把Flow中的最新数据做变幻，这个变幻必须从元素变成另一个Flow，这时会取消掉之前转换生成的内层流，结果虽然也是嵌套，但内层流只有一个，就是原Flow中最新元素转换生成的那个流。然后再展平，这个其实也不需要真展平，因为内层流只有一个，它里面的数据就是最终展平后的数据。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-merge.html">flatMapMerge</a> 与flatMapConcat一样，只不过展平的时候嵌套的内层流是以并发的形式来拼接的。</li>
</ul>


<p>来看个&#127792;就能明白它们的作用了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@OptIn</span><span class="p">(</span><span class="n">ExperimentalCoroutinesApi</span><span class="o">::</span><span class="k">class</span><span class="p">)</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">source</span> <span class="p">=</span> <span class="p">(</span><span class="m">1.</span><span class="p">.</span><span class="m">3</span><span class="p">).</span><span class="n">asFlow</span><span class="p">()</span>
</span><span class='line'>        <span class="p">.</span><span class="n">onEach</span> <span class="p">{</span> <span class="n">delay</span><span class="p">(</span><span class="m">100</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;With flatMapConcat:&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">start</span> <span class="p">=</span> <span class="n">System</span><span class="p">.</span><span class="n">currentTimeMillis</span><span class="p">()</span>
</span><span class='line'>    <span class="n">source</span><span class="p">.</span><span class="n">flatMapConcat</span><span class="p">(</span><span class="o">::</span><span class="n">requestFlow</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">collect</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;$it at ${System.currentTimeMillis() - start}ms from the start&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;With flatMapMerge:&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">start</span> <span class="p">=</span> <span class="n">System</span><span class="p">.</span><span class="n">currentTimeMillis</span><span class="p">()</span>
</span><span class='line'>    <span class="n">source</span><span class="p">.</span><span class="n">flatMapMerge</span><span class="p">(</span><span class="m">4</span><span class="p">,</span> <span class="o">::</span><span class="n">requestFlow</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">collect</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;$it at ${System.currentTimeMillis() - start}ms from the start&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;With flatMapLatest:&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">source</span><span class="p">.</span><span class="n">flatMapLatest</span><span class="p">(</span><span class="o">::</span><span class="n">requestFlow</span><span class="p">)</span>
</span><span class='line'>        <span class="p">.</span><span class="n">collect</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;$it at ${System.currentTimeMillis() - start}ms from the start&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="nf">requestFlow</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Flow</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">flow</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">emit</span><span class="p">(</span><span class="s">&quot; &gt;&gt;[$x]: First: $x&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">delay</span><span class="p">(</span><span class="m">150</span><span class="p">)</span>
</span><span class='line'>    <span class="n">emit</span><span class="p">(</span><span class="s">&quot; &gt;&gt;[$x]: Second: ${x * x}&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">delay</span><span class="p">(</span><span class="m">200</span><span class="p">)</span>
</span><span class='line'>    <span class="n">emit</span><span class="p">(</span><span class="s">&quot; &gt;&gt;[$x]: Third: ${x * x * x}&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出比较多：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='Bash'><span class='line'>With flatMapConcat:
</span><span class='line'> &gt;&gt;<span class="o">[</span>1<span class="o">]</span>: First: <span class="m">1</span> at 140ms from the start
</span><span class='line'> &gt;&gt;<span class="o">[</span>1<span class="o">]</span>: Second: <span class="m">1</span> at 306ms from the start
</span><span class='line'> &gt;&gt;<span class="o">[</span>1<span class="o">]</span>: Third: <span class="m">1</span> at 508ms from the start
</span><span class='line'> &gt;&gt;<span class="o">[</span>2<span class="o">]</span>: First: <span class="m">2</span> at 613ms from the start
</span><span class='line'> &gt;&gt;<span class="o">[</span>2<span class="o">]</span>: Second: <span class="m">4</span> at 765ms from the start
</span><span class='line'> &gt;&gt;<span class="o">[</span>2<span class="o">]</span>: Third: <span class="m">8</span> at 969ms from the start
</span><span class='line'> &gt;&gt;<span class="o">[</span>3<span class="o">]</span>: First: <span class="m">3</span> at 1074ms from the start
</span><span class='line'> &gt;&gt;<span class="o">[</span>3<span class="o">]</span>: Second: <span class="m">9</span> at 1230ms from the start
</span><span class='line'> &gt;&gt;<span class="o">[</span>3<span class="o">]</span>: Third: <span class="m">27</span> at 1432ms from the start
</span><span class='line'>With flatMapMerge:
</span><span class='line'> &gt;&gt;<span class="o">[</span>1<span class="o">]</span>: First: <span class="m">1</span> at 130ms from the start
</span><span class='line'> &gt;&gt;<span class="o">[</span>2<span class="o">]</span>: First: <span class="m">2</span> at 235ms from the start
</span><span class='line'> &gt;&gt;<span class="o">[</span>1<span class="o">]</span>: Second: <span class="m">1</span> at 284ms from the start
</span><span class='line'> &gt;&gt;<span class="o">[</span>3<span class="o">]</span>: First: <span class="m">3</span> at 341ms from the start
</span><span class='line'> &gt;&gt;<span class="o">[</span>2<span class="o">]</span>: Second: <span class="m">4</span> at 386ms from the start
</span><span class='line'> &gt;&gt;<span class="o">[</span>1<span class="o">]</span>: Third: <span class="m">1</span> at 486ms from the start
</span><span class='line'> &gt;&gt;<span class="o">[</span>3<span class="o">]</span>: Second: <span class="m">9</span> at 492ms from the start
</span><span class='line'> &gt;&gt;<span class="o">[</span>2<span class="o">]</span>: Third: <span class="m">8</span> at 591ms from the start
</span><span class='line'> &gt;&gt;<span class="o">[</span>3<span class="o">]</span>: Third: <span class="m">27</span> at 695ms from the start
</span><span class='line'>With flatMapLatest:
</span><span class='line'> &gt;&gt;<span class="o">[</span>1<span class="o">]</span>: First: <span class="m">1</span> at 807ms from the start
</span><span class='line'> &gt;&gt;<span class="o">[</span>2<span class="o">]</span>: First: <span class="m">2</span> at 915ms from the start
</span><span class='line'> &gt;&gt;<span class="o">[</span>3<span class="o">]</span>: First: <span class="m">3</span> at 1021ms from the start
</span><span class='line'> &gt;&gt;<span class="o">[</span>3<span class="o">]</span>: Second: <span class="m">9</span> at 1173ms from the start
</span><span class='line'> &gt;&gt;<span class="o">[</span>3<span class="o">]</span>: Third: <span class="m">27</span> at 1378ms from the start
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://velog.velcdn.com/images/morning-la/post/5d218551-4021-4a91-8b85-bf69beb786d6/image.png" alt="" /></p>

<p>这个示例中原始Flow是一个Int值，把它转换成为一个字符串流Flow&lt;String&gt;。从输出中可以看到flatMapConcat确实是串行拼接，并且flatMapMerge是并发式的混合，不保证内部Flow的元素顺序。仔细看flatMapLatest的输出，每当原始Flow中有新的值生成时，之前转换生成的流会被取消，它们并没有运行完（仅第一个元素流出了）。而原始流的最后一个元素『3』则完整的从展平流中流出了。</p>

<p>展平的函数比较多容易学杂，其实有一个非常简单的区分方法：带有<strong>Map字样</strong>的函数就是先把元素<strong>转换成Flow</strong>之后再展平；带有<strong>Concat</strong>就是把嵌套内层流<strong>串行拼接</strong>；而带有<strong>Merge</strong>的则是把内层流<strong>并发式的混合</strong>。使用的时候，如果<strong>想保证顺序就用带有Concat的函数；想要并发性，想高效一些，并且不在乎元素顺序，那就用带有Merge的函数。</strong></p>

<h2>Flow是冷流</h2>

<p>对于数据流来说有<strong>冷热</strong>之分，冷流(Cold stream)是指消费者开始接收数据时，才开始生产数据，换句话说就是生产者消费者整个链路搭建好了后，上游才开始生产数据；热流(Hot stream)，与之相反，不管有没有人在消费，都在生产数据。有一个非常形象的比喻就是，冷流就好比CD，你啥时候都可以听，而且只要你播放就从头开始播放CD上所有的音乐；而热流就好比电台广播，不管你听不听，它总是按它的节奏在广播，今天不听，就错过今天的数据了，今天听跟明天听，听到的内容也是不一样的。</p>

<p>Kotlin的<strong>Flow是冷流</strong>，其实从上面的例子也能看出来，每个例子中都是只创建一个Flow对象，然后有多次collect，但<strong>每次collect都能拿到Flow中完整的数据</strong>，这就是<strong>典型的冷流</strong>。绝大多数场景，我们需要的也都是冷流。</p>

<p>扩展阅读<a href="https://kt.academy/article/cc-hot-cold">Hot and cold data sources</a>。</p>

<h2>与ReactiveX的区别</h2>

<p>Flow是用于处理异步数据流的API，是函数响应式编程范式FRP的一个实现。但它并不是唯一的，更为<a href="https://github.com/ReactiveX/RxJava">流行的RxJava</a>也是符合FRP的异步数据流处理API，它出现的要更早，社区更活跃，资源更丰富，流行程度更高，基本上是每个安卓项目必备的依赖库，同时也是面试必考题。</p>

<p>因为Kotlin是基于JVM的衍生语言，它与Java是互通的，可以混着用。所以RxJava可以直接在Kotlin中使用，无需要任何改动。但毕竟RxJava是原生的Java库，Kotlin中的大量语法糖还是很香的，由此便有了<a href="https://github.com/ReactiveX/RxKotlin">RxKotlin</a>。RxKotlin并不是把<a href="https://reactivex.io/">ReactiveX规范</a>重新实现一遍，它只是一个轻量的粘合库，通过扩展函数和Kotlin的语法糖等，让RxJava更加的Kotlin友好，在Kotlin中使用RxJava时更加的顺滑。但核心仍是RxJava，如并发的实现仍是用线程。</p>

<p>那么Flow相较RxJava有啥区别呢？区别就在于Flow是纯的Kotlin的东西，它们背后的思想是一样的都是异步数据流，都是FRP，但Flow是原生的，它与Kotlin的特性紧密结合，比如它的并发是用协程通信用的是Channel。使用建议就是，如果本身对RxJava很熟悉，且是遗留代码，那就没有必要去再改成Flow；但如果是新开发的纯新功能，并且不与遗留代码交互，也没有与架构冲突，还是建议直接上Flow。</p>

<h2>什么时候用Flow</h2>

<p>每一个工具都有它特定的应用场景，Flow虽好，但不可滥用，要以架构的角度来认清问题的本质，符合才可以用。Flow是用于处理异步数据流的API，是FRP范式下的利器。因此，只当核心业务逻辑是由异步数据流驱动的场景时，用Flow才是合适的。现在绝大多数端（前端，客户端和桌面）GUI应用都是响应式的，用户输入了，或者服务器Push了数据，应用做出响应，所以都是符合FRP范式的。那么重点就在于数据流了，如果数据连串成流，就可以用Flow。比如用户输出，点击事件/文字输入等，这并不只发生一次，所以是数据流（事件流）。核心的业务数据，比如新闻列表，商品列表，文章列表，评论列表等都是流，都可以用Flow。配置，设置和数据库的变化也都是流。</p>

<p>但，一个单篇的文章展示，一个商品展示这就不是流，只有一个文章，即使用流，它也只有一个数据，而且我们知道它只有一个数据。这种情况就没有必要用Flow，直接用一个supsend请求就好了。</p>

<h2>在Android中使用Flow</h2>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2020/05/KotlinFlow-twitter.png" alt="" /></p>

<p>安卓开发的官方语言已经变成了Kotlin了，安卓应用也非常符合FRP范式，那么对于涉及异步数据流的场景自然要使用Flow。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://blog.mindorks.com/what-is-flow-in-kotlin-and-how-to-use-it-in-android-project/">What is Flow in Kotlin and how to use it in Android Project?</a></li>
<li><a href="https://developer.android.com/kotlin/flow">Kotlin flows on Android</a></li>
<li><a href="https://github.com/amitshekhariitbhu/Learn-Kotlin-Flow">Learn Kotlin Flow by real examples for Android</a></li>
</ul>


<h2>书籍推荐</h2>

<p>Flow本身的东西其实并不多，就是三板斧：创建，变幻和终端。但Flow背后的思想是很庞大的，想要用好Flow必须要学会函数响应式编程范式。也就是说只有学会以FRP范式来构建软件时，才能真正用好Flow。</p>

<p><a href="https://www.manning.com/books/functional-reactive-programming">《Functional Reactive Programming》</a></p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/flow.html">Asynchronous Flow</a></li>
<li><a href="https://amitshekhar.me/blog/flow-api-in-kotlin">Mastering Flow API in Kotlin</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin进阶之协程从上车到起飞]]></title>
    <link href="http://toughcoder.net/blog/2024/01/14/kotlin-coroutines-an-advanced-guide/"/>
    <updated>2024-01-14T21:17:20+08:00</updated>
    <id>http://toughcoder.net/blog/2024/01/14/kotlin-coroutines-an-advanced-guide</id>
    <content type="html"><![CDATA[<p>通过<a href="http://toughcoder.net/blog/2024/01/11/kotlin-coroutine-made-easy/">前面的一篇文章</a>我们理解了协程的基本概念，学会协程的基本使用方法，算是正式入门了，接下来就是要深入的学习技术细节和高级使用方法，以期完全掌握Kotlin协程并能熟练的正确的使用协程，发挥出协程应有的并发编程能力。</p>

<p><a href="http://toughcoder.net/blog/2024/01/14/kotlin-coroutines-an-advanced-guide/"><img src="https://repository-images.githubusercontent.com/61722736/08e87280-62dc-11ea-8fed-a8a4a4ea865d" title="auto auto" ></a></p>

<!-- more -->


<p>本篇为协程三步曲中的第二篇：</p>

<ul>
<li>初级篇：<a href="http://toughcoder.net/blog/2024/01/11/kotlin-coroutine-made-easy/">Kotlin进阶之协程从入门到放弃</a></li>
<li>高级篇：<a href="http://toughcoder.net/blog/2024/01/14/kotlin-coroutines-an-advanced-guide/">Kotlin进阶之协程从上车到起飞</a></li>
<li>终极篇：<a href="http://toughcoder.net/blog/2023/01/27/understanding-coroutines/">Kotlin进阶之协程从专家到出家</a></li>
</ul>


<p>本篇将细致的讨论协程中的一些重要的话题，以期更好的理解协程的原理和正确的使用协程，将从协程运行的上下文开始。</p>

<h2>深究协程上下文</h2>

<p><img src="https://files.betamax.kodeco.com/attachments/videos/3493/c049283d-193b-43b9-b796-0aafe8e9c804.png" alt="" /></p>

<p>创建协程的方法launch/async一共<strong>有3个参数</strong>，除了最后一个是协程的代码块以外，另外两个参数都是用来<strong>控制协程</strong>的，如协程上下文是用以控制协程运行环境的，包括在什么线程中去运行，句柄和树形关系以及何时切换线程，通过传递给launch/async的参数CoroutineContext。以及CoroutineStart就可以控制协程的运行。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">CoroutineScope</span><span class="p">.</span><span class="n">launch</span><span class="p">(</span>
</span><span class='line'>    <span class="n">context</span><span class="p">:</span> <span class="n">CoroutineContext</span> <span class="p">=</span> <span class="n">EmptyCoroutineContext</span><span class="p">,</span>
</span><span class='line'>    <span class="n">start</span><span class="p">:</span> <span class="n">CoroutineStart</span> <span class="p">=</span> <span class="n">CoroutineStart</span><span class="p">.</span><span class="n">DEFAULT</span><span class="p">,</span>
</span><span class='line'>    <span class="n">block</span><span class="p">:</span> <span class="n">suspend</span> <span class="n">CoroutineScope</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">Unit</span>
</span><span class='line'><span class="p">):</span> <span class="n">Job</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="err">&lt;</span><span class="nf">T</span><span class="p">&gt;</span> <span class="n">CoroutineScope</span><span class="p">.</span><span class="n">async</span><span class="p">(</span>
</span><span class='line'>    <span class="n">context</span><span class="p">:</span> <span class="n">CoroutineContext</span> <span class="p">=</span> <span class="n">EmptyCoroutineContext</span><span class="p">,</span>
</span><span class='line'>    <span class="n">start</span><span class="p">:</span> <span class="n">CoroutineStart</span> <span class="p">=</span> <span class="n">CoroutineStart</span><span class="p">.</span><span class="n">DEFAULT</span><span class="p">,</span>
</span><span class='line'>    <span class="n">block</span><span class="p">:</span> <span class="n">suspend</span> <span class="n">CoroutineScope</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">T</span>
</span><span class='line'><span class="p">):</span> <span class="n">Deferred</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>首先我们来看一下协程上下文对象CoroutineContext。</p>

<h3>CoroutineContext</h3>

<p><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/">CoroutineContext</a>是一个集合，具体元素类型是<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/-element/">Element</a>，Element重载了操作符，可以通过<strong>&#43;</strong>来形成集合。CoroutineContext是类似于Map的，每个Element有自己的Key，这是为了保证每个CoroutineContext对象中每个Key只能有一个Element对象。可以把CoroutineContext看成是Map，因此可以使用<strong>[]</strong>来获取Key对应的Element，如取Job，可以用context[Job]，取名字时可以用context[CoroutineName]等。</p>

<p>具体Element有四种：</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/">Job</a>：协程的句柄，或者说唯一标识，用以具体控制每个协程的（cancel和join等），具有树形关系</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/">CoroutineDispatcher</a>：用以指定协程的运行线程</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-name/">CoroutineName</a>：给协程取个名字，方便调试</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/">CoroutineExceptionHandler</a>：指定协程的异常处理器，用以处理未被捕获的异常</li>
</ul>


<p>这里主要介绍一下Job，CoroutineDispatcher和Name，至于ExceptionHandler留到后面讲异常处理时再细讲。</p>

<h4><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/">Job</a></h4>

<p>用launch创建一个协程时也会返回一个Job对象，它就是新创建的协程的句柄，但更好的方式是通过launch的参数，在上下文中指定一个Job对象作为协程的句柄。前面了讲过了，Job用以控制协程的，更为重要的是它能维持树形关系，父协程是可以控制子协程的，像cancel是会传导到所有的子协程的。自己创建Job对象就可以自由指定父协程，而不是默认的从CoroutineScope中继承。</p>

<p>另外，Job也会影响Exception handling，会在后面异常处理部分详细的讲。</p>

<h4><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/">CoroutineDispatcher</a></h4>

<p>这个是在平时用的最多的，因为协程是一种并发编程范式，而要想真并发，必然要涉及线程的切换，不可能指望着主线程把所有的事情都干了，而Dispatcher的作用就是用于主动的指定协程的运行线程。与Java中的Executor，和RxJava中的Schedulers作用是一样的。有一些预定义好的Dispatcher可以用，它们定义在<a href="">Dispatchers</a>里面：</p>

<ul>
<li><a href="">Main</a> 主线程，主函数所在的主线程，以及像UI框架（如Swing和Android）等的UI线程（主线程）</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/">IO</a> 适合I/O密集型的协程，如网络操作（上传/下载），文件读写，数据库读写等等。它背后是线程池，线程的数量是比较多的。因为<strong>I/O虽然耗时，但一般都耗在等待</strong>上面，所以线程的数量可以多一些。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html">Default</a> 适合CPU密集型的协程，比如计算类型的，图形的计算，矩阵计算，多媒体文件的编解码，压缩解压缩，或者算法时间复杂度较高的任务等等。也是线程池，线程的数量一般是CPU的核数。这个线程池的数量很少，因为<strong>这是CPU密集型的任务，需要大量占用着CPU，使CPU一直处于忙碌状态，因此线程数量即使多了，也是没有用处的，因为多创建的线程根本得不到操作系统的调试，没有多余的CPU给线程跑。</strong></li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html">Unconfied</a> 未给协程指定线程，协程会在当前的线程中执行（也就是调用者的线程），直到协程被挂起(suspended)。挂起后再继续(resume)时，由在恢复的线程中继续执行。很混乱吧，是的并发虽然讲究效率，虽然线程/协程啥时候进行，挂起并不能直接完全控制，但是我们仍希望并发要有秩序和确定性。一定要为新创建的协程指定其线程运行环境，因此，<strong>Unconfined不应该被使用</strong>。</li>
</ul>


<p>一般情况下，框架预定义好了的这些dispatcher已经够用了。但如果真的不够用，也可以自定义dispatcher，用扩展函数<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/as-coroutine-dispatcher.html">asCoroutineDispatcher</a>可以非常方便的把Java中的线程池Executors转化为dispatcher：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">dispatcher</span> <span class="p">=</span> <span class="n">Executors</span><span class="p">.</span><span class="n">newSingleThreadExecutor</span><span class="p">().</span><span class="n">asCoroutineDispatcher</span>
</span><span class='line'><span class="n">launch</span><span class="p">(</span><span class="n">dispatcher</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">delay</span><span class="p">(</span><span class="m">1000</span><span class="p">)</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Single thread dispatcher&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>CoroutineName</h4>

<p><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-name/">CoroutineName</a>是比较简单的结构，的构造方法可以传一个字符串用以指定协程的名字。协程的名字只有调试的意义，对于代码的运行没有任何影响。比如在调试的时候，或者在性能分析Profiling的时候，可以用名字更加方便的区分不同的协程，进而缩小调试的范围。</p>

<h3>CoroutineStart</h3>

<p><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/">CoroutineStart</a>，是一个枚举类型，用以控制协程的启动方式，具体有四种模式类型：</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-d-e-f-a-u-l-t/">DEFAULT</a> 默认，如果未指定这个参数 时也是默认模式，根据指定的上下文环境，立即调度此协程</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-l-a-z-y/">LAZY</a> 只有当需要此协程时才调度它。比较有意思，具体啥是<strong>需要</strong>呢，也就是当await其结果时，或者需要此协程去<strong>生产事件(produce)</strong>或者<strong>消费事件(consume)</strong>时。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-a-t-o-m-i-c/">ATOMIC</a> 以原子化的方式来调度此协程，也就是以不可取消的方式来调度协程。也就是说在协程代码块执行之前是不可取消的。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-u-n-d-i-s-p-a-t-c-h-e-d/">UNDISPATCHED</a> 在当前的线程环境（也就是调用者的线程）中立即执行协程直到协程的第一个挂起点。挂起之后，继续时则在指定的上下文中的线程运行。</li>
</ul>


<p>一般情况下，我们用默认的就行了。但当熟悉了协程以后，在适当的场景使用不同的启动方式参数可以更大限度的发挥协程的威力。</p>

<p>延展阅读：</p>

<ul>
<li><a href="https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html">Coroutine context and dispatchers</a></li>
<li><a href="https://juejin.cn/post/6926695962354122765">揭秘kotlin协程中的CoroutineContext</a></li>
<li><a href="https://juejin.cn/post/7270899168532152381">深入Kotlin协程系列|图解上下文</a></li>
<li><a href="https://juejin.cn/post/7137927889835524126">协程是怎么切换线程的</a></li>
</ul>


<h2>启动，挂起，让度和延续</h2>

<p>知道了如何创建协程，以及如何通过参数指定它运行的上下文和影响启动的参数后，就需要详细的了解一下协程的几中运行状态，以及什么是挂起，如何让度再到咋回到延续。</p>

<h3>协程的状态</h3>

<p>与Java中的线程类似，协程也是有几种不同的状态的，可以参考下表：</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 协程状态 </th>
<th style="text-align:left;"> 描述 </th>
<th style="text-align:center;"> isActive </th>
<th style="text-align:center;"> isCompleted </th>
<th style="text-align:center;"> isCancelled </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> New </td>
<td style="text-align:left;"> 协程刚被创建，但还未被调度，未运行 </td>
<td style="text-align:center;"> false </td>
<td style="text-align:center;"> false </td>
<td style="text-align:center;"> false </td>
</tr>
<tr>
<td style="text-align:center;"> Active </td>
<td style="text-align:left;"> 已被调度，已运行 </td>
<td style="text-align:center;"> true </td>
<td style="text-align:center;"> false </td>
<td style="text-align:center;"> false </td>
</tr>
<tr>
<td style="text-align:center;"> Completing </td>
<td style="text-align:left;"> 等待子协程结束中 </td>
<td style="text-align:center;"> true </td>
<td style="text-align:center;"> false </td>
<td style="text-align:center;"> false </td>
</tr>
<tr>
<td style="text-align:center;"> Cancelling </td>
<td style="text-align:left;"> cancel子协程中 </td>
<td style="text-align:center;"> false </td>
<td style="text-align:center;"> false </td>
<td style="text-align:center;"> true </td>
</tr>
<tr>
<td style="text-align:center;"> Cancelled </td>
<td style="text-align:left;"> 已被取消，是最终状态 </td>
<td style="text-align:center;"> false </td>
<td style="text-align:center;"> true </td>
<td style="text-align:center;"> true </td>
</tr>
<tr>
<td style="text-align:center;"> Completed </td>
<td style="text-align:left;"> 已结束，是最终状态 </td>
<td style="text-align:center;"> false </td>
<td style="text-align:center;"> true </td>
<td style="text-align:center;"> false </td>
</tr>
</tbody>
</table>


<p>需要注意，这些状态是由<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/">接口Job</a>来定义的，它是一个广义上的异步并发任务，协程是它的一个实现而已，协程返回的也是对象Job，可以通过Job的方法如join，cancel，isActive等方法来控制协程和查询状态。协程的状态转移可以看这张图：</p>

<p><img src="https://assets.alexandria.raywenderlich.com/books/kco/images/7116dd4d1cf7d079a1ece92d888198c4fdcd6cced5bc408119700a236409fdbd/original.png" alt="" /></p>

<h3>协程的挂起，让度和延续</h3>

<p>用suspend修饰的函数必须在协程里调用，因为它们在运行的时候可以让协程挂起，协程遇到<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html">delay</a>或者<a href="">join</a>以及<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/await.html">await/awaitAll</a>时就会被挂起。除此之外，还可以调用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html">yield</a>主动进行挂起，这会释放线程，让其他协程得以运行，这便是<strong>让度</strong>。挂起，是可能导致线程切换的，这取决 于我们如何设置协程的上下文以及start参数。</p>

<p>那么，Kotlin中的协程是如何做到协程延续(resume)时，协程的运行状态和本地变量等是如何得以在线程之间保存和传播的呢？这就涉及到了<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-continuation/">Continuation</a>，在挂起的时候会创建一个Continuation对象，它把恢复协程所需要的数据都会打包起来，延续运行的的时候只需要调用Continuation#resume就可以了。一般情况下，我们不需要了解Conitnuation的创建过程，因为这过于底层了，Kotlin的编译器会帮我们做好一切。</p>

<p><img src="https://doordash.engineering/wp-content/uploads/2021/11/coroutine-11-1-1024x484.jpg" alt="" /></p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://juejin.cn/post/7288606110336401467">一文搞懂 Kotlin Coroutine Job 的工作流程</a></li>
<li><a href="https://juejin.cn/post/7304615395741351988">详解Kotlin协程实现原理</a></li>
<li><a href="https://juejin.cn/post/7312404578958934054">源解 Kotlin 协程</a></li>
</ul>


<h2>无限序列</h2>

<p>在继续深入学习其他话题之前先来看一个实际的妙用协程的例子，使用协程创建异步无限序列。<a href="https://kotlinlang.org/docs/constructing-collections.html">集合(Collections)</a>是对象的容器，用来存储对象实例（objects）的，把对象放入到集合中，也就是说在『放入』的过程中时，元素必须已经创建好了。而<a href="https://kotlinlang.org/docs/sequences.html">序列(Sequences)</a>并不存储对象实例，它按需生成对象，也就是说只有需要某个元素时，序列才会生成它，并且序列可以有无限个元素，它是按需生成元素，如果需要可以有无限发子弹。</p>

<p>序列是按需生成元素，因此它具有延迟化，占用资源少的特点。对于用<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/sequence.html">sequence builder</a>来创建无限序列时，其实就用到了协程，比如说创建一个质数的序列：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">primes</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Sequence</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">sequence</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Infinite prime sequence:&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">n</span> <span class="p">=</span> <span class="n">start</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="p">&gt;</span> <span class="m">1</span> <span class="p">&amp;&amp;</span> <span class="p">(</span><span class="m">2</span> <span class="n">until</span> <span class="n">n</span><span class="p">).</span><span class="n">none</span> <span class="p">{</span> <span class="n">i</span> <span class="p">-&gt;</span> <span class="n">n</span> <span class="p">%</span> <span class="n">i</span> <span class="p">==</span> <span class="m">0</span> <span class="p">})</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">yield</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
</span><span class='line'>            <span class="n">println</span><span class="p">(</span><span class="s">&quot;\tGenerating next prime after $n&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">n</span><span class="p">++</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">prime</span> <span class="k">in</span> <span class="n">primes</span><span class="p">(</span><span class="n">start</span> <span class="p">=</span> <span class="m">10</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;Received $prime&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">prime</span> <span class="p">&gt;</span> <span class="m">30</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">break</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码的输出是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='Bash'><span class='line'>Infinite prime sequence:
</span><span class='line'>Received 11
</span><span class='line'>  Generating next prime after 11
</span><span class='line'>Received 13
</span><span class='line'>  Generating next prime after 13
</span><span class='line'>Received 17
</span><span class='line'>  Generating next prime after 17
</span><span class='line'>Received 19
</span><span class='line'>  Generating next prime after 19
</span><span class='line'>Received 23
</span><span class='line'>  Generating next prime after 23
</span><span class='line'>Received 29
</span><span class='line'>  Generating next prime after 29
</span><span class='line'>Received 31
</span></code></pre></td></tr></table></div></figure>


<p>序列生成器之所以能够一个一个的生成元素，并返回给调用者的原因就是在于<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence-scope/yield.html">yield()</a>函数，它是一个suspend函数，执行后就会挂起，然后调用者的代码得以继续执行。如果没有把sequence生成器挂起的话，它会陷入死循环。我们可以详细的看一眼sequence的签名：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="err">&lt;</span><span class="nf">T</span><span class="p">&gt;</span> <span class="n">sequence</span><span class="p">(</span>
</span><span class='line'>    <span class="n">block</span><span class="p">:</span> <span class="n">suspend</span> <span class="n">SequenceScope</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;.()</span> <span class="p">-&gt;</span> <span class="n">Unit</span>
</span><span class='line'><span class="p">):</span> <span class="n">Sequence</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以发现sequence builder的参数是一个运行在SequenceScope中的挂起函数，内部一定是会创建一个协程来运行此代码块。并且，我们在此代码块中一定要让协程挂起，否则可能会陷入死循环。</p>

<p>拓展阅读 <a href="https://kt.academy/article/cc-sequence">Sequence builders in Kotlin Coroutines</a>。</p>

<h2>协程取消</h2>

<p>创建协程能得到协程的句柄即Job对象，可以用来控制协程，最重要的一个操作就是取消协程，通过<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/cancel.html">cancel</a>方法，目的是终止协程的运行。我们先来看一个示例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">job</span> <span class="p">=</span> <span class="n">launch</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">repeat</span><span class="p">(</span><span class="m">1000</span><span class="p">)</span> <span class="p">{</span> <span class="n">i</span> <span class="p">-&gt;</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;job: I&#39;m sleeping $i ...&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="m">500L</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">delay</span><span class="p">(</span><span class="m">1300L</span><span class="p">)</span> <span class="c1">// delay a bit</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;main: I&#39;m tired of waiting!&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">job</span><span class="p">.</span><span class="n">cancel</span><span class="p">()</span> <span class="c1">// cancels the job</span>
</span><span class='line'><span class="n">job</span><span class="p">.</span><span class="n">join</span><span class="p">()</span> <span class="c1">// waits for job&#39;s completion </span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;main: Now I can quit.&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">job</span><span class="p">:</span> <span class="n">I</span><span class="err">&#39;</span><span class="n">m</span> <span class="n">sleeping</span> <span class="m">0</span> <span class="p">...</span>
</span><span class='line'><span class="n">job</span><span class="p">:</span> <span class="n">I</span><span class="err">&#39;</span><span class="n">m</span> <span class="n">sleeping</span> <span class="m">1</span> <span class="p">...</span>
</span><span class='line'><span class="n">job</span><span class="p">:</span> <span class="n">I</span><span class="err">&#39;</span><span class="n">m</span> <span class="n">sleeping</span> <span class="m">2</span> <span class="p">...</span>
</span><span class='line'><span class="n">main</span><span class="p">:</span> <span class="n">I</span><span class="err">&#39;</span><span class="n">m</span> <span class="n">tired</span> <span class="n">of</span> <span class="n">waiting</span><span class="p">!</span>
</span><span class='line'><span class="n">main</span><span class="p">:</span> <span class="n">Now</span> <span class="n">I</span> <span class="n">can</span> <span class="n">quit</span><span class="p">.</span>
</span></code></pre></td></tr></table></div></figure>


<h3>协程取消的特性</h3>

<p>协程只有<strong>处于挂起状态时才能被取消</strong>，这个可以看上面Job的状态表格。父协程被取消，它同时也会取消所有的子协程，并且父协程只有在所有子协程退出后才会退出，这种树形管理关系是结构化并发的基础。另外就是，为了更好的<strong>实现可取消性</strong>，在协程内部要在关键的地方检查<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/is-active.html">isActive</a>，比如循环时，或者做一些耗时操作时，以及时响应cancel。</p>

<p>为了更全面的响应取消操作，也要捕获<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/">CancellationException</a>，并在finally中清理占用的资源，这是因为对于挂起的库函数，当被cancel时会抛出CancellationException。如果有Java的并发经验的同学可以发现，这跟取消Thread是一样的（即interrupt一个Thread）。</p>

<h3>不可取消协程</h3>

<p>有时候可能希望协程不被取消，也就是不能被取消，因为可能在执行一些关键的初始化工作，不可被打断和取消，这时可以用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-non-cancellable/">withContext(NonCancellable) { &hellip; }</a>来作为协程的上下文环境，这坨代码块就不可被取消了，只有执行完才会返回，任外部如何cancel都没用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">job</span> <span class="p">=</span> <span class="n">launch</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">repeat</span><span class="p">(</span><span class="m">1000</span><span class="p">)</span> <span class="p">{</span> <span class="n">i</span> <span class="p">-&gt;</span>
</span><span class='line'>            <span class="n">println</span><span class="p">(</span><span class="s">&quot;job: I&#39;m sleeping $i ...&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">delay</span><span class="p">(</span><span class="m">500L</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">withContext</span><span class="p">(</span><span class="n">NonCancellable</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">println</span><span class="p">(</span><span class="s">&quot;job: I&#39;m running finally&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">delay</span><span class="p">(</span><span class="m">1000L</span><span class="p">)</span>
</span><span class='line'>            <span class="n">println</span><span class="p">(</span><span class="s">&quot;job: And I&#39;ve just delayed for 1 sec because I&#39;m non-cancellable&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">delay</span><span class="p">(</span><span class="m">1300L</span><span class="p">)</span> <span class="c1">// delay a bit</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;main: I&#39;m tired of waiting!&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">job</span><span class="p">.</span><span class="n">cancelAndJoin</span><span class="p">()</span> <span class="c1">// cancels the job and waits for its completion</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;main: Now I can quit.&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码非常有意思，父协程启动了子协程后就取消它，子协程中的try代码块会被取消，repeat不会执行完，但它的finally代码块是不可以取消的，一定要执行完子协程才能返回。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/cancellation-and-timeouts.html">Cancellation and timeouts</a>。</p>

<h2>超时处理</h2>

<p>对于异步和并发编程来说，<strong>超时处理</strong>是非常关键的，虽然异步地或者并发地去执行任务，但对于主线程来说不可能永远等待任务，比如请求网络时，如果在网络库未设置连接超时，那么主线程或者说主协程就有可能面临无限等待。一般的做法是把问题丢给用户，用户受不了了，不想等了，那就返回或者退出，返回或者退出自然会去cancel掉所有的异步任务，无论是协程还是线程。</p>

<p>但是，更为优雅的方式是对于每一个启动的异步任务，都主动的设置一个超时时间，在给定的时间内任务仍未结束，那就取消它，终止它。这样整体的并发会更加的有秩序和可控，当然了，取消随时仍可能发生，超时时间未到时，仍是可以主动取消的。</p>

<p>在Kotlin中，给协程加上超时时限非常的方便，用扩展函数<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html">withTimeout(limit) {&hellip;}</a>就可以非常方便的给代码块加上超时时限，当超时时限达到时，如果协程仍未返回，会终止协程并抛出异常<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html">TimeoutCancellationException</a>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">withTimeout</span><span class="p">(</span><span class="m">1300L</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">repeat</span><span class="p">(</span><span class="m">1000</span><span class="p">)</span> <span class="p">{</span> <span class="n">i</span> <span class="p">-&gt;</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;I&#39;m sleeping $i ...&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="m">500L</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//I&#39;m sleeping 0 ...</span>
</span><span class='line'><span class="c1">//I&#39;m sleeping 1 ...</span>
</span><span class='line'><span class="c1">//I&#39;m sleeping 2 ...</span>
</span><span class='line'><span class="c1">//Exception in thread &quot;main&quot; kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1300 ms</span>
</span></code></pre></td></tr></table></div></figure>


<p>扩展阅读 <a href="https://juejin.cn/post/7250085815431020605">探索 Kotlin 协程 withTimeout 原理</a>。</p>

<h2>异常处理</h2>

<p>程序运行总会遇到异常情况，至少有一半的代码都是在处理各种异常情况。协程就是以异常的方式运行一坨代码块，这些代码块自然也可能会抛出异常，这时要如何处理呢？有同学举手了，好办啊，try-catch不就行了？这位同学先坐下，对于同步的代码是可行的，但对于异步代码并不总是可行。并发编程中的异常处理略微稍复杂一些，我们来详细的看看协程中的异常处理方法。</p>

<h3>协程中异常的传播</h3>

<p>对于同步代码来说，在外面调用层包裹try-catch总是管用的，比如说：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">boo</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// do some sync works that may throw exceptions</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">Exception</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;Got you, no where to run!!!&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>但对于异步代码，这不管用，比如说想在协程外面try-catch异常，是行不通的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">job</span> <span class="p">=</span> <span class="n">launch</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">Default</span> <span class="p">+</span> <span class="n">SupervisorJob</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">println</span><span class="p">(</span><span class="s">&quot;Ready to run!&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">delay</span><span class="p">(</span><span class="m">400</span><span class="p">)</span>
</span><span class='line'>            <span class="k">throw</span> <span class="n">Exception</span><span class="p">(</span><span class="s">&quot;You will never catch me, hahaha!&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">job</span><span class="p">.</span><span class="n">join</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">Exception</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;Try to handle everything: ${e.message}&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//Ready to run!</span>
</span><span class='line'><span class="c1">//Exception in thread &quot;DefaultDispatcher-worker-1&quot; java.lang.Exception: You will never catch me, hahaha!</span>
</span></code></pre></td></tr></table></div></figure>


<p>协程中抛出了异常，但外层并没有能catch住，这段代码会crash。我们再看看async的情况：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">deferred</span> <span class="p">=</span> <span class="n">async</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">Default</span> <span class="p">+</span> <span class="n">SupervisorJob</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">println</span><span class="p">(</span><span class="s">&quot;Ready to run!&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">delay</span><span class="p">(</span><span class="m">400</span><span class="p">)</span>
</span><span class='line'>            <span class="k">throw</span> <span class="n">Exception</span><span class="p">(</span><span class="s">&quot;You will never catch me, hahaha!&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">deferred</span><span class="p">.</span><span class="n">await</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">Exception</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;No where to run: ${e.message}&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//Ready to run!</span>
</span><span class='line'><span class="c1">//No where to run: You will never catch me, hahaha!</span>
</span></code></pre></td></tr></table></div></figure>


<p>这回外层的catch是生效的，能把协程中的异常捕获住！到此，我们可以总结一下协程中的异常的传播：<strong>launch创建的协程异常是不可在外面捕获的，而async则可以</strong>。</p>

<p><strong>注意：</strong>无论是launch还是async，如果父协程不去join或者await等待子协程的话，则是死活都无法捕获到子协程的异常的，因为协程是异步的，launch/async很快就返回了，会立马执行它后面的语句，所以，当协程运行时，外面的代码（即launch/async后面的语句）可能已执行完了，自然是不可能捕获到任何异常的，可以通过把上面两个例子中的join和await去掉，然后运行试试看，都会crash。</p>

<p>那么，要想处理协程中的异常，一是让协程自己去try-catch，另外就是使用CoroutineContext的另一个Element，叫作CoroutineExceptionHandler。</p>

<h3>未捕获异常处理器CoroutineExceptionHandler</h3>

<p>如果协程内部出现了未捕获的异常(uncaught exceptions)时，会先看协程上下文中有没有指定未捕获异常处理器(uncaught exception handler)，如果没有则会按前面说的方式再传播。在指定协程上下文时可以用一个<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/">CoroutineExceptionHandler</a>对象来当作uncaught excpetion handler，以处理未捕获异常：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">handler</span> <span class="p">=</span> <span class="n">CoroutineExceptionHandler</span> <span class="p">{</span> <span class="n">_</span><span class="p">,</span> <span class="n">exception</span> <span class="p">-&gt;</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;Totally under control: ${exception.message}&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">val</span> <span class="py">job1</span> <span class="p">=</span> <span class="n">launch</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">Default</span> <span class="p">+</span> <span class="n">SupervisorJob</span><span class="p">()</span> <span class="p">+</span> <span class="n">handler</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="m">200</span><span class="p">)</span>
</span><span class='line'>        <span class="k">throw</span> <span class="n">Exception</span><span class="p">(</span><span class="s">&quot;Exploded!!!&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">val</span> <span class="py">job2</span> <span class="p">=</span> <span class="n">launch</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">Default</span> <span class="p">+</span> <span class="n">SupervisorJob</span><span class="p">()</span> <span class="p">+</span> <span class="n">handler</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="m">800</span><span class="p">)</span>
</span><span class='line'>        <span class="k">throw</span> <span class="n">Exception</span><span class="p">(</span><span class="s">&quot;Can I run away???&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">val</span> <span class="py">deferred</span> <span class="p">=</span> <span class="n">async</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">Default</span> <span class="p">+</span> <span class="n">SupervisorJob</span><span class="p">()</span> <span class="p">+</span> <span class="n">handler</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="m">400</span><span class="p">)</span>
</span><span class='line'>        <span class="k">throw</span> <span class="n">Exception</span><span class="p">(</span><span class="s">&quot;You will never catch me, hahaha!&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">joinAll</span><span class="p">(</span><span class="n">job1</span><span class="p">,</span> <span class="n">job2</span><span class="p">,</span> <span class="n">deferred</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//Totally under control: Exploded!!!</span>
</span><span class='line'><span class="c1">//Totally under control: Can I run away???</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以发现通过给launch指定CoroutineExceptionHandler可以捕获其uncaught excpetions。但是注意看async创建的协程似乎没效果，这是因为async本来就会把异常传播给其父协程，不会给CoroutineExceptionHandler处理，所以对于async来说指定了handler也是没有效果的，会<strong>被async忽略掉</strong>。</p>

<p>还需要注意的是，只有根协程（root coroutine）的上下文中的CoroutineExceptionHandler是有效的，被用于处理uncaught exceptions。协程是有树形关系的，一个协程出现未捕获异常(uncaught exception)时，它会把它丢给它的父协程处理，一层一层的传播直到根协程（root coroutine），如果根协程的上下文环境中有handler，那就用它来处理，否则就crash。换句话说，只有最外层的协程(root coroutine)设置一个handler给其context就够了，其他的子协程即使设置了handler也是没有用处的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">handler</span> <span class="p">=</span> <span class="n">CoroutineExceptionHandler</span> <span class="p">{</span> <span class="n">_</span><span class="p">,</span> <span class="n">exception</span> <span class="p">-&gt;</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;Totally under control: ${exception.message}&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">val</span> <span class="py">job1</span> <span class="p">=</span> <span class="n">launch</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">Default</span> <span class="p">+</span> <span class="n">SupervisorJob</span><span class="p">()</span> <span class="p">+</span> <span class="n">handler</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">subHandler</span> <span class="p">=</span> <span class="n">CoroutineExceptionHandler</span> <span class="p">{</span> <span class="n">_</span><span class="p">,</span> <span class="n">exp</span> <span class="p">-&gt;</span>
</span><span class='line'>            <span class="n">println</span><span class="p">(</span><span class="s">&quot;Try to intercept exceptions: ${exp.message}&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">subJob</span> <span class="p">=</span> <span class="n">launch</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">Default</span> <span class="p">+</span> <span class="n">subHandler</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">val</span> <span class="py">grandJob</span> <span class="p">=</span> <span class="n">launch</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">Default</span> <span class="p">+</span> <span class="n">subHandler</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">throw</span> <span class="n">Exception</span><span class="p">(</span><span class="s">&quot;Bad thing happened deep down!&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="n">grandJob</span><span class="p">.</span><span class="n">join</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">subJob</span><span class="p">.</span><span class="n">join</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">val</span> <span class="py">job2</span> <span class="p">=</span> <span class="n">launch</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">Default</span> <span class="p">+</span> <span class="n">SupervisorJob</span><span class="p">()</span> <span class="p">+</span> <span class="n">handler</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="m">800</span><span class="p">)</span>
</span><span class='line'>        <span class="k">throw</span> <span class="n">Exception</span><span class="p">(</span><span class="s">&quot;Can I run away???&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">joinAll</span><span class="p">(</span><span class="n">job1</span><span class="p">,</span> <span class="n">job2</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//Totally under control: Bad thing happened deep down!</span>
</span><span class='line'><span class="c1">//Totally under control: Can I run away???</span>
</span></code></pre></td></tr></table></div></figure>


<p>是的，聪明的你一定发现了，这里的规则其实与Java中的<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler">Thread.UncaughtExceptionHandler</a>)是一样一样的，它也是只需要有一个所以用<strong>static</strong>成员就可以了。</p>

<h3>链式反应</h3>

<p>当协程发生未捕获异常(uncaught exceptions)而被动终止时，它自己肯定是会被终止的，这个异常会沿树形向上传给它的父协程，其父协程也会被终止(cancle)，由于结构化并发，父协程被cancel时，会cancel其所有的子协程。就像<strong>链式反应</strong>一样，在未经特殊处理情况下，一旦<strong>子协程发生异常</strong>，就会导致其所在的<strong>树形结构的所有协程被终止</strong>，可以通过一个示例来验证一下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">handler</span> <span class="p">=</span> <span class="n">CoroutineExceptionHandler</span> <span class="p">{</span> <span class="n">_</span><span class="p">,</span> <span class="n">exception</span> <span class="p">-&gt;</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;Totally under control: ${exception.message}&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">val</span> <span class="py">root</span> <span class="p">=</span> <span class="n">launch</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">Default</span> <span class="p">+</span> <span class="n">SupervisorJob</span><span class="p">()</span> <span class="p">+</span> <span class="n">handler</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">subJob1</span> <span class="p">=</span> <span class="n">launch</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">val</span> <span class="py">grandJob</span> <span class="p">=</span> <span class="n">launch</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">delay</span><span class="p">(</span><span class="m">100</span><span class="p">)</span>
</span><span class='line'>                <span class="k">throw</span> <span class="n">Exception</span><span class="p">(</span><span class="s">&quot;Bad thing happened from deep down!&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="n">grandJob</span><span class="p">.</span><span class="n">join</span><span class="p">()</span>
</span><span class='line'>            <span class="n">println</span><span class="p">(</span><span class="s">&quot;Sub coroutine #1 completed&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">val</span> <span class="py">subJob2</span> <span class="p">=</span> <span class="n">launch</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">delay</span><span class="p">(</span><span class="m">60</span> <span class="p">*</span> <span class="m">1000</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">println</span><span class="p">(</span><span class="s">&quot;Sub coroutine #2 cancelled!!&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">val</span> <span class="py">subJob3</span> <span class="p">=</span> <span class="n">launch</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">delay</span><span class="p">(</span><span class="m">60</span> <span class="p">*</span> <span class="m">1000</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">println</span><span class="p">(</span><span class="s">&quot;Sub coroutine #3 cancelled!!!&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">val</span> <span class="py">subJob4</span> <span class="p">=</span> <span class="n">launch</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">delay</span><span class="p">(</span><span class="m">60</span> <span class="p">*</span> <span class="m">1000</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">println</span><span class="p">(</span><span class="s">&quot;Sub coroutine #4 cancelled!!!!&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">joinAll</span><span class="p">(</span><span class="n">subJob1</span><span class="p">,</span> <span class="n">subJob2</span><span class="p">,</span> <span class="n">subJob3</span><span class="p">,</span> <span class="n">subJob4</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">root</span><span class="p">.</span><span class="n">join</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//Sub coroutine #2 cancelled!!</span>
</span><span class='line'><span class="c1">//Sub coroutine #4 cancelled!!!!</span>
</span><span class='line'><span class="c1">//Sub coroutine #3 cancelled!!!</span>
</span><span class='line'><span class="c1">//Totally under control: Bad thing happened from deep down!</span>
</span></code></pre></td></tr></table></div></figure>


<p>其他几个子协程subJob2，subJob3和subJob4都在工作中，但被grandJob的未捕获异常给终止掉了。另外，我们还可以发现这个异常是在根协程(root)里面的Uncaught exception handler中处理了，同时还可以发现，异常处理handler是在所有子协程被终止结束后才得以处理。再来看一个来自官方教程上面的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">handler</span> <span class="p">=</span> <span class="n">CoroutineExceptionHandler</span> <span class="p">{</span> <span class="n">_</span><span class="p">,</span> <span class="n">exception</span> <span class="p">-&gt;</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;CoroutineExceptionHandler got $exception&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">val</span> <span class="py">job</span> <span class="p">=</span> <span class="n">GlobalScope</span><span class="p">.</span><span class="n">launch</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">launch</span> <span class="p">{</span> <span class="c1">// the first child</span>
</span><span class='line'>        <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">delay</span><span class="p">(</span><span class="n">Long</span><span class="p">.</span><span class="n">MAX_VALUE</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">withContext</span><span class="p">(</span><span class="n">NonCancellable</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">println</span><span class="p">(</span><span class="s">&quot;Children are cancelled, but exception is not handled until all children terminate&quot;</span><span class="p">)</span>
</span><span class='line'>                <span class="n">delay</span><span class="p">(</span><span class="m">100</span><span class="p">)</span>
</span><span class='line'>                <span class="n">println</span><span class="p">(</span><span class="s">&quot;The first child finished its non cancellable block&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">launch</span> <span class="p">{</span> <span class="c1">// the second child</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;Second child throws an exception&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="k">throw</span> <span class="n">ArithmeticException</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">job</span><span class="p">.</span><span class="n">join</span><span class="p">()</span>
</span><span class='line'><span class="c1">//Second child throws an exception</span>
</span><span class='line'><span class="c1">//Children are cancelled, but exception is not handled until all children terminate</span>
</span><span class='line'><span class="c1">//The first child finished its non cancellable block</span>
</span><span class='line'><span class="c1">//CoroutineExceptionHandler got java.lang.ArithmeticException</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个例子非常的有意思，用到了好几个特性，先是第二个子协程发生了未捕获异常(ArithmeticException)，导致其父协程job被取消，但job还有其他子协程，所以还会去cancel仍在运行中的子协程，这个子协程被取消了，它正在delay，这时cancel它会抛CancellationException而终止delay，进入finally，finally中有一个不可以被打断的任务。而只有当所有子协程都终止完成了，job的handler才得以处理这个异常(ArithmeticException)。</p>

<h3>监管责任(Supervision)</h3>

<p>链式反应，异常会在树形关系中传递导致整个树形协程都被终止，这样设计的目的在于结构化并发，它能让整体结构的行为较一致，形成一个整体结构。很多时候这并不是想要的行为，比如说启动四个协程去服务器取四段数据，然后拼成一个整体使用，即使某段异常了，取不到，也没有必须把整体都取消掉。</p>

<p>可以给父协程加上监管责任，这样当其某一个子协程失败了，它会履行监管责任，保障其他子协程仍能运行，可以用一个例子来看一下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">supervisor</span> <span class="p">=</span> <span class="n">SupervisorJob</span><span class="p">()</span>
</span><span class='line'><span class="n">with</span><span class="p">(</span><span class="n">CoroutineScope</span><span class="p">(</span><span class="n">coroutineContext</span> <span class="p">+</span> <span class="n">supervisor</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// launch the first child -- its exception is ignored for this example (don&#39;t do this in practice!)</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">firstChild</span> <span class="p">=</span> <span class="n">launch</span><span class="p">(</span><span class="n">CoroutineExceptionHandler</span> <span class="p">{</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="p">-&gt;</span>  <span class="p">})</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;The first child is failing&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="k">throw</span> <span class="n">AssertionError</span><span class="p">(</span><span class="s">&quot;The first child is cancelled&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="c1">// launch the second child</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">secondChild</span> <span class="p">=</span> <span class="n">launch</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">firstChild</span><span class="p">.</span><span class="n">join</span><span class="p">()</span>
</span><span class='line'>        <span class="c1">// Cancellation of the first child is not propagated to the second child</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;The first child is cancelled: ${firstChild.isCancelled}, but the second one is still active&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">delay</span><span class="p">(</span><span class="n">Long</span><span class="p">.</span><span class="n">MAX_VALUE</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// But cancellation of the supervisor is propagated</span>
</span><span class='line'>            <span class="n">println</span><span class="p">(</span><span class="s">&quot;The second child is cancelled because the supervisor was cancelled&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="c1">// wait until the first child fails &amp; completes</span>
</span><span class='line'>    <span class="n">firstChild</span><span class="p">.</span><span class="n">join</span><span class="p">()</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Cancelling the supervisor&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">supervisor</span><span class="p">.</span><span class="n">cancel</span><span class="p">()</span>
</span><span class='line'>    <span class="n">secondChild</span><span class="p">.</span><span class="n">join</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//The first child is failing</span>
</span><span class='line'><span class="c1">//The first child is cancelled: true, but the second one is still active</span>
</span><span class='line'><span class="c1">//Cancelling the supervisor</span>
</span><span class='line'><span class="c1">//The second child is cancelled because the supervisor was cancelled</span>
</span></code></pre></td></tr></table></div></figure>


<p>有两种方式加上监管责任，一种是在协程上下文时指定一个<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-supervisor-job.html">SupervisorJob</a>对象，比如前面那个例子，可以这样修改：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">handler</span> <span class="p">=</span> <span class="n">CoroutineExceptionHandler</span> <span class="p">{</span> <span class="n">_</span><span class="p">,</span> <span class="n">exception</span> <span class="p">-&gt;</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;Totally under control: ${exception.message}&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">val</span> <span class="py">root</span> <span class="p">=</span> <span class="n">launch</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">Default</span> <span class="p">+</span> <span class="n">SupervisorJob</span><span class="p">()</span> <span class="p">+</span> <span class="n">handler</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">subJob1</span> <span class="p">=</span> <span class="n">launch</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">val</span> <span class="py">grandJob</span> <span class="p">=</span> <span class="n">launch</span><span class="p">(</span><span class="n">SupervisorJob</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">delay</span><span class="p">(</span><span class="m">100</span><span class="p">)</span>
</span><span class='line'>                <span class="k">throw</span> <span class="n">Exception</span><span class="p">(</span><span class="s">&quot;Bad thing happened from deep down!&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="n">grandJob</span><span class="p">.</span><span class="n">join</span><span class="p">()</span>
</span><span class='line'>            <span class="n">println</span><span class="p">(</span><span class="s">&quot;Sub coroutine #1 completed&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">val</span> <span class="py">subJob2</span> <span class="p">=</span> <span class="n">launch</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">delay</span><span class="p">(</span><span class="m">10</span> <span class="p">*</span> <span class="m">1000</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">println</span><span class="p">(</span><span class="s">&quot;Sub coroutine #2 cancelled!!&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">val</span> <span class="py">subJob3</span> <span class="p">=</span> <span class="n">launch</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">delay</span><span class="p">(</span><span class="m">20</span> <span class="p">*</span> <span class="m">1000</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">println</span><span class="p">(</span><span class="s">&quot;Sub coroutine #3 cancelled!!!&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">val</span> <span class="py">subJob4</span> <span class="p">=</span> <span class="n">launch</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">delay</span><span class="p">(</span><span class="m">30</span> <span class="p">*</span> <span class="m">1000</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">println</span><span class="p">(</span><span class="s">&quot;Sub coroutine #4 cancelled!!!!&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">joinAll</span><span class="p">(</span><span class="n">subJob1</span><span class="p">,</span> <span class="n">subJob2</span><span class="p">,</span> <span class="n">subJob3</span><span class="p">,</span> <span class="n">subJob4</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">root</span><span class="p">.</span><span class="n">join</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//Totally under control: Bad thing happened from deep down!</span>
</span><span class='line'><span class="c1">//Sub coroutine #1 completed</span>
</span><span class='line'><span class="c1">//Sub coroutine #2 cancelled!!</span>
</span><span class='line'><span class="c1">//Sub coroutine #3 cancelled!!!</span>
</span><span class='line'><span class="c1">//Sub coroutine #4 cancelled!!!!</span>
</span></code></pre></td></tr></table></div></figure>


<p>除了单独的为每个协程上下文指定SupervisorJob以外，还有更为优雅的方式就是在合适的层级使用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html">扩展函数superivorScope</a>来创建一个scope，我们用此方法改造另一 个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">handler</span> <span class="p">=</span> <span class="n">CoroutineExceptionHandler</span> <span class="p">{</span> <span class="n">_</span><span class="p">,</span> <span class="n">exception</span> <span class="p">-&gt;</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;CoroutineExceptionHandler got $exception&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">job</span> <span class="p">=</span> <span class="n">GlobalScope</span><span class="p">.</span><span class="n">launch</span><span class="p">(</span><span class="n">handler</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">supervisorScope</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">launch</span> <span class="p">{</span> <span class="c1">// the first child</span>
</span><span class='line'>                <span class="k">try</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">delay</span><span class="p">(</span><span class="m">10</span> <span class="p">*</span> <span class="m">1000</span><span class="p">)</span>
</span><span class='line'>                <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">withContext</span><span class="p">(</span><span class="n">NonCancellable</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                        <span class="n">println</span><span class="p">(</span><span class="s">&quot;Children are cancelled, but exception is not handled until all children terminate&quot;</span><span class="p">)</span>
</span><span class='line'>                        <span class="n">delay</span><span class="p">(</span><span class="m">100</span><span class="p">)</span>
</span><span class='line'>                        <span class="n">println</span><span class="p">(</span><span class="s">&quot;The first child finished its non cancellable block&quot;</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">}</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="n">launch</span> <span class="p">{</span> <span class="c1">// the second child</span>
</span><span class='line'>                <span class="n">delay</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>
</span><span class='line'>                <span class="n">println</span><span class="p">(</span><span class="s">&quot;Second child throws an exception&quot;</span><span class="p">)</span>
</span><span class='line'>                <span class="k">throw</span> <span class="n">ArithmeticException</span><span class="p">()</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">job</span><span class="p">.</span><span class="n">join</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//Second child throws an exception</span>
</span><span class='line'><span class="c1">//CoroutineExceptionHandler got java.lang.ArithmeticException</span>
</span><span class='line'><span class="c1">//Children are cancelled, but exception is not handled until all children terminate</span>
</span><span class='line'><span class="c1">//The first child finished its non cancellable block</span>
</span></code></pre></td></tr></table></div></figure>


<h3>取消异常(CancellationException)不是异常</h3>

<p>需要注意取消异常<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/">CancellationException</a>并不是常规的异常，不遵循前面说的规则，它会被忽略掉。这是因为CancellationException只会发生在主动取消协程时<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/cancel.html">Job#cancel</a>，这是自上而下的取消协程，并不需要链式反应和异常处理。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://kotlinlang.org/docs/exception-handling.html">Coroutine exceptions handling</a></li>
<li><a href="https://juejin.cn/post/7270478168758829111">彻底掌握kotlin 协程异常处理</a></li>
<li><a href="https://juejin.cn/post/7249647450515996732">Kotlin篇 > > 协程中的异常及异常处理</a></li>
</ul>


<h2>调试</h2>

<p>调试总是必须且难免的，有时候代码运行与预期不符，但又想不通为啥时就需要进行调试以弄清楚为啥会产生那样的结果。与常规的代码一样，调试有两种方式，一是<strong>通过IDE中的『Debug』功能，step-by-step</strong>的运行代码，修改代码；另一种就是<strong>通过加日志</strong>。</p>

<h3>在IDE中『Debug』</h3>

<p>凡是IDE，或者说敢称自己是IDE的，肯定有调试功能，也就是step-by-step式的单步跟踪功能。对Kotlin比较友好的IDEA和Android Studio自然也不例外。协程也是标准的Kotlin代码，所以也是可以调试的，并且在调试方面其实没有区别。都是先在代码中设置断点，然后使用虫子图标的『Debug』功能就好了。对于IDEA系（包括Android Studio），设置断点就是在代码编辑器行号旁边点一下就可以了：</p>

<p><img src="https://kotlinlang.org/docs/images/coroutine-breakpoint.png" alt="" /></p>

<p>然后点虫子图标进行『Debug』即可：</p>

<p><img src="https://kotlinlang.org/docs/images/flow-debug-project.png" alt="" /></p>

<p>这时代码会运行，然后在预设置的断点处停止，并出现调试窗口，这里面可以单步跟踪，继续执行，或者查看代码的运行状态。对于协程来说，会比较方便的显示每个协程的状态，比如是<em>SUSPENDED</em>还是<em>RUNNING</em>等。</p>

<p><img src="https://kotlinlang.org/docs/images/coroutine-idea-debugging-1.png" alt="" /></p>

<p>注意，对于异步流程和并发流程比较多的代码来说，『Debug』会扰乱原本的时序，因为JVM必须在断点处停下来。因此，『Debug』更适用于比较复杂的大段的同步代码的调试，比如协程内部的某一段逻辑。</p>

<h3>用日志来调试</h3>

<p>另外的方式就是用日志来查看代码的运行状态，其实这跟协程也没啥关系，用日志输出想要输出的信息就可以了。只不过对于协程，我们需要知道协程信息，也就是说要知道每条日志是哪个协程输出的。这就需要一个能够输出当前协程名字的方法，一个办法是在打日志时输出CoroutineName，可以通过context[CoroutineName]；更为方便的方法是直接输出线程名字<strong>Thread.currentThread().name</strong>，然后给JVM加上选项<strong>-Dkotlinx.coroutines.debug</strong>就可以得到协程的详细名字：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">log</span><span class="p">(</span><span class="n">msg</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">=</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;[${Thread.currentThread().name}] $msg&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">a</span> <span class="p">=</span> <span class="n">async</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">log</span><span class="p">(</span><span class="s">&quot;I&#39;m computing a piece of the answer&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="m">6</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">b</span> <span class="p">=</span> <span class="n">async</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">log</span><span class="p">(</span><span class="s">&quot;I&#39;m computing another piece of the answer&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="m">7</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">log</span><span class="p">(</span><span class="s">&quot;The answer is ${a.await() * b.await()}&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//[main @coroutine#2] I&#39;m computing a piece of the answer</span>
</span><span class='line'><span class="c1">//[main @coroutine#3] I&#39;m computing another piece of the answer</span>
</span><span class='line'><span class="c1">//[main @coroutine#1] The answer is 42</span>
</span></code></pre></td></tr></table></div></figure>


<p>从日志中可以看每条日志所在的线程名字（即前面的main）和协程名字（即&#64;后面的内容）。注意，一定要给VM加上选项<strong>-Dkotlinx.coroutines.debug</strong>，要不然不会带有协程名字，只有线程名字：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Bash'><span class='line'><span class="c"># Output without -Dkotlinx.coroutines.debug</span>
</span><span class='line'>
</span><span class='line'><span class="o">[</span>main<span class="o">]</span> I<span class="s1">&#39;m computing a piece of the answer</span>
</span><span class='line'><span class="s1">[main] I&#39;</span>m computing another piece of the answer
</span><span class='line'><span class="o">[</span>main<span class="o">]</span> The answer is 42
</span></code></pre></td></tr></table></div></figure>


<p>对于Android应用来说，是没有办法<strong>直接给VM加上选项的</strong>，这时可以通过<strong>设置系统属性</strong>，在应用的入口处，比如在<a href="">Application#onCreate</a>或者<a href="">Activity#onCreate</a>时，设置属性即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">System</span><span class="p">.</span><span class="n">setProperty</span><span class="p">(</span><span class="s">&quot;kotlinx.coroutines.debug&quot;</span><span class="p">,</span> <span class="k">if</span> <span class="p">(</span><span class="n">BuildConfig</span><span class="p">.</span><span class="n">DEBUG</span><span class="p">)</span> <span class="s">&quot;on&quot;</span> <span class="k">else</span> <span class="s">&quot;off&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于异步流程和并发流程较多的地方，用日志是比较理想的调试手段，因为它<strong>对程序运行的干扰相对较小</strong>。</p>

<p>当然了，并发编程最大的问题就是<strong>比较难调试</strong>，调试必然需要知道程序运行的状态，无论是日志还是单步调试都会对程序的运行造成影响，从而使原本的逻辑发生改变。相信同学们都会遇到类似的情景：加了几句日志，Bug就不复现了。这就好比量子世界里面观察者对量子的影响一样，听起来不可思议，但确实会发生。并发编程需要在编码之前做好功课，用什么样的模型，选什么样的范式，谁是生产者，谁是消费者，用图形画一画，厘清思路，之后再去编码实现。而不是上来就编码，边想边做，发现线程不够用了，就多开一个吧，A数据回来的太快了，消费者还没有准备好，那就先用一个Map存着吧，这样乱撞式的开发，最后可能会实现需求，但出现Bug必然是极难调试的。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html#debugging-coroutines-and-threads">Debugging coroutines and threads﻿</a></li>
<li><a href="https://kotlinlang.org/docs/debug-coroutines-with-idea.html">Debug coroutines using IntelliJ IDEA – tutorial</a></li>
<li><a href="https://juejin.cn/post/6860647298926379021">Kotlin Jetpack 实战 | 08. 协程“不为人知”的调试技巧</a></li>
</ul>


<h2>协程间通信</h2>

<p>大多数时候协程之间是需要通信的，比如说一个协程在从网络拉取数据，另一个协程可能需要显示进度。可以通过一些共享变量来实现，但这会有潜在的问题，因为<strong>协程随时可能会切换线程运行环境</strong>，这时共享变量就会存在线程安全问题。Kotlin则提供了更为优雅的方式，即Channel。</p>

<p><img src="https://kotlinlang.org/docs/images/using-channel-many-coroutines.png" alt="" /></p>

<p><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/">Channel</a>是一个<a href="https://jenkov.com/tutorials/java-concurrency/producer-consumer.html">生产者-消费者模式</a>，它是线程安全的，可以在生产者与消费之间传递数据。它与Java中的<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html">BlockingQueue</a>是类似的，不同之处在于，它是为协程而生的，它的操作只会挂起不会阻塞，但都是线程安全的。生产者通过<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/">send</a>来生产数据，消费者通过<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/">receive</a>来消费数据。生产者和消费者都可以用协程来实现，所以Channel是一个非常优雅的协程通信方式，高效，可靠且线程安全，来看个小示例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span><span class="p">&lt;</span><span class="n">Unit</span><span class="p">&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">channel</span> <span class="p">=</span> <span class="n">Channel</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;()</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">launch</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">Default</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">channel</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">&quot;A1&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>
</span><span class='line'>        <span class="n">channel</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">&quot;A2&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">logd</span><span class="p">(</span><span class="s">&quot;Producer A done&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">launch</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">IO</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">channel</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="s">&quot;B1&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">logd</span><span class="p">(</span><span class="s">&quot;Producer B done&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">launch</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">repeat</span><span class="p">(</span><span class="m">3</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">val</span> <span class="py">x</span> <span class="p">=</span> <span class="n">channel</span><span class="p">.</span><span class="n">receive</span><span class="p">()</span>
</span><span class='line'>            <span class="n">logd</span><span class="p">(</span><span class="s">&quot;Got $x&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="nf">logd</span><span class="p">(</span><span class="n">message</span><span class="p">:</span> <span class="n">Any</span><span class="p">?)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;[${Thread.currentThread().name}] $message&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//[main @coroutine#4] Got A1</span>
</span><span class='line'><span class="c1">//[main @coroutine#4] Got B1</span>
</span><span class='line'><span class="c1">//[DefaultDispatcher-worker-1 @coroutine#3] Producer B done</span>
</span><span class='line'><span class="c1">//[DefaultDispatcher-worker-2 @coroutine#2] Producer A done</span>
</span><span class='line'><span class="c1">//[main @coroutine#4] Got A2</span>
</span></code></pre></td></tr></table></div></figure>


<p>进一步学习：</p>

<ul>
<li><a href="https://kotlinlang.org/docs/coroutines-and-channels.html#channels">Coroutines and Channels﻿</a></li>
<li><a href="https://kotlinlang.org/docs/channels.html">More about channels﻿</a></li>
<li><a href="https://juejin.cn/post/7171272840426029063">Kotlin协程之一文看懂Channel管道</a></li>
<li><a href="https://juejin.cn/post/7272174836335296548">Kotlin协程之Channel的使用与原理</a></li>
<li><a href="https://kt.academy/article/cc-channel">Channel in Kotlin Coroutines</a></li>
</ul>


<h2>在安卓中使用协程</h2>

<p><img src="https://ts1.cn.mm.bing.net/th/id/R-C.bd4dc46a7a5a9909ddeb90af8b5d689c?rik=6LThCIIV%2bEN67w&amp;riu=http%3a%2f%2fwikicodecamp.com%2fwp-content%2fuploads%2f2022%2f07%2fandroid_2_coroutine.jpg&amp;ehk=EORu%2fSzDMOJNZINUWgwnsOQ%2bf%2f53YvmcuiPz9Cj%2b%2bNI%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" /></p>

<p>从2019年开始，安卓开发生态中已经是<a href="https://developer.android.com/kotlin/first">Kotlin first</a>了，Kotlin是推荐的编程语言，因此协程自然也变成了推荐的异步和并发编程方式。想要在Android应用开发中用好协程，除了协程本身的知识以外，还需要注意的就是Android本身的东西。Android本身是有框架和相当多组件的，并不像我们前面写demo那样，都是从主函数main开始。因此，我们需要注意的就是多多使用框架和组件已经为我们定义好的协程工具，比如UI逻辑层的协程都要在viewModelScope中启动；以及要符合一些架构上的原则，比如Repository要有自己的scope和dispatcher。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://developer.android.com/kotlin/coroutines">Kotlin coroutines on Android</a></li>
<li><a href="https://developer.android.com/kotlin/coroutines/coroutines-adv">Improve app performance with Kotlin coroutines</a></li>
<li><a href="https://developer.android.com/kotlin/coroutines/coroutines-best-practices">Best practices for coroutines in Android</a></li>
</ul>


<h2>书籍推荐</h2>

<p>当对Kotlin以及协程有了基本的认识之后，如果想要进阶的学习，就需要读一些专题书籍，这里推荐两本：</p>

<ul>
<li><a href="https://www.packtpub.com/product/learning-concurrency-in-kotlin/9781788627160">《Learn Concurrency in Kotlin》</a> 这本书以并发为主题，只不过是用Kotlin协程的方式来实现并发，所以它的重点在于<strong>并发编程Concurrency</strong>，具体实现方式其实可以多种多样。</li>
<li><a href="https://www.bennyhuo.com/project/kotlin-coroutines.html">《深入理解Kotlin协程》</a> 这本书的优点在于会横向的介绍其他编程语言中的并发范式，从而能够深入的理解协程，对于有一定编程经验的人来说，横向比较的方式是非常有效的。</li>
</ul>


<h2>参考资料</h2>

<ul>
<li><a href="https://amitshekhar.me/blog/kotlin-coroutines">Mastering Kotlin Coroutines</a></li>
<li><a href="https://doordash.engineering/2021/11/09/the-beginners-guide-to-kotlin-coroutine-internals/">The Beginner’s Guide to Kotlin Coroutine Internals</a></li>
<li><a href="https://theboreddev.wpcomstaging.com/understanding-kotlin-coroutines/">Understanding Kotlin Coroutines</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin进阶之协程从入门到放弃]]></title>
    <link href="http://toughcoder.net/blog/2024/01/11/kotlin-coroutine-made-easy/"/>
    <updated>2024-01-11T22:29:39+08:00</updated>
    <id>http://toughcoder.net/blog/2024/01/11/kotlin-coroutine-made-easy</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Coroutine">协程Coroutine</a>是最新式的并发编程范式，它是纯编程语言层面的东西，不受制于操作系统，轻量级，易于控制，结构严谨，不易出错，易于测试，工具和配套设施都比较完备。在新生代编程语言（如Kotlin和Swift）中支持良好，在Kotlin中有着非常友好的支持，并且是写异步和并发程序的推荐方式。为了彻底学会使用协程和理解协程背后的原理，计划用三篇文章专注来学习协程。</p>

<p><a href="http://toughcoder.net/blog/2024/01/11/kotlin-coroutine-made-easy/"><img src="https://cdn.filestackcontent.com/fShtqYm3Tp2Xl9C36xN8" title="auto auto" ></a></p>

<!-- more -->


<ul>
<li>第一篇：主要介绍协程的基本概念，以及如何使用协程，目标就是讲清基本概念，并快速上手。</li>
<li>第二篇：协程的高级用法，如结构化协程，Scope，Context，Exception handling，在框架中使用（如在Compose和Jetpack中），与Flow一起使用。目标就是进一步发挥协程的威力，写出专业健壮的协程代码 。</li>
<li>第三篇：理解协程的核心原理，以及协程的实现机制，以及在其他编程语言中的支持情况。目标是深刻理解协程的原理的实现机制，做到心中无剑，以及尝试在不支持协程的语言中实现协程</li>
</ul>


<p><strong>注意</strong>：在任何一个编程语言中异步和并发编程总是略微复杂的话题，Kotlin中的协程也不例外，因此需要先有一定的前置知识，也就是说要大概弄懂操作系统中的进程与线程， 以及要有一些Java中的线程和并发编程经验，否则是没有办法很好理解和使用Kotlin协程的。</p>

<h2>Hello, coroutines</h2>

<p>每当学习一门新的技术，最喜欢的方式就是快速的上手，比如先弄个『Hello, world!』之类的，而不是上来就讲什么概念，原理，范式和方法论。编程是门实践性很强的学科，要快速上手快速体验，当有了一定的感觉之后，再去研究它的概念和原理。</p>

<p>我们也要从一个『Hello, coroutines!』开始我们的Kotlin协程之旅。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">launch</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="m">1000</span><span class="p">)</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;, coroutines!&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// Hello, coroutines!</span>
</span></code></pre></td></tr></table></div></figure>


<p>以常规的方式来思考，写在前面的语句会先执行，写在后面的语句会后执行，这就是同步的意思，似乎应该输出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='Bash'><span class='line'>, coroutines!
</span><span class='line'>Hello
</span></code></pre></td></tr></table></div></figure>


<p>但我们得到了期望的输出『Hello, coroutines!』，这就是协程的作用，它可以实现异步。这里launch是一个函数，后面的lambda是它的参数，它的作用就是启动一个协程来运行传入的代码块。这个代码块很简单，它先delay了1秒，然后再输出语句。因为启动了协程，并且协程里的代码等了1秒再执行余下的语句，因此，主函数中的输出语句先执行了，这样就得到了我们期望的输出顺序。</p>

<h3>配置协程运行环境</h3>

<p><strong>注意，注意</strong>，协程并不是Kotlin标准库的一部分，它属于<a href="https://github.com/Kotlin/kotlinx.coroutines/tree/master">官方扩展库</a>的一部分，有自己单独的版本号，要想使用协程还需要<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects">单独配置依赖</a>。协程模块的名字是kotlinx.coroutines，有自已独立的版本号，需要注意的是，要注意Kotlin版本与协程版本之间的匹配关系，协程库对它所支持的Kotlin有最低版本要求。目前协程库最新版本是1.8.0-RC2，它对应的Kotlin版本是1.9.21。</p>

<p>配置协程库依赖：</p>

<h4>Maven</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;dependency&gt;</span>
</span><span class='line'>    <span class="nt">&lt;groupId&gt;</span>org.jetbrains.kotlinx<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>    <span class="nt">&lt;artifactId&gt;</span>kotlinx-coroutines-core<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>    <span class="nt">&lt;version&gt;</span>1.8.0-RC2<span class="nt">&lt;/version&gt;</span>
</span><span class='line'><span class="nt">&lt;/dependency&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;properties&gt;</span>
</span><span class='line'>    <span class="nt">&lt;kotlin.version&gt;</span>1.9.21<span class="nt">&lt;/kotlin.version&gt;</span>
</span><span class='line'><span class="nt">&lt;/properties&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Gradle</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='Groovy'><span class='line'><span class="n">dependencies</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">implementation</span><span class="o">(</span><span class="s2">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.8.0-RC2&quot;</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">plugins</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// For build.gradle.kts (Kotlin DSL)</span>
</span><span class='line'>    <span class="n">kotlin</span><span class="o">(</span><span class="s2">&quot;jvm&quot;</span><span class="o">)</span> <span class="n">version</span> <span class="s2">&quot;1.9.21&quot;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// For build.gradle (Groovy DSL)</span>
</span><span class='line'>    <span class="n">id</span> <span class="s2">&quot;org.jetbrains.kotlin.jvm&quot;</span> <span class="n">version</span> <span class="s2">&quot;1.9.21&quot;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">repositories</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">mavenCentral</span><span class="o">()</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Android</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Groovy'><span class='line'><span class="n">implementation</span><span class="o">(</span><span class="s2">&quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.8.0-RC2&quot;</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>协程是啥</h2>

<p><img src="https://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/58ee3d6d55fbb2fb3f8cdfbe474a20a44723dcf3.jpg" alt="" /></p>

<p>那么协程是啥呢？协程就是一个子例程，或者说一个函数，与常规的函数其实也没啥区别，只不过它可以异步地执行，可以挂起，当然不同的协程也可以并行的执行（这就是并发了）。协程是没有阻塞的，协程只会挂起，一旦协程挂起，就交出CPU的控制权，就可以去执行其他协程了。协程是一种轻量级的线程，但它并不是线程，跟线程也没有直接关系，当然它跟其他函数一样，也是要运行在某一个线程里面的。</p>

<p>在Kotlin中协程的关键字是suspend，它用以修饰一个函数，suspend函数只能被另一个suspend函数调用，或者运行在一个协程内。另外就是delay函数了，它是将协程挂起一定时间。<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch/async</a>函数则是创建并启动一个协程，await函数是等待一个协程执行结束并返回结果。runBlocking函数则是创建一个可以使用协程的作用域，叫作CoroutineScope，协程只能在协程作用域内启动，作用域的目的就是为了管理在其内启动的协程。不理解或者记不住这些关键字和函数也没有关系，这里只需要先有一个印象就够了。</p>

<h3>动动手，折腾一下</h3>

<p>对于我们的『Hello, coroutines!』程序，可以尝试进行一些修改，比如改一下delay的值，去掉runBlocking，或者去掉launch看看会发生什么！</p>

<h2>创建协程</h2>

<p>在继续之前，我们把之前的代码重构一下，把协程代码块抽象成一个函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span> <span class="c1">// this: CoroutineScope</span>
</span><span class='line'>    <span class="n">launch</span> <span class="p">{</span> <span class="n">doWorld</span><span class="p">()</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// Hello, coroutines!</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// this is your first suspending function</span>
</span><span class='line'><span class="n">suspend</span> <span class="k">fun</span> <span class="nf">doWorld</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">delay</span><span class="p">(</span><span class="m">1000L</span><span class="p">)</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;, coroutines!!&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>功能没变仍是输出『Hello, coroutines!』只不过代码块变成了一个suspend函数，被suspend修饰的函数只能运行在协程之中，或者被另一个suspend函数调用，当然 最终仍是要运行在某一个协程之中的。</p>

<p>创建协程的函数是launch()和<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async()</a>，它们都是函数，参数都是一个代码块，它们的作用是创建一个协程并让代码块参数运行在此协程内。把上面的launch换成async得到的结果是一模一样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span> <span class="c1">// this: CoroutineScope</span>
</span><span class='line'>    <span class="n">async</span> <span class="p">{</span> <span class="n">doWorld</span><span class="p">()</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// Hello, coroutines!</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然了，它们之间肯定是区别的，要不然何必费事弄两个函数呢，我们后面再讲它们的具体区别。</p>

<p>到现在我们知道了如何创建协程了，但如我们手动把<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a>删除掉，就会有编译错误，说launch/async找不到，那是因为这两个函数是扩展函数，它们是CoroutineScope类的扩展函数。前面说了，所有的协程必须运行在一个CoroutineScope内，前面的runBlocking函数的作用就是创建一个CoroutineScope，下面我们重点来看看啥是CoroutineScope。</p>

<h2>协程作用域</h2>

<p><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/">作用域（CoroutineScope）</a>是用于管理协程的，所有的协程必须运行在某个作用域内，这样通过作用域就可以更好的管理协程，比如控制它们的生命周期。这里面的概念就是<a href="https://kotlinlang.org/docs/coroutines-basics.html#structured-concurrency">结构化并发(structured concurrency)</a>，也就是让所有的协程以一种结构化的方式来组织和管理，以让整体的并发更为有秩序和可控。</p>

<p><img src="https://www.ericthecoder.com/wp-content/uploads/2019/09/feature-1.jpg" alt="" /></p>

<p>这与人类社会是类似的，比如军队，要把士兵编为不同的组织结构（如团，旅，师，军，集团军），目的就是增强整体的执行效率，进而增强战斗力，试想一个军队，如果没有组织结构，那就会是一盘散沙，战斗力可想而知。</p>

<h3>如何创建作用域</h3>

<p>有很多<a href="https://kotlinlang.org/docs/coroutines-basics.html#scope-builder">构造器方法</a>可以用于创建作用域，基本上不会直接创建作用域对象。最常见的就是用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a>函数，它的作用是创建一个CoroutineScope，执行里面的协程，并等待所有的协程执行完毕后再退出(返回)，我们可以继续改造我们的例子，自己为我们的协程创建一个作用域：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">doWorld</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">suspend</span> <span class="k">fun</span> <span class="nf">doWorld</span><span class="p">()</span> <span class="p">=</span> <span class="n">coroutineScope</span> <span class="p">{</span>  <span class="c1">// this: CoroutineScope</span>
</span><span class='line'>    <span class="n">launch</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="m">1000L</span><span class="p">)</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;, coroutines!!&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>还有一些其他的作用域生成方法如runBlocking和<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/">GlobalScope</a>，GlobalScope是一个全局的作用域，也就是Kotlin提供的一个在整个Kotlin中都可以直接使用的协程作用域，显然，我们不应该使用它，因为作用域的目的在于组织和管理协程，如果把所有的协程都放在一个全局作用域下面了，那跟没有使用域也没有啥区别了。就好比一个军队，只有一个将军，下面直辖一万个士兵，这跟没有将军是没有分别的。</p>

<p>至于runBlocking，它是创建一个作用域，执行其里面创建的协程，等待所有协程执行完毕后退出，但它还有一个重要的功能就是，在等待协程执行的过程中它会阻塞线程，以保证调用者的线程一定比协程晚些退出。因此，只应该在一个地方使用runBlocking，那就是在主函数中使用，其他地方都不应该使用它。</p>

<p>虽然说协程必须运行在某一个CoroutineScope中，但是不是说在每个要创建协程的地方都使用coroutineScope创建一个新的作用域呢？这显然是滥用了。作用域的目的在于组织和管理协程，因此作用域应该符合架构设计的原则，比如为一个模块或者同一类功能创建一个作用域，以方便管理其内部分的协程。并且CoroutineScope是树形结构的，也就是说作用域本身也可以管理其他作用域，这才能形成完整的结构，体现结构化并发的思想。</p>

<h3>使用框架中的CoroutineScope</h3>

<p>如前所述作用域更多的要从架构角度来考虑。实际上大多数时候，我们并不需要自己创建作用域，因为框架会为我们准备好。就好比Jetpack中的<a href="https://developer.android.com/topic/libraries/architecture/viewmodel">ViewModel</a>，它的作用是把UI操作的逻辑封装起来，那么ViewModel中的所有协程都应该运行在viewModelScope之中，而这是框架已经为我们创建好了的，它会结合系统组件生命周期来管理协程。</p>

<h2>运行上下文</h2>

<p>协程不是什么神密的东西，也不是什么银弹，它就是一个普通的函数（例程routine），只不过它可以异步执行，也就是说launch了一个协程后，这条语句很快就执行完了，马上去执行launch {&hellip;}下面的语句了，协程代码块的执行是在协程里面，它什么时候返回结果是不知道的。也可以挂起，协程挂起后就释放了运行它的线程，并不会阻塞运行它的线程，那么其他协程就有机会运行。</p>

<p>这就涉及另一个重要的东西，就是协程运行的上下文，或者说协程运行的线程环境。协程它就是一个函数，它当然需要运行在某个线程里面。除非特别指定以切换运行的线程，否则所有的协程是运行在主线程中的。</p>

<p>协程的运行环境由<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/">CoroutineContext</a>来定义，但其实基本上不会直接创建这个对象，都是通过参数或者其他构建函数来指定协程的运行上下文环境。</p>

<h3>创建协程时指定上下文</h3>

<p>创建协程的函数launch和async是有多个参数，一共有三个参数，最后一个当然是代码块，前面两个都是有默认值的参数，因此大部分时候可以省略，它们的完整函数签名是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">CoroutineScope</span><span class="p">.</span><span class="n">launch</span><span class="p">(</span>
</span><span class='line'>    <span class="n">context</span><span class="p">:</span> <span class="n">CoroutineContext</span> <span class="p">=</span> <span class="n">EmptyCoroutineContext</span><span class="p">,</span>
</span><span class='line'>    <span class="n">start</span><span class="p">:</span> <span class="n">CoroutineStart</span> <span class="p">=</span> <span class="n">CoroutineStart</span><span class="p">.</span><span class="n">DEFAULT</span><span class="p">,</span>
</span><span class='line'>    <span class="n">block</span><span class="p">:</span> <span class="n">suspend</span> <span class="n">CoroutineScope</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">Unit</span>
</span><span class='line'><span class="p">):</span> <span class="n">Job</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="err">&lt;</span><span class="nf">T</span><span class="p">&gt;</span> <span class="n">CoroutineScope</span><span class="p">.</span><span class="n">async</span><span class="p">(</span>
</span><span class='line'>    <span class="n">context</span><span class="p">:</span> <span class="n">CoroutineContext</span> <span class="p">=</span> <span class="n">EmptyCoroutineContext</span><span class="p">,</span>
</span><span class='line'>    <span class="n">start</span><span class="p">:</span> <span class="n">CoroutineStart</span> <span class="p">=</span> <span class="n">CoroutineStart</span><span class="p">.</span><span class="n">DEFAULT</span><span class="p">,</span>
</span><span class='line'>    <span class="n">block</span><span class="p">:</span> <span class="n">suspend</span> <span class="n">CoroutineScope</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">T</span>
</span><span class='line'><span class="p">):</span> <span class="n">Deferred</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>第一个参数便是指定协程运行的上下文。现在可以为我们的协程加上线程环境了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">doWorld</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">suspend</span> <span class="k">fun</span> <span class="nf">doWorld</span><span class="p">()</span> <span class="p">=</span> <span class="n">coroutineScope</span> <span class="p">{</span>  <span class="c1">// this: CoroutineScope</span>
</span><span class='line'>    <span class="n">launch</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">Default</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="m">1000L</span><span class="p">)</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;, coroutines!!&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>使用扩展函数withContext</h3>

<p>另外一种方式就是使用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html">扩展函数withContext</a>，在其参数指定的上下文环境中调用代码块中的协程，等待其执行完，并返回结果。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">suspend</span> <span class="k">fun</span> <span class="err">&lt;</span><span class="nf">T</span><span class="p">&gt;</span> <span class="n">withContext</span><span class="p">(</span><span class="n">context</span><span class="p">:</span> <span class="n">CoroutineContext</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">suspend</span> <span class="n">CoroutineScope</span><span class="p">.()</span> <span class="p">-&gt;</span> <span class="n">T</span><span class="p">):</span> <span class="n">T</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的例子也可以这样写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">doWorld</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">suspend</span> <span class="k">fun</span> <span class="nf">doWorld</span><span class="p">()</span> <span class="p">=</span> <span class="n">coroutineScope</span> <span class="p">{</span>  <span class="c1">// this: CoroutineScope</span>
</span><span class='line'>    <span class="n">launch</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">withContext</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">Default</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">delay</span><span class="p">(</span><span class="m">1000L</span><span class="p">)</span>
</span><span class='line'>            <span class="n">println</span><span class="p">(</span><span class="s">&quot;, coroutines!!&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>但这并不是好的用法，withContext应该用在一些suspend方法中，并且这些方法想自己指定执行环境，并且执行环境对调用方是透明的。比如说，一个负责用户操作的UesrRepository，它只向外部暴露一些suspend方法，在这些suspend方法内部通过withContext来指定它自己运行的上下文环境，从而不用管调用者的执行环境，不也需要调用者知道repo的执行环境：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">UserRepository</span><span class="p">(</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">dispatcher</span><span class="p">:</span> <span class="n">Dispatcher</span> <span class="p">=</span> <span class="n">Dispathers</span><span class="p">.</span><span class="n">IO</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">suspend</span> <span class="k">fun</span> <span class="nf">login</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">withContext</span><span class="p">(</span><span class="n">dispatcher</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// Do login</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>让每一个架构层次或者模块自己管理好自己运行的上下文，还有一个好处在于，可以方便的通过<strong>依赖注入</strong>来进行<strong>Mock或者测试</strong>。</p>

<h3>使用框架中的上下文环境</h3>

<p>虽然我们可以指定<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/">协程运行的上下文环境</a>，那是不是意味着要自己创建很多的context呢？非也，非也。框架中也预定义好了<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/">很多context</a>，可以直接拿来用，比如<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html">Dispatchers.Default</a>，这是Kotlin中的默认线程适合做计算密集类任务；<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-i-o.html">Dispatchers.IO</a>，这适合做IO密集的操作，如文件读写，网络等；<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html">Dispatchers.Main</a>，这是Kotlin中的主线程（即main函数运行的线程），UI中的主线程（如Swing和安卓的主线程）；等等，当然了，也可以自己创建一个context。</p>

<p>到这里我们可以发现，现代化的并发框架较以前是是非常的完备，从创建，到管理，再到运行环境都考虑的非常全面。比如<a href="https://github.com/ReactiveX/RxJava">RxJava</a>或者我们现在正在学习的协程，都是如此。在Java中，其实也有类似的东西，其实就是<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html">ExecutorService</a>，它就是异步和并发任务运行的环境。只不过，它的API设计的还是太过原始，你仍然 需要自己去实现一个<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html">Executor</a>，并没有像RxJava中的<a href="https://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/schedulers/Schedulers.html">Schedulers</a>以及Kotlin中的Dispatchers一样，有一些功能明确的预定义的对象可以直接使用。</p>

<h2>并发性</h2>

<p>并发就是代码『同时运行』，当然 有真并发，那就是并行，比如两台电脑同时都在运行不同的或者相同的应用程序，类似于两个人同时都在干活儿，这是并行（真并发）；大多数并发都是假的，只不过操作系统以粒度非常小的时间片在不同的代码间来回切换，让人感觉起来好像所有的代码都在同时运行，但真到了CPU的指令周期里面，其实同一个周期只能执行一个命令。当然了，现代处理器都具有多核心，每个核心可以执行一个指令，因此多核心可以真的同时运行多个线程，也可以实现真并发。</p>

<p>并发的前提是要能异步，也就是像我们的launch {&hellip;}一样，它很快就执行完了，这样后面可以继续执行，因此，协程是可以实现并发的，也就是让多个协程『同时运行』：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">doWorld</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Concurrently executes both sections</span>
</span><span class='line'><span class="n">suspend</span> <span class="k">fun</span> <span class="nf">doWorld</span><span class="p">()</span> <span class="p">=</span> <span class="n">coroutineScope</span> <span class="p">{</span> <span class="c1">// this: CoroutineScope</span>
</span><span class='line'>    <span class="n">launch</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="m">2000L</span><span class="p">)</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;, coroutine #2, comes later!&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">launch</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="m">1000L</span><span class="p">)</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;, coroutine #1, here I am!&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//Hello, coroutine #2, here I am!</span>
</span><span class='line'><span class="c1">//, coroutine #1, comes later!</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，我们这里是假并发，我们没有指定线程，两个协程都是运行在主线程里面的，但它们没有相互影响，更没有阻塞发生，它们确实是『同时运行的』。</p>

<p>当然了，在实际开发过程中呢，肯定还是要指定协程的运行线程，以实现真的并发，原因在于真实的软件代码是比较复杂，主线程，以及每个协程都有大量的代码要执行，都去揩主线程的油，肯定 很快就被榨干了，所以必然要上<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-i-o.html">Dispatchers.IO</a>之类的多线程以实现真正的并发。</p>

<h2>可控制性</h2>

<p>好的并发框架一定是可控的，也就是说对于异步任务来说要能很好的<strong>开启</strong>，<strong>等待</strong>和<strong>终止</strong>。Kotlin中的协程是可以做到这一点的。前面说到launch和async都可以创建一个协程，那它俩到底 啥区别？我们从前面它们的函数签名可以看出它俩的返回值是不一样的，launch返回一个<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/">Job对象</a>，而async返回一个<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/">Deferred对象</a>。</p>

<p>Job对象可以理解为协程的一个句柄，可以用来控制协程，比如终止它（取消它cancel），『同步等待』它执行完（join()）。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">suspend</span> <span class="k">fun</span> <span class="nf">doWorld</span><span class="p">()</span> <span class="p">=</span> <span class="n">coroutineScope</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">job</span> <span class="p">=</span> <span class="n">launch</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="m">2000L</span><span class="p">)</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot; and coroutine #2&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">launch</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="m">1000L</span><span class="p">)</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;from coroutine #1 !&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">job</span><span class="p">.</span><span class="n">join</span><span class="p">()</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;All jobs done.&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">doWorld</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的例子输出是符合期望的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='Bash'><span class='line'>Hello
</span><span class='line'>from coroutine <span class="c">#1 !</span>
</span><span class='line'> and coroutine <span class="c">#2</span>
</span><span class='line'>All <span class="nb">jobs </span><span class="k">done</span>.
</span></code></pre></td></tr></table></div></figure>


<p>而如果，把 job.join()去掉的话，因为launch {&hellip;}创建的协程是异步执行，很快就返回了，最后的语句println(&ldquo;All jobs done.&rdquo;)会得到执行，因为协程都有delay，所以『All jobs done.』要先于协程中的语句输出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='Bash'><span class='line'>Hello
</span><span class='line'>All <span class="nb">jobs </span><span class="k">done</span>?
</span><span class='line'>from coroutine <span class="c">#1 !</span>
</span><span class='line'> and coroutine <span class="c">#2</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.gkI-tiJSxqG7wpydbs9EugHaEK?rs=1&amp;pid=ImgDetMain" alt="" /></p>

<p>而Deferred是Job的一个子类，它特有的功能是取得协程的返回结果，通过其await函数可以『同步的等待』协程结果返回，launch可以通过Job来等待协程执行完成，但是拿不到协程的返回结果，这就是launch与async的最大的区别。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">one</span> <span class="p">=</span> <span class="n">async</span> <span class="p">{</span> <span class="n">computeOne</span><span class="p">()</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">two</span> <span class="p">=</span> <span class="n">async</span> <span class="p">{</span> <span class="n">computeTwo</span><span class="p">()</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot; Finally we got: ${one.await() + two.await()}&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span> <span class="n">suspend</span> <span class="k">fun</span> <span class="nf">computeOne</span><span class="p">():</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">withContext</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">IO</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">print</span><span class="p">(</span><span class="s">&quot;Coroutine #1: Calculating ...&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="m">2400</span><span class="p">)</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">res</span> <span class="p">=</span> <span class="m">12</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;, got $res&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span><span class="n">@withContext</span> <span class="n">res</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">private</span> <span class="n">suspend</span> <span class="k">fun</span> <span class="nf">computeTwo</span><span class="p">():</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">withContext</span><span class="p">(</span><span class="n">Dispatchers</span><span class="p">.</span><span class="n">IO</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">print</span><span class="p">(</span><span class="s">&quot;Coroutine #2: Calculating ...&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="m">2200</span><span class="p">)</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">res</span> <span class="p">=</span> <span class="m">20</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;, got $res&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span><span class="n">@withContext</span> <span class="n">res</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">//Coroutine #1: Calculating ...Coroutine #2: Calculating ..., got 20</span>
</span><span class='line'><span class="c1">//, got 12</span>
</span><span class='line'><span class="c1">// Finally we got: 32</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>注意，注意</strong>：前面说Job#join()和Deferred#await()都可以『同步地等待』协程执行完成，但这里的『同步等待』是非阻塞式的，它只是把当前协程挂起，虽然说join和await后面的语句在协程返回前不会得到执行，但这并不是像<a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/sleep.html">join/sleep/wait</a>之于<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html">Thread</a>那种阻塞式的。协程的join和await只是挂起，把运行环境中的线程释放，在此期间其他协程是可以得到CPU资源（即线程）继续运行的。</p>

<h2>总结</h2>

<p>本文主要介绍了Kotlin中的协程基本使用方法：在一个协程作用域中，通过launch/async来创建一个协程，通过context来切换协程的运行上下文（线程环境），并可以通过Job/Deferred对象来控制协程。</p>

<p>到此，我们可以总结出协程的一些特点：</p>

<ul>
<li><strong>轻量级</strong>，它是纯编程语言层面的东西，不涉及操作系统支持的进程和线程的创建，因此它占用的资源非常少，是轻量级的异步和并发利器。</li>
<li><strong>非阻塞式</strong>，协程最重要的特点是非阻塞，它的等待虽然会让其后面的语句延迟执行，但此时运行的线程已被释放，其他协程可以得到运行。</li>
<li><strong>设施完备</strong>，管理协程的作用域，切换运行环境的context，协程的可控，可以非常优雅的实现结构化并发编程，从而减少出错，并且完全可测。</li>
</ul>


<p>其实，可以看出<strong>协程是一种代码执行上的操作框架</strong>，它能让代码挂起，交出真实的CPU控制权（可以想像为一个大的switch语句，在不同的函数之间跳转切换）。进程和线程都是操作系统直接支持的，操作硬件资源的方法，一个运行中的线程必须占有一个CPU核心，线程只能被阻塞，无法挂起，因为操作系统切换线程就意味着让CPU去运行另外一个线程，那么前一个线程就进入了阻塞状态(Blocked)，等操作系统再切换回这个线程时，它才得以继续运行，从阻塞状态转为运行状态。而协程是纯的编程语言层面实现的东西，视线程为透明，一旦挂起，就可以去执行另一坨代码，它全靠程序员自己来控制，协程，即一起协作的子例程，这也是协程，作为新一代并发编程范式最大的优势。</p>

<h2>书籍推荐</h2>

<p>《Kotlin编程实战》是推荐的书籍，这本书比较厚实，把Kotlin的每个特性都论述的十分详细。</p>

<h2>实践</h2>

<p>强烈推荐<a href="https://kotlinlang.org/docs/coroutines-and-channels.html">官方的一个实战教程</a>，非常适合入门，难度也不大，并且有答案，可以一步一步的学会使用协程，并理解它。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/coroutines-guide.html">Coroutines guide</a></li>
<li><a href="https://kotlinlang.org/docs/coroutines-basics.html">Coroutines basics</a></li>
<li><a href="https://kotlinlang.org/docs/coroutines-and-channels.html">Coroutines and channels − tutorial</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding KMP Algorithm]]></title>
    <link href="http://toughcoder.net/blog/2023/12/11/understanding-kmp-algortihm/"/>
    <updated>2023-12-11T22:21:17+08:00</updated>
    <id>http://toughcoder.net/blog/2023/12/11/understanding-kmp-algortihm</id>
    <content type="html"><![CDATA[<p>字符串模式匹配问题是非常重要且基础的问题，它是解决在目标字符串str中搜索模式字符串pattern出现的次数，或者索引位置。这个问题最为高效的方法就是著名的KMP算法，但这个算法不太好理解，毕竟是解决了从O(n<sup>2</sup>)的复杂度提升到线程O(n)的，今天就来学习并理解一下KMP算法。</p>

<p><a href="http://toughcoder.net/blog/2023/12/11/understanding-kmp-algortihm/"><img src="https://www.boardinfinity.com/blog/content/images/2022/10/27c5585ec1e3503400.webp" title="auto auto" ></a></p>

<!-- more -->


<p>字符串模式匹配问题有很多变幻，比如从头匹配就是前缀匹配，从后就是后缀匹配，找出所有匹配的索引，找第一个，看是否有匹配等等。以及其他能转化为模式匹配的问题，比如回文相关问题，但本质都<strong>模式匹配</strong>问题。这里就以寻找模式pattern在str中的第一个索引位置为例题。</p>

<h2>暴力大法</h2>

<p>世上无难题，只要能用暴力不超时。很容易写出一个暴力方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kt">int</span> <span class="nf">index</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">,</span> <span class="n">String</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
</span><span class='line'>  <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>      <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span> <span class="o">&amp;&amp;</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="o">)</span> <span class="o">==</span> <span class="n">pattern</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">j</span><span class="o">++;</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">return</span> <span class="n">i</span><span class="o">;</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>很明显暴力大法的时间复杂度是O(nm)，需要从str中的每一个字符开始尝试去匹配pattern。str的指针在尝试这一次匹配后，只能向前<strong>步进一个</strong>，这是暴力大法最大的问题。假如能有方法让它步进的快一些，那么就能显著 的提升效率，这就是KMP算法的牛逼之处。</p>

<h2><a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">KMP算法</a></h2>

<p>KMP算法的牛逼之处就是利用<strong>预处理</strong>和已做过的<strong>上一次匹配</strong>来<strong>快速步进</strong>str的i指针，使总的匹配次数降到O(n + m)。</p>

<p>无论是否能理解，好在代码不长，就当模板题背下来吧。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">int</span> <span class="nf">index</span><span class="o">(</span><span class="n">String</span> <span class="n">str</span><span class="o">,</span> <span class="n">String</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">char</span><span class="o">[]</span> <span class="n">sc</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
</span><span class='line'>    <span class="kt">char</span><span class="o">[]</span> <span class="n">pc</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">();</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">pc</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
</span><span class='line'>    <span class="kt">int</span><span class="o">[]</span> <span class="n">next</span> <span class="o">=</span> <span class="n">calcNext</span><span class="o">(</span><span class="n">pc</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">sc</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="n">pc</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">j</span> <span class="o">=</span> <span class="n">next</span><span class="o">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">sc</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="n">pc</span><span class="o">[</span><span class="n">j</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">j</span><span class="o">++;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">m</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">i</span> <span class="o">-</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">calcNext</span><span class="o">(</span><span class="kt">char</span><span class="o">[]</span> <span class="n">pattern</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">m</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
</span><span class='line'>    <span class="kt">int</span><span class="o">[]</span> <span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">];</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">pattern</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">!=</span> <span class="n">pattern</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">k</span> <span class="o">=</span> <span class="n">next</span><span class="o">[</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">pattern</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">==</span> <span class="n">pattern</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">k</span><span class="o">++;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">next</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">next</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>next数组</strong>的现实意义是在pattern中当前字符之前的<strong>最长前后缀长度</strong>。前后缀就是即是前缀，又是后缀，比如&#8217;abcddabc&#8217;，这里&#8217;abc&#8217;就是这个字符串的前后缀。next数组长度与pattern长度一致，next[i]的意义是，在pattern中截止到pattern[i]的子串的最长前后缀长度。要牢记next数组的意义，这会是KMP的重点应用范围，比如题214回文问题。</p>

<p>整个KMP算法，匹配过程并不难理解，主串的指针i从不回溯，一直在前进，而模式串的j指针则不断的跳转到其next数组指示的位置。核心仍是next数组的计算方式，有些难于理解，当作模板背下来也行。当涉及<strong>最长前后缀</strong>的题目时，就可以拿出next数组来使用。</p>

<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. 找出字符串中第一个匹配项的下标</a>  </td>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/1650934/by-alexhilton-7n6e/">题解</a>  </td>
<td style="text-align:left;"> KMP板子题 </td>
</tr>
<tr>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/shortest-palindrome/description/">214. 最短回文串</a>  </td>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/shortest-palindrome/solutions/2562115/xi-you-yuan-su-214-zui-duan-hui-wen-chua-0nac/">题解</a>  </td>
<td style="text-align:left;"> next数组妙用 </td>
</tr>
<tr>
<td style="text-align:left;">  <a href=""></a>  </td>
<td style="text-align:left;">  <a href="">题解</a>  </td>
<td style="text-align:left;">  </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/">KMP Algorithm for Pattern Searching</a></li>
<li><a href="https://www.javatpoint.com/daa-knuth-morris-pratt-algorithm">The Knuth-Morris-Pratt (KMP)Algorithm</a></li>
<li><a href="https://cp-algorithms.com/string/prefix-function.html">Prefix function. Knuth–Morris–Pratt algorithm</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/83334559">KMP 算法详解</a></li>
<li><a href="https://www.cnblogs.com/dusf/p/kmp.html">KMP算法详解-彻底清楚了(转载+部分原创) </a></li>
<li><a href="http://data.biancheng.net/view/180.html">KMP算法（快速模式匹配算法）C语言详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/145536254">全网最通俗的KMP算法图解</a></li>
<li><a href="https://blog.csdn.net/weixin_46007276/article/details/104372119">数据结构KMP算法配图详解（超详细）</a></li>
<li><a href="https://www.cnblogs.com/lin0/p/16252948.html">图解KMP字符串匹配算法+代码实现</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让你从此不再惧怕ANR]]></title>
    <link href="http://toughcoder.net/blog/2023/12/08/android-anr-made-easy/"/>
    <updated>2023-12-08T22:12:55+08:00</updated>
    <id>http://toughcoder.net/blog/2023/12/08/android-anr-made-easy</id>
    <content type="html"><![CDATA[<blockquote><p>这篇文章是基于官方的<a href="https://developer.android.com/topic/performance/anrs/diagnose-and-fix-anrs">Diagnose and fix ANRs</a>翻译而来，但也不是严格的翻译，原文的内容都在，又加上了自己的理解以及自己的经验，以译注的形式对原文的作一些补充。</p></blockquote>

<hr />


<p>当一个Android应用的UI线程被阻塞时间过长，系统就会发出一个臭名昭著的“应用程序未响应”(ANR, Application Not Responding&#8221;)错误。本文将讲述不同类型的ANR，如何分析以及如何解决。文中列出的所有的超时时间范围都是基于<a href="https://source.android.com/">AOSP</a>和Pixel设备；这些时间范围可能会依OEM厂商而不同。</p>

<p><a href="http://toughcoder.net/blog/2023/12/08/android-anr-made-easy/"><img src="https://ts1.cn.mm.bing.net/th/id/R-C.b5cd953e9f33003456314ae6608fcecc?rik=pPBn5R3rPZ83ew&riu=http%3a%2f%2fiotts.com.cn%2fblog%2fimages%2fAndroid_a.jpg&ehk=qj91EEfUUgZ32njo8AfBJIdOoPJYInW%2b7chI6g6Jxqs%3d&risl=&pid=ImgRaw&r=0" title="auto auto" ></a></p>

<!-- more -->


<p>需要注意的是，当分析ANR的根因时，区分<strong>系统原因</strong>和<strong>应用本身的原因</strong>是很有帮助的。
当整个系统处于一个糟糕状态时，下面这些问题可能会引发ANR：</p>

<ul>
<li>系统服务内部的一些瞬时问题(Transient issues)就会导致通常很快的binder call变得非常慢。</li>
<li>系统服务的问题以及较高的系统负载会导致应用程序的线程无法被正常的调度。</li>
</ul>


<blockquote><p><strong>译注：</strong><a href="https://learn.microsoft.com/en-us/azure/architecture/best-practices/transient-faults">瞬时问题Transient issue</a>是指一些服务运行时出现了一些瞬时的小错误比如服务器的网络抽风(闪断又闪连)，或者一个系统服务的I/O错误，但可能会导致客户无法正常的获得响应。这里要这样来理解，服务(servers)一般都是长时间运行的，它是有可能会发生一些小错误的，瞬时的很快就恢复了，但如果客户恰好在此时来请求就不会得到响应。尽管这对于服务来说是一个可以忽略的小错误，毕竟它是长时间运行的，几秒钟的小错误不影响它本身的运行，但对客户侧的影响却是较大，对客户侧来说就是请求得不到响应。</p></blockquote>

<p>如果可以的话，区分系统问题还是应用问题的好方法就是使用<a href="https://perfetto.dev/docs/">Perfetto traces</a>:</p>

<ul>
<li>通过查看在Perfetto跟踪的是运行中还是未运行的线程的状态来判断应用的主线程有没有被正常的调度。</li>
<li>查看系统进程system_server的线程，看有没有锁竞争之类的问题。</li>
<li>对于耗时的(跨进程调用)binder calls，查看一下是否存在应答进程，以及为何它会耗时。</li>
</ul>


<blockquote><p><strong>译注：</strong>很多重要的系统服务都在system_server进程里面，如负责创建调度所有组件的<a href="https://android.googlesource.com/platform/frameworks/base/+/4f868ed/services/core/java/com/android/server/am/ActivityManagerService.java">AMS(Activity Manager Service)</a>，包管理<a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/services/core/java/com/android/server/pm/PackageManagerService.java">PMS(Package Manager Service)</a>，窗口管理<a href="https://android.googlesource.com/platform/frameworks/base/+/android-4.3_r2.1/services/java/com/android/server/wm/WindowManagerService.java">WMS(Window Manager Service)</a>等等，system_server进程本来的load其实不轻。再加上很多OEM定制化的功能也必须要在AMS处做事情（如hook或者拦截），导致system_server并不比应用程序少引发问题，而一旦system_server有耗时操作或者在等待锁，会导致整个系统处于极度卡顿状态，这时事件的派发，组件的创建，生命周期的调度，以及WMS的焦点处理等等正常的逻辑都不可能得到及时的流转和响应。这种时候任何一个应用都可能随时发生ANR，但应用本身却都是idle状态，问题是在system_server这一侧。</p>

<p><a href="https://developer.android.com/reference/android/os/Binder">Binder</a>是安卓系统的核心基础通信机制，组件件间的通信，Intent，ContentResolver，应用与AMS，PMS和WMS等等之间的交互都是通过binder call来进行的，常规情况下大部分时候binder call都没有问题会很快问题，但如果binder另一头的某个服务发生了问题，即使是瞬时问题，也会导致binder call被阻塞或者变慢，这时就可能引发应用侧的ANR。</p>

<p>需要厘清概念，系统服务(services)与进程并不是同一回事，也不是一一对应的关系。系统服务是安卓系统架构上的模块，都分布于框架层，支撑着系统的运转。而进程则是CPU（准确的说是操作系统内核）运行和调度的基本单元（进程则再细分为线程）。一个系统服务可能独立占用一个进程，比如像<a href="https://cs.android.com/android/platform/superproject/+/master:packages/providers/MediaProvider/src/com/android/providers/media/MediaService.java">Media Service(mediaserver)</a>，<a href="https://source.android.com/docs/core/camera">CameraService(cameraserver)</a>，也可能会生成几个进程；当然 也有可能几个服务都在同一个进程里面，比如前面提到的与应用程序最为密切相关的三大服务AMS, WMS和PMS。当一个服务必须要有独立进程的时候，就会为它创建独立的进程，比如像CameraService，在Android O以前是没有独立进程的，它活在mediaserver里，后来才有独立的进程cameraserver。</p>

<p>服务是架构上的逻辑概念，而进程和线程是从硬件（CPU）角度看到的代码的执行。ANR是由于进程（准确的说是线程，进程由至少一个线程组成）卡顿或者被阻塞导致的。调试的手段也都是从代码执行的角度，把线程的栈帧转储出来(stack trace dump)，以查看是被哪 个函数阻塞了。</p></blockquote>

<h2>输入派发超时(Input dispatch timeout)</h2>

<p>输入派发无响应发生在应用的主线程无法及时地响应一个输入事件，如滑动手势或者物理按键。因为当输入派发超时发生时应用是在前台的，所以这类超时总是对用户可见的，所以想办法规避是很重要的。</p>

<p><strong>默认超时时间：5秒</strong></p>

<p>输入派发超时无响应通常是由于主线程的问题引起的。如果主线程因为等待获取某个锁而阻塞，锁的持有线程也包含在内。遵循以下最佳实践以防止输入派发未响应：</p>

<ul>
<li>主线程不要进行可能会阻塞或者耗时的操作。可以考虑使用<a href="https://developer.android.com/reference/android/os/StrictMode">严格模式StrictMode</a>来捕捉主线程的一些异常的行为。</li>
<li>尽可能的减少主线程和其他线程之间的锁竞争。</li>
<li>在主线程尽可能减少非UI相关的操作，比如当处理广播(Broadcasts)时或者处理服务时(Services)。</li>
</ul>


<h3>常见的根因</h3>

<p>这里列出一些输入派发无响应常见的根因以及修复建议。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 根因 </th>
<th style="text-align:left;"> 表象 </th>
<th style="text-align:left;"> 修复建议 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 耗时跨进程调用slow binder call </td>
<td style="text-align:left;"> 主线程执行了一个耗时同步binder call </td>
<td style="text-align:left;"> 把这个调用放到非主线程，或者优化一下这个调用，如果你负责这个API的话 </td>
</tr>
<tr>
<td style="text-align:left;"> 很多连续的binder calls </td>
<td style="text-align:left;"> 主线程执行了很多连续的跨进程调用 </td>
<td style="text-align:left;"> 不要在一个密集的循环中执行binder call </td>
</tr>
<tr>
<td style="text-align:left;"> 阻塞式的I/O </td>
<td style="text-align:left;"> 主线程执行了阻塞式的I/O，如数据库操作或者网络请求 </td>
<td style="text-align:left;"> 把所有阻塞式I/O调用放到非主线程里 </td>
</tr>
<tr>
<td style="text-align:left;"> 锁竞争 </td>
<td style="text-align:left;"> 主线程因为等待获取某个锁而阻塞 </td>
<td style="text-align:left;"> 减少主线程与其他线程之间的锁竞争，优化其他线程中的耗时代码 </td>
</tr>
<tr>
<td style="text-align:left;"> 耗时的帧 </td>
<td style="text-align:left;"> 在一帧里面做太多的渲染，导致严重的丢帧 </td>
<td style="text-align:left;"> 减少帧渲染的工作。不要用超过O(n<sup>2</sup>)的算法。用一些高效的组件来进行滑动和分页，比如<a href="https://developer.android.com/jetpack">Jetpack</a>中的<a href="https://developer.android.com/topic/libraries/architecture/paging/v3-overview">Paging library</a> </td>
</tr>
<tr>
<td style="text-align:left;"> 被其他组件阻塞 </td>
<td style="text-align:left;"> 其他的组件比如广播接收器(BroadcastReceiver)正在运行并阻塞着主线程 </td>
<td style="text-align:left;"> 主线程尽量不要做非UI操作，另起一个线程运行broadcast receivers </td>
</tr>
<tr>
<td style="text-align:left;"> GPU挂起 </td>
<td style="text-align:left;"> GPU挂起是一个系统问题或者硬件问题，会导致渲染被阻塞，因此也会引发输入派发ANR </td>
<td style="text-align:left;"> 很不幸的是在应用程序侧是无法搞定这个问题的。唯一的可能就是联系对应厂商。</td>
</tr>
</tbody>
</table>


<p><br /></p>

<h3>如何调试</h3>

<p>通过查看在Google Play Console和Firebase Crashlytics中的ANR簇标来开始调试。簇集会包含疑似引发ANR的最多的栈帧。</p>

<p><strong>注意：</strong>忽略簇集是&#8221;navivePollOnce&#8221;和&#8221;main thread idle&#8221;的输入派发ANR。这类标志通常是关联着栈帧转储太晚的ANRs，没有可操作的提示所以要忽略掉。一般来说，真正的ANR会在其他簇集里，所以问题并不会被掩盖。详细信息可参见<strong>nativePollOnce部分</strong>。</p>

<blockquote><p><strong>译注：</strong>这篇文档是谷歌官方的，所以它自然会使用谷歌官方的应用后台(Google Play Console)和统计分析(Firebase Crashlytics)工具，对于大部分国内的开发者来说这两个东西可能比较陌生。但没关系，原理是相通的，国内也有很多应用异常统计工具和后台，或者一些本地工具抓取的日志，形式是不限的，只要能收集到类似的栈帧(stack traces)就可以用于分析调试ANR。栈帧(stack frame或者stack trace)就是线程里面的函数调用栈，比如a()->b()->c()->d()这样的函数调用，所有的异常统计工具或者日志工具都能抓取出来某一时刻每个线程的栈帧，这也称之为栈帧转储(stack frame dump)。</p></blockquote>

<p>下面的流程图展示如何确定一个输入派发超时ANR的根因：</p>

<p><img src="https://developer.android.com/static/topic/performance/images/debug-input-dispatch-anr.png" alt="" />
图1. 如何调试一个输入派发无响应ANR</p>

<p>Play vitals能够探测并帮助调试这些常见ANRs原因中的一部分。比如说，如果vitals探测到一个ANR是因为锁竞争，它会总结这些问题并在ANR Insights部分给出建议的修复方法。</p>

<p><img src="https://developer.android.com/static/topic/performance/images/play-vitals-anr-detection.png" alt="" />
图2. Google Play vitals ANR探测</p>

<blockquote><p><strong>译注：</strong>输入派发超时ANR发生的时候应用一定是在前台的，并且用户正在交互。因此重点要看主线程里面的可能的耗时操作，对于系统侧的问题以及关键的生命周期方法则一般不太相干，因为这时生命周期一般都走完了，处理常规的交互阶段。</p></blockquote>

<h2>找不到有焦点的窗口(No focused window)</h2>

<p>像触摸等的事件通过命中测试后会直接发送到相关窗口，而像硬件按键事件则需要一个目标（窗口）。这个目标就是指有焦点的窗口。每一个显示器每一时刻只有一个有焦点的窗口，并且常常就是用户当前正在使用的那个。如果找不到有焦点的窗口，输入服务会触发一个&#8221;No focused window ANR&#8221;。找不到焦点窗口ANR是输入派发无响应中的一种。</p>

<p><strong>默认超时时间：5秒。</strong></p>

<h3>常见的原因</h3>

<p>无焦点窗口ANRs通常由以下原因导致：</p>

<ul>
<li>应用启动做了太多耗时操作，还没有渲染出来第一帧。</li>
<li>应用的主窗口无法获取焦点。如果一个窗口被使用了标志位<a href="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams#FLAG_NOT_FOCUSABLE">FLAG_NOT_FOCUSABLE</a>，那么用户 就无法发送按键事件或者触摸事件到这个窗口上面。</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="n">Bundle</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">super</span><span class="p">.</span><span class="n">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">)</span>
</span><span class='line'>    <span class="n">setContentView</span><span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">layout</span><span class="p">.</span><span class="n">activity_main</span><span class="p">)</span>
</span><span class='line'>    <span class="n">window</span><span class="p">.</span><span class="n">addFlags</span><span class="p">(</span><span class="n">WindowManager</span><span class="p">.</span><span class="n">LayoutParams</span><span class="p">.</span><span class="n">FLAG_FLAG_NOT_FOCUSABLE</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p><strong>译注：</strong>No focused window说明应用应在前台而未在前台，或者不应该在前台而在前台，这类ANR最容易发生在生命周期方法执行太慢导致input与window焦点状态不同步导致的。所以重点要看应用的关键生命周期回调方法是否有耗时操作，比如onCreate()/onDestroy()，onStart()/onStop()，以及特别的onResume()/onPause()。可以与上面的输入派发超时进行对比，可以发现这两类ANR分析的侧重点并不一样。</p></blockquote>

<h2>广播接收器超时(Broadcast receiver timeout)</h2>

<p>广播接收器ANR发生在当一个广播接收器无法及时的响应一个广播。对于一个同步的接收器，或者没有调用<a href="https://developer.android.com/reference/android/content/BroadcastReceiver#goAsync(">goAsync</a>)的receivers，超时的意思是<a href="https://developer.android.com/reference/android/content/BroadcastReceiver#onReceive(android.content.Context,%20android.content.Intent">onReceive()</a>)方法未能及时的执行完。对于异步接收器，或者调用了goAsync的receivers，超时的意思是<a href="https://developer.android.com/reference/kotlin/android/content/BroadcastReceiver.PendingResult#finish">PendingResult.finish</a>未能及时的被调用。</p>

<p>广播接收器ANRs经常发生在这些线程中：</p>

<ul>
<li>主线程，问题会是应用启动太慢</li>
<li>运行broadcast receiver的线程，问题会是onReceive执行太慢</li>
<li>广播的后台线程，问题会是执行goAsync的代码太耗时了</li>
</ul>


<p>遵循这些最佳实践来避免广播接收器ANRs：</p>

<ul>
<li>保证快速应用启动，因为应用启动时间也会被计算在ANR的超时时间里，如果应用是被唤醒来处理广播。</li>
<li>如果使用了goAsync，要确保PengingResult.finish早点被调用。这跟同步receivers一样都受超时时间影响。</li>
<li>如果使用了goAsync，要确保工作线程没有开启耗时操作或者阻塞性的操作。</li>
<li>考虑在非主线程里面调用<a href="https://developer.android.google.cn/reference/android/content/Context#registerReceiver(android.content.BroadcastReceiver,%20android.content.IntentFilter">registerReceiver</a>)以免阻塞主线程中的代码执行。（这里的意思是要为广播提供一个非主线程的Handler，这是广播处理回调onReceiver运行的线程。如不提供Handler将会在主线程中运行 &mdash;译注）</li>
</ul>


<blockquote><p><strong>译注：</strong>广播接收器是一个独立的组件，用于任何时候接收广播事件并进行处理，包括应用还未运行时。因此，如果应用还未有运行，那么要响应广播，必须先把应用唤起(创建进程，并创建Application实例)，然后才能创建receiver实例来处理广播。所以应用冷启动时间是会被计算在超时时限内的，从而慢的冷启动肯定会影响广播处理。通常开发者都会只关注应用启动后的情况，比如渲染性能或者用户体验，会忽略其他组件如BroadcastReceiver，Service以及ContentProvider是与Activity一样的平台级别的组件，它们都能单独的运行，但它们毕竟都是在同一个应用里面，要运行在同一进程和同一个Application实例下面，所以在运行这些组件前AMS是需要先唤起应用，应用的启动会影响着所有的四大组件。另外要注意，尽管可以用&#8221;android:process&#8221;给组件(通常是给Service和ContentProvider)指定单独的进程，但冷启动的影响也是存在的，同样需要创建进程和Application实例，并且其实主进程也是被会唤起的。</p></blockquote>

<h3>超时时限(Broadcast receiver timeout)</h3>

<p>广播接收超时时限取决于前台Intent标志是否启用以及系统平台的版本：</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> Intent类型 </th>
<th style="text-align:left;"> Android 13以及更低版本 </th>
<th style="text-align:left;"> Android 14及更高的版本 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 优先级是前台的Intent(启用了FLAG_RECEIVER_FOREGROUND) </td>
<td style="text-align:left;"> 10秒 </td>
<td style="text-align:left;"> 10~20秒，取决于进程是否是CPU挨饿 </td>
</tr>
<tr>
<td style="text-align:left;"> 优先级是后台Intent(未启用FLAG_RECEIVER_FOREGROUND) </td>
<td style="text-align:left;"> 60秒 </td>
<td style="text-align:left;"> 60~120秒，取决于进程是否是CPU挨饿 </td>
</tr>
</tbody>
</table>


<p>想要知道是否启用了FLAG_RECEIVER_FOREGROUND，可以通过在ANR标题中寻找&#8221;flg=&ldquo;然后查看是否存在<strong>0x10000000</strong>。如果这他二进制位是1就说明前台标志被启用了。</p>

<p>受制于短时广播超时时间(10~20秒)的标题例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Broadcast of Intent <span class="o">{</span> <span class="nv">act</span><span class="o">=</span>android.inent.action.SCREEN_ON <span class="nv">flg</span><span class="o">=</span>0x50200010 <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>受制于长广播超时(60~120秒)的标题例子:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Broadcast of Intent <span class="o">{</span> <span class="nv">act</span><span class="o">=</span>android.intent.action.TIME_SET <span class="nv">flg</span><span class="o">=</span>0x25200010 <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>广播的超时时间是如何计算的</h3>

<p>广播耗时时长测量从system_server把广播派发给应用时开始，到当应用完成广播的处理时结束。如果应用程序的进程没在运行，还需要把应用冷启动时间计算在ANR的超时时间里面。因此，缓慢的应用启动也可能会导致广播接收超时ANR。</p>

<p>下面这张图展示了广播接收器的时间线与应用进程的对齐关系：</p>

<p><img src="https://developer.android.com/static/topic/performance/images/broadcast-receiver-anr-timeline.png" alt="" />
图3. 广播接收器时间线</p>

<p>ANR超时时间测量当接收器处理完广播时就结束，具体这个什么时候算结束取决于是同步接收器还是异步接收器：</p>

<ul>
<li>对于同步接收器，当onReceive方法返回时测量就结束了。</li>
<li>对于异步接收器，当PendingResult.finish被调用时就结束。</li>
</ul>


<p><img src="https://developer.android.com/static/topic/performance/images/sync-async-measurement-end.png" alt="" />
图4. 同步接收器和异步接收器的ANR超时测量结束时间点</p>

<h3>常见的根因</h3>

<p>这里列出广播接收超时ANR的一些常见根因以及修复建议。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 根因 </th>
<th style="text-align:left;"> 适用于 </th>
<th style="text-align:left;"> 表象 </th>
<th style="text-align:left;"> 建议的修复方式 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 缓慢的应用启动 </td>
<td style="text-align:left;"> 所有接收器 </td>
<td style="text-align:left;"> 应用在冷启动耗时太多 </td>
<td style="text-align:left;"> 优化应用的冷启动 </td>
</tr>
<tr>
<td style="text-align:left;"> onReceive未被调度 </td>
<td style="text-align:left;"> 所有接收器 </td>
<td style="text-align:left;"> 广播接收器线程正忙于其他操作无法执行onReceive </td>
<td style="text-align:left;"> 不要在接收器的线程里面做长时间的耗时操作(放到其他工作线程里去) </td>
</tr>
<tr>
<td style="text-align:left;"> 缓慢的onReceive </td>
<td style="text-align:left;"> 所有的接收器，主要是同步接收器 </td>
<td style="text-align:left;"> 开始执行onReceive了，但因为被阻塞了或者执行的太慢，无法及时的完成并返回 </td>
<td style="text-align:left;"> 优化缓慢的onReceive代码 </td>
</tr>
<tr>
<td style="text-align:left;"> 异步接收器未被调度 </td>
<td style="text-align:left;"> goAsync()接收器 </td>
<td style="text-align:left;"> onReceive要在一个被阻塞的工作线程池中执行，所以始终得不到执行 </td>
<td style="text-align:left;"> 优化阻塞的代码或者binder call，或者用不同的线程来当作广播的工作线程 </td>
</tr>
<tr>
<td style="text-align:left;"> 工作线程太慢或者被阻塞 </td>
<td style="text-align:left;"> goAsync()接收器 </td>
<td style="text-align:left;"> 当处理广播时，在工作线程池中有耗时操作或者阻塞代码。因此，PendingResult.finish()无法及时被调用 </td>
<td style="text-align:left;"> 优化缓慢的异步接收器代码 </td>
</tr>
<tr>
<td style="text-align:left;"> 忘记调用PendingResult.finish() </td>
<td style="text-align:left;"> goAsync()接收器 </td>
<td style="text-align:left;"> 代码的逻辑中没有调用finish() </td>
<td style="text-align:left;"> 保证finish()被调用到 </td>
</tr>
</tbody>
</table>


<p><br /></p>

<h3>如何调试</h3>

<p>基于簇集标签(cluster signature)和ANR报告，可以定位到广播接收器运行的线程，然后再定位到未执行的代码或者运行缓慢的代码。</p>

<blockquote><p><strong>注意：</strong>不要忽略&#8221;nativePollOnce&#8221;或者&#8221;main thread idle&#8221;的簇集标签。Google Play Console和Firebase Crashlytics的ANR标签里面的栈帧通常都是从主线程中获取生成的。但是，广播接收器可能运行在非主线程或者调用了goAsync()（也即转成了异步接收器&mdash;译注）。因此，这些簇集标签仍然有实际价值，可以查看一下栈帧里面的相关线程。</p></blockquote>

<p>下面的流程图展示了如何确定一个广播接收超时ANR的根因：</p>

<p><img src="https://developer.android.com/static/topic/performance/images/debug-broadcast-receiver-timeout-anr.png" alt="" />
图5. 如何调试一个广播超时ANR</p>

<h3>找到接收器的代码</h3>

<p>Google Play Console会在ANR簇集标签里面显示接收器的类名和广播Intent。寻找以下信息：</p>

<ul>
<li>cmp=&lt;receiver class&gt;</li>
<li>act=&lt;broadcast_intent&gt;</li>
</ul>


<p>这里是一个广播超时ANR标签的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>com.example.app.MyClass.myMethod
</span><span class='line'>Broadcast of Intent <span class="o">{</span> <span class="nv">act</span><span class="o">=</span>android.accounts.LOGIN_ACCOUNTS_CHANGED
</span><span class='line'><span class="nv">cmp</span><span class="o">=</span>com.example.app/com.example.app.MyAccountReceiver <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>寻找运行onReceive方法的线程</h3>

<p>如果使用Context.registerReceiver()时指定了自定义的handler，那就会运行在此handler所依附的线程里。此外，就是在主线程里。</p>

<h3>实例：异步接收器未被调度</h3>

<p>这部分将逐步的演示如何调试一个广播接收超时ANR。</p>

<p>比如说ANR标签是像酱紫的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>com.example.app.MyClass.myMethod
</span><span class='line'>Broadcast of Intent <span class="o">{</span>
</span><span class='line'><span class="nv">act</span><span class="o">=</span>android.accounts.LOG_ACCOUNTS_CHANGED <span class="nv">cmp</span><span class="o">=</span>com.example.app/com.example.app.MyReceiver <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从标签中可以看出，广播intent是android.accounts.LOG_ACCOUNTS_CHANGED，接收器类型是com.example.app.MyReceiver。</p>

<p>从接收器的代码，可以发现线程池&#8221;BG Thread [0,1,2,3]&ldquo;在主要负责处理这个广播。查看栈帧，可以发现所有四个后台线程(background threads)的模式是一样的：它们都执行了一个阻塞式的调用getDataSync。因为所有的后台线程都被占用着，这个广播无法被及时处理，最后发生了ANR。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>BG Thread <span class="c">#0 (tid=26) Waiting</span>
</span><span class='line'>
</span><span class='line'>at jdk.internal.misc.Unsafe.park<span class="o">(</span>Native method:0<span class="o">)</span>
</span><span class='line'>at java.util.concurrent.locks.LockSupport.park<span class="o">(</span>LockSupport.java:211<span class="o">)</span>
</span><span class='line'>at com.google.common.util.concurrent.AbstractFuture.get<span class="o">(</span>AbstractFuture:563<span class="o">)</span>
</span><span class='line'>at com.google.common.util.concurrent.ForwardingFuture.get<span class="o">(</span>ForwardingFuture:68<span class="o">)</span>
</span><span class='line'>at com.example.app.getDataSync<span class="o">(</span>&lt;MyClass&gt;:152<span class="o">)</span>
</span><span class='line'>
</span><span class='line'>...
</span><span class='line'>
</span><span class='line'>at java.util.concurrent.ThreadPoolExecutor.runWorker<span class="o">(</span>ThreadPoolExecutor.java:1145<span class="o">)</span>at java.util.concurrent.ThreadPoolExecutor<span class="nv">$Worker</span>.run<span class="o">(</span>ThreadPoolExecutor.java:644<span class="o">)</span>
</span><span class='line'>at com.google.android.libraries.concurrent.AndroidExecutorsModule.lambda<span class="nv">$withStrictMode$5</span><span class="o">(</span>AndroidExecutorsModule:451<span class="o">)</span>
</span><span class='line'>at com.google.android.libraries.concurrent.AndroidExecutorsModule<span class="nv">$$</span>ExternalSyntheticLambda8.run<span class="o">(</span>AndroidExecutorsModule:1<span class="o">)</span>
</span><span class='line'>at java.lang.Thread.run<span class="o">(</span>Thread.java:1012<span class="o">)</span>
</span><span class='line'>at com.google.android.libraries.concurrent.ManagedPriorityThread.run<span class="o">(</span>ManagedPriorityThread:34<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>有几种方法可以修复这个问题：</p>

<ul>
<li>查出为何getDataSync会如此之慢，然后优化</li>
<li>不要在四后台线程中都执行getDataSync</li>
<li>更为通用的做法是，保证后台线程池中不要执行长时间的耗时操作</li>
<li>为goAsync任务设计一个专用线程池</li>
<li>使用一个无数量限制的线程池，而不是限量为4的后台线程池</li>
</ul>


<h3>实例：应用启动缓慢</h3>

<p>应用启动缓慢可能会导致几个不同类型的ANR，以广播接收超时ANR和执行服务超时ANR最为显著。如果你在主线程的帧中看到了ActivityThread.handleBindApplication，那么这个ANR的根因很有可能就是启动慢造成的。</p>

<blockquote><p><strong>译注：</strong>四大组件(Activity, Service, BroadcastReceiver和ContentProvidier)都是平台能直接识别的组件，均可由AMS直接启动运行，但它们都是应用的一部分，如果应用尚未运行，那么AMS必须先要创建进程，并创建Application实例，这都需要花费时间，会耗费更久，甚至引发ANR，如果冷启动过程中有耗时操作。所以优化应用启动是性能优化的基石。</p></blockquote>

<h2>执行服务超时(Exceute service timeout)</h2>

<p>当应用程序的主线程无法及时的启动一个Service时就会发生执行服务超时ANR。具体来说，就是一个服务无法在一定时限范围内完成onCreate()或者onStartCommand()或者onBind()的执行。</p>

<p><strong>默认超时时间：</strong>前台服务(Foreground Service)是20秒; 后台服务(Background Service)是200秒。ANR超时时间包括应用冷启动，以及onCreate()，onBind()和onStartCommand的调用。</p>

<p>遵循如下最佳实战来规避执行服务ANR：</p>

<ul>
<li>确保应用启动很快，因为如果一个应用被唤起来运行服务组件，启动时间也会被计算在超时时间内。</li>
<li>确保服务的onCreate()，onBind()和onStartCommand()执行的都很快。</li>
<li>不要在主线程里执行来自其他组件的耗时操作或者阻塞式操作，这些操作会阻碍服务的快速启动。</li>
</ul>


<h3>常见的根因</h3>

<p>下表列出执行服务超时ANR的常见根因和修复建议：。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 根因 </th>
<th style="text-align:left;"> 表象 </th>
<th style="text-align:left;"> 建议的修复 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 缓慢的应用启动 </td>
<td style="text-align:left;"> 应用冷启动时间过长 </td>
<td style="text-align:left;"> 优化应用启动速度 </td>
</tr>
<tr>
<td style="text-align:left;"> 缓慢的onCreate()，onStartCommand和onBind </td>
<td style="text-align:left;"> 服务组件的onCreate()，onStartCommand()和onBind()在主线程执行了耗时操作 </td>
<td style="text-align:left;"> 优化代码，或者把耗时操作从这些关键的方法中移出去 </td>
</tr>
<tr>
<td style="text-align:left;"> 未被调度(在执行onStart()之前主线程就被阻塞了) </td>
<td style="text-align:left;"> 在服务启动之前，主线程就被其他组件级阻塞了 </td>
<td style="text-align:left;"> 把其他组件的工作移出主线程。优化其他组件的阻塞代码 </td>
</tr>
</tbody>
</table>


<p><br /></p>

<h3>如何调试</h3>

<p>从Google Play Console和Firebase Crashlytics中的簇集标签和ANR报告，基于主线程当时的运行状态，通常就能确定ANR的根因。</p>

<p><strong>注意：</strong>忽略标签是&#8221;nativePollOnce&#8221;和&#8221;main thread idle&#8221;的执行服务ANR簇集。这些簇集通常是栈帧捕获的太晚，无实际参考意义。真实的ANR栈帧可能会在其他的簇集里，所以问题并不会被掩藏。详细参见nativePollOnce部分。</p>

<p>下面的流程图描述了如何调试一个执行服务超时ANR。</p>

<p><img src="https://developer.android.com/static/topic/performance/images/debug-execute-service-anr.png" alt="" />
图6. 如何调试一个执行服务ANR</p>

<p>如果发现某个执行报务ANR是有实际操作意义的，遵循以下步骤来解决问题：</p>

<ol>
<li>找到ANR簇集标签中的服务组件。在Google Play Console里，服务组件类型会显示在ANR标签里。在后面的这个例子里，类型就是com.example.app/MyService。</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>com.google.common.util.concurrent.Uninterruptibles.awaitUninterruptibly
</span><span class='line'>Executing service com.example.app/com.example.app.MyService
</span></code></pre></td></tr></table></div></figure>


<ol>
<li>确定应用启动过程中，服务组件或者其他地方是否有耗时或者阻塞操作，通过检查主线程中的下面这些重要的方法调用</li>
</ol>


<table>
<thead>
<tr>
<th style="text-align:left;"> 主线程栈帧中的方法调用 </th>
<th style="text-align:left;"> 背后的含义 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> android.app.ActivityThread.handleBindApplication </td>
<td style="text-align:left;"> 应用正在启动，ANR由启动太慢引起 </td>
</tr>
<tr>
<td style="text-align:left;"> <ServiceClass>.onCreate()<br/>[&hellip;.]<br/>android.app.ActivityThread.handleCreateService </td>
<td style="text-align:left;"> 服务正在被创建中，所以ANR是由缓慢的onCreate()引起的 </td>
</tr>
<tr>
<td style="text-align:left;"> <ServiceClass>.onBind()<br/>[&hellip;.]<br/>android.app.ActivityThread.handleBindService </td>
<td style="text-align:left;"> 服务正在被绑定中，所以ANR是由缓慢的onBind()引起的 </td>
</tr>
<tr>
<td style="text-align:left;"> <ServiceClass>.onStartCommand()<br/>[&hellip;.]<br/>android.app.ActivityThread.handleServiceArgs </td>
<td style="text-align:left;"> 服务正在被启动中，所以ANR是由缓慢的onStartCommand()引起的 </td>
</tr>
</tbody>
</table>


<p><br />
举个粟子，如果在类MyService里的onStartCommand执行缓慢，主线程栈帧会像酱婶儿的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>at com.example.app.MyService.onStartCommand<span class="o">(</span>FooService.java:25<span class="o">)</span>
</span><span class='line'>at android.app.ActivityThread.handleServiceArgs<span class="o">(</span>ActivityThread.java:4820<span class="o">)</span>
</span><span class='line'>at android.app.ActivityThread.-<span class="nv">$$</span>Nest<span class="nv">$mhandleServiceArgs</span><span class="o">(</span>unavailable:0<span class="o">)</span>
</span><span class='line'>at android.app.ActivityThread<span class="nv">$H</span>.handleMessage<span class="o">(</span>ActivityThread.java:2289<span class="o">)</span>
</span><span class='line'>at android.os.Handler.dispatchMessage<span class="o">(</span>Handler.java:106<span class="o">)</span>
</span><span class='line'>at android.os.Looper.loopOnce<span class="o">(</span>Looper.java:205<span class="o">)</span>
</span><span class='line'>at android.os.Looper.loop<span class="o">(</span>Looper.java:294<span class="o">)</span>
</span><span class='line'>at android.app.ActivityThread.main<span class="o">(</span>ActivityThread.java:8176<span class="o">)</span>
</span><span class='line'>at java.lang.reflect.Method.invoke<span class="o">(</span>Native method:0<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果没有发现重要的方法调用，还有其他一些可能：</p>

<ul>
<li> 服务正在运行或者在关闭中，意思是说栈帧捕获的太晚了，可以忽略此类ANR或者视为假阳性。</li>
<li><p> 另外一个组件正在运行，比如广播接收器。这种情况下主线程可能被这个组件阻塞着，导致服务无法启动。</p></li>
<li><p>如果能看到关键的方法 调用并确定ANR发生的地点，检查主线程的栈帧以找到缓慢的操作并把它们从关键的方法中移出去。</p></li>
</ul>


<p>关于服务的更多信息，可以看下面这些链接：</p>

<ul>
<li><a href="https://developer.android.com/guide/components/services">服务概览</a></li>
<li><a href="https://developer.android.com/guide/components/foreground-services">前台服务</a></li>
<li><a href="https://developer.android.com/reference/android/app/Service">服务</a></li>
</ul>


<h2>内容提供程序无响应(Content Provider not responding)</h2>

<p>当一个远端内内容提供程序响应查询(query)时花费超过时限，内容提供程序ANR就会发生，且会被杀掉。</p>

<p><strong>默认超时时间：</strong>内容提供程序通过ContentProviderClient.setDetectNotResponding指定的。ANR超时时限包括远端内容提供程序执行查询的时间，以及如果远端应用还未启还包括它的冷启动时间，加在一起的总时间。</p>

<p>遵循下面这些最佳实践来规避内容提供程序ANR：</p>

<ul>
<li>确保应用启动很快，因为如果应用未运行时会被唤起，冷启动时间也会被计算在超时时间内。</li>
<li>确保内容提供程序的查询能很快执行完。</li>
<li>不要执行大量的并发阻塞式的binder call，因为这会阻塞应用的所有的binder线程。</li>
</ul>


<blockquote><p><strong>译注：</strong><a href="https://developer.android.com/reference/android/content/ContentProvider">内容提供程序Content provider</a>都是要经过跨进程调用(binder call)，尽管可能并没有真正的在另外一个进程里。因为我们使用<a href="https://developer.android.com/guide/topics/providers/content-provider-basics">ContentProvider</a>的时候都是通过另一个API ContentResolver来完成，而ContentResolver是通过binder call来与ContentProvider通信的，无论是否真的跨进程。所以，ContentProvider就像一个服务器一样是远端的一侧提供内容，而应用程序(使用者)是客户端一侧需要内容。内容提供程序可能同时服务着不同的客户请求，比如像系统通用的内容提供程序ContactsProvider或者MediaProvider可能同时会有大量的应用请求查询，每一个请求都需要执行binder call，因此内容提供程序可能会同时执行着大量的binder call(它需要查询结果，并把结果以binder call的形式返回给请求方)。所以对于内容提供程序来说，查看binder call的运行状态对于解决ANR问题以及排查性能问题都是非常有帮助的。</p></blockquote>

<h3>常见根因</h3>

<p>下表列出了内容提供程序ANR的常见根因和修复建议。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 根因 </th>
<th style="text-align:left;"> 表象 </th>
<th style="text-align:left;"> 信号 </th>
<th style="text-align:left;"> 建议的修复方式 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 缓慢的查询 </td>
<td style="text-align:left;"> 内容提供程序执行耗时太长或者被阻塞 </td>
<td style="text-align:left;"> binder线程里有android.content.ContentProvider\$Transport.query栈帧 </td>
<td style="text-align:left;"> 优化查询或者查出什么东西在阻塞着binder线程 </td>
</tr>
<tr>
<td style="text-align:left;"> 应用启动太慢 </td>
<td style="text-align:left;"> 内容提供程序启动耗时太久 </td>
<td style="text-align:left;"> 主线程里有ActivityThread.handleBindApplication栈帧 </td>
<td style="text-align:left;"> 优化应用启动 </td>
</tr>
<tr>
<td style="text-align:left;"> Binder线程耗尽了，所有的binder线程都被占用着 </td>
<td style="text-align:left;"> 所有的binder线程都被占用着服务着其他的同步请求，因此内容提供程序binder调用无法执行 </td>
<td style="text-align:left;"> 应用未启动起来，所有的binder线程都被占用，内容提供程序也未能启动起来 </td>
<td style="text-align:left;"> 减小binder线程的负载。也就是说执行更少一些的外发同步binder调用或者在处理到来的调用时少做一些操作。</td>
</tr>
</tbody>
</table>


<p><br /></p>

<h3>如何调试</h3>

<p>要想调试一个内容提供程序ANR，使用Google Play Console或者Firebase Crashlytics中的簇集标签和ANR报告，并用来查看主线程以及binder线程都在做什么。</p>

<p>下面的流程图描述如何调试一个内容提供程序ANR：</p>

<p><img src="https://developer.android.com/static/topic/performance/images/debug-content-provider-anr.png" alt="" />
图7.如何调试一个内容提供程序ANR</p>

<p>下面的代码块展示了当被一个缓慢的内容提供程序查询阻塞时，binder线程的状态。在这个例子里，内容提供程序的查询正在等待一个打开数据库的锁。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>binder:11300_2 <span class="o">(</span><span class="nv">tid</span><span class="o">=</span>13<span class="o">)</span> Blocked
</span><span class='line'>
</span><span class='line'>Waiting <span class="k">for</span> osm <span class="o">(</span>0x01ab5df9<span class="o">)</span> held by at com.google.common.base.Suppliers<span class="nv">$NonSerializableMemoizingSupplier</span>.get<span class="o">(</span>Suppliers:182<span class="o">)</span>
</span><span class='line'>at com.example.app.MyClass.blockingGetOpenDatabase<span class="o">(</span>FooClass:171<span class="o">)</span>
</span><span class='line'><span class="o">[</span>...<span class="o">]</span>
</span><span class='line'>at com.example.app.MyContentProvider.query<span class="o">(</span>MyContentProvider.java:915<span class="o">)</span>
</span><span class='line'>at android.content.ContentProvider<span class="nv">$Transport</span>.query<span class="o">(</span>ContentProvider.java:292<span class="o">)</span>
</span><span class='line'>at android.content.ContentProviderNative.onTransact<span class="o">(</span>ContentProviderNative.java:107<span class="o">)</span>
</span><span class='line'>at android.os.Binder.execTransactInternal<span class="o">(</span>Binder.java:1339<span class="o">)</span>
</span><span class='line'>at android.os.Binder.execTransact<span class="o">(</span>Binder.java:1275<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面的代码块展示了当被缓慢的应用启动阻塞时，binder线程的状态。在这个例子里，应用启动因为dagger初始化时的锁竞争而变得很慢。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>main <span class="o">(</span><span class="nv">tid</span><span class="o">=</span>1<span class="o">)</span> Blocked
</span><span class='line'>
</span><span class='line'><span class="o">[</span>...<span class="o">]</span>
</span><span class='line'>at dagger.internal.DoubleCheck.get<span class="o">(</span>DoubleCheck:51<span class="o">)</span>
</span><span class='line'>- locked 0x0e33cd2c <span class="o">(</span>a qsn<span class="o">)</span>at dagger.internal.SetFactory.get<span class="o">(</span>SetFactory:126<span class="o">)</span>
</span><span class='line'>at com.myapp.Bar_Factory.get<span class="o">(</span>Bar_Factory:38<span class="o">)</span>
</span><span class='line'><span class="o">[</span>...<span class="o">]</span>
</span><span class='line'>at com.example.app.MyApplication.onCreate<span class="o">(</span>DocsApplication:203<span class="o">)</span>
</span><span class='line'>at android.app.Instrumentation.callApplicationOnCreate<span class="o">(</span>Instrumentation.java:1316<span class="o">)</span>
</span><span class='line'>at android.app.ActivityThread.handleBindApplication<span class="o">(</span>ActivityThread.java:6991<span class="o">)</span>
</span><span class='line'>at android.app.ActivityThread.-<span class="nv">$$</span>Nest<span class="nv">$mhandleBindApplication</span><span class="o">(</span>unavailable:0<span class="o">)</span>
</span><span class='line'>at android.app.ActivityThread<span class="nv">$H</span>.handleMessage<span class="o">(</span>ActivityThread.java:2235<span class="o">)</span>
</span><span class='line'>at android.os.Handler.dispatchMessage<span class="o">(</span>Handler.java:106<span class="o">)</span>
</span><span class='line'>at android.os.Looper.loopOnce<span class="o">(</span>Looper.java:205<span class="o">)</span>
</span><span class='line'>at android.os.Looper.loop<span class="o">(</span>Looper.java:294<span class="o">)</span>
</span><span class='line'>at android.app.ActivityThread.main<span class="o">(</span>ActivityThread.java:8170<span class="o">)</span>
</span><span class='line'>at java.lang.reflect.Method.invoke<span class="o">(</span>Native method:0<span class="o">)</span>
</span><span class='line'>at com.android.internal.os.RuntimeInit<span class="nv">$MethodAndArgsCaller</span>.run<span class="o">(</span>RuntimeInit.java:552<span class="o">)</span>
</span><span class='line'>at com.android.internal.os.ZygoteInit.main<span class="o">(</span>ZygoteInit.java:971<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>缓慢的作业响应(Slow job response)</h2>

<p>当应用响应JobService.onStartJob()或者JobService.onStopJob耗时太久，或者用JobService.setNotification()提供通知时耗时太久，都会引发缓慢的作业响应ANR发生。这说明应用的主线程因为其他操作而被阻塞了。</p>

<p>如果问题是与JobService.onStartJob()或者JobService.onStopJob()有关系，就要检查下主线程的情况。如果问题与JobService.setNotification()有关系，要保证它尽可能的快速的被调用到。在提供通知之前 不要做很多其他事情。</p>

<blockquote><p><strong>译注：</strong><a href="https://developer.android.com/reference/android/app/job/JobService">JobService</a>是Android 5.0 API 21时增加的一个专门用于后台作业的一个Service的子类。上面提到的是都是它的一些回调，与一些其他的回调类似，这些回调必须快速执行完毕，因为<a href="https://developer.android.com/reference/android/app/job/JobScheduler">JobSchedule</a>内部需要做一些资源回收之类的工作，所以这些回调不允许被阻塞。</p></blockquote>

<h2>隐秘的ANRs</h2>

<p>有时候搞不清楚为啥ANR会发生，或者在簇集标签和ANR报告中找不到足够的信息去调试。遇到这些情况，还是可以采取一些步骤以确定这些ANR是否是值得处理的。</p>

<h3>消息队列是空闲(Message queue idle)的或者正处理轮询中(nativePollOnce)</h3>

<p>如果你在栈帧信息中发现android.os.MessageQueue.nativePollOnce，这通常说明疑似无响应的线程实际上是空闲的或者在等待队列中的消息。在Google Play Console里面，ANR的细节是酱紫的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>Native method - android.os.MessageQueue.nativePollOnce
</span><span class='line'>Executing service com.example.app/com.example.app.MyService
</span></code></pre></td></tr></table></div></figure>


<p>举个粟子，如果主线程是空闲的，栈帧是酱紫的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="s2">&quot;main&quot;</span> <span class="nv">tid</span><span class="o">=</span><span class="m">1</span> NativeMain threadIdle
</span><span class='line'>
</span><span class='line'><span class="c">#00  pc 0x00000000000d8b38  /apex/com.android.runtime/lib64/bionic/libc.so (__epoll_pwait+8)</span>
</span><span class='line'><span class="c">#01  pc 0x0000000000019d88  /system/lib64/libutils.so (android::Looper::pollInner(int)+184)</span>
</span><span class='line'><span class="c">#02  pc 0x0000000000019c68  /system/lib64/libutils.so (android::Looper::pollOnce(int, int*, int*, void**)+112)</span>
</span><span class='line'><span class="c">#03  pc 0x000000000011409c  /system/lib64/libandroid_runtime.so (android::android_os_MessageQueue_nativePollOnce(_JNIEnv*, _jobject*, long, int)+44)</span>
</span><span class='line'>at android.os.MessageQueue.nativePollOnce <span class="o">(</span>Native method<span class="o">)</span>
</span><span class='line'>at android.os.MessageQueue.next <span class="o">(</span>MessageQueue.java:339<span class="o">)</span>  at android.os.Looper.loop <span class="o">(</span>Looper.java:208<span class="o">)</span>
</span><span class='line'>at android.app.ActivityThread.main <span class="o">(</span>ActivityThread.java:8192<span class="o">)</span>
</span><span class='line'>at java.lang.reflect.Method.invoke <span class="o">(</span>Native method<span class="o">)</span>
</span><span class='line'>at com.android.internal.os.RuntimeInit<span class="nv">$MethodAndArgsCaller</span>.run <span class="o">(</span>RuntimeInit.java:626<span class="o">)</span>
</span><span class='line'>at com.android.internal.os.ZygoteInit.main <span class="o">(</span>ZygoteInit.java:1015<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>疑似无响应线程可能是空闲的会有几个原因：</p>

<ul>
<li>延迟的栈转储：在ANR被 触发和栈帧转储之间的短时间内，线程状态恢复了。在Android 13版本的Pixels设备上这个延迟大约在100ms，但也可能超过1秒。Android 14版本的Pixels设备上这个延迟小于10ms。</li>
<li>线程归因错误：用于构建ANR标签的线程并不是实际上触发ANR的无响应线程。这种情况下，尝试确定一下这个ANR是否是如下的类型：

<ul>
<li>广播接收超时</li>
<li>内容提供程序无响应</li>
<li>找不到带焦点的窗口</li>
<li>系统侧问题：由于系统负载太重或者系统服务有问题而导致应用进程无法被调度。</li>
</ul>
</li>
</ul>


<h3>没有栈帧(No stack frames)</h3>

<p>有一些ANR报告里面没有包含与ANR相关的栈帧，这说明在生成ANR报告时栈帧转储失败了。有很多可能的原因会导致栈帧丢失：</p>

<ul>
<li>转储栈帧太耗时了，所以超时了</li>
<li>在栈帧转储完成之前进程就挂了或者被杀掉了</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="o">[</span>...<span class="o">]</span>
</span><span class='line'>
</span><span class='line'>--- CriticalEventLog ---
</span><span class='line'>capacity: 20
</span><span class='line'>timestamp_ms: 1666030897753
</span><span class='line'>window_ms: 300000
</span><span class='line'>
</span><span class='line'>libdebuggerd_client: failed to <span class="nb">read </span>status response from tombstoned: timeout reached?
</span><span class='line'>
</span><span class='line'>----- Waiting Channels: pid <span class="m">7068</span> at 2022-10-18 02:21:37.&lt;US_SOCIAL_SECURITY_NUMBER&gt;+0800 -----
</span><span class='line'>
</span><span class='line'><span class="o">[</span>...<span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>簇集标签或者ANR报告里面没有栈帧的ANR是没有实际分析意义的。如果要调试，可以去看其他的簇集信息，因为如果一个问题足够明显的话，那么它通常会有它自己的簇集标签存在。其他的可行方案就是查看<a href="https://perfetto.dev/docs/">Perfetto traces</a>.</p>

<h2>已知问题(Known issues)</h2>

<p>在应用的进程里用计时器来测量广播的处理时间或者ANR的触发是行不通的，因为系统是以异步的方式在监控着ANR。</p>

<blockquote><p><strong>译注：</strong>这里的意思是不要想着取巧，应用开发者的重点应该放在你的业务逻辑和性能优化上面，借助平台提供的工具和方法来优化应用的代码逻辑。而像尝试在应用侧自己统计超时这种事情是行不通的，因为系统以比较复杂的异步的方式在统计着超时，应用侧不可能做到与系统侧一样的测量方法，所以自己的统计就变得毫无意义（要么不可行，要么不准确）。还是老老实实的优化好自己的代码吧。</p></blockquote>

<h2>更多的官方资料</h2>

<ul>
<li><a href="https://developer.android.com/topic/performance/anrs/find-unresponsive-thread">Find the unresponsive thread</a></li>
<li><a href="https://developer.android.com/topic/performance/anrs/keep-your-app-responsive">Keep your app responsive</a></li>
<li><a href="https://developer.android.com/guide/topics/resources/layout-resource">Layout resource</a></li>
<li><a href="https://developer.android.com/topic/performance/vitals/anr">ANRs</a></li>
</ul>


<h2>其他优质博文</h2>

<ul>
<li><a href="https://juejin.cn/post/7181731795439157306">钉钉 ANR 治理最佳实践 | 定位 ANR 不再雾里看花</a></li>
<li><a href="https://juejin.cn/post/6940061649348853796">今日头条 ANR 优化实践系列 - 设计原理及影响因素</a></li>
<li><a href="https://juejin.cn/post/7053819042268151838">Android ANR全解析&amp;华为AGC性能管理解决ANR案例集</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实战技巧：为Android应用设置独立的多语言]]></title>
    <link href="http://toughcoder.net/blog/2023/11/27/android-set-per-app-langauges/"/>
    <updated>2023-11-27T22:40:38+08:00</updated>
    <id>http://toughcoder.net/blog/2023/11/27/android-set-per-app-langauges</id>
    <content type="html"><![CDATA[<p>通常情况下多语言的设置都在系统设置中，应用需要做的就是提供本应用所使用的字串的多语言翻译，使用时使用R.string.app_name类似的引用，然后系统会根据用户在系统设置中的选项来选择合适的具体的语言。并且这是一个<strong>全局选项</strong>，也就是说选择一个多语言后整个手机都变了。但有些时候，应用想要自己能够设置一个独自的多语言，也就是说想要给自己的应用设置一个不同于全局的多语言。今天就来研究一下这个话题。</p>

<p><a href="http://toughcoder.net/blog/2023/11/27/android-set-per-app-langauges/"><img src="https://i2.wp.com/techvidvan.com/tutorials/wp-content/uploads/sites/2/2021/08/Android-Localization-1.jpg?fit=1200%2C628&ssl=1"></a></p>

<!--  more -->


<p>这样做的目的是为了提供更好的用户体验，因为一些仅支持某些特定语言的应用，可能会与系统全局选项冲突，或者只在某些固定地区发行的应用，单独的个性化的局部设置会更好一些。这个谷歌已经通过<a href="https://developer.android.com/jetpack">Jetpack</a>中的<a href="https://developer.android.com/jetpack/androidx/releases/appcompat">appcomat</a>库给与了比较好的支持，详细的可以<a href="https://developer.android.com/guide/topics/resources/app-languages">参考这个文档</a>，以及<a href="https://github.com/android/user-interface-samples/tree/main/PerAppLanguages">官方的Sample</a>。我们在官方文档基础之上再叠加试验和理解，做进一步的总结。</p>

<p>主要分为两种方法，一是系统支持单独给应用设置多语言；二是应用中独自设置，这个也是更为通用的解法。</p>

<p><strong>注意</strong>：这里的方法都是让某一个应用内部使用的多语言改变为相应的设置（一般情况下是与系统全局设置不一样的），但是需要注意仅仅局限于应用启动后的应用内部界面使用的语言。对于像桌面上应用的入口仍是系统全局设置为准，因为这个入口并不属于应用自己管辖范围内的。</p>

<h2>系统设置中支持为应用设置单独多语言</h2>

<p>谷歌官方的表述是从Android 13（Android T, SDK 33)开始，就支持了在系统中有一个入口，可以为每个应用单独设置多语言选项。这一部分里面描述的方法也都是支持这个系统入口的情况才能生效的。需要注意，虽然谷歌官方说从Android 13开始就支持了，但这个也要取决 于厂商的定制，目前看大部分国内厂商会把这个功能和入口给屏蔽掉，那么这里后面描述的方法也就都不会生效了。</p>

<h3>入口在哪里</h3>

<p>需要通过系统设置来进行，有两个入口：</p>

<p><img src="https://developer.android.com/static/images/about/versions/13/app-languages.png" height="480" width="320" alt="" /></p>

<ul>
<li>Settings（设置）> Additional Settings (更多设置) > Languages &amp; Input (语言和输入) > (App Languages) 应用语言 > select an app（选择一个应用）</li>
<li>Settings（设置）> Apps (应用)> select an app（选择一个应用） > Language（语言）</li>
</ul>


<p>具体的方法，又分为两种，一是自动式的，二是手动式的。</p>

<h3>自动添加</h3>

<p>说是自动，其实也是利用IDE（即Android Studio）和编译打包时自动根据res下面的多语言生成一份配置而已。在build.gradle或者build.gradle.kts中的android下面添加generateLocaleConfig = true：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="n">android</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">androidResources</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">generateLocaleConfig</span> <span class="p">=</span> <span class="k">true</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在resl中增加一个名为resources.properties的文件，加入默认值配置：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="n">unqualifiedResLocale</span><span class="p">=</span><span class="n">en</span><span class="p">-</span><span class="n">US</span>
</span></code></pre></td></tr></table></div></figure>


<h3>手动添加</h3>

<p>在res/xml中增加文件locales_config.xml，加入需要支持的多语言选项，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
</span><span class='line'><span class="nt">&lt;locale-config</span> <span class="na">xmlns:android=</span><span class="s">&quot;http://schemas.android.com/apk/res/android&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>   <span class="nt">&lt;locale</span> <span class="na">android:name=</span><span class="s">&quot;en-US&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>   <span class="nt">&lt;locale</span> <span class="na">android:name=</span><span class="s">&quot;en-GB&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>   <span class="nt">&lt;locale</span> <span class="na">android:name=</span><span class="s">&quot;fr&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>   <span class="nt">&lt;locale</span> <span class="na">android:name=</span><span class="s">&quot;ja&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>   <span class="nt">&lt;locale</span> <span class="na">android:name=</span><span class="s">&quot;zh-Hans-MO&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>   <span class="nt">&lt;locale</span> <span class="na">android:name=</span><span class="s">&quot;zh-Hant-MO&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'><span class="nt">&lt;/locale-config&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在AndroidManifest.xml中的appllication加上这一个属性：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;manifest&gt;</span>
</span><span class='line'>  ...
</span><span class='line'>  <span class="nt">&lt;application</span>
</span><span class='line'>      <span class="err">...</span>
</span><span class='line'>      <span class="na">android:localeConfig=</span><span class="s">&quot;@xml/locales_config&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/application&gt;</span>
</span><span class='line'><span class="nt">&lt;/manifest&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为还没有找到支持如此设置的手机，所以上述方法未经验证。</p>

<h2>在应用内部设置多语言</h2>

<p>这个是更为通用的做法，具体的UI就是可以随便弄了，弄个List或者DrowDownMenu都可以。重点是让设置生效的时候需要用到一个API，叫做<a href="https://developer.android.com/reference/androidx/appcompat/app/AppCompatDelegate#setApplicationLocales(androidx.core.os.LocaleListCompat">setApplicationLocales()</a>)和<a href="https://developer.android.com/reference/androidx/appcompat/app/AppCompatDelegate#getApplicationLocales(">getApplicationLocales()</a>)。并且在appcompat 1.6.0以后的版本，有比较方便的API可以直接使用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">appLocale</span><span class="p">:</span> <span class="n">LocaleListCompat</span> <span class="p">=</span> <span class="n">LocaleListCompat</span><span class="p">.</span><span class="n">forLanguageTags</span><span class="p">(</span><span class="s">&quot;xx-YY&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// Call this on the main thread as it may require Activity.restart()</span>
</span><span class='line'><span class="n">AppCompatDelegate</span><span class="p">.</span><span class="n">setApplicationLocales</span><span class="p">(</span><span class="n">appLocale</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果要还原使用系统设置中的全局多语言配置，可以用LocaleListCompat.getEmptyLocaleList()当作参数。</p>

<p><strong>特别注意</strong>：此方法要想生效，宿主Activity必须是继承自appcompat中的AppCompatActivity，而不是其他 。</p>

<p>为了兼容以前的版本（Android 12，API level 32以前），还需要在AndroidManifest中添加一个额外的Service：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;application</span>
</span><span class='line'>  <span class="err">...</span>
</span><span class='line'>  <span class="err">&lt;service</span>
</span><span class='line'>    <span class="na">android:name=</span><span class="s">&quot;androidx.appcompat.app.AppLocalesMetadataHolderService&quot;</span>
</span><span class='line'>    <span class="na">android:enabled=</span><span class="s">&quot;false&quot;</span>
</span><span class='line'>    <span class="na">android:exported=</span><span class="s">&quot;false&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;meta-data</span>
</span><span class='line'>      <span class="na">android:name=</span><span class="s">&quot;autoStoreLocales&quot;</span>
</span><span class='line'>      <span class="na">android:value=</span><span class="s">&quot;true&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/service&gt;</span>
</span><span class='line'>  ...
</span><span class='line'><span class="nt">&lt;/application&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意，这个Service在appcomat库中已经定义好了，只需要在manfiest里添加一下就可以了。</p>

<p>另外需要注意的是，一般情况下，应用自己肯定 会保存一下当前用户所选择的语言。但如果系统也支持应用语言选择入口的话，那么通过系统入口也是可能会修改应用的多语文选项的，这时，就需要把系统的选项与应用内部的选项进行同步。可以通过<a href="https://developer.android.com/reference/androidx/appcompat/app/AppCompatDelegate#getApplicationLocales(">AppCompatDelegate.getApplicationLocales</a>)来获取当前生效的语言选项，它是由appcompat库来维护的，肯定是最新的，所以应用自己保存的选项如果与这个API的结果不一致，就要重置为这个API的结果。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/guide/topics/resources/app-languages">Per-app language preferences</a></li>
<li><a href="https://github.com/android/user-interface-samples/tree/main/PerAppLanguages">user-interface-samples/PerAppLanguages</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[线性排序算法总结]]></title>
    <link href="http://toughcoder.net/blog/2023/10/26/understanding-linear-sorting-algorithm/"/>
    <updated>2023-10-26T23:04:18+08:00</updated>
    <id>http://toughcoder.net/blog/2023/10/26/understanding-linear-sorting-algorithm</id>
    <content type="html"><![CDATA[<p><strong>排序</strong>是程序设计中的最为基础也是最为重要的算法，从程序设计这一行业开始，便有了对排序的研究，至今到了人工智能大行其道的时代，算法科学家们对排序的探索仍未停止。这是因为计算机是处理信息的最为高效的工具，如何高效的处理信息则是计算机科学的重中之重，而要想高效的处理信息，就必须先对信息进行排序，因为各种高效率的信息检索必须要基于已排序的数据。</p>

<p><a href="http://toughcoder.net/blog/2023/10/26/understanding-linear-sorting-algorithm/"><img src="https://i0.wp.com/www.xamnation.com/wp-content/uploads/2020/07/sorting-algorithms.png?fit=2240%2C1260&ssl=1" title="auto auto" ></a></p>

<!-- more -->


<p>总的来说排序算法分为三大类：</p>

<ol>
<li>常规排序，也称为低效排序，如冒泡排序，插入排序，选择排序等，复杂度是O(n<sup>2</sup>)，空间复杂度都为O(1)</li>
<li>高效排序，如谢尔排序，快速排序，归并排序，堆排序等，复杂度是O(nlogn)，空间复杂度一般为O(logn)</li>
<li>线性排序，或者叫做非比较排序，仅针对特定数据集（有固定范围的整数集合）有效，如计数排序，基数排序，桶排序等，复杂度是O(n)，但至少需要O(n)的空间复杂度</li>
</ol>


<p>排序算法属于编程的基础，相关的文章一大把，集大成者有Yu神的<a href="https://leetcode.cn/circle/discuss/eBo9UB/">十大排序从入门到入赘</a>。今天重点整理一下线性排序算法。</p>

<h2><a href="https://en.wikipedia.org/wiki/Counting_sort">计数排序</a></h2>

<p><img src="https://www.cdn.geeksforgeeks.org/wp-content/uploads/scene02521.jpg" alt="" /></p>

<p>计数排序的核心思想是<strong>统计输入数组每个元素的频次</strong>，然后按照频次表的顺序把原始数据都输出出来。它的输入必须是一组有固定范围的整数，而且范围不应该太大，否则空间浪费严重。具体步骤如下：</p>

<ol>
<li>找出输入数据的范围，即其最大值max，创建一个长度为max + 1的整数数组，这是频次数组freq</li>
<li>遍历输入数组，对其元素进行频次统计，也就是把元素当作频次数组的下标，来统计freq[arr[i]]++</li>
<li>遍历频次数组，按频次输出元素，得到的就是一个有序数组</li>
</ol>


<p>伪码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='python3'><span class='line'><span class="k">def</span> <span class="nf">countSort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
</span><span class='line'>  <span class="nb">len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'>  <span class="n">freq</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span>
</span><span class='line'>  <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
</span><span class='line'>      <span class="n">freq</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">++</span>
</span><span class='line'>  <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">):</span>
</span><span class='line'>      <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
</span><span class='line'>          <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">res</span>
</span></code></pre></td></tr></table></div></figure>


<h3>具有稳定特质的计数排序</h3>

<p>默认的方法（上面描述）的<strong>是不稳定的</strong>，所谓排序的稳定性是指对于比较起来相等的两个元素能否在结果数组中保留它们在原数组的先后顺序。一般情况下，不需要稳定时也不用管。但当在其他地方使用计数排序时，如在基数排序中使用计数排序，那么稳定性就相当重要了。</p>

<p>如果想要稳定，就需要额外做些事情：<strong>要保证先放入的数先输出（在前面），后放的后输出（在后面）</strong>，可以对频次数组求前缀和，然后遍历频次时是从后往前遍历，同时更新频次：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='python3'><span class='line'><span class="k">def</span> <span class="nf">stableCoutingSort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
</span><span class='line'>  <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span><span class='line'>  <span class="c"># find max to determine the range of input array</span>
</span><span class='line'>  <span class="nb">len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'>  <span class="n">freq</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span>
</span><span class='line'>  <span class="c"># count the frequency</span>
</span><span class='line'>  <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
</span><span class='line'>      <span class="n">freq</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">++</span>
</span><span class='line'>  <span class="c"># presum the frequency</span>
</span><span class='line'>  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">):</span>
</span><span class='line'>      <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">frq</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</span><span class='line'>  <span class="c"># output by iterating backwardly</span>
</span><span class='line'>  <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
</span><span class='line'>  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span><span class='line'>      <span class="n">out</span><span class="p">[</span><span class="n">freq</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</span><span class='line'>      <span class="n">freq</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">--</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">out</span>
</span></code></pre></td></tr></table></div></figure>


<h3>应用条件</h3>

<p>需要十分注意，计数排序可应用的条件很严格，只有数据集是范围不大的正整数时才可以使用，要不然空间浪费严重。最适合应用计数排序的场景是数组数值范围很小，但元素数量很多，也就是说<strong>元素数量远大于数值范围</strong>，比如说基数排序中，针对每一数位排序时，就是典型应用计数排序的地方，这时数值范围只有0~9，元素数量可能很多，非常适合计数排序。</p>

<p>当然，有负数时也可以使用，这时需要把数据加上最小的负数，平移到0以后就可以了，比如最小值（负数）是min，那么转化为arr[i]-min即可。</p>

<h2><a href="https://en.wikipedia.org/wiki/Radix_sort">基数排序</a></h2>

<p><img src="https://image1.slideserve.com/2528167/radix-sort-in-action4-l.jpg" alt="" /></p>

<p>基数排序是以<strong>整数数制的数位为依据</strong>来排序，比如123，一共有3个数位分别是1，2和3。把数组中的每个元素都按照它们的每一个数位进行排序，之后即是结果，可以从低位到位的顺序（右到左），也可以从高位到低位的顺序（左到右）。针对每个数位排元素时可以应用计数排序。但要是<strong>稳定版本的计数排序</strong>，比如{11, 23, 25}三个数，先按最低位排序后是{11, 23, 25}，这时再按十分位排序时，如果不稳定就可能会排出{11, 25, 23}这样的结果，因此 需要稳定版本的排序。具体过程如下：</p>

<ol>
<li>求出最大数位，或者说<strong>最宽的数</strong>，对于整数来说也就是找出最大值，然后求出其数位宽度width</li>
<li>对每个数位进行循环，循环次数就是width，每一轮就是针对 一个数位排序，可以用稳定版本的计数排序</li>
<li>结束后就得到了结果</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='python3'><span class='line'><span class="k">def</span> <span class="nf">radixSort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
</span><span class='line'>  <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span><span class='line'>  <span class="n">m</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span><span class='line'>  <span class="n">width</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>  <span class="n">base</span> <span class="o">=</span> <span class="mi">10</span>
</span><span class='line'>  <span class="k">while</span> <span class="n">m</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
</span><span class='line'>      <span class="n">width</span><span class="o">++</span>
</span><span class='line'>      <span class="n">m</span> <span class="o">/=</span> <span class="n">base</span>
</span><span class='line'>  <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
</span><span class='line'>  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">width</span><span class="p">):</span>
</span><span class='line'>      <span class="n">freq</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10</span>
</span><span class='line'>      <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
</span><span class='line'>          <span class="n">ridx</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">%</span> <span class="n">base</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">base</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
</span><span class='line'>          <span class="n">freq</span><span class="p">[</span><span class="n">ridx</span><span class="p">]</span><span class="o">++</span>
</span><span class='line'>      
</span><span class='line'>      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">):</span>
</span><span class='line'>          <span class="n">freq</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">freq</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
</span><span class='line'>      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
</span><span class='line'>          <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="n">base</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">base</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>
</span><span class='line'>          <span class="n">out</span><span class="p">[</span><span class="n">freq</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
</span><span class='line'>          <span class="n">freq</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">--</span>
</span><span class='line'>      <span class="n">arr</span> <span class="o">=</span> <span class="n">out</span>
</span><span class='line'>      <span class="n">base</span> <span class="o">*=</span> <span class="mi">10</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">return</span> <span class="n">arr</span>
</span></code></pre></td></tr></table></div></figure>


<h3>复杂度和应用范围</h3>

<p>跟三个变量有关，输入数组长度n，最大宽度width，以及数制数位的范围d，时间复杂度为O(width * (n + d))，对于常规整数来说d是10，而width顶多也就10左右（整数有范围的），都可忽略，因此时间复杂度是O(n)。空间复杂度也是O(n)。</p>

<p>基数排序可以应用于整数，对于有负数的情况，只需要把数平移到0以右就可以了。</p>

<p>另外，可以拓展到其他数制，比如16进制，8进制，甚至字符串也都可以。</p>

<h2><a href="https://en.wikipedia.org/wiki/Bucket_sort">桶排序</a></h2>

<p><img src="https://www.simplilearn.com/ice9/free_resources_article_thumb/Bucket-Sort-Algorithm-Soni/what-is-bucket-sort-algorithm.png" alt="" /></p>

<p>桶排序其实是<strong>分治</strong>，它的核心思想是把数据以一定的数据范围分成若干个桶，每个桶再应用其他的排序算法，然后再按照桶的顺序把桶里的数据接在一起就是结果了：</p>

<ol>
<li>确定数值范围min, max和桶数量k，然后得到一些区间</li>
<li>以这些区间来把数据进行分桶</li>
<li>每个桶单独排序</li>
<li>以桶的顺序 把结果连接在一起</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='python3'><span class='line'><span class="k">def</span> <span class="nf">bucketSort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
</span><span class='line'>  <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span><span class='line'>  <span class="n">k</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">4</span>
</span><span class='line'>  <span class="nb">min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span><span class='line'>  <span class="nb">max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</span><span class='line'>  <span class="n">buckets</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>
</span><span class='line'>  <span class="n">interval</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span> <span class="o">-</span> <span class="nb">min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>  <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
</span><span class='line'>      <span class="n">bidx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="nb">min</span><span class="p">)</span> <span class="o">/</span> <span class="n">interval</span><span class="p">)</span>
</span><span class='line'>      <span class="n">buckets</span><span class="p">[</span><span class="n">bidx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'>  
</span><span class='line'>  <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">buckets</span><span class="p">:</span>
</span><span class='line'>      <span class="n">sort</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</span><span class='line'>  <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>  <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">buckets</span><span class="p">:</span>
</span><span class='line'>      <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">out</span>
</span></code></pre></td></tr></table></div></figure>


<h3>复杂度与适用范围</h3>

<p>复杂度取决 于桶的个数k以及每个桶的排序方法，如果采用O(n<sup>2</sup>)，那么就会是O(n<sup>2</sup> / k)，如果采用O(nlogn)就会是O(nlog(n/k))，空间复杂度是O(n)。</p>

<p>需要注意，<strong>桶排序适用于浮点型</strong>，只要是数就可以。至于稳定性，则要看桶内排序算法的选择。</p>

<p>其实，如果是整数，无论范围是啥样的，都没有必要采用桶排序，因为桶排序 的复杂度不会估于O(nlogn)的。而如果桶内再采用计数或者基数排序的话（假如输入的是整数数组）就相当于脱了裤子放屁，因为本可以不用分桶的，直接采用计数排序或者基数排序。</p>

<p>桶排序适用于<strong>数据在桶中分布较均匀</strong>的场景，这样性能会达到最优。因为如果桶分配的不均匀，假如某一个桶中集中了绝大部分数据，其他桶几乎没有，这跟不分桶有啥区别（就像一个极不平衡的二叉树一样）。</p>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/contains-duplicate-iii/description/">220. 存在重复元素 III</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/contains-duplicate-iii/solutions/2566509/xi-you-yuan-su-220-cun-zai-zhong-fu-yuan-7zh8/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>总结</h2>

<p>今天重点学习了三种非比较排序算法，都是线性复杂度的，但它们并不是普适的算法，都<strong>有着特定的应用场景</strong>。要深刻理解它的原理和适用范围，以在实际运用中能够根据实际的问题灵活选择。</p>

<p>对于整数集合而言，如果元数数量远大于其数值范围，那么就用计数排序；否则就用基数排序。</p>

<p>对于浮点数，可以考虑使用桶排序。</p>

<p>当然 不可以死学，这些算法背后的核心思想也是可以用来解其他的题目的，比如桶的分治思想，以及像基数的以数位来处理问题的思想，可以拓展到字符排序等等。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://leetcode.cn/circle/discuss/eBo9UB/">十大排序从入门到入赘</a></li>
<li><a href="https://www.geeksforgeeks.org/counting-sort/">Counting Sort – Data Structures and Algorithms Tutorials</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1684188">漫画：什么是计数排序？</a></li>
<li><a href="https://oi-wiki.org/basic/counting-sort/">计数排序</a></li>
<li><a href="https://www.geeksforgeeks.org/radix-sort/">Radix sort</a></li>
<li><a href="https://www.cnblogs.com/bigsai/p/13977411.html">八大排序算法—16张图搞懂基数排序</a></li>
<li><a href="https://oi-wiki.org/basic/radix-sort/">基数排序</a></li>
<li><a href="https://www.geeksforgeeks.org/bucket-sort-2/">Bucket sort</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/125737294">【算法】排序算法之桶排序</a></li>
<li><a href="https://oi-wiki.org/basic/bucket-sort/">桶排序</a></li>
<li><a href="http://data.biancheng.net/view/115.html">桶排序（箱排序）原理及其时间复杂度详解</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解摩尔投票算法]]></title>
    <link href="http://toughcoder.net/blog/2023/10/09/understanding-boyer-moore-voting-algorithm/"/>
    <updated>2023-10-09T20:40:58+08:00</updated>
    <id>http://toughcoder.net/blog/2023/10/09/understanding-boyer-moore-voting-algorithm</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm">摩尔投票法(Boyer–Moore majority vote algorithm)</a>，也称为『多数投票法』，这个算法解决的问题是：如何在任意多的候选人中，选出获利票数最多的那个。从算法的角度来说就是在一个长度为n的数组中，找出出现次数大于n/2的那个数，称为<strong>多数元素</strong>或者<strong>主要元素</strong>(Majority Element)。</p>

<p><a href="http://toughcoder.net/blog/2023/10/09/understanding-boyer-moore-voting-algorithm/"><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.9kA_yyWm90PJSlwlt_XWMQHaEK?pid=ImgDet&rs=1" title="auto auto" ></a></p>

<!-- more -->


<h2>理解摩尔投票算法</h2>

<p>它的核心思想是让不同的数『相互抵消』，那么剩下的那个数就是Majority Element。要这样来理解，把数组想像成为很多不同颜色的气球，不同颜色的气球相撞就会两两爆破，那么我们让这些不同颜色 的气球两两爆破，最后剩下的那个颜色一定是数量最多的气球。</p>

<p><img src="https://i0.wp.com/strategicpeacock.com/wp-content/uploads/2015/09/colorful-balloons-hd-wallpapers-download-colorful-balloons-images-free1.jpeg" alt="" /></p>

<p>它分为两个步骤：</p>

<ol>
<li>相互抵消</li>
<li>验证结果</li>
</ol>


<p>伪码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="k">def</span> <span class="nf">majorityElement</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
</span><span class='line'>   <span class="c"># step 1: kill each other</span>
</span><span class='line'>   <span class="n">major</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>   <span class="n">vote</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>   <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
</span><span class='line'>      <span class="k">if</span> <span class="n">vote</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">major</span><span class="p">:</span>
</span><span class='line'>          <span class="n">vote</span><span class="o">--</span>
</span><span class='line'>      <span class="k">else</span> <span class="k">if</span> <span class="n">vote</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span><span class='line'>          <span class="n">major</span> <span class="o">=</span> <span class="n">x</span>
</span><span class='line'>          <span class="n">vote</span><span class="o">++</span>
</span><span class='line'>      <span class="k">else</span><span class="p">:</span>
</span><span class='line'>          <span class="n">vote</span><span class="o">++</span>
</span><span class='line'>
</span><span class='line'>   <span class="c"># verifty the major element</span>
</span><span class='line'>   <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>   <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">:</span>
</span><span class='line'>      <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">major</span><span class="p">:</span>
</span><span class='line'>          <span class="n">count</span><span class="o">++</span>
</span><span class='line'>   <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">major</span>
</span><span class='line'>   <span class="k">else</span><span class="p">:</span>
</span><span class='line'>      <span class="k">return</span> <span class="bp">None</span>
</span></code></pre></td></tr></table></div></figure>


<p>它的优点在于效率高，能够以O(n)的效率找到数组中的多数元素，并且不占用额外空间。如果能够确定数组中存在多数元素，那么第2步验证过程可以省略。否则的话还要再遍历一次数组，对第1步低消过程中留存下来的多数元素进行计数，验证其频次是否达到要求（如超过n/2）。</p>

<h2>证明</h2>

<p>该算法其实有一些前提，那就是超过n/2的多数元素只会有一个，可以用反证法来证明，如果存在两个多数元素，x是多数元素数量为m，y是另一个多数元素数量为n，根据定义，m和n都大于n/2是不可能的，与假设矛盾，因此原命题成立。</p>

<p><img src="https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_229_two_candidates.png" alt="" /></p>

<p>同理，还可以推广到超过n/3的多数最多有2个，超过n/m的多数元素最多有m-1个。</p>

<h2>典型题目</h2>

<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/majority-element/">169. 多数元素</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/majority-element/solutions/1395882/by-alexhilton-upn7/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/majority-element-ii/description/">229. 多数元素 II</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/majority-element-ii/solutions/2473700/xi-you-yuan-su-229-duo-shu-yuan-su-iiha-80mpo/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/boyer-moore-majority-voting-algorithm/">Boyer-Moore Majority Voting Algorithm</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1600607">图解算法 | 摩尔投票法求多数元素</a></li>
<li><a href="https://www.zhihu.com/question/49973163">如何理解摩尔投票算法？</a></li>
<li><a href="https://juejin.cn/post/6983311959588339743">使用摩尔投票法解决多数问题</a></li>
<li><a href="https://blog.csdn.net/qq_44443986/article/details/112366223">算法 摩尔投票算法(图解例题)</a></li>
<li><a href="https://blog.csdn.net/u014248127/article/details/79230221">摩尔投票算法( Boyer-Moore Voting Algorithm)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/104609555">摩尔投票法(Boyer–Moore majority vote algorithm)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Weather App With Jetpack Compose]]></title>
    <link href="http://toughcoder.net/blog/2023/09/19/weather-app-with-jetpack-compose/"/>
    <updated>2023-09-19T21:10:56+08:00</updated>
    <id>http://toughcoder.net/blog/2023/09/19/weather-app-with-jetpack-compose</id>
    <content type="html"><![CDATA[<p>现在满屏的Compose，近期也看了一些教程，似懂非懂，总感觉还缺点什么，于是有必要使用这些新技术来构造一个真实的Android App，以加深理解。第一个实例就是想做一个天气查询和展示的应用，使用<a href="https://developer.android.com/jetpack/compose">Jetpack Compose</a>以及Google推荐的<a href="https://developer.android.com/modern-android-development">MAD（Modern Android Development）</a>。</p>

<p><a href="http://toughcoder.net/blog/2023/09/19/weather-app-with-jetpack-compose/"><img src="http://images.shejidaren.com/wp-content/uploads/2013/09/weather-app.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>核心目的</h2>

<p>学习使用Jetpack Compose构建UI，和学习新的架构方式（MVVM）。其实我们不是只读式的学习，更重要的是要在一个真实的项目中去实践这些知识。</p>

<p>Follow官方的教程和建议，先由最简单的版本，一步步的使用这些轮子打造我们的天气应用。</p>

<p><strong>特别注意</strong>：此行不是为了做一个天气App，而是以MAD的方式来构建App，每一步都要<a href="https://m3.material.io/">符合设计规范</a>和<a href="https://developer.android.com/topic/architecture">架构原则</a>，不留破窗。</p>

<h2>技术栈</h2>

<p><img src="https://innovationm.co/wp-content/uploads/2021/05/Jetpack-compose.png" alt="" /></p>

<p>使用MAD，Jpetpack和Compose，以及<a href="https://developer.android.com/jetpack/androidx/releases/compose-material3">Material Design</a>。</p>

<h2>Weather API</h2>

<p>使用 <a href="https://dev.qweather.com/docs/start/">和风API</a>。</p>

<h2>第一个版本</h2>

<p>本着<a href="http://toughcoder.net/blog/2023/08/08/understanding-minimum-viable-product/">MVP的原则</a>，第一个版本尽量简单，实现核心需求即可，第一个版本的目标：查询预定列表中的城市天气，并展示其详细天气信息。</p>

<p>流程图：</p>

<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script>




<div class="mermaid">
flowchart TD
    A([Start]) &#45;&#45;> C{Has preferred city?}
    C &#45;&#45;> |No| E([Show City list])
    E &#45;&#45;> F([Pick a city])
    F &#45;&#45;> J([Save as prefered])
    J &#45;&#45;> D
    C &#45;&#45;> |Yes| D([Show detail page])
    D &#45;&#45;> G{data need refresh?}
    G &#45;&#45;> |Yes| H([Get weather data])
    H &#45;&#45;> D
    G &#45;&#45;> |No| I([End])
</div>


<h3>第一步：构建UI</h3>

<p>第一版本中的第一步，不用网络，全用fake data，把需要的两个页面构建出来，目的在于搭建基础设施，并把流程跑通。</p>

<h3>第二步：接入Weather API</h3>

<p>获取真实的天气数据，并完善天气详情页面。</p>

<h2>Reference</h2>

<ul>
<li><a href="https://juejin.cn/post/7176875120839884860">从 0 到 1 搞一个 Compose Desktop 版本的天气应用（附源码）</a></li>
<li><a href="https://juejin.cn/column/7127467629022806030">天气App系列文章</a></li>
<li><a href="https://github.com/harsh2907/JetWeather">A weather app built on MVVM architecture with jetpack compose and other jetpack libraries</a></li>
<li><a href="https://github.com/Felix-Kariuki/JetWeather">A weather app built using Jetpack compose</a></li>
<li><a href="https://github.com/Mercandj/android-dev-challenge-compose-4">Weather app done in Jetpack Compose for the #AndroidDevChallenge 2021 🌦 ☀️. Neumorphism UI.</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Kotlin Delegation]]></title>
    <link href="http://toughcoder.net/blog/2023/09/14/understanding-kotlin-delegation/"/>
    <updated>2023-09-14T22:01:46+08:00</updated>
    <id>http://toughcoder.net/blog/2023/09/14/understanding-kotlin-delegation</id>
    <content type="html"><![CDATA[<p>委托或者说委派，是一种设计机制，实现者并不真正的实现某些方法（行为），而是让另外一个对象来当真正的实现者。委拖与依赖注入和延时加载技术结合在一起会产生非常巨大的威力，让代码不但灵活方便扩展，也非常的优雅，但确实会较难以理解。<a href="https://kotlinlang.org/docs/delegation.html">委托机制(Delegation)</a>在Kotlin中的支持是很友好的，并且非常完善，用关键字by和lazy一起就可以写出非常强大的委拖机制代码。</p>

<p><a href="http://toughcoder.net/blog/2023/09/14/understanding-kotlin-delegation/"><img src="https://hashnode.com/utility/r?url=https:%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1629222884259%2FI3f9YGK1M.png%3Fw%3D1200%26h%3D630%26fit%3Dcrop%26crop%3Dentropy%26auto%3Dcompress%2Cformat%26format%3Dwebp%26fm%3Dpng" title="auto auto" ></a></p>

<!-- more -->


<h2><a href="https://en.wikipedia.org/wiki/Delegation_pattern">Delegation Pattern</a></h2>

<p>要想理解Kotlin中的委托，要先理解一下设计模式中的委托模式。严格来说委拖并不是一种设计模式，因为它并没有固定的范式，在GoF以及很多关于设计模式的书中并没有这一模式，准确的来说它是一种行为的实现方式，并不自己直接实现，而是委派给另外一个对象的方法。委托是一种行为模式，它只注重于行为，一般情况下都是对对象的方法进行委托，或者行为产生的结果也就是一个变量或者对象的域也可以委托，但只能委托给一个函数，这个函数会产生结果，以得到域的值。</p>

<p><img src="https://assets.alexandria.raywenderlich.com/books/des/images/c57492352703ffd13faa67205936b3bcb113947305da80d0be80770d0ceea10e/original.png" alt="" /></p>

<h3>委托与代理的区别</h3>

<p>代理是一种正式的设计模式，它强调的是权限和隔离，client只能访问到proxy，而并不知道realObject。而委托是一种实现机制，不自己实现，委派给其他对象去实现，它更强调的是行为和结果。代理是一种委托机制，但委托并不是代理。</p>

<p><img src="https://i1.wp.com/www.robertlarsononline.com/wp-content/uploads/2017/05/ProxyPatternGeneric.png?resize=700%2C388&amp;ssl=1" alt="" /></p>

<p>在理解了委托的概念后，就可以进一步的来看一下Kotlin中的委托了。</p>

<h2><a href="https://kotlinlang.org/docs/delegation.html">实现委托</a></h2>

<p>就是某一个类的实现，完全委托给另外一个对象，为了保持行为的一致，它们都实现了某一个接口。用关键字by来实现这一委托机制：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="n">interface</span> <span class="n">Base</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">fun</span> <span class="nf">print</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">BaseImpl</span><span class="p">(</span><span class="k">val</span> <span class="py">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">:</span> <span class="n">Base</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">override</span> <span class="k">fun</span> <span class="nf">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">Derived</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="n">Base</span><span class="p">)</span> <span class="p">:</span> <span class="n">Base</span> <span class="k">by</span> <span class="n">b</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">b</span> <span class="p">=</span> <span class="n">BaseImpl</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>
</span><span class='line'>    <span class="n">Derived</span><span class="p">(</span><span class="n">b</span><span class="p">).</span><span class="n">print</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>类Drived也实现了接口Base，但它并没有自己去实现方法，而是委派给了它的构造参数b，b也是一个实现了接口的对象。这样Drived的行为就都委托给了对象b。而b则可以是任何一个实现了Base接口的对象，并且是在创建Drived时才指定的。更进一步的，这里可以用工厂方法，因为只要能生成一个实现了Base接口的对象即可，甚至可以用依赖注入来动态生成对委托对象。</p>

<p>这里需要明确一下术语，委托给别人的对象称为受托对象或者受托类，真正的做事情的人称之为委托对象。</p>

<p>Kotlin仅用一个关键字by就可以完成委托，编译器会自动生成受托类的实现，它的每个方法就直接调用委托对象的方法，可以理解 为上面的代码会编译生成这要的字节码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">Derived</span> <span class="kd">extends</span> <span class="n">Base</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Base</span> <span class="n">impl</span><span class="o">;</span>
</span><span class='line'>    <span class="n">override</span> <span class="kt">void</span> <span class="nf">print</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>         <span class="n">impl</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2><a href="https://kotlinlang.org/docs/delegated-properties.html">属性委托</a></h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">class</span> <span class="nc">Example</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">p</span><span class="p">:</span> <span class="n">String</span> <span class="k">by</span> <span class="n">Delegate</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>属性委托是把属性的getter/setter委托给某一个函数，或者某一个对象（这个对象要有setValue/getValue方法，本质上仍是委托给一个函数）。</p>

<h2><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/lazy.html">延时机制(lazy)</a></h2>

<p>延时机制的委托才能产生最大的威力，而在Kotlin中，借助by和lazy就能对对象的属性实现延时委托机制，让只有在必要的时候(即第一次访问这个属性的时候)才生产出属性的真实值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">lazyValue</span><span class="p">:</span> <span class="n">String</span> <span class="k">by</span> <span class="n">lazy</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;computed!&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="s">&quot;Hello&quot;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="n">lazyValue</span><span class="p">)</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="n">lazyValue</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其实，by lazy可以应用在任何地方，不光是属性，常规的变量也是可以的。另外，需要注意lazy不但是第一次用到此变量时才会此具体计算，而且也只计算一次，后续再访问时，会从cache中读取首次计算后的值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">var</span> <span class="py">foo</span> <span class="k">by</span> <span class="n">lazy</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">someCondition</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>         <span class="n">generate</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>         <span class="n">defaultValue</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个例子，假如第一次访问变量foo时，执行lazy后时someCondition是false就会返回defaultValue，而且后续再访问foo也不会再执行这个尾部lambda了，会直接返回defaultValue，因为它被cache住了。所以一般用lazy都是要针对 只读变量，也即<code>val foo by lazy { ... }</code>，这才是最正统的用法。</p>

<p>需要注意，lazy并不是一个关键字，它是一个函数，它只有一个参数就是一个lambda，所以可以写成尾部lambda的方式。</p>

<h2>常规委托</h2>

<p>使用by关键字就可以实现委托，这除了可以用于类的实现，属性实现以外，其实任何一个变量也可以用by来委托给一个函数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">var</span> <span class="py">expand</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.cnblogs.com/itzhoucong/p/14255117.html">设计模式（二）之委派模式（Delegate Pattern）深入浅出 </a></li>
<li><a href="https://learnku.com/docs/99-software-pattern/delegation-pattern/12018">委托模式 Delegation Pattern</a></li>
<li><a href="https://www.zhihu.com/question/23123039">编程设计模式中委托 和代理模式什么区别？</a></li>
<li><a href="https://stackoverflow.com/questions/38250022/what-does-by-keyword-do-in-kotlin">What does &lsquo;by&rsquo; keyword do in Kotlin?</a></li>
<li><a href="https://blog.csdn.net/wzgiceman/article/details/82689135">Kotlin -by 详解</a></li>
<li><a href="https://juejin.cn/post/7057675598671380493">Kotlin常用的by lazy你真的了解吗</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[More About Kotlin Functions]]></title>
    <link href="http://toughcoder.net/blog/2023/09/13/more-about-kotlin-functions/"/>
    <updated>2023-09-13T20:52:36+08:00</updated>
    <id>http://toughcoder.net/blog/2023/09/13/more-about-kotlin-functions</id>
    <content type="html"><![CDATA[<p>Kotlin中的函数是一级对象，除了常规的函数式编程以外，还支持一些非常灵活的特殊用法，可以大大增强代码的可读性和简洁性，让代码更加的优雅，在业界顶级的库如Compose中有大量的应用，今天就来学习一些，以扫清学习Compose的障碍。</p>

<p><a href="http://toughcoder.net/blog/2023/09/13/more-about-kotlin-functions/"><img src="https://www.callicoder.com/static/faf261ddf8d3f25d8c48da997d9a2dc1/kotlin-functions.png" title="auto auto" ></a></p>

<!-- more -->


<h2><a href="https://kotlinlang.org/docs/extensions.html">Extension Functions</a></h2>

<p>与传统的编程语言如C/C++，Java或者Python最大的不同就是，Kotlin对于类的扩展提供了相当灵活的方式。像Java和Python除了标准的继承方式以外，就只能用注解和Decorator。但对于Kotlin还可以用<a href="https://kotlinlang.org/docs/extensions.html">Extensions</a>这一方式。无论是注解还是Decorator，它的使用方式还是比较笨拙的，可以明显的看出来是额外定义的函数，与原Class是没啥关系的。</p>

<p><img src="https://thetechstack.net/assets/images/banners/kotlin-extension-function.png" alt="" /></p>

<p>比如说，对于整数来说，我们通常会有求绝对值，通常可以这样写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">fun</span> <span class="nf">abs</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">=</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span> <span class="p">-</span><span class="n">a</span> <span class="k">else</span> <span class="n">a</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后，这样使用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">aa</span> <span class="p">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>但在Kotlin中，有更优雅的方式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">fun</span> <span class="nf">Int</span><span class="p">.</span><span class="n">abs</span><span class="p">()</span> <span class="p">=</span> <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span> <span class="p">-</span><span class="k">this</span> <span class="k">else</span> <span class="k">this</span>
</span><span class='line'>
</span><span class='line'><span class="n">println</span><span class="p">((-</span><span class="m">4</span><span class="p">).</span><span class="n">abs</span><span class="p">())</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="m">100.</span><span class="n">abs</span><span class="p">())</span>
</span></code></pre></td></tr></table></div></figure>


<p>这就是Extension functions，这样定义了后，可以像整数类型本身定义的方法那样直接在其对象上面调用。</p>

<h3>如何定义Extension functions</h3>

<p>Extension functions是针对Class的，或者一个Type的，指定目标Class名字，和参数就可以了，在函数的内部this就是调用函数时的对象。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">fun</span> <span class="err">&lt;</span><span class="nf">ClassName</span><span class="p">&gt;.&lt;</span><span class="n">function</span> <span class="n">name</span><span class="p">&gt;(</span><span class="n">params</span><span class="p">...):</span> <span class="k">return</span> <span class="k">type</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// this is the function&#39;s receiver, which is the object when function invoked.</span>
</span><span class='line'>  <span class="c1">// function implementation</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意，Extension functions必须是针对Class的。</p>

<h3>理解Extension functions</h3>

<p>Extension functions并没什么高深和神秘的东西，它只是相当于一个static函数，接收目标Class的对象而已，比如说：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">fun</span> <span class="nf">Shape</span><span class="p">.</span><span class="n">area</span><span class="p">():</span> <span class="n">Int</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">length</span> <span class="p">*</span> <span class="k">this</span><span class="p">.</span><span class="n">width</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="nf">area</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">Shape</span><span class="p">):</span> <span class="n">Int</span> <span class="p">=</span> <span class="n">shape</span><span class="p">.</span><span class="n">length</span> <span class="p">*</span> <span class="n">shape</span><span class="p">.</span><span class="n">width</span>
</span></code></pre></td></tr></table></div></figure>


<p>其实这两个函数是完全一样的，上面的那个Extension function其实就相当于后面的那个常规函数。只不过在函数的调用上面更加的方便，看起来更像是目标Class提供的方法一样，更优雅一些。</p>

<h3>Extension function的作用域</h3>

<p>Extension function并不会真的对目标Class做任何修改，它只是相当于你自己定义的一个函数。所以，它的作用域就是你定义的函数的作用域，如果你是在一个文件中定义的，那么它的作用域就是导入了这个文件的地方；如果是在一个类中的，那作用域就是这个类。</p>

<p>另外的问题就是，假如在多个地方定义了相同的Extension function，会发生什么呢，相同的意思就是目标Class一样，函数名字也一样，所做的事情也一样，仍是把它当成普通函数来理解就行，按照虚拟机懒惰加载的原则，应该是第一个被引用到的Extension function生效。</p>

<h3>参考资料</h3>

<ul>
<li><a href="https://www.baeldung.com/kotlin/extension-methods">Extension Functions in Kotlin</a></li>
<li><a href="https://marketsplash.com/tutorials/kotlin/kotlin-extension-function/">Kotlin Extension Function: How To Implement And Use It</a></li>
<li><a href="https://www.geekailab.com/doc/as/book/docs/Part1/Android%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87Kotlin%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/KotlinExtensions.html">让人爱不释手的Kotlin扩展（Extensions）技术探Extensions秘与应用</a></li>
<li><a href="https://www.jianshu.com/p/314cdb1603fc">Kotlin 扩展函数及原理</a></li>
<li><a href="https://juejin.cn/post/6935027613542907941">Kotlin 编程 #3 扩展函数（终于知道为什么 with 用 this，let 用 it）</a></li>
</ul>


<h2><a href="https://kotlinlang.org/docs/functions.html#infix-notation">Infix Functions</a></h2>

<p>准确的来说是Infix notation，它是一种执行函数的特殊方式，并不是定义了特殊的函数。也就是说某个函数被infix修饰了后，就可以用更为简洁的方式来调用它。常规的函数执行（或者说调用）是用函数名字加上括号，括号里面是参数，比如foo()，bar(&ldquo;here&rdquo;)。而infix方式则可以是 <code>参数1 函数名 参数2</code> 这种方式，也即与常规的函数调用完全不一样。看起来像是语言本身的关键字一样。</p>

<p><img src="https://www.fusebes.com/wp-content/uploads/2021/03/Post-Banners-FuseBase-17-1.png" alt="" /></p>

<p>比如，移位并不是运算符，也不是关键字，而是一个被infix修饰的二元参数函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="n">finfix</span> <span class="n">un</span> <span class="n">Int</span><span class="p">.</span><span class="n">shr</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Int</span> <span class="p">{...}</span>
</span><span class='line'>
</span><span class='line'><span class="m">8.</span><span class="n">shr</span><span class="p">(</span><span class="m">2</span><span class="p">)</span> <span class="c1">// 这样正常调用也完全可以，把整数8右移2位</span>
</span><span class='line'><span class="m">8</span> <span class="n">shr</span> <span class="m">2</span> <span class="c1">// 这是infix式的用法，其实是等同于上面的函数调用</span>
</span></code></pre></td></tr></table></div></figure>


<p>infix必须是Extension function，并且只能有一个参数，算上Extension function的接收对象，其实一共是2个参数。标准库中也定义了大量的infix，如整数位移的shr和shl。以及像一些DSL中的函数，都会定义成infix，以让代码更简洁。</p>

<p>总之，下次再见到 <code>a xyz b</code> 这种写法时，不用害怕，并不是有了新的关键字，这里的xyz是infix notation，把它当成函数调用 <code>xyz(a, b)</code> 就好了。</p>

<h3>参考资料</h3>

<ul>
<li><a href="https://www.programiz.com/kotlin-programming/infix-notation">Kotlin Infix Function Call</a></li>
<li><a href="https://www.baeldung.com/kotlin/infix-functions">Infix Functions in Kotlin</a></li>
</ul>


<h2><a href="https://kotlinlang.org/docs/inline-functions.html">inline Functions</a></h2>

<p><img src="https://cdn.educba.com/academy/wp-content/uploads/2021/04/Kotlin-Inline-Function.jpg" alt="" /></p>

<p>常规的lambda会有closure（捕获上下文中的对象），在编译后会产生很多对象，这会导致一些性能问题，但这是标准的函数式编程。</p>

<p>但某些情况下，我提供的是一个单纯的行为（lambda），比如像Collections的forEach以及filter，传入的lambda也好，或者其他函数也好，这是一个单纯的行为，你在集合中遍历时执行它就好。这种情况好，我们希望高阶函数在其函数体内直接使用传入的函数参数就可以了，不需要进行常规的对象创建（closure对象以及函数接口对象）。就可以使用inline关键字来修饰这人高阶函数。</p>

<h3>参考资料</h3>

<ul>
<li><a href="https://www.baeldung.com/kotlin/inline-functions">Inline Functions in Kotlin</a></li>
<li><a href="https://amitshekhar.me/blog/inline-function-in-kotlin">inline function in Kotlin</a></li>
<li><a href="https://www.geeksforgeeks.org/kotlin-inline-functions/">Kotlin Inline Functions</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jetpack Compose Road Map]]></title>
    <link href="http://toughcoder.net/blog/2023/09/08/jetpack-compose-road-map/"/>
    <updated>2023-09-08T23:04:44+08:00</updated>
    <id>http://toughcoder.net/blog/2023/09/08/jetpack-compose-road-map</id>
    <content type="html"><![CDATA[<p>Jetpack Compose是由Google在2019年Google I/O大会提出的新一代声明式UI框架，它基于Kotlin编程语言与Android Studio可以无缝衔接，在Google的大力推动下，现在已经变成了Android App的标准UI构建方式。网络上更是更是满屏的相关内容，如果说没有用过Compose都不好意思说自己会Android开发。是时候恶补一下了。</p>

<p><a href="http://toughcoder.net/blog/2023/09/08/jetpack-compose-road-map/"><img src="https://www.somagnews.com/wp-content/uploads/2021/02/Jetpack-Compose.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>快速上手体验</h2>

<p>可以follow下Google官方的<a href="https://developer.android.com/jetpack/compose/tutorial">Quick start</a>教程来快速体验一下。</p>

<p>可以<a href="https://developer.android.com/jetpack/compose/documentation">参考官方文档</a>以进一步了解。</p>

<h2>理解Compose</h2>

<h3>全用代码撸UI</h3>

<p>体验过Compose可以发现，它与原生的Android app UI开发完全不同，最大的区别就是全是Kotlin代码，不用再去摆弄xml了。</p>

<h3>本质是DSL</h3>

<p>其实Compose与Kotlin最初搞的<a href="https://github.com/Kotlin/anko">anko</a>是类似的东西，它的核心是利用Kotlin的语言特性来实现了一套写UI的DSL。在Compose里面所有的花括号其实都是一个函数，而且Compose里面的DSL都是用的大写字母开头的驼峰式，如<strong>Text {}</strong>，让人误以为这是一个类，但其实它是一个函数，容易让人误解不说，还不符合Kotlin语言的开发规范。这一点上当初的anko就相当的好，它的DSL命令都与函数的命名是一致（小写开头的驼峰式）。</p>

<p><strong>注意</strong>，如果Compose用起来感觉相当的别扭，这说明缺少前置知识，要把Kotlin的一些高级特性熟悉一下，比如<a href="http://toughcoder.net/blog/2023/02/14/understanding-kotlin-based-dsl/">DSL</a>，委拖机制以及扩展函数，只有把这些概念熟悉了以后，再写Compose会顺手很多。记住，Compose里面的所有东西都是函数调用，当成函数来写就可以了。</p>

<p>Compose其实就是一坨DSL，一层层的嵌套，本质上是一坨函数调用。极容易写出『箭头式』的代码，如这种：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">private</span> <span class="k">fun</span> <span class="nf">Greetings</span><span class="p">(</span>
</span><span class='line'>    <span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">,</span>
</span><span class='line'>    <span class="n">names</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">List</span><span class="p">(</span><span class="m">100</span><span class="p">)</span> <span class="p">{</span> <span class="s">&quot;Compose #${it + 1}&quot;</span> <span class="p">}</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// A surface container using the &#39;background&#39; color from the theme</span>
</span><span class='line'>    <span class="n">Surface</span><span class="p">(</span><span class="n">modifier</span><span class="p">,</span> <span class="n">color</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">colorScheme</span><span class="p">.</span><span class="n">background</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">LazyColumn</span><span class="p">(</span><span class="n">modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="n">vertical</span> <span class="p">=</span> <span class="m">4.</span><span class="n">dp</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">items</span><span class="p">(</span><span class="n">items</span> <span class="p">=</span> <span class="n">names</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                 <span class="n">Greeting</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当view的嵌套比较深的时候，更明显，这就需要我们要及时的抽出公共的Composable组件，其实就相当于抽出函数，以让嵌套不那么深。</p>

<p>其实Android的原生UI开发方式（也即View与xml）是相当强大的，特别是在复用，如animation，drawable，color，string和dimens的复用和适配已经相当完善了。这方面Compose还是略显笨拙，因为还必须代码，甚至还可能重复的代码。对于常规的页面，比如列表（横竖或者格子）和基础UI组件（图片，文字和按扭）组合而成的页，用Compose是完全不成问题的。但对于成百上千个各种小组件时，View的结构与交互都非常复杂的页面时，如某宝某东某团的页面，或者页面有重型的组件，如Webview，如video，graphics或者游戏，Compose肯定 力不从心。这也是为何国内，特别是一些大厂其实对Compose这玩意儿并不怎么感冒，真正在产品里使用的可能还是那些国外头部app。</p>

<h3>到处是函数</h3>

<p>Compose是用函数式编程方法，所有的Composable都是顶层的函数，也即是定义在类外面的函数，通常称为顶层函数。</p>

<p>标准库以及Material库中提供的所有轮子也都是函数，虽然它们的名字是大写的驼峰式，看起来像类一样，但其实它们都是函数。所有的Composable都接收尾部lambda，它其实是函数的最后一个参数，接收的是类型为Composable的函数，因此可以用尾部lambda的方式来实现这个参数。</p>

<p>还有一点就是，很多参数接收的也是一个函数，比如像接收Icon和Text的地方，其实是一个函数，而并不是直接把具体对象传过去，像这些地方的参数实际上需要的是一个能产生目标对象的Producer。这也是标准的函数式编程思想，也就是说尽可能的传递函数而非对象，目的在于这样更为灵活，可以让参数的使用尽可能的延时生成对象，也就是仅当真实需要的时候才会运行这个函数生成对象。而在中间过程中，或者说假如出错了，进入到错误显示的逻辑或者直接退出 了，那么其实就不需要生产对象了。</p>

<p>而传统的OO方式，是在构建流程的一开始就把对象创建好，并作为参数传过去，但其实可能完全没有必要。</p>

<h2>进阶之路</h2>

<p>最好的资源莫过于官方推出的教程。
<a href="https://developer.android.com/courses/jetpack-compose/course">jetpack compose course</a>是Google官方推出的一系列教程，有视频讲解，有实战codelab，还有测试quiz。相当的丰富，可以看得出Google对Compose还是相当上心的。</p>

<h2>项目实战</h2>

<p>有一些非常优秀的真实的用Compose构建 出来的App可以供学习和参考，<a href="https://developer.android.com/jetpack/compose/samples">有些是官方的</a>，有些则是民间的，不但开源，而且还有配套的博客来说明构建 的过程，是非常难得的参考 资料。</p>

<ul>
<li><a href="https://github.com/android/compose-samples/tree/main/Jetchat">Jetchat</a> 纯Compose构建UI，适合初学者上手</li>
<li><a href="https://github.com/android/compose-samples/tree/main/Jetsurvey">Jetsurvey</a>纯Compose构建UI，适合上手</li>
<li><a href="https://github.com/android/sunflower/tree/main">Sunflower</a> 除UI外，还有网络要用到Jetpack组件</li>
<li><a href="https://github.com/android/nowinandroid/tree/main">Now in Android</a> 集大成者，Compose，加上Jetpack再上架构思维，适合高级玩家</li>
<li><a href="https://github.com/ellisonchan/ComposeMovie">电影App</a> 一个电影的简单app，配套<a href="https://blog.csdn.net/allisonchen/article/details/115052707">博客在这里</a></li>
<li><a href="https://jetpackcompose.cn/docs/">Jetpack Compose博物馆</a> 不但有教程，还有数个实例</li>
<li><a href="https://github.com/wangchenyan/wanandroid-compose">WanAndroid</a> <a href="https://www.wanandroid.com/">WanAndroid</a>的一个客户端，<a href="https://www.jianshu.com/p/cc11f2c93778">配套博客</a></li>
<li><a href="https://github.com/Mercandj/android-dev-challenge-compose-4">Compose Weather App</a> <a href="https://www.jetpackcompose.net/compose-weather-app">配套博客</a></li>
<li><a href="https://github.com/microsoft/surface-duo-compose-samples/tree/main">Surface Dual Compose Samples</a> Compose是一个跨平台的UI构建工具，不光能为Android构建，为其他平台也能构建App，<a href="https://learn.microsoft.com/zh-cn/dual-screen/android/jetpack/compose/samples">如Surface</a></li>
</ul>


<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.google.cn/kotlin/first">Android’s Kotlin-first approach</a></li>
<li><a href="https://coolshell.cn/articles/17757.html">如何重构“箭头型”代码</a></li>
<li><a href="https://developer.android.com/jetpack/compose/mental-model">Thinking in Compose</a></li>
<li><a href="https://www.jetpackcompose.net/">Jetpack Compose Tutorial</a></li>
<li><a href="https://www.jetpackcompose.app/">The #1 destination for all things Jetpack Compose</a></li>
<li><a href="https://www.theinsaneapp.com/2021/08/jetpack-compose-sample-examples-projects-and-android-apps.html">70+ Jetpack Compose Projects For Beginners And Experts</a></li>
<li><a href="https://developersbreach.com/compose/">Collection of Android Compose UI samples</a></li>
<li><a href="https://c1ctech.com/android-jetpack-compose-example/">Android Jetpack Compose Example</a></li>
<li><a href="https://blog.mindorks.com/jetpack-compose-tutorial/">Jetpack Compose Tutorial - Step by Step Guide</a></li>
<li><a href="https://foso.github.io/Jetpack-Compose-Playground/compose_projects/">Compose Projects</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[回乡见闻：感知农村的新变化]]></title>
    <link href="http://toughcoder.net/blog/2023/08/09/hometown-travel-notes/"/>
    <updated>2023-08-09T22:28:53+08:00</updated>
    <id>http://toughcoder.net/blog/2023/08/09/hometown-travel-notes</id>
    <content type="html"><![CDATA[<p>前不久休了一个星期的假，回了趟老家，一路所见所闻不少令人惊叹的事情，有必要略作小结并记录下来，也没什么特别的目的，就是把一些看到的比较有意思的事情以及产生的想法分享一下。</p>

<p><a href="http://toughcoder.net/blog/2023/08/09/hometown-travel-notes/"><img src="https://ts1.cn.mm.bing.net/th/id/R-C.4c2c27ca5d13da44d3fced7c83764ff7?rik=Y4MYdJogaFhAsQ&riu=http%3a%2f%2fimg.siluclouds.com%2fa%2fthumb%2f10009%2f201902%2f8a895a81d2c2425a656bea42dade314f.jpg!w960_h540.jpg&ehk=KlsjVgYoPkPh4RVso0rQpCyZXeeNVBbmRFABESBYr%2bM%3d&risl=&pid=ImgRaw&r=0" title="auto auto" ></a></p>

<!-- more -->


<h2>一些背景</h2>

<p>我的老家是在东北的一个贫困县城的一个村子里，跟一些讲述东北地区影视剧里面的村子是一样的。虽然是贫困县，但其实并不是想像中的那种吃不上饭，住不上房子的那种，从小到大吃穿住以及上学的费用等等都不成问题的。贫困的原因并不是生活不温饱，而是这么多年来，一直富不起来，与同区域内的较富一点的县城比，以及南方的大多数县城比，还是落后很多的，生活在这里的人也相对较穷。</p>

<p>县城下面，就是镇和乡，一个县城下面会十几个乡镇，乡和镇下面是村，我老家就住在村上，村下面还有屯儿，一个乡或镇下面会十几个村，一个村通常有十个左右的屯儿。对于生活在村里面的人来说，乡镇就是活动半径，一年会去几次县城，县城的商品是最全的，生活所需要的所有东西都能在县城买到，乡镇上最常用的东西如米面菜，零食，日用百货和常用药品也都能买 得到，到了村儿里，就只有食杂店了，零食和最常用的日用品能买 得到，屯儿的话则是啥都没有，只有生活在这里的人。</p>

<p>以前路不好，柏油水泥这种下雨天也能走的路只通到乡镇一级，而且也破败不堪。现在情况大为改观，村屯之间都修了水泥路，村屯里面的主要几条街道也都给修了水泥路，对出行有极大的改善，以前那种雨后全是大泥巴，无法出行的场景，已看不到了。因为路好了，所以走村串屯的流动商贩也远比以前多了，通常是用一个小型货车，拉车各种生活物品，一个村一个村的流动，到了村上就走街串巷的叫卖。</p>

<h2>微信无处不在</h2>

<p>令人震惊的是微信真的无处不在，已经触达了所有人，村里的老人也都用微信相互沟通。此外，商业活动和行政工作也都用微信。比如，省城到县城的客运大巴的售票都是通过微信服务号实现的，并没有官方网站。村上的行政工作，也都是通过微信，发什么通知之类的都是通过微信群，甚至有些福利的发放等也都通过微信。</p>

<p><img src="https://logodix.com/logo/1812564.png" alt="" /></p>

<p>还有一个现象是，都用微信支付，几乎看不到支付宝的影子。比如县城的出租车，乡镇村店里的收款，以及一些流动商贩都是用微信来收款，没有用支付宝的。猜测原因可能是大家平时就用微信，所以顺便用微信支付来方便交易，支付宝只有支付功能，不能用来干别的，为啥要用它？</p>

<h2>镇上的蜜雪冰城极为受欢迎</h2>

<p><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.5y5uvhFtaTE__UmR4U6xEQHaFj?pid=ImgDet&amp;rs=1" alt="" /></p>

<p>稍好一点的乡镇上有蜜雪冰城的店，并且比较受欢迎，但没看到同类型的其他品牌的饮品店。店的空间不小，有空调冷气，有舒适的位子坐，年轻人会扫码微信点餐（微信真的无所不能，无所不在啊），年纪大一点的人就现场排队点餐，所有单品均在5~10块左右，却比袋装的冷饮和瓶装的饮料口味好上不少，老少皆宜。</p>

<h2>快递最后一公里极为蛋疼</h2>

<p>村里人网购其实前几年就开始了，但现在仍不是主流，最主要的原因仍旧是快递最后一公里问题。快递包裹只能送到乡镇一级的代收点，无法到村，连京东也只是送到乡镇的代收点，后面就只能自己想办法去取。</p>

<h2>美团社区团购已深入村里</h2>

<p><img src="https://n.sinaimg.cn/sinakd20111/320/w1200h720/20210413/acde-knqqqmv1811611.jpg" alt="" /></p>

<p>最令人震惊的是村里面的人已经有不少人使用美团的社区团购了，不过只能是次日达，也就是今天下单明天送达，并且品类越来越齐全了，不但有瓜果蔬菜，米面油和酒水，连日用百货也都有了。不但村里面的年轻人会大量的下单，连一些老年人也开始大量的下单了，因为有些单品确实很便宜。并且使用相当的方便，直接用微信里面的美团小程序就能下单，微信就能登录，支付就用微信支付，即使对于老年人也是没有难度的。</p>

<p>每天下午4点左右，会有配货的车把货物送到村里面的团长家里，然后大家都去团长家里取货。商品的丰富程度与县城的超市是一样的，远比乡镇村的各种店丰富，事实上货品也都是从县城的仓库中调配出来的。</p>

<h2>手机多是HOV的中低端机</h2>

<p>村里人用的手机都是荣耀，OPPO和Vivo的中低端手机，约在1000元~2000元档，年轻一点的人用2000元往上一点的，老年人一般都是一千出头的千出头的千元机。大部分人手机中应用不多但微信，快手和抖音这三个几乎每个手机上都有。</p>

<p>手机毕竟属于较贵重的单品，前面也说了快递无法直达村，所以人们买 手机肯定是去县城里面的店里面买，这说明在县城级别的线下市场，HOV仍占绝对优势，粮厂的优势仍是在一二线城市。</p>

<h2>农村垃圾处理问题很大</h2>

<p>现在村里面垃圾处理是一个很大的问题，其实一直都是一个问题，只是以前感觉没那么明显，但现在人们生活水平好了一些，衣食方面更新的速度比以前快很多，自然产生的垃圾也多了很多，网购和社区团购也导致人们买更多的有包装的食品，这也会产生比以前更多的垃圾。</p>

<p>垃圾也不会随处丢，一般都是集中到村子外面的某一处，但也只是简单的堆放在那里，没有进一步的处理方式（如填埋或者焚烧），有的管理稍好一点的乡镇，会调用资源进行进一步的集中，然后填埋，但也不够理想，毕竟成本很高，村屯又很分散，清运垃圾的成本很高，很多乡镇都搞过垃圾集中站，但最后都不了了之了。</p>

<h2>房地产大周期已到尽头</h2>

<p>现在村屯里面全是新房子了（砖墙和铁皮屋顶），小时侯那种土墙和茅草屋顶已经见不到了，稍年轻一点的人也会在县城里面买楼房住，农忙时会回到村里面住，忙完了就会回到县城住，大部分也都买 了小汽车。即使这样县城的楼房还空着一大半，前几年地产商在县城疯狂的建了好多新楼房，但愿去县城的人和有能力去县城的人毕竟有限。另一方面，县城的建材市场行情近一两年也大幅下滑，因为村里面的新房子建的差不多了，也饱和了。</p>

<h2>无人机喷农药</h2>

<p><img src="https://ts1.cn.mm.bing.net/th/id/R-C.f25f792f9e4ecacacaa6da55525f80d9?rik=QQjyA%2f1eY%2fgo2Q&amp;riu=http%3a%2f%2fwww.qfhkzb.com%2fUploads%2fimage%2f20190805%2f1564965385884174.jpg&amp;ehk=pRZuEOrAGmbG3prpdgy9x1BQiNgHBgGQb9aHUITD2fU%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0&amp;sres=1&amp;sresct=1" alt="" /></p>

<p>村里面已经有人用上了无人机来喷农药了，是那种较大型的四翼无人机，与常见的航拍那种是一样的，只不过个头更大。运营模式是中介式的，也就是有人专门养护无人机，给农民的田地里喷农药，赚取佣金。毕竟这种大型的无人机成本较高，维护成本也很高，并且操作起来难度也不小，并不是人人都能驾驭得了的。</p>

<h2>明天会更好</h2>

<p><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.U0S--5yGkvRugBuww7MHkAHaEK?pid=ImgDet&amp;rs=1" alt="" /></p>

<p>现在国家的政策也更多的偏向广大农村地区，每年都会出台很多的惠农政策以及振兴新农村政策，因为各种不可抗力，到了基层执行效果会大打折扣，但仍相信一切都只会变得越来越好。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Minimum Viable Product]]></title>
    <link href="http://toughcoder.net/blog/2023/08/08/understanding-minimum-viable-product/"/>
    <updated>2023-08-08T22:11:11+08:00</updated>
    <id>http://toughcoder.net/blog/2023/08/08/understanding-minimum-viable-product</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Minimum_viable_product">Minimum Viable Product(MVP)</a>是创业公司中比较流行的一个产品开发方法，一个比较贴切的翻译是最低可行产品，但总感觉不如英文原文有感觉。它能够帮助创业团队以最小的成本，开发出一个刚好能满足用户核心需求的产品，来验证商业逻辑是否可行。</p>

<p><a href="http://toughcoder.net/blog/2023/08/08/understanding-minimum-viable-product/"><img src="https://www.agiratech.com/wp-content/uploads/2019/09/what-is-a-minimum-viable-product.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>理解MVP</h2>

<p>MVP最初由Eric Ries提出来的，它的意思是一个能够让一个团队以最少的成本（时间与金钱）来收集最多的用户的真实需求和想法。通过做出一个最基础功能的产品，并发布给用户使用，不断的接受用户的反馈，基于用户的反馈，再进行迭代。</p>

<p><img src="https://ts1.cn.mm.bing.net/th/id/R-C.537b2438249904649d41a4f5e5f952da?rik=AYTulqitQkA9CA&amp;riu=http%3a%2f%2fwww.azquotes.com%2fpicture-quotes%2fquote-the-minimum-viable-product-is-that-version-of-a-new-product-which-allows-a-team-to-collect-eric-ries-72-47-40.jpg&amp;ehk=HBGya%2bo4pC0WU1lX10ONl%2bMz4pne%2fsrzCEx3Zq4qAQM%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" /></p>

<p>这段原文并不难，直接多读几遍去理解其内在涵义，目前并末找到一个非常贴切的翻译。</p>

<p>一个最为贴切的表达MVP精髓的图片就是那张滑板车到跑车的图片了：</p>

<p><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.Sroo_DWfJfKCeSmQs5QdewHaE7?pid=ImgDet&amp;rs=1" alt="" /></p>

<h2>MVP不是什么</h2>

<p>需要特别注意的是，MVP不是产品原型，也不是软件的alpha版本。它是一个完整的产品，经过了足够的测试，足够安全，足够稳定，是符合上线发布标准的产品。从产品上来说它是『Viable』的，也即是完全可使用的，也能解决用户问题，满足用户需求的产品。精华在于『Minimum』也就是仅仅包含能满足用户核心需求的最少功能。</p>

<h2>如何做到MVP</h2>

<h3>弄清楚产品的市场定位</h3>

<p>也就是说你的产品到底是给谁使用的，必须 弄清楚。</p>

<h3>挖掘核心需求</h3>

<p>也就是你的产品到底解决了用户的什么问题。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.productplan.com/glossary/minimum-viable-product/">Minimum Viable Product (MVP)</a></li>
<li><a href="https://www.agilealliance.org/glossary/mvp/">What is a Minimum Viable Product (MVP)</a></li>
<li><a href="https://www.netsolutions.com/insights/how-to-build-an-mvp-minimum-viable-product-a-step-by-step-guide/">A Step-by-Step Guide to Build a Minimum Viable Product (MVP)</a></li>
<li><a href="https://www.woshipm.com/pd/879821.html">五个步骤，实现产品MVP</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/258565534">什么是MVP（最小可行性产品）？如何构建和验证MVP？</a></li>
<li><a href="https://www.minjiekaifa.com/agilearticles/mvp-prototype-proof-of-concept-80445.mhtml">MVP、原型、概念验证，傻傻分不清楚？</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1724045">5 分钟，带你了解MVP（最低可行性产品）</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
