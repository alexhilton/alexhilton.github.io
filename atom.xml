<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[稀有猿诉]]></title>
  <link href="http://toughcoder.net/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2023-05-16T21:06:43+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[悼念耗子叔]]></title>
    <link href="http://toughcoder.net/blog/2023/05/16/mourn-mr-hao-chen/"/>
    <updated>2023-05-16T10:03:45+08:00</updated>
    <id>http://toughcoder.net/blog/2023/05/16/mourn-mr-hao-chen</id>
    <content type="html"><![CDATA[<p>惊闻<a href="https://coolshell.cn/haoel">耗子叔</a>突然辞世，悲伤不已。仍活跃在一线的技术大神，前几天仍在社交网络上活跃的大牛，突然就这么走了，犹如一首高亢激昂的交响乐曲，嘎然而止，亦如波涛奔涌的大江，瞬间冰封，不免让人心痛，亦会唏嘘感慨生命的短暂。</p>

<p><a href="http://toughcoder.net/blog/2023/05/16/mourn-mr-hao-chen/"><img src="https://coolshell.cn/wp-content/uploads/2011/03/me.jpg"></a></p>

<!-- more -->


<p>早年就曾关注耗子叔，并成为<a href="https://coolshell.cn/">其博客</a>的忠实读者，但如果非硬要扯上关系，也曾做过同事，2015年初我去了大阿里，彼时耗子叔仍在阿里，记得彼时耗子叔经常分享一些国际巨头（谷歌，亚马逊）的一些高效的工作模式，先进的技术迭代方式，在阿里味引起了不小的反响。</p>

<p>耗子叔是一个技术布道者，对技术有着极度热情和坚定的信仰，写了大量的优质博客，影响了无数人，是很多年轻人的良师益友。他常说的两句话是：学无止境，以及年轻人要多到大平台大公司去开阔眼界。个人最受影响的便是他那篇著名的博客<a href="https://coolshell.cn/articles/4990.html">程序员技术练级攻略</a>，这篇文章的影响力可比肩<a href="https://norvig.com/">Peter Norvig</a>大神的那篇著名的<a href="https://norvig.com/21-days.html">Teach Yourself Programming in Ten Years</a>。</p>

<p>耗子叔起步不高，却大器晚成，是勤奋成材的典范，是学无止境的标兵，坚定的信仰着技术改变世界，并为之奋斗，为技术布道追求极致的工程师文化。相信如果耗子叔起点高一些，或者再多给他一些时间，他的成就会更高，至少能达到巨头公司副总的级别。</p>

<p>现今社会职场压力大，特别是IT行业内卷极其严重，小则996，大则007，耗子叔以及很多嘎然而止的鲜活生命也都在提醒着我们要多多运动，关注身心健康，正所谓前面那个1倒下了，后面再多的0都是徒劳。</p>

<p>愿耗子叔能安息，也愿天堂有纯正的技术氛围和极致的工程师文化。</p>


]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Scoped Storage Puzzles]]></title>
    <link href="http://toughcoder.net/blog/2023/05/03/android-scope-storage-puzzles/"/>
    <updated>2023-05-03T17:58:43+08:00</updated>
    <id>http://toughcoder.net/blog/2023/05/03/android-scope-storage-puzzles</id>
    <content type="html"><![CDATA[<p>安卓对于文件存储这块，其实是相当混乱的，在早期的版本中对存储甚至是没有所谓的管理的，有多种方法可以操作文件存储，比如通过Java原生的方式(File/InputStream/OutputStream)，以及通过ContentProvider的方式(openFile/openOutputStream)。文件的路径也是相当混乱的，有公共存储区域，App的沙盒，外部存储中的App沙盒，但其实整个文件系统中的文件都是可读的，除了系统目录，其他应用的沙盒(内部和外部）以外也都是可写的。这就造成了，安卓的文件系统特别的混乱，加之应用使用不规范，对存储造成极大的滥用，外部存储空间产生大量的垃圾文件，应用卸载后仍然存在，这也催生了一系列的清理软件。</p>

<p><a href="http://toughcoder.net/blog/2023/05/03/android-scope-storage-puzzles/"><img src="https://co-well.vn/wp-content/uploads/2020/05/Android-01-2048x1280.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>但随着用户隐私问题越来越被重视，谷歌也开始收紧了存储权限管理。</p>

<h2>存储权限的变迁史</h2>

<h3>强制动态申请权限</h3>

<p>从Android 6.0（Android M, API 23）开始，存储权限除了在AndroidManifest中静态声明以外，还需要在运行时动态的申请，用户授权了后才可以使用。但这并没有本质的变化，只要用户授权了，就跟以前一样，所有文件可读，大量位置的文件也都可写，App依然可以随便乱搞。</p>

<h3><a href="https://developer.android.com/training/data-storage#scoped-storage">Scoped Storage</a></h3>

<p>后来到了Android 10 (Android Q, API 29)时提出了scoped storage的概念，并把权限进一步的收紧，仅留下几个公共的文件夹可写，其他地方均不可写。并且写媒体文件时(Image/Video/Audio)，要用MediaStore API的方式，直接以Java的文件方式将不再可用。Android 10并未强制开启scoped storage，通过在Manifest中设置requestLegacyStorageManage=true，依然可以像以往那样搞，但到了Android 11时，就强制开启了scoped storage。
<img src="https://koenig-media.raywenderlich.com/uploads/2020/06/PreparingScopedStorage-twitter.png" alt="" /></p>

<h3>强制Score Storage</h3>

<p>到了Android 11(Android R, API 30)时，就强制了，只有应用自己的沙盒可自由读写。创建媒体文件必须 通过MediaStore API。只有少数区域可写（Documents/Downloads/Pictures）等，并且这些区域只有自己创建的文件是可见和可读的。这就导致了，应用能乱搞的区间相当有限了。</p>

<h3>细分文件种类权限</h3>

<p>到了Android 13(Android T, API 33)，更加变态了，把原来的<a href="https://developer.android.com/reference/android/Manifest.permission#WRITE_EXTERNAL_STORAGE">WRITE_EXTERNAL_STORAGE</a>/<a href="https://developer.android.com/reference/android/Manifest.permission#READ_EXTERNAL_STORAGE">READ_EXTERNAL_STORAGE</a>权限细分为对具体文件种类的操作，拆分为Image/Audio/Video三种媒体文件类型的读写。</p>

<p><strong>注意</strong>：只有当targetSdk=33时，并且目标设备是Android 13时，才需要做权限的细分处理。也许后面的版本就会强制了，如果强制那无论taregtSdk是多少都会强制使用细分 权限。</p>

<h2>存储问题的适配</h2>

<p>前面简单的介绍了安卓存储权限的变化过程，重点还是要了解一下如何适配。因为现在已经是2023年了，Android 13(Android T)，API 33也快要普及了，所以就直接总结下现在应该怎么做。</p>

<h3>动态申请存储权限</h3>

<p>对于现在来说，动态申请权限已经是必备的技能之一了，不用多说了。就是先在应用的入口处，或者将要使用存储的地方去申请</p>

<h3>在manifest中声明<a href="https://developer.android.com/reference/android/R.attr#requestLegacyExternalStorage">requestLegacyExternalStorage=true</a></h3>

<h3>用MediaStore API来操作媒体文件(Image/Audio/Video)</h3>

<p>首先要声明具体的权限，然后用<a href="https://developer.android.com/training/data-storage/shared/media">MediaStore API</a>来操作。</p>

<h3>申请另外一个权限MANAGE_EXTERNAL_STORAGE</h3>

<p><strong>注意</strong>: 这个不管你的targetSDK是多少，只要目标运行设备是Android 11，就必须 这样做。</p>

<p>从Android 11开始，要想看到公共区域(Documents/Downloads)中的所有文件，还必须申请另外一个权限<a href="https://developer.android.com/reference/android/Manifest.permission#MANAGE_EXTERNAL_STORAGE">MANAGE_EXTERNAL_STORAGE</a>。因为理论上来说，公共区域你只能看见你自己创建的文件就够了，想看所有文件就越权了。但对于有些应用来说，如文件浏览器，或者请记录阅读器来说，肯定要能看到所有的文件。这个权限需要再次单独申请，用户授权后即可以看到公共区域的所有的文件了。</p>

<p>需要注意，这个权限像常规权限那样去申请是没用的，它的状态永远是denied的，所以，逻辑要这样写：</p>

<ol>
<li>先正常申请存储相关的权限</li>
<li>正常权限有了后，判断Environment.isExternalStorageManager()，如果 是false则需要再次申请另外一个叫做access all files的权限，通过<a href="https://developer.android.com/reference/android/provider/Settings#ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION">ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION</a>或者<a href="https://developer.android.com/reference/android/provider/Settings#ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION">ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION</a></li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>   <span class="c1">// after read/write permission granted</span>
</span><span class='line'>   <span class="k">if</span> <span class="o">(!</span><span class="n">Environment</span><span class="o">.</span><span class="na">isExternalStorageManager</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">requestAllFilesAccess</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>
</span><span class='line'>   <span class="kd">private</span> <span class="kt">void</span> <span class="nf">requestAllFilesAccess</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Intent</span> <span class="n">intent</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Intent</span><span class="o">(</span><span class="n">Settings</span><span class="o">.</span><span class="na">ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION</span><span class="o">);</span>
</span><span class='line'>    <span class="n">intent</span><span class="o">.</span><span class="na">addCategory</span><span class="o">(</span><span class="n">Intent</span><span class="o">.</span><span class="na">CATEGORY_DEFAULT</span><span class="o">);</span>
</span><span class='line'>    <span class="n">Uri</span> <span class="n">uri</span> <span class="o">=</span> <span class="n">Uri</span><span class="o">.</span><span class="na">fromParts</span><span class="o">(</span><span class="s">&quot;package&quot;</span><span class="o">,</span> <span class="n">getPackageName</span><span class="o">(),</span> <span class="kc">null</span><span class="o">);</span>
</span><span class='line'>    <span class="n">intent</span><span class="o">.</span><span class="na">setData</span><span class="o">(</span><span class="n">uri</span><span class="o">);</span>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">startActivity</span><span class="o">(</span><span class="n">intent</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ActivityNotFoundException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Log</span><span class="o">.</span><span class="na">d</span><span class="o">(</span><span class="n">LOG_TAG</span><span class="o">,</span> <span class="s">&quot;Exception: &quot;</span> <span class="o">+</span> <span class="n">e</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意，有可能会有Activity not found exception，注意try-catch下。</p>

<p>因为这个权限又会导致失控，只要申请了就可以在公共区域随意创建文件了，所以谷歌对这个权限管控也是比较严的。虽然你在研发测试阶段可以申请这个权限，但是在发布阶段，要给应用商店一个使用此权限的合理理由，否则Play store会拒绝上线的。</p>

<h3>合理使用公共区域</h3>

<p>作为App，最应该做的就是从业务上区分文件的属性，然后合理的选择存储空间进行存储。对于App本身运行相关的文件，如配置，如算法的模型，如数据库，缓存和日志等等应用本身运行密切相关的文件，一定不可以放在公共区域，一定要放在应用自己的沙盒内（通过<a href="https://developer.android.com/reference/android/content/Context#getFilesDir(">context.getFilesDir</a>), <a href="https://developer.android.com/reference/android/content/Context#getCacheDir(">context.getCacheDir</a>), <a href="https://developer.android.com/reference/android/content/Context#getExternalFilesDir(java.lang.String">context.getExternalFilesDir</a>), <a href="https://developer.android.com/reference/android/content/Context#getExternalCacheDir(">context.getExternalCacheDir</a>), <a href="https://developer.android.com/reference/android/content/Context#openFileOutput(java.lang.String,%20int">context.openFileOutput</a>)）等来读写，应用自己的沙盒也是属于App的自由空间，你可以随意玩。</p>

<p>对于用户生成的文件则要放在公共区域，比如说相机产出的图片和视频，编辑软件产生的文档，这些属于用户生成文件，它的所有权是用户的，可能会通过其他软件再次编辑或者分享，这些肯定要放在公共区域的。对于媒体类Image/Audio/Video则要通过MediaStore API的方式来创建和管理。对于其他文档类型，在获得了WRITE权限 后也可以在（Documents/Downloads）中创建和管理的，绝大多数情况下，这就够了。</p>

<p>总的来说，在用户隐私越来越被重视的今天，安卓现在存储管理策略在保护用户隐私的前提下是能够满足开发者使用的。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://apilevels.com/">Android API Levels</a></li>
<li><a href="https://developer.android.com/guide/topics/providers/document-provider">Open files using storage access framework</a></li>
<li><a href="https://developer.android.com/about/versions/11/privacy/storage">Storage updates in Android 11</a></li>
<li><a href="https://developer.android.com/training/permissions/requesting">Request runtime permissions</a></li>
<li><a href="https://www.geeksforgeeks.org/external-storage-in-android-with-example/">External Storage in Android with Example</a></li>
<li><a href="https://developer.android.com/training/data-storage/manage-all-files">Manage all files on a storage device</a></li>
<li><a href="https://stackoverflow.com/questions/62782648/android-11-scoped-storage-permissions">Android 11 Scoped storage permissions</a></li>
<li><a href="https://ourcodeworld.com/articles/read/1559/how-does-manage-external-storage-permission-work-in-android">How does MANAGE_EXTERNAL_STORAGE permission work in Android?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Kotlin Scope Functions]]></title>
    <link href="http://toughcoder.net/blog/2023/04/12/understanding-kotlin-scope-functions/"/>
    <updated>2023-04-12T15:06:18+08:00</updated>
    <id>http://toughcoder.net/blog/2023/04/12/understanding-kotlin-scope-functions</id>
    <content type="html"><![CDATA[<p>Kotlin是基于JVM衍生出来的新一代通用编程语言，它的目标是简洁，可读和高效，这里的高效并不是代码的运行效率高，而是说项目的开发效率高。Kotlin有太多的小巧的新特性（在Java眼中就是语法糖），比如在Kotlin中有几个作用和用法都非常接近的函数apply/with/run/let/also，它们的正统名字是<strong>作用域函数</strong>(Scope functions)，今天就来学习一下这些函数的使用方法和具体区别。</p>

<p><a href="http://toughcoder.net/blog/2023/04/12/understanding-kotlin-scope-functions/"><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.eDXYmyuQp-E1wGqx4WnhIgHaEK?pid=ImgDet&rs=1" title="auto auto" ></a></p>

<!-- more -->


<p>Java是面向对象的王牌语言，它的特点是严谨和教条，Java写出来的代码学过Java的人大多都看得懂，所以规模以上的项目现在基本上都用Java，这对维护是有好处的。但Kotlin不一样，它有非常多的特性，融合了众多编程语言的特点，同样一件事情，可能有无数种写法，虽然号称是用标准Kotlin语言实现的，但是即使学过Kotin的人也看不懂。比如虽然你学会了Function，Object和lambda，以及像inline function和extension，但是如果用apply和with写几段方法，你就看不懂了，这就导致了Kotlin虽然易于上手，但是要想学透和提高曲线 就会陡峭许多。</p>

<p><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.pVewkBVy74Ivnoumj0Gx0wHaF8?pid=ImgDet&amp;rs=1" alt="" /></p>

<h2>到底是个啥</h2>

<p>先来看一下Scope function到底是什么，它们的作用是在一个对象上执行一段代码，我们来看一个简单的例子：有一个类是Person，它有一些属性和方法，我们想对它的一个对象进行操作，通常会这样做：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">alice</span> <span class="p">=</span> <span class="n">Person</span><span class="p">(</span><span class="n">name</span><span class="p">=</span><span class="s">&quot;Alice&quot;</span><span class="p">,</span> <span class="n">age</span><span class="p">=</span><span class="m">20</span><span class="p">,</span><span class="n">addr</span><span class="p">=</span><span class="s">&quot;Amsterdam&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="n">alice</span><span class="p">)</span>
</span><span class='line'><span class="n">alice</span><span class="p">.</span><span class="n">moveTo</span><span class="p">(</span><span class="s">&quot;London&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">alice</span><span class="p">.</span><span class="n">incrementAge</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;Two years later ${alice.name} is at ${alice.addr}&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>但使用scope function，我们可以这样做：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">alice</span> <span class="p">=</span> <span class="n">Person</span><span class="p">(</span><span class="s">&quot;Alice&quot;</span><span class="p">,</span> <span class="m">20</span><span class="p">,</span> <span class="s">&quot;Amsterdam&quot;</span><span class="p">).</span><span class="n">apply</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">println</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
</span><span class='line'>  <span class="n">moveTo</span><span class="p">(</span><span class="s">&quot;London&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="n">incrementAge</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;Two years later ${alice.name} is at ${alice.addr}&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//Person(name=&#39;Alice&#39;, age=20, addr=&#39;Amsterdam&#39;)</span>
</span><span class='line'><span class="c1">//Two years later Alice is at London</span>
</span></code></pre></td></tr></table></div></figure>


<p>这两段代码的输出是完全一样的，但是第二段明显要简洁很多这就是scope function的作用，仔细看apply后面的lambda块，它是一个scope，犹如在对象的类定义之中，在这个代码块中可以直接引用对象的方法，而不是像常规的那样使用对象的引用。</p>

<p><em>注意</em>：如果不是很尾部lambda的同学可以先行参考<a href="http://toughcoder.net/blog/2023/01/24/understanding-kotlin-functions/">另外一篇文章</a>，以加强理解。</p>

<h2>理解Scope</h2>

<p>作用域也可以理解为一个代码块的上下文，也就是说在一个代码中，可以直接使用的东西，环境变量之于进程，系统框架为应用准备的基础对象，都可以视为一种scope。最为明显的就是类的定义，在类中，我们可以引用this指针来代表当前对象super指针来代表基类，这也是一种scope。lambda捕获的闭包也是一种scope。</p>

<p>Kotlin的scope functions就是把某一个对象当作代码块的scope，代码块中的代码可以方便的使用这个对象。</p>

<h2>Scope funtions的作用</h2>

<p>如同开头讨论的，能用scope function写出来的东西，用常规方式也一样可以做到，那到底图个啥呢？用scope function的方式代码变得更加的简洁和紧凑，我们把针对某一对象的密集操作集中在一起放入一个代码块中，会更加的内聚和紧凑，易于扩展和维护。但也要注意不能滥用，代码块中只应该写与对象相关的操作，与scope对象不相干的事情是绝对不应该放入其中的。</p>

<h2>Scope functions</h2>

<p>主要有6个，它们的应用主体都是一个对象，也就是要在一个对象上面调用这些函数，然后提供一个代码块（lambda）：</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> Scope Function </th>
<th style="text-align:center;"> Object reference </th>
<th style="text-align:center;"> Return value </th>
<th style="text-align:center;"> Description </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> let </td>
<td style="text-align:center;"> it </td>
<td style="text-align:center;"> lambda result </td>
<td style="text-align:center;"> Extension function </td>
</tr>
<tr>
<td style="text-align:center;"> run </td>
<td style="text-align:center;"> this </td>
<td style="text-align:center;"> lambda result </td>
<td style="text-align:center;"> Extension function </td>
</tr>
<tr>
<td style="text-align:center;"> run </td>
<td style="text-align:center;"> _ </td>
<td style="text-align:center;"> lambda result </td>
<td style="text-align:center;"> No object in the scope </td>
</tr>
<tr>
<td style="text-align:center;"> with </td>
<td style="text-align:center;"> this </td>
<td style="text-align:center;"> lambda result </td>
<td style="text-align:center;"> Take the object as an argument </td>
</tr>
<tr>
<td style="text-align:center;"> apply </td>
<td style="text-align:center;"> this </td>
<td style="text-align:center;"> context object </td>
<td style="text-align:center;"> Extension function </td>
</tr>
<tr>
<td style="text-align:center;"> also </td>
<td style="text-align:center;"> it </td>
<td style="text-align:center;"> context object </td>
<td style="text-align:center;"> Extension function </td>
</tr>
</tbody>
</table>


<h2>它们的区别和如何选用</h2>

<h3>with不是一个extension函数</h3>

<p>其他几个都是extension函数，所以with一定要把scope object作为参数传入。</p>

<h3>scope对象的引用方式</h3>

<p>对于scope function来说scope对象都会作为一个context object，可以在lambda块中使用，有些是作为this指针，有些是作为lambda的默认参数名字也即it指针，但它们都指向context object，本质上是没有区别的只是指针的名字一个是this一个是it。但是，跟类的定义scope是一样的，this指针是可以省略的，但如果it作为参数，则是不能省略的，具体来说，比如说，用apply时，代码块中是this指针，那么可以直接这样写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">alice</span> <span class="p">=</span> <span class="n">Person</span><span class="p">(</span><span class="s">&quot;Alice&quot;</span><span class="p">,</span> <span class="m">20</span><span class="p">,</span> <span class="s">&quot;Amsterdam&quot;</span><span class="p">).</span><span class="n">apply</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">println</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
</span><span class='line'>  <span class="n">moveTo</span><span class="p">(</span><span class="s">&quot;London&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="n">incrementAge</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然 你也可以显式的把this写出来，this.moveTo(&ldquo;London&rdquo;)，但这就麻烦多了，何必呢。所以apply最合适的场景是对对象本身的操作，如赋值和修改属性。</p>

<p>但如果是用also，就必须用it了，这个不能省，因为它是对scope对象的引用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="n">alice</span><span class="p">.</span><span class="n">also</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">println</span><span class="p">(</span><span class="s">&quot;Two years later ${it.name} is at ${it.addr}&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>所以，also最适合的不是对对象本身的操作，而是一些与对象相关的副作用，如打印日志等。</p>

<h3>返回值不同</h3>

<p>这坨Scope functions是一个函数，它是有返回值的，这个返回是不一样的，apply/also返回的是context object，其他几个则是返回lambda中的返回值也就是lambda的最后一个表达 式或者lambda中显式的return语句。</p>

<p>所以，如果是想继续使用scope object，那么就要用apply/also，如果想得到某个其他值就要用let/run/with，即使说不在乎函数的返回值时，这时也推荐使用also，因为假如后续想继续添加其他操作时，可以直接在后面链接上其他的scope function。其他返回值的let/run/with一般用在一组操作的确定性的终点上面，比如统计均值，那最后的均值计算可以用run，比如文件操作，读写都可以用with。</p>

<h2>注意事项</h2>

<p>任何技术和工具要深刻理解它们的应用范围和使用场景以避免滥用，要用到恰到好处才能发挥最大的价值。对于一些非必须的东西，更是如此。</p>

<p>Scope functions是应用于对象上面的，所以前提是当你需要对一个对象进行一些操作时，才可以使用scope functions，具体选择哪一个参考 上面一节的讨论。另外，就是放入代码块中的操作必须全部是scope对象相关的才可以。一个scope function中只能是一组相关的操作，不同组的操作要启用不同的scope functions。比如说网络请求response的处理，可以分为服务器状态码和返回实体的检测，转成具体数据，打印日志这么三个scope functions，而不是全放进一个里面。</p>

<p>总而言之，要视具体的需求和场景，并基于场景选择合适的scope function，切忌过度使用。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/scope-functions.html">Scope functions</a></li>
<li><a href="https://blog.mindorks.com/using-scoped-functions-in-kotlin-let-run-with-also-apply/">Using Scoped Functions in Kotlin - let, run, with, also, apply</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/kotlin-let-run-also-apply-with">Kotlin let, run, also, apply, with</a></li>
<li><a href="https://shusheng007.top/2020/10/02/1-6/">秒懂Kotlin之彻底掌握Scope Functions (apply, also,let,run,with)</a></li>
<li><a href="https://www.jianshu.com/p/5c4a954d2b2c">Kotlin之let,apply,run,with等函数区别</a></li>
<li><a href="https://juejin.cn/post/6868179386344931342">Kotlin学习：run、with、apply、also、let的区别</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[String Problems Archive]]></title>
    <link href="http://toughcoder.net/blog/2023/03/19/string-problem-archive/"/>
    <updated>2023-03-19T10:24:09+08:00</updated>
    <id>http://toughcoder.net/blog/2023/03/19/string-problem-archive</id>
    <content type="html"><![CDATA[<p>字符串即由字符组成的线性数组结构，可以理解为字符数组或者字符列表，但元素的集合是有限集合，通常是英文字符，数字和算术运算符号。可以说数组和列表的常见问题和技巧都可以应用于字符串，但因为是有限集合，所以又有一些独特的问题和技巧，今天就来总结一下。</p>

<p><a href="http://toughcoder.net/blog/2023/03/19/string-problem-archive/"><img src="https://cdn.programiz.com/sites/tutorial2program/files/c-strings.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>编程技巧</h2>

<h3>转成字符数组来遍历</h3>

<p>对于Java语言来说charAt(i)非常的慢，所以如果需要多次遍历，或者多次获利某个索引位置的字符，最好先转成字符数组toCharArray()，这样效率会高出很多。对于其他语言像Python3和Kotlin则没必要，因为本来就可以像常规数组(列表)一样遍历。</p>

<h3>用桶代替哈希表</h3>

<p>字符串的每个元素是有限集合，所以要尽可能的用桶来代替哈希表，每当需要对字符计数，或者做映射的时候，都可以先尝试用桶。
比如小写英文字母，就可以用一个长度为26的整数数组来计数，字符与索引的转化关系是ch-&lsquo;a&#8217;，同理可以扩展到大写ch-&#8216;A&#8217;，甚至数字字符ch-&#8216;0&#8217;。</p>

<h3>字符与索引相互转化</h3>

<p>前面提到了用桶，就是把字符转化为索引。反过来也是可行的。目标字符ch = (char) (i + &lsquo;a&rsquo;)就把索引转为小写，大写和数字字符也是同理的。</p>

<h4>Java/C/C++</h4>

<p>传统语言里面char相当于无符号整数，所以可以直接强行互转：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="kt">char</span> <span class="n">ch</span> <span class="o">=</span> <span class="o">(</span><span class="kt">char</span><span class="o">)</span> <span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="sc">&#39;a&#39;</span><span class="o">);</span>
</span><span class='line'><span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">ch</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Python3</h4>

<p>大Python3中要用ord()和chr()来进行字符到整数的互转</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='Python3'><span class='line'><span class="n">idx</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">ch</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="nb">ord</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Kotlin</h4>

<p>因为Kotlin中没有所谓的基础类型，都是对象，所以就用对象提供的方法即可。字符转为整数用Char.code，要把数字字符转为对应字面的整数用Char.digitToInt，如:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">ch</span><span class="p">:</span> <span class="n">Char</span> <span class="p">=</span> <span class="sc">&#39;3&#39;</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;ch as int ${ch.code}, ch digit as int ${ch.digitToInt()}&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// ch as int 51, ch digit as int 3</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果是想转成其他进制的整数，可以传入基数作为参数，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">hexCh</span> <span class="p">=</span> <span class="sc">&#39;F&#39;</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;hex ch ${hexCh.digitToInt(16)}&quot;</span><span class="p">)</span> <span class="c1">// 15</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为是基于JVM的，所以字符也可以用于计算，比如idx = ch - &lsquo;a&#8217;，这是完全没有问题的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">a</span> <span class="p">=</span> <span class="sc">&#39;a&#39;</span>
</span><span class='line'><span class="k">var</span> <span class="py">idx</span> <span class="p">=</span> <span class="sc">&#39;d&#39;</span> <span class="p">-</span> <span class="n">a</span>
</span><span class='line'><span class="k">val</span> <span class="py">aidx</span> <span class="p">=</span> <span class="n">idx</span> <span class="p">+</span> <span class="m">7</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;idx $idx, aidx to ch ${(aidx + &#39;a&#39;.code).toChar()}&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">//idx 3, aidx to ch k</span>
</span></code></pre></td></tr></table></div></figure>


<p>反过来，整数转到字符，用Int.toChar()就可以了，会按ASCII的code值去转。另外，如果想转成数字字符用Character.forDigit(ch, radix):</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">d</span> <span class="p">=</span> <span class="m">8</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot; int to char ${d.toChar()}, to digit char ${Character.forDigit(d, 10)}&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>字符数组/列表转为String</h3>

<p>涉及字符的题目，一般需要转成字符数组处理后，再把字符数组转成字符串。</p>

<p>对于Java来说，String的构造方法支持传入char[]作为参数。</p>

<p>而Python3，其实就是字符列表转为字串，可以用join方法，这个方法是str提供的方法，用一个str当作分隔符来把一个列表连接起来：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='Python3'><span class='line'><span class="n">chars</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;H&#39;</span><span class="p">,</span> <span class="s">&#39;e&#39;</span><span class="p">,</span> <span class="s">&#39;l&#39;</span><span class="p">,</span> <span class="s">&#39;l&#39;</span><span class="p">,</span> <span class="s">&#39;o&#39;</span><span class="p">]</span>
</span><span class='line'><span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span> <span class="c"># &quot;Hello&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>同样，Kotlin中也有joinToString方法，它对数组和列表都支持，可以传入一个参数作为分隔符：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">chars</span> <span class="p">=</span> <span class="n">charArrayOf</span><span class="p">(</span><span class="sc">&#39;H&#39;</span><span class="p">,</span> <span class="sc">&#39;e&#39;</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span><span class="p">,</span> <span class="sc">&#39;l&#39;</span><span class="p">,</span> <span class="sc">&#39;o&#39;</span><span class="p">)</span>
</span><span class='line'><span class="k">val</span> <span class="py">res</span> <span class="p">=</span> <span class="n">chars</span><span class="p">.</span><span class="n">joinToString</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>压缩到位运算</h3>

<p>如果字符集合特别有限，比如只有有限几个字符，或者只有小写，只有大写，这时可以更进一步的，用位运算来进行优化。小写字符只有26个，一个整数有32位可以用，完全够用。</p>

<p>当满足以下两个条件时就可以考虑用位运算来优化：仅涉及两个状态，有和没有；另外就是字符或者组合后的集合范围在32个以内。</p>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sort-characters-by-frequency/">451. 根据字符出现频率排序</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sort-characters-by-frequency/solution/451-gen-ju-zi-fu-chu-xian-pin-lu-pai-xu-01mur/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>变位词</h2>

<p>变位词是指对于一个字符串，把某几个字符位置换一下之后得到的字符串，与原串互为变位词。其实变位词不局限于字符串，对于任何一个线性列表来说，把某几个元素位置变一下就是互为变位词了。变位词有两大特点：字符集合是一样的，种类一样，频次也一样，但排列不一样。</p>

<p>基于它的特点，涉及变位词的问题，就变成了字符频次统计的问题了，如果两个字符串的字符频次一样，那么就互为变位词。另外的处理方式就是排序，因为只是排列不一样，所以按照同一规则排序后，两字符串就相同了，那么通过排序 来验证也可以可行的。具体处理时，要依据不同的条件来灵活选择具体的识别方式。</p>

<p>需要注意的是，当用频次统计法时，记得用桶而不是直接用哈希表。</p>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/group-anagrams/solution/49-zi-mu-yi-wei-ci-fen-zu-by-alexhilton-ni22/">题解</a> </td>
<td style="text-align:left;"> 排序法 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>回文</h2>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-palindromic-substring/solution/">5. 最长回文子串</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-palindromic-substring/solution/5-zui-chang-hui-wen-zi-chuan-by-alexhilt-6kvt/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>状态压缩</h2>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/repeated-dna-sequences/solution/187-zhong-fu-de-dnaxu-lie-by-alexhilton-5or9/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>其他</h2>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基础利器之Stack和Queue]]></title>
    <link href="http://toughcoder.net/blog/2023/03/05/stack-and-queue/"/>
    <updated>2023-03-05T10:11:21+08:00</updated>
    <id>http://toughcoder.net/blog/2023/03/05/stack-and-queue</id>
    <content type="html"><![CDATA[<p>在基础的数据结构中栈和队列使用极其广泛，其用法也很多，今天就来总结一下栈和队列的使用方法和相关的题目。</p>

<p><a href="http://toughcoder.net/blog/2023/03/05/stack-and-queue/"><img src="https://i0.wp.com/www.dineshonjava.com/wp-content/uploads/2017/01/stack-queue.png?fit=523%2C228&ssl=1" title="auto auto" ></a></p>

<!-- more -->


<h2>队列Queue</h2>

<p><img src="https://www.wisdomjobs.com/tutorials/representation-of-a-fifo-queue.png" alt="" /></p>

<h3>基本概念</h3>

<p>队列是一个线性数据 结构，特点是先入先出，也就是能保证先入队的元素先出队，也即FIFO First In First Out。与现实生活中的排队是一样的。</p>

<h3>基础应用</h3>

<p>应用很广泛，像消息队列，任务队列，以及像滑动窗口。</p>

<h4>典型题目</h4>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/qIsx9U/">剑指 Offer II 041. 滑动窗口的平均值</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/qIsx9U/solution/by-alexhilton-1c5a/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-circular-queue/">622. 设计循环队列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-circular-queue/solution/622-she-ji-xun-huan-dui-lie-by-alexhilto-adr5/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h3>中级应用</h3>

<p>BFS要用到队列。</p>

<p>BFS可以<a href="http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy/">参考另外一个文章</a>。</p>

<h4>典型题目</h4>

<h3>高级应用</h3>

<p>单调队列，队列中的元素以非递增顺序或者非递减顺序排列。</p>

<p>单调队列<a href="http://toughcoder.net/blog/2022/08/15/secret-weapon-monotonic-stack/">参见另外一个文章</a>。</p>

<h2>栈Stack</h2>

<p><img src="https://holycoders.com/content/images/2020/06/Stack.png" alt="" /></p>

<h3>基本概念</h3>

<p>也是一个线性结构，与队列类似，但它是先入后出，或者说后入先出，FILO First In Last Out。现实生活中也有，比如像盘子，通常是叠在一起的，这就是一个栈，一个一个叠 在一起，最后放上去的，最先拿下来用。</p>

<h3>基础应用</h3>

<p>程序运行时会用到栈，函数的调用会用到栈。还有一些模拟的场景也会用到栈，比如像处理括号和表达式一类的问题时。</p>

<h4>典型题目</h4>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/valid-parentheses/solution/by-alexhilton-8tcu/">题解</a> </td>
<td style="text-align:left;"> 栈模拟 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/min-stack/solution/by-alexhilton-20au/">题解</a> </td>
<td style="text-align:left;"> 栈模拟 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/asteroid-collision/">735. 行星碰撞</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/asteroid-collision/solution/by-alexhilton-87ks/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-frequency-stack/">895. 最大频率栈</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-frequency-stack/solution/by-alexhilton-xdq9/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/validate-stack-sequences/">946. 验证栈序列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/validate-stack-sequences/solution/946-yan-zheng-zhan-xu-lie-by-alexhilton-cjjq/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/build-an-array-with-stack-operations/">1441. 用栈操作构建数组</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/build-an-array-with-stack-operations/solution/1441-yong-zhan-cao-zuo-gou-jian-shu-zu-b-sw1y/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h3>中级应用</h3>

<p>DFS需要用到栈.</p>

<p>DFS可以<a href="http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy/">参考另外一个文章</a>。</p>

<h3>高级应用</h3>

<p>单调栈<a href="http://toughcoder.net/blog/2022/08/15/secret-weapon-monotonic-stack/">参见另外一个文章</a>。</p>

<h2>双端队列Deque</h2>

<p>双端队列Deque读作dek，是两端都可以入队和出队，因此它即可以用作栈也可以用作队列，在实际使用中是最多的，大多数时候都尽可能用双端队列。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Table Tennis Road Map]]></title>
    <link href="http://toughcoder.net/blog/2023/02/22/table-tennis-road-map/"/>
    <updated>2023-02-22T21:28:33+08:00</updated>
    <id>http://toughcoder.net/blog/2023/02/22/table-tennis-road-map</id>
    <content type="html"><![CDATA[<p>乒乓球可以锻炼反应能力，运动量适中，场地要求不高，能放下球台就能玩，人数要求也不高，二个人就能玩，所以非常适合中老年人，打了一段时间感觉良好，但乱打还是不行的，需要好好入门，然后再慢慢提高。</p>

<p><a href="http://toughcoder.net/blog/2023/02/22/table-tennis-road-map/"><img src="https://www.athens2020.org/sites/default/files/styles/fullhd/public/disciplines-table-tennis.jpg?itok=tgR2uDF5" title="auto auto" ></a></p>

<!-- more -->


<p>注意，所有的动作均以右手横板为基准，因为尝试了各种手法，横板是最为舒服的，因此决定用横板。</p>

<h2>乒乓球核心要点</h2>

<p>其实乒乓球不难，但基础的东西一定要对，否则会养成不好的习惯，而一旦形成习惯了就很难改，所以从最开始，基本的动作都要按照 标准的来，打下良好的基础后，后续提高才会更顺利。</p>

<h3>放松，舒服</h3>

<p>运动一定是符合身体的自然规律的，所以一定要做到放松和舒服，凡是不舒服不放松就违被了自然规律，就一定是错的，不但效果不好，而且会去身体造成伤害。</p>

<p>比如站位，是又脚自然分开，一前一后，在中间偏左一点（惯用右手，横板），身体略向前。肩要放松，手腕肘都要放松，千万不能端着肩，提着肘，或者全身都绷的很紧，这是错误的。运动的规律都是在发力（击球时）的时候，是紧的，是端的，但绝大部分时间都是要自然放松，所有运动都是如此。</p>

<p>引拍，挥拍也要适度，让肘和手以身体为轴心自然的去旋转，而不要过度的引后（向后甩的太远），过度的挥拍（向前挥的太远）这都是不对的。</p>

<p>包括握拍，也要松紧适度，不用太紧的捏着，只有击球时需要握紧，不然容易飞出去，其余大部分时间，都是拿住拍子即可，只要拍不从手上掉下来即可，不用太紧，要放松，要自然。</p>

<p>时刻想着自然和舒服，始终处于一种自然和放松的状态。</p>

<h3>以身体为轴，用腰转动发力</h3>

<p>乒乓球的主要动作引拍和挥拍，都是以身体为轴，通过转动腰来进行，手腕，肘和肩都是不动的。向后转身，即是引拍，向前转身即是挥拍。</p>

<p>要仔细体会这个要领，用腰的转动来实现引拍和挥拍，身体的各个部位都没有位移，只有转动。</p>

<h3>重心轮换</h3>

<p>两脚 自然分开，略比肩宽，一前一后，重心随着身体的转动而不停在两脚 之间切换。正常时重心在左脚上，引拍时，向后转动，重心到了右脚上，向前转身，挥拍击球，重心又回到左脚 上，然后再向后转心，还原动作。</p>

<h3>还原动作，专注于球，提前调整位置</h3>

<p>击球后，要立刻还原动作，然后专注于球，预判球的方位，远近，然后调整位置，同时引拍，准备击球。</p>

<h2>具体技术要点</h2>

<ol>
<li>站位，站在中线的左边，身体不能超过中线</li>
<li>左脚在前，右脚 在后，重心在左脚上，两脚略比肩宽，身体略前倾</li>
<li>肩放松，肘放松，腕放松，手放松，不能端着，不能紧绷着，要放松</li>
<li>不要抬肘，一定不能抬肘，要自然放松</li>
<li>拍子，腕，肘要成一个直线，拍了向前斜，与台面约45度角</li>
<li>球在身体右边，用正手攻球，就是向右后转身，引拍，击球，然后还原</li>
<li>球在身体左边，用反手攻球，向左后转身，引拍，击求，然后还原</li>
<li>想要击球有力度，就引拍幅度大一些，力量靠身休转动的角度发出来的，而不是肘或者手腕（身体是轴心，手臂是半径，转动角度越大，产生的力矩就越大）</li>
<li>拍子要始终与台面形成斜角，这样击球才会有旋转，并且球会速度快且向下飞，而不是速度慢向上飞（那就被挑起来了，会被对方狠拍杀死），球要越旋越好，越低越好，越快越好。所以，拍子要压低与台面的斜角，角度越小越好。</li>
</ol>


<p><img src="https://so1.360tres.com/t014e6a3a2efc70251f.jpg" alt="" />
所以，总结 起来，其实乒乓球就两个主要动作，向右后转身，然后还原（正手攻球）；向左后转身，然后还原（反手攻球），不打球时，也可以练习这些基本动作。
<img src="https://file.zhibo.tv/uploads/imgs/2021/06-07/1623061996619420_2606x1817.jpg" alt="" /></p>

<h2>四大打法</h2>

<h3>抽</h3>

<p>拍子向前斜，与台面呈斜角，从下向上击球，这是抽，正手攻球，反手基本都是抽。引拍幅度要大一些，球拍角度要圧低一些，这样回球力度大，速度快，旋转好，高度低。打出来的都是上旋球。</p>

<p>适合长球，球在台面外，球下落时，从下向上抽。</p>

<h3>推</h3>

<p>拍子，稍向前斜，比抽时斜角要大，几乎快直立。拍子不动，手腕不动，是整个手臂（肘，腕和拍）整体向前推，推的过程中拍子腕和肘仍呈直线，相对位置不变，是整体向前推。</p>

<p>适合，反手时，球比较高，球在台面上，球速也不快时，把球推回对方。当然 也有快推和慢推，但整体差别不大，打出来的球也基本没旋转，球速也不快，也很高。很容易被对方直接快速抽回来。</p>

<h3>削</h3>

<p>拍向后斜，从上向下击球，这是削。打出来的是下旋球
<img src="https://www.ttline.cn/uploadfile/ueditor/image/2022/02/4085168991547474880.jpg" alt="" />
适合球比较高时，在台面上，或者在台面外都可以，但一定要比较高。</p>

<h3>搓</h3>

<p>拍子向下斜，与台面的斜角是负的，基本是直着向前搓球。</p>

<p><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.-yw5SLZUxW0Tgg88poSb-QHaE8?pid=ImgDet&amp;rs=1" alt="" /></p>

<p>适合台内的短球。搓出来的也是下旋球。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to Android Jetpack]]></title>
    <link href="http://toughcoder.net/blog/2023/02/15/introduction-to-android-jetpack/"/>
    <updated>2023-02-15T15:31:39+08:00</updated>
    <id>http://toughcoder.net/blog/2023/02/15/introduction-to-android-jetpack</id>
    <content type="html"><![CDATA[<p><a href="https://developer.android.com/jetpack">Android Jetpack</a>是一个由谷歌官方提供的安卓开发套件（套件是一组组件的意思），目的是帮助安卓开发者解决兼容性问题，减少重复代码，提升体验和性能，最重要的是提升开发效率。安卓以碎片化著名，不同的版本，不同的OEM厂商导致整个安卓设备碎片化严重，对App生态来说是很不友好，加之安卓本身的原因导致像流畅度，体验和性能始终逊水果不止一筹。后来谷歌推出一系列的Android SDK之外的一系列开发组件如<a href="https://developer.android.com/topic/libraries/support-library">support library</a>来解决兼容性(App compat)和新的开发组件(RecyclerView, CardView, Pager等)，后来这些东西就演变成了现在的Android Jetpack。</p>

<p><a href="http://toughcoder.net/blog/2023/02/15/introduction-to-android-jetpack/"><img src="https://mobikul.com/wp-content/uploads/2020/07/navigation.png" title="auto auto" ></a></p>

<!-- more -->


<h2>缘起</h2>

<p>最开始是一坨support library，有v4有v7还有v13，它们是针对 不同的SDK版本使用的不同的兼容性组件。后来到了2017年的Google I/O，又推出了一系列叫做Android Architecture Components，然后到了2018年的Google I/O大会，把所有这一坨融合了在一起，进行了大统一，起了个新名字叫做Android Jetpack，各个组件包名统一为androidx.&#42;。这便是Android Jetpack的由来。</p>

<p>之后2019年Google I/O，已经初具格局，之后Android Jetpack就定型了，不断的向前演进，更新的频次也很快，每当有的新的技术，新的编程范式都会有所呈现，甚至有点超过Android SDK本身了。Android SDK与安卓本身是绑定在一起的，受制于底层SoC的发展，因为它毕竟是一个操作系统。但Android Jetpack却不一样，它是纯的三方软件，可以以相当快的速度在迭代，软件开发最前沿的东西都能快速得到尝试，只要它符合Android Jetpack本身的定位，会很快被纳入其中。</p>

<h2>Android Jetpack到底是个啥</h2>

<p>前面说了好多废话，下面来看一下Android Jetpack到底是个啥，它就是一套软件开发组件，由谷歌官方提供，能解决Android App开发中的比较蛋疼的问题（如兼容性和碎片化），并有很多能提升体验，提升性能提升效率的组件。</p>

<p>它提供了四大技术组件：</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 技术方向 </th>
<th style="text-align:left;"> 组件 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> Foundation components </td>
<td style="text-align:left;"> <a href="https://developer.android.com/jetpack/androidx/releases/appcompat">App compat</a><br/>Multidex<br/><a href="https://developer.android.com/training/testing/">Test</a><br/><a href="https://developer.android.com/kotlin/ktx">Android KTX</a> </td>
<td style="text-align:left;"> 兼容性组件<br/>测试框架<br/>Kotlin支持 </td>
</tr>
<tr>
<td style="text-align:left;"> Architecture components </td>
<td style="text-align:left;"> <a href="https://developer.android.com/topic/libraries/data-binding/">Data binding 优雅的把数据绑定到View上，省去findView and setText</a><br/><a href="https://developer.android.com/topic/libraries/architecture/lifecycle">Lifecycles 感知系统框架(Activity/Fragment)的生命周期</a><br/><a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData 监听数据变化且能感知生命周期</a><br/><a href="https://developer.android.com/guide/navigation">Navigation 内部页面跳转</a><br/><a href="https://developer.android.com/topic/libraries/architecture/paging/v3-overview">Paging 分页</a><br/><a href="https://developer.android.com/training/data-storage/room">Room 数据库封装</a><br/><a href="https://developer.android.com/topic/libraries/architecture/viewmodel">ViewModel MVVM式架构</a><br/><a href="https://developer.android.com/topic/libraries/architecture/workmanager/">WorkManager 耗时后台任务或者定时后台任务</a> </td>
<td style="text-align:left;"> 在架构层面能起到作用的组件<br/>增强模块化，可测试性和可维护性 </td>
</tr>
<tr>
<td style="text-align:left;"> Behavior components </td>
<td style="text-align:left;"> <a href="https://developer.android.com/training/camerax">CameraX</a><br/><a href="https://developer.android.com/develop/ui/views/components/settings">Preference</a><br/> </td>
<td style="text-align:left;"> 更好的与Android系统进行交互 </td>
</tr>
<tr>
<td style="text-align:left;"> UI components </td>
<td style="text-align:left;"> <a href="https://developer.android.com/develop/ui/views/animations">Animations and Transitions</a><br/><a href="https://developer.android.com/develop/ui/views/text-and-emoji/emoji-compat">Emoji</a><br/><a href="https://developer.android.com/guide/fragments">Fragments</a><br/><a href="https://developer.android.com/develop/ui/views/graphics/palette-colors">Palette 调色板</a><br/><a href="https://developer.android.com/develop/ui/views/layout/declaring-layout">Layouts</a> </td>
<td style="text-align:left;"> 更丰富更强大的UI部件，<br/>体验好，兼容性好，易于使用 </td>
</tr>
</tbody>
</table>


<h2>为何要用它</h2>

<p>自从2019年起统一成了Android Jetpack后，它相较之前分散的support library在整个生态中的地位不一样了，现基本上与Android SDK有着同等的重要性，甚至很多东西都会优先被放到Jetpack里面。</p>

<p>毕竟它是由谷歌官方主推的东西，是由正统的Android专家写出来的，质量是有保证的。并且现在它的迭代速度也很快，生态上已形成闭环，如果能解决项目上的问题，当然首选Android Jetpack。</p>

<h2>Jetpack Compose又是个啥</h2>

<p>在2019年的Google I/O与Jetpack一起发布的还有一个叫做<a href="https://developer.android.com/jetpack/compose">Compose</a>的东西，它是一个符合<a href="https://m3.material.io/develop/android/jetpack-compose">Material Design</a>的全新的写UI的方式，基于Kotlin语言。
需要注意的是Compose是一种构建原生UI的方式，它用Kotlin DSL的方式来构建 UI，而不是原始的View和XML，它有点类似于早先的anko。</p>

<p>需要特别注意的是，它并不像Android Jetpack那样是一种三方组件，而是一种构建原生UI的方式，它的野心也比较大，并不局限于构建Android UI，现在也支持构建 Desktop UI了，重点理解它是一种构建UI界面的工具，至于底下的平台可以适配到任何平台。结合Kotlin，Kotlin也在做<a href="https://kotlinlang.org/docs/multiplatform-mobile-getting-started.html">KMM Kotlin Multiplatform Mobile</a>，也即跨平台的Kotlin，以后的Compose可以生成任何平台的目标文件。</p>

<p>所以，学习Compose的曲线就要比Jetpack要陡峭得多了，因为Jetpack其实就是额外的一些三方组件，但Compose是一种全新的构建UI的方式，需要系统的学习才能掌握它。并且除非你从头搭建app，否则Compose很难与现有的UI构建方式(View和XML)融合在一起。其实这种东西并不新鲜，从<a href="https://reactnative.dev/">React Native</a>到<a href="https://flutter.dev/">Flutter</a>都是这种可以构建跨平台UI的工具(虽然RN和Flutter并不仅仅是UI，它们号称跨平台构建App，UI是跨平台最大的挑战，因为每个平台的原生UI构建方式都不一样，非UI部分，做一层API的桥接就可以做到)。</p>

<p>而且感觉Compose想要挑战RN和Flutter难度也不小，因为RN和Flutter出生就是为了跨平台开发，而Compose是生于安卓UI，它们的出发点的高度并不一样，是因为有了Kotlin KMM的支持，所以有想跨平台的野心。其实Compose是被<a href="https://developer.apple.com/cn/xcode/swiftui/">水果Swift UI</a>逼出来的，所以它的定位与Swift UI是一样的。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://blog.mindorks.com/what-is-android-jetpack-and-why-should-we-use-it/">What is Android Jetpack and why should we use it?</a></li>
<li><a href="https://stackoverflow.com/questions/50251658/what-exactly-is-android-jetpack">What exactly is Android Jetpack?</a></li>
<li><a href="https://www.geeksforgeeks.org/foundation-components-of-android-jetpack/?ref=lbp">Foundation Components of Android Jetpack</a></li>
<li><a href="https://www.geeksforgeeks.org/jetpack-architecture-components-in-android/?ref=lbp">Jetpack Architecture Components in Android</a></li>
<li><a href="https://www.geeksforgeeks.org/behaviour-components-of-android-jetpack/?ref=lbp">Behaviour Components of Android Jetpack</a></li>
<li><a href="https://www.geeksforgeeks.org/ui-components-of-android-jetpack/?ref=lbp">UI Components of Android Jetpack</a></li>
<li><a href="https://developer.android.com/modern-android-development">Modern Android Development</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Kotlin Based DSL]]></title>
    <link href="http://toughcoder.net/blog/2023/02/14/understanding-kotlin-based-dsl/"/>
    <updated>2023-02-14T16:51:58+08:00</updated>
    <id>http://toughcoder.net/blog/2023/02/14/understanding-kotlin-based-dsl</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL Domain Specific Langauge</a>是解决特定领域内问题的编程语言，它的特点通常是简洁，虽不通用，但可读性强，呈描述式和声明式，比较典型的例子就是SQL语句和正则表达式，以及一些文本处理工具如Sed和AWK。与之对应的就是通用编程语言<a href="https://en.wikipedia.org/wiki/General-purpose_language">GPL General Purpose Language</a>，能解决几乎所有的计算机问题，没有为特定领域进行定制，但语句可读性远不及DSL，它们的语句一般都是命令式的，如熟悉的C/C++, Java和Python等。</p>

<p><a href="http://toughcoder.net/blog/2023/02/14/understanding-kotlin-based-dsl/"><img src="https://cdn.educba.com/academy/wp-content/uploads/2022/07/Kotlin-DSL.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>GPL中的DSL痛点</h2>

<p>DSL的优点是<strong>声明式的，描述式的</strong>，并不在意<strong>具体细节的实现</strong>，比如像SQL语句，我只关心我想要什么，具体如何实现的是底下工具的事情：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='SQL'><span class='line'><span class="k">select</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span>
</span><span class='line'>    <span class="k">where</span> <span class="n">name</span> <span class="o">=</span> <span class="ss">&quot;John&quot;</span> <span class="k">and</span> <span class="n">age</span> <span class="o">&lt;=</span> <span class="mi">10</span>
</span><span class='line'>    <span class="k">from</span> <span class="n">classlist</span>
</span></code></pre></td></tr></table></div></figure>


<p>但，当在GPL，通用编程语言中解决DSL问题时，就会很蛋疼，在任何一个编程语言中实现一个SQL查询 的接口都会相当的笨拙和难用，要么需要创建很多个对象，要么需要传递一大堆令人费解的参数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Java'><span class='line'><span class="n">Cursor</span> <span class="n">cursor</span> <span class="o">=</span> <span class="n">query</span><span class="o">(</span><span class="n">uri</span><span class="o">,</span> <span class="n">projects</span><span class="o">,</span> <span class="n">where</span><span class="o">,</span> <span class="n">whereArgs</span><span class="o">,</span> <span class="n">sortby</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>可读性非常的差，假如能写成DSL那样，可读性会大大的增强。</p>

<h2>DSL式的API</h2>

<p>在Kotlin中，可以写成这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="n">query</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">from</span> <span class="s">&quot;classlist&quot;</span>
</span><span class='line'>    <span class="k">where</span> <span class="p">{</span>
</span><span class='line'>        <span class="s">&quot;name&quot;</span> <span class="n">eq</span> <span class="s">&quot;John&quot;</span>
</span><span class='line'>        <span class="s">&quot;age&quot;</span> <span class="n">lessEq</span> <span class="m">10</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可读性大大加强，这样的API使用起来也会如丝般顺滑，因为它符合DSL：描述性的，声明式的，不关心具体实现细节，只关注想要什么。</p>

<h2>背后原理</h2>

<p>Kotlin借助尾部lambda，infix函数，扩展函数。整体来就其实是一个函数调用，因为Kotlin函数最后一个参数如果是lambda时可以写在函数调用之外，所以，一层一层的DSL，其实就是函数调用。</p>

<p>再借助扩展函数和infix函数，可以把另外一些函数调用写成DSL式，比如像二进制按位或运算a or b等同于a.or(b)，这也是一个函数调用，但可读性大大加强。可以像写不作文一样的来写代码。</p>

<p>总之，见到DSL式的语句时不用惊慌，它是合法的Kotlin函数调用，把它理解成为函数调用就可以了。</p>

<h2>合理使用</h2>

<p>虽然DSL式的API能大大提高可读性，像真正的DSL一样去使用，但也要注意合理使用，不能滥用。我们要正向的解决问题，当遇到特定领域的问题时，就可以定义和实现出一套符合DSL的API。也就是说我们要利用Kotin语言提供的能力来实现DSL式的API去解决特定领域的问题。就像Android的布局，就可以定义出一套DSL式的API，这就是当时比较火的<a href="https://github.com/Kotlin/anko">anko</a>(现已废弃了)，以及像涉及HTML，涉及SQL的相关问题时。</p>

<p>但不能反过来，为了写成DSL式，而去把所有的API都搞成那样，比如把一些常规的操作像网络，像文件操作等都搞成那样，那就纯属滥用了。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/type-safe-builders.html#full-definition-of-the-com-example-html-package">Type-safe builders﻿</a></li>
<li><a href="https://www.baeldung.com/kotlin/dsl">Building DSLs in Kotlin</a></li>
<li><a href="https://coolshell.cn/articles/5709.html">API设计：用流畅接口构造内部DSL</a></li>
<li><a href="https://www.jianshu.com/p/f5f0d38e3e44">Kotlin之美——DSL篇</a></li>
<li><a href="https://blog.mindorks.com/mastering-kotlin-dsl-in-android-step-by-step-guide/">Mastering Kotlin DSL In Android - Step By Step Guide</a></li>
<li><a href="https://brunoaybar.com/how-do-kotlin-dsl-libraries-work/">How do Kotlin DSL libraries work?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Design Problems Archive]]></title>
    <link href="http://toughcoder.net/blog/2023/02/09/design-problems-archive/"/>
    <updated>2023-02-09T20:58:57+08:00</updated>
    <id>http://toughcoder.net/blog/2023/02/09/design-problems-archive</id>
    <content type="html"><![CDATA[<p>设计类习题是指要求设计一个类以完成某种特定需求，不是很复杂，通常一个类就能搞定，整体代码也不会特别长，但又能考察到一些基本的知识点，或者一些基本的技巧。通常是由一些日常中常见的任务经过简化而来。</p>

<p><a href="http://toughcoder.net/blog/2023/02/09/design-problems-archive/"><img src="http://www.dreamtemplate.com/blog/wp-content/uploads/2012/05/p228.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>因为通常都不会特别复杂，用常规的数据结构就能实现，此类问题最为关键的是要理清需求，各种边界条件的处理。一般情况下哈希表加上线性的结构如队栈或者链表就能解决。不用往复杂了想，常规数据结构，常用技术就能搞定，关键还是要读懂需求。</p>

<h2>典型问题</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/lru-cache/solution/by-alexhilton-xdf0/">题解</a> </td>
<td style="text-align:left;"> 哈希表，双向链表 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/min-stack/solution/by-alexhilton-20au/">题解</a> </td>
<td style="text-align:left;"> 栈 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/implement-queue-using-stacks/solution/by-alexhilton-hj5r/">题解</a> </td>
<td style="text-align:left;">  栈，队列 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/">304. 二维区域和检索 - 矩阵不可变</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/solution/xi-you-yuan-su-304-er-wei-qu-yu-he-jian-uqui5/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/encode-and-decode-tinyurl/">535. TinyURL 的加密与解密</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/encode-and-decode-tinyurl/solution/by-alexhilton-lz1t/">题解</a> </td>
<td style="text-align:left;"> 哈希表 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-circular-queue/">622. 设计循环队列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-circular-queue/solution/622-she-ji-xun-huan-dui-lie-by-alexhilto-adr5/">题解</a> </td>
<td style="text-align:left;"> 队列 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-circular-deque/">641. 设计循环双端队列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-circular-deque/solution/by-alexhilton-ve31/">题解</a> </td>
<td style="text-align:left;"> 队列 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/online-stock-span/">901. 股票价格跨度</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/online-stock-span/solution/by-alexhilton-piye/">题解</a> </td>
<td style="text-align:left;">  单调栈 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/complete-binary-tree-inserter/">919. 完全二叉树插入器</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/complete-binary-tree-inserter/solution/by-alexhilton-msqn/">题解</a> </td>
<td style="text-align:left;"> 队列，BFS </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-skiplist/">1206. 设计跳表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-skiplist/solution/1206-she-ji-tiao-biao-by-alexhilton-sd06/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-an-ordered-stream/">1656. 设计有序流</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-an-ordered-stream/solution/by-alexhilton-cev5/">题解</a> </td>
<td style="text-align:left;"> 队列 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-authentication-manager/">1797. 设计一个验证系统</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-authentication-manager/solution/1797-she-ji-yi-ge-yan-zheng-xi-tong-by-a-copl/">题解</a> </td>
<td style="text-align:left;"> 哈希表，双向链表，LRUCache </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/qIsx9U/">剑指 Offer II 041. 滑动窗口的平均值</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/qIsx9U/solution/by-alexhilton-1c5a/">题解</a> </td>
<td style="text-align:left;"> 队列 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[链表问题总结]]></title>
    <link href="http://toughcoder.net/blog/2023/01/31/mastering-linkedlist/"/>
    <updated>2023-01-31T23:18:57+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/31/mastering-linkedlist</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Linked_list">链表LinkedList</a>是一种线性的非连续数据结构，优势是随机删除和添加特别高效，但随机访问效率差。因为链表边界条件较多，容易出错，所以还是比较常见的一类题目。但链表常见的问题就那么多，总结起来就那么几个，想要掌握还是比较容易的。</p>

<p><a href="http://toughcoder.net/blog/2023/01/31/mastering-linkedlist/"><img src="https://myeasytuts.com/wp-content/uploads/2020/04/Linked-List-in-Swift.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>单链表</h2>

<p>单链表是出现频率最高的，虽然现实中很少用它，因为它的效率差，现实中一般多用双向链表。单链表也即是每个节点只有一个指针，指向下一个节点，只能从前往后的顺序来遍历，如果想对某一个节点进行操作，必须找到这个节点的前一个节点。
<img src="https://www.testingdocs.com/questions/wp-content/uploads/Single-Linked-List.png" alt="" /></p>

<h3>哨兵节点</h3>

<p>哨兵节点是指在输入的头节点的前面加一个节点，它的值没有任何意义，它的存在是为了简化逻辑。通常用于添加和删除操作中，如果输入的头节点是null，那么就需要特殊处理，而用了哨兵节点，就可以简化逻辑。</p>

<p>比如说，常规的添加和删除：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="n">ListNode</span> <span class="nf">normalAppend</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">ListNode</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ListNode</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
</span><span class='line'>    <span class="c1">// ugly</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">newNode</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">ListNode</span> <span class="n">current</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
</span><span class='line'>    <span class="k">while</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="n">ListNode</span> <span class="nf">normalDelete</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// ugly</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="c1">// ugly</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">head</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">ListNode</span> <span class="n">current</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
</span><span class='line'>    <span class="k">while</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class='line'>            <span class="k">break</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">head</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到为了处理头节点是null的情况要加很多逻辑，但如果使用哨兵节点，逻辑就会非常简单：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="n">ListNode</span> <span class="nf">append</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">head</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">ListNode</span> <span class="n">current</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>
</span><span class='line'>    <span class="k">while</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ListNode</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="n">ListNode</span> <span class="nf">delete</span><span class="o">(</span><span class="n">ListNode</span> <span class="n">head</span><span class="o">,</span> <span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">ListNode</span> <span class="n">dummy</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">ListNode</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">head</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">ListNode</span> <span class="n">current</span> <span class="o">=</span> <span class="n">dummy</span><span class="o">;</span>
</span><span class='line'>    <span class="k">while</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">val</span> <span class="o">==</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">current</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class='line'>            <span class="k">break</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">dummy</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>哨兵节点的作用是要能简化逻辑，一般用在需要考虑头节点为null的情况，或者当使用双指针，需要从-1位置出发时。但不要滥用，要真能起到简化逻辑才可以。另外就是注意哨兵节点的值要尽可能与常规节点的值区分开来，否则把哨兵节点当成常规节点就会出错。</p>

<h3>反转</h3>

<p>链表反转是基础的操作，有三种方式：<strong>迭代，逆向构造式</strong>；<strong>借助栈，顺向构建</strong>；和<strong>递归式</strong>，详见206的题解。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reverse-linked-list/solution/206-fan-zhuan-lian-biao-by-alexhilton-6ttd/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/palindrome-linked-list/solution/by-alexhilton-pcab/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br/></p>

<h3>遍历和随机访问</h3>

<p>主要是为了查找某个节点，以进行其他操作。需要别注意的是单链表必须 要找到前一个节点才可以，所以遍历的终止条件一般都是curr.next == target。高级的方法就是<strong>双指针</strong>和<strong>快慢指针</strong>，双指针是指两个指针指向不同的位置，然后以同样的速度向前移动；而快慢指针的特点是一个跑的快（两倍步长到next.next），一个跑的慢（常规步长到next），通常从同一个起点出发，注意它们之间是有区别的。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/19-shan-chu-lian-biao-de-dao-shu-di-n-ge-xa3i/">题解</a> </td>
<td style="text-align:left;"> 双指针 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/solution/by-alexhilton-p9ch/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/solution/xi-you-yuan-su-25-k-ge-yi-zu-fan-zhuan-l-i2ej/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/linked-list-components/">817. 链表组件</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/linked-list-components/solution/by-alexhilton-0raa/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/">面试题 02.02. 返回倒数第 k 个节点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/solution/by-alexhilton-us40/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/middle-of-the-linked-list/solution/by-alexhilton-0uz4/">题解</a> </td>
<td style="text-align:left;"> 快慢指针 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="">1290. 二进制链表转整数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/convert-binary-number-in-a-linked-list-to-integer/solution/by-alexhilton-h6oe/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br/></p>

<h3>插入和删除</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/solution/by-alexhilton-p9ch/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/solution/82-shan-chu-pai-xu-lian-biao-zhong-de-zh-cmlv/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/solution/by-alexhilton-u8ul/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-duplicate-node-lcci/">面试题 02.01. 移除重复节点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-duplicate-node-lcci/solution/by-alexhilton-u6rm/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-linked-list-elements/solution/by-alexhilton-qvkv/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/delete-node-in-a-linked-list/">237. 删除链表中的节点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/delete-node-in-a-linked-list/solution/by-alexhilton-3c7t/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br/></p>

<h3>链表合并</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-two-sorted-lists/solution/21-he-bing-liang-ge-you-xu-lian-biao-by-2pafg/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-k-sorted-lists/solution/by-alexhilton-zctb/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sort-list/solution/by-alexhilton-tqk5/">题解</a> </td>
<td style="text-align:left;"> 寻找中间点，归并排序 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reorder-list/">143. 重排链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reorder-list/solution/cbi-jiao-you-tiao-li-de-yi-chong-xie-fa-l56fx/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-in-between-linked-lists/">1669. 合并两个链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-in-between-linked-lists/solution/by-alexhilton-gl5m/">题解</a> </td>
<td style="text-align:left;"> 严格来说不算合并，<br/>主要涉及删除和插入，<br/>以及随机访问 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br/></p>

<h3>相交链表</h3>

<p>属于高级题目，但套路单一，当作基本套路记住就行了。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/solution/by-alexhilton-jhos/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/solution/114-er-cha-shu-zhan-kai-wei-lian-biao-by-3mke/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br/></p>

<h3>环形链表</h3>

<p>主要分两种，一种是链表部分成环；另外就是整个链表就是环（首尾相接），套路也比较单一，记住就行了。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/4ueAj6/">剑指 Offer II 029. 排序的循环链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/4ueAj6/solution/by-alexhilton-dr5w/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/linked-list-cycle/solution/141-huan-xing-lian-biao-by-alexhilton-pzk1/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/linked-list-cycle-ii/solution/by-alexhilton-u2dm/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br/></p>

<h3>综合</h3>

<p>| 题目 | 题解 | 说明 |
| :&ndash; | :&ndash; | :&ndash; |
| <a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a>| <a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/solution/114-er-cha-shu-zhan-kai-wei-lian-biao-by-3mke/">题解</a> | |
| <a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a>| <a href="https://leetcode.cn/problems/lru-cache/solution/by-alexhilton-xdf0/">题解</a> | |
| <a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a>| <a href="https://leetcode.cn/problems/design-linked-list/solution/xi-you-yuan-su-707-she-ji-lian-biao-lian-hcpr/">题解</a> | |
| <a href=""></a>| <a href="">题解</a> | |
| <a href=""></a>| <a href="">题解</a> | |
<br/></p>

<h2>双向链表</h2>

<p>每个节点有两个指针分别指向下一个节点和前一个节点，这是在实际工作中使用的最多的链表形式，绝大部分操作与单链表是一样的，也是线性的。</p>

<p><img src="https://www.studytonight.com/data-structures/images/doubly-linked-list-1.png" alt="" /></p>

<p>双向链表因为有两个指针，所以在删除或者插入的时候需要小心处理好四个指针，其他的东西与单链表是一样的。另外，双链表为了达到最好的效果要使用两个哨兵节点，一个是head，指向头节点，一个是tail是末尾节点。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-authentication-manager/">1797. 设计一个验证系统</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-authentication-manager/solution/1797-she-ji-yi-ge-yan-zheng-xi-tong-by-a-copl/">题解</a> </td>
<td style="text-align:left;"> 双向链表，哈希表<br/>LURCache </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>跳表 SkipList</h2>

<p>这是以链表为基础能构造出来的最复杂的数据结构，是二维链表形式，它能够实现log(n)级别的各种操作，效率非常之高，在很多地方替代了平衡二叉树（二叉树只有达到平衡才能到最高的效率，所以工程中使用的二叉树肯定要平衡）。
<img src="https://pic2.zhimg.com/v2-17f6e0c031067f3d2a1d5b8f0e586ff5_r.jpg" alt="" /></p>

<p>首先，要明确一下问题，跳表也好，二叉树也好，是解决有序数据集的查询效率的。对于数量为n的数据集来说，如果是无序的肯定是O(n)，但如果数据有序，比如一个排好序的数组或者列表就可以用二分查找，或者用BST（二叉搜索树）时间复杂度都会降低到O(log<sup>n</sup>)。也就是说跳表解决的问题是有序列数据集的查询问题。</p>

<h3>基本原理</h3>

<p>前面说了，对于有序数据集，如果是用数组或者列表来存储，查询 效率肯定是O(log<sup>n</sup>)的，但是连续结构有一个问题就是它的插入和删除是O(n)的。链表呢虽然插入和删除可以做到O(1)，但是它的随机访问（也即查询）慢要O(n)。那么对于一个有序的单链表来说，有没有办法可以提升它的查询效率呢？（插入和删除以及修改都要以查询为先，只有找到了才方便做插删改）。我们要利用数据已排好序，假如能像BST或者二分那样，能把数据集缩小，就可以提升效率。</p>

<p>假如有一个现成的指针指向有序单链表的中间，那么就可以把中单节点的值与目标值比较，如果目标值大于中间节点，那目标值肯定 在后半段，否则就在前半段。假如有更多的中间节点指针，是不是就是二分查找了？可以用空间换时间，给有序单链表建立索引层，每一层也是一个单链表，它会把下面一层链表分成几段，底层是数据集，即有序单链表。这样，从最上层往下层走，就可以把数据集缩小到一个很小的范围内。极端情况下，可以在1/2，1/4，1/8. &hellip; 建立索引层，那这是不是就变成BST了？</p>

<p>这就是跳表的核心想。查询的时候总是从最上层开始，因为每一层也是一个有序链表，当下一个节点值大于目标值时，就需要向下走，然后从这一层的这个节点开始，先向后查询，下一个节点大于目标值时，再向下走，这样当前指针就会一层一层的来回跳着走，故名跳表。</p>

<h3>实现细节</h3>

<p>跳表的原理并不复杂，容易理解，但从原理到编码仍有很多细节需要考虑，比如如何表示每一层？以及分多少层，分层多能提升效率，但分层多占用的空间也越大，而且如果分的过细，不就变成了二叉树了么。以及说在哪些节点建立索引（也即分层），是按固定的位置（1/2, &frac14;&hellip;）还是按什么规律，因为这直接会影响查询效率。</p>

<h4>如何实现分层</h4>

<p>分层在节点中实现，常规的节点有一个指针next指向下一个节点，在跳表中节点的next指针是一个数组，数组的长度就是这个节点的层数，以此实现分层，0层是底层，level-1是最上层。这样就能实现每层两个方向的遍历方式，每一层的next指针就是这一层的链表，通过curr.next[i]就能向后遍历。下楼（也即从上层往下一层走）就是level-1就下去了。</p>

<p>当然 这里也可以用指针，比如节点有两个指针一个是next，指向同层的后面的节点，以及down，指针下一层的同位置的指针。但并无概念上的区别，总之层的实现是在每个节点上面的。</p>

<p>从大的维度来说，整体仍是一个从左向右的单链表，分层是在每个节点上面的实现的。</p>

<h4>在哪里分层</h4>

<p>固定位置分层不可取，因为这就是BST的方式啊，数据集的变化可不会因为位置而改变，比如以1/2, 1/4和1/8这几个位置来分层，那假如数据向1/4后的位置集中了，这就会不平衡，就必须做平衡，会比较麻烦（这也是各种平衡二叉树的痛点）。</p>

<p>跳表用一个比较骚的方式，随机化分层，一个长度为n的有序单链表，每个节点都有机会建立分层索引，这样摊还分析后，整体的效率是最好的。</p>

<p>同时，为了防止分层过于集中，还设立了最大层限制MAX_DEPTH。具体的策略是预先设置一个阈值P（0 &lt; P &lt; 1)，每次随机生成一个0~1的浮点数，如果它大于P，那么这个节点的层数加1，否则就返回当前层数（即保持层数不变）。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kt">int</span> <span class="nf">randomLevel</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">lv</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>    <span class="k">while</span> <span class="o">(</span><span class="n">random</span><span class="o">.</span><span class="na">nextDouble</span><span class="o">()</span> <span class="o">&lt;</span> <span class="n">P_FACTOR</span> <span class="o">&amp;&amp;</span> <span class="n">lv</span> <span class="o">&lt;</span> <span class="n">MAX_LEVEL</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">lv</span><span class="o">++;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">lv</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>哨兵节点</h4>

<p>为了方便，可以加入哨兵节点head，head犹为重要，这是整个数据结构的入口，并且有了head后插入和删除的逻辑都能得到简化。</p>

<h3>标准实现</h3>

<p>为了简单，节点值用整数，节点值的有效范围可以设定为0~n-1，长度共是n。</p>

<h4>节点</h4>

<p>节点，与单链表很像，一个代表值的int，以及一个数组，代表next指针。</p>

<p>需要注意，一个节点的层数在创建节点时就确定了，在节点的生命周期过程中其层数不会变化。因为对跳表数据结构产生变化 的操作只有插入和删除，插入是生成新的节点，插入时层数已确定；删除是把节点移除，自然也没必要再去改变节点本身了。所以节点的数据类型是Immutable的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">final</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">final</span> <span class="n">Node</span><span class="o">[]</span> <span class="n">next</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Node</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">,</span> <span class="kt">int</span> <span class="n">level</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
</span><span class='line'>        <span class="n">next</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">[</span><span class="n">level</span><span class="o">];</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>构造</h4>

<p>跳表其实就是一个单链表表，所以整体数据结构也不复杂，一个哨兵入口的头节点head，还有当前节点中的最大层数level，和两个阈值P_FACTOR是要不要增加层深的阈值以及最大层数MAX_LEVEL。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">INF</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">;</span>
</span><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAX_LEVEL</span> <span class="o">=</span> <span class="mi">32</span><span class="o">;</span>
</span><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">double</span> <span class="n">P_FACTOR</span> <span class="o">=</span> <span class="mf">0.25</span><span class="o">;</span>
</span><span class='line'><span class="kd">private</span> <span class="kd">final</span> <span class="n">Node</span> <span class="n">head</span><span class="o">;</span>
</span><span class='line'><span class="kd">private</span> <span class="kt">int</span> <span class="n">level</span><span class="o">;</span>
</span><span class='line'><span class="kd">private</span> <span class="kd">final</span> <span class="n">Random</span> <span class="n">random</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="nf">SkipList</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">head</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Node</span><span class="o">(-</span><span class="n">INF</span><span class="o">,</span> <span class="n">MAX_LEVEL</span><span class="o">);</span>
</span><span class='line'>    <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Random</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>查询</h4>

<p>从头节点入口，从其最高层开始查询，具体查询过程与单链表是一样的，持有当前指针，当前指针初化为head节点，不断向后遍历curr直到curr.next[level].val大于目标值，然后走到下一层，继续向后遍历。直到最底层，如果curr.next[0].val等于目标值则找到，否则就是没有，不存在。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">search</span><span class="o">(</span><span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Node</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(</span><span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">value</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">value</span> <span class="o">==</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>删除</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">delete</span><span class="o">(</span><span class="kt">int</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Node</span><span class="o">[]</span> <span class="n">updates</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">[</span><span class="n">MAX_LEVEL</span><span class="o">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Node</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(</span><span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">value</span> <span class="o">&lt;</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">updates</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">curr</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">curr</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">curr</span><span class="o">.</span><span class="na">value</span> <span class="o">!=</span> <span class="n">target</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="c1">// target not exist</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">level</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">updates</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">next</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="n">curr</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">break</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">updates</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">next</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">while</span> <span class="o">(</span><span class="n">level</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">head</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">level</span><span class="o">--;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>插入</h4>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Node</span><span class="o">[]</span> <span class="n">updates</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">[</span><span class="n">MAX_LEVEL</span><span class="o">];</span>
</span><span class='line'>    <span class="n">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">updates</span><span class="o">,</span> <span class="n">head</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Node</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(</span><span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">value</span> <span class="o">&lt;</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">updates</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">curr</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kt">int</span> <span class="n">lv</span> <span class="o">=</span> <span class="n">randomLevel</span><span class="o">();</span>
</span><span class='line'>    <span class="n">level</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">max</span><span class="o">(</span><span class="n">level</span><span class="o">,</span> <span class="n">lv</span><span class="o">);</span>
</span><span class='line'>    <span class="n">Node</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Node</span><span class="o">(</span><span class="n">value</span><span class="o">,</span> <span class="n">lv</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lv</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">newNode</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">updates</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">next</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>        <span class="n">updates</span><span class="o">[</span><span class="n">i</span><span class="o">].</span><span class="na">next</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">newNode</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>修改</h4>

<p>一般的实现中不会不回修改的接口，因为修改就是删除原节点，然后再插入新节点，所以用删除和插入就可以实现了，没必要再添加一个方法。</p>

<h4>运行</h4>

<p>为了方便加一个调试方法</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'> <span class="kd">public</span> <span class="kt">void</span> <span class="nf">dump</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span><span class="o">--)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">StringBuilder</span> <span class="n">sb</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">StringBuilder</span><span class="o">();</span>
</span><span class='line'>        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&quot;L #%3d [ &quot;</span><span class="o">,</span> <span class="n">i</span><span class="o">));</span>
</span><span class='line'>        <span class="n">Node</span> <span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
</span><span class='line'>        <span class="n">Node</span> <span class="n">bottomCurr</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(</span><span class="n">bottomCurr</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">curr</span><span class="o">.</span><span class="na">value</span> <span class="o">==</span> <span class="n">bottomCurr</span><span class="o">.</span><span class="na">value</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">curr</span> <span class="o">==</span> <span class="n">head</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&quot;-Inf -&gt; &quot;</span><span class="o">);</span>
</span><span class='line'>                <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">&quot;%5d -&gt; &quot;</span><span class="o">,</span> <span class="n">curr</span><span class="o">.</span><span class="na">value</span><span class="o">));</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>                <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&quot;         &quot;</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="n">bottomCurr</span> <span class="o">=</span> <span class="n">bottomCurr</span><span class="o">.</span><span class="na">next</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">sb</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&quot; null ]&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">sb</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">SkipList</span> <span class="n">sl</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">SkipList</span><span class="o">();</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>
</span><span class='line'>    <span class="n">Random</span> <span class="n">rand</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Random</span><span class="o">();</span>
</span><span class='line'>    <span class="kt">int</span><span class="o">[]</span> <span class="n">values</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="mi">7</span><span class="o">];</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">values</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">values</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
</span><span class='line'>        <span class="n">sl</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">values</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;After insertion.&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="n">sl</span><span class="o">.</span><span class="na">dump</span><span class="o">();</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">values</span><span class="o">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="o">];</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Searching (true) &quot;</span> <span class="o">+</span> <span class="n">target</span> <span class="o">+</span> <span class="s">&quot; -&gt; &quot;</span> <span class="o">+</span> <span class="n">sl</span><span class="o">.</span><span class="na">search</span><span class="o">(</span><span class="n">target</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Delete some.&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">values</span><span class="o">[</span><span class="n">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">n</span><span class="o">)</span> <span class="o">%</span> <span class="n">values</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Deleting (true) &quot;</span> <span class="o">+</span> <span class="n">target</span> <span class="o">+</span> <span class="s">&quot; -&gt; &quot;</span> <span class="o">+</span> <span class="n">sl</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">target</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">target</span> <span class="o">=</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
</span><span class='line'>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Deleting &quot;</span> <span class="o">+</span> <span class="n">target</span> <span class="o">+</span> <span class="s">&quot; -&gt; &quot;</span> <span class="o">+</span> <span class="n">sl</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">target</span><span class="o">));</span>
</span><span class='line'>    <span class="n">target</span> <span class="o">=</span> <span class="n">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">n</span><span class="o">);</span>
</span><span class='line'>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Deleting &quot;</span> <span class="o">+</span> <span class="n">target</span> <span class="o">+</span> <span class="s">&quot; -&gt; &quot;</span> <span class="o">+</span> <span class="n">sl</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">target</span><span class="o">));</span>
</span><span class='line'>    <span class="n">sl</span><span class="o">.</span><span class="na">dump</span><span class="o">();</span>
</span><span class='line'>    <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Insert some more.&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">sl</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">rand</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">n</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">sl</span><span class="o">.</span><span class="na">dump</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行结果，要用等宽字体看才有效果：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>After insertion.
</span><span class='line'>L <span class="c">#  3 [ -Inf -&gt;                               29 -&gt;                             null ]</span>
</span><span class='line'>L <span class="c">#  2 [ -Inf -&gt;             16 -&gt;             29 -&gt;                             null ]</span>
</span><span class='line'>L <span class="c">#  1 [ -Inf -&gt;     7 -&gt;    16 -&gt;             29 -&gt;             57 -&gt;           null ]</span>
</span><span class='line'>L <span class="c">#  0 [ -Inf -&gt;     7 -&gt;    16 -&gt;    21 -&gt;    29 -&gt;    44 -&gt;    57 -&gt;    88 -&gt;  null ]</span>
</span><span class='line'>Searching <span class="o">(</span><span class="nb">true</span><span class="o">)</span> <span class="m">16</span> -&gt; <span class="nb">true</span>
</span><span class='line'>Searching <span class="o">(</span><span class="nb">true</span><span class="o">)</span> <span class="m">29</span> -&gt; <span class="nb">true</span>
</span><span class='line'>Searching <span class="o">(</span><span class="nb">true</span><span class="o">)</span> <span class="m">57</span> -&gt; <span class="nb">true</span>
</span><span class='line'>Delete some.
</span><span class='line'>Deleting <span class="o">(</span><span class="nb">true</span><span class="o">)</span> <span class="m">16</span> -&gt; <span class="nb">true</span>
</span><span class='line'>Deleting <span class="o">(</span><span class="nb">true</span><span class="o">)</span> <span class="m">29</span> -&gt; <span class="nb">true</span>
</span><span class='line'>Deleting <span class="o">(</span><span class="nb">true</span><span class="o">)</span> <span class="m">57</span> -&gt; <span class="nb">true</span>
</span><span class='line'>Deleting <span class="m">75</span> -&gt; <span class="nb">false</span>
</span><span class='line'>Deleting <span class="m">80</span> -&gt; <span class="nb">false</span>
</span><span class='line'>L <span class="c">#  1 [ -Inf -&gt;     7 -&gt;                             null ]</span>
</span><span class='line'>L <span class="c">#  0 [ -Inf -&gt;     7 -&gt;    21 -&gt;    44 -&gt;    88 -&gt;  null ]</span>
</span><span class='line'>Insert some more.
</span><span class='line'>L <span class="c">#  1 [ -Inf -&gt;     7 -&gt;                      37 -&gt;    41 -&gt;             82 -&gt;           null ]</span>
</span><span class='line'>L <span class="c">#  0 [ -Inf -&gt;     7 -&gt;    17 -&gt;    21 -&gt;    37 -&gt;    41 -&gt;    44 -&gt;    82 -&gt;    88 -&gt;  null ]</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="https://github.com/alexhilton/EffectiveAlgorithm/blob/main/datastructure/src/main/java/linkedlist/SkipList.java">完整代码在这里</a>。</p>

<h3>相关题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-skiplist/">1206. 设计跳表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-skiplist/solution/1206-she-ji-tiao-biao-by-alexhilton-sd06/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/data-structures/linked-list/">Linked List Data Structure</a></li>
<li><a href="https://www.javatpoint.com/singly-linked-list">Linked List</a></li>
<li><a href="https://www.tutorialspoint.com/data_structures_algorithms/linked_list_algorithms.htm">Data Structure and Algorithms - Linked List</a></li>
<li><a href="https://www.programiz.com/dsa/linked-list">Linked list Data Structure</a></li>
<li><a href="https://www.simplilearn.com/tutorials/data-structure-tutorial/linked-list-in-data-structure">Linked List in A Data Structure: All You Need to Know</a></li>
<li><a href="https://www.geeksforgeeks.org/skip-list/">Skip List | Set 1 (Introduction)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/33674267">SkipList的原理与实现</a></li>
<li><a href="https://www.jianshu.com/p/9d8296562806">Skip List&ndash;跳表（全网最详细的跳表文章没有之一）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/108386262">详解SkipList跳跃链表【含代码】</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/339750543">跳表(skiplist)分析设计与实现(Java)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Coroutines]]></title>
    <link href="http://toughcoder.net/blog/2023/01/27/understanding-coroutines/"/>
    <updated>2023-01-27T10:59:13+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/27/understanding-coroutines</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Coroutine">协程Coroutine</a>是一种轻量级的实现异步的方式，使用上大大简化了以往异步和多线和带来的种种麻烦（如状态同步和锁），今天就来学习一下协程，以及在<a href="https://kotlinlang.org/docs/coroutines-guide.html">Kotlin中协程</a>的使用方式。</p>

<p><a href="http://toughcoder.net/blog/2023/01/27/understanding-coroutines/"><img src="https://cdn.filestackcontent.com/fShtqYm3Tp2Xl9C36xN8" title="auto auto" ></a></p>

<!-- more -->


<h2>理解异步</h2>

<p>在解释什么是协程之前，得先要理解什么是异步。异步也就是说程序是非阻塞非同步的，并不是按照顺序来执行的。这么说依然很绕，我们来一个简单的例子。比如有这样一个语句：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
</span><span class='line'>     <span class="n">println</span><span class="p">(</span><span class="s">&quot;world of Coroutine!&quot;</span><span class="p">)</span> <span class="c1">// 1</span>
</span><span class='line'>     <span class="n">print</span><span class="p">(</span><span class="s">&quot;Hello ...&quot;</span><span class="p">)</span> <span class="c1">// 2</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个代码的输出很明显是</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>world of Coroutine
</span><span class='line'>Hello ...
</span></code></pre></td></tr></table></div></figure>


<p>函数的执行是从上到下按我们写的顺序执行的，这就是顺序执行的意思，虽然说编译器会做一些指令重排以期对字节码进行一些优化，但有一个前提就是它不会改变程序的正确性，比如后面语句如果需要前面表达的结果时，一定能保证它们的执行顺序。同步的意思是，执行一个子函数，子函数会占用CPU，直到它运行结束再返回到调用它的函数，继续运行并能把结果带回给调用者，这即是同步的意思。比如这里的println，println没有执行完时，后面的语句是不会执行的。</p>

<p>异步的意思是函数语句的执行并不是按照我们写的顺序来运行的。比如说，前面的函数，如何能输出&#8221;Hello &hellip;world of Coroutine&#8221; ？这就需要让代码实现异步，非顺序的执行。有多种方式，协程就可以实现异步：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">=</span> <span class="n">runBlocking</span> <span class="p">{</span> <span class="c1">// this: CoroutineScope</span>
</span><span class='line'>    <span class="n">launch</span> <span class="p">{</span> <span class="c1">// launch a new coroutine and continue</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="m">1000L</span><span class="p">)</span> <span class="c1">// non-blocking delay for 1 second (default time unit is ms)</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;world of Coroutine!&quot;</span><span class="p">)</span> <span class="c1">// print after delay</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;Hello ...&quot;</span><span class="p">)</span> <span class="c1">// main coroutine continues while a previous one is delayed</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// Hello ...world of Coroutine!</span>
</span></code></pre></td></tr></table></div></figure>


<h2>协程不是线程</h2>

<p>需要特别注意的是协程并不是线程，它并不是实现多线程或者并行的方式，相反，协程是实现异步和并发的方式，它是让多个函数更好的协作以实现异步和并发，<a href="http://c.biancheng.net/view/9486.html">并发与并行的区别可以看这里</a>。</p>

<p><img src="https://ts1.cn.mm.bing.net/th/id/R-C.cd0dda66a295b461b1ec1f269be2314d?rik=4v1wb0LmAIbRew&amp;riu=http%3a%2f%2fsungjk.github.io%2fimages%2f2021%2f08%2f01%2fcoroutine.png&amp;ehk=D9i5q9A3eVYLMoxOPPbCAU0Rxek54FJ%2figmJCJYuY%2fc%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" /></p>

<p>从它的名字可以看出，它是子例程之间的协作，它是函数的执行，可以挂起，可以继续，但它不会产生阻塞。可以理解为它把线程进行了拆解，分为线程环境的具体函数的执行，协程则是函数的执行。</p>

<p>理解协程的要点是协程只会挂起，不会阻塞，重点转移到了各个函数如何协作，如何设计挂起点。至于并发部分，则交由协程运行的上下文环境(CoroutineContext)来处理。</p>

<h2>实战</h2>

<p>这时强烈推荐<a href="https://kotlinlang.org/docs/coroutines-and-channels.html">官方的一个实战性的教程</a>，它是一个有具体应用场景且足够的复杂的小项目，大部分代码已实现了，预留了一些任务来练手，并有教程进行讲解，当然也有参考答案，非常适合学习和参考。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://zhuanlan.zhihu.com/p/25979906">简单解释 Coroutine</a></li>
<li><a href="https://www.baeldung.com/kotlin/threads-coroutines">Threads vs Coroutines in Kotlin</a></li>
<li><a href="https://developer.android.google.cn/kotlin/coroutines">Kotlin coroutines on Android</a></li>
<li><a href="https://amitshekhar.me/blog/kotlin-coroutines">Mastering Kotlin Coroutines</a></li>
<li><a href="https://blog.csdn.net/xinzhilinger/article/details/116240688">Unity 协程(Coroutine)原理与用法详解</a></li>
<li><a href="https://docs.python.org/3/library/asyncio-task.html">Coroutines and Tasks</a></li>
<li><a href="https://www.educba.com/coroutines-vs-threads/">Coroutines vs Threads</a></li>
<li><a href="https://coolshell.cn/articles/10975.html">一个“蝇量级” C 语言协程库</a></li>
<li><a href="https://coolshell.cn/articles/12012.html">STATE THREADS 回调终结者</a></li>
<li><a href="https://en.wikipedia.org/wiki/Asynchronous_I/O">Asynchronous I/O</a></li>
<li><a href="https://realpython.com/async-io-python/">Async IO in Python: A Complete Walkthrough</a></li>
<li><a href="https://www.topcoder.com/thrive/articles/Introduction-to-asyncio-asynchronous-io-in-python">INTRODUCTION TO ASYNCIO (ASYNCHRONOUS IO) IN PYTHON</a></li>
<li><a href="https://andela.com/insights/an-introduction-to-asynchronous-programming-in-python-with-async-io/">An introduction to asynchronous programming in Python with Async IO</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin Collections]]></title>
    <link href="http://toughcoder.net/blog/2023/01/26/kotlin-arrays-and-collections/"/>
    <updated>2023-01-26T16:39:49+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/26/kotlin-arrays-and-collections</id>
    <content type="html"><![CDATA[<p>现代的软件一般比较复杂，程序语言中的基本数据类型往往不能满足需要，除了<a href="http://toughcoder.net/blog/2023/01/19/kotlin-types-and-operators/">基本的数据类型</a>以外，还有对象的容器也非常的重要，比如线性容器（数组，列表和Set）和二维容器（哈希表）等。今天就来学习一下Kotlin中的容器。</p>

<p><a href="http://toughcoder.net/blog/2023/01/26/kotlin-arrays-and-collections/"><img src="https://koenig-media.raywenderlich.com/uploads/2019/06/KotlinCollections-twitter.png" title="auto auto" ></a></p>

<!-- more -->


<h2><a href="https://kotlinlang.org/docs/collections-overview.html">Kotlin Collections</a></h2>

<p>集合就是用于处理一组对象的容器，因为用的人较多，所以就成了标准库。常见的集合有三种主要类型，列表类，Set类和Map类。</p>

<h3>线性容器</h3>

<p>这里并不单纯指类List，主要的意思是线性的容器，它的特点是以<strong>相对顺序存储同一类型的对象</strong>，有一个整数索引(index)来表示其相对的位置，查找性能差，其他还好。代表为数组。</p>

<h3><a href="https://kotlinlang.org/docs/arrays.html">数组</a></h3>

<p>最简单也是使用最为广泛的线性容器，不用过多的介绍了，可以参考<a href="http://toughcoder.net/blog/2023/01/19/kotlin-types-and-operators/">之前的文章</a>。</p>

<p>最大的弊端就是长度是固定的，长度在创建数组时就确定了，后面就改不了了。所以，必须在<strong>事先要能够确定数组的长度</strong>。</p>

<h4>创建复杂数组</h4>

<p>比如数组的元素是一个Collection，而非常见的基本数据类型，这时要如何写？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'>   <span class="k">val</span> <span class="py">carray</span> <span class="p">=</span> <span class="n">arrayOf</span><span class="p">&lt;</span><span class="n">MutableList</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;&gt;(</span>
</span><span class='line'>        <span class="n">mutableListOf</span><span class="p">(),</span>
</span><span class='line'>        <span class="n">mutableListOf</span><span class="p">()</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">val</span> <span class="py">narray</span> <span class="p">=</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">MutableList</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">&gt;&gt;(</span><span class="m">10</span><span class="p">)</span> <span class="p">{</span> <span class="n">mutableListOf</span><span class="p">()</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>关键就在于要声明元素的类型，其他的与基本数据类型的数组是一样的。另外，如果数组数量比较少，方便直接写，那就用字面构造函数，其实很方便。或者用数组元素的构造方法也可以。</p>

<h4>多维数组</h4>

<p>以最为常见的二维数组来说，要如何创建?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'>   <span class="k">val</span> <span class="py">smatrix</span> <span class="p">=</span> <span class="n">arrayOf</span><span class="p">(</span>
</span><span class='line'>        <span class="n">arrayOf</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">),</span>
</span><span class='line'>        <span class="n">arrayOf</span><span class="p">(</span><span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">6</span><span class="p">),</span>
</span><span class='line'>        <span class="n">arrayOf</span><span class="p">(</span><span class="m">7</span><span class="p">,</span> <span class="m">8</span><span class="p">,</span> <span class="m">9</span><span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">val</span> <span class="py">matrix</span> <span class="p">=</span> <span class="n">Array</span><span class="p">(</span><span class="m">5</span><span class="p">)</span> <span class="p">{</span> <span class="n">IntArray</span><span class="p">(</span><span class="m">6</span><span class="p">)</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3><a href="https://kotlinlang.org/docs/ranges.html">Ranges</a></h3>

<p>用于表示区间的表达式，最为直观理解就是数组的索引，用<strong>操作符..</strong>来表示区间，比如0~9，就是<strong>0..9</strong>，通常用于for-loop中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">1.</span><span class="p">.</span><span class="m">4</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// equivalent of i &gt;= 1 &amp;&amp; i &lt;= 4</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">1.</span><span class="p">.</span><span class="m">4</span><span class="p">)</span> <span class="n">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1">// for (int i = 1; i &lt;= 4; i++) print(i)</span>
</span></code></pre></td></tr></table></div></figure>


<p>还可以指定步长和边界，以及方向：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">0</span> <span class="n">until</span> <span class="m">10</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// for (int i = 0; i &lt; 10; i++)</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="n">ln</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">0</span> <span class="n">until</span> <span class="m">10</span> <span class="n">step</span> <span class="m">2</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// for (int i = 0; i &lt; 10; i += 2)</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="n">ln</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">9</span> <span class="n">downTo</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// for (int i = 9; i &gt;= 0; i--)</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>还可以用于字符，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">c</span> <span class="k">in</span> <span class="sc">&#39;a&#39;</span><span class="p">..</span><span class="sc">&#39;z&#39;</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// for (char c = &#39;a&#39;; c &lt;= &#39;z&#39;; c++)</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Range是一个表达式，所以在其之上做其他操作，但需要注意这时<strong>需要加上括号</strong>，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="p">(</span><span class="m">0.</span><span class="p">.</span><span class="m">9</span><span class="p">).</span><span class="n">filter</span> <span class="p">{</span><span class="n">it</span> <span class="p">%</span> <span class="m">2</span> <span class="p">==</span> <span class="m">0</span> <span class="p">})</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="c1">// only evens</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">c</span> <span class="k">in</span> <span class="p">(</span><span class="sc">&#39;a&#39;</span><span class="p">..</span><span class="sc">&#39;z&#39;</span><span class="p">).</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">toUpperCase</span><span class="p">()</span> <span class="p">})</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="c1">// upper case</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>需要注意</strong>，虽然Ranges方便操作数组的索引，但如果想要带着索引遍历数组的话，还是要用专用的遍历方式，而不是用Range，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">for</span> <span class="p">((</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">in</span> <span class="n">array</span><span class="p">.</span><span class="n">withIndex</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;the element: [$index] = $value&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>注意与repeat的区别</h4>

<p>Ranges是一个数据结构代表着一个区间，这个区间可能是一个整数范围，也可能是一个字符范围，其实也可以是其他自定义数据类型，只要能表达 出区间的概念。只不过整数区间是为常用的一种方式，以及整数区间可以方便当作数组和列表的索引。</p>

<p>但有时如果仅仅想重复一件事情n次，那就没有必要用Ranges，虽然它也可以，这时最为方便的是函数repeat，它与区间的唯一区别是repeat是没有返回值的，它仅是把一件事情重复n次，但没有返回值也就是说没有办法再转化为其他数组或者列表。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="n">repeat</span><span class="p">(</span><span class="m">10</span><span class="p">)</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;repeat # $it&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="c1">//repeat # 0</span>
</span><span class='line'><span class="c1">//repeat # 1</span>
</span><span class='line'><span class="c1">//repeat # 2</span>
</span><span class='line'><span class="c1">//repeat # 3</span>
</span><span class='line'><span class="c1">//repeat # 4</span>
</span><span class='line'><span class="c1">//repeat # 5</span>
</span><span class='line'><span class="c1">//repeat # 6</span>
</span><span class='line'><span class="c1">//repeat # 7</span>
</span><span class='line'><span class="c1">//repeat # 8</span>
</span><span class='line'><span class="c1">//repeat # 9</span>
</span></code></pre></td></tr></table></div></figure>


<p>而比如Ranges是可以转化为其他数组和列表的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="p">(</span><span class="m">0</span> <span class="n">until</span> <span class="m">5</span><span class="p">).</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span> <span class="p">*</span> <span class="n">it</span> <span class="p">}.</span><span class="n">toIntArray</span><span class="p">()</span>
</span><span class='line'><span class="c1">// [0, 1, 4, 9, 16]</span>
</span></code></pre></td></tr></table></div></figure>


<h3><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/">列表List</a></h3>

<p>列表可以简单理解为无限长的数组，它最大的特点是<strong>长度不固定，不必事先定好长度，它会随着添加元素而自动增长</strong>。所以，当你事先不知道容器的长度时，就需要用List。它是一个泛型，其余操作与数组一样。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">names</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="s">&quot;James&quot;</span><span class="p">,</span> <span class="s">&quot;Donald&quot;</span><span class="p">,</span> <span class="s">&quot;Kevin&quot;</span><span class="p">,</span> <span class="s">&quot;George&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">names</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">toUpper</span><span class="p">()</span> <span class="p">}</span>
</span><span class='line'>  <span class="p">.</span><span class="n">forEach</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3><a href="https://kotlinlang.org/docs/sequences.html">序列Sequence</a></h3>

<p>序列与列表比较难区分，直观上它们是一样的。简单来说它并不是容器，它并不持有对象，它生产对象，类似于物理上的信号发射器和<a href="http://toughcoder.net/blog/2023/01/05/introduction-to-rxjava/">RxJava中的Observable</a>，是有时序上的概念的，当你需要时它就生产出来一个元素。</p>

<h3>队列queue</h3>

<p>队列可以用双端队列deque（读作dek），具体实现对象是<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-array-deque/">ArrayDeque&lt;T&gt;</a>。</p>

<p>双端队列是强大的数据结构，即可以用作队列，也可以用作栈。</p>

<h3>Set容器</h3>

<p>Set是一个<strong>不含有重复元素</strong>的容器，特点是<strong>不会保存相对顺序</strong>，可以<strong>快速实现检索</strong>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">names</span> <span class="p">=</span> <span class="n">setOf</span><span class="p">(</span><span class="s">&quot;James&quot;</span><span class="p">,</span> <span class="s">&quot;Harden&quot;</span><span class="p">,</span> <span class="s">&quot;Donald&quot;</span><span class="p">,</span> <span class="s">&quot;Joe&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">nm</span> <span class="k">in</span> <span class="n">names</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="n">nm</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">names</span><span class="p">.</span><span class="n">filter</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">length</span> <span class="p">&gt;</span> <span class="m">4</span> <span class="p">}</span>
</span><span class='line'>    <span class="p">.</span><span class="n">forEach</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Map容器</h3>

<p>由映射键->值对组成的二维容器，键不可重复，值可以重复，不会保存相对顺序，也可以用于快速检索。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">nameMap</span> <span class="p">=</span> <span class="n">mapOf</span><span class="p">(</span><span class="s">&quot;James&quot;</span> <span class="n">to</span> <span class="m">15</span><span class="p">,</span> <span class="s">&quot;Harden&quot;</span> <span class="n">to</span> <span class="m">30</span><span class="p">,</span> <span class="s">&quot;Donald&quot;</span> <span class="n">to</span> <span class="m">80</span><span class="p">,</span> <span class="s">&quot;Joe&quot;</span> <span class="n">to</span> <span class="m">86</span><span class="p">)</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">nm</span> <span class="k">in</span> <span class="n">nameMap</span><span class="p">.</span><span class="n">keys</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="n">nm</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">age</span> <span class="k">in</span> <span class="n">nameMap</span><span class="p">.</span><span class="n">values</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="n">age</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">e</span> <span class="k">in</span> <span class="n">nameMap</span><span class="p">.</span><span class="n">entries</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;${e.key} is ${e.value}&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">nameMap</span><span class="p">.</span><span class="n">filter</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">key</span><span class="p">.</span><span class="n">length</span> <span class="p">&gt;</span> <span class="m">5</span> <span class="p">}</span>
</span><span class='line'>    <span class="p">.</span><span class="n">forEach</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;${it.key} = ${it.value}&quot;</span><span class="p">)</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>注意Immutability</h2>

<p>有一个地方需要特别注意，那就是容器的<strong>不可变性Immutability</strong>，用常规的方法创建的集合对象是<strong>不可变的Immutable</strong>，就是无法向其中添加元素也无法删除元素。对象的不可变Immutable在函数式编程中是很重要的特性可以有效的减少异步和并发带来的<strong>状态一致性问题</strong>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">names</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="s">&quot;James&quot;</span><span class="p">,</span> <span class="s">&quot;Donald&quot;</span><span class="p">,</span> <span class="s">&quot;Kevin&quot;</span><span class="p">,</span> <span class="s">&quot;George&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">names</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;Paul&quot;</span><span class="p">)</span> <span class="c1">// compile error, names is immutable</span>
</span><span class='line'><span class="n">names</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">toUpper</span><span class="p">()</span> <span class="p">}</span>
</span><span class='line'>  <span class="p">.</span><span class="n">forEach</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样写会有<strong>编译错误</strong>，因为用listOf创建的列表对象是<strong>不可变的Immutable</strong>。如果想要改变就必须用支持更改的对象，如MutableList, MutableSet和MutableMap，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">names</span> <span class="p">=</span> <span class="n">mutableListOf</span><span class="p">(</span><span class="s">&quot;James&quot;</span><span class="p">,</span> <span class="s">&quot;Donald&quot;</span><span class="p">,</span> <span class="s">&quot;Kevin&quot;</span><span class="p">,</span> <span class="s">&quot;George&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">names</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&quot;Paul&quot;</span><span class="p">)</span> <span class="c1">// okay</span>
</span><span class='line'><span class="n">names</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">toUpper</span><span class="p">()</span> <span class="p">}</span>
</span><span class='line'>  <span class="p">.</span><span class="n">forEach</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果有可能还是要尽可能的<strong>用不可变对象(Immutable objects)</strong>。</p>

<h2>集合的操作</h2>

<p>集合的操作就是函数式的三板斧过滤filter，转化map和折叠化约fold/reduce，前面讲的所有的容器都是支持的，结合<a href="http://toughcoder.net/blog/2023/01/24/understanding-kotlin-functions/">lambdas</a>可以写出非常规范的函数式代码。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/kotlin-collections/">Kotlin Collections</a></li>
<li><a href="https://blog.csdn.net/u013700502/article/details/123115051">Kotlin常用Collection集合操作整理</a></li>
<li><a href="https://www.baeldung.com/kotlin/kotlin-collection-guide">Kotlin Collections Guide</a></li>
<li><a href="https://www.geeksforgeeks.org/kotlin-ranges/">Kotlin Ranges</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Kotlin Functions]]></title>
    <link href="http://toughcoder.net/blog/2023/01/24/understanding-kotlin-functions/"/>
    <updated>2023-01-24T16:43:37+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/24/understanding-kotlin-functions</id>
    <content type="html"><![CDATA[<p>函数对于编程语言来说是极其重要的一个组成部分，函数可以视为是程序的执行，是真正活的代码，为啥呢？因为运行的时候你必须要执行一个函数，一般从主函数入口，开始一个套一个的函数调用。函数更能体现程序的运行。特别是近些年函数式编程的编程范式开始广泛流行，让函数的地位再次在各种语言中都得到了极大的进升。对于任何一门编程语言，如果没有学好函数，那就相当于没有学，今天就要深入的学习一下Kotlin中的函数。</p>

<p><a href="http://toughcoder.net/blog/2023/01/24/understanding-kotlin-functions/"><img src="https://cdn.codetober.com/wp-content/uploads/2018/11/02121424/kotlin_functions_title-660x320.png" title="auto auto" ></a></p>

<!-- more -->


<p>首先来区分一下，什么是函数什么是方法，函数是编程语言中的一级对象，地位等同于其他Type，函数可以声明在任何地方：顶层（即在任何类任何方法的外面），类里面，另外函数里面等。一般支持函数式编程语言更喜欢用函数。声明在类里面的函数叫作成员函数，但更准确的说是方法。比如像纯OO的编程语言Java就只会说方法(Method)，而像函数式编程语言(Kotlin/Scala/Groovy)喜欢说函数。</p>

<h2><a href="Functions%EF%BB%BF">函数</a>的基本使用</h2>

<p>函数(Functions)在Kotlin中的一级对象，这就意味着它能像其他类型那样，可以声明变量，可以当作参数传递，可以在函数内部定义，先从基本的使用开始。</p>

<h3>函数的声明与定义</h3>

<p>用<strong>关键字fun</strong>来声明函数，然后是<strong>函数名字，参数列表，返回值</strong>和<strong>函数体</strong>：<em>修饰符</em> fun <em>函数名</em>(<em>参数列表</em>) <em>:返回类型</em> {<em>函数体</em>}</p>

<ul>
<li>修饰符，对于类的成员函数才有，一般是权限open/private</li>
<li>fun，用于声明这是一个函数的关键字</li>
<li>函数名，就像变量名一样，是函数的名字</li>
<li>(参数列表)，要用括号约束起来，就是变量的声明，多个要用逗号分隔</li>
<li>:返回类型，注意冒号，也即是函数返回值的类型，如果很明显类型可以推断出来时，就可以省略</li>
<li>{函数体}，也即函数的真实定义部分，想要执行的一些语句</li>
</ul>


<p>如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">fun</span> <span class="nf">double</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>     <span class="k">return</span> <span class="n">x</span> <span class="p">+</span> <span class="n">x</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这就是一个标准的函数。</p>

<h3>函数的使用</h3>

<p>函数的使用有三种，一是调用，另一种是声明变量，再有就是当作参数（这其实是在定义一个变量，然后当作参数）。</p>

<h4>函数的调用</h4>

<p>函数都是表达式，都有返回值，但可以不用管返回值，调用函数的时候用括号来标识，比如前面的函数double，可以这样来调用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">dx</span> <span class="p">=</span> <span class="n">double</span><span class="p">(</span><span class="m">5</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是函数最为常用的使用方法，因为程序最终要执行，所以所有的函数最终都是要被调用的。</p>

<h4>声明函数变量</h4>

<p>前面说了，函数是一级类型，它可以像其他类型那样去定义变量，比如前面的double也可以这来写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">myDouble</span> <span class="p">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">Int</span> <span class="p">-&gt;</span> <span class="n">x</span> <span class="p">+</span> <span class="n">x</span><span class="p">}</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="n">myDouble</span><span class="p">(</span><span class="m">6</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的myDouble就是一个函数变量，它的函数类型与前面的double是一样的，它是一个变量，要想执行它的函数体要加括号。</p>

<h4>把函数当作参数</h4>

<p>这里会涉及<a href="https://kotlinlang.org/docs/lambdas.html#higher-order-functions">高阶函数</a>，高阶函数就是涉及函数中的函数，主要体现在函数的参数或者返回值也是一个函数。比如数组和集合的过滤(filter)和遍历(forEach)里面的参数就是一个函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">asc</span> <span class="p">=</span> <span class="n">arrayOf</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span>
</span><span class='line'><span class="n">asc</span><span class="p">.</span><span class="n">filter</span><span class="p">({(</span><span class="n">it</span> <span class="n">and</span> <span class="m">0</span><span class="n">x01</span><span class="p">)</span> <span class="p">==</span> <span class="m">0</span><span class="p">}).</span><span class="n">map</span><span class="p">(</span><span class="n">myDouble</span><span class="p">).</span><span class="n">forEach</span><span class="p">({</span> <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">})</span>
</span><span class='line'><span class="c1">// output-&gt; 4, 8</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为把函数当作参数传递时都涉及<a href="https://kotlinlang.org/docs/lambdas.html#function-types">函数的类型定义</a>，而一般情况下用<a href="https://kotlinlang.org/docs/lambdas.html">lambda</a>是最方便的，先有个印象，后面会详细讲解。</p>

<h3>参数</h3>

<p>函数的参数还有两种比较有用的变体，称之为命名参数和默认值，这两个通常会一起使用。</p>

<h4><a href="https://kotlinlang.org/docs/functions.html#named-arguments">命名参数</a></h4>

<p>当一个函数的参数比较多时，那么在调用时想要传递参数就比较蛋疼，特别是还有相同类型的参数的时候，一片混乱，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">fun</span> <span class="nf">log</span><span class="p">(</span><span class="n">tag</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">event</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">price</span><span class="p">:</span> <span class="n">Float</span><span class="p">,</span> <span class="n">persist</span><span class="p">:</span> <span class="n">Boolean</span><span class="p">):</span> <span class="n">Unit</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;$tag, $event, $amount $price&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">persist</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// write to file</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">log</span><span class="p">(</span><span class="s">&quot;func&quot;</span><span class="p">,</span> <span class="s">&quot;Function arguments&quot;</span><span class="p">,</span> <span class="s">&quot;Hard way&quot;</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">2.3f</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样调用，参数太多了，并且相同类型的有三个，这三个极容易传错，而且因为类型检查 不会报错，可能会引发极难调试的bug。</p>

<p>这时就可以使用命名参数来缓解了，命名参数，就是在调用函数，传递参数的时候，指定参数的名字，即就是在声明函数时参数的名字，用以指定具体参数，然后这时就可不用管参数的相对顺序了，比如上面的函数也可以这样调用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'>   <span class="n">log</span><span class="p">(</span><span class="n">event</span> <span class="p">=</span> <span class="s">&quot;Named arguments&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="n">tag</span> <span class="p">=</span> <span class="s">&quot;func&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="n">source</span> <span class="p">=</span> <span class="s">&quot;Elegant&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="n">amount</span> <span class="p">=</span> <span class="m">5</span><span class="p">,</span>
</span><span class='line'>        <span class="n">persist</span> <span class="p">=</span> <span class="k">false</span><span class="p">,</span>
</span><span class='line'>        <span class="n">price</span> <span class="p">=</span> <span class="m">100f</span>
</span><span class='line'>    <span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>不会出错，而且可读性大大加强。但需要注意的是，如果要使用命名参数，就要保持一致性，给所有的参数都要命名。所以，当参数比较多的时候还是比较蛋疼，这时就需要用到参数默认值了。</p>

<h4><a href="https://kotlinlang.org/docs/functions.html#default-arguments">参数默认值</a></h4>

<p>默认值也即是在声明参数的时候指定一个默认值，在调用的时候可以省略这个参数了，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">fun</span> <span class="nf">foo</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">0</span><span class="p">):</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">x</span> <span class="p">+</span> <span class="n">y</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="nf">afoo</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">0</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">x</span> <span class="p">-</span> <span class="n">y</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">foo</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>
</span><span class='line'><span class="n">afoo</span><span class="p">(</span><span class="n">y</span> <span class="p">=</span> <span class="m">5</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，如果默认参数是最后一个参数，那么可以直接省略它，如示例中的foo(3)，但如果默认参数不是最后一个，想省略的话，必须要用命名参数，如afoo(y = 5)。当然了，两个参数都传也可以的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="n">foo</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span>
</span><span class='line'><span class="n">afoo</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>所以要把默认值和命名参数结合起来才能发挥最大的价值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">fun</span> <span class="nf">log</span><span class="p">(</span><span class="n">tag</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">event</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="s">&quot;Elegant&quot;</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">0</span><span class="p">,</span> <span class="n">price</span><span class="p">:</span> <span class="n">Float</span><span class="p">,</span> <span class="n">persist</span><span class="p">:</span> <span class="n">Boolean</span> <span class="p">=</span> <span class="k">false</span><span class="p">):</span> <span class="n">Unit</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;$tag, $event, $amount $price&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">persist</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// write to file</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">log</span><span class="p">(</span><span class="n">event</span> <span class="p">=</span> <span class="s">&quot;Named arguments&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="n">tag</span> <span class="p">=</span> <span class="s">&quot;func&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="n">price</span> <span class="p">=</span> <span class="m">100f</span>
</span><span class='line'>    <span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>把握一下<strong>使用原则</strong>：如果参数不多（4个以内），那么就把默认参数往后放，调用的时候也可以不用命名参数，直接省略默认参数就好；如果参数比较多，也要把默认参数往后放，在调用的时候尽可能的使用使用参数。</p>

<h3><a href="https://kotlinlang.org/docs/functions.html#explicit-return-types">返回值</a></h3>

<p>函数的返回值是在参数列表之后，函数体之前用冒号加类型来声明。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">fun</span> <span class="nf">printHello</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="n">String</span><span class="p">?):</span> <span class="n">Unit</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;Hello $name&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(</span><span class="s">&quot;Hi there!&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="c1">// `return Unit` or `return` is optional</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果函数没有返回值就用Unit来声明，相当于Java中的void，但更多的时候是可以省略的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">fun</span> <span class="nf">printHello</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="n">String</span><span class="p">?)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当<a href="https://kotlinlang.org/docs/functions.html#single-expression-functions">函数体只有一个表达式</a>的时候，这个时候可以省略掉函数体，而把表达式直接写在函数声明的后面，用<strong>赋值符=</strong>来连接，如前面的double也可以这样写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">fun</span> <span class="nf">double</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Int</span> <span class="p">=</span> <span class="n">x</span> <span class="p">+</span> <span class="n">x</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个时候，因为函数体只有一个表达式，所以返回类型很容易推断出来，意味着这时返回类型的声明也可以省略掉：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">fun</span> <span class="nf">double</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">=</span> <span class="n">x</span> <span class="p">+</span> <span class="n">x</span>
</span></code></pre></td></tr></table></div></figure>


<p>这会让代码非常的简洁，又不失可读性。</p>

<h3>解构返回</h3>

<p>Kotlin的函数只能有一个返回值，代表某一个类型的一个变量，如果想有多个返回值，就需要用复杂的类型，比如同一类型的多个有规律的变量可能就要用集合，如数组列表等。但如果类型不同，但逻辑上有关系的2个到3个值，如果想要一起返回，就需要用到组合类型如Pair和Triple，Pair可以把两个不同类型的变量组合成一个对象，Triple可以把三个不同类型的变量组合成一个对象，这样就可以在函数中返回了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">fun</span> <span class="nf">nameAge</span><span class="p">()</span> <span class="p">=</span> <span class="n">Pair</span><span class="p">(</span><span class="s">&quot;Alex&quot;</span><span class="p">,</span> <span class="m">50</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="nf">fullName</span><span class="p">()</span> <span class="p">=</span> <span class="n">Triple</span><span class="p">(</span><span class="s">&quot;Donald&quot;</span><span class="p">,</span> <span class="s">&quot;Jonh&quot;</span><span class="p">,</span> <span class="s">&quot;Trump&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>对于函数的调用者也很麻烦，要先声明Pair或者Triple对象，然后再拆解，比如这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">pna</span> <span class="p">=</span> <span class="n">nameAge</span><span class="p">()</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;Name ${pna.first}, age ${pna.second}&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这显然比较笨拙，不够简洁。在Kotlin中有更好的做法，可以在函数调用的时候，对返回值进行拆解，称之为解构，如下写法与上面是一样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="err">(</span><span class="py">name</span><span class="p">,</span> <span class="n">age</span><span class="p">)</span> <span class="p">=</span> <span class="n">nameAge</span><span class="p">()</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;Name $name, age $age&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>而且，如果只对组合中的某几个感兴趣，可以把不想要的变量用<strong>下划线_</strong>(underscore)来表示，比如说：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="err">(</span><span class="py">firstName</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">lastName</span><span class="p">)</span> <span class="p">=</span> <span class="n">fullName</span><span class="p">()</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;This is $firstName $lastName&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>尾部lambda参数传递</h3>

<p>前面说了函数可以作为参数传递给其他函数，但我们在使用的时候，一般会直接把一个lambda传递进去，比如说：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">fun</span> <span class="nf">execute</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="p">(</span><span class="n">Int</span><span class="p">)-&gt;</span><span class="n">Int</span><span class="p">):</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="p">-</span><span class="m">1</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>调用的时候，可以这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="n">execute</span><span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="p">{</span> <span class="n">it</span> <span class="p">*</span> <span class="n">it</span> <span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>但更建议的方式是把lambda放到函数调用之外：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="n">execute</span><span class="p">(</span><span class="m">5</span><span class="p">)</span> <span class="p">{</span> <span class="n">it</span> <span class="p">+</span> <span class="n">it</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>再比如像集合的函数式写法，通常也只传递一个lambda，这时一般都写在函数调用之外，并且当目标函数没有其他参数时也即除了要传入的lambda外无其他参数时，代表函数调用的括号也可以省略：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">nums</span> <span class="p">=</span> <span class="n">arrayOf</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span>
</span><span class='line'><span class="n">nums</span><span class="p">.</span><span class="n">filter</span> <span class="p">{</span> <span class="n">it</span> <span class="n">and</span> <span class="m">0</span><span class="n">x01</span> <span class="p">==</span> <span class="m">0</span> <span class="p">}</span> <span class="c1">// 等同于filter({ it and 0x01 == 0 })</span>
</span><span class='line'>        <span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span> <span class="p">*</span> <span class="n">it</span> <span class="p">}</span> <span class="c1">// 等同于map({ it * it })</span>
</span><span class='line'>        <span class="p">.</span><span class="n">forEach</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span> <span class="c1">// 等同于forEach({ println(it) })</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样写非常的简洁，但会牺牲一些可读性，因为花样多了，就会比较难识别出来函数的声明与函数的调用，甚至有时候会分不清函数与普通的变量。所以，识别<strong>函数调用</strong>有两种方式，一是看<strong>有没有括号</strong>，另外就看<strong>有没有尾部lambda</strong>。</p>

<h2>匿名函数</h2>

<p>匿名函数就是不指定函数的名字，通常用于把函数当作 参数传递给高阶函数时使用。</p>

<h2>内部函数</h2>

<h2><a href="https://kotlinlang.org/docs/lambdas.html">高阶函数</a></h2>

<p>高阶函数就是函数的函数，也就是说函数的参数或者返回值是一个函数的函数，也即把函数像其他类型那样使用。函数在Kotlin中一级类型(first class type)，因此从语义层面支持了函数式编程范式，当然也就支持了高阶函数以及lambdas。比如像集合的操作filter/map/fold都是高阶函数，因为它们接受一个函数作为参数。</p>

<h3><a href="https://kotlinlang.org/docs/lambdas.html#function-types">函数类型</a></h3>

<p>高级函数是把函数作为参数或者返回值，但显然并不是所有的函数都能当作高阶函数的参数或者返回值，换句话说，函数本身其实也是有类型之别的，两个函数不见得就是一样的。函数是用来针对其参数，然后在函数体内进行一些运算最终返回一个值，所以区分不同的函数最关键的是输入参数和返回值，与其名字其实没有关系，因此输入参数一致，返回值一致就可以视为同一种函数。</p>

<p>函数的类型用<strong>参数和返回值</strong>来表示，如<strong>(A, B) -> R</strong>形式，A和B是参数，R是返回值，需要注意的是括号不能省略，常见的具体形式有：</p>

<ul>
<li>() -> Unit 无参数无返回值</li>
<li>() -> R 无参数有返回值</li>
<li>(A) -> Unit 有一个参数，无返回值</li>
<li>(A) -> R 一个参数，一个返回值</li>
<li>(A, B) -> Unit 两个参数，无返回值</li>
<li>(A, B) -> R 两个参数，一个返回值</li>
</ul>


<p>函数的类型与方法签名类似(method signature)，代表着某一类的函数。在高阶函数的函数参数或者返回函数就需要用函数类型来声明。</p>

<h3><a href="https://kotlinlang.org/docs/lambdas.html#instantiating-a-function-type">实例化一个函数类型</a></h3>

<p>有很多种途径可以实例化一个函数类型，比较常见的有：</p>

<ul>
<li>通过lambda表达式，如{ a, b -> a + b }，这就是一个函数类型(A, B) -> R的实例</li>
<li>匿名函数，如fun(a: Int, b: Int): Int { return if (a > 0 &amp;&amp; b > 0) a + b else -1 }</li>
<li>引用现存的某一个函数，函数签名（参数相同，返回值相同）就视为同一种函数类型，那么已定义好的函数中有能匹配的就可以直接引用过来，<strong>顶级函数和构造函数用::</strong>来引用，<strong>类成员函数用类名::</strong>来引用，如::isOdd, String::toInt, ::Tripple</li>
</ul>


<h2>lambda表达式</h2>

<p>就是匿名隐式函数体，匿名是不用指定函数的名字，连参数的类型和返回值的类型也都省略，有时甚至连参数都可以省略，只有一个函数体，是最为简洁的一种函数定义方式，通常用于传递给高阶函数的参数，lambda力求简洁，所以但凡能推断出来的都可以省略。最简洁的lambda只有函数体，如val asc = IntArray(5) { it * it } // 创建一个长度为5的整数数组并初始化为[0,1,4,9,16]。
<img src="https://oracle-patches.com/images/2021/02/12/Kotlin_Lambda_expressions_large.jpg" alt="" /></p>

<p>lambda的形式是<strong>{ A, B -> expressions }</strong>，外面的花括号不可省略，这是lambda的标识，然后是参数列表，->用于分隔参数和函数体，除了函数体，其余的都可以省略掉，只要能推断出来。</p>

<h3>Trailing lambdas(尾部lambda)</h3>

<p>这个前面讲过了，再复习一下，当一个函数的最后一个参数是一个函数时，就可以在函数的调用外部写lambda，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">product</span> <span class="p">=</span> <span class="n">items</span><span class="p">.</span><span class="n">fold</span><span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="p">{</span> <span class="n">acc</span><span class="p">,</span> <span class="n">e</span> <span class="p">-&gt;</span> <span class="n">acc</span> <span class="p">*</span> <span class="n">e</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">run</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;...&quot;</span><span class="p">)</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>隐式参数</h3>

<p>如果lambda表达式只有一个参数，那么这个参数也可以省略，只写函数体就可以，并且可以用<strong>隐式参数it</strong>，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="n">ints</span><span class="p">.</span><span class="n">filter</span> <span class="p">{</span> <span class="n">it</span> <span class="p">&gt;</span> <span class="m">0</span> <span class="p">}</span> <span class="c1">// this literal is of type &#39;(it: Int) -&gt; Boolean&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="py">asc</span> <span class="p">=</span> <span class="n">IntArray</span><span class="p">(</span><span class="m">5</span><span class="p">)</span> <span class="p">{</span> <span class="n">it</span> <span class="p">*</span> <span class="n">it</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>lambda的返回值</h3>

<p>lambda力求简洁，所以函数体的最后一个表达式的值即是此lambda的返回值，一般不用显式的return：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="n">ints</span><span class="p">.</span><span class="n">filter</span> <span class="p">{</span> <span class="n">it</span> <span class="p">&gt;</span> <span class="m">0</span> <span class="p">}</span> <span class="c1">// boolean result of &#39;it &gt; 0&#39; is returned</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="py">asc</span> <span class="p">=</span> <span class="n">IntArray</span><span class="p">(</span><span class="m">5</span><span class="p">)</span> <span class="p">{</span> <span class="n">it</span> <span class="p">*</span> <span class="n">it</span> <span class="p">}</span> <span class="c1">// it * it is the return</span>
</span><span class='line'>
</span><span class='line'><span class="n">ints</span><span class="p">.</span><span class="n">filter</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">shouldFilter</span> <span class="p">=</span> <span class="n">it</span> <span class="p">&gt;</span> <span class="m">0</span>
</span><span class='line'>    <span class="n">shouldFilter</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果要用显式的return语句，要注意scope，在<a href="http://toughcoder.net/blog/2023/01/21/kotlin-controls-and-expressions/">这篇文章有深入讨论</a>，用隐式label来限定scope：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="n">ints</span><span class="p">.</span><span class="n">filter</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">shouldFilter</span> <span class="p">=</span> <span class="n">it</span> <span class="p">&gt;</span> <span class="m">0</span>
</span><span class='line'>    <span class="k">return</span><span class="n">@filter</span> <span class="n">shouldFilter</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>丢弃参数</h3>

<p>有时候，参数有多个，但可能并不会全都使用，仅使用了其中一个，这时不使用的参数就可以用<strong>下划线_(underscore)</strong>来代替，以表示这个参数不会被使用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="n">map</span><span class="p">.</span><span class="n">forEach</span> <span class="p">{</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="p">-&gt;</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;$value!&quot;</span><span class="p">)</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Kotlin的lambda可以写出非常简洁的函数式链式语句，一气呵成可读性又非常的好，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">headers</span> <span class="p">=</span> <span class="n">fetchHeaders</span><span class="p">()</span>
</span><span class='line'><span class="n">headers</span><span class="p">.</span><span class="n">filter</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">length</span> <span class="p">==</span> <span class="m">5</span> <span class="p">}</span>
</span><span class='line'>  <span class="p">.</span><span class="n">sortedBy</span> <span class="p">{</span> <span class="n">it</span> <span class="p">}</span>
</span><span class='line'>  <span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">uppercase</span><span class="p">()</span> <span class="p">}</span>
</span><span class='line'>  <span class="p">.</span><span class="n">forEach</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>内联函数</h2>

<h2>操作符重载</h2>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/kotlin-functions/">Kotlin functions</a></li>
<li><a href="https://www.geeksforgeeks.org/kotlin-default-and-named-argument/?ref=lbp">Kotlin | Default and Named argument</a></li>
<li><a href="https://www.cnblogs.com/Jetictors/p/8647888.html">Kotlin——高级篇（一）：Lambda表达式详解</a></li>
<li><a href="https://www.baeldung.com/kotlin/lambda-expressions">Lambda Expressions in Kotlin</a></li>
<li><a href="https://www.yiibai.com/kotlin/lambdas.html">Kotlin lambda表达式</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin Controls and Expressions]]></title>
    <link href="http://toughcoder.net/blog/2023/01/21/kotlin-controls-and-expressions/"/>
    <updated>2023-01-21T17:06:32+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/21/kotlin-controls-and-expressions</id>
    <content type="html"><![CDATA[<p>有结果返回的是表达式，没有返回的称之为语句，语句最大的问题是它没有返回值，那么想要保存结果就必然会产生副作用，比如改变变量。很多时候这是不够方便的，并且在多线程条件下，这甚至是不安全的。Kotlin中，为了加强线程安全性和方便并发和异步，因此绝大多数语句都是表达式。</p>

<p><a href="http://toughcoder.net/blog/2023/01/21/kotlin-controls-and-expressions/"><img src="https://www.jrebel.com/sites/default/files/image/2021-01/what%20is%20kotlin%20banner%20image.png" title="auto auto" ></a></p>

<!-- more -->


<h2>分支表达式</h2>

<p>Kotlin中没有三元条件符（a > b ? a : b)，但它的<strong>条件分支都是表达式</strong>，可以直接放在赋值符的右边，或者用在return语句中。</p>

<h3><a href="https://kotlinlang.org/docs/control-flow.html#if-expression">if表达式</a></h3>

<p>它是一个两个分支的表达式，是有返回值的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">maxV</span> <span class="p">=</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="n">a</span> <span class="k">else</span> <span class="n">b</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然了，把它当作常规的语句来使用也是没有问题的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">var</span> <span class="py">max</span><span class="p">:</span> <span class="n">Int</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">max</span> <span class="p">=</span> <span class="n">a</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">max</span> <span class="p">=</span> <span class="n">b</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3><a href="https://kotlinlang.org/docs/control-flow.html#when-expression">when表达式</a></h3>

<p>当超过2个分支时，if就不能用了，这时可以用when表达式，它支持多个分支，类似于其他语言中的switch：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">when</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="m">1</span> <span class="p">-&gt;</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;it is 1&quot;</span><span class="p">)</span>
</span><span class='line'>     <span class="m">2</span> <span class="p">-&gt;</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;it is 2&quot;</span><span class="p">)</span>
</span><span class='line'>     <span class="k">else</span> <span class="p">-&gt;</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">println</span><span class="p">(</span><span class="s">&quot;it is neight 1 nor 2&quot;</span><span class="p">)</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是，每一行是一个条件，并不是单单指参数与其相等，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">when</span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="k">in</span> <span class="m">1.</span><span class="p">.</span><span class="m">5</span> <span class="p">-&gt;</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;Less than 5 bigger than 1&quot;</span><span class="p">)</span>
</span><span class='line'>     <span class="n">x</span><span class="p">.</span><span class="n">isEven</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;it is even&quot;</span><span class="p">)</span>
</span><span class='line'>     <span class="k">else</span> <span class="p">-&gt;</span> <span class="n">println</span><span class="p">(</span><span class="s">&quot;It is neither even or less than 5&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然，最重要的是when是一个表达式，可以<strong>直接用在赋值符的右边，或者当参数传，或者用在return中</strong>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">fun</span> <span class="nf">Request</span><span class="p">.</span><span class="n">getBody</span><span class="p">()</span> <span class="p">=</span>
</span><span class='line'>    <span class="k">when</span> <span class="p">(</span><span class="k">val</span> <span class="py">response</span> <span class="p">=</span> <span class="n">executeRequest</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">is</span> <span class="n">Success</span> <span class="p">-&gt;</span> <span class="n">response</span><span class="p">.</span><span class="n">body</span>
</span><span class='line'>        <span class="k">is</span> <span class="n">HttpError</span> <span class="p">-&gt;</span> <span class="k">throw</span> <span class="n">HttpException</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">status</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的when就是函数的返回值，可以看到<strong>when是一个表达式，它会返回一个值，这个值直接作为函数的返回值</strong>。</p>

<p>从这几个示例可以看出<strong>when表达式相当强大</strong>比其他语言的switch要强大许多，并且可以直接当作返回值，当需要超过2个条件分支时就可以使用when表达式。</p>

<h2>循环语句</h2>

<p>循环是语句，与其他语言也差不多。</p>

<h3>while loop</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</span><span class='line'>    <span class="n">x</span><span class="p">++</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>屁股向后式do-while loop</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">do</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">x</span> <span class="p">=</span> <span class="n">poll</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">x</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3><a href="https://kotlinlang.org/docs/control-flow.html#for-loops">强大的for loop</a></h3>

<p>这个是最强大，也是最常用的循环语句遍历数组，集合和固定步长时的首选。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">item</span> <span class="k">in</span> <span class="n">collection</span><span class="p">)</span> <span class="n">print</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的collection可以是数组和集合（列表和Set）。严格来说只要collection类型实现了iterator()和next()，就可以在for loop中使用。</p>

<p>for加上range，可以非常强大：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">1.</span><span class="p">.</span><span class="m">10</span><span class="p">)</span> <span class="c1">// = for (int i = 1; i &lt;= 10; i++)</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">0</span> <span class="n">until</span> <span class="m">10</span><span class="p">)</span> <span class="c1">// = for (int i = 0; i &lt; 10; i++)</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">9</span> <span class="n">downTo</span> <span class="m">0</span><span class="p">)</span> <span class="c1">// = for (int i = 9; i &gt;= 0; i--)</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">0</span> <span class="n">until</span> <span class="m">10</span> <span class="n">step</span> <span class="m">2</span><span class="p">)</span> <span class="c1">// = for (int i = 0; i &lt; 10; i += 2)</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果是数组或者列表，但又必须要用索引，也可以直接来：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="n">array</span><span class="p">.</span><span class="n">indices</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="n">println</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="c1">// &#39;i&#39; is the index</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其实有更好的方式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">for</span> <span class="p">((</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">in</span> <span class="n">array</span><span class="p">.</span><span class="n">withIndex</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;the element at $index is $value&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其实吧，Kotlin是多范式编程语言，天生支持函数式编程，多数情况下不建议直接上for loop，而是用函数式方式的forEach，数组和集合都支持forEach的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="n">array</span><span class="p">.</span><span class="n">forEach</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2><a href="https://kotlinlang.org/docs/returns.html#return-to-labels">终止语句</a></h2>

<p>当想提前退出函数的执行，或者循环时，就需要用到终止语句，有三种<strong>return, break和continue</strong>。</p>

<h3>return终止函数执行</h3>

<p>这个都比较熟悉，常规的用法都是一样的，可以提前退出函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">fun</span> <span class="nf">plot</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="p">&lt;</span> <span class="m">1</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>         <span class="k">return</span> <span class="p">-</span><span class="m">1</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>     <span class="p">...</span>
</span><span class='line'>     <span class="k">return</span> <span class="n">y</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>但当有嵌套的lambda时，如不特别指定，return会退出外层的函数，而不是像想当然的退出lambda，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">fun</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">listOf</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">).</span><span class="n">forEach</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="p">==</span> <span class="m">3</span><span class="p">)</span> <span class="k">return</span> <span class="c1">// non-local return directly to the caller of foo()</span>
</span><span class='line'>        <span class="n">print</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;this point is unreachable&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个不是终止lambda的执行，而是直接退出函数foo的执行。如果想解决呢，即也退出遍历的lambda有三种方案：</p>

<ul>
<li>使用标签</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">fun</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">listOf</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">).</span><span class="n">forEach</span> <span class="n">lit</span><span class="err">@</span><span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="p">==</span> <span class="m">3</span><span class="p">)</span> <span class="k">return</span><span class="n">@lit</span> <span class="c1">// local return to the caller of the lambda - the forEach loop</span>
</span><span class='line'>        <span class="n">print</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot; done with explicit label&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>使用隐式标签，也即遍历的方法当作标签</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">fun</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">listOf</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">).</span><span class="n">forEach</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">it</span> <span class="p">==</span> <span class="m">3</span><span class="p">)</span> <span class="k">return</span><span class="n">@forEach</span> <span class="c1">// local return to the caller of the lambda - the forEach loop</span>
</span><span class='line'>        <span class="n">print</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot; done with implicit label&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>使用匿名函数而不是lambda，匿名函数与常规函数体效力一样，所以return只在函数体内生效</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">fun</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">listOf</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">).</span><span class="n">forEach</span><span class="p">(</span><span class="k">fun</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="p">==</span> <span class="m">3</span><span class="p">)</span> <span class="k">return</span>  <span class="c1">// local return to the caller of the anonymous function - the forEach loop</span>
</span><span class='line'>        <span class="n">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span class='line'>    <span class="p">})</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot; done with anonymous function&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这三种方式，如果非要使用，建议使用方式二，用自带的隐式label，因为比较方便，可读性也不差。</p>

<p>但，<strong>非常不建议如此使用return语句</strong>，这本是应该避免的问题，lambda多半是用在函数式遍历和处理，在lambda里面提加return本就是非常奇怪的事情。因为如果某些条件不满足，<strong>想不执行此lambda，应该用filter啊</strong>，而不是笨拙的非要在lambda中去终止：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">fun</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">listOf</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span>
</span><span class='line'>      <span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="n">i</span> <span class="p">-&gt;</span> <span class="n">i</span> <span class="p">!=</span> <span class="m">3</span><span class="p">)</span>
</span><span class='line'>      <span class="p">.</span><span class="n">forEach</span> <span class="p">{</span> <span class="n">println</span><span class="p">(</span><span class="n">it</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="n">print</span><span class="p">(</span><span class="s">&quot;You can do whatever you like here.&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>循环的终止</h3>

<p>break终止当前循环，continue则是跳过当前循环的当前步骤，直接跳到下一次迭代。这两个的常规使用与其他语言是一样的。</p>

<p>但对于break，一般来说有一个痛点，就是当有循环嵌套时，break只能终止一层，如果想终止所有循环时，只能再手动的加条件去判断，然后再一层一层的break，比如:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">0</span> <span class="n">until</span> <span class="m">10</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>   <span class="k">var</span> <span class="py">found</span> <span class="p">=</span> <span class="k">false</span>
</span><span class='line'>   <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="k">in</span> <span class="n">i</span> <span class="n">until</span> <span class="m">10</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>       <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">+</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>           <span class="n">found</span> <span class="p">=</span> <span class="k">true</span>
</span><span class='line'>           <span class="k">break</span> <span class="c1">// only break inner for loop</span>
</span><span class='line'>       <span class="p">}</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'>   <span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>       <span class="k">break</span> <span class="c1">// this break outer for loop</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这多少有点笨拙和丑陋，Kotlin有更优雅的解决方式，就是引入了<strong>标签label</strong>，可以给循环加上标签，在break时可以指定标签，同样是上面的情况，可以这样做：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="n">loop</span><span class="err">@</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">0</span> <span class="n">until</span> <span class="m">10</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>   <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="k">in</span> <span class="n">i</span> <span class="n">until</span> <span class="m">10</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>       <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">+</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="p">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>          <span class="k">break</span> <span class="n">@loop</span> <span class="c1">// break all loops easily</span>
</span><span class='line'>       <span class="p">}</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其实吧，这玩意儿跟当年的goto是一样的，虽然可行，但<strong>不建议多使用</strong>，<strong>标签多了以后会让程序的执行更加的混乱</strong>，试想假如在层层循环中break错了某个标签，调试的难度是相当大的。更多的时候需要仔细想想有没有更好的遍历方式，而不是靠标签来救命。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin Types and Operators]]></title>
    <link href="http://toughcoder.net/blog/2023/01/19/kotlin-types-and-operators/"/>
    <updated>2023-01-19T15:16:43+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/19/kotlin-types-and-operators</id>
    <content type="html"><![CDATA[<p><a href="https://kotlinlang.org/">Kotlin</a>是新一代的基于JVM的静态多范式编程语言，功能强大，语法简洁，前面已经做过<a href="https://en.wikipedia.org/wiki/Kotlin_(programming_language)">Kotlin</a>的基本的介绍，今天就来深入的学习一下它的数据类型和运算操作符。</p>

<p><a href="http://toughcoder.net/blog/2023/01/19/kotlin-types-and-operators/"><img src="https://cdn.educba.com/academy/wp-content/uploads/2019/08/Kotlin-Operators-.2.png" title="auto auto" ></a></p>

<!-- more -->


<h2>数据类型</h2>

<p>与大部分语言不同的是，在Kotlin中一切皆为对象(Everything is an object)，它没有像Java/C++那样，是没有基础数据类型(primitive types)的，都是对象，因此也不会有像Java那样的box和auto box的麻烦。box和autobox对于单独使用基础数据类型时没啥问题，比如一个方法add(Integer)，会进行自动装箱和拆箱。但如果在集合中使用就不一样了，比如array of int与array of Integer是完全不同的数据类型，以及list of int与list of Integer也是完全不同的数据类型，在这些场景里就会相当麻烦，要进行转换，详细可以<a href="http://toughcoder.net/blog/2022/06/14/java-collection-opertions-made-easy/">参考这篇文章</a>。</p>

<h3>变量类型的声明</h3>

<p>类型是放在变量之后，这样可以先强调变量的名字，后关注其类型，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">var</span> <span class="py">count</span><span class="p">:</span> <span class="n">Int</span>
</span><span class='line'><span class="k">var</span> <span class="py">message</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">double</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Int</span><span class="p">):</span> <span class="n">Int</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">x</span> <span class="p">+</span> <span class="n">x</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>类型推断</h3>

<p>虽然Kotlin是<strong>静态强类型语言</strong>，也就是说在编译的时候，编译器必须知道你的数据是什么类型的，这与Java和C++等是一样的，但并不意味着你必须为每个变量声明它的类型。变量的声明，是告诉编译器有一个什么类型的变量，以及叫什么，就比如在函数中的参数列表，就是变量的声明；而变量的定义，则是在声明的同时，要给变量赋值。</p>

<p>那么，当定义变量的时候，编译器是能够直接推断出来它的类型的，这个时候就可以省去类型的声明，<strong>Kotlin语言力求简洁</strong>，凡是能<strong>推断出变量的类型时都可以省去类型的声明</strong>，如定义变量的时候，如在lambda中，或者在函数的返回值中。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">PI</span> <span class="p">=</span> <span class="m">3.14</span> <span class="c1">// Double</span>
</span><span class='line'><span class="k">val</span> <span class="py">PI</span><span class="p">:</span> <span class="n">Double</span> <span class="p">=</span> <span class="m">3.14</span> <span class="c1">// 与上面的效果一样</span>
</span></code></pre></td></tr></table></div></figure>


<h3>数字类型(Numbers)</h3>

<p>数字类型与大部分语言一样，特别的，它与Java语言是一样的，都是有符号的，即数字最高数位代表符号。</p>

<h4>整数</h4>

<p>与Java语言一样，有四大整数具体类型，8位的Byte，16位的Short，32位的Int以及64位的Long。它们的范围如下：</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> Type </th>
<th style="text-align:center;"> Size(bits) </th>
<th style="text-align:left;"> Min value </th>
<th style="text-align:left;"> Max value </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> Byte </td>
<td style="text-align:center;"> 8 </td>
<td style="text-align:left;"> -128 </td>
<td style="text-align:left;"> 127 </td>
</tr>
<tr>
<td style="text-align:center;"> Short </td>
<td style="text-align:center;"> 16 </td>
<td style="text-align:left;"> -32768 (-2<sup>15</sup>) </td>
<td style="text-align:left;"> 32767 (2<sup>15</sup> - 1) </td>
</tr>
<tr>
<td style="text-align:center;"> Int </td>
<td style="text-align:center;"> 32 </td>
<td style="text-align:left;"> -2,147,483,648 (-2<sup>31</sup>) </td>
<td style="text-align:left;"> 2,147,483,647 (2<sup>31</sup> - 1) </td>
</tr>
<tr>
<td style="text-align:center;"> Long </td>
<td style="text-align:center;"> 64 </td>
<td style="text-align:left;"> -9,223,372,036,854,775,808 (-2<sup>63</sup>) </td>
<td style="text-align:left;"> 9,223,372,036,854,775,807 (2<sup>63</sup> - 1) </td>
</tr>
</tbody>
</table>


<p>当然了，每个类型都有其<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/-m-a-x_-v-a-l-u-e.html">最大值</a>和<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/-m-i-n_-v-a-l-u-e.html">最小值</a>的常量可以直接引用，不用自己手动写。另外需要注意的是非10进制的字面常量都是二的补码形式，并不是直观的二进制，详细的可以参考<a href="http://toughcoder.net/blog/2022/03/08/java-integer-basics/">另外一篇文章</a>。</p>

<h4>浮点数</h4>

<p>有Float和Double，它们的定义如下：</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> Type </th>
<th style="text-align:center;"> Size (bits) </th>
<th style="text-align:center;"> Significant bits </th>
<th style="text-align:center;"> Exponent bits </th>
<th style="text-align:center;"> Decimal digits </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> Float </td>
<td style="text-align:center;"> 32 </td>
<td style="text-align:center;"> 24 </td>
<td style="text-align:center;"> 8 </td>
<td style="text-align:center;"> 6-7 </td>
</tr>
<tr>
<td style="text-align:center;"> Double </td>
<td style="text-align:center;"> 64 </td>
<td style="text-align:center;"> 53 </td>
<td style="text-align:center;"> 11 </td>
<td style="text-align:center;"> 15-16 </td>
</tr>
</tbody>
</table>


<p><br/></p>

<h4>字面常量(Literals)</h4>

<p>字面常量是指直接写在代码中的数字，默认的是Int和Double，如果需要指定类型，可以用标记或者给变量指定类型，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">one</span> <span class="p">=</span> <span class="m">1</span> <span class="c1">// Int</span>
</span><span class='line'><span class="k">val</span> <span class="py">threeBillion</span> <span class="p">=</span> <span class="m">3000000000</span> <span class="c1">// Long, exceeding Int, so it is Long</span>
</span><span class='line'><span class="k">val</span> <span class="py">aLong</span> <span class="p">=</span> <span class="m">1L</span> <span class="c1">// mark it as Long</span>
</span><span class='line'><span class="k">val</span> <span class="py">oneByte</span><span class="p">:</span> <span class="n">Byte</span> <span class="p">=</span> <span class="m">1</span> <span class="c1">// Byte</span>
</span><span class='line'><span class="k">val</span> <span class="py">e</span> <span class="p">=</span> <span class="m">2.7182818284</span> <span class="c1">// Double</span>
</span><span class='line'><span class="k">val</span> <span class="py">eFloat</span> <span class="p">=</span> <span class="m">2.7182818284f</span> <span class="c1">// Float, actual value is 2.7182817</span>
</span></code></pre></td></tr></table></div></figure>


<p>常见的语法糖：</p>

<ul>
<li>浮点数可以用乘方形式如123.5e10</li>
<li>可以下划线(underscore)来加强可读性，如1_000_000</li>
<li>16进制用0x打头，如0xFF_AB</li>
<li>二进制用0b打头，如0b1101_1111</li>
</ul>


<h3>布尔类型(Booleans)</h3>

<h3>字符类型(Characters)</h3>

<p>用两个单引号来表示，如val ch = &lsquo; &rsquo;</p>

<p>需要注意因为字符是对象，所以不能直接与整数进行比较，需要转化为整数，这点不像Java，在Java中字符是可以直接与整数比较的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'>    <span class="k">val</span> <span class="py">map</span> <span class="p">=</span> <span class="n">CharArray</span><span class="p">(</span><span class="m">26</span><span class="p">)</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">index</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">ch</span> <span class="k">in</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(!</span><span class="n">ch</span><span class="p">.</span><span class="n">isLetter</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">continue</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">[</span><span class="n">ch</span> <span class="p">-</span> <span class="sc">&#39;a&#39;</span><span class="p">].</span><span class="n">toInt</span><span class="p">()</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">map</span><span class="p">[</span><span class="n">ch</span> <span class="p">-</span> <span class="sc">&#39;a&#39;</span><span class="p">]</span> <span class="p">=</span> <span class="sc">&#39;a&#39;</span> <span class="p">+</span> <span class="n">index</span>
</span><span class='line'>            <span class="n">index</span><span class="p">++</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">message</span><span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="n">it</span><span class="p">.</span><span class="n">isLetter</span><span class="p">())</span> <span class="n">map</span><span class="p">[</span><span class="n">it</span> <span class="p">-</span> <span class="sc">&#39;a&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="n">it</span> <span class="p">}</span>
</span><span class='line'>                <span class="p">.</span><span class="n">joinToString</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>字符串类型(Strings)</h3>

<p>可以视为字符的数组，是一个<strong>不可变对象(immutable object)</strong>，用两个双引号来表示，如</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">message</span> <span class="p">=</span> <span class="s">&quot;Hello, world&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>字符串拼接用<strong>加号+</strong>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">name</span> <span class="p">=</span> <span class="s">&quot;John&quot;</span>
</span><span class='line'><span class="k">val</span> <span class="py">message</span> <span class="p">=</span> <span class="s">&quot;Hello&quot;</span> <span class="p">+</span> <span class="n">name</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然了，直接用加号拼接效率不好，一般情况下可以直接用字符串模板更好一些。</p>

<h4>字符串模板</h4>

<p>这是一个强大且方便的内置功能，相当于简化版本的String.format，可以在字符串用<strong>美元符&#36;</strong>来引用一个变量的值，如果是有方法调用或者运算或者成员引用等情况可以加花括号：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">name</span> <span class="p">=</span> <span class="s">&quot;John&quot;</span>
</span><span class='line'><span class="k">val</span> <span class="py">message</span> <span class="p">=</span> <span class="s">&quot;Hello, $name&quot;</span>
</span><span class='line'><span class="n">println</span><span class="p">(</span><span class="s">&quot;Length is ${name.length}&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h4>字符遍历</h4>

<p>与Java不同的是，字符串在Kotlin里面更像是字符数组，或者说一个列表，因此可以直接遍历：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">mesage</span> <span class="p">=</span> <span class="s">&quot;The quick fox jumps over the lazy dog&quot;</span>
</span><span class='line'><span class="k">for</span> <span class="p">(</span><span class="n">ch</span> <span class="k">in</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="n">println</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>in</strong>是一个强大的操作符，可以用于集合的遍历。另外，字符串可以像列表一样进行函数式的操作，如判断是否包含某个字符：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="n">any</span> <span class="p">{</span><span class="n">it</span> <span class="p">==</span> <span class="n">ch</span><span class="p">})</span> <span class="p">{</span>
</span><span class='line'>   <span class="n">println</span><span class="p">(</span><span class="s">&quot;$ch is in $message&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3><a href="https://kotlinlang.org/docs/arrays.html">数组类型</a>(Arrays)</h3>

<p>数组Array<T>是一个具体类型为T的数组，这是通用的数组，另外还有一种就是基本数组类型数组，我们分别来看一下</p>

<h4>通用对象数组 Array&lt;T&gt;</h4>

<p>这是适用于所有对象的数组，有两种构造方式，一是通过arrayOf()，直接传入数组的具体值，另外就是用构造方法Array(size)</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">heights</span> <span class="p">=</span> <span class="n">arrayOf</span><span class="p">(</span><span class="m">240</span><span class="p">,</span> <span class="m">360</span><span class="p">,</span> <span class="m">480</span><span class="p">,</span> <span class="m">640</span><span class="p">)</span>
</span><span class='line'><span class="k">val</span> <span class="py">classes</span> <span class="p">=</span> <span class="n">arrayOf</span><span class="p">(</span><span class="s">&quot;John&quot;</span><span class="p">,</span> <span class="s">&quot;Harden&quot;</span><span class="p">,</span> <span class="s">&quot;Kevin&quot;</span><span class="p">,</span> <span class="s">&quot;Stephen&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">val</span> <span class="py">guards</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">Array</span><span class="p">(</span><span class="m">5</span><span class="p">)</span>
</span><span class='line'><span class="n">guards</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="s">&quot;Stephen&quot;</span>
</span><span class='line'><span class="n">guards</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="p">=</span> <span class="s">&quot;Kevin&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>还有一种用lambda方式来构造数组，可以非常方便的实现数组的定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">asc</span> <span class="p">=</span> <span class="n">Array</span><span class="p">(</span><span class="m">5</span><span class="p">)</span> <span class="p">{</span> <span class="n">i</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="n">i</span> <span class="p">*</span> <span class="n">i</span><span class="p">).</span><span class="n">toString</span><span class="p">()</span> <span class="p">}</span>
</span><span class='line'><span class="c1">// asc = [&quot;0&quot;, &quot;1&quot;, &quot;4&quot;, &quot;9&quot;, &quot;16&quot;]</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意的是这里的类型T都是对象。但其实，对于基础类型的数组，如果都box成为对象效率并不高，虽然Kotlin中并没有真的基础数据类型，但涉及到数组这种批量的数据时，使用基础类型能提升很大的效率，因此还有专门用于基础类型的数组类型。</p>

<h4>基础类型数组 IntArray和FloatArray</h4>

<p>其实有很多，基础的类型都有IntArray, ByteArray, ShortArray, FloatArray, DoubleArray。而且需要注意的是Array&lt;Int&gt;与IntArray是两个数组类型，它们并不一样，这个区别与Java中的Integer[]和int[]是类似的。而且IntArray与Array&lt;T&gt;也没什么关系，也不是什么继承关系。但是它们表现出来的使用方法是一样的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">val</span> <span class="py">heights</span> <span class="p">=</span> <span class="n">intArrayOf</span><span class="p">(</span><span class="m">240</span><span class="p">,</span> <span class="m">360</span><span class="p">,</span> <span class="m">480</span><span class="p">,</span> <span class="m">640</span><span class="p">)</span>
</span><span class='line'><span class="k">val</span> <span class="py">squares</span> <span class="p">=</span> <span class="n">IntArray</span><span class="p">(</span><span class="m">5</span><span class="p">)</span> <span class="p">{</span> <span class="n">i</span> <span class="p">-&gt;</span> <span class="n">i</span> <span class="p">*</span> <span class="n">i</span> <span class="p">}</span> <span class="c1">// [0, 1, 4, 9, 16]</span>
</span><span class='line'><span class="k">val</span> <span class="py">arr</span> <span class="p">=</span> <span class="n">IntArray</span><span class="p">(</span><span class="m">5</span><span class="p">)</span> <span class="p">{</span> <span class="m">42</span> <span class="p">}</span> <span class="c1">// [42, 42, 42, 42, 42]</span>
</span><span class='line'><span class="k">val</span> <span class="py">bundle</span> <span class="p">=</span> <span class="n">arrayOf</span><span class="p">(</span><span class="n">intArrayOf</span><span class="p">(</span><span class="m">1080</span><span class="p">,</span> <span class="m">720</span><span class="p">),</span> <span class="n">intArrayOf</span><span class="p">(</span><span class="m">1920</span><span class="p">,</span> <span class="m">1080</span><span class="p">))</span> <span class="c1">// bundle type is Array&lt;IntArray&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>运算操作符</h2>

<p>运算操作符与大部分语言是一样的。</p>

<h3>算术运算符</h3>

<p>也即是常规的算术操作符，<strong>+(加) -(减）&#42;(乘) /(除) %(取模)</strong>，这些都是二元操作符，也就是需要两个操作数才能使用。</p>

<p>还有单元操作符，如<strong>自增++自减&ndash;</strong>，当然也分前置和后置，区别与Java/C++中一样。</p>

<p>操作符与<strong>赋值符=</strong>可以配合一起使用，如a += b等同于a = a + b，a /= c等同于 a = a / c</p>

<h3>逻辑运算符</h3>

<p>双元操作符: <strong>&amp;&amp; 逻辑与，|| 逻辑或</strong>，它们的操作数必须 是布尔型，且返回值也是布尔。</p>

<p>与其他语言一样，这两个操作符是short-circiut的或者说是lazy的，也即a &amp;&amp; b，如果a是false，那就不去管b了，因为不影响结果；a || b也一样，如果a是true就不去管b了。</p>

<p>还有单元操作符<strong>! 逻辑非</strong>。一个有意思的地方在于，逻辑非可以与一些操作符合起来使用，而不是直接写在表达式之外，比如，下面两种写法等效：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">if</span> <span class="p">(!(</span><span class="n">a</span> <span class="k">in</span> <span class="n">asc</span><span class="p">))</span> <span class="p">{...}</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="p">!</span><span class="k">in</span> <span class="n">asc</span><span class="p">)</span> <span class="p">{...}</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="p">!</span><span class="k">is</span> <span class="n">Array</span><span class="p">)</span> <span class="p">{...}</span>
</span><span class='line'><span class="k">if</span> <span class="p">(!(</span><span class="n">b</span> <span class="k">is</span> <span class="n">Array</span><span class="p">))</span> <span class="p">{...}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>位运算符</h3>

<p>位运算符比较特殊，与大部分语言不一样。</p>

<h4>移位</h4>

<table>
<thead>
<tr>
<th style="text-align:center;"> 操作符 </th>
<th style="text-align:left;"> 含义 </th>
<th style="text-align:left;"> 示例 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> shr </td>
<td style="text-align:left;"> 向右移位 </td>
<td style="text-align:left;"> a shr 1 </td>
<td style="text-align:left;"> 把a向右移1位 </td>
</tr>
<tr>
<td style="text-align:center;"> shl </td>
<td style="text-align:left;"> 向左移位 </td>
<td style="text-align:left;"> a shl 1 </td>
<td style="text-align:left;"> a向左移1位 </td>
</tr>
<tr>
<td style="text-align:center;"> ushr </td>
<td style="text-align:left;"> 无符号向右移位 </td>
<td style="text-align:left;"> a ushr 1 </td>
<td style="text-align:left;"> （包含符号位）向右移1位 </td>
</tr>
</tbody>
</table>


<h4>按位逻辑运算</h4>

<table>
<thead>
<tr>
<th style="text-align:center;"> 操作符 </th>
<th style="text-align:left;"> 含义 </th>
<th style="text-align:left;"> 示例 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> and </td>
<td style="text-align:left;"> 按位与</td>
<td style="text-align:left;"> a and 1 </td>
<td style="text-align:left;"> a与1按位与 </td>
</tr>
<tr>
<td style="text-align:center;"> or </td>
<td style="text-align:left;"> 按位或 </td>
<td style="text-align:left;"> a or 1 </td>
<td style="text-align:left;"> a与1按位或 </td>
</tr>
<tr>
<td style="text-align:center;"> xor </td>
<td style="text-align:left;"> 按位异或 </td>
<td style="text-align:left;"> a xor 1 </td>
<td style="text-align:left;"> a与1按位异或 </td>
</tr>
<tr>
<td style="text-align:center;"> inv </td>
<td style="text-align:left;"> 按位取反 </td>
<td style="text-align:left;"> inv(a) </td>
<td style="text-align:left;"> 把a按位取反 </td>
</tr>
</tbody>
</table>


<p>这些操作符看起来可能比较怪，然后更怪异的是位运算操作符<strong>不能</strong>与<strong>赋值符=</strong>一起使用，只能这样写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="n">a</span> <span class="p">=</span> <span class="n">a</span> <span class="n">or</span> <span class="n">b</span>
</span><span class='line'><span class="n">c</span> <span class="p">=</span> <span class="n">c</span> <span class="n">xor</span> <span class="p">(</span><span class="m">1</span> <span class="n">shl</span> <span class="m">3</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>事实上位运算不是操作符，它们是一种函数，叫做<a href="https://kotlinlang.org/docs/functions.html#infix-notation">infix函数</a>，简写了把括号省略了，看起来就像操作符一样，但它们并不是操作符。</p>

<h3><a href="https://kotlinlang.org/docs/operator-overloading.html">运算符重载</a></h3>

<p>与C++中的运算符重载类似，Kotlin中支持运算符重载，本质上它们都是对象定义的方法，但支持重载为运算符。</p>

<p>比如说加法，a + b，可以写成方法调用的形式a.plus(b)；b or c等同于b.or&copy;，!a等同于a.not()。</p>

<h3>运算符的优先级</h3>

<p>尽管是有默认的优先级的，但<strong>强烈建议使用括号</strong>以减少歧义和增强可读性，更可以避免一些难以察觉的Bug。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/basic-types.html">Basic types﻿</a></li>
<li><a href="https://www.baeldung.com/kotlin/bitwise-operators">Using Bitwise Operators in Kotlin</a></li>
<li><a href="https://www.programiz.com/kotlin-programming/bitwise">Kotlin Bitwise and Bitshift Operations</a></li>
<li><a href="https://www.programiz.com/kotlin-programming/operators">Kotlin Operators</a></li>
<li><a href="https://www.tutorialspoint.com/kotlin/kotlin_operators.htm">Kotlin - Operators</a></li>
<li><a href="https://www.geeksforgeeks.org/kotlin-operators/">Kotlin Operators</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to WebSocket]]></title>
    <link href="http://toughcoder.net/blog/2023/01/14/introduction-to-websocket/"/>
    <updated>2023-01-14T18:02:12+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/14/introduction-to-websocket</id>
    <content type="html"><![CDATA[<p><a href="https://javascript.info/websocket">WebSocket</a>是HTML5带来的新时代网络通信协议，它让前端的能力再一次得到提升，因为通信不再是单向的了。最初<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">在浏览器和JavaScript</a>中有很好的支持，现在各种编程语言和平台都支持WebSocket协议了。今天就来学习一下它。</p>

<p><a href="http://toughcoder.net/blog/2023/01/14/introduction-to-websocket/"><img src="https://cdn.educba.com/academy/wp-content/uploads/2019/05/What-is-WebSocket.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>缘起</h2>

<p>在以往的前端中通过Ajax或者Jsonp可以让前端像一般的桌面客户端一样，有了更好的交互方式，但总的来说仍然局限于单向通信，因为底层的协议仍是HTTP，只能由客户端发起请求，服务器来响应。对于更新潮的需求，比如服务器向客户端推送消息，用HTTP来实现就略显笨拙了，常规的方法就是<a href="https://en.wikipedia.org/wiki/Comet_(programming">建立长链接</a>)或者让客户端来轮询（polling），但这显然效率不高。于是就有了<a href="https://en.wikipedia.org/wiki/WebSocket">WebSocket</a>，它支持双向通信（全双工通信信道），除了客户端主动发起请求外，服务器也可以主动向客户端推送消息。通信效率和交互性又一次得到了大大的提升。</p>

<p>就协议本身来说，它与HTTP一样，都是基于TCP实现的，对于协议本身想要深入了解的，可以去看<a href="https://www.rfc-editor.org/rfc/rfc6455">协议规范</a>。</p>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.b0ueeCtwidYP_RDzAWPVOgHaF_?pid=ImgDet&amp;rs=1" alt="" /></p>

<p>另外，需要注意，WebSocket协议的地址的schema是<strong>wss://xxxx</strong>。</p>

<h2>WebSocket in Android</h2>

<p>安卓平台也已经有了现成的WebSocket协议可以使用了，已经比较成熟了，直接使用就行了。</p>

<ul>
<li><a href="https://github.com/TooTallNate/Java-WebSocket">Java-WebSocket</a> 是一个WebSocket协议的纯Java实现，适用于所有JVM平台</li>
<li><a href="https://socket.io/">Socket.IO</a> 这个不单单是WebSocket，它在WebSocket协议基础之上又进行了进一步的封装，在API的易用性面以及错误处理和状态处理上面有了不少的提升。各种语言平台基本都有支持了。</li>
</ul>


<h2>测试服务器</h2>

<p>光有客户端还不够，还需要有测试服务器，整理一下如何搭建测试服务器。</p>

<h3>公有的测试服务器</h3>

<p>在线的免费的可公开使用的简单WebSocket服务器，一般都是echo式的，也即把请求的数据直接当成回复推给client，这个可以当作chat类的测试server。</p>

<ul>
<li><a href="wss://echo.websocket.org">wss://echo.websocket.org</a></li>
<li><a href="https://socketsbay.com/test-websockets">wss://socketsbay.com/wss/v2/1/demo/</a></li>
<li><a href="https://glitch.com/~websocket-echo">WebSocket on Glitch</a></li>
</ul>


<p><img src="https://quarkus.pro/guides/images/websocket-guide-architecture.png" alt="" /></p>

<h3>自已搭建服务器</h3>

<p>此外，就是用WebSocket服务端的组件来自己搭建服务器，当然也都有现成的组件，配置一下就可以了，只不过需要运行在自己的Server上面。</p>

<ul>
<li><a href="https://socket.io/">Socket.IO</a> 对的，这货Server端Client端全套都提供了</li>
<li><a href="https://github.com/uNetworking/uWebSockets">uWebSockets</a> 核心库是用C/C++实现的，可以与Node.js无缝衔接</li>
<li><a href="https://github.com/theturtle32/WebSocket-Node">WebSocket-Node</a> 基于Node.js，用纯JavaScript实现的</li>
<li><a href="http://websocketd.com/">websocketd</a> 一个独立的WebSocket Daemon，不依赖于其他的组件，功能强大，配置简单，方便使用，只需要提供一个Shell脚本就可以了</li>
<li><a href="https://github.com/jmalloc/echo-server">echo-server</a> 基于Go实现的，支持HTTP协议和WebSocket协议的echo server</li>
<li><a href="https://pypi.org/project/echo-server/">python echo server</a> 基于Python的echo server，不确定是否支持WebSocket</li>
<li><a href="https://echo.labstack.com/">Echo</a> 基于Go的Echo Web Frameworks</li>
<li><a href="https://github.com/websockets/websocket-echo-server">WebSocket echo server</a> 基于Node.js</li>
</ul>


<h2>参考资料</h2>

<ul>
<li><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">WebSocket 教程</a></li>
<li><a href="https://github.com/nkzawa/socket.io-android-chat">socket.io-android-chat</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/23467317">WebSocket 与 Socket.IO</a></li>
<li><a href="https://juejin.cn/post/6844903577438126094">Android WebSocket 编程</a></li>
<li><a href="https://www.jianshu.com/p/7b919910c892">Android WebSocket实现即时通讯功能</a></li>
<li><a href="https://www.jianshu.com/p/4e80b931cdea">Socket.io</a></li>
<li><a href="https://www.lob.com/blog/websocket-org-is-down-here-is-an-alternative">Websocket.org Is Down, Here Is an Alternative</a></li>
<li><a href="https://blog.postman.com/introducing-postman-websocket-echo-service/">Introducing Postman’s WebSocket Echo Service</a></li>
<li><a href="https://www.piesocket.com/blog/echo-websocket-org-alternative">An Alternative To Echo.WebSocket.Org – Live WebSocket Server
</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding RxJava]]></title>
    <link href="http://toughcoder.net/blog/2023/01/12/understanding-rxjava/"/>
    <updated>2023-01-12T17:26:41+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/12/understanding-rxjava</id>
    <content type="html"><![CDATA[<p>RxJava不仅仅是一个函数库，它是响应式编程范式的一个JVM实现，所以准确的来说RxJava是一种编程范式。而且它的学习曲线非常之陡峭，必须充分理解它背后的编程思想，才能真正算使用它。</p>

<p><a href="http://toughcoder.net/blog/2023/01/12/understanding-rxjava/"><img src="https://i0.wp.com/ayusch.com/wp-content/uploads/2018/12/featured.png?w=1686" title="auto auto" ></a></p>

<!-- more -->


<h2>理解<a href="https://reactivex.io/">ReactiveExtensions</a></h2>

<p>Rx的核心思想是两个方面，一是数据流，把一切看成数据流，只需要关心数据来了如何响应；二是异步，也就是说不会立马得到结果。需要做的就是搭建好处理数据流的管道和定义数据最终的响应方式，其他的交给Rx内部去处理。</p>

<h3><a href="https://en.wikipedia.org/wiki/Functional_programming">Functional Programming</a></h3>

<p>函数式编程是以函数为核心来构建程序，通过不同的函数的不同形式的组合来作为主要解决方案。
这是从另外的角度来看待问题。程序如果只写出来，做了静态意义上的区分 是没有意义的，程序必须 运行起来 才有价值。函数式编程更加注重程序的运行，程序运行的基本单元是什么？函数，任何程序都是从一个叫主函数开始，一层一层的调用，所以函数式编程思考问题时的基本单元是函数，至于数据则以参数形式在函数之间传递。以函数为核心带来的好处是，让异步变得容易 。</p>

<h3><a href="https://en.wikipedia.org/wiki/Reactive_programming">Reactive Programming</a></h3>

<p>大部分编程思想是以控制流为核心(flow of control)，而响应式核心是数据流(data flow)为核心，再加上异步。并不关心程序的控制，只关心数据如何流动，以及当数据来了时如何响应，以及对数据如何处理。</p>

<h3><a href="https://en.wikipedia.org/wiki/Functional_reactive_programming">Functional Reactive Programming</a></h3>

<p>综合函数式和响应式，主要还是数据流，只不过以函数式的方式来处理数据流，并且都是异步形式。</p>

<h3>什么是异步</h3>

<p>这个也要理解 一下。异步与同步是一个程序执行顺序上的概念，而非具体的编程技术。同步，也就是说一坨一坨的代码是自上而下的执行，或者说函数是按照书写时的调用顺序，顺序 的执行。最明显的就是调用一个函数，你会等待函数执行完毕，然后拿到返回结果。
当然 ，这次并不是绝对的自上而下，编译器在保证取值正确的前提下，会进行指令重排的，但是当涉及取值时，会保证自上而下时的顺序。</p>

<p>而异步，则是说代码的执行，特别是函数 的执行，并不是按照你书写时的顺序 执行的。比如消息发布，虽然a先发布消息，b后发布了消息，但是仍然 可能b的消息先被收到。这就是异步。或者说两个函数分别被两个线程执行，就能并行。这也是异步。
最明显的就是函数调用，如果函数执行是异步的，你会立即 返回，拿不到执行结果，而函数的执行结果会在另外的不确定的时间通知给你。
多线程或者多进程，或者叫做并发
这是实现异步的一个方式。但是多线程并不一定就能实现异步，比如有太多的共享资源时，就需要做同步锁等待，其实这是在同步，你的效率并未得到提高。要想充分并发，必须 先做到异步，然后才能最大限度 的利用并发来提高性能。</p>

<h2>Thinking in RxJava</h2>

<h3>Architect with <a href="https://learn.microsoft.com/en-us/dotnet/architecture/maui/mvvm">MVVM</a></h3>

<p>软件架构方式从<a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a>到MVP，再到MVVM，其实是并无本质上的区别，都是为了能把数据，业务逻辑和UI区分开来，进行解耦。而MVVM强调UI要响应数据进行自动更新，与Reactive的核心思想是一致的，因此Reactive界更习惯使用MVVM来作为架构方式。
因为RxJava是Reactive的模式，也就是说它的核心思想是Reactive，是push based数据流方式。
因此，比较适合MVVM方式，因为ViewModel的存在就是为了接收数据，然后它负责主动去刷新View。
具体架构原则与方式还需要进一步总结。</p>

<h3>设计原则</h3>

<h4>不可变性<a href="https://en.wikipedia.org/wiki/Immutable_object">Immutable object</a></h4>

<p>数据要是纯数据类型，且是Immutable的，简单言之，数据对象所有的域都应该是final的，对象提供的方法只有getters，以及构造方法。一定不能让对象有改变自身状态的方法，这是为了保持immutability，管道计算过程中，当有状态发生变化时，需要创建一个新的对象，基于原对象，做些状态变化，然后生成一个新的对象。</p>

<p>存储时，只需要存储原始数据即可，中间使用的数据和状态，也即是可以通过从原始数据 计算得到的数据和状态，不需要存储，这实际上就是搭建的管道的目的啊。</p>

<h4>函数要无副作用和幂等</h4>

<p>函数与方法，要是纯函数，也就是说接受一些参数输入，然后产生一些输出，不能有副作用，不能对函数定义范围外的状态和变量产生依赖。而且要幂等，也就说给定同一个参数，多次调用，得到的结果都是一样的。</p>

<p>一个Observable实例只能被subscribe一次，一旦被subscribe，就代表着管道到达了终点，数据到此结束不会继续流动了。当subscribe了后，即使你再把这个Observable接到另外的Observable上面去，它也不会再向后面的管道(Observable)发射数据。这个需要特别注意，subscribe一定是要在最后做的事情。
如果需要subscribe两次，说明你需要不同的数据，要不然不合逻辑，如果是同数据类型，你只需要在一个subscibe做多件事情就可以了（比如刷新两个View），即使是需要不同的数据，那么就需要搭建管道进行计算，而一旦通过了operator，就会产生一个新的Observable实例（这也是为啥能连用很多点的原因，它每个operator都返回一个新的实例），因为是新的实例，所以也就可以再次subscribe。这实际上是相当于给原管道接出分支，源头数据会通过分支进行流动。</p>

<p>Immutable数据加上纯函数，一起就可以保证线程安全，你在operator过程中切换线程是很安全的。但如果你在函数中有依赖其他全局变量，那么结果将会是灾难性的。</p>

<p>依赖的原则是，ViewModel只知道Model，Model只知道Store，注意反过来不行（Store不知道Model，Model也不知道ViewModel）。它们的输出都是Observable，因此从上到下是直接依赖，通过提供的方法或者operator，而反向的反馈则是通过Observable本身。具体的，ViewModel调用Model的方法，或者直接通过operator来使用Model，反向的反馈则是通过Model给出的Observable，Model不能直接返回基本的数据对象；同理Model与Store之间也是如此。</p>

<p>ViewModel以及，Model和Store都要纯粹一些，不能有平台的依赖，目的就是为了方便测试。平台的依赖，要从外部传入。Activity或者Service，这些重要的组件，干的就是Container和组织者的身份，它创建ViewModel，Model以及Store所需要的输入，然后创建这些对象，并把它们拼装在一起，管理它们的生命周期。至于平台依赖，这些东西与Reactive也并不冲突啊，把它们封装好了后，接入Store即可了。</p>

<p>一些简单的逻辑可能直接在Container中写了也是可以的，没必要非要传入ViewModel。</p>

<h2>推荐书籍</h2>

<h3><a href="https://www.manning.com/books/rxjava-for-android-developers">《RxJava for Android Developers》</a></h3>

<p>这本书的侧重点在于Reactive，而非RxJava，它有大量的项目实例，来展示如何用Reactive的思想构建和架构一个项目。它关于RxJava本身介绍的不多，远不及文档详细，但它的重点在于项目，如何用纯Reactive的方式来架构一个项目，并且项目都是真实可运行的。书中的示例，以章节为单位，每一章都是一个完整的项目，所以它也不光涉及RxJava，也会包含一些其他的，如网络库等等。</p>

<p>对于如何把握RxJava的核心精髓，以及如何以Reactive的方式来构建一个项目，这本书是相当不错的参考。</p>

<p>这本书读起来也是相当的费劲，有二方面原因，一是它毕竟都是活生生的项目，而项目必然会涉及除RxJava以外的东西，如项目本身的业务逻辑，以及像网络库等等，这些东西与书的主题并不直接相关，都没有详细的讲解，这就非常影响对章节的整体的理解程度；另外一个原因，就是书中的前后流畅度不好，每一章节都是一步步的向你展示 如何用Reactive方式从零构建 一个项目，也就是说项目代码有迭代，但是它总是前后对应不上，比如说文字部分说某某个方法或者函数，与书中给出的代码片断对应不上，而书中的代码片断全连在一起，也不是完整的，且与代码示例包中的代码也对应不上，代码是有迭代的，代码示例包中肯定是最终的代码，但是书中的文字以及书中的代码片断都是迭代过程中的。这就导致读起来相当的费劲，前后对应不上，有时候不得不直接把源码翻出来看，但它与书中的描述也对应不上。</p>

<p>从这里，也可以看出编程书籍的无奈，特别是以完整项目为示例的书籍，因为项目必然会有迭代的过程，小步迭代，每一步都能run是比较好的迭代方式，而且项目当中必然会有大量的编程工具生成的一些冗余代码。那么，摆在作者面前就是一个难题，如何把代码与文字更好的结合在一起。很多差劲的作者会把项目完整代码全贴在书中，这是相当差劲的作法，虽然说足够完整，但是代码会占用大量的篇幅，项目中的有大量的代码也是编程工具生成的冗余 代码，更会占用大量的篇幅，这纯是凑字数的做法。另外的做法，就是像这本书的作者这样，书中仅贴出一些关键的代码片断，完整的代码要去找书的示例源码包。前提是读者要能非常容易的获得到源码包。</p>

<p>但是，为了更好的理解，因为读者读书的时候，可能不能方便的查看示例源码包，所以 书中的章节要与关键代码片断要做好流畅性，前后要能对应得起来。然后示例源码包中，最好分成几批，以展示项目的迭代过程。</p>

<p>这本书，终于读完了，还是比较费劲的，花了远超当时预估 的时间，但仍不够，对于Reactive的思想把握仍不够。书中的示例确实很好，值得继续重构和优化，以作为实践。</p>

<h3><a href="https://www.amazon.com/Functional-Reactive-Programming-Stephen-Blackheath/dp/1633430103">《Functional Reactive Programming》</a></h3>

<p>这是第一本详细论述FRP编程范式的书，值得详细研读，而且非常棒的是这本书有在线版本的，可以<a href="https://livebook.manning.com/book/functional-reactive-programming/table-of-contents/">直接在线阅读</a>。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/rxjava-for-android/">RxJava For Android</a></li>
<li><a href="https://www.codingdojo.com/blog/what-is-functional-programming">What Is Functional Programming and Why Use It?</a></li>
<li><a href="https://www.geeksforgeeks.org/functional-programming-paradigm/">Functional Programming Paradigm</a></li>
<li><a href="https://www.techtarget.com/searchapparchitecture/definition/reactive-programming">reactive programming</a></li>
<li><a href="https://developers.redhat.com/blog/2017/06/30/5-things-to-know-about-reactive-programming">5 Things to Know About Reactive Programming</a></li>
<li><a href="https://www.freecodecamp.org/news/functional-reactive-programming-frp-imperative-vs-declarative-vs-reactive-style-84878272c77f/">A quick introduction to Functional Reactive Programming (FRP)</a></li>
<li><a href="https://blog.danlew.net/2017/07/27/an-introduction-to-functional-reactive-programming/">An Introduction to Functional Reactive Programming</a></li>
<li><a href="https://learn.microsoft.com/en-us/xamarin/xamarin-forms/enterprise-application-patterns/mvvm">The Model-View-ViewModel Pattern</a></li>
<li><a href="https://www.geeksforgeeks.org/introduction-to-model-view-view-model-mvvm/">Introduction to Model View View Model (MVVM)</a></li>
<li><a href="https://tech.meituan.com/2016/11/11/android-mvvm.html">如何构建Android MVVM 应用框架</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html">MVC，MVP 和 MVVM 的图示</a></li>
<li><a href="https://www.infoq.cn/article/rethinking-mvc-mvvm">被误解的 MVC 和被神化的 MVVM</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Glossary/MVC">MVC</a></li>
<li><a href="https://www.geeksforgeeks.org/mvc-framework-introduction/">MVC Framework Introduction</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding the Observer Pattern]]></title>
    <link href="http://toughcoder.net/blog/2023/01/11/understanding-observer-pattern/"/>
    <updated>2023-01-11T22:21:24+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/11/understanding-observer-pattern</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Observer_pattern">观察者模式</a>是用于解耦的，把不同功能的类，而又对某一共同事件或者消息感兴趣解耦开来，使双方互不知道对方。常规的实现是通过接口的方式来把需要关注的消息封装起来，双方各自实现接口即可。</p>

<p><a href="http://toughcoder.net/blog/2023/01/11/understanding-observer-pattern/"><img src="https://i1.wp.com/www.jeremyshanks.com/wp-content/uploads/2018/04/The-Observer-Pattern.jpg?fit=750%2C750" title="auto auto" ></a></p>

<!-- more -->


<h2>理解观察者模式</h2>

<h3>什么是观察者模式</h3>

<p>观察者模式<a href="https://en.wikipedia.org/wiki/Observer_pattern">Observer pattern</a>用于解耦消息发布或者状态发布的，对象之间有消息依赖的一种设计模式。消息发布者，或者说被关注者称之为主体(Subject)，它会不定时的更新消息和状态，希望接收到消息和状态变化的称为观察者(Observer)。用接口来隔离主题对象（被关注者）和观察者，观察者被动接收来自主题的变化，然后更新自己的状态。</p>

<p><img src="https://www.researchgate.net/profile/Michael-Perscheid/publication/224198176/figure/fig2/AS:667774309388288@1536221210042/Observer-pattern-running-example.png" alt="" /></p>

<p>通常也被称作为发布-订阅者模式因为它与生活中的报纸杂志订阅非常的类似，用户（Subscriber）向发行商(Publisher)订阅，当有新的期刊来了时，发行商会邮寄给用户。发行商称之为Subject或者Publisher，用户称之为Observer或者Subscriber，添加订阅称作Subscription，邮寄新期刊称之为notify。</p>

<p>Subject持有一个Observer的列表，提供三个接口：添加订阅(attach或者addObserver)，取消订阅detach或者removeObserver)和通知更新(notify)，Observer则有一个更新(update)。</p>

<p>订阅 关系建立后，当有新的数据或者状态需要更新时，Subject就会调用notify接口来实现状态的发布。</p>

<h3>观察者模式的示例</h3>

<p>对于大部分编程语言来说都提供了观察者模式的接口，比如Java中就可以直接用java.util.Observable和java.util.Observer来实现。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">import</span> <span class="nn">java.util.Observable</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">java.util.Observer</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">java.util.Random</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestDriver</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">final</span> <span class="n">MusicTeacher</span> <span class="n">teacher</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">MusicTeacher</span><span class="o">();</span>
</span><span class='line'>        <span class="kd">final</span> <span class="n">Student</span> <span class="n">tommy</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Student</span><span class="o">(</span><span class="s">&quot;Tommy&quot;</span><span class="o">,</span> <span class="n">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">tommy</span><span class="o">));</span>
</span><span class='line'>        <span class="kd">final</span> <span class="n">Student</span> <span class="n">jimmy</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Student</span><span class="o">(</span><span class="s">&quot;Jimmy&quot;</span><span class="o">,</span> <span class="n">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">jimmy</span><span class="o">));</span>
</span><span class='line'>        <span class="kd">final</span> <span class="n">Student</span> <span class="n">george</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Student</span><span class="o">(</span><span class="s">&quot;George&quot;</span><span class="o">,</span> <span class="n">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">george</span><span class="o">));</span>
</span><span class='line'>        <span class="n">teacher</span><span class="o">.</span><span class="na">addObserver</span><span class="o">(</span><span class="n">tommy</span><span class="o">);</span>
</span><span class='line'>        <span class="n">teacher</span><span class="o">.</span><span class="na">addObserver</span><span class="o">(</span><span class="n">jimmy</span><span class="o">);</span>
</span><span class='line'>        <span class="n">teacher</span><span class="o">.</span><span class="na">addObserver</span><span class="o">(</span><span class="n">george</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">teacher</span><span class="o">.</span><span class="na">singWithMe</span><span class="o">();</span>
</span><span class='line'>        <span class="n">teacher</span><span class="o">.</span><span class="na">singWithMe</span><span class="o">();</span>
</span><span class='line'>        <span class="n">teacher</span><span class="o">.</span><span class="na">singWithMe</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">class</span> <span class="nc">MusicTeacher</span> <span class="kd">extends</span> <span class="n">Observable</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span><span class="o">[]</span> <span class="n">songs</span> <span class="o">=</span> <span class="o">{</span>
</span><span class='line'>            <span class="s">&quot;\tTwinkle twinkle little star,\n\tHow I wonder what you are.&quot;</span><span class="o">,</span>
</span><span class='line'>            <span class="s">&quot;\tJohnny Johnny?\n\tYes papa.\n\tEating sugar?\n\tNo papa.&quot;</span><span class="o">,</span>
</span><span class='line'>            <span class="s">&quot;\tHumpty dumpty sat on wall,\n\tHumpty dumpty had a great fall.&quot;</span><span class="o">,</span>
</span><span class='line'>            <span class="s">&quot;\tOne two three four five,\n\tOnce I caught a fish alive.&quot;</span>
</span><span class='line'>    <span class="o">};</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Random</span> <span class="n">random</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">MusicTeacher</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Random</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">());</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">singWithMe</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">setChanged</span><span class="o">();</span>
</span><span class='line'>        <span class="n">notifyObservers</span><span class="o">(</span><span class="n">songs</span><span class="o">[</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">songs</span><span class="o">.</span><span class="na">length</span><span class="o">)]);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">class</span> <span class="nc">Student</span> <span class="kd">implements</span> <span class="n">Observer</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Student</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="n">Observable</span> <span class="n">observable</span><span class="o">,</span> <span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">&quot;:\n&quot;</span> <span class="o">+</span> <span class="n">o</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>常规的实现是这样的，在代码层面有直接的依赖，也就是说Observable与Observer相互知道对方的存在，且代码上面有直接的编译依赖关系。并且一般也都是同步的，状态变化 后Subject会直接发出通知，以更新Observer。</p>

<h3>什么时候用观察者模式</h3>

<p>观察者模式的特点是『一对多』，主体只有一个，向多个观察者发布状态更新，这是它最主要的特点。另外就是，它最主要的作用是解耦 这种『一对多』状态更新关系。所以，当需要解决这种『一对多』状态更新的问题时就可以使用观察者模式。</p>

<p>厘清问题，找到主体Subject，再找到Observer，然后分别实现对应的接口即可。</p>

<h2>发布-订阅模式</h2>

<p>随着软件越来越复杂，比如组件的出现，多中间件的出现，远程（服务器客户端），并发和多线程多进程的出现，使得观察者模式也有了新的样式，比如Subject和Observer可以不会有直接依赖关系，或者都依赖于一个中间组件，比如一些Event-Bus系统，以及消息的更新与通知都是异步的。
这时就是出现了发布-订阅者模式（<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">Publish-Subscrib pattern</a>）。
向外发布消息的叫Publisher，它与Observable类似，但最重要的区别在于，Publisher并不知道Subscriber的存在，它是直接像一个第三方的消息队列，或者叫做消息平台，发布消息。而Subscriber，也不知道Publisher的存在，是直接向消息队列或者消息平台订阅。</p>

<p>它的特点是：</p>

<ul>
<li>组件间，甚至是不同的应用之间，不同的端之间的消息发布模型。</li>
<li>都是异步的，就说是发布者是往消息队列发消息，然后就算发布完成了。订阅者是从消息队列拿消息。Publisher与Subscriber之间并无同步关系。一个消息发布出去，接收时间不确定。</li>
<li>对应该关系自由，可以多对多，也可以多对一或者一对多。</li>
<li>支持并发。</li>
</ul>


<p>安卓里面非常著名的EventBus就是这一模式的经典实现。以及Linux世界里的dbus也是这种。</p>

<p>关于观察者模式与发布者模式区别可以看<a href="https://hackernoon.com/observer-vs-pub-sub-pattern-50d3b27f838c">这篇文章</a>。</p>

<h2>生产者消费者问题</h2>

<p>再有一个比较类似的就是生产者和消费者问题(<a href="https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem">Producer consumer problem</a>）主要是涉及多线程和同步问题。</p>

<h2>参考资料</h2>

<ul>
<li><a href="http://www.ni.com/tutorial/3023/zhs/">LabVIEW​之​生产​者/​消费​者​架构</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/how-to-implement-a-producer-consumer-dataflow-pattern">How to: Implement a producer-consumer dataflow pattern</a></li>
<li><a href="https://dzone.com/articles/producer-consumer-pattern">The Producer Consumer Pattern</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/standard/events/observer-design-pattern">Observer Design Pattern</a></li>
<li><a href="https://www.tutorialspoint.com/design_pattern/observer_pattern.htm">Design Patterns - Observer Pattern</a></li>
<li><a href="https://www.geeksforgeeks.org/observer-pattern-set-1-introduction/?ref=lbp">Observer Pattern | Set 1 (Introduction)</a></li>
<li><a href="https://refactoring.guru/design-patterns/observer">Observer</a></li>
<li><a href="https://blog.csdn.net/itachi85/article/details/50773358">设计模式（五）观察者模式</a></li>
<li><a href="https://www.oreilly.com/library/view/learning-javascript-design/9781449334840/ch09s05.html">The Observer Pattern</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber">Publisher-Subscriber pattern</a></li>
<li><a href="https://www.enjoyalgorithms.com/blog/publisher-subscriber-pattern">Publisher-Subscriber</a></li>
<li><a href="https://www.educative.io/answers/what-is-the-producer-consumer-problem">What is the Producer-Consumer problem?</a></li>
<li><a href="https://www.javatpoint.com/producer-consumer-problem-in-os">Producer-Consumer problem</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Upgrade to RxJava 3]]></title>
    <link href="http://toughcoder.net/blog/2023/01/10/upgrade-to-rxjava-3/"/>
    <updated>2023-01-10T21:36:44+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/10/upgrade-to-rxjava-3</id>
    <content type="html"><![CDATA[<p>RxJava从2015年问世，2016到2017开始流行，在2018到2019左右达到顶峰，几乎无人不会RxJava，无项目不用RxJava。这期间项目本身也在迭代，从1.0版本，到2.0版本，行业内流行最广的，用的人最多的，项目使用也最多的仍是2.0版本。时过境迁，现在虽然RxJava是一个项目的标配，但是现在它的受关注度，没有前几年高了，但仍有必要研究一下它的最新版本RxJava 3。</p>

<p><a href="http://toughcoder.net/blog/2023/01/10/upgrade-to-rxjava-3/"><img src="https://i0.wp.com/blog.mallow-tech.com/wp-content/uploads/2017/03/Multithreading-with-rxjava.png?fit=820%2C400&ssl=1" title="auto auto" ></a></p>

<!-- more -->


<h2><a href="https://github.com/ReactiveX/RxJava">RxJava</a>的前世今生</h2>

<p>RxJava从诞生致今一共有三个大版本，区别都比较明显。最初是RxJava 1.0版本，它的特点是异步和数据流，核心思想仍是这些，但其它与<a href="https://reactivex.io/">Reactive Extensions</a>基本上是同步在迭代的，因此RxJava 1并不是完全符合Reactive Extensions规范的，并且它是基于Java 6.0语言的，对一些新的Java特性的支持并不好。</p>

<p>后来Rx编程范式渐渐流行起来，以及Java语言本身的发现，所以就有了RxJava 2.0，它是Reactive Extensions的一个标准实现，也就是说从RxJava 2.0开始，是完全符合Rx规范的。RxJava 2.0版本并不是基于1.0版本的迭代，而是完全重写的，基于Rx规范从新实现的。对一些东西如函数的定义，以及像方法的名字都进行了规范化。这也是流行最广泛的一个版本，坊间绝大多数资料都是基于RxJava 2的，很多其他三方的开源库，如RxAndroid等也都基于此。</p>

<p>RxJava 2.0版本有单独的groudId是<strong>io.reactivex.rxjava2</strong>，可以用以区分。</p>

<h2>RxJava 3.0</h2>

<p>技术仍在不断的演进，RxJava最新的版本是3.0，它是基于2.0的迭代，并没有像1.0到2.0那样完全重写。主要的变化 是更加符合Rx规范，性能进一步的提高。1.0和2.0都已停止维护了。它也有单独的groudId是<strong>io.reactivex.rxjava3</strong>，可以与2.0进行区分。</p>

<h3>包结构变化</h3>

<p>代码层面的包名是有明显变化的，对代码进行了更好的组织。1.0和2.0都是在io.reactivex，到了3.0组件都有了单独的package。</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> Component </th>
<th style="text-align:left;"> RxJava 2 </th>
<th style="text-align:left;"> RxJava 3 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> Core </td>
<td style="text-align:left;"> io.reactivex </td>
<td style="text-align:left;"> io.reactivex.rxjava3.core </td>
</tr>
<tr>
<td style="text-align:center;"> Annotations </td>
<td style="text-align:left;"> io.reactivex.annotations </td>
<td style="text-align:left;"> io.reactivex.rxjava3.annotations </td>
</tr>
<tr>
<td style="text-align:center;"> Disposables </td>
<td style="text-align:left;"> io.reactivex.disposables </td>
<td style="text-align:left;"> io.reactivex.rxjava3.disposables </td>
</tr>
<tr>
<td style="text-align:center;"> Exceptions </td>
<td style="text-align:left;"> io.reactivex.exceptions </td>
<td style="text-align:left;"> io.reactivex.rxjava3.exceptions </td>
</tr>
<tr>
<td style="text-align:center;"> Functions </td>
<td style="text-align:left;"> io.reactivex.functions </td>
<td style="text-align:left;"> io.reactivex.rxjava3.functions </td>
</tr>
<tr>
<td style="text-align:center;"> Flowables </td>
<td style="text-align:left;"> io.reactivex.flowables </td>
<td style="text-align:left;"> io.reactivex.rxjava3.flowables </td>
</tr>
<tr>
<td style="text-align:center;"> Observables </td>
<td style="text-align:left;"> io.reactivex.observables </td>
<td style="text-align:left;"> io.reactivex.rxjava3.observables </td>
</tr>
<tr>
<td style="text-align:center;"> Subjects </td>
<td style="text-align:left;"> io.reactivex.subjects </td>
<td style="text-align:left;"> io.reactivex.rxjava3.subjects </td>
</tr>
<tr>
<td style="text-align:center;"> Processors </td>
<td style="text-align:left;"> io.reactivex.processors </td>
<td style="text-align:left;"> io.reactivex.rxjava3.processors </td>
</tr>
<tr>
<td style="text-align:center;"> Observers </td>
<td style="text-align:left;"> io.reactivex.observers </td>
<td style="text-align:left;"> io.reactivex.rxjava3.observers </td>
</tr>
<tr>
<td style="text-align:center;"> Subscribers </td>
<td style="text-align:left;"> io.reactivex.subscribers </td>
<td style="text-align:left;"> io.reactivex.rxjava3.subscribers </td>
</tr>
<tr>
<td style="text-align:center;"> Parallel </td>
<td style="text-align:left;"> io.reactivex.parallel </td>
<td style="text-align:left;"> io.reactivex.rxjava3.parallel </td>
</tr>
<tr>
<td style="text-align:center;"> Internal </td>
<td style="text-align:left;"> io.reactivex.internal </td>
<td style="text-align:left;"> io.reactivex.rxjava3.internal </td>
</tr>
</tbody>
</table>


<p>使用起来更加的清晰和规范，并且不与老版本有冲突。</p>

<h3>与Java 8更好的融合</h3>

<p>另外一个重大改进就是与新版本的Java，即Java 8有了更好的融合，支持了好多Java 8中的数据类型。比如Optional和Stream：</p>

<ul>
<li>Observable.fromOptional()</li>
<li>Observable.fromStream</li>
<li>Observable.mapOptional</li>
<li>Observable.blockingStream</li>
<li>Observable.flatMapStream</li>
</ul>


<h3>行为变化</h3>

<p>因为RxJava 2.0是符合Rx规范的，所以大部分功能和核心概念在3.0上面是没有变化的。只有在一些高级的概念上面有一些差别，比如错误处理有加强，以前在2.0时有些error会丢失，并且不会被处理，3.0上加强了error的流动，保证它能到达Subscriber。</p>

<p>另外一个重要变化 就是在multicast，也即针对Hot Observables的共享问题，多了一个reset方法，以让所有Subscriber都接收到同样的数据。</p>

<p>还有就是Flowable有了pause的功能。</p>

<h3>三方库的兼容</h3>

<p>还要注意三方库如Retrofit adapter，RxAndroid以及RxBinding等也是与RxJava的版本绑定的，要注意它们之间版本的匹配。</p>

<h2>升级建议</h2>

<p>因为RxJava 1并不完全符合Rx规范，所以如果还在用RxJava 1，那么是要立即升级到3.0。</p>

<p>因为RxJava 2.0是最流行的版本，所以现在大部分项目使用的应该是RxJava 2.0。那么就要看项目本身的情况，如果RxJava 2.0能完全满足项目的需要，没有用到太多高级的特性（如multicast或者Flowable），而且项目中重点引用RxJava的部分也基本上成成熟了，此种情况下，其实不建议升级到3.0，因为不会带来多少收益。</p>

<p>相反，如果使用了大量的高级特性，甚至还遇到了RxJava本身导致的问题，并且项目中还在大量使用RxJava，未来新功能的开发也会使用RxJava，那么还是尽早升级为妙。同时要注意，RxJava是一个流行的库，有很多三方库的依赖于它，版本一旦变动，会引发链式反应，要注意版本的匹配，以免发生不兼容的情况。</p>

<p>可以到这里找到<a href="https://github.com/ReactiveX/RxJava/releases">最新的版本</a>。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://github.com/ReactiveX/RxJava/wiki/What's-different-in-3.0">What&rsquo;s different in 3.0</a></li>
<li><a href="https://prog.world/whats-new-in-rxjava-3/#:~:text=There%20was%20a%20problem%20with%20hot%20sources%20in,to%20enable%20newly%20connected%20subscribers%20to%20process%20data.">What’s New in RxJava 3</a></li>
<li><a href="https://stackoverflow.com/questions/38423079/differences-between-rxjava1-and-rxjava2">Differences between RxJava1 and RxJava2</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数学相关题目]]></title>
    <link href="http://toughcoder.net/blog/2023/01/09/mathematics-problem-set/"/>
    <updated>2023-01-09T22:03:57+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/09/mathematics-problem-set</id>
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6/107037">数学</a>是自然科学之母，数学也是算法之母，有一些数学相关的题目需要总结一下。当然暴力法也都是可以解决的，但是通过数学一些公式的引入会提升时间效率。</p>

<p><a href="http://toughcoder.net/blog/2023/01/09/mathematics-problem-set/"><img src="https://ts1.cn.mm.bing.net/th/id/R-C.ba01d095b9f9a650e61d8f49d2b28519?rik=rVVFOj18ozgpZw&riu=http%3a%2f%2fwww.pixelstalk.net%2fwp-content%2fuploads%2f2016%2f05%2fMath-Mathematics-Formula-Wallpaper-for-PC.jpg&ehk=%2bfTho6j8Ym8wGaYhOjf%2bGXs56O7AyL38fNlEbHjIzqQ%3d&risl=&pid=ImgRaw&r=0" title="auto auto" ></a></p>

<!-- more -->


<h2>数学题目的特点</h2>

<p>用暴力法或者模拟法也可以解决。</p>

<p>运用相关的数学知识或者数学公式，可以提升效率。</p>

<p>一般都可以使用查表大法。</p>

<h2>数论</h2>

<p>主要是以整数为基础的一些题目，一般会涉及素数，数位等。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/ugly-number-ii/">264. 丑数 II</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/ugly-number-ii/solution/xi-you-yuan-su-264-chou-shu-iizui-xiao-d-e7sj/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/add-digits/">258. 各位相加</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/add-digits/solution/by-alexhilton-uehk/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/prime-arrangements/">1175. 质数排列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/prime-arrangements/solution/by-alexhilton-p5rj/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/count-integers-with-even-digit-sum/">2180. 统计各位数字之和为偶数的整数个数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/count-integers-with-even-digit-sum/solution/2180-tong-ji-ge-wei-shu-zi-zhi-he-wei-ou-mc2e/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>数组轮转</h2>

<p>一般就是把数组的元素按照一定的规则进行移动和轮转。一般涉及LCM（最小公倍数）。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotate-array/solution/189-lun-zhuan-shu-zu-by-alexhilton-1ih4/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/">918. 环形子数组的最大和</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/solution/xi-you-yuan-su-918-huan-xing-zi-shu-zu-d-mtqb/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/minimum-number-of-operations-to-reinitialize-a-permutation/">1806. 还原排列的最少操作步数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/minimum-number-of-operations-to-reinitialize-a-permutation/solution/1806-huan-yuan-pai-lie-de-zui-shao-cao-z-mqq1/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>矩阵</h2>

<p>矩阵在数学中是非常重要的概念，在计算机科学中矩阵也是非常的重要，像在图形图像以及人工智能领域矩阵都有非常重要的应用。矩阵在编程语言中的表示也非常的容易一般用一个二维数组就可以表示一个矩阵。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotate-array/solution/189-lun-zhuan-shu-zu-by-alexhilton-1ih4/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/minimum-number-of-operations-to-reinitialize-a-permutation/">1806. 还原排列的最少操作步数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/minimum-number-of-operations-to-reinitialize-a-permutation/solution/1806-huan-yuan-pai-lie-de-zui-shao-cao-z-mqq1/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>计算几何</h2>

<p>几何相关的题目也是比较常见的，但通常都是离散化的，一般主要涉及直线，三角形和圆。</p>

<p>计算几何相关问题最需要注意的问题就是精度问题，特别是当坐标是以整数形式给出的时候，这时计算斜率要用乘法，而不能直接用除法。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotate-image/solution/by-alexhilton-5das/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reshape-the-matrix/">566. 重塑矩阵</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reshape-the-matrix/solution/566-zhong-su-ju-zhen-by-alexhilton-nb09/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/queries-on-number-of-points-inside-a-circle/">1828. 统计一个圆中点的数目</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/queries-on-number-of-points-inside-a-circle/solution/by-alexhilton-o0yb/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/check-if-matrix-is-x-matrix/">2319. 判断矩阵是否是一个 X 矩阵</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/check-if-matrix-is-x-matrix/solution/by-alexhilton-083v/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>随机化</h2>

<p>涉及随机数。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/majority-element/">169. 多数元素</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/majority-element/solution/by-alexhilton-upn7/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shuffle-an-array/">384. 打乱数组</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shuffle-an-array/solution/by-alexhilton-10th/">题解</a> </td>
<td style="text-align:left;"> 洗牌算法 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>大数运算</h2>

<p>常规的数是有一定范围的，超出的数字用整数是无法表达的，这时就用字符串来表示数，称之为大数，大数也是要做四则运算的，这就是大数运算，通常就是用模拟正常加法乘法就行了。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/add-two-numbers/solution/add-two-by-alexhilton-vaw0/">题解</a> </td>
<td style="text-align:left;"> 加法模拟 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/multiply-strings/">43. 字符串相乘</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/multiply-strings/solution/43-zi-fu-chuan-xiang-cheng-by-alexhilton-rdps/">题解</a> </td>
<td style="text-align:left;"> 大数乘法 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/add-strings/">415. 字符串相加</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/add-strings/solution/415-zi-fu-chuan-xiang-jia-by-alexhilton-qouw/">题解</a> </td>
<td style="text-align:left;"> 大数加法 </td>
</tr>
</tbody>
</table>


<h2>其他</h2>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/gray-code/">89. 格雷编码</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/gray-code/solution/by-alexhilton-rjx8/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/unique-binary-search-trees/solution/by-alexhilton-y089/">题解</a> </td>
<td style="text-align:left;"> 卡特兰数 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/arithmetic-slices/">413. 等差数列划分</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/arithmetic-slices/solution/by-alexhilton-0shk/">题解</a> </td>
<td style="text-align:left;"> 数列知识 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://zhuanlan.zhihu.com/p/497110875">数学是什么？什么是数学？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/301338035">刷算法题必备的数学考点汇总</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
