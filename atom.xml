<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[稀有猿诉]]></title>
  <link href="http://toughcoder.net/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2023-01-15T20:40:26+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Introduction to WebSocket]]></title>
    <link href="http://toughcoder.net/blog/2023/01/14/introduction-to-websocket/"/>
    <updated>2023-01-14T18:02:12+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/14/introduction-to-websocket</id>
    <content type="html"><![CDATA[<p><a href="https://javascript.info/websocket">WebSocket</a>是HTML5带来的新时代网络通信协议，它让前端的能力再一次得到提升，因为通信不再是单向的了。最初在浏览器和JavaScript中有很好的支持，现在各种编程语言和平台都支持WebSocket协议了。今天就来学习一下它。</p>

<p><a href="http://toughcoder.net/blog/2023/01/14/introduction-to-websocket/"><img src="https://cdn.educba.com/academy/wp-content/uploads/2019/05/What-is-WebSocket.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>缘起</h2>

<p>在以往的前端中通过Ajax或者Jsonp可以让前端像一般的桌面客户端一样，有了更好的交互方式，但总的来说仍然局限于单向通信，因为底层的协议仍是HTTP，只能由客户端发起请求，服务器来响应。对于更新潮的需求，比如服务器向客户端推送消息，用HTTP来实现就略显笨拙了，常规的方法就是让客户端来轮询（polling），但这显然效率不高。于是就有了WebSocket，它支持双向通信（全双工通信信道），除了客户端主动发起请求外，服务器也可以主动向客户端推送消息。通信效率和交互性又一次得到了大大的提升。</p>

<p>就协议本身来说，它与HTTP一样，都是基于TCP实现的，对于协议本身想要深入了解的，可以去看<a href="https://www.rfc-editor.org/rfc/rfc6455">协议规范</a>。</p>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.b0ueeCtwidYP_RDzAWPVOgHaF_?pid=ImgDet&amp;rs=1" alt="" /></p>

<p>另外，需要注意，WebSocket协议的地址的schema是<strong>ws://xxxx</strong>。</p>

<h2>WebSocket in Android</h2>

<p>安卓平台也已经有了现成的WebSocket协议可以使用了，已经比较成熟了，直接使用就行了。</p>

<ul>
<li><a href="https://github.com/TooTallNate/Java-WebSocket">Java-WebSocket</a>是一个WebSocket协议的纯Java实现，适用于所有JVM平台</li>
<li><a href="https://socket.io/">Socket.IO</a>这个不单单是WebSocket，它在WebSocket基础之上又进行了进一步的封装，在API的易用性面以及错误处理和状态处理上面有了不少的提升。各种语言平台基本都有支持了。</li>
</ul>


<h2>测试服务器</h2>

<p>光有客户端还不够，还需要有测试服务器，整理一下如何搭建测试服务器。</p>

<h3>公有的测试服务器</h3>

<p>在线的免费的可公开使用的简单WebSocket服务器，一般都是echo式的，也即把请求的数据直接当成回复推给client，这个可以当作chat类的测试server。</p>

<ul>
<li><p><a href="wss://echo.websocket.org">wss://echo.websocket.org</a>
<img src="https://quarkus.pro/guides/images/websocket-guide-architecture.png" alt="" /></p>

<h3>自已搭建服务器</h3>

<p>此外，就是用WebSocket服务端的组件来自己搭建服务器，当然也都有现成的组件，配置一下就可以了，只不过需要运行在自己的Server上面。</p></li>
<li><p><a href="https://socket.io/">Socket.IO</a> 对的，这货Server端Client端全套都提供了</p></li>
<li><a href="https://github.com/uNetworking/uWebSockets">uWebSockets</a> 核心库是用C/C++实现的，可以与Node.js无缝衔接</li>
<li><a href="https://github.com/theturtle32/WebSocket-Node">WebSocket-Node</a> 基于Node.js，用纯JavaScript实现的</li>
<li><a href="http://websocketd.com/">websocketd</a> 一个独立的WebSocket Daemon，不依赖于其他的组件，功能强大，配置简单，方便使用，只需要提供一个Shell脚本就可以了</li>
<li><a href="https://github.com/jmalloc/echo-server">echo-server</a> 基于Go实现的，支持HTTP协议和WebSocket协议的echo server</li>
<li><a href="https://pypi.org/project/echo-server/">python echo server</a> 基于Python的echo server，不确定是否支持WebSocket</li>
<li><a href="https://echo.labstack.com/">Echo</a> 基于Go的Echo Web Frameworks</li>
</ul>


<h2>参考资料</h2>

<ul>
<li><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">WebSocket 教程</a></li>
<li><a href="https://github.com/nkzawa/socket.io-android-chat">socket.io-android-chat</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/23467317">WebSocket 与 Socket.IO</a></li>
<li><a href="https://juejin.cn/post/6844903577438126094">Android WebSocket 编程</a></li>
<li><a href="https://www.jianshu.com/p/7b919910c892">Android WebSocket实现即时通讯功能</a></li>
<li><a href="https://www.jianshu.com/p/4e80b931cdea">Socket.io</a></li>
<li><a href="https://www.lob.com/blog/websocket-org-is-down-here-is-an-alternative">Websocket.org Is Down, Here Is an Alternative</a></li>
<li><a href="https://blog.postman.com/introducing-postman-websocket-echo-service/">Introducing Postman’s WebSocket Echo Service</a></li>
<li><a href="https://www.piesocket.com/blog/echo-websocket-org-alternative">An Alternative To Echo.WebSocket.Org – Live WebSocket Server
</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding RxJava]]></title>
    <link href="http://toughcoder.net/blog/2023/01/12/understanding-rxjava/"/>
    <updated>2023-01-12T17:26:41+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/12/understanding-rxjava</id>
    <content type="html"><![CDATA[<p>RxJava不仅仅是一个函数库，它是响应式编程范式的一个JVM实现，所以准确的来说RxJava是一种编程范式。而且它的学习曲线非常之陡峭，必须充分理解它背后的编程思想，才能真正算使用它。</p>

<p><a href="http://toughcoder.net/blog/2023/01/12/understanding-rxjava/"><img src="https://i0.wp.com/ayusch.com/wp-content/uploads/2018/12/featured.png?w=1686" title="auto auto" ></a></p>

<!-- more -->


<h2>理解<a href="https://reactivex.io/">ReactiveExtensions</a></h2>

<p>Rx的核心思想是两个方面，一是数据流，把一切看成数据流，只需要关心数据来了如何响应；二是异步，也就是说不会立马得到结果。需要做的就是搭建好处理数据流的管道和定义数据最终的响应方式，其他的交给Rx内部去处理。</p>

<h3><a href="https://en.wikipedia.org/wiki/Functional_programming">Functional Programming</a></h3>

<p>函数式编程是以函数为核心来构建程序，通过不同的函数的不同形式的组合来作为主要解决方案。
这是从另外的角度来看待问题。程序如果只写出来，做了静态意义上的区分 是没有意义的，程序必须 运行起来 才有价值。函数式编程更加注重程序的运行，程序运行的基本单元是什么？函数，任何程序都是从一个叫主函数开始，一层一层的调用，所以函数式编程思考问题时的基本单元是函数，至于数据则以参数形式在函数之间传递。以函数为核心带来的好处是，让异步变得容易 。</p>

<h3><a href="https://en.wikipedia.org/wiki/Reactive_programming">Reactive Programming</a></h3>

<p>大部分编程思想是以控制流为核心(flow of control)，而响应式核心是数据流(data flow)为核心，再加上异步。并不关心程序的控制，只关心数据如何流动，以及当数据来了时如何响应，以及对数据如何处理。</p>

<h3><a href="https://en.wikipedia.org/wiki/Functional_reactive_programming">Functional Reactive Programming</a></h3>

<p>综合函数式和响应式，主要还是数据流，只不过以函数式的方式来处理数据流，并且都是异步形式。</p>

<h3>什么是异步</h3>

<p>这个也要理解 一下。异步与同步是一个程序执行顺序上的概念，而非具体的编程技术。同步，也就是说一坨一坨的代码是自上而下的执行，或者说函数是按照书写时的调用顺序，顺序 的执行。最明显的就是调用一个函数，你会等待函数执行完毕，然后拿到返回结果。
当然 ，这次并不是绝对的自上而下，编译器在保证取值正确的前提下，会进行指令重排的，但是当涉及取值时，会保证自上而下时的顺序。</p>

<p>而异步，则是说代码的执行，特别是函数 的执行，并不是按照你书写时的顺序 执行的。比如消息发布，虽然a先发布消息，b后发布了消息，但是仍然 可能b的消息先被收到。这就是异步。或者说两个函数分别被两个线程执行，就能并行。这也是异步。
最明显的就是函数调用，如果函数执行是异步的，你会立即 返回，拿不到执行结果，而函数的执行结果会在另外的不确定的时间通知给你。
多线程或者多进程，或者叫做并发
这是实现异步的一个方式。但是多线程并不一定就能实现异步，比如有太多的共享资源时，就需要做同步锁等待，其实这是在同步，你的效率并未得到提高。要想充分并发，必须 先做到异步，然后才能最大限度 的利用并发来提高性能。</p>

<h2>Thinking in RxJava</h2>

<h3>Architect with <a href="https://learn.microsoft.com/en-us/dotnet/architecture/maui/mvvm">MVVM</a></h3>

<p>软件架构方式从<a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a>到MVP，再到MVVM，其实是并无本质上的区别，都是为了能把数据，业务逻辑和UI区分开来，进行解耦。而MVVM强调UI要响应数据进行自动更新，与Reactive的核心思想是一致的，因此Reactive界更习惯使用MVVM来作为架构方式。
因为RxJava是Reactive的模式，也就是说它的核心思想是Reactive，是push based数据流方式。
因此，比较适合MVVM方式，因为ViewModel的存在就是为了接收数据，然后它负责主动去刷新View。
具体架构原则与方式还需要进一步总结。</p>

<h3>设计原则</h3>

<h4>不可变性<a href="https://en.wikipedia.org/wiki/Immutable_object">Immutable object</a></h4>

<p>数据要是纯数据类型，且是Immutable的，简单言之，数据对象所有的域都应该是final的，对象提供的方法只有getters，以及构造方法。一定不能让对象有改变自身状态的方法，这是为了保持immutability，管道计算过程中，当有状态发生变化时，需要创建一个新的对象，基于原对象，做些状态变化，然后生成一个新的对象。</p>

<p>存储时，只需要存储原始数据即可，中间使用的数据和状态，也即是可以通过从原始数据 计算得到的数据和状态，不需要存储，这实际上就是搭建的管道的目的啊。</p>

<h4>函数要无副作用和幂等</h4>

<p>函数与方法，要是纯函数，也就是说接受一些参数输入，然后产生一些输出，不能有副作用，不能对函数定义范围外的状态和变量产生依赖。而且要幂等，也就说给定同一个参数，多次调用，得到的结果都是一样的。</p>

<p>一个Observable实例只能被subscribe一次，一旦被subscribe，就代表着管道到达了终点，数据到此结束不会继续流动了。当subscribe了后，即使你再把这个Observable接到另外的Observable上面去，它也不会再向后面的管道(Observable)发射数据。这个需要特别注意，subscribe一定是要在最后做的事情。
如果需要subscribe两次，说明你需要不同的数据，要不然不合逻辑，如果是同数据类型，你只需要在一个subscibe做多件事情就可以了（比如刷新两个View），即使是需要不同的数据，那么就需要搭建管道进行计算，而一旦通过了operator，就会产生一个新的Observable实例（这也是为啥能连用很多点的原因，它每个operator都返回一个新的实例），因为是新的实例，所以也就可以再次subscribe。这实际上是相当于给原管道接出分支，源头数据会通过分支进行流动。</p>

<p>Immutable数据加上纯函数，一起就可以保证线程安全，你在operator过程中切换线程是很安全的。但如果你在函数中有依赖其他全局变量，那么结果将会是灾难性的。</p>

<p>依赖的原则是，ViewModel只知道Model，Model只知道Store，注意反过来不行（Store不知道Model，Model也不知道ViewModel）。它们的输出都是Observable，因此从上到下是直接依赖，通过提供的方法或者operator，而反向的反馈则是通过Observable本身。具体的，ViewModel调用Model的方法，或者直接通过operator来使用Model，反向的反馈则是通过Model给出的Observable，Model不能直接返回基本的数据对象；同理Model与Store之间也是如此。</p>

<p>ViewModel以及，Model和Store都要纯粹一些，不能有平台的依赖，目的就是为了方便测试。平台的依赖，要从外部传入。Activity或者Service，这些重要的组件，干的就是Container和组织者的身份，它创建ViewModel，Model以及Store所需要的输入，然后创建这些对象，并把它们拼装在一起，管理它们的生命周期。至于平台依赖，这些东西与Reactive也并不冲突啊，把它们封装好了后，接入Store即可了。</p>

<p>一些简单的逻辑可能直接在Container中写了也是可以的，没必要非要传入ViewModel。</p>

<h2>推荐书籍</h2>

<h3><a href="https://www.manning.com/books/rxjava-for-android-developers">《RxJava for Android Developers》</a></h3>

<p>这本书的侧重点在于Reactive，而非RxJava，它有大量的项目实例，来展示如何用Reactive的思想构建和架构一个项目。它关于RxJava本身介绍的不多，远不及文档详细，但它的重点在于项目，如何用纯Reactive的方式来架构一个项目，并且项目都是真实可运行的。书中的示例，以章节为单位，每一章都是一个完整的项目，所以它也不光涉及RxJava，也会包含一些其他的，如网络库等等。</p>

<p>对于如何把握RxJava的核心精髓，以及如何以Reactive的方式来构建一个项目，这本书是相当不错的参考。</p>

<p>这本书读起来也是相当的费劲，有二方面原因，一是它毕竟都是活生生的项目，而项目必然会涉及除RxJava以外的东西，如项目本身的业务逻辑，以及像网络库等等，这些东西与书的主题并不直接相关，都没有详细的讲解，这就非常影响对章节的整体的理解程度；另外一个原因，就是书中的前后流畅度不好，每一章节都是一步步的向你展示 如何用Reactive方式从零构建 一个项目，也就是说项目代码有迭代，但是它总是前后对应不上，比如说文字部分说某某个方法或者函数，与书中给出的代码片断对应不上，而书中的代码片断全连在一起，也不是完整的，且与代码示例包中的代码也对应不上，代码是有迭代的，代码示例包中肯定是最终的代码，但是书中的文字以及书中的代码片断都是迭代过程中的。这就导致读起来相当的费劲，前后对应不上，有时候不得不直接把源码翻出来看，但它与书中的描述也对应不上。</p>

<p>从这里，也可以看出编程书籍的无奈，特别是以完整项目为示例的书籍，因为项目必然会有迭代的过程，小步迭代，每一步都能run是比较好的迭代方式，而且项目当中必然会有大量的编程工具生成的一些冗余代码。那么，摆在作者面前就是一个难题，如何把代码与文字更好的结合在一起。很多差劲的作者会把项目完整代码全贴在书中，这是相当差劲的作法，虽然说足够完整，但是代码会占用大量的篇幅，项目中的有大量的代码也是编程工具生成的冗余 代码，更会占用大量的篇幅，这纯是凑字数的做法。另外的做法，就是像这本书的作者这样，书中仅贴出一些关键的代码片断，完整的代码要去找书的示例源码包。前提是读者要能非常容易的获得到源码包。</p>

<p>但是，为了更好的理解，因为读者读书的时候，可能不能方便的查看示例源码包，所以 书中的章节要与关键代码片断要做好流畅性，前后要能对应得起来。然后示例源码包中，最好分成几批，以展示项目的迭代过程。</p>

<p>这本书，终于读完了，还是比较费劲的，花了远超当时预估 的时间，但仍不够，对于Reactive的思想把握仍不够。书中的示例确实很好，值得继续重构和优化，以作为实践。</p>

<h3><a href="https://www.amazon.com/Functional-Reactive-Programming-Stephen-Blackheath/dp/1633430103">《Functional Reactive Programming》</a></h3>

<p>这是第一本详细论述FRP编程范式的书，值得详细研读，而且非常棒的是这本书有在线版本的，可以<a href="https://livebook.manning.com/book/functional-reactive-programming/table-of-contents/">直接在线阅读</a>。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/rxjava-for-android/">RxJava For Android</a></li>
<li><a href="https://www.codingdojo.com/blog/what-is-functional-programming">What Is Functional Programming and Why Use It?</a></li>
<li><a href="https://www.geeksforgeeks.org/functional-programming-paradigm/">Functional Programming Paradigm</a></li>
<li><a href="https://www.techtarget.com/searchapparchitecture/definition/reactive-programming">reactive programming</a></li>
<li><a href="https://developers.redhat.com/blog/2017/06/30/5-things-to-know-about-reactive-programming">5 Things to Know About Reactive Programming</a></li>
<li><a href="https://www.freecodecamp.org/news/functional-reactive-programming-frp-imperative-vs-declarative-vs-reactive-style-84878272c77f/">A quick introduction to Functional Reactive Programming (FRP)</a></li>
<li><a href="https://blog.danlew.net/2017/07/27/an-introduction-to-functional-reactive-programming/">An Introduction to Functional Reactive Programming</a></li>
<li><a href="https://learn.microsoft.com/en-us/xamarin/xamarin-forms/enterprise-application-patterns/mvvm">The Model-View-ViewModel Pattern</a></li>
<li><a href="https://www.geeksforgeeks.org/introduction-to-model-view-view-model-mvvm/">Introduction to Model View View Model (MVVM)</a></li>
<li><a href="https://tech.meituan.com/2016/11/11/android-mvvm.html">如何构建Android MVVM 应用框架</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html">MVC，MVP 和 MVVM 的图示</a></li>
<li><a href="https://www.infoq.cn/article/rethinking-mvc-mvvm">被误解的 MVC 和被神化的 MVVM</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Glossary/MVC">MVC</a></li>
<li><a href="https://www.geeksforgeeks.org/mvc-framework-introduction/">MVC Framework Introduction</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding the Observer Pattern]]></title>
    <link href="http://toughcoder.net/blog/2023/01/11/understanding-observer-pattern/"/>
    <updated>2023-01-11T22:21:24+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/11/understanding-observer-pattern</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Observer_pattern">观察者模式</a>是用于解耦的，把不同功能的类，而又对某一共同事件或者消息感兴趣解耦开来，使双方互不知道对方。常规的实现是通过接口的方式来把需要关注的消息封装起来，双方各自实现接口即可。</p>

<p><a href="http://toughcoder.net/blog/2023/01/11/understanding-observer-pattern/"><img src="https://i1.wp.com/www.jeremyshanks.com/wp-content/uploads/2018/04/The-Observer-Pattern.jpg?fit=750%2C750" title="auto auto" ></a></p>

<!-- more -->


<h2>理解观察者模式</h2>

<h3>什么是观察者模式</h3>

<p>观察者模式<a href="https://en.wikipedia.org/wiki/Observer_pattern">Observer pattern</a>用于解耦消息发布或者状态发布的，对象之间有消息依赖的一种设计模式。消息发布者，或者说被关注者称之为主体(Subject)，它会不定时的更新消息和状态，希望接收到消息和状态变化的称为观察者(Observer)。用接口来隔离主题对象（被关注者）和观察者，观察者被动接收来自主题的变化，然后更新自己的状态。</p>

<p><img src="https://www.researchgate.net/profile/Michael-Perscheid/publication/224198176/figure/fig2/AS:667774309388288@1536221210042/Observer-pattern-running-example.png" alt="" /></p>

<p>通常也被称作为发布-订阅者模式因为它与生活中的报纸杂志订阅非常的类似，用户（Subscriber）向发行商(Publisher)订阅，当有新的期刊来了时，发行商会邮寄给用户。发行商称之为Subject或者Publisher，用户称之为Observer或者Subscriber，添加订阅称作Subscription，邮寄新期刊称之为notify。</p>

<p>Subject持有一个Observer的列表，提供三个接口：添加订阅(attach或者addObserver)，取消订阅detach或者removeObserver)和通知更新(notify)，Observer则有一个更新(update)。</p>

<p>订阅 关系建立后，当有新的数据或者状态需要更新时，Subject就会调用notify接口来实现状态的发布。</p>

<h3>观察者模式的示例</h3>

<p>对于大部分编程语言来说都提供了观察者模式的接口，比如Java中就可以直接用java.util.Observable和java.util.Observer来实现。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">import</span> <span class="nn">java.util.Observable</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">java.util.Observer</span><span class="o">;</span>
</span><span class='line'><span class="kn">import</span> <span class="nn">java.util.Random</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TestDriver</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">final</span> <span class="n">MusicTeacher</span> <span class="n">teacher</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">MusicTeacher</span><span class="o">();</span>
</span><span class='line'>        <span class="kd">final</span> <span class="n">Student</span> <span class="n">tommy</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Student</span><span class="o">(</span><span class="s">&quot;Tommy&quot;</span><span class="o">,</span> <span class="n">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">tommy</span><span class="o">));</span>
</span><span class='line'>        <span class="kd">final</span> <span class="n">Student</span> <span class="n">jimmy</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Student</span><span class="o">(</span><span class="s">&quot;Jimmy&quot;</span><span class="o">,</span> <span class="n">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">jimmy</span><span class="o">));</span>
</span><span class='line'>        <span class="kd">final</span> <span class="n">Student</span> <span class="n">george</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Student</span><span class="o">(</span><span class="s">&quot;George&quot;</span><span class="o">,</span> <span class="n">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">george</span><span class="o">));</span>
</span><span class='line'>        <span class="n">teacher</span><span class="o">.</span><span class="na">addObserver</span><span class="o">(</span><span class="n">tommy</span><span class="o">);</span>
</span><span class='line'>        <span class="n">teacher</span><span class="o">.</span><span class="na">addObserver</span><span class="o">(</span><span class="n">jimmy</span><span class="o">);</span>
</span><span class='line'>        <span class="n">teacher</span><span class="o">.</span><span class="na">addObserver</span><span class="o">(</span><span class="n">george</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">teacher</span><span class="o">.</span><span class="na">singWithMe</span><span class="o">();</span>
</span><span class='line'>        <span class="n">teacher</span><span class="o">.</span><span class="na">singWithMe</span><span class="o">();</span>
</span><span class='line'>        <span class="n">teacher</span><span class="o">.</span><span class="na">singWithMe</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">class</span> <span class="nc">MusicTeacher</span> <span class="kd">extends</span> <span class="n">Observable</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">String</span><span class="o">[]</span> <span class="n">songs</span> <span class="o">=</span> <span class="o">{</span>
</span><span class='line'>            <span class="s">&quot;\tTwinkle twinkle little star,\n\tHow I wonder what you are.&quot;</span><span class="o">,</span>
</span><span class='line'>            <span class="s">&quot;\tJohnny Johnny?\n\tYes papa.\n\tEating sugar?\n\tNo papa.&quot;</span><span class="o">,</span>
</span><span class='line'>            <span class="s">&quot;\tHumpty dumpty sat on wall,\n\tHumpty dumpty had a great fall.&quot;</span><span class="o">,</span>
</span><span class='line'>            <span class="s">&quot;\tOne two three four five,\n\tOnce I caught a fish alive.&quot;</span>
</span><span class='line'>    <span class="o">};</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Random</span> <span class="n">random</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">MusicTeacher</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Random</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">());</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">singWithMe</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">setChanged</span><span class="o">();</span>
</span><span class='line'>        <span class="n">notifyObservers</span><span class="o">(</span><span class="n">songs</span><span class="o">[</span><span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">songs</span><span class="o">.</span><span class="na">length</span><span class="o">)]);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">class</span> <span class="nc">Student</span> <span class="kd">implements</span> <span class="n">Observer</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Student</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="n">Observable</span> <span class="n">observable</span><span class="o">,</span> <span class="n">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">name</span> <span class="o">+</span> <span class="s">&quot;:\n&quot;</span> <span class="o">+</span> <span class="n">o</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>常规的实现是这样的，在代码层面有直接的依赖，也就是说Observable与Observer相互知道对方的存在，且代码上面有直接的编译依赖关系。并且一般也都是同步的，状态变化 后Subject会直接发出通知，以更新Observer。</p>

<h3>什么时候用观察者模式</h3>

<p>观察者模式的特点是『一对多』，主体只有一个，向多个观察者发布状态更新，这是它最主要的特点。另外就是，它最主要的作用是解耦 这种『一对多』状态更新关系。所以，当需要解决这种『一对多』状态更新的问题时就可以使用观察者模式。</p>

<p>厘清问题，找到主体Subject，再找到Observer，然后分别实现对应的接口即可。</p>

<h2>发布-订阅模式</h2>

<p>随着软件越来越复杂，比如组件的出现，多中间件的出现，远程（服务器客户端），并发和多线程多进程的出现，使得观察者模式也有了新的样式，比如Subject和Observer可以不会有直接依赖关系，或者都依赖于一个中间组件，比如一些Event-Bus系统，以及消息的更新与通知都是异步的。
这时就是出现了发布-订阅者模式（<a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">Publish-Subscrib pattern</a>）。
向外发布消息的叫Publisher，它与Observable类似，但最重要的区别在于，Publisher并不知道Subscriber的存在，它是直接像一个第三方的消息队列，或者叫做消息平台，发布消息。而Subscriber，也不知道Publisher的存在，是直接向消息队列或者消息平台订阅。</p>

<p>它的特点是：</p>

<ul>
<li>组件间，甚至是不同的应用之间，不同的端之间的消息发布模型。</li>
<li>都是异步的，就说是发布者是往消息队列发消息，然后就算发布完成了。订阅者是从消息队列拿消息。Publisher与Subscriber之间并无同步关系。一个消息发布出去，接收时间不确定。</li>
<li>对应该关系自由，可以多对多，也可以多对一或者一对多。</li>
<li>支持并发。</li>
</ul>


<p>安卓里面非常著名的EventBus就是这一模式的经典实现。以及Linux世界里的dbus也是这种。</p>

<p>关于观察者模式与发布者模式区别可以看<a href="https://hackernoon.com/observer-vs-pub-sub-pattern-50d3b27f838c">这篇文章</a>。</p>

<h2>生产者消费者问题</h2>

<p>再有一个比较类似的就是生产者和消费者问题(<a href="https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem">Producer consumer problem</a>）主要是涉及多线程和同步问题。</p>

<h2>参考资料</h2>

<ul>
<li><a href="http://www.ni.com/tutorial/3023/zhs/">LabVIEW​之​生产​者/​消费​者​架构</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/how-to-implement-a-producer-consumer-dataflow-pattern">How to: Implement a producer-consumer dataflow pattern</a></li>
<li><a href="https://dzone.com/articles/producer-consumer-pattern">The Producer Consumer Pattern</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/standard/events/observer-design-pattern">Observer Design Pattern</a></li>
<li><a href="https://www.tutorialspoint.com/design_pattern/observer_pattern.htm">Design Patterns - Observer Pattern</a></li>
<li><a href="https://www.geeksforgeeks.org/observer-pattern-set-1-introduction/?ref=lbp">Observer Pattern | Set 1 (Introduction)</a></li>
<li><a href="https://refactoring.guru/design-patterns/observer">Observer</a></li>
<li><a href="https://blog.csdn.net/itachi85/article/details/50773358">设计模式（五）观察者模式</a></li>
<li><a href="https://www.oreilly.com/library/view/learning-javascript-design/9781449334840/ch09s05.html">The Observer Pattern</a></li>
<li><a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber">Publisher-Subscriber pattern</a></li>
<li><a href="https://www.enjoyalgorithms.com/blog/publisher-subscriber-pattern">Publisher-Subscriber</a></li>
<li><a href="https://www.educative.io/answers/what-is-the-producer-consumer-problem">What is the Producer-Consumer problem?</a></li>
<li><a href="https://www.javatpoint.com/producer-consumer-problem-in-os">Producer-Consumer problem</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Upgrade to RxJava 3]]></title>
    <link href="http://toughcoder.net/blog/2023/01/10/upgrade-to-rxjava-3/"/>
    <updated>2023-01-10T21:36:44+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/10/upgrade-to-rxjava-3</id>
    <content type="html"><![CDATA[<p>RxJava从2015年问世，2016到2017开始流行，在2018到2019左右达到顶峰，几乎无人不会RxJava，无项目不用RxJava。这期间项目本身也在迭代，从1.0版本，到2.0版本，行业内流行最广的，用的人最多的，项目使用也最多的仍是2.0版本。时过境迁，现在虽然RxJava是一个项目的标配，但是现在它的受关注度，没有前几年高了，但仍有必要研究一下它的最新版本RxJava 3。</p>

<p><a href="http://toughcoder.net/blog/2023/01/10/upgrade-to-rxjava-3/"><img src="https://i0.wp.com/blog.mallow-tech.com/wp-content/uploads/2017/03/Multithreading-with-rxjava.png?fit=820%2C400&ssl=1" title="auto auto" ></a></p>

<!-- more -->


<h2><a href="https://github.com/ReactiveX/RxJava">RxJava</a>的前世今生</h2>

<p>RxJava从诞生致今一共有三个大版本，区别都比较明显。最初是RxJava 1.0版本，它的特点是异步和数据流，核心思想仍是这些，但其它与<a href="https://reactivex.io/">Reactive Extensions</a>基本上是同步在迭代的，因此RxJava 1并不是完全符合Reactive Extensions规范的，并且它是基于Java 6.0语言的，对一些新的Java特性的支持并不好。</p>

<p>后来Rx编程范式渐渐流行起来，以及Java语言本身的发现，所以就有了RxJava 2.0，它是Reactive Extensions的一个标准实现，也就是说从RxJava 2.0开始，是完全符合Rx规范的。RxJava 2.0版本并不是基于1.0版本的迭代，而是完全重写的，基于Rx规范从新实现的。对一些东西如函数的定义，以及像方法的名字都进行了规范化。这也是流行最广泛的一个版本，坊间绝大多数资料都是基于RxJava 2的，很多其他三方的开源库，如RxAndroid等也都基于此。</p>

<p>RxJava 2.0版本有单独的groudId是<strong>io.reactivex.rxjava2</strong>，可以用以区分。</p>

<h2>RxJava 3.0</h2>

<p>技术仍在不断的演进，RxJava最新的版本是3.0，它是基于2.0的迭代，并没有像1.0到2.0那样完全重写。主要的变化 是更加符合Rx规范，性能进一步的提高。1.0和2.0都已停止维护了。它也有单独的groudId是<strong>io.reactivex.rxjava3</strong>，可以与2.0进行区分。</p>

<h3>包结构变化</h3>

<p>代码层面的包名是有明显变化的，对代码进行了更好的组织。1.0和2.0都是在io.reactivex，到了3.0组件都有了单独的package。</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> Component </th>
<th style="text-align:left;"> RxJava 2 </th>
<th style="text-align:left;"> RxJava 3 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> Core </td>
<td style="text-align:left;"> io.reactivex </td>
<td style="text-align:left;"> io.reactivex.rxjava3.core </td>
</tr>
<tr>
<td style="text-align:center;"> Annotations </td>
<td style="text-align:left;"> io.reactivex.annotations </td>
<td style="text-align:left;"> io.reactivex.rxjava3.annotations </td>
</tr>
<tr>
<td style="text-align:center;"> Disposables </td>
<td style="text-align:left;"> io.reactivex.disposables </td>
<td style="text-align:left;"> io.reactivex.rxjava3.disposables </td>
</tr>
<tr>
<td style="text-align:center;"> Exceptions </td>
<td style="text-align:left;"> io.reactivex.exceptions </td>
<td style="text-align:left;"> io.reactivex.rxjava3.exceptions </td>
</tr>
<tr>
<td style="text-align:center;"> Functions </td>
<td style="text-align:left;"> io.reactivex.functions </td>
<td style="text-align:left;"> io.reactivex.rxjava3.functions </td>
</tr>
<tr>
<td style="text-align:center;"> Flowables </td>
<td style="text-align:left;"> io.reactivex.flowables </td>
<td style="text-align:left;"> io.reactivex.rxjava3.flowables </td>
</tr>
<tr>
<td style="text-align:center;"> Observables </td>
<td style="text-align:left;"> io.reactivex.observables </td>
<td style="text-align:left;"> io.reactivex.rxjava3.observables </td>
</tr>
<tr>
<td style="text-align:center;"> Subjects </td>
<td style="text-align:left;"> io.reactivex.subjects </td>
<td style="text-align:left;"> io.reactivex.rxjava3.subjects </td>
</tr>
<tr>
<td style="text-align:center;"> Processors </td>
<td style="text-align:left;"> io.reactivex.processors </td>
<td style="text-align:left;"> io.reactivex.rxjava3.processors </td>
</tr>
<tr>
<td style="text-align:center;"> Observers </td>
<td style="text-align:left;"> io.reactivex.observers </td>
<td style="text-align:left;"> io.reactivex.rxjava3.observers </td>
</tr>
<tr>
<td style="text-align:center;"> Subscribers </td>
<td style="text-align:left;"> io.reactivex.subscribers </td>
<td style="text-align:left;"> io.reactivex.rxjava3.subscribers </td>
</tr>
<tr>
<td style="text-align:center;"> Parallel </td>
<td style="text-align:left;"> io.reactivex.parallel </td>
<td style="text-align:left;"> io.reactivex.rxjava3.parallel </td>
</tr>
<tr>
<td style="text-align:center;"> Internal </td>
<td style="text-align:left;"> io.reactivex.internal </td>
<td style="text-align:left;"> io.reactivex.rxjava3.internal </td>
</tr>
</tbody>
</table>


<p>使用起来更加的清晰和规范，并且不与老版本有冲突。</p>

<h3>与Java 8更好的融合</h3>

<p>另外一个重大改进就是与新版本的Java，即Java 8有了更好的融合，支持了好多Java 8中的数据类型。比如Optional和Stream：</p>

<ul>
<li>Observable.fromOptional()</li>
<li>Observable.fromStream</li>
<li>Observable.mapOptional</li>
<li>Observable.blockingStream</li>
<li>Observable.flatMapStream</li>
</ul>


<h3>行为变化</h3>

<p>因为RxJava 2.0是符合Rx规范的，所以大部分功能和核心概念在3.0上面是没有变化的。只有在一些高级的概念上面有一些差别，比如错误处理有加强，以前在2.0时有些error会丢失，并且不会被处理，3.0上加强了error的流动，保证它能到达Subscriber。</p>

<p>另外一个重要变化 就是在multicast，也即针对Hot Observables的共享问题，多了一个reset方法，以让所有Subscriber都接收到同样的数据。</p>

<p>还有就是Flowable有了pause的功能。</p>

<h3>三方库的兼容</h3>

<p>还要注意三方库如Retrofit adapter，RxAndroid以及RxBinding等也是与RxJava的版本绑定的，要注意它们之间版本的匹配。</p>

<h2>升级建议</h2>

<p>因为RxJava 1并不完全符合Rx规范，所以如果还在用RxJava 1，那么是要立即升级到3.0。</p>

<p>因为RxJava 2.0是最流行的版本，所以现在大部分项目使用的应该是RxJava 2.0。那么就要看项目本身的情况，如果RxJava 2.0能完全满足项目的需要，没有用到太多高级的特性（如multicast或者Flowable），而且项目中重点引用RxJava的部分也基本上成成熟了，此种情况下，其实不建议升级到3.0，因为不会带来多少收益。</p>

<p>相反，如果使用了大量的高级特性，甚至还遇到了RxJava本身导致的问题，并且项目中还在大量使用RxJava，未来新功能的开发也会使用RxJava，那么还是尽早升级为妙。同时要注意，RxJava是一个流行的库，有很多三方库的依赖于它，版本一旦变动，会引发链式反应，要注意版本的匹配，以免发生不兼容的情况。</p>

<p>可以到这里找到<a href="https://github.com/ReactiveX/RxJava/releases">最新的版本</a>。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://github.com/ReactiveX/RxJava/wiki/What's-different-in-3.0">What&rsquo;s different in 3.0</a></li>
<li><a href="https://prog.world/whats-new-in-rxjava-3/#:~:text=There%20was%20a%20problem%20with%20hot%20sources%20in,to%20enable%20newly%20connected%20subscribers%20to%20process%20data.">What’s New in RxJava 3</a></li>
<li><a href="https://stackoverflow.com/questions/38423079/differences-between-rxjava1-and-rxjava2">Differences between RxJava1 and RxJava2</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数学相关题目]]></title>
    <link href="http://toughcoder.net/blog/2023/01/09/mathematics-problem-set/"/>
    <updated>2023-01-09T22:03:57+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/09/mathematics-problem-set</id>
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6/107037">数学</a>是自然科学之母，数学也是算法之母，有一些数学相关的题目需要总结一下。当然暴力法也都是可以解决的，但是通过数学一些公式的引入会提升时间效率。</p>

<p><a href="http://toughcoder.net/blog/2023/01/09/mathematics-problem-set/"><img src="https://ts1.cn.mm.bing.net/th/id/R-C.ba01d095b9f9a650e61d8f49d2b28519?rik=rVVFOj18ozgpZw&riu=http%3a%2f%2fwww.pixelstalk.net%2fwp-content%2fuploads%2f2016%2f05%2fMath-Mathematics-Formula-Wallpaper-for-PC.jpg&ehk=%2bfTho6j8Ym8wGaYhOjf%2bGXs56O7AyL38fNlEbHjIzqQ%3d&risl=&pid=ImgRaw&r=0" title="auto auto" ></a></p>

<!-- more -->


<h2>数学题目的特点</h2>

<p>用暴力法或者模拟法也可以解决。</p>

<p>运用相关的数学知识或者数学公式，可以提升效率。</p>

<p>一般都可以使用查表大法。</p>

<h2>数论</h2>

<p>主要是以整数为基础的一些题目，一般会涉及素数，数位等。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/add-digits/">258. 各位相加</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/add-digits/solution/by-alexhilton-uehk/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/prime-arrangements/">1175. 质数排列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/prime-arrangements/solution/by-alexhilton-p5rj/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/count-integers-with-even-digit-sum/">2180. 统计各位数字之和为偶数的整数个数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/count-integers-with-even-digit-sum/solution/2180-tong-ji-ge-wei-shu-zi-zhi-he-wei-ou-mc2e/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>数组轮转</h2>

<p>一般就是把数组的元素按照一定的规则进行移动和轮转。一般涉及LCM（最小公倍数）。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotate-array/solution/189-lun-zhuan-shu-zu-by-alexhilton-1ih4/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/minimum-number-of-operations-to-reinitialize-a-permutation/">1806. 还原排列的最少操作步数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/minimum-number-of-operations-to-reinitialize-a-permutation/solution/1806-huan-yuan-pai-lie-de-zui-shao-cao-z-mqq1/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>计算几何</h2>

<p>几何相关的题目也是比较常见的，但通常都是离散化的，一般主要涉及直线，三角形和圆。</p>

<p>计算几何相关问题最需要注意的问题就是精度问题，特别是当坐标是以整数形式给出的时候，这时计算斜率要用乘法，而不能直接用除法。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/max-points-on-a-line/">149. 直线上最多的点数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/max-points-on-a-line/solution/by-alexhilton-gksh/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/projection-area-of-3d-shapes/">883. 三维形体投影面积</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/projection-area-of-3d-shapes/solution/by-alexhilton-9252/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/valid-boomerang/">1037. 有效的回旋镖</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/valid-boomerang/solution/by-alexhilton-1noz/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>其他</h2>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/unique-binary-search-trees/solution/by-alexhilton-y089/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://zhuanlan.zhihu.com/p/497110875">数学是什么？什么是数学？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/301338035">刷算法题必备的数学考点汇总</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Beyond RxJava]]></title>
    <link href="http://toughcoder.net/blog/2023/01/07/beyond-rxjava/"/>
    <updated>2023-01-07T09:47:50+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/07/beyond-rxjava</id>
    <content type="html"><![CDATA[<p>RxJava是一种编程范式，它并不是一个库，而是一种编程思想，一种解决问题的新思路，一种架构思想。因此，基于RxJava还有大量的其他的库，可以一起更容易让用RxJava构建应用程序。</p>

<p>其他书籍和文档也有提及，这些东西称为<a href="https://github.com/davidmoten/rxjava-extras">RxJava Extras</a>。</p>

<p><a href="http://toughcoder.net/blog/2023/01/07/beyond-rxjava/"><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.YSq989RaoMIlYVnsxoBOLQHaE8?pid=ImgDet&rs=1" title="auto auto" ></a></p>

<!-- more -->


<h2><a href="https://github.com/ReactiveX/RxAndroid">RxAndroid</a></h2>

<p>这是Jake Wharton大神弄的，但其实这个库里面的东西比较少。</p>

<p>最为常用的就是Schedulers之中的AndroidScheduler.main()，这个是在切线程时常用到的。其他的好像也没啥。</p>

<h2><a href="https://github.com/JakeWharton/RxBinding">RxBinding</a></h2>

<p>主要是处理Android UI的响应事件，它把UI响应事件，如OnClick，onTouch和onTextChanged等变成一个Observable。方便创建数据流。</p>

<p>虽然从语义上理解，这些UI事件的Observable应该是hot的，但是它们并不支持multicast。也就是说如果想用UI事件创建的Observable，创建两个数据处理流程，就需要去multicast。</p>

<p>方法就是可以用share()，之后就可以multicast了。</p>

<p>但这里也需要处理资源清理问题，因为事件都是通过向View添加listener来实现的，那么如何及时的清理listener，这个需要研究一下。</p>

<h2><a href="https://github.com/tbruyelle/RxPermissions">RxPermissions</a></h2>

<p>专门处理权限问题。权限，因为必须先调用request，然后在onActivityResult里面去处理，所以你的代码逻辑必然会被分成两段：</p>

<p>初始化时，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">onCreate</span>
</span><span class='line'><span class="k">if</span> <span class="n">permission</span> <span class="n">granted</span>
</span><span class='line'>   <span class="n">doOurThings</span>
</span><span class='line'><span class="k">else</span> <span class="n">request</span> <span class="n">permissions</span>
</span><span class='line'>
</span><span class='line'><span class="n">onActivityResult</span>
</span><span class='line'><span class="k">if</span> <span class="n">permission</span> <span class="n">granted</span><span class="p">:</span>
</span><span class='line'>   <span class="n">do</span> <span class="n">Our</span> <span class="n">things</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果以Rx方式来理解，权限也是一个数据流，可能来一个granted或者rejected的权限，虽然状态不一样，但都可以理解 为权限数据，而且数据的发射是异步的，你不知道什么时候数据来。因此完全可以用Rx的方式来处理权限。</p>

<p>尝试失败，因为依赖无法添加。尝试网上解决方案仍无效，依赖无法添加。暂先放弃。
后面再观察一下吧，如果真心想用，只有以源码方式来集成，试用。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.jianshu.com/p/517c3f4c7bc1">RxAndroid使用初探—简洁、优雅、高效</a></li>
<li><a href="https://github.com/ReactiveX/RxAndroid/wiki">RxAndroid Extensions</a></li>
<li><a href="https://www.jianshu.com/p/34cf96b72102">RxBinding详解: 规范而强大的安卓UI响应式编程</a></li>
<li><a href="https://juejin.cn/post/6844903886507999246">RxPermissions使用总结</a></li>
<li><a href="https://www.raywenderlich.com/books/reactive-programming-with-kotlin">Reactive Programming with Kotlin</a></li>
<li><a href="https://github.com/davidmoten/rxjava2-extras">Utilities for use with RxJava 2</a></li>
<li><a href="https://github.com/davidmoten/rxjava-extras">Utilities for use with rxjava</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to RxJava]]></title>
    <link href="http://toughcoder.net/blog/2023/01/05/introduction-to-rxjava/"/>
    <updated>2023-01-05T22:57:44+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/05/introduction-to-rxjava</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/ReactiveX/RxJava">RxJava</a>是一个异步数据流式的开源库，已流行于Android开发行业中多年，现在已经变成了Android开发的一个标配，几乎所有，是的几乎所有的项目都会使用它（即使大部分人并没有真的在用它）。也几乎每个开发人员的简历中都会写着熟悉RxJava，甚至是精通RxJava，可见它的流行程度，今天就来学习一下RxJava的基本使用。</p>

<p><a href="http://toughcoder.net/blog/2023/01/05/introduction-to-rxjava/"><img src="https://ts1.cn.mm.bing.net/th/id/R-C.8bf825c83d71d679305006ad8877881f?rik=ntxCAiBD5wztvw&riu=http%3a%2f%2fwww.allaboutweb.biz%2fwp-content%2fuploads%2f2018%2f04%2fWhat-is-RxJava.jpg&ehk=K75BZ9hKVA%2bAu7Gjm9QXOAtzL3uOtKQeoRkvFi1KDAA%3d&risl=&pid=ImgRaw&r=0" title="auto auto" ></a></p>

<!-- more -->


<h2>理解基本的范式</h2>

<p>RxJava是Reactive Extensions的Java实现，是基于数据流的响应式编程范式，同时结合了函数式编程，准确的来说它是函数式响应式编程范式FRP(Functional Reacive Programming)。核心思想是数据流和响应式。
一个Observable就是一个会发出事件的机器，这里事件是一个数据的意思。就好比marble球，一个Observable就是一个可以不断发射出marble的机器，它就是一个数据流。
<img src="https://ts1.cn.mm.bing.net/th/id/R-C.2f9fed625ff00e7f0cfa51632f7b9644?rik=8AI5UL%2fV%2bFQO2Q&amp;riu=http%3a%2f%2fwww.philosophicalhacker.com%2fwp-content%2fuploads%2f2015%2f06%2fwe_know_rxjava_is_observer_plus_iterator.jpg&amp;ehk=3KXNE20j2MAeyThqdNT%2bZX9DHY2wRHvlVLLrCeusLCc%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" />
可以把它想像成一个无限列表，但并不是常规意义上的List，因为它是异步的，这里异步的意思是，同一个时间内，你看不到所有的元素，对于常规意义上的列表是同步的，意思是拿到列表时，里面的数据 全在。但Observable是异步的，拿到Observable时，可能还没有数据。数据是有时序的，有点类似于信号。如果你收集齐了Observable发出的所有数据，假设它是有限的（比如从一个真正列表创建的Observable），那么得到的就是一个列表。</p>

<p>Observable最佳的类比就是一个物理信号，是有时域上的概念。</p>

<p><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.L_gen2R661qqPG-UbhM2lAHaDl?pid=ImgDet&amp;rs=1" alt="" /></p>

<p>Subscriber是数据的消费者，它是对数据的响应，由它来体现响应式Reactive。</p>

<p>我们需要做的就是把数据封装成为一个Observable，然后定义好一个响应数据的Subscriber，这就是FRP了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'> <span class="n">Observable</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="s">&quot;Hello, world of RxJava!&quot;</span><span class="o">)</span>
</span><span class='line'>           <span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="nl">helloLabel:</span><span class="o">:</span><span class="n">setText</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<h2>常见的Operator</h2>

<h3>Map</h3>

<p>比较容易理解，把Observable发出的事件进行转换。提供一个单元函数（一个输入参数，一个输出参数），输入就是Observable发出的数据，输出就是转换后的结果。针对发出的事件每个都应用提供的函数。
<img src="https://www.adictosaltrabajo.com/wp-content/uploads/2017/06/rxjava_android_map.png" alt="" /></p>

<h3>concatMap</h3>

<p>与flatMap类似，保证顺序。</p>

<h3>flatMap</h3>

<p>先做map，然后再做flat，把二维结构展平为一维，也即是把Observable of Observable展平为一个Observable。传入的map函数必须是返回一个Observable，也即是把常规数据转化为一个Observable。</p>

<p>此外，它的每个map操作可以是并行的，不能保证先后顺序，如果想保证顺序要使用concatMap。</p>

<h3>switchMap</h3>

<h3>combineLatest</h3>

<p>Operator就是数据的管道，用以把各种不同的数据发射器(Observable)连接起来，一起组成一个能够从源头数据，通过管道计算，最终生成符合预期的数据，流出到Subscriber那里。</p>

<h2>常见的技巧</h2>

<h3>感知冷热</h3>

<p>Observable是一个数据流，可视为一个事件发射器，不断的向下游发送数据(emission)。但数据何时发送，以及发送多少，是有一些细微区别的，这就引出了Observable是有冷热之分(Cold vs Hot)。</p>

<p>在《Learning RxJava》这本书中有一个非常形象的比喻，cold Observables就像音乐CD，每次播放都能得到相同的内容。对于所有Subscriber来说，无论你啥时候去subscribe，都能得到同样的数据流，这就是cold的。大多数以数据集为基础创建的Observable都是cold的，如Observable.just, Observable.fromIterable以及像从数据库或者文件存储中读取的数据。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>     <span class="n">Observable</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">Observable</span><span class="o">.</span><span class="na">just</span><span class="o">(</span><span class="s">&quot;alpha&quot;</span><span class="o">,</span> <span class="s">&quot;beta&quot;</span><span class="o">,</span> <span class="s">&quot;gamma&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="n">source</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Subscriber #1 received: &quot;</span> <span class="o">+</span> <span class="n">s</span><span class="o">));</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">source</span><span class="o">.</span><span class="na">subscribe</span><span class="o">(</span><span class="n">s</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Subscriber #2 received: &quot;</span> <span class="o">+</span> <span class="n">s</span><span class="o">));</span>
</span><span class='line'>
</span><span class='line'>     <span class="c1">//Subscriber #1 received: alpha</span>
</span><span class='line'>    <span class="c1">//Subscriber #1 received: beta</span>
</span><span class='line'>    <span class="c1">//Subscriber #1 received: gamma</span>
</span><span class='line'>    <span class="c1">//Subscriber #2 received: alpha</span>
</span><span class='line'>    <span class="c1">//Subscriber #2 received: beta</span>
</span><span class='line'>    <span class="c1">//Subscriber #2 received: gamma</span>
</span></code></pre></td></tr></table></div></figure>


<p>Hot Observables则是像一个音乐广播电台，你今天收听到的内容，跟昨天收听到的内容是不一样的。不同的时间去subscribe会得到不一样的数据流，晚些subscribe就会错失前面的数据，这便是hot Observables。像一些无限数据集（比如社交信息，或者新闻信息），与时间有关的数据（如interval），以及用户事件都属于hot Observables。</p>

<h3>RxBinding只能被subscribe一次</h3>

<p>一般来说一个Observable，只能被subscribe一次。</p>

<p>但总的说 是分为冷和热，对于冷的，一般是有限集合的Observable，它可以被subscribe无限次，且每个Subscriber接收到的东西是一样的。</p>

<p>但对于热的，就不一样，有些可以被subscribe多次，有些则不能。</p>

<p>给一个Observable subscribe多个Subscriber的行为叫做multicast。
对于cold的，可以通过ConnectableObesrver，通过connect，来让几个Subscriber同步接收来自Observable的emission。</p>

<p>但是对于hot的Observable，如何 让 不同的Subscriber同步接收emission呢？
就比如说RxBinding中的大部分来自于View的事件Observable，都是hot的，并且，它们默认情况下，不能被multicast，只有最后一个subscribe的Observer，才可以接收事件。</p>

<p>这时就需要把Observable share一下。通过share()，之后就可以multicast了。</p>

<h3>如何做Recursion</h3>

<p>有一些场景是会出现循环，或者说Recursion的，比如说像文件遍历，对于文件夹的操作，是需要Recursion的。</p>

<p>这里就有两种场景，一种会在某个节点停留，用户具体进一步操作才会深入的遍历的情况，比如像文件浏览器，展示的就是当前的文件夹，用户点子目录，才会更进一步。这种场景，需要Hold住当前的文件夹，但当有新的文件夹变成当前文件夹时，它需要更新数据，这种数据产生的闭环，可以用Subject来解决。</p>

<p>但，如果是一个完整的遍历流程，从根节点开始，一直到所有的叶子为止，那么用subject可能就不太合适。这时就需要用一些Recursion来解决，可以看一些网络上的例子。需要用到常规的recursion方式，先要弄一个方法，在里面做出reactive chain，就是在Reactive链里面再调用这个方法，以此递归下去。不过，不知道这个当有一些耗时操作时，会不会造成堆积，以及会不会有资源释放的问题，有待考查。</p>

<p>Reactive这玩意儿，确实难度较大，想写出符合Reactive规范，且正确的代码还是相当难的。而且它难以调试，有时候完全不知道错在哪里。</p>

<h2>书籍推荐</h2>

<p>RxJava的学习曲线 非常之陡峭，它融合了异步，多线程，函数式编程和响应式编程，集多种编程范式于一体，要想真正的用好RxJava需要深度理解RxJava本身，更需要函数式和响应式编程的一些思维。必须要以Reactive的方式来架构你的应用程序，这才能真正算得上使用了RxJava。比如仅是用了几个Observable，用了几个operator，但是整体项目的代码仍是状态变量散落一大堆，这根本不叫用了RxJava，这仅仅是把RxJava当成工具来用了，并没真正践行它的精髓思想。</p>

<p>要想学好RxJava必须要啃书，它的学习曲线陡峭，并不是看了文档就能用（那根本不叫Reactive，仅是把RxJava当成工具类了），通过啃书达到一定的理解深度，然后再在项目中去实践。</p>

<h3>《Learning RxJava》</h3>

<p>这本书对于深入的理解RxJava本身非常有帮助，它比官方文档要详细得多，具体给你解释什么是Observable，什么是Observer以及各种operator，并且都带有实例。这本书，不建议从头读到尾，而是要像文档一样对待，需要深入理解哪个知点点的时候就去具体看那一章节就好。</p>

<p>书中的示例非常短小精悍，但能非常好的帮助你理解对应的知识点。</p>

<p>这本书的目的是让你更深入的了解RxJava这一库的本身，也就是说让你更好的了解工具本身。但这远远不够，即使把这本书看完，你仍旧会是把RxJava当成一个工具类来使用。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/">ReactiveX/RxJava文档中文版</a></li>
<li><a href="https://reactivex.io/">ReactiveX</a></li>
<li><a href="https://github.com/ReactiveX/RxJava">RxJava</a></li>
<li><a href="https://www.journaldev.com/19300/rxjava-flatmap-switchmap-concatmap">RxJava flatMap, switchMap, concatMap</a></li>
<li><a href="https://www.androidhive.info/RxJava/map-flatmap-switchmap-concatmap/">RxJava Operators – Understanding Map, FlatMap, SwitchMap and ConcatMap</a></li>
<li><a href="https://juejin.cn/post/6844903914022633486">从源码查看RxJava中的map和flatMap的用法与区别</a></li>
<li><a href="https://www.jianshu.com/p/0cd258eecf60">这可能是最好的RxJava 2.x 教程（完结版）</a></li>
<li><a href="https://gank.io/post/560e15be2dca930e00da1083">给 Android 开发者的 RxJava 详解</a></li>
<li><a href="https://colobu.com/2016/07/25/understanding-rxjava-thread-model/">理解RxJava的线程模型</a></li>
<li><a href="https://www.baeldung.com/rxjava-multiple-subscribers-observable">RxJava One Observable, Multiple Subscribers</a></li>
<li><a href="https://www.baeldung.com/rx-java">Introduction to RxJava</a></li>
<li><a href="https://medium.com/bystevenp/comment-trees-and-recursion-with-rxjava-d147a904610a">Comment Trees and Recursion with RxJava</a></li>
<li><a href="https://stackoverflow.com/questions/31246088/how-to-do-recursive-observable-call-in-rxjava">How To Do Recursive Observable Call in RxJava?</a></li>
<li><a href="https://medium.com/@stevenlow1983/rx-java-and-recursion-719f8ee1977a">RX Java and Recursion</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搞懂动态规划之状态压缩]]></title>
    <link href="http://toughcoder.net/blog/2022/12/26/understanding-bitmask-dynamic-programming/"/>
    <updated>2022-12-26T12:10:24+08:00</updated>
    <id>http://toughcoder.net/blog/2022/12/26/understanding-bitmask-dynamic-programming</id>
    <content type="html"><![CDATA[<p>动态规划算法博大精深，非常的广泛而复杂。但动态规划离不开状态的存储和转移，要想用动态规划来求解一个问题，必须把问题分解为多个子问题，然后再用状态来记录以解决子问题，最终通过状态转移以得到整个问题的解。根据问题的不同，状态也会有不同的定义，比如有些是用整数来代表计数，有些是用布尔来代表True/False（或者0/1）的状态。</p>

<p><a href="http://toughcoder.net/blog/2022/12/26/understanding-bitmask-dynamic-programming/"><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.w0EUQBEfTpJW2jcJ-TeghAHaDU?pid=ImgDet&rs=1" title="auto auto" ></a></p>

<!-- more -->


<p>如果状态可以用True/False（或者0/1）来代表时，那么可以进一步的利用位运算，利用计算机的bit的特点，一个bit可以是0也可以是1，足以表示一个状态，那么就可以把整体的状态只用一个或者几个有限的整数来表示了，这就是状态压缩。</p>

<p>更进一步的，其实可以拓展一下，不光局限在动态规划里面，凡是用到True/False（或者0/1，选与不选等）的辅助存储时，都可以尝试用位运算来代表数组或者哈希表，这其实也是状态压缩。广义上来讲，把一坨用数组或者哈希表表示的状态压缩成为一个整数或者几个有限的整数就是状态压缩。</p>

<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br /></p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.cnblogs.com/labuladong/p/13940269.html">状态压缩：对动态规划进行降维打击</a></li>
<li><a href="https://cp-wiki.vercel.app/dynamic-programming/bitmask-dp/">Bitmask DP</a></li>
<li><a href="https://blog.csdn.net/qq_40722827/article/details/116400306">动态规划之状态压缩DP详细介绍和例题练习</a></li>
<li><a href="https://oi-wiki.org/dp/state/">OI wiki 状压DP</a></li>
<li><a href="https://blog.nowcoder.net/n/fcc30eadb2b44395862194814e819315">【状压DP】状态压缩动态规划入门超详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/131585177">动态规划——状态压缩DP</a></li>
<li><a href="https://www.cnblogs.com/mxrmxr/p/9799832.html">状态压缩入门</a></li>
<li><a href="https://github.com/cormacpayne/Data-Structures-and-Algorithms/blob/master/dynamic-programming/bitmask-dynamic-programming/bitmask-dynamic-programming.md#:~:text=Bitmask%20DP%20is%20a%20type%20of%20dynamic%20programming,or%20a%20binary%20string%20representation%20of%20the%20number.">Bitmask Dynamic Programming</a></li>
<li><a href="https://www.geeksforgeeks.org/bitmasking-and-dynamic-programming-set-1-count-ways-to-assign-unique-cap-to-every-person/">Bitmasking and Dynamic Programming | Set 1 (Count ways to assign unique cap to every person)</a></li>
<li><a href="https://www.geeksforgeeks.org/bitmasking-dynamic-programming-set-2-tsp/">Bitmasking and Dynamic Programming | Set-2 (TSP)</a></li>
<li><a href="https://algo.monster/problems/bitmask_intro">Bitmask and Dynamic Programming</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[前缀和与差分数组简介]]></title>
    <link href="http://toughcoder.net/blog/2022/09/25/intro-to-diff-array/"/>
    <updated>2022-09-25T09:44:51+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/25/intro-to-diff-array</id>
    <content type="html"><![CDATA[<p>在数组相关的问题中前缀和与差分数组是使用使用比较多的辅助数组，能有效的提升效率。前缀和就是数组中到当前元素的和；差分数组是一个辅助数组，每个元素是原数组相邻元素之差，故命名为差分数组，它在原数组区间修改等操作上能辅助提升效率。</p>

<p><a href="http://toughcoder.net/blog/2022/09/25/intro-to-diff-array/"><img src="https://cdn.luogu.com.cn/upload/image_hosting/n0yy6qgd.png" title="auto auto" ></a></p>

<!-- more -->


<h2>一维前缀和</h2>

<p>前缀和的定义不复杂，对于一维列表来说，前缀和是一个辅助列表，前缀和中的元素i，就是原列表中从元素0到元素i的累加和，即preSum[i] = sum(nums, 0, i)。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>preSum[0] = nums[0]
</span><span class='line'>preSum[1] = nums[0] + nums[1] = preSum[0] + nums[1]
</span><span class='line'>preSum[2] = nums[0] + nums[1] + nums[2] = preSum[1] + nums[2]
</span><span class='line'>preSum[n-1]= nums[0] + nums[1] + ... + nums[n - 1] = preSum[n - 2] + nums[n - 1]</span></code></pre></td></tr></table></div></figure>


<p>代码实现就是这个样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">preSum</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">preSum</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">preSum</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>前缀和的应用</h3>

<p>前缀和最大的作用就是能够以常数时间求出一维列表的区间和，或者说连续子列表的和。</p>

<p>比如给定一个列表nums，长度是n，如果想求出子列表[l, r]，都是闭区间的子列表的和，就可以用前缀和。朴素做法很容易想到，就是从遍历区间[l, r]累加即可，显然这是O(n)复杂度，如果查询就一次两次的，当然 也可以，但如果查询次数多了，显然效率差，如果查询m次，时间复杂度会上升到O(mn)。</p>

<p>区间和[l, r]，记为sum(l, r) = nums[l] + nums[l + 1] + &hellip; + nums[r-1] + nums[r]，是可以转化用前缀和来求解的，过程如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">sum</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="o">...</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]</span>
</span><span class='line'>           <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+...</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">+</span> <span class="o">...</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">-</span> <span class="o">(</span><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+...+</span> <span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="o">])</span>
</span><span class='line'>           <span class="o">=</span> <span class="n">preSum</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">-</span> <span class="n">preSum</span><span class="o">[</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>事先计算前缀和列表，就可以直接以一次减法求出区间和：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kt">int</span> <span class="nf">regionSum</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">preSum</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">preSum</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">-</span> <span class="n">preSum</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="https://github.com/alexhilton/EffectiveAlgorithm/blob/main/datastructure/src/main/java/AuxiliaryArray.java">完整代码看这里</a>。</p>

<h3>前缀和典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/subarray-sum-equals-k/solution/by-alexhilton-eh11/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/find-the-highest-altitude/">1732. 找到最高海拔</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/find-the-highest-altitude/solution/1732-zhao-dao-zui-gao-hai-ba-by-alexhilt-fxhn/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>差分数组</h2>

<p>与前缀和类似，差分数组也是一个常用的辅助数组。它的定义是原数组相邻两元素之差：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">diff</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span>
</span><span class='line'><span class="n">diff</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
</span><span class='line'><span class="n">diff</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
</span><span class='line'><span class="n">diff</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
</span><span class='line'><span class="n">diff</span><span class="o">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>不难发现，差分数组是前缀和的逆运算，也就是说把差分数组diff求它的前缀和，刚好能得到原始数组：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">diff</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
</span><span class='line'><span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">diff</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">diff</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
</span><span class='line'><span class="n">nums</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">diff</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">diff</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">diff</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span>
</span><span class='line'><span class="n">nums</span><span class="o">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="o">...</span> <span class="n">nums</span><span class="o">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">n</span><span class="o">-</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="n">diff</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="o">...</span> <span class="n">diff</span><span class="o">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<h3>差分数组的作用</h3>

<p>差分数组的作用是能快速的对区间更新。区间更新是指对于数组nums，长度为n，想要对区间[l, r]做更新，比如都加上一个数x，或者都减去一个数y。常规的实现肯定遍历[l, r]然后对每个元素做更新，这是线性时间O(n)的，而用差分数组可以在常数时间完成区间更新。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">]</span> <span class="o">+</span> <span class="n">x</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">+</span> <span class="n">x</span><span class="o">,</span> <span class="n">nums</span><span class="o">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">x</span><span class="o">,</span> <span class="o">...</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">x</span><span class="o">,</span> <span class="n">nums</span><span class="o">[</span><span class="n">r</span><span class="o">]</span> <span class="o">+</span> <span class="n">x</span>
</span><span class='line'>                  <span class="o">=</span> <span class="n">diff</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">+</span> <span class="n">x</span><span class="o">,</span> <span class="n">diff</span><span class="o">[</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="o">],</span> <span class="o">....</span> <span class="n">diff</span><span class="o">[</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="o">],</span> <span class="n">diff</span><span class="o">[</span><span class="n">r</span><span class="o">],</span> <span class="n">diff</span><span class="o">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">x</span>
</span><span class='line'>                  <span class="o">=</span> <span class="n">diff</span><span class="o">[</span><span class="n">l</span><span class="o">]</span> <span class="o">+</span> <span class="n">x</span><span class="o">,</span> <span class="n">diff</span><span class="o">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">x</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看出，只对差分数组的区间两端做加减法就可以实现原数组区间增加。当然了，如果想得出原数组的真实修改后的结果，仍需要对差分数组做前缀和才可以，因为差分数组的前缀和才是原始数组。所以，<strong>差分数组是一个辅助数组，它的作用不像前缀和那样明显，它只能配合使用，无法单独使用</strong>。（单独使用仍要用O(n)来计算前缀和才能得到原始数组，失去了意义）。</p>

<p>差分数组与前缀和通常作为辅助数组一起使用，以解决快速区间查询和区间修改，这便是树状数组，理解 了前缀和和差分数组的作用，对于理解 树状数组有很大的帮助。树状数组的具体原理与应用可以<a href="http://toughcoder.net/blog/2022/09/06/intro-to-binary-indexed-tree/">参考 这篇文章。</a></p>

<h2>拓展到二维</h2>

<p>一维上能做的事情，肯定 都能拓展到二维，对于二维列表也就是说矩阵，也可以使用前缀和和差分，差分本来的应用比较有限，不像前缀和可以单独应用，并且二维差分要复杂的多得多，所以这里就讨论一下二维前缀和。</p>

<p>假设一个矩阵为matrix，尺寸是mxn，即m行n列，对于它的任意一个格子{i, j}和前缀和preSum[i, j]等于其左上部分的所有元素之和。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">preSum</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">]</span>
</span><span class='line'><span class="n">preSum</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">preSum</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">]</span>
</span><span class='line'><span class="n">preSum</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">preSum</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">]</span>
</span><span class='line'><span class="n">preSum</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">preSum</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">preSum</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">preSum</span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="mi">0</span><span class="o">]</span>
</span><span class='line'><span class="n">preSum</span><span class="o">[</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">preSum</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">preSum</span><span class="o">[</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">,</span><span class="n">j</span><span class="o">]</span> <span class="o">-</span> <span class="n">preSum</span><span class="o">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">preSum</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">m</span><span class="o">][</span><span class="n">n</span><span class="o">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">m</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">preSum</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
</span><span class='line'>    <span class="n">preSum</span><span class="o">[</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">preSum</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">1</span><span class="o">][</span><span class="mi">0</span><span class="o">];</span>
</span><span class='line'>    <span class="n">preSum</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">preSum</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="o">[</span><span class="mi">0</span><span class="o">][</span><span class="mi">1</span><span class="o">];</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">preSum</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">preSum</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="n">preSum</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">+</span> <span class="n">matrix</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span> <span class="o">-</span> <span class="n">preSum</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>二维前缀和的应用</h3>

<p>与一维前缀和类似，二维前缀和的应用用于快速求出区间和，比如求子矩阵和，求[r1,c1]到[r2,c2]之间的子矩阵之和，就可以应用二维前缀和，可以从O(mn)的复杂度降到O(1)。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">sum</span><span class="o">[</span><span class="n">r1</span><span class="o">,</span><span class="n">c1</span><span class="o">]~[</span><span class="n">r2</span><span class="o">,</span><span class="n">c2</span><span class="o">]</span> <span class="o">=</span> <span class="n">preSum</span><span class="o">[</span><span class="n">r2</span><span class="o">,</span><span class="n">c2</span><span class="o">]</span> <span class="o">-</span> <span class="n">preSum</span><span class="o">[</span><span class="n">r2</span><span class="o">,</span><span class="n">c1</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">preSum</span><span class="o">[</span><span class="n">r1</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">c2</span><span class="o">]</span> <span class="o">+</span> <span class="n">preSum</span><span class="o">[</span><span class="n">r1</span><span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="n">c1</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kt">int</span> <span class="nf">regionSum</span><span class="o">(</span><span class="kt">int</span> <span class="n">r1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c1</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r2</span><span class="o">,</span> <span class="kt">int</span> <span class="n">c2</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">r1</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">c1</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">preSum</span><span class="o">[</span><span class="n">r2</span><span class="o">][</span><span class="n">c2</span><span class="o">];</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">preSum</span><span class="o">[</span><span class="n">r2</span><span class="o">][</span><span class="n">c2</span><span class="o">]</span> <span class="o">-</span> <span class="n">preSum</span><span class="o">[</span><span class="n">r2</span><span class="o">][</span><span class="n">c1</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">preSum</span><span class="o">[</span><span class="n">r1</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">c2</span><span class="o">]</span> <span class="o">+</span> <span class="n">preSum</span><span class="o">[</span><span class="n">r1</span> <span class="o">-</span> <span class="mi">1</span><span class="o">][</span><span class="n">c1</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>两个坐标[r1,c1]和[r2,c2]把矩阵分成了三个区域，一是[0, 0]~[r2,c2]这就是preSum[r2,c2]，二是[0,0]~[r2,c1-1]，三是[0,0]~[r1-1,c2]，相减，多减了一个公共区域[0,0]~[r1-1,c1-1]，所以要加回来。</p>

<p><a href="https://github.com/alexhilton/EffectiveAlgorithm/blob/main/datastructure/src/main/java/AuxiliaryMatrix.java">完整代码看这里</a>。</p>

<p>前缀和与差分数组一般作为辅助数组使用，理解了它们的原理对于理解更复杂的数组结构如树状数组是非常有帮助的，<a href="http://toughcoder.net/blog/2022/09/06/intro-to-binary-indexed-tree/">关于树状数组可以参考 此文</a>。</p>

<h2>拓展到后缀和最值</h2>

<p>前缀和是最常用的一种前缀辅助数组，但并不局限于此，也可以用后缀和，视具体情况而定。</p>

<p>另外，还可以拓展到最值，就是说前缀最值（最小值最大值），或者后缀最小值最大值，也可以帮助降低复杂度。</p>

<h2>典型问题</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/my-calendar-ii/">731. 我的日程安排表 II</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/my-calendar-ii/solution/by-alexhilton-bggq/">题解</a> </td>
<td style="text-align:left;"> TreeMap当作差分数组 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/partition-array-into-disjoint-intervals/">915. 分割数组</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/partition-array-into-disjoint-intervals/solution/by-alexhilton-9eh3/">题解</a> </td>
<td style="text-align:left;"> 后缀最小值辅助数组 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/global-and-local-inversions/">775. 全局倒置与局部倒置</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/global-and-local-inversions/solution/by-alexhilton-xagt/">题解</a> </td>
<td style="text-align:left;"> 后缀最小值 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.jianshu.com/p/2a4e861b44ae">差分数组</a></li>
<li><a href="https://blog.csdn.net/qq_31601743/article/details/105352885">什么是差分数组？</a></li>
<li><a href="https://blog.csdn.net/Miracle_ps/article/details/126573360">【LeetCode】一文吃透差分数组（附例题）</a></li>
<li><a href="https://blog.csdn.net/qq_44786250/article/details/100056975">差分数组是个啥？能干啥？怎么用？（差分详解+例题）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/117569086">【朝夕的ACM笔记】算法基础-前缀和</a></li>
<li><a href="https://blog.csdn.net/qq_45914558/article/details/107385862">前缀和【超详细讲解前缀和】</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/436526162">前缀和</a></li>
<li><a href="https://juejin.cn/post/7005057884555837476">面试必会的算法题——前缀和</a></li>
<li><a href="https://juejin.cn/post/6944913393627168798">什么是前缀和?</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/107778275">前缀和技巧</a></li>
<li><a href="https://blog.csdn.net/weixin_45629285/article/details/111146240">前缀和与差分 图文并茂 超详细整理（全网最通俗易懂）</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Dijkstra Algorithm]]></title>
    <link href="http://toughcoder.net/blog/2022/09/12/understanding-dijkstra-algorithm/"/>
    <updated>2022-09-12T10:49:54+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/12/understanding-dijkstra-algorithm</id>
    <content type="html"><![CDATA[<p>最短路径问题，是图论中经常遇到的问题，对于非加权图，用广度优先搜索（BFS）就可以找到两个顶点之间的最短路径（最少边数），但对于加权图，就需要用到著名的犾克斯特拉算法（<a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra Algorithm</a>）。</p>

<p><a href="http://toughcoder.net/blog/2022/09/12/understanding-dijkstra-algorithm/"><img src="https://www.researchgate.net/profile/Atta_Ur_Rehman14/publication/331484960/figure/fig1/AS:732550733512704@1551665113143/Illustration-of-Dijkstras-algorithm.ppm" title="auto auto" ></a></p>

<!-- more -->


<h2>思路</h2>

<p>犾克斯特拉算法的核心思想是：</p>

<ol>
<li>以起步的顶点作为<strong>当前顶点</strong></li>
<li>检查当前顶点的所有邻接顶点，计算当前顶点到所有其邻接顶点的权重，并记录下来</li>
<li>从<strong>未访问过</strong>的邻接顶点中，选择一个总权重最小的顶点，作为下一个<strong>当前顶点</strong></li>
<li>重复第3步，直到图中所有的顶点都被访问过</li>
</ol>


<p>这样就能得到起步顶点到其他所有顶点的最短路径（最小权重）。</p>

<p><img src="https://img-blog.csdnimg.cn/201902261948522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc5NTkyMQ==,size_16,color_FFFFFF,t_70" alt="" /></p>

<h2>实例</h2>

<p>前面的思路听起来还是不够清爽，我们来看一个具体的实例，比如计算不同的城市之间的飞行费用问题，就可以用Dijkstra算法来求解，一共有五个城市，以及它们之间的航班费用：</p>

<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>


<script>mermaid.initialize({startOnLoad:true});</script>


<div class="mermaid">
flowchart LR;
    A([Atlanta])
    B([Boston])
    C([Chicago])
    D([Denver])
    E([El Paso])
        A&#45;&#45; 100 &#45;&#45;>B;
    A&#45;&#45; 160 &#45;&#45;>D;    B&#45;&#45; 120 &#45;&#45;>C;    B&#45;&#45; 180 &#45;&#45;>D;    D&#45;&#45; 40 &#45;&#45;>C;
    D&#45;&#45; 140 &#45;&#45;>E;
    </div>


<p>以Atlanta为起点，来计算到其他几个城市的最小飞行费用，为方便用一个表格来展现Dijkstra算法的每一步：</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 步骤 </th>
<th style="text-align:left;"> 当前顶点 </th>
<th style="text-align:center;"> Atlanta </th>
<th style="text-align:center;"> Boston </th>
<th style="text-align:center;"> Chicago </th>
<th style="text-align:center;"> Denver </th>
<th style="text-align:center;"> El Paso </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 初始化 </td>
<td style="text-align:left;"> n/a </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:left;"> inf为正无穷，代表还未有计算的距离  </td>
</tr>
<tr>
<td style="text-align:left;"> 第1步<br/>起始顶点作为当前顶点 </td>
<td style="text-align:left;"> Atlanta </td>
<td style="text-align:center;"> 0 </td>
<td style="text-align:center;"> 100 </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:center;"> 160 </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:left;"> Atlanta能到达Boston和Denver，是邻接 的顶点 直接填权重 </td>
</tr>
<tr>
<td style="text-align:left;"> 第2步<br/>未访问顶点Boston和Denver中选择权重小的Boston </td>
<td style="text-align:left;"> Boston </td>
<td style="text-align:center;"> 0 </td>
<td style="text-align:center;"> 100 </td>
<td style="text-align:center;"> 220 </td>
<td style="text-align:center;"> 160 </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:left;"> 到Boston的费用是100，以此为基础，<br/>Boston到Chicago是120，所以起始点到Chicago的费用是220。<br/>Boston到Denver是180再加上基础100就是280，它大于Atlanta直飞Denver，所以这个放弃 </td>
</tr>
<tr>
<td style="text-align:left;"> 第3步<br/>未访问的中Denver最小，所以用Denver </td>
<td style="text-align:left;"> Denver </td>
<td style="text-align:center;"> 0 </td>
<td style="text-align:center;"> 100 </td>
<td style="text-align:center;"> 200 </td>
<td style="text-align:center;"> 160 </td>
<td style="text-align:center;"> 300 </td>
<td style="text-align:left;"> 到Denver的费用是160，以此为基础，<br/>Denver到Chicago是40，经Denver到Chicago更划算，所以到Chicago更新为200；<br/>Denver还可以到达El Paso费用是300 </td>
</tr>
<tr>
<td style="text-align:left;"> 第4步<br/>未访问的中Chicago最小，所以用Chicago </td>
<td style="text-align:left;"> Chicago </td>
<td style="text-align:center;"> 0 </td>
<td style="text-align:center;"> 100 </td>
<td style="text-align:center;"> 200 </td>
<td style="text-align:center;"> 160 </td>
<td style="text-align:center;"> 280 </td>
<td style="text-align:left;"> 到Chicago的费用是200，以此为基础，<br/>Chicago到El Paso是80，经Chicago到El Paso更划算，所以到El Paso更新为280 </td>
</tr>
<tr>
<td style="text-align:left;"> 第5步<br/>只有El Paso未访问了，所以用El Paso </td>
<td style="text-align:left;"> El Paso </td>
<td style="text-align:center;"> 0 </td>
<td style="text-align:center;"> 100 </td>
<td style="text-align:center;"> 200 </td>
<td style="text-align:center;"> 160 </td>
<td style="text-align:center;"> 280 </td>
<td style="text-align:left;"> 到El Paso的费用是280，以此为基础，<br/>El Paso到Boston是100，不划算，所以不用更新。<br/>所有顶点都访问过了，这就是Atlanta出发到所有城市的最小飞行费用 </td>
</tr>
</tbody>
</table>


<h2>实现</h2>

<p>Dijkstra算法比较复杂，它的时间空间复杂度都比较高。算法的输入是一个加树图，和一个起始顶点，输出则是一个列表，表示起始顶点到其他顶点的最短路径。</p>

<h3>实现思路</h3>

<ol>
<li>创建一个结果列表，长度是顶点数量N，尽管其实不管起始顶点，但为了方便还是加上，用以存储起始顶点到所有顶点的最小距离，列表初始化为正无穷</li>
<li>创建一个标记列表，长度是N，用以标记顶点是否访问过，在选择下一个当前节点时，以及判断算法是否结束时，都需要用到此列表</li>
<li>选择实始顶点为当前顶点</li>
<li>把当前节点加入到标记列表中</li>
<li>更新最小距离列表：以当前顶点为基础，计算到它的每个邻接顶点的距离（也即基础值加上与其邻接的边的权重），如果距离小于结果列表中的距离，就更新结果列表</li>
<li>选择下一个当前顶点：遍历结果列表，找最小值，并且还未访问过（不在标记列表里），作为下一个当前顶点</li>
<li>重复第4到第6步，直到所有顶点都已标记，这时在第6步肯定 找不到下一个当前顶点</li>
</ol>


<h3>伪代码</h3>

<p>有了前面的实现思路，就不难写出伪代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>creat a list with length of N distanceList, init with MAX
</span><span class='line'>create a set visitedSet
</span><span class='line'>currentNode = start
</span><span class='line'>distanceList[start] = 0
</span><span class='line'>while currentNode is not null:
</span><span class='line'>    add currentNode to visitedSet
</span><span class='line'>    
</span><span class='line'>    base = distanceList[currentNode]
</span><span class='line'>    for each node adjacent with currentNode:
</span><span class='line'>         if node.weight + base &lt; distanceList[node]:
</span><span class='line'>              distanceList[node] = node.weight + base
</span><span class='line'>              
</span><span class='line'>    min = null
</span><span class='line'>    for each node in distanceList:
</span><span class='line'>        if node not in visitedSet and min &gt; distanceList[node]:
</span><span class='line'>              min = node;
</span><span class='line'>    currentNode = min</span></code></pre></td></tr></table></div></figure>


<h3>示例代码</h3>

<p>到了代码层面的实现，需要灵活选择数据结构，如果顶点可以方便的用下标来代表的话，那么就可以用数组代替列表，否则可能就要使用哈希表。这里为了方便，用下标来代表顶点：0代表Atlanta，1代表Boston，2代表Chicago，3代表Denver，4代表El Paso，这样就都可以用数组来当列表用。</p>

<p>图用矩阵来表示，每一行代表到另一个城市的费用，其实默认值可以都用0，在计算费用时就不用特殊处理了，但为了体现邻接顶点，所以没有连通的顶点用-1，自己用0，相邻的顶点才有权重。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DijkstraAlgorithm</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">dijkstra</span><span class="o">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">graph</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">final</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
</span><span class='line'>        <span class="kt">int</span><span class="o">[]</span> <span class="n">distance</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
</span><span class='line'>        <span class="kt">boolean</span><span class="o">[]</span> <span class="n">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">boolean</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
</span><span class='line'>        <span class="n">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">distance</span><span class="o">,</span> <span class="n">Integer</span><span class="o">.</span><span class="na">MAX_VALUE</span><span class="o">);</span>
</span><span class='line'>        <span class="n">Arrays</span><span class="o">.</span><span class="na">fill</span><span class="o">(</span><span class="n">visited</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
</span><span class='line'>        <span class="n">distance</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">current</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(</span><span class="n">current</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">// Mark as current node as visited</span>
</span><span class='line'>            <span class="n">visited</span><span class="o">[</span><span class="n">current</span><span class="o">]</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// Update the shortest distance for the nodes adjacent with current node</span>
</span><span class='line'>            <span class="kd">final</span> <span class="kt">int</span> <span class="n">base</span> <span class="o">=</span> <span class="n">distance</span><span class="o">[</span><span class="n">current</span><span class="o">];</span>
</span><span class='line'>            <span class="kt">int</span><span class="o">[]</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="n">graph</span><span class="o">[</span><span class="n">current</span><span class="o">];</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">neighbors</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                    <span class="c1">// Skip not adjacent node</span>
</span><span class='line'>                    <span class="k">continue</span><span class="o">;</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(</span><span class="n">base</span> <span class="o">+</span> <span class="n">neighbors</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="o">[</span><span class="n">i</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">distance</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">neighbors</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// Pick next current node</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">;</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="o">(!</span><span class="n">visited</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">(</span><span class="n">min</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">distance</span><span class="o">[</span><span class="n">min</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">distance</span><span class="o">[</span><span class="n">i</span><span class="o">]))</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">min</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
</span><span class='line'>                <span class="o">}</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">current</span> <span class="o">=</span> <span class="n">min</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="n">distance</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">String</span><span class="o">[]</span> <span class="n">cities</span> <span class="o">=</span> <span class="o">{</span><span class="s">&quot;Atlanta&quot;</span><span class="o">,</span> <span class="s">&quot;Boston&quot;</span><span class="o">,</span> <span class="s">&quot;Chicago&quot;</span><span class="o">,</span> <span class="s">&quot;Denver&quot;</span><span class="o">,</span> <span class="s">&quot;El Paso&quot;</span><span class="o">};</span>
</span><span class='line'>        <span class="kt">int</span><span class="o">[][]</span> <span class="n">graph</span> <span class="o">=</span> <span class="o">{</span>
</span><span class='line'>                <span class="o">{</span><span class="mi">0</span><span class="o">,</span> <span class="mi">100</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">160</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">},</span>
</span><span class='line'>                <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">120</span><span class="o">,</span> <span class="mi">180</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">},</span>
</span><span class='line'>                <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">80</span><span class="o">},</span>
</span><span class='line'>                <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">40</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">140</span><span class="o">},</span>
</span><span class='line'>                <span class="o">{-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">100</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">},</span>
</span><span class='line'>        <span class="o">};</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>        <span class="kt">int</span><span class="o">[]</span> <span class="n">shortestPath</span> <span class="o">=</span> <span class="n">dijkstra</span><span class="o">(</span><span class="n">graph</span><span class="o">,</span> <span class="n">start</span><span class="o">);</span>
</span><span class='line'>        <span class="n">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">graph</span><span class="o">.</span><span class="na">length</span><span class="o">)</span>
</span><span class='line'>                <span class="o">.</span><span class="na">mapToObj</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="s">&quot;Shortest distance from &quot;</span> <span class="o">+</span> <span class="n">cities</span><span class="o">[</span><span class="n">start</span><span class="o">]</span> <span class="o">+</span> <span class="s">&quot; to &quot;</span> <span class="o">+</span> <span class="n">cities</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="s">&quot;: &quot;</span> <span class="o">+</span> <span class="n">shortestPath</span><span class="o">[</span><span class="n">i</span><span class="o">])</span>
</span><span class='line'>                <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">::</span><span class="n">println</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>输出结果：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Shortest</span> <span class="n">distance</span> <span class="n">from</span> <span class="n">Atlanta</span> <span class="n">to</span> <span class="nl">Boston:</span> <span class="mi">100</span>
</span><span class='line'><span class="n">Shortest</span> <span class="n">distance</span> <span class="n">from</span> <span class="n">Atlanta</span> <span class="n">to</span> <span class="nl">Chicago:</span> <span class="mi">200</span>
</span><span class='line'><span class="n">Shortest</span> <span class="n">distance</span> <span class="n">from</span> <span class="n">Atlanta</span> <span class="n">to</span> <span class="nl">Denver:</span> <span class="mi">160</span>
</span><span class='line'><span class="n">Shortest</span> <span class="n">distance</span> <span class="n">from</span> <span class="n">Atlanta</span> <span class="n">to</span> <span class="n">El</span> <span class="nl">Paso:</span> <span class="mi">280</span>
</span></code></pre></td></tr></table></div></figure>


<h2>应用</h2>

<p>Dijkstra算法只能用于有向无环加权图（DAG），且没有负权重的情况下，才可以正常工作。并且，它的复杂度较高，如果顶点数量为n，那么它的时间复杂度会达到O(n<sup>2</sup>)。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/">Dijkstra’s Shortest Path Algorithm</a></li>
<li><a href="https://www.freecodecamp.org/news/dijkstras-shortest-path-algorithm-visual-introduction/">Dijkstra&rsquo;s Shortest Path Algorithm - A Detailed and Visual Introduction</a></li>
<li><a href="https://www.programiz.com/dsa/dijkstra-algorithm">Dijkstra&rsquo;s Algorithm</a></li>
<li><a href="https://brilliant.org/wiki/dijkstras-short-path-finder/">Dijkstra&rsquo;s Shortest Path Algorithm</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/338414118">Dijkstra算法详解 通俗易懂</a></li>
<li><a href="https://blog.csdn.net/lbperfect123/article/details/84281300">Dijkstra算法图文详解</a></li>
<li><a href="https://blog.csdn.net/qq_35644234/article/details/60870719">最短路径问题&mdash;Dijkstra算法详解</a></li>
<li><a href="https://www.cnblogs.com/dijkstra2003/p/7222182.html">Dijkstra 最短路径算法 秒懂详解</a></li>
<li><a href="https://www.cnblogs.com/goldsunshine/p/12978305.html">一篇文章讲透Dijkstra最短路径算法</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图论基础知识]]></title>
    <link href="http://toughcoder.net/blog/2022/09/08/graph-data-structure-made-easy/"/>
    <updated>2022-09-08T18:05:45+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/08/graph-data-structure-made-easy</id>
    <content type="html"><![CDATA[<p>图（<a href="https://en.wikipedia.org/wiki/Graph_(abstract_data_type">Graph</a>)）是一个由节点和边组成的略复杂的二维数据结构，通常用于表示物体之间的关系。</p>

<p><a href="http://toughcoder.net/blog/2022/09/08/graph-data-structure-made-easy/"><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.-HB8jzKKYmCKNH9ui2LDpwHaDH?pid=ImgDet&rs=1" title="auto auto" ></a></p>

<!-- more -->


<h2>图的基础知识</h2>

<p>图由节点（Vertex）和边（Edge）组成，节点之间会有边来连接以表示某种关系。逻辑上的形状会是这样子的：
<img src="https://www.thecrazyprogrammer.com/wp-content/uploads/2017/08/Graph-Data-Structure.png" alt="" /></p>

<p>图的节点通常用于表示物体或者数值，变化较少，图的复杂性主要就体现在边上面，比如有些是有向的，有些是无向的，还有指向自己的。</p>

<h3>顶点</h3>

<p>顶点即Vertex，是图的基本单元，也称作节点。</p>

<h3>边</h3>

<p>边是Edge，两个顶点之间的连接称为边。分为无方向的，有方向的，和带权重的。</p>

<h3>权重</h3>

<p>权重，weight，是边的一个属性，一条边（也即两个顶点的连接）可以带有权重以表示某种成本。</p>

<h3>路径 Path</h3>

<p>在一个图中，路径是一系列节点和边，其中的节点都由边连接</p>

<h3>路径长度 Path length</h3>

<p>两个节点之间的边的数量称为路径长度</p>

<h3>简单路径 Simple Path</h3>

<p>一个路径所经过的节点没有重复的，就称为简单路径</p>

<h3>根 Root</h3>

<p>如果一个节点，由它出发的路径可以连通到所有节点，那么这个节点称作图根</p>

<h3>环 Cycle</h3>

<p>存在路径起始节点相同，就形成了环</p>

<h3>度 Degrees</h3>

<p>针对 节点而言，经过一个节点的所有边的数量之和，称之为节点的度</p>

<h3>入度 In degress</h3>

<p>对于有向图而言，以节点为终点的边的数量，称这节点的入度。</p>

<h3>出度 Out degrees</h3>

<p>对于有向图而言，从一个节点出发的边的数量，称为节点的出度。</p>

<h2>图的分类</h2>

<h3>空图 Null graph</h3>

<p>也就是只有顶点，没有边的图，样子大概是这样：</br>
<img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.QifCHVxIx4myhHIXgxapLQAAAA?pid=ImgDet&amp;rs=1" alt="" /></p>

<h3>有限图 Finite graph</h3>

<p>顶点和边的数量是有限的，接触到的绝大多数图都是有限图。</p>

<h3>无限图 Infinite graph</h3>

<p>顶点和边的数量是无限的</br>
<img src="https://www.researchgate.net/profile/David-Evans-81/publication/225108378/figure/fig1/AS:393838129631243@1470909735860/The-infinite-graph-A-6.png" alt="" /></p>

<h3>完全图 Complete graph</h3>

<p>所有节点都是有路径连通的</br>
<img src="https://miro.medium.com/max/7954/1*q0tQ1svUWfN05kWsZ_Uo2g.jpeg" alt="" /></p>

<h3>权重图 Weighted graph</h3>

<p>每一条边都有一个数值表示的权重以代表两个节点之间的某种成本</p>

<p><img src="https://i1.wp.com/algorithms.tutorialhorizon.com/files/2018/03/Weighted-Graph.png?ssl=1" alt="" /></p>

<h3>无向图 Undirected graph</h3>

<p>连接节点之间的边是没有方向的，称之为无向图，它也是普通 的图</p>

<h3>有向图 Directed graph</h3>

<p>每条边都是有方向的，对于两个节点来说v[i]和v[j]来说，e[i,j]=(v[i],v[j])，它与e[j,i]=(v[j],v[i])是不一样的，有向图通常用于表示物体之间的依赖关系</p>

<p><img src="https://www.filepicker.io/api/file/1KMTR25HS2OzpZcpy0mJ" alt="" /></p>

<h3>连通图 Connected graph</h3>

<p>任意两节点都连通，称之为连通图也叫强连通图。</p>

<h3>非连通图 Disconnected graph</h3>

<p>有两个节点没有边连接，就称为非连通图。</p>

<h3>自环</h3>

<p>也就是某个节点有一条边是自己连接着自己，这个有向和无向图都可以有</p>

<h3>有环图 Cyclic graph</h3>

<p>起点和终点相同的路径，就形成了环。如果图中存在一个环，就是有环图。</p>

<p><img src="https://www.droidtechknow.com/programming/data-structure/an-introduction-to-graph-data-structure/images/graph-example.jpg" alt="" /></p>

<h3>无环图 Acyclic graph</h3>

<p>图中没有环就是无环图</p>

<h3>有向无环图 Directed Acyclic Graph</h3>

<p>有向图中不存在环就是DAG，这是比较重要的一种图，拓扑排序 可以验证DAG。</p>

<p><img src="https://wiki.swarma.org/images/c/cd/A_DAG_G.png" alt="" /></p>

<ul>
<li><a href="https://www.geeksforgeeks.org/introduction-to-graphs/">Introduction to Graphs</a></li>
</ul>


<h2>图的表示方法</h2>

<p>图的表示方法一般有邻接矩阵法和邻接表法。</p>

<h3>邻接矩阵 Adjacency Matrix</h3>

<p>对于有n个顶点的图来说要创建一个nxn的矩阵来表示此图，每一个格子[i,j]表示顶点v[i]到v[j]是连通的，有一条边存在，如果是有向图，则[j,i]表示v[j]到v[i]的边。另外，如果有权重，格子的值也可以表示边的权重。
<img src="https://educativesite.com/wp-content/uploads/2019/09/incidence-matrix.png" alt="" />
因为用矩阵一般比较浪费空间，比如顶点较多，但边较少时，就有点浪费空间。一般，矩阵通常就是一类单独的矩阵类搜索问题，直接应用图的搜索方法。</p>

<h3>邻接表 Adjacency List</h3>

<p>也就是列表的列表，先用一个链表代表所有的顶点，然后这个链表的元素是这个与这个顶点相连的所有顶点组成的列表。
<img src="https://cdn.programiz.com/sites/tutorial2program/files/adjacency-list.png" alt="" />
通常是用数组加链表的形式，主表用数组或者可变长数组，因为这些都是顶点，有可能会随时从某个顶点开始遍历，所以要用随机访问效率高一些的数组。与顶点相连的顶点列表一般用链表，因为它方便删除和插入，且遍历一般都是从顶点开始遍历。</p>

<p><img src="https://ts1.cn.mm.bing.net/th/id/R-C.4fe11a408a41fa5509274d85a4c09c1f?rik=YfKo9VJ94v7kxw&amp;riu=http%3a%2f%2fprogressivecoder.com%2fwp-content%2fuploads%2f2020%2f12%2fadjacency-list.png&amp;ehk=WAS3o3piPNsR6QCXSeDCVsjO%2fcuyO6KisgW5kv4uwYQ%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" /></p>

<p>但，也要看实际情况，有时候用哈希表也可以，键是每个顶点，值为顶点所连接的顶点列表，顶点列表可以用列表，也可以用Set等等。</p>

<p><img src="https://condor.depaul.edu/glancast/393class/docs/images/topsort7C++.gif" alt="" /></p>

<p>邻接表的实现方式比较自由，只要能从一个顶点出发，方便的找到与其相连的顶点，就可以。具体的，可以依据实际数据情况来灵活选择，比如说顶点如果是某一个范围内的整数，那么可能用数组就更方便一些，如果是字串或者其他的，可能用哈希表就更方便一些。</p>

<ul>
<li><a href="https://www.geeksforgeeks.org/graph-and-its-representations/">Graph and its representations</a></li>
</ul>


<h2>图与树的关系</h2>

<p>图是一个比较大的概念，只要是有节点与节点相连接就可以看作是图，数组（可视为下标与元素的连接），哈希表（键与值的连接），树，链表都可以看作是图。这些数据结构是一种特殊的图，强加了很多其他规则，就比如树，有一个根，有多个子节点。</p>

<p><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.sELEF-9VK_G1wwU413LUFgAAAA?pid=ImgDet&amp;rs=1" alt="" /></p>

<p>适用于图的很多算法也适用树，比如DFS和BFS对树也是适用的。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/">Graph Data Structure And Algorithms</a></li>
<li><a href="https://www.programiz.com/dsa/graph">Graph Data Stucture</a></li>
<li><a href="https://medium.com/data-structures-and-algorithms/graph-dd2b72c32f1f">Graph</a></li>
<li><a href="https://www.simplilearn.com/tutorials/data-structure-tutorial/graphs-in-data-structure">Your One-Stop Solution For Graphs In Data Structures</a></li>
<li><a href="https://www.runoob.com/data-structures/graph-theory.html">图论基础和表示</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/124259930">【朝夕的ACM笔记】图论-图论基础概念</a></li>
<li><a href="https://blog.csdn.net/Karen_Yu_/article/details/78776354">图论基础知识总结（一）</a></li>
<li><a href="https://cuigeg.github.io/2017/06/27/Graph-theory/">这一点点的图论基础</a></li>
<li><a href="https://labuladong.github.io/algo/2/22/50/">图论基础及遍历算法</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1922486">图论算法基础（修订版）</a></li>
<li><a href="https://www.cnblogs.com/BlairGrowing/p/13637688.html">图论&mdash;-基础知识 </a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解并运用并查集]]></title>
    <link href="http://toughcoder.net/blog/2022/09/08/disjoint-set-data-structure/"/>
    <updated>2022-09-08T17:27:05+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/08/disjoint-set-data-structure</id>
    <content type="html"><![CDATA[<p><a href="">并查集</a>（<a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">Disjoint-set Data Structure</a>）是一种树形的结构，用于处理<strong>不相交</strong>的集合的高效的查询(find)和合并(union)问题。主要有两种操作一是查询(find)，也就是查询某个元素是否属于某个集合；二是合并(union)，也即把某个加入到某个集合中，这里的集合都是无交集的。通过路径压缩，并查集的查询和合并都可以达到常数级别O(1)。</p>

<p><a href="http://toughcoder.net/blog/2022/09/08/disjoint-set-data-structure/"><img src="https://images.xiaozhuanlan.com/photo/2019/891afdf6961c0eab3d3aa28a3f355e12.png" title="auto auto" ></a></p>

<!-- more -->


<h2>朋友关系问题</h2>

<p>先来看一个问题，比如有一个朋友关系的问题，两个人可以成为朋友关系，两两是朋友的一群人就形成了一个朋友圈，那么如何快速判断某两个是不是朋友关系呢？又如何让两个人成为朋友呢？</p>

<p>一个可行的方法是用图的搜索，两个人的朋友关系可以视为图的一条边，一个朋友圈就是相互连通的一个图，查看两人是否是朋友关系，可以从一个人出发，不断遍历相连的边，看能否到达另一个人，但这样效率有点低，每次查询 都会是线性时间，因为都要遍历一遍图才知道。</p>

<p>我们换个思路，可以为一个朋友图指定一个『圈长』，把关系改成其他人都直接跟圈长相连，或者每个人都能找到自己的圈长，这时判断两个人是不是在同一个朋友圈内，就看它们的圈长是不是同一个人就可以了，这就是并查集。</p>

<p><img src="https://red-green-rewrite.github.io/images/maze/disjoint-set-merge-3+7.png" alt="" /></p>

<h2>并查集的概念与基本实现</h2>

<p>并查集用以表示不相交的集合，逻辑上它是一种扁平的树形结构，每一个树代表一个集合，树的根就是这个集合的『圈长』，或者叫做一个集合的代表（representative）。并查集支持两种操作，查询（find） 和合并（union），查询是看两个元素是否属于同一个集合，合并则是把两个集合合并成为一个集合。</p>

<p>并查集的精髓就在于它的『圈长』机制，我们不管具体某个元素它的路径与关系，每个元素都只关心自己的圈长，它能找到自己的圈长就可以，因此查询是否属于同一个集合就看元素的圈长是否是同一个；合并，也非常简单，两个集合合并，就是把其中一个圈长的圈长设置为另一个圈长就可以了。</p>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.ywrpxwo6g4mKItHNwrzyVgHaFU?pid=ImgDet&amp;rs=1" alt="" /></p>

<h3>具体实现</h3>

<p>需要注意，虽然并查集逻辑上是一种树形结构，但一般情况都用线性的数组来实现并查集。比如用一个长度为n的数组来表示并查集，实际上我们只关心圈长，所以下标为i的元素就是i的圈长，一般命名为parent，也就是说parent[i]就是i的圈长，或者顺着它就能找到圈长（树的根），而parent[i]=i则是一个集合的『圈长』（representative）。</p>

<p>初始时，每个元素都是独立的，每个元素都独立成团，自己就是圈长，也即parent[i]=i。当有元素合并了，就把它们指向同一个圈长，比如parent[8]=6，parent[1]=6，parent[2]=4，parent[3]=4，parent[9]=4，parent[7]=4，这样就知道一共有三个集合，其中5独自成一个集合，1和8还有6是同一个集合6是他们的圈长，2，3，9，7，4是同一个集合4是圈长，画出图来就是这样的：</p>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.aqoDLciI4xvo7AnTDg3KRQHaFI?pid=ImgDet&amp;rs=1" alt="" /></p>

<h3>查询与合并</h3>

<p>查询某两个元素是否属于同一个集合，就是归结来查找每个人所属集合的圈长（representative），然后判断是否是同一个元素，因此问题归结为圈长的查找。比如2的父节点是4，而parent[4]=4，它就是圈长，所以2的圈长是4；再看7，它的父节点是9，而9的父节点是4，4是圈长，因此2和7属于同一个集合。</p>

<p>合并，也是类似的，而且更加简单，先查询要合并是否属于同一个集合，如果属于那自然就不用合并了。如果不是，那就找到各自的圈长，然后把某一个圈长的圈长设为另一个即可。比如想把5和8合并，5独自成圈，而8的圈长是6，那么把5的圈长设置为6，parent[5]=6，就合并完成了。</p>

<p><strong>注意</strong>：并查集的具体实现要看实际数据类型，比如集合元素个休是一个0~n范围内的整数，那么自然用数据非常方便，或者能够方便的转化为数组的下标时，用数组也行。否则也可以用哈希表。因为元素只要能递归的向上找到它的圈长（树的根）就行。</p>

<h2>路径压缩</h2>

<p>从前面的例子来看，查询过程其实是O(n)的，因为某个元素的父节点不一定就是圈长，为了找到圈长要递归的找下去，直到找到圈长为止，即只有找到了parent[i]=i，才算找到了圈长。这样每次查询都是线性时间，就会导致并查集整体效率变成O(n<sup>2</sup>)的。</p>

<p>因为并查集是处理集合问题，也就是说我们只关系某两个元素是否属于同一个集合，至于它跟其他元素之间的关系并不重要，我们只希望快速的找到它的圈长就可以了，那么我们在查找圈长的过程中，就可以把元素都直接指向其圈长，比如前面的7，它的父节点是9，不是圈长，我们查找后发现圈长是4，那么在查询过程中就可以把parent[7]=4，让7的父节点变成圈长。这样做的好处是，下次再查询时就能直接找到圈长了，变成了O(1)，不用再线性去查找了，这便是路径压缩。路径压缩的复杂度是常数级别的。准确说它的复杂度是O(alpha(n))，这个alpha(n)叫做<a href="https://en.wikipedia.org/wiki/Ackermann_function">反阿克曼函数</a>，当n无限增大时，这个函数的极限值是5，有兴趣的<a href="https://zhuanlan.zhihu.com/p/93644792">可以深入研究</a>。</p>

<p>最终树变成了扁平的，集合中的每一个元素都直接指向圈长：</p>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.v4afq3bNSl3SnFPKfVM3jwHaCO?pid=ImgDet&amp;rs=1" alt="" /></p>

<h2>按秩合并</h2>

<p>合并的时候是把一个集合的圈长的圈长设置为另一个集合的圈长，比如前面5和8要合并，5的圈长是5，8的圈长是6，这时其实有两种可行方法，可以把5的圈长设为6，即parent[5]=6，但也可以把6的圈长设置为5啊，即parent[6]=5，逻辑上都可行的，但应该用哪种呢？</p>

<p>逻辑上并无对错，要从效率上来比较哪个更好。前面提到了，常规查询是线性时间的，集合是树形的，树的高度越高，那么找到圈长的时间就越长，路径压缩后树才会变得扁平，因此，可以认为树的高度是越小越好的。由此来看，把5的圈长设置为6效率更高，6这个集合高度是2，如果把6的圈长设置为5，那么树的高度会变成3，需要一次路径压缩才可以；相反，如果把5的圈长设置为6，即parent[5]=6，那么树的高度还是2，不需要额外的路径压缩了。所以应该把高度小的集合并到高度大的集合中去。</p>

<p>那么，可以用另外一个数组rank来表示集合的秩，即rank[i]是i所属于集合的秩，也就是树的高度，当合并的时候就可以参考 rank来进行更高效的合并，总是把秩低的往秩高的上面的合并。只看圈长的秩就可以了，因为合并的时候是两个圈长在打架。</p>

<h2>实例</h2>

<p>还是来一个具体的实例，来演示并查集的思路和具体实现。把朋友圈关系进行抽象，用数字0~n来代表N个人，N=n+1，实现一个并查集，并进行查询和合并操作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DisjointSet</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">parent</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">rank</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">DisjointSet</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="n">size</span><span class="o">;</span>
</span><span class='line'>        <span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
</span><span class='line'>        <span class="n">rank</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
</span><span class='line'>        <span class="n">init</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">init</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">parent</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">union</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">xRoot</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">x</span><span class="o">);</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">yRoot</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">y</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">xRoot</span> <span class="o">==</span> <span class="n">yRoot</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">// In the same set already, do nothing</span>
</span><span class='line'>            <span class="k">return</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Union by rank, ruled by higher rank.</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">rank</span><span class="o">[</span><span class="n">xRoot</span><span class="o">]</span> <span class="o">&lt;</span> <span class="n">rank</span><span class="o">[</span><span class="n">yRoot</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">parent</span><span class="o">[</span><span class="n">xRoot</span><span class="o">]</span> <span class="o">=</span> <span class="n">yRoot</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">rank</span><span class="o">[</span><span class="n">xRoot</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">rank</span><span class="o">[</span><span class="n">yRoot</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">parent</span><span class="o">[</span><span class="n">yRoot</span><span class="o">]</span> <span class="o">=</span> <span class="n">xRoot</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">parent</span><span class="o">[</span><span class="n">xRoot</span><span class="o">]</span> <span class="o">=</span> <span class="n">yRoot</span><span class="o">;</span>
</span><span class='line'>            <span class="n">rank</span><span class="o">[</span><span class="n">yRoot</span><span class="o">]++;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">find</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">==</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">x</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Path compression</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">root</span> <span class="o">=</span> <span class="n">find</span><span class="o">(</span><span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]);</span>
</span><span class='line'>        <span class="c1">// Make each node point to its root</span>
</span><span class='line'>        <span class="n">parent</span><span class="o">[</span><span class="n">x</span><span class="o">]</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">root</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">DisjointSet</span> <span class="n">dset</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">DisjointSet</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
</span><span class='line'>        <span class="n">dset</span><span class="o">.</span><span class="na">union</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
</span><span class='line'>        <span class="n">dset</span><span class="o">.</span><span class="na">union</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
</span><span class='line'>        <span class="n">dset</span><span class="o">.</span><span class="na">union</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;True: &quot;</span> <span class="o">+</span> <span class="o">(</span><span class="n">dset</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span> <span class="o">==</span> <span class="n">dset</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="mi">0</span><span class="o">)));</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;False: &quot;</span> <span class="o">+</span> <span class="o">(</span><span class="n">dset</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span> <span class="o">==</span> <span class="n">dset</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="mi">0</span><span class="o">)));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>并查集的应用</h2>

<p>可以发现并查集是一个<strong>很优雅</strong>的数据结构，它的实现很简单，效率却非常高。凡是涉及不相交集合的查找与合并问题，都可以使用并查集来解决问题。这里最为关键的是集合元素之间不能有交集，也就是说除以我们指定的圈长方式来划分集合以外，不能有其他的约束条件，否则并查集就失效了。比如说现实生活中的人，可以以工作所在的公司来划分集合，也可以以住的小区来划分，假如题目中两个约束条件都在，那就没有办法应用并查集了。</p>

<p>并查集相关的题目，一般求解的是集合的数量，或者找最大集合，或者找最小集合。这两种统计结果都可以由内部的数据来得到。比如集合的数量，就是遍历parent数组，找到所有的parent[i]=i；而集合的大小，则可以用用秩来追踪，只需要合并的时候把秩也加上，最大集合就是找秩的最大值，可以参考题695。</p>

<p>并查集<strong>最大的特点是集合中的元素直接跟根节点产生关系</strong>，因此如果能够根据元素与根节点的关系继而计算出两两元素之间的关系，那么也是可以应用并查集的，带权并查集就是此类问题，可参考 题399。</p>

<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-consecutive-sequence/solution/by-alexhilton-ip97/">题解</a> </td>
<td style="text-align:left;"> 用哈希表代替数组 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-islands/solution/200-dao-yu-shu-liang-by-alexhilton-cexx/">题解</a> </td>
<td style="text-align:left;"> 集合的数量即是岛屿数量 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/max-area-of-island/solution/by-alexhilton-9eby/">题解</a> </td>
<td style="text-align:left;"> 秩的最大值即是最大的岛屿 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/evaluate-division/">399. 除法求值</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/evaluate-division/solution/399-chu-fa-qiu-zhi-by-alexhilton-euqp/">题解</a> </td>
<td style="text-align:left;"> 带权并查集，节点映射 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/possible-bipartition/"> 886. 可能的二分法</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/possible-bipartition/solution/886-ke-neng-de-er-fen-fa-by-alexhilton-5au7/">题解</a> </td>
<td style="text-align:left;"> 建图，基本并查集，二分图 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-provinces/">547. 省份数量</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-provinces/solution/by-alexhilton-liy7/">题解</a> </td>
<td style="text-align:left;"> 标准并查集 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/find-if-path-exists-in-graph/">1971. 寻找图中是否存在路径</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/find-if-path-exists-in-graph/solution/by-alexhilton-uucs/">题解</a> </td>
<td style="text-align:left;"> 标准并查集 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/disjoint-set-data-structures/">Disjoint Set Data Structures</a></li>
<li><a href="https://cp-algorithms.com/data_structures/disjoint_set_union.html">Disjoint Set Union</a></li>
<li><a href="https://www.javatpoint.com/disjoint-set-data-structure">Disjoint set data structure</a></li>
<li><a href="https://www.techiedelight.com/disjoint-set-data-structure-union-find-algorithm/">Disjoint–Set Data Structure (Union–Find Algorithm)</a></li>
<li><a href="https://www.hackerearth.com/practice/notes/disjoint-set-union-union-find/">Disjoint Set Union (Union Find)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/93647900">算法学习笔记(1) : 并查集</a></li>
<li><a href="https://oi-wiki.org/ds/dsu/">并查集</a></li>
<li><a href="https://www.cnblogs.com/onlyblues/p/14668087.html">并查集算法 </a></li>
<li><a href="https://segmentfault.com/a/1190000022952886">图解并查集，附赠几道 Leetcode 练手题</a></li>
<li><a href="https://blog.csdn.net/weixin_44176696/article/details/106434770">简单并查集讲解（并+查）与代码实现</a></li>
<li><a href="https://zh-spike.github.io/studyRepo/Algorithm/Notes/AdvancedDataStructure/%E5%B9%B6%E6%9F%A5%E9%9B%86/">并查集</a></li>
<li><a href="https://leetcode.cn/circle/discuss/qmjuMW/">并查集从入门到出门</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解拓扑排序]]></title>
    <link href="http://toughcoder.net/blog/2022/09/08/topological-sorting/"/>
    <updated>2022-09-08T16:41:37+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/08/topological-sorting</id>
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/5223807">拓扑排序</a>（<a href="https://en.wikipedia.org/wiki/Topological_sorting">Topological Sorting</a>）是指将一个有向无环图（Directed Acyclic Graph）的所有顶点排成一个线性序列，使得图中的起始节点总是排在终止节点的前面，这是有向图每一个边都有起始节点和终止节点。这个名字有点容易混淆，它跟排序算法没有任何关系，拓扑排序仅是针对有向无环图，找到所有节点的一个可达的线性顺序。</p>

<p><a href="http://toughcoder.net/blog/2022/09/08/topological-sorting/"><img src="https://iq.opengenus.org/content/images/2020/03/topo1-1.png" title="auto auto" ></a></p>

<!-- more -->


<p>关于图的基本概念可以<a href="http://toughcoder.net/blog/2022/09/08/graph-data-structure-made-easy/">参阅这个文章</a>。</p>

<h2>理解拓扑排序</h2>

<p>拓扑排序是针对有向无环图才有意义，它是有向无环图所有顶点的一个线性序列，每个顶点只出现一次，所有顶点都要出现，如果有一条边是从顶点v[i]到v[j]的，那么在拓扑排序中v[i]一定要排在v[j]的前面。</p>

<p><img src="https://wiki.swarma.org/images/c/cd/A_DAG_G.png" alt="" /></p>

<p>有向无环图不一定存在拓扑排序，比如图不是全连通的，有些节点之间没有路径连接。但存在拓扑排序的一定是有向无环图，因此拓扑排序可以用来验证一个图是否是有向无环图。</p>

<h2>拓扑排序的意义</h2>

<p>拓扑排序通常代表着顶点之间的依赖关系，比如软件库的依赖关系，比如课程之间的依赖关系，比如任务调度中的依赖关系等，拓扑排序能够保证任务正确执行，被依赖的肯定 能先执行完，两个顶点（代表的任务）要么是有依赖关系的，要么是没有关系的，在拓扑排序中肯定 不会存在依赖错乱。</p>

<h2>拓扑排序的实现方法</h2>

<p>借助BFS可以实现拓扑排序。</p>

<p><img src="https://www.omegaxyz.com/wp-content/uploads/2019/02/topological2.jpg" alt="" /></p>

<h3>实现思路</h3>

<ol>
<li>先计算顶点的入度，入度是针对 有向图而言的，以顶点为终点的边的数量称为顶点的入度</li>
<li>从入度为为0的顶点开始，把它放入队列</li>
<li>每次从队列中取出顶点，打印出来。然后把这个节点所能直接连通的节点入度减1，并取出入度为0的顶点放入队列</li>
<li>重复第3步，直到没有入度为0的顶点，这时应该所有顶点都遍历到了，如果还有剩余顶点，说明有环</li>
</ol>


<p><img src="https://www.omegaxyz.com/wp-content/uploads/2019/02/topological.png" alt="" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'>    <span class="n">Queue</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">queue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;();</span>
</span><span class='line'>    <span class="n">IntStream</span><span class="o">.</span><span class="na">range</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">numCourses</span><span class="o">)</span>
</span><span class='line'>        <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">i</span> <span class="o">-&gt;</span> <span class="n">inDegrees</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>        <span class="o">.</span><span class="na">forEach</span><span class="o">(</span><span class="nl">queue:</span><span class="o">:</span><span class="n">offer</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">while</span> <span class="o">(!</span><span class="n">queue</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">from</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="na">poll</span><span class="o">();</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">v</span> <span class="o">:</span> <span class="n">graph</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">from</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">inDegrees</span><span class="o">[</span><span class="n">v</span><span class="o">]--;</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">inDegrees</span><span class="o">[</span><span class="n">v</span><span class="o">]</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">queue</span><span class="o">.</span><span class="na">offer</span><span class="o">(</span><span class="n">v</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/course-schedule/solution/by-alexhilton-r7hf/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/ur2n8P/">剑指 Offer II 115. 重建序列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/ur2n8P/solution/by-alexhilton-qc9l/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/topological-sorting/">Topological Sorting</a></li>
<li><a href="https://www.interviewcake.com/concept/java/topological-sort">Topological Sort</a></li>
<li><a href="https://www.hackerearth.com/practice/algorithms/graphs/topological-sort/tutorial/">Topological Sort</a></li>
<li><a href="https://www.scaler.com/topics/data-structures/topological-sort-algorithm/">Topological Sort Algorithm</a></li>
<li><a href="https://cp-algorithms.com/graph/topological-sort.html">Topological Sorting</a></li>
<li><a href="https://www.javatpoint.com/topological-sorting">Topological Sorting</a></li>
<li><a href="https://songlee24.github.io/2015/05/07/topological-sorting/">拓扑排序（Topological Sorting）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/135094687">图文详解面试常考算法 —— 拓扑排序</a></li>
<li><a href="https://oi-wiki.org/graph/topo/">拓扑排序</a></li>
<li><a href="https://www.cnblogs.com/bigsai/p/11489260.html">拓扑排序详解与实现</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记忆化搜索简介]]></title>
    <link href="http://toughcoder.net/blog/2022/09/08/memorization-search/"/>
    <updated>2022-09-08T16:03:31+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/08/memorization-search</id>
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/4275706">记忆化搜索</a>（Memorization Search），是指在做搜索过程中（比如DFS或者动态规划中）把重叠的子问题的解或者状态存储下来，以防止重复计算。最为常见的就是图搜索方法BFS和DFS时都要对已搜索过的节点进行标记以防止重复遍历，这就是一种记忆化搜索方法。再如动态规划的重复子问题，用数组进行缓存以防止重复计算，这也是一种记忆化搜索方法。</p>

<p><a href="http://toughcoder.net/blog/2022/09/08/memorization-search/"><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.3-yxYgu36IJsH2oONsdqFQHaEe?pid=ImgDet&rs=1" title="auto auto" ></a></p>

<!-- more -->


<h2>记忆化搜索</h2>

<p>记忆化搜索是自上而下的优化过程，通常用于优化有递推关系的递归算式，比如一些重叠子问题，像爬楼梯或者Fibonacci数列问题，它们的求解是f(i)=f(i-1)+f(i-2)，如果直接使用递归算式也能得到答案，但重复计算太多，因此可以递推过程中引入记忆化搜索，用额外的存储空间把已计算过的值缓存下来，然后递归过程中如果需要引用时，就直接引用不用再重复计算。</p>

<p>它与动态规划的区别就在于，记忆化搜索是自顶而下的，正面的调用递归关系，比较符合常规的思维模式。但动态规划一般是自下而上的逆向求解递推关系。比如像Fibonacci数列，递推关系是f(i)=f(i-1)+f(i-2)，动态规划是要把i从0到n这样逆着递推出来。</p>

<p>但关键的地方都在于先找到状态转移方程（也即递推关系）。</p>

<p>记忆化搜索要选用状态转移方程所定义的参数作为参数，然后进行向下递归调用。</p>

<p>应用记忆化搜索时要注意缓存结果状态时，需要对状态进行定义，一般要分为三种状态：1）是未计算的状态，这个很关键，因为未计算就要先去计算，否则就可以直接返回结果；2）是非法解，也即是找不到合理的解时的状态，这个是非法解也是解的一种，并不是未计算；3）是合法解。</p>

<p>还需要注意状态的个数，状态一般用数组或者哈希表来呈现，还要注意它与参数之间的对应关系。</p>

<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/palindrome-partitioning/solution/by-alexhilton-mqgw/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/coin-change/solution/322-ling-qian-dui-huan-by-alexhilton-pqum/">题解</a> </td>
<td style="text-align:left;"> 典型的递推式记忆化搜索 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/memoization-1d-2d-and-3d/">Memoization (1D, 2D and 3D)</a></li>
<li><a href="https://oi-wiki.org/dp/memo/">记忆化搜索</a></li>
<li><a href="https://blog.csdn.net/hjf1201/article/details/78680814">记忆化搜索专题</a></li>
<li><a href="https://blog.csdn.net/u010700335/article/details/44136339">记忆化搜索（搜索+dp思想）</a></li>
<li><a href="https://www.cnblogs.com/jinkun113/p/12531918.html">[知识点] 4.1 记忆化搜索与动态规划</a></li>
<li><a href="https://www.zhihu.com/question/60730045">记忆化搜索与动态规划等价吗？</a></li>
<li><a href="http://yudaer.github.io/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/">记忆化搜索</a></li>
<li><a href="https://www.luogu.com.cn/blog/interestingLSY/memdfs-and-dp">聊聊动态规划与记忆化搜索</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/438406757">记忆化搜索 —— 搜索 or 动态规划 ？</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[动态规划从入门到放弃]]></title>
    <link href="http://toughcoder.net/blog/2022/09/08/introduction-to-dynamic-programming/"/>
    <updated>2022-09-08T11:26:06+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/08/introduction-to-dynamic-programming</id>
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408">动态规划</a>(<a href="https://en.wikipedia.org/wiki/Dynamic_programming">Dynamic Programming</a>)动态规划是用来求解具有最优子结构性质问题的一种方法。通俗的来说如果一个问题可以分成多个子问题或者分成多个步骤，每个子问题有多个解或者每个步骤有多个选择，最终求整体问题的一个最优解（最大值，最小值，方法总数，是否可行等等），这样的问题就适合用动态规划来求解。</p>

<p>动态规划一般可分为自顶而下式和自下而上式，自顶而下是通过递归，但因为涉及大量重复计算而导致时间复杂度过高，所以一般都是采用自下而上式，借助额外的空间来缓存子问题的解，减少重复计算从而降低时间复杂度，与<a href="https://baike.baidu.com/item/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/4275706">记忆化搜索</a>有点类似。</p>

<p><a href="http://toughcoder.net/blog/2022/09/08/introduction-to-dynamic-programming/"><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.1-yqbboBtUIUqcYV1V1p5gHaEK?pid=ImgDet&rs=1" title="auto auto" ></a></p>

<!-- more -->


<h2>动态规划的适用范围</h2>

<h3>最优子结构性质</h3>

<p><a href="https://blog.csdn.net/lanchunhui/article/details/52480106">最优子结构特性</a>（<a href="https://en.wikipedia.org/wiki/Optimal_substructure">Optimal Substructure</a>）是指一个问题可以分成多个子问题，每个问题的最优解凑成整个问题的最优解。</p>

<h3>重叠子问题性质</h3>

<p>重叠子问题(<a href="https://en.wikipedia.org/wiki/Overlapping_subproblems">Overlapping subproblems</a>)是指一个问题可以分成多个子问题，每个子问题的解会重复使用多次，也就说后一个子问题的解需要使用到前一个子问题的解。最为典型的就是Fibonacci数列，也就是常说的自上而下的方式来实现动态规划（递归式），因为子问题重复，所以为了提升效率必须把子问题的解存储下来以防止重复计算。</p>

<h2>寻找状态转移方程</h2>

<p>动态规划并不像排序或者二分查找那样有具体的形式，它更是一种策略而非具体的算法，发现一个题目可以用动态规划求解时，还远远不够，要想写出代码，必须推导出来状态转移方程，这才是动态规划的核心，而动态如何定义，又如何转移要视具体的问题而定变化万千，所以说动态规划是最难的一类题，没有之一。</p>

<p>一般而言状态转移方程要以结果为导向，也就是说用这个方程能得到问题的解，这依然是一句废话，要通过大量的练习才能掌握。</p>

<h2>动态规划的分类总结</h2>

<p>动态规划问题博大深精，甚至有人说万物皆可DP，意思是说几乎所有的题都可以用动态规划来求解。可以根据几个维度来对动态规划进行分类总结：一是看输入数据结构，是一维的数组列表，还是二维的矩阵或者树或者邻接表，当然还有双一维的输入。二是看时间复杂度是线性（即O(n)）的还是二次的（即O(n<sup>2</sup>)）。为什么要这样来分，因为这样分了之后就会有共性，能总结出一些经验。</p>

<p>还需要注意，动态规划总是要使用额外的空间来存储状态，一般来说空间复杂度与输入数据的维度是一致的，比如对于一维输入，一维的空间复杂度就够了（O(n)），即使有些会用到二维空间复杂度，但也可以优化到一维。</p>

<h2>一维一次</h2>

<p>也就是输入是一个一维数组，且用线性时间和线性空间就能解决的动态规划问题。这一般是入门级别的问题。</p>

<p>这种问题最为明显的特点是状态转移方程只跟前后相邻的元素有关系，或者最多是前前一个元素有关系，并且状态转移方程肯定只有一个参数。f(i) 通常能由f(i-1)或者f(i-2)推导而来。最最典型的例子就是爬楼梯和打家劫舍。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-subarray/solution/by-alexhilton-21zr/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/climbing-stairs/solution/by-alexhilton-7zms/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/JEj789/">剑指 Offer II 091. 粉刷房子</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/JEj789/solution/by-alexhilton-1g2g/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/decode-ways/">91. 解码方法</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/decode-ways/solution/by-alexhilton-17vp/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-product-subarray/">152. 乘积最大子数组</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-product-subarray/solution/by-alexhilton-mbgo/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/house-robber/solution/by-alexhilton-kmj8/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/house-robber-ii/">213. 打家劫舍 II</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/house-robber-ii/solution/by-alexhilton-6ph0/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/">309. 最佳买卖股票时机含冷冻期</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/by-alexhilton-3btu/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>一维二次</h2>

<p>输入是一维，但是时间复杂度会上升到O(n<sup>2</sup>)。原因在于当前的状态f(i)与其前面的所有状态都有可能有关系，通常f(i)是前面状态的一种极值，或者累加。状态转移方向一般为f(i) = max{f(j), 0&lt;=j&lt;i}。因为对于每一个状态，都要遍历一次其前面的所有状态，以寻找满足某种约束条件的结果，所以时间复度会上升到O(n<sup>2</sup>)。典型的问题是背包问题和子序列问题。</p>

<p>背包问题是典型的一维二次问题，关于背包问题，单独<a href="http://toughcoder.net/blog/2022/09/07/knapsack-problems-made-easy/">总结了一篇文章</a>。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/jump-game-ii/solution/by-alexhilton-fhbq/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/jump-game/solution/by-alexhilton-wjej/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-increasing-subsequence/solution/by-alexhilton-8ynf/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/integer-break/">343. 整数拆分</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/integer-break/solution/by-alexhilton-bpj3/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence/">673. 最长递增子序列的个数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence/solution/by-alexhilton-ezqr/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/">873. 最长的斐波那契子序列的长度</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/solution/by-alexhilton-ijsk/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>双一维二次</h2>

<p>输入是两个一维数组（或者序列或者字符串），因为输入是两个一维的，必然是要按个遍历一次，所以时间复杂度不可能小于二次（O(mn)），其中m和n是两个一维数组的和度。通常空间复杂度都有优化到一维。最为典型的例子就是两个字符串的最长公共子序列。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/edit-distance/solution/by-alexhilton-cjmy/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/delete-operation-for-two-strings/">583. 两个字符串的删除操作</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/delete-operation-for-two-strings/solution/583-liang-ge-zi-fu-chuan-de-shan-chu-cao-okcw/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-common-subsequence/solution/by-alexhilton-5n8f/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>二维二次</h2>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/unique-paths/solution/by-alexhilton-zdrr/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/minimum-path-sum/solution/by-alexhilton-40r3/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/triangle/">120. 三角形最小路径和</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/triangle/solution/120-san-jiao-xing-zui-xiao-lu-jing-he-by-cyah/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximal-square/">221. 最大正方形</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximal-square/solution/by-alexhilton-s7fg/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/house-robber-iii/solution/by-alexhilton-wpnk/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/champagne-tower/">799. 香槟塔</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/champagne-tower/solution/by-alexhilton-2a6j/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.programiz.com/dsa/dynamic-programming">Dynamic Programming</a></li>
<li><a href="https://towardsdatascience.com/understanding-dynamic-programming-75238de0db0d">Understanding Dynamic Programming</a></li>
<li><a href="https://www.geeksforgeeks.org/dynamic-programming/">Dynamic Programming</a></li>
<li><a href="https://www.freecodecamp.org/news/demystifying-dynamic-programming-3efafb8d4296/">Demystifying Dynamic Programming</a></li>
<li><a href="http://web.mit.edu/15.053/www/AMP-Chapter-11.pdf">Dynamic Programming</a></li>
<li><a href="https://www.javatpoint.com/dynamic-programming">Dynamic Programming</a></li>
<li><a href="https://oi-wiki.org/dp/">动态规划部分</a></li>
<li><a href="https://juejin.cn/post/6951922898638471181">看一遍就理解：动态规划详解</a></li>
<li><a href="https://houbb.github.io/2020/01/23/data-struct-learn-07-base-dp">五大基本算法之动态规划算法 DP dynamic programming</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/137992855">一文搞定动态规划问题（附DP所有问题链接）</a></li>
<li><a href="https://www.zhihu.com/question/23995189">什么是动态规划（Dynamic Programming）？动态规划的意义是什么？</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1692068">动态规划一篇就够了 全网第二详细, 逐步理解, 万字总结</a></li>
<li><a href="https://blog.csdn.net/u013309870/article/details/75193592">算法-动态规划 Dynamic Programming&ndash;从菜鸟到老鸟</a></li>
<li><a href="https://www.javatpoint.com/optimal-substructure-property">Optimal Substructure Property</a></li>
<li><a href="https://stackoverflow.com/questions/33563230/optimal-substructure-in-dynamic-programing">Optimal substructure in Dynamic Programing</a></li>
<li><a href="https://afteracademy.com/blog/optimal-substructure-and-overlapping-subproblems">Optimal Substructure and Overlapping Subproblems</a></li>
<li><a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84.md">动态规划答疑篇</a></li>
<li><a href="https://www.zhihu.com/question/52165201">动态规划的最优子结构问题，有什么样的问题它不满足最优子结构？</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1695752">深入浅出理解动态规划（二） | 最优子结构</a></li>
<li><a href="https://blog.nowcoder.net/n/7390417560b54107b421b13b47adea88">动态规划（最优子结构、重叠子问题）——附代码示例</a></li>
<li><a href="https://www.geeksforgeeks.org/overlapping-subproblems-property-in-dynamic-programming-dp-1/">Overlapping Subproblems Property in Dynamic Programming | DP-1</a></li>
<li><a href="https://www.geeksforgeeks.org/optimal-substructure-property-in-dynamic-programming-dp-2/?ref=lbp">Optimal Substructure Property in Dynamic Programming | DP-2</a></li>
<li><a href="https://stackoverflow.com/questions/64499367/what-are-overlapping-subproblems-in-dynamic-programming-dp">What are overlapping subproblems in Dynamic Programming (DP)?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[彻底搞懂背包问题]]></title>
    <link href="http://toughcoder.net/blog/2022/09/07/knapsack-problems-made-easy/"/>
    <updated>2022-09-07T21:43:23+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/07/knapsack-problems-made-easy</id>
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/2416931">背包问题</a>（<a href="https://en.wikipedia.org/wiki/Knapsack_problem">Knapsack Problem</a>）是指给定一个容量固定为W的背包和一组数量为n的物品，每个物品的重量为wi，价值为vi，要求从物品中选择若干放入背包，使总物品重量不超过背包容量，并且使价值最大。这是动态规划的一类非常典型的问题。</p>

<p><a href="http://toughcoder.net/blog/2022/09/07/knapsack-problems-made-easy/"><img src="https://ts1.cn.mm.bing.net/th/id/R-C.6b090586ea607208aa7489afa2100875?rik=0hp8cDJSsKDtBw&riu=http%3a%2f%2ftheoptimizationexpert.com%2fwp-content%2fuploads%2f2017%2f01%2f2000px-Knapsack.svg_.png&ehk=Z7IOVN53Bwm0zCcsj9U6VW1sRRzdApmWIymc%2bxo4TSU%3d&risl=&pid=ImgRaw&r=0" title="auto auto" ></a></p>

<!-- more -->


<p>背包问题如果每种物品数量只有一个，那么每个物品只有两种状态『放入背包』和『不放入背包』，这个一般称作0-1背包问题；如果每种物品的数量无限又称完全背包。</p>

<h2>物品可分割</h2>

<p>这类背包问题最简单，它是说有n种物品，每种物品的总重是wi，价值是vi，每种物品可分割为更小的部分，求不超过背包总容量W，使放入背包的价值最大。</p>

<p>因为物品可分割，那么要想装满背包价值最大，就优先选择单位容积价值最大的物品，可以计算每种物品的价值容积比，然后从大到小排序，优先往背包里面装价值容积比大的物品，直到背包装满为止。这其实是<strong>贪心算法</strong>。</p>

<p>这个问题是有实际例子，比如往一个盒子里面装糖果，不同糖果价格不同，想要让盒子最贵，就优先往里面塞最贵的糖果。</p>

<p>可以看<a href="http://toughcoder.net/blog/2022/09/07/introduction-to-greedy-algorithm/">贪心算法的文章</a>，里面有更详细的讨论。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-units-on-a-truck/">1710. 卡车上的最大单元数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-units-on-a-truck/solution/by-alexhilton-cuad/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br /></p>

<h2>0-1背包问题</h2>

<p>这是背包问题的基础，只有完全理解 了这类问题后，才能对其他背包问题有更好的理解。</p>

<p>0-1背包问题的特点是每种物品只有一个，对于每种物品的选择是放入背包，或者不放入。0-1背包问题与子集的问题一样的，从一堆物品中选择若干，其实就相当于对于一个集合选择子集，从<a href="http://toughcoder.net/blog/2022/09/04/backtracking-algorithm-explained/">回溯算法的一些实例中</a>，可以得到一个暴力解法，可以用二进制枚举的方法，找出所有的子集，然后计算每个子集的总价值，最后取最大值即可。从子集问题可知，这样做的时间复杂度可达到O(2<sup>n</sup>)，非常的高。可以用动态规划来降低到O(n<sup>2</sup>)。</p>

<p>背包问题要采用子问题的思路，对于物品数量为n，背包容量为W，来说一个子问题是i个物品和容量为j，其中0&lt;=i&lt;n，0&lt;=j&lt;=W。那么，背包问题的<strong>状态转移方程就是f(i,j) = max{f(i-1,j), f(i-1, j-weight[i])+value[i])}</strong>，意即当前物品i要么不放入背包，那总价值就是背包之前的状态f(i-1,j)，或者放入，但要想把物品i放进去，必须要保证有足够的空间装下它，所以是f(i-1,j-weight[i])再加上当前物品的价值value[i]，这两者取最大值就是，到当前物品i，容易为j时的最大价值。当尝试完所有的物品和所有的容量后，最后f(n,W)就是整个问题的解。</p>

<p>背包问题的时间复杂度是O(n<sup>2</sup>)，因为你要遍历所有的物品和所有的容积，基本没有优化空间了，因为有两个参数，所以空间复杂度也是O(n<sup>2</sup>)，因为要用矩阵来存储所有的状态，更进一步可以用一维数组来缓存状态，从而把空间复杂度降低到O(n)。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/partition-equal-subset-sum/solution/by-alexhilton-xxp8/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/target-sum/">494. 目标和</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/target-sum/solution/by-alexhilton-7pnd/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br /></p>

<h2>完全背包问题</h2>

<p>完全背包与0-1背包的区别就在于每种物品i的数量是无限的，你想选多少就选多少。那么在选择的时候可以假设选择物品i的数量为k，显然k=1时就是0-1背包问题。
可以基于0-1背包进行拓展，来解决完全背包。依旧是取状态转移方向为f(i,j)为选择到物品i，容积为j时的背包最大价值，当到物品i时，可选0个，也可以选1个，也可以选k个，所以<strong>状态转移方程是f(i,j) = max{f(i-1, j-k*weight[i]) + k * values[i]}</strong>，其中i的取值是所有的物品0&lt;=i&lt;n，j是所有的容积0&lt;=j&lt;=W，而k是物品i的可选数量0&lt;=k&lt;j/weight[i]，也就是说当前物品最多能选择的数量就是当前容积的限制j/weight[i]。
时间复杂度会上升到O(n<sup>3</sup>)，空间复杂度可以从O(n<sup>2</sup>)优化到O(n)。</p>

<p>还可以换个思路，定义f(i)为背包容量为i时所能取得的最大价值，那么f(W)是问题的解。每种物品的数量是无限的，但也有范围，每种物品的最大数量显然是背包的最大容量，也就是说每种物品的数量上限是c[i] = W/w[i]。如何能得到f(i)呢？可以把每种物品都往里面放一个去尝试，比如把第j个物品放进背包，那么这时f(i) = f(i-w[j]) + v[j]，因为不知道要放哪一个，所以应该把所有的物品都尝试一遍，然后取最大值，也即是<strong>f(i) = max{f(i-w[j]) + v[j], when i-w[j]>=0}</strong>，这里j的取值范围是所有物品数量i-w[j]>=0是要保证背包还装得下，如果某个物品太大了装不下，超过了背包的容量限制，那也不能选择它。为了找到最后的解背包容量i要从0到W。这样时间复杂度就降低到O(n<sup>2</sup>)了。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/perfect-squares/solution/by-alexhilton-rkb7/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/coin-change/solution/322-ling-qian-dui-huan-by-alexhilton-pqum/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br /></p>

<h2>参考资料</h2>

<ul>
<li><a href="http://masc.cs.gmu.edu/wiki/KnapsackProblems">Knapsack Problems</a></li>
<li><a href="https://www.geeksforgeeks.org/0-1-knapsack-problem-dp-10/">0-1 Knapsack Problem | DP-10</a></li>
<li><a href="https://medium.com/@fabianterh/how-to-solve-the-knapsack-problem-with-dynamic-programming-eb88c706d3cf">How to solve the Knapsack Problem with dynamic programming</a></li>
<li><a href="https://www.interviewbit.com/blog/0-1-knapsack-problem/">0-1 Knapsack Problem</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/345364527">咱就把0-1背包问题讲个通透！</a></li>
<li><a href="https://blog.csdn.net/liangbopirates/article/details/9750463">背包问题详解</a></li>
<li><a href="https://blog.csdn.net/Iseno_V/article/details/100001133">01背包问题详解（浅显易懂）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/93857890">动态规划之背包问题系列</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/349054931">背包问题算法总结</a></li>
<li><a href="https://blog.csdn.net/na_beginning/article/details/62884939">背包问题详解：01背包、完全背包、多重背包</a></li>
<li><a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/%E8%83%8C%E5%8C%85%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%8001%E8%83%8C%E5%8C%85-1.md">动态规划：关于01背包问题，你该了解这些！</a></li>
<li><a href="https://seramasumi.github.io/docs/Algorithms/mc-%E5%BE%AE%E8%AF%BE%E5%A0%82-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.html">第一章 背包问题介绍</a></li>
<li><a href="https://oi-wiki.org/dp/knapsack/">背包 DP</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[贪心算法简介]]></title>
    <link href="http://toughcoder.net/blog/2022/09/07/introduction-to-greedy-algorithm/"/>
    <updated>2022-09-07T20:55:12+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/07/introduction-to-greedy-algorithm</id>
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/5411800">贪心算法</a>(<a href="https://en.wikipedia.org/wiki/Greedy_algorithm">Greedy Algorithm</a>)，又可称作贪婪算法，简称贪心，它是一指一种决策策略，依据统一的规则，在局部选择最优解，继而成为全局最优解。最经典的问题就是一类最短路径问题，从当前节点选择离它最近的节点，然后继续，到达目标节点后这一路径就是全局最短路径（这是<a href="http://toughcoder.net/blog/2022/09/12/understanding-dijkstra-algorithm/">Dijkstra算法</a>）；再如可分割的背包问题，物品有不同的重量和价值，但物品可分割，这也是贪心算法的经典应用案例。</p>

<p><a href="http://toughcoder.net/blog/2022/09/07/introduction-to-greedy-algorithm/"><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.avKovBqhy1bYjf6o2e81RgHaFj?pid=ImgDet&rs=1" title="auto auto" ></a></p>

<!-- more -->


<h2>贪心算法的适用范围</h2>

<p>贪心算法最重要的特点是子问题的局部最优解即是最后的全局最优解，每一个子问题相互独立，不相互影响，这样的问题贪心能得到最优解，但通常这类问题较少，经典的就是会议室调度问题。</p>

<p>更多的时候，贪心是一近似算法（<a href="https://en.wikipedia.org/wiki/Approximation_algorithm">Approximation aglorithm</a>），比如对于NP问题，贪心算法能得到一个近似解，虽然不是最优，但比较按近最优。比如像集合覆盖，地图着色，旅行商地图问题等，都是可以用贪心来求得一个近似解。</p>

<p>贪心算法就是，把问题分成多个子问题，设定一个贪心策略，针对每个子问题应用贪心策略，继而得到整个问题的解。比如会议室调度问题，每次都选择前一个会议结束后，最早开始最早结束；再如Dijkstra算法，每次从当前顶点出发，在其相邻的顶点中刷新较小的距离，并选择距离最短的顶点作为下一个当前顶点。</p>

<h2>贪心与动态规划的区别</h2>

<p>贪心和动态规划都是求解最优子结构问题，但贪心不考虑全局，只关注局部最优，而动态规划则要考虑整体最优解，局部可能选择最优也可能不选择。动态规划的应用范围更广，能用贪心解决的问题用动态规划一定可以，而能用动态规划解的，贪心不一定可以，应该说贪心是动态规划的一个子方法。</p>

<p>就比如0-1背包问题，如果物品不可分割，那么贪心是得不到解的，只考虑局部最优（每次选择最大能填满剩余空间的物品）是不可能得到全局最优解的，只能用动态规划来解。但假如物品是可以分割的，那么贪心就可解，并且是一个效率较高的解法。</p>

<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/solution/by-alexhilton-pv84/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-units-on-a-truck/">1710. 卡车上的最大单元数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-units-on-a-truck/solution/by-alexhilton-cuad/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://brilliant.org/wiki/greedy-algorithm/">Greedy Algorithms</a></li>
<li><a href="https://www.freecodecamp.org/news/what-is-a-greedy-algorithm/">Greedy Algorithms Explained with Examples</a></li>
<li><a href="https://www.programiz.com/dsa/greedy-algorithm">Greedy Algorithm</a></li>
<li><a href="https://www.guru99.com/greedy-algorithm.html">Greedy Algorithm with Example: What is, Method and Approach</a></li>
<li><a href="https://www.simplilearn.com/tutorials/data-structure-tutorial/greedy-algorithm">What is Greedy Algorithm: Example, Applications, Limitations and More</a></li>
<li><a href="https://www.hackerearth.com/practice/algorithms/greedy/basics-of-greedy-algorithms/tutorial/">Basics of Greedy Algorithms</a></li>
<li><a href="https://blog.csdn.net/effective_coder/article/details/8736718">贪心算法详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/53334049">小白带你学&mdash;贪心算法（Greedy Algorithm)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/180104885">贪心算法详解（附例题）</a></li>
<li><a href="https://houbb.github.io/2020/01/23/data-struct-learn-07-base-greedy">五大基本算法之贪心算法 Greedy</a></li>
<li><a href="https://blog.csdn.net/weixin_39799825/article/details/111391311">贪心策略取得最优解的条件_常用算法之贪心算法</a></li>
<li><a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/31/2616926.html">贪心算法</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树状树组简介]]></title>
    <link href="http://toughcoder.net/blog/2022/09/06/intro-to-binary-indexed-tree/"/>
    <updated>2022-09-06T21:22:36+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/06/intro-to-binary-indexed-tree</id>
    <content type="html"><![CDATA[<p><a href="https://zh.m.wikipedia.org/zh-hans/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84">树状数组</a>，即<a href="https://en.wikipedia.org/wiki/Fenwick_tree">Binary Indexed Tree</a>，简单来理解就是用数组来表示一颗树，它的实际存储结构是数组，但元素之间的逻辑关系是树。通常用于解决区间问题和快速计算前缀和的问题。</p>

<p><a href="http://toughcoder.net/blog/2022/09/06/intro-to-binary-indexed-tree/"><img src="https://www.cdn.geeksforgeeks.org/wp-content/uploads/BITSum.png" title="auto auto" ></a></p>

<!-- more -->


<h2>区间查询和区间修改</h2>

<p>在介绍树状数组之前，先来看一个问题，给定数组nums，长度为n，如何快速实现如下四种操作：</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 操作 </th>
<th style="text-align:left;"> 参数 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 单点查询 </td>
<td style="text-align:left;"> i </td>
<td style="text-align:left;"> 查询索引为i的元素值 </td>
</tr>
<tr>
<td style="text-align:left;"> 区间查询 </td>
<td style="text-align:left;"> l, r </td>
<td style="text-align:left;"> 查询区间[l, r]内元素之和 </td>
</tr>
<tr>
<td style="text-align:left;"> 单点修改 </td>
<td style="text-align:left;"> i </td>
<td style="text-align:left;"> 修改索引 为i的元素值 </td>
</tr>
<tr>
<td style="text-align:left;"> 区间修改 </td>
<td style="text-align:left;"> l, r </td>
<td style="text-align:left;"> 修改区间[l, r]内的元素值，比如都加上一个数x </td>
</tr>
</tbody>
</table>


<p>首先，肯定 可以想到朴素做法，简单的优化就是用<a href="http://toughcoder.net/blog/2022/09/25/intro-to-diff-array/">前缀和（参考此文）</a>，可以做如下对比：</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 操作 </th>
<th style="text-align:left;"> 方法 </th>
<th style="text-align:left;"> 时间复杂度 </th>
<th style="text-align:left;"> 方法 </th>
<th style="text-align:left;"> 时间复杂度 </th>
<th style="text-align:left;"> 方法 </th>
<th style="text-align:left;"> 时间复杂度 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 单点查询 </td>
<td style="text-align:left;"> 朴素做法 </td>
<td style="text-align:left;"> O(1) </td>
<td style="text-align:left;"> 前缀和 </td>
<td style="text-align:left;"> O(1) </td>
<td style="text-align:left;"> 差分数组 </td>
<td style="text-align:left;"> O(n) </td>
</tr>
<tr>
<td style="text-align:left;"> 区间查询 </td>
<td style="text-align:left;"> 朴素做法 </td>
<td style="text-align:left;"> O(n) </td>
<td style="text-align:left;"> 前缀和 </td>
<td style="text-align:left;"> O(1) </td>
<td style="text-align:left;"> 差分数组 </td>
<td style="text-align:left;"> O(n) </td>
</tr>
<tr>
<td style="text-align:left;"> 单点修改 </td>
<td style="text-align:left;"> 朴素做法 </td>
<td style="text-align:left;"> O(1) </td>
<td style="text-align:left;"> 前缀和 </td>
<td style="text-align:left;"> O(n) </td>
<td style="text-align:left;"> 差分数组 </td>
<td style="text-align:left;"> O(1) </td>
</tr>
<tr>
<td style="text-align:left;"> 区间修改 </td>
<td style="text-align:left;"> 朴素做法 </td>
<td style="text-align:left;"> O(n) </td>
<td style="text-align:left;"> 前缀和 </td>
<td style="text-align:left;"> O(n) </td>
<td style="text-align:left;"> 差分数组 </td>
<td style="text-align:left;"> O(1) </td>
</tr>
</tbody>
</table>


<p>可以看到基本的方法必然会有一种操作会达到O(n)复杂度。而用树状数组就可以区间相关的操作（区间查询和区间修改）都降到O(log<sup>n</sup>)。</p>

<p><strong>注意</strong>：单点操作，可以视为区间操作的特例，比如区间查询i，可以视为区间查询[i, i]。</p>

<h2>树状数组的思想</h2>

<p>树状数组就是把原数组分成多个区间，用一个辅助数组来存储这些划分出来的区间的区间和。普通前缀和，对于区间查询 和单点查询 来说肯定 可以O(1)来完成，但对于单点修改，比如要修改nums[i]的值，这会影响到包含nums[i]的所有的区间和，因此会是O(n)的复杂度。树状数组因为预先划分了一些区间，能能够保证受nums[i]影响的区间只有O(log<sup>n</sup>)个，因此单点修改对于树状数组的复杂度只会是O(log<sup>n</sup>)。</p>

<p>树状数组是一个辅助数组tree[]，长度是原数组长度n+1，区间划分的原则是从[1,n]中的每一个下标i，存储的是一个区间和，这个区间是(i-lowbit(i),i]，注意区间是左开右闭。这个lowbit是一个函数取的是索引i的最左一个1所代表的数字，比如索引4，其lowbit(4) = (0b100)2=4，所以tree[4]存储的是(0,4]这个区间的区间和；而5，lowbit(5)=(0b101)2=1，所以tree[5]只存它自己。</p>

<p>这样划分区间后，对于单点修改，只需要把包含影响的元素的区间更新一遍就可以了。比如修改元素i，那么只需要把[i, i+lowbit(i)]的元素更新一下就可以了。</p>

<p>对于区间查询，区间查询用前缀和可以做到O(1)，因此问题的关键在于利用划分的区间和区间和来找到前缀和。区间划分大小为lowbit(i)，tree[i]存储的是(i-lowbit(i), i]的和，那么，如果令j=i-lowbit(i)，那么tree[j]就是(j-lowbit(j)，j]的和，这样一直到索引0，就找到了到i的前缀和了。由此可以看出用下标索引lowbit来划分区间可以非常巧妙的分治单点修改和区间查询的问题，使得复杂度都降为O(log<sup>n</sup>)。</p>

<h3>lowbit</h3>

<p>区间划分最为精妙 的就是这个lowbit，它是能保证tree中所有的查询和修改都能在O(log<sup>n</sup>)时间内完成。它的作用是取索引二进制形式的最后一个1所代表的数字。它的实现并不复杂，用一点位运算的技巧就可以了，位运算技巧可以<a href="http://toughcoder.net/blog/2022/08/23/most-used-tricks/">参考文章</a>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">lowbit</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">i</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>细心的你肯定可以发现，对于奇数索引lowbit肯定是1，所以tree中奇数索引存储的都是原数组的元素，只有偶数索引存储的才是区间之和。</p>

<h2>基础树状数组的实现</h2>

<p>基于前面的原理，可以实现基础版本的树状数组，基础版本的意思是，对于<strong>单点修改和区间查询</strong>两个操作可以实现O(log<sup>n</sup>)复杂度的支持。</p>

<p>实现细节需要注意，树状数组是一个辅助数组tree，它的长度是原数组长度加1，索引为0的是不使用的，仅[1, n]是有效数据。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * The Binary Indexed Tree.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BIT</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// The original array, which is not really necessary.</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// the size of the Binary Indexed array, size = n + 1, n is the length of original array.</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// The Binary Indexed Array, valid data are in [1, size), where size = n + 1</span>
</span><span class='line'>    <span class="c1">// Original array element [i] is mapped to [i + 1] in the tree.</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">tree</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">BIT</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">nums</span> <span class="o">=</span> <span class="n">nums</span><span class="o">;</span>
</span><span class='line'>        <span class="n">size</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">add</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">lowbit</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">i</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Update array element [i] to val</span>
</span><span class='line'>    <span class="c1">// Meaning set nums[i] to val, but it is easier to maintain tree with delta</span>
</span><span class='line'>    <span class="c1">// nums[i] = val, is the same to nums[i] = nums[i] + (val - nums[i]), where val - nums[i]</span>
</span><span class='line'>    <span class="c1">// is the delta.</span>
</span><span class='line'>    <span class="c1">// So we add affected items in tree with the delta.</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">add</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">val</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
</span><span class='line'>        <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">val</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">lowbit</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">tree</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="n">x</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Query the regional sum in [l, r]</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">query</span><span class="o">(</span><span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nf">preSum</span><span class="o">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="n">preSum</span><span class="o">(</span><span class="n">l</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Get the preSum up to i inclusive.</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">preSum</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">-=</span> <span class="n">lowbit</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">sum</span> <span class="o">+=</span> <span class="n">tree</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">};</span>
</span><span class='line'>        <span class="n">BIT</span> <span class="n">bit</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">BIT</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;3 = &quot;</span> <span class="o">+</span> <span class="n">bit</span><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;18 = &quot;</span> <span class="o">+</span> <span class="n">bit</span><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">bit</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;3 = &quot;</span> <span class="o">+</span> <span class="n">bit</span><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;19 = &quot;</span> <span class="o">+</span> <span class="n">bit</span><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="https://github.com/alexhilton/EffectiveAlgorithm/blob/main/datastructure/src/main/java/BIT.java">完整代码看这里</a>。</p>

<h2>中级树状数组</h2>

<p>基础版本只能支持单点修改，区间查询。但如果想要区间修改，单点查询的话使用基础版本就会达到O(nlog<sup>n</sup>)的复杂度，因为每次单点修改会是O(log<sup>n</sup>)的，那么区间修改就会达到O(nlog<sup>n</sup>)。</p>

<p>在<a href="http://toughcoder.net/blog/2022/09/25/intro-to-diff-array/">前缀和与差分数组简介</a>这个文章中介绍过差分数组就是前缀和的逆运算，差分数组支持常数级的区间修改，而对差分数组求前缀和就能得到原数组。基于这个，我们可以把树状数组中的输入数组换成原数组的差分，这样tree就变成了差分的区间和，进尔前缀和就变成了原数组，由此便可以实现对数级别的区间修改和单点查询。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * The Binary Indexed Tree</span>
</span><span class='line'><span class="cm"> * Support point query (PQ) and range update (RU) in O(log^n) complexity.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">PQRUBIT</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">tree</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">PQRUBIT</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
</span><span class='line'>        <span class="n">size</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>        <span class="kt">int</span><span class="o">[]</span> <span class="n">diff</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
</span><span class='line'>        <span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">diff</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">diff</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">add</span><span class="o">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">diff</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">lowbit</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">tree</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="n">x</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">lowbit</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">i</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">query</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">-=</span> <span class="n">lowbit</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">res</span> <span class="o">+=</span> <span class="n">tree</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">add</span><span class="o">(</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
</span><span class='line'>        <span class="n">add</span><span class="o">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="n">x</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">};</span>
</span><span class='line'>        <span class="n">PQRUBIT</span> <span class="n">bit</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">PQRUBIT</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;1 = &quot;</span> <span class="o">+</span> <span class="n">bit</span><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;5 = &quot;</span> <span class="o">+</span> <span class="n">bit</span><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="mi">4</span><span class="o">));</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">bit</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;1 = &quot;</span> <span class="o">+</span> <span class="n">bit</span><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="mi">0</span><span class="o">));</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;6 = &quot;</span> <span class="o">+</span> <span class="n">bit</span><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;8 = &quot;</span> <span class="o">+</span> <span class="n">bit</span><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="mi">4</span><span class="o">));</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;9 = &quot;</span> <span class="o">+</span> <span class="n">bit</span><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="mi">5</span><span class="o">));</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;7 = &quot;</span> <span class="o">+</span> <span class="n">bit</span><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="mi">6</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="https://github.com/alexhilton/EffectiveAlgorithm/blob/main/datastructure/src/main/java/PQRUBIT.java">完整代码看这里</a>。</p>

<p>需要特别<strong>注意数据对齐</strong>，输入数组和差分数组diff都是从0到n-1的，而区间和数组，也即树状数组是从1到n的。但开放出来的接口肯定 也都是从0到n-1的，需要注意当使用nums和diff时，如果是对tree的操作需要对索引做加1。比如BIT中的query在调用preSum时已把索引加1；和PQRUBIT中的query要从j = i + 1开始。</p>

<h2>高级树状数组</h2>

<p>最高级的树状数组就是支持O(log<sup>n</sup>)级别的区改区查，要结合前面两种。这个较为复杂一些，需要做一些推导。</p>

<p>先来看差分数组，详细的<a href="http://toughcoder.net/blog/2022/09/25/intro-to-diff-array/">可以看文章</a>。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">diff</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
</span><span class='line'><span class="n">diff</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
</span><span class='line'><span class="n">diff</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
</span><span class='line'><span class="n">diff</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">diff</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">diff</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>原数组是差分数组的前缀和：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">diff</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
</span><span class='line'><span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">diff</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">diff</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
</span><span class='line'><span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">sum</span><span class="o">(</span><span class="n">diff</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>而原数组的前缀和：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">preSum</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">nums</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="o">...</span> <span class="n">nums</span><span class="o">[</span><span class="n">k</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>把差分数组与原数组的关系代入原数组的前缀和，可得：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">preSum</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="n">diff</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="o">(</span><span class="n">diff</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">diff</span><span class="o">[</span><span class="mi">1</span><span class="o">])</span> <span class="o">+</span> <span class="o">...</span> <span class="o">(</span><span class="n">diff</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">diff</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="o">...</span> <span class="n">diff</span><span class="o">[</span><span class="n">k</span><span class="o">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>把括号展开，合并同类项，可得：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">preSum</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="n">diff</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="o">((</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="n">diff</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="o">...</span> <span class="o">((</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="o">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">))</span> <span class="o">*</span> <span class="n">diff</span><span class="o">[</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="o">((</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="n">k</span><span class="o">)</span> <span class="o">*</span> <span class="n">diff</span><span class="o">[</span><span class="n">k</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>再把，括号展开，以k为中心合并，可得：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">preSum</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="o">(</span><span class="n">diff</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">diff</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="o">...</span> <span class="n">diff</span><span class="o">[</span><span class="n">k</span><span class="o">])</span> <span class="o">-</span> <span class="o">(</span><span class="n">diff</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">diff</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="n">diff</span><span class="o">[</span><span class="n">k</span><span class="o">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>从PQRUBIT中可知，对于以差分数组为基础的BIT，其query(k) = nums[k] = sum(diff, 0, k)，代入上式，可得：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">preSum</span><span class="o">[</span><span class="n">k</span><span class="o">]</span> <span class="o">=</span> <span class="o">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="n">query</span><span class="o">(</span><span class="n">k</span><span class="o">)</span> <span class="o">-</span> <span class="o">(</span><span class="mi">0</span> <span class="o">*</span> <span class="n">diff</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">diff</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">diff</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="n">diff</span><span class="o">[</span><span class="n">k</span><span class="o">])</span>
</span></code></pre></td></tr></table></div></figure>


<p>至于，后面这一坨，因为它也直接与差分数组diff产生关系，所以可以引入另外一个辅助数组用以存储，进而就可以求出原数组的区间和，也就解决区间查询的问题。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="cm">/**</span>
</span><span class='line'><span class="cm"> * The Binary Indexed Tree</span>
</span><span class='line'><span class="cm"> * Support range query (RQ) and range update (RU) in O(log^n) complexity.</span>
</span><span class='line'><span class="cm"> */</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RQRUBIT</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">tree</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">conTree</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">RQRUBIT</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">nums</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">final</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
</span><span class='line'>        <span class="n">size</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">int</span><span class="o">[]</span> <span class="n">diff</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span><span class="o">];</span>
</span><span class='line'>        <span class="n">diff</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">diff</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">-</span> <span class="n">nums</span><span class="o">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="o">];</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">add</span><span class="o">(</span><span class="n">tree</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">diff</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">conTree</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">size</span><span class="o">];</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">add</span><span class="o">(</span><span class="n">conTree</span><span class="o">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">i</span> <span class="o">*</span> <span class="n">diff</span><span class="o">[</span><span class="n">i</span><span class="o">]);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">rangeQuery</span><span class="o">(</span><span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">preSumL</span> <span class="o">=</span> <span class="n">l</span> <span class="o">*</span> <span class="n">query</span><span class="o">(</span><span class="n">tree</span><span class="o">,</span> <span class="n">l</span><span class="o">)</span> <span class="o">-</span> <span class="n">query</span><span class="o">(</span><span class="n">conTree</span><span class="o">,</span> <span class="n">l</span><span class="o">);</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">preSumR</span> <span class="o">=</span> <span class="o">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="n">query</span><span class="o">(</span><span class="n">tree</span><span class="o">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">-</span> <span class="n">query</span><span class="o">(</span><span class="n">conTree</span><span class="o">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">preSumR</span> <span class="o">-</span> <span class="n">preSumL</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">rangeUpdate</span><span class="o">(</span><span class="kt">int</span> <span class="n">l</span><span class="o">,</span> <span class="kt">int</span> <span class="n">r</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">add</span><span class="o">(</span><span class="n">tree</span><span class="o">,</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">x</span><span class="o">);</span>
</span><span class='line'>        <span class="n">add</span><span class="o">(</span><span class="n">tree</span><span class="o">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">2</span><span class="o">,</span> <span class="o">-</span><span class="n">x</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">add</span><span class="o">(</span><span class="n">conTree</span><span class="o">,</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">l</span> <span class="o">*</span> <span class="n">x</span><span class="o">);</span>
</span><span class='line'>        <span class="n">add</span><span class="o">(</span><span class="n">conTree</span><span class="o">,</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">2</span><span class="o">,</span> <span class="o">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="o">-</span><span class="n">x</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">t</span><span class="o">,</span> <span class="kt">int</span> <span class="n">i</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">lowbit</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">t</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">+=</span> <span class="n">x</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">query</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">t</span><span class="o">,</span> <span class="kt">int</span> <span class="n">k</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">res</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">k</span><span class="o">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">-=</span> <span class="n">lowbit</span><span class="o">(</span><span class="n">j</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">res</span> <span class="o">+=</span> <span class="n">t</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">res</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">lowbit</span><span class="o">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">i</span> <span class="o">&amp;</span> <span class="o">-</span><span class="n">i</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span><span class="o">[]</span> <span class="n">a</span> <span class="o">=</span> <span class="o">{</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">7</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">9</span><span class="o">};</span>
</span><span class='line'>        <span class="n">RQRUBIT</span> <span class="n">bit</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">RQRUBIT</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;3 = &quot;</span> <span class="o">+</span> <span class="n">bit</span><span class="o">.</span><span class="na">rangeQuery</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;18 = &quot;</span> <span class="o">+</span> <span class="n">bit</span><span class="o">.</span><span class="na">rangeQuery</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">bit</span><span class="o">.</span><span class="na">rangeUpdate</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="mi">6</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;3 = &quot;</span> <span class="o">+</span> <span class="n">bit</span><span class="o">.</span><span class="na">rangeQuery</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">1</span><span class="o">));</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;27 = &quot;</span> <span class="o">+</span> <span class="n">bit</span><span class="o">.</span><span class="na">rangeQuery</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;10 = &quot;</span> <span class="o">+</span> <span class="n">bit</span><span class="o">.</span><span class="na">rangeQuery</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><a href="https://github.com/alexhilton/EffectiveAlgorithm/blob/main/datastructure/src/main/java/RQRUBIT.java">完整代码看这里</a>。</p>

<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/range-sum-query-mutable/">307. 区域和检索 - 数组可修改</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/range-sum-query-mutable/solution/307-qu-yu-he-jian-suo-shu-zu-ke-xiu-gai-g83yd/">题解</a> </td>
<td style="text-align:left;"> 单点修改，区间查询，标准的BIT </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://halfrost.com/binary_indexed_tree/">聊聊树状数组 Binary Indexed Tree</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/99167607">算法和数据结构 | 树状数组（Binary Indexed Tree）</a></li>
<li><a href="https://www.topcoder.com/thrive/articles/Binary%20Indexed%20Trees">BINARY INDEXED TREES</a></li>
<li><a href="https://blog.csdn.net/Yaokai_AssultMaster/article/details/79492190">树状数组（Binary Indexed Tree），看这一篇就够了</a></li>
<li><a href="https://blog.csdn.net/bestsort/article/details/80796531">树状数组 数据结构详解与模板(可能是最详细的了)</a></li>
<li><a href="https://www.cnblogs.com/Last--Whisper/p/13823614.html">树状数组（BIT）—— 一篇就够了</a></li>
<li><a href="https://blog.csdn.net/flushhip/article/details/79165701">树状数组简单易懂的详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/93795692">算法学习笔记(2) : 树状数组</a></li>
<li><a href="https://www.cnblogs.com/xenny/p/9739600.html">树状数组详解</a></li>
<li><a href="https://oi-wiki.org/ds/fenwick/">树状数组</a></li>
<li><a href="https://leetcode.cn/circle/discuss/qGREiN/">树状数组从入门到下车</a></li>
<li><a href="https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/">Binary Indexed Tree or Fenwick Tree</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to Trie]]></title>
    <link href="http://toughcoder.net/blog/2022/09/06/introduction-to-trie/"/>
    <updated>2022-09-06T11:41:14+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/06/introduction-to-trie</id>
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209">字典树</a>，<a href="https://en.wikipedia.org/wiki/Trie">Trie</a>（发音与try一样），也叫前缀树，是在一个树状数据结构中存储一个字典中的所有单词，以快速的实现前缀搜索和单词搜索的数据结构。前缀树是一个多叉树，每个节点会有多个子节点，具体子节点 数量取决于字符集的大小，除了根节点以外，每个节点代表字典中的一个字符，从根节点开始的路径代表着一个前缀或者一个单词。</p>

<p><a href="http://toughcoder.net/blog/2022/09/06/introduction-to-trie/"><img src="https://pic2.zhimg.com/v2-cb9b476f3856b7ae68a00af6911c07a9_b.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>Trie通常用于解决单词搜索和前缀匹配一类的问题，特点是输入的字符集合有限（通常是仅有小写字母），给一组字符串作为输入字典（这就是字典），然后涉及前缀或者单词搜索，符合这几个条件的问题就可以考虑使用Trie来解决。</p>

<h2><a href="https://en.wikipedia.org/wiki/Trie">Trie</a>的标准实现</h2>

<p>标准的Trie是一个树形结构，其节点是TrieNode，有一个构建字典方法通常是插入一个字符串，以及查询方法search通常是一个完整单词，还有一个前缀查询方法startsWith。</p>

<p>节点的实现，对于大多数情况下依据字符集而定，通常情况下都是只有小写英文字符，所以用一个长度为26的数组即可，因为是树状，要能找到子节点，所以这个数组的类型仍是TrieNode，下标可以作为当前节点的字符。同时可以添加额外的字段 用以标记，到当前节点是否是一个完整单词。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">Trie</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">TrieNode</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">TrieNode</span><span class="o">[]</span> <span class="n">children</span><span class="o">;</span>
</span><span class='line'>        <span class="kt">boolean</span> <span class="n">isWord</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">TrieNode</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">children</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TrieNode</span><span class="o">[</span><span class="mi">26</span><span class="o">];</span>
</span><span class='line'>            <span class="n">isWord</span> <span class="o">=</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="n">TrieNode</span> <span class="n">root</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">Trie</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">TrieNode</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">word</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">TrieNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">ch</span> <span class="o">:</span> <span class="n">word</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">ch</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="o">;</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">TrieNode</span><span class="o">();</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">];</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">node</span><span class="o">.</span><span class="na">isWord</span> <span class="o">=</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">search</span><span class="o">(</span><span class="n">String</span> <span class="n">word</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">word</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">word</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">TrieNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">ch</span> <span class="o">:</span> <span class="n">word</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">ch</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="o">;</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">];</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="na">isWord</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">startsWith</span><span class="o">(</span><span class="n">String</span> <span class="n">prefix</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">prefix</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">prefix</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">TrieNode</span> <span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">ch</span> <span class="o">:</span> <span class="n">prefix</span><span class="o">.</span><span class="na">toCharArray</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">ch</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="o">;</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">]</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="na">children</span><span class="o">[</span><span class="n">idx</span><span class="o">];</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDE3MDk3OC1iZDdmYzQyZDFhODdmMTkxLnBuZw?x-oss-process=image/format,png" alt="" /></p>

<h2>解题技巧</h2>

<p>对于标准实现中，每个节点只有一个额外的字段用以标记到此节点时的路径是否是一个单词。</p>

<p>其实这里也可以加入更多的字段，比如输入字符串携带的其他信息，这样当搜索时遇到匹配，就可以直接提取出这些额外的信息，较复杂的问题必然有单词匹配或者前缀匹配以外的信息需要融合，这时节点就需要多定义一些字段。最为典型的就是题745。</p>

<h2>典型问题</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/implement-trie-prefix-tree/solution/by-alexhilton-8p2z/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/replace-words/">648. 单词替换</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/replace-words/solution/by-alexhilton-dr8k/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-common-prefix/">14. 最长公共前缀</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-common-prefix/solution/by-alexhilton-ajgh/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/implement-magic-dictionary/">676. 实现一个魔法字典</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/implement-magic-dictionary/solution/by-alexhilton-f3jt/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/prefix-and-suffix-search/">745. 前缀和后缀搜索</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/prefix-and-suffix-search/solution/by-alexhilton-qbjy/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://simpledevcode.wordpress.com/2018/12/04/trie-data-structure-from-scratch/">Trie data structure from scratch</a></li>
<li><a href="https://www.toptal.com/java/the-trie-a-neglected-data-structure">The Trie Data Structure: A Neglected Gem</a></li>
<li><a href="https://oi-wiki.org/string/trie/">字典树 (Trie)</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/trie-data-structure-in-c-plus-plus">Trie Data Structure in C/C++</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/28891541">数据结构与算法：字典树（前缀树）</a></li>
<li><a href="https://segmentfault.com/a/1190000040801084">一文搞懂字典树</a></li>
<li><a href="https://pdai.tech/md/algorithm/alg-basic-tree-trie.html">树 - 前缀树(Trie Tree)</a></li>
<li><a href="https://blog.csdn.net/yuzhiqiang666/article/details/80711441">数据结构与算法（十一）Trie字典树</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[回溯算法从入门到精通]]></title>
    <link href="http://toughcoder.net/blog/2022/09/04/backtracking-algorithm-explained/"/>
    <updated>2022-09-04T08:16:04+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/04/backtracking-algorithm-explained</id>
    <content type="html"><![CDATA[<p>回溯(<a href="https://en.wikipedia.org/wiki/Backtracking">Backtracking</a>)是指在求解的过程中，不断的试探每一步的所有可能的解，如果发现不符合要求，就回退到最初的状态，尝试另外一种可能，直到所有的可能的解都找到。它与DFS的思想是一致的。</p>

<p><a href="http://toughcoder.net/blog/2022/09/04/backtracking-algorithm-explained/"><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.WZQpfmaWBboOu2d1G3ar0gHaE8?pid=ImgDet&rs=1" title="auto auto" ></a></p>

<!-- more -->


<p>回溯通常用来解决的问题是，问题会分成很多步骤，每一步面临多个选择，有多种可能性，需要一个一个的尝试，最终需要找到所有的可能的解。回溯通常用递归来实现，并且它的时间复杂度一般都比较高。它基本上就是穷举和暴力搜索一样，但通过各种奇技淫巧可以做剪枝以降低复杂度。</p>

<p><img src="https://image2.slideserve.com/4888360/backtracking1-l.jpg" alt="" /></p>

<p>最为经典的回溯算法问题就是迷宫问题，比如从一个格子a，出发，有二个方向，还不知道哪个是对的，那就分别向前走，一直走，直到撞墙了，或者到了死路了，才知道这个方向是错的；然后回退到a，按个方向继续走，这就是经典的回溯。</p>

<p><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.5sU8HuB5SNkBeZqVTYShqQHaFj?pid=ImgDet&amp;rs=1" alt="" /></p>

<h2>回溯的模板套路</h2>

<p>运用回溯算法需要厘清四个条件：1）把问题每成多个步骤，一步一步的走完，就得到了一个解；2）每个步骤又分成多个备选选择，有些是符合要求的，有些则是不符合要求的；3）什么条件算是得到了解，或者说什么情况下算是把问题解决了，在这个条件时终止递归，并得到一个解；4）剪枝，如何剪掉不符合题意的选择或者步骤。</p>

<p>虽然说具体的问题的分析场景不太一样，也就是说具体的每个问题的分为子问题的方式，以及子问题的解决步骤还有回溯方式是不一样的，但整体来说，回溯算法是有套路的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def backtracking(current_option):
</span><span class='line'>   if satisfied:
</span><span class='line'>     return solution
</span><span class='line'>   if not satisfied:
</span><span class='line'>     return null
</span><span class='line'>   next_option = getNext()
</span><span class='line'>   backtrack(next_option)
</span><span class='line'>   undo next_option</span></code></pre></td></tr></table></div></figure>


<p>下面来看一下一些典型的可以用回溯算法来求解的问题类型。</p>

<h2>递归树</h2>

<p>回溯是一个DFS的过程，是在遍历一颗递归树(State space tree)，所以要想更好的应用回溯，最好画出一颗递归树，以更好的厘清回溯过程和剪枝。一个节点代表一个状态，一个路径代表一个操作，叶子节点表示递归到达终止条件。
比如说子集问题，给定一个无重复元素的数组，找出所有的子集，比如给定[1,2,3]，那么递归树就会是这个样子的:</p>

<p><img src="https://s2.51cto.com/images/blog/202207/14100620_62cf7a1cd872b99542.png" alt="" /></p>

<p>剪枝即是依据某些约束条件，把不符合要求的路径排除在外，这不单单排除一个节点，而是把这个节点的所在的路径都排除了，这个节点及其后面的DFS都不需要做了，就像把树的一根分杈剪掉一样，所以形象的称之为剪枝。</p>

<h2>基础回溯问题</h2>

<p>有一些非常典型的用回溯解决的问题，如子集（幂集），组合和排列问题，这些问题是基础的回溯算法应用问题，有标准的套路，用于理解回溯和训练加溯思维都是很好的例子。</p>

<h3>子集(幂集)问题</h3>

<p><a href="https://baike.baidu.com/item/%E5%AD%90%E9%9B%86/5017034?fromModule=lemma_inlink">子集</a>是指一个如果 一个集合A的元素都属于另一个集合B，那么A就是B的一个子集，空集和全集也都是子集。回溯算法解决的问题，更准确的说是求一个给定集合（一般以数组形式给出）的<a href="https://baike.baidu.com/item/%E5%B9%82%E9%9B%86/9555341">幂集</a>。一个集合所有子集所组成的集合，称之为该集合的幂集(<a href="https://en.wikipedia.org/wiki/Power_set">Power set</a>)。集合中每一个元素都有两种选择，加入某个子集，或者不加入，假如集合大小为n，那么一共会有2<sup>n</sup>个不同的子集，所以子集相关问题的复杂度，至少会是O(2<sup>n</sup>)的。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/subsets/">78. 子集</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/subsets/solution/by-alexhilton-1ego/">题解</a> </td>
<td style="text-align:left;"> 回溯模板，无需剪枝 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/subsets-ii/solution/90-zi-ji-ii-by-alexhilton-2ym6/">题解</a> </td>
<td style="text-align:left;"> 在78基础上进行剪 枝 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sum-of-all-subset-xor-totals/">1863. 找出所有子集的异或总和再求和</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sum-of-all-subset-xor-totals/solution/1863-zhao-chu-suo-you-zi-ji-de-yi-huo-zo-mm0k/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/count-number-of-maximum-bitwise-or-subsets/">2044. 统计按位或能得到最大值的子集数目</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/count-number-of-maximum-bitwise-or-subsets/solution/2044-tong-ji-an-wei-huo-neng-de-dao-zui-1djyn/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br /></p>

<h3>组合问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solution/by-alexhilton-7d4f/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/combination-sum/solution/by-alexhilton-1dzy/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/combination-sum-ii/">40. 组合总和 II</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/combination-sum-ii/solution/by-alexhilton-mskx/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/combinations/">77. 组合</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/combinations/solution/by-alexhilton-hrj9/">题解</a> </td>
<td style="text-align:left;"> 子集的简化版本 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/combination-sum-iii/solution/by-alexhilton-2hmo/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/binary-watch/">401. 二进制手表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/binary-watch/solution/by-alexhilton-i35b/">题解</a> </td>
<td style="text-align:left;"> 与216是同一题 </td>
</tr>
</tbody>
</table>


<p><br /></p>

<h3>排列问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/permutations/solution/by-alexhilton-k4r5/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/permutations-ii/solution/by-alexhilton-m337/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/letter-case-permutation/">784. 字母大小写全排列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/letter-case-permutation/solution/by-alexhilton-c4lx/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/solution/by-alexhilton-6m8r/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br /></p>

<h2>高级回溯问题（搜索问题）</h2>

<h3>棋盘类问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sudoku-solver/">37. 解数独</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sudoku-solver/solution/by-alexhilton-jwwh/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/n-queens/solution/by-alexhilton-b3md/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/n-queens-ii/">52. N皇后 II</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/n-queens-ii/solution/52-nhuang-hou-ii-by-alexhilton-qrk5/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br /></p>

<h3>分割类问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/restore-ip-addresses/">93. 复原 IP 地址</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/restore-ip-addresses/solution/by-alexhilton-zdne/">题解</a> </td>
<td style="text-align:left;"> 与131类似，但简单不少，因为只需要分四段即可 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/palindrome-partitioning/solution/by-alexhilton-mqgw/">题解</a> </td>
<td style="text-align:left;"> 学会如何对字串分割子串 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br /></p>

<h3>构造类问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/generate-parentheses/solution/by-alexhilton-9yxt/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br /></p>

<h3>DFS+回溯</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/all-paths-from-source-to-target/">797. 所有可能的路径</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/all-paths-from-source-to-target/solution/797-suo-you-ke-neng-de-lu-jing-by-alexhi-70xm/">题解</a> </td>
<td style="text-align:left;"> DFS+回溯 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/binary-tree-paths/solution/by-alexhilton-xjyj/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/word-search/solution/79-dan-ci-sou-suo-by-alexhilton-2luf/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br /></p>

<h2>其他枚举类问题</h2>

<p>回溯本质上就是暴力穷举，所以一些枚举类问题也可以通过回溯来解决。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/ambiguous-coordinates/">816. 模糊坐标</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/ambiguous-coordinates/solution/816-mo-hu-zuo-biao-by-alexhilton-ne9d/">题解</a> </td>
<td style="text-align:left;"> 就是枚举，其实没用到回溯 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/coordinate-with-maximum-network-quality/">1620. 网络信号最好的坐标</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/coordinate-with-maximum-network-quality/solution/by-alexhilton-ofb6/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/max-points-on-a-line/">149. 直线上最多的点数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/max-points-on-a-line/solution/by-alexhilton-gksh/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br /></p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/introduction-to-backtracking-data-structure-and-algorithm-tutorials/">Introduction to Backtracking</a></li>
<li><a href="https://techwithkp.com/backtracking-algorithm-explained-with-examples/">Backtracking Algorithm Explained With Examples</a></li>
<li><a href="https://www.programiz.com/dsa/backtracking-algorithm">Backtracking Algorithm</a></li>
<li><a href="https://www.simplilearn.com/tutorials/data-structure-tutorial/backtracking-algorithm">What is Backtracking Algorithm? Types, Examples &amp; its Application</a></li>
<li><a href="https://www.freecodecamp.org/news/backtracking-algorithms-explained/">Backtracking Algorithms Explained</a></li>
<li><a href="https://blog.csdn.net/a1241692733/article/details/123029578">Leetcode 刷题笔记(二十) ——回溯算法篇之分割、子集、全排列问题</a></li>
<li><a href="http://c.biancheng.net/view/3400.html">回溯算法详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/165083789">回溯算法详细总结</a></li>
<li><a href="https://blog.csdn.net/weiyuefei/article/details/79316653">[回溯算法] 五大常用算法之回溯法</a></li>
<li><a href="https://www.jianshu.com/p/dd3c3f3e84c0">小白带你学&ndash;回溯算法</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/93530380">回溯算法套路详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/308282208">关于回溯算法，你该了解这些！</a></li>
<li><a href="https://blog.csdn.net/m0_52824954/article/details/123467217">彻底搞懂回溯算法（本文真的很详细）</a></li>
<li><a href="https://www.cnblogs.com/Curryxin/p/15139654.html">【算法】回溯</a></li>
<li><a href="https://blog.csdn.net/weixin_43208423/article/details/101081544">理解回溯算法——回溯算法的初学者指南</a></li>
<li><a href="https://juejin.cn/post/7060704637736714253">一文带你了解回溯算法的套路</a></li>
<li><a href="https://leetcode.cn/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/">C++ 总结了回溯问题类型 带你搞懂回溯算法(大量例题)</a></li>
<li><a href="https://leetcode.cn/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/">回溯算法入门级详解 + 练习（持续更新）</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
