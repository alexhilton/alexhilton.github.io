<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2025-02-06T21:17:16+08:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Compose多平台 (CMP) 开发的四个实用技巧]]></title>
    <link href="https://alexhilton.github.io/blog/2025/02/04/tips-to-migrate-to-kmp/"/>
    <updated>2025-02-04T17:21:07+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/02/04/tips-to-migrate-to-kmp</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自<a href="https://proandroiddev.com/4-useful-tips-for-compose-kotlin-multiplatform-kmp-8809ba1cac51">Four useful tips for Compose Kotlin Multiplatform (KMP)</a></p></blockquote>

<p><strong>译注：</strong> 这篇文章虽然比较短，但提到的问题还是比较具体和典型的，针对CMP项目的一些配置还是很有借鉴意义的。</p>

<p><a href="https://alexhilton.github.io/blog/2025/02/04/tips-to-migrate-to-kmp/"><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/j9tap6mygsqvxh6aauc8.png" title="auto auto" ></a></p>

<!-- more -->


<h2>简介</h2>

<p>正如我在上一篇文章<a href="https://medium.com/@lizarraga.iosu/a-complete-migration-of-a-multi-module-app-to-compose-kotlin-multiplatform-kmp-682905266bde">《将多模块应用程序完全迁移到 Compose Kotlin Multiplatform (KMP)》</a>中所说，上个月我一直在将现有的多模块应用程序迁移到 Compose Multiplatform，除此之外，我还从头开始创建一个新的 Compose Multiplatform 多模块项目。在这两个项目中，我都遇到了相同的“问题”或者说“阻碍”，因此，如果您正在迁移或从头开始启动 CMP 项目，那么本文就是为你量身定做的。</p>

<h2>提示 1：预览</h2>

<p>KMP 不支持 commonMain 目录Compose组件的预览，因此我想到了在 androidMain 目录中创建它们，并且它们的预览运行得很好。</p>

<blockquote><p><strong>译注：</strong>此文原文发布于2024年12月初，彼时非Android侧的源码确实无法Preview，后来JetBrains解决了这个问题，通过一个<a href="https://plugins.jetbrains.com/plugin/16541-compose-multiplatform-ide-support">支持桌面Compose的插件</a>。</p></blockquote>

<p>例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>commonMain/com/example/feature/component/FeatureScreen.kt
</span><span class='line'>androidMain/com/example/feature/component/FeatureScreenPreview.kt
</span></code></pre></td></tr></table></div></figure>


<h2>提示 2：BackHandler</h2>

<p>KMP 不支持 BackHandler 操作，因此我创建了一个用于屏幕的expect函数，并在 androidMain 中的actual函数上添加了 BackHandler 操作，并将 iosMain 留空（因为我在 iOS 中没有找到类似的操作）。</p>

<p>例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="c1">// commonMain/ com.example.feature.component.FeatureScreen.kt</span>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="n">expect</span> <span class="k">fun</span> <span class="nf">FeatureScreen</span><span class="p">(</span>
</span><span class='line'>    <span class="n">viewModel</span><span class="p">:</span> <span class="n">FeatureScreenViewModel</span><span class="p">,</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">internal</span> <span class="k">fun</span> <span class="nf">Content</span><span class="p">(</span>
</span><span class='line'>    <span class="n">viewModel</span><span class="p">:</span> <span class="n">FeatureScreenViewModel</span><span class="p">,</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="c1">// androidMain/ com.example.feature.component.FeatureScreenActual.kt (needs a name different from common)</span>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="n">actual</span> <span class="k">fun</span> <span class="nf">FeatureScreen</span><span class="p">(</span>
</span><span class='line'>    <span class="n">viewModel</span><span class="p">:</span> <span class="n">WorkScreenViewModel</span><span class="p">,</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">BackHandler</span> <span class="p">{</span> <span class="n">viewModel</span><span class="p">.</span><span class="n">onIntent</span><span class="p">(</span><span class="n">WorkIntent</span><span class="p">.</span><span class="n">Back</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Content</span><span class="p">(</span>
</span><span class='line'>        <span class="n">viewModel</span> <span class="p">=</span> <span class="n">viewModel</span><span class="p">,</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// extra: I have joined the preview in this same class to have it better organized.</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="c1">// iosMain/ com.example.feature.component.FeatureScreenActual.kt (needs a name different from common)</span>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="n">actual</span> <span class="k">fun</span> <span class="nf">FeatureScreen</span><span class="p">(</span>
</span><span class='line'>    <span class="n">viewModel</span><span class="p">:</span> <span class="n">WorkScreenViewModel</span><span class="p">,</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Content</span><span class="p">(</span>
</span><span class='line'>        <span class="n">viewModel</span> <span class="p">=</span> <span class="n">viewModel</span><span class="p">,</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>提示 3：测试模拟</h2>

<p>我喜欢使用 <a href="https://mockk.io/">mockk</a> 库进行模拟测试，在撰写本文时，KMP 尚不支持该库，因此我决定在 androidUnitTest 目录中创建 UnitTest，并将库依赖项添加到 androidUnitTest.dependencies {} 块中。</p>

<p>对于此类测试，我使用了支持 KMP 的 kotlin-test jetbrains 库。</p>

<p>例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">mockk</span> <span class="p">=</span> <span class="p">{</span> <span class="n">group</span> <span class="p">=</span> <span class="s">&quot;io.mockk&quot;</span><span class="p">,</span> <span class="n">name</span> <span class="p">=</span> <span class="s">&quot;mockk&quot;</span><span class="p">,</span> <span class="n">version</span><span class="p">.</span><span class="n">ref</span> <span class="p">=</span> <span class="s">&quot;mockk-version&quot;</span> <span class="p">}</span>
</span><span class='line'><span class="n">kotlin</span><span class="p">-</span><span class="n">test</span> <span class="p">=</span> <span class="p">{</span> <span class="n">group</span> <span class="p">=</span> <span class="s">&quot;org.jetbrains.kotlin&quot;</span><span class="p">,</span> <span class="n">name</span> <span class="p">=</span> <span class="s">&quot;kotlin-test&quot;</span><span class="p">,</span> <span class="n">version</span><span class="p">.</span><span class="n">ref</span> <span class="p">=</span> <span class="s">&quot;kotlin-version&quot;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="c1">// feature build.gradle.kts</span>
</span><span class='line'><span class="n">kotlin</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">sourceSets</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">androidUnitTest</span><span class="p">.</span><span class="n">dependencies</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="n">libs</span><span class="p">.</span><span class="n">mockk</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">commonTest</span><span class="p">.</span><span class="n">dependencies</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="n">libs</span><span class="p">.</span><span class="n">kotlin</span><span class="p">.</span><span class="n">test</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>androidUnitTest/com/example/feature/usecase/UseCaseTest.kt
</span></code></pre></td></tr></table></div></figure>


<h2>提示 4：UI 测试</h2>

<p><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-test.html">官方的 Compose 多平台 UI 测试指南</a>指出，必须使用commonTest 目录进行 UI 测试，但我更喜欢使用androidInstrumentedTest目录，因为使用这种方法，我可以将单元测试与 UI 测试分开，并且我可以直接从同一个测试类执行它们，并从目录运行所有 UI 测试。</p>

<p>例如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">mockk</span><span class="p">-</span><span class="n">android</span> <span class="p">=</span> <span class="p">{</span> <span class="n">group</span> <span class="p">=</span> <span class="s">&quot;io.mockk&quot;</span><span class="p">,</span> <span class="n">name</span> <span class="p">=</span> <span class="s">&quot;mockk-android&quot;</span><span class="p">,</span> <span class="n">version</span><span class="p">.</span><span class="n">ref</span> <span class="p">=</span> <span class="s">&quot;mockk-version&quot;</span> <span class="p">}</span>
</span><span class='line'><span class="n">ui</span><span class="p">-</span><span class="n">test</span><span class="p">-</span><span class="n">junit4</span><span class="p">-</span><span class="n">android</span> <span class="p">=</span> <span class="p">{</span> <span class="n">group</span> <span class="p">=</span> <span class="s">&quot;androidx.compose.ui&quot;</span><span class="p">,</span> <span class="n">name</span> <span class="p">=</span> <span class="s">&quot;ui-test-junit4-android&quot;</span><span class="p">,</span> <span class="n">version</span><span class="p">.</span><span class="n">ref</span> <span class="p">=</span> <span class="s">&quot;uiTestJunit4AndroidVersion&quot;</span> <span class="p">}</span>
</span><span class='line'><span class="n">ui</span><span class="p">-</span><span class="n">test</span><span class="p">-</span><span class="n">manifest</span> <span class="p">=</span> <span class="p">{</span> <span class="n">group</span> <span class="p">=</span> <span class="s">&quot;androidx.compose.ui&quot;</span><span class="p">,</span> <span class="n">name</span> <span class="p">=</span> <span class="s">&quot;ui-test-manifest&quot;</span><span class="p">,</span> <span class="n">version</span><span class="p">.</span><span class="n">ref</span> <span class="p">=</span> <span class="s">&quot;uiTestManifestVersion&quot;</span> <span class="p">}</span>
</span><span class='line'><span class="n">kotlin</span><span class="p">-</span><span class="n">test</span> <span class="p">=</span> <span class="p">{</span> <span class="n">group</span> <span class="p">=</span> <span class="s">&quot;org.jetbrains.kotlin&quot;</span><span class="p">,</span> <span class="n">name</span> <span class="p">=</span> <span class="s">&quot;kotlin-test&quot;</span><span class="p">,</span> <span class="n">version</span><span class="p">.</span><span class="n">ref</span> <span class="p">=</span> <span class="s">&quot;kotlin-version&quot;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="c1">// feature build.gradle.kts</span>
</span><span class='line'><span class="n">plugins</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>    <span class="n">alias</span><span class="p">(</span><span class="n">libs</span><span class="p">.</span><span class="n">plugins</span><span class="p">.</span><span class="n">compose</span><span class="p">.</span><span class="n">multiplatform</span><span class="p">)</span>
</span><span class='line'>    <span class="n">alias</span><span class="p">(</span><span class="n">libs</span><span class="p">.</span><span class="n">plugins</span><span class="p">.</span><span class="n">compose</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">kotlin</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">...</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">sourceSets</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">androidInstrumentedTest</span><span class="p">.</span><span class="n">dependencies</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="n">libs</span><span class="p">.</span><span class="n">mockk</span><span class="p">.</span><span class="n">android</span><span class="p">)</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="n">libs</span><span class="p">.</span><span class="n">ui</span><span class="p">.</span><span class="n">test</span><span class="p">.</span><span class="n">junit4</span><span class="p">.</span><span class="n">android</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">commonTest</span><span class="p">.</span><span class="n">dependencies</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="n">libs</span><span class="p">.</span><span class="n">kotlin</span><span class="p">.</span><span class="n">test</span><span class="p">)</span>
</span><span class='line'>            <span class="n">@OptIn</span><span class="p">(</span><span class="n">ExperimentalComposeLibrary</span><span class="o">::</span><span class="k">class</span><span class="p">)</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="n">compose</span><span class="p">.</span><span class="n">uiTest</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">...</span>
</span><span class='line'>
</span><span class='line'><span class="n">dependencies</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">debugImplementation</span><span class="p">(</span><span class="n">libs</span><span class="p">.</span><span class="n">ui</span><span class="p">.</span><span class="n">test</span><span class="p">.</span><span class="n">manifest</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>androidInstrumentedTest/com/example/feature/component/ScreenAndroidTest.kt
</span></code></pre></td></tr></table></div></figure>


<h2>结论</h2>

<p>在本文中，我们看到了一些 Compose Multiplatform 技巧，希望您觉得它们有用。感谢您阅读本文，欢迎提供任何反馈。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于Android 16你想知道的都在这里]]></title>
    <link href="https://alexhilton.github.io/blog/2025/01/02/android-16-is-comming/"/>
    <updated>2025-01-02T22:14:32+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/01/02/android-16-is-comming</id>
    <content type="html"><![CDATA[<p>2025年的Android新版本来的比2024年稍早了一些。今年Google非常反常地提前就发布了Android的<a href="https://developer.android.com/about/versions/16">新版本Android 16 Baklava</a>，整体的计划比往年提前了2～3个月。另外，谷歌把<a href="https://www.androidfaithful.com/android-16-code-name/">Android 16的代码命名为「Baklava」</a>,这与先前的字母表顺序的点心食物命名方式截然不同，不过「Baklava」巴克拉瓦，又称果仁蜜饼，是一种口味浓郁、甜蜜的土耳其酥皮点心。</p>

<p><a href="https://alexhilton.github.io/blog/2025/01/02/android-16-is-comming/"><img src="https://www.android-user.de/wp-content/uploads/2024/11/20241101-Android-16-Baklava-Beitragsbild.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>谷歌的发布计划</h2>

<p>从<a href="https://developer.android.com/about/versions/16">官方的消息</a>来看会在24年结束Preview，在25年1月其实是Q1就开始Beta release，并在Q2进入Platform Stability，预计上半年就可能会正式发布，整体的节奏较往年提前了约2～3个月（往年是Q1会有Preview，Q2发布Beta,6~7月左右开始Platform Stability，Q3 9月～10月正式发布）。</p>

<p><img src="file:///Users/alexhilton/Downloads/android-16-release.webp" alt="图1. Android 16的发布计划" /></p>

<p>不过现仍在非常为初始的Preview阶段，后面可能会有变数，官方也没有给具体的计划。但有一点是确定的，那就是今年Android 16的发布肯定较往年会提拉一些，至少提拉2个月。</p>

<p>对于应用开发者来说，更为关心的是API的发布情况，一般情况下API会较系统版本提前一个季度就会正式稳定下来（也即不会再有大的变动），换句话说，今年在Q2就能得到较为稳定的API版本，当然比往年还是有提拉的。</p>

<p><img src="file:///Users/alexhilton/Downloads/android16-api-release.webp" alt="图2. Android 16 API的发布计划" /></p>

<p>发布计划不受我们控制，了解一下就可以了，下面我们看一下如何用条件区分这些新的API。</p>

<h2>区分使用新的API的方式</h2>

<p>如果应用不是运行在最新的版本，那么新的API不应该被执行，因此我们需要用条件来区分不同的API版本，用<a href="https://developer.android.com/reference/android/os/Build.VERSION#SDK_INT">SDK_INT</a>和<a href="https://developer.android.com/reference/android/os/Build.VERSION_CODES">VERSION_CODES</a>就可以做到。当然，需要先在Android Studio中把SDK中的Android 16 Preview版本下载下来才能编译。</p>

<p><img src="file:///Users/alexhilton/Downloads/install-baklava-sdk.png" alt="图3. 升级SDK" /></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">SDK_INT</span> <span class="p">&gt;=</span> <span class="n">VERSION_CODES</span><span class="p">.</span><span class="n">BAKLAVA</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// 使用Android 16中才有的API</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了能更细致地区分版本，Android 16新增加了一个新的版本常量<a href="https://developer.android.com/reference/android/os/Build.VERSION#SDK_INT_FULL">SDK_INT_FULL</a>，并在<a href="https://developer.android.com/reference/android/os/Build.VERSION_CODES_FULL">VERSION_CODES_FULL</a>中定义了具体的常量值。它可以粒度更细地检查API的版本，分为Major版本和Minor版本。以往的SDK_INT只能区分大的版本（Major版本），这是它们最大的不同。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">SDK_INT_FULL</span> <span class="p">&gt;=</span> <span class="n">VERSION_CODES_FULL</span><span class="p">.[</span><span class="n">MAJOR</span> <span class="n">or</span> <span class="n">MINOR</span> <span class="n">RELEASE</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// 用Major版本或者Minor版本才有的API</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>每个Major版本可能会多个Minor版本，如果不想麻烦，可以用<a href="https://developer.android.com/reference/android/os/Build#getMinorSdkVersion%28int%29">Build.getMinorSdkVersion()</a>来从VERSION_CODES_FULL中取出Minor版本号。</p>

<p><strong>注意：</strong> SDK_INT_FULL，VERSION_CODES_FULL以及getMinorSdkVersion都是Android 16中新增的API，确保把SDK升级到最新才可以编译成功。</p>

<p>接下来我们重点来看一下新一代的Android带来了哪些变化。</p>

<h2>新的功能和新的API</h2>

<p>很不幸，Android 16并没有带来全新的功能。只有一些小的新API。</p>

<h3>用户体验和系统UI</h3>

<p>提供一些的新的API以更好更灵活的控制系统的行为。</p>

<h4>可预见的返回更新</h4>

<p>Android 16增加了新的API以使能手势导航中的可预见返回系统动画，比如从应用返回到桌面的动画。使用新的<a href="https://developer.android.com/reference/android/window/OnBackInvokedDispatcher#PRIORITY_SYSTEM_NAVIGATION_OBSERVER">PRIORITY_SYSTEM_NAVIGATION_OBSERVER</a>向系统注册一个回调<a href="https://developer.android.com/reference/android/window/OnBackInvokedDispatcher#registerOnBackInvokedCallback(int,%20android.window.OnBackInvokedCallback">onBackInvokedCallback</a>)，每当系统处理一个返回导航时就能够收到<a href="https://developer.android.com/reference/android/window/OnBackInvokedCallback#onBackInvoked(">onBackInvoked</a>)回调，而不影响常规的返回导航流程。</p>

<p>Android 16还增加了两个API <a href="https://developer.android.com/reference/android/window/SystemOnBackInvokedCallbacks#finishAndRemoveTaskCallback(android.app.Activity">finishAndRemoveTaskCallback</a>)和<a href="https://developer.android.com/reference/android/window/SystemOnBackInvokedCallbacks#moveTaskToBackCallback(android.app.Activity">moveTaskToBackCallback</a>)。通过向<a href="https://developer.android.com/reference/android/window/OnBackInvokedDispatcher">OnBackInvokedDispatcher</a>注册这些回调，当执行返回手势时系统就能触发具体的行为和播放相关的动画。</p>

<h4>更加丰富的震感反馈</h4>

<p>Android 16增加了<a href="https://developer.android.com/reference/android/os/vibrator/package-summary">震感API</a>，能让应用定义震感效果的振幅和频率的曲线，同时屏蔽设备的差异。</p>

<h3>性能和电池</h3>

<p>Android 16提供了新的API以帮助收集应用的洞察。</p>

<h4>系统触发的分析</h4>

<p><a href="https://developer.android.com/about/versions/15/features#app-start-info">Android 15</a>添加的<a href="https://developer.android.com/reference/android/os/ProfilingManager">ProfilingManager</a>能让应用请求分析数据集。然而，这个分析必须由应用来发起，一些像启动过程以及ANR就很抓取得到（因为应用必须要先正常启动起来后，才能调用ProfilingManager去获取分析数据）。</p>

<p>为了解决这个问题，Android 16在ProfilingManager中增加了系统触发的分析数据。应用可以注册感兴趣的特定场景的trace，诸如冷起动或者ANR，系统会替应用开启和停止trace。trace收集完毕后，结果会传到应用的data目录。</p>

<h3>ApplicationStartInfo中增加Start component</h3>

<p>ApplicationStateInfo是在Android 15增加的，让应用能够看到进程启动原因，启动类型，启动时间等一系列诊断数据。Android 16增加了方法<a href="">getStartComponent</a>以辨识哪种组件类型触发的启动，这对于优化应用启动过程将会非常有帮助。</p>

<h3>更好的（后台）任务反查</h3>

<p>API <a href="https://developer.android.com/reference/android/app/job/JobScheduler#getPendingJobReason(int">JobScheduler#getPendingJobReason()</a>)能返回任何处于待处理的原因。当然，一个任务可能由于很多种原因待处理。</p>

<p>在Android 16中，增加了一个新的API <a href="https://developer.android.com/reference/android/app/job/JobScheduler#getPendingJobReasons(int">JobScheduler#getPendingJobReasons(int jobId)</a>)，用以返回任务处于待处理的多个原因，比如缘于开发者设置了显性的限制或者系统设置的隐性限制。</p>

<p>还增加了一个API <a href="https://developer.android.com/reference/android/app/job/JobScheduler#getPendingJobReasonsHistory(int">JobScheduler#getPendingJobReasonsHistory(int jobId)</a>)，用以返回最近的限制变更列表。</p>

<p>推荐使用这些API来调试为何后台任务没被执行，尤其是当看到特定任务的成功率降低时，或者特定任务完成有延迟时。例如，在后台更新桌面小部件时失败或者预先拉取任务在应用启动前失败等等。</p>

<p>这也能够更好的帮助你明白因为系统定义的限制还是因为显性的限制而导致特定的任务未执行完成。</p>

<h3>自适应刷新频率</h3>

<p>Android 15引入的自适应刷新频率(Adaptive refresh rate ARR)通过离散化的VSync步长能够让屏幕刷新频率适配内容频率。这会降低功耗同时消除潜在的掉帧。</p>

<p>Android 16增加了方法<a href="https://developer.android.com/reference/android/view/Display#hasArrSupport(">hasArrSupport</a>)和方法<a href="https://developer.android.com/reference/android/view/Display#getSuggestedFrameRate(int">getSuggestedFrameRate(int)</a>)以及<a href="https://developer.android.com/reference/android/view/Display#getSupportedRefreshRates(">getSupportedRefreshRates()</a>)，让应用容易利用ARR。Jetpack中的很多组件在内部实现上已经利用ARR以增强平滑的滑动，详细的可<a href="https://developer.android.com/media/optimize/performance/frame-rate">参见了此文章</a>。</p>

<h3>连接</h3>

<p>WiFi可以用来室内定位，Android 16增加了对WiFi位置安全性的支持，通过<a href="https://developer.android.com/reference/android/net/wifi/rtt/SecureRangingConfig">这个特性</a>。</p>

<h3>媒体</h3>

<h4>照片选择增强</h4>

<p><a href="https://developer.android.com/training/data-storage/shared/photopicker">照片选择器(photo picker)</a>提供了一个安全且内置的方式让应用在用户授权的情况下从存储中选择媒体文件。</p>

<p>Android 16带来的增强点有：</p>

<ul>
<li>嵌入式的图片选择器：<a href="https://developer.android.com/reference/android/widget/photopicker/package-summary">新的API</a>能够让应用把图片选择器嵌入到自己的视图中。这会让图片选择看起来更像是应用整体的一部分。后续的Jetpack中会提供可嵌入的图片选择器。</li>
<li>图片选择器支持云搜索：<a href="https://developer.android.com/sdk/api_diff/b-dp2-incr/changes/pkg_android.provider">新的API</a>在图片选择器将支持云搜索。</li>
</ul>


<h3>隐私</h3>

<h4>健康连接更新</h4>

<p>开发者Preview版本中的健康连接增加了ACTIVITY_INTENSITY（活动强度），依据世界健康组织（WHO）给出的指南中定义的一个新的数据类型。每一条记录将必须包括开始时间，结束时间以及活动强度。</p>

<h4>隐私沙盒</h4>

<p>Android 16集成了<a href="https://developers.google.com/privacy-sandbox/overview/android">Android隐私沙盒</a>的最新版本，这是一项为保护用户隐私而持续进行的工作。可以查看<a href="https://developer.android.com/design-for-safety/privacy-sandbox/program-overview">网站内容</a>以了解更多。</p>

<h2>行为变更</h2>

<p>比起新的API，Android 16带来的行为变更更值得我们关注，因为这会直接影响所有应用，无论targetSdkVersion是否是Baklava。</p>

<h3>核心功能</h3>

<h4>JobScheduler配额优化</h4>

<p>从Android 16开始，以基于以下因素来调整常规任务和加急任务的运行时配额：</p>

<ul>
<li>应用处于<a href="https://developer.android.com/topic/performance/appstandby">哪个等待区</a>：在Android 16中，活跃的等待区会减少限制。</li>
<li>如果任务开始执行时应用处于头部状态：在Android 16中，任务启动时，如果应用是用户可见的且应用变成可见后仍在继续执行，会加入到运行时配额中。</li>
<li>如果任务执行时正在运行一个前台服务：在Android 16中，当正在执行一个前台服务时，正在执行的任务将加入到运行时配额中。如果任务是用于用户数据传送，建议<a href="https://developer.android.com/develop/background-work/background-tasks/uidt">考虑替换方案</a>。</li>
</ul>


<p>这些变动将会影响由WorkManager，JobScheduler和DownloadManager调度的任务。如果要调试为何一个任务被终止了，建议通过调用<a href="https://developer.android.com/reference/androidx/work/WorkInfo#getStopReason(">WorkInfo.getStopReason()</a>)来打印日志。</p>

<p>也可以通过Android 16新增加的API <a href="https://developer.android.com/partners/android-16/features#feature-pending-job-reason-history">JobScheduler#getPendingJobReasonsHistory</a>来了解为何任务未执行。</p>

<p>另外，在Android 16上还可以通过adb命令强制调整运行时任务配额，以方便测试：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='Bash'><span class='line'><span class="c"># 取消头部状态配额限制</span>
</span><span class='line'>adb shell am compat <span class="nb">enable </span>OVERRIDE_QUOTA_ENFORCEMENT_TO_TOP_STARTED_JOBS &lt;APP_PACKAGE_NAME&gt;
</span><span class='line'>
</span><span class='line'><span class="c"># 设置等待区</span>
</span><span class='line'>adb shell am <span class="nb">set</span>-standby-bucket &lt;APP_PACKAGE_NAME&gt; active<span class="p">|</span>working_set<span class="p">|</span>frequent<span class="p">|</span>rare<span class="p">|</span>restricted
</span><span class='line'>
</span><span class='line'><span class="c"># 获取所处的等待区状态</span>
</span><span class='line'>adb shell am get-standby-bucket &lt;APP_PACKAGE_NAME&gt;
</span></code></pre></td></tr></table></div></figure>


<h3>用户体验和系统UI</h3>

<p>Android 16废弃了无障碍公告(announcement)，一种使用<a href="https://developer.android.com/reference/android/view/View#announceForAccessibility(java.lang.CharSequence">announceForAccessibility</a>)或者派发<a href="https://developer.android.com/reference/android/view/accessibility/AccessibilityEvent#TYPE_ANNOUNCEMENT">TYPE_ANNOUNCEMENT</a>引起的无障碍事件。这些公告会造成Talkback和屏幕发声的混乱，容易被滥用，一些可行的替换方案有：</p>

<ul>
<li>对于像窗口变化之类的极重要的UI变化，可以用<a href="https://developer.android.com/reference/android/app/Activity#setTitle(java.lang.CharSequence">Activity.setTitle(CharSequence)</a>)和<a href="https://developer.android.com/reference/android/view/View#setAccessibilityPaneTitle(java.lang.CharSequence">setAccessibilityPaneTitle(java.lang.CharSequence)</a>)。在Compose中使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/semantics/package-summary#(androidx.compose.ui.semantics.SemanticsPropertyReceiver">Modifier.semantics { paneTitle = &ldquo;paneTitle&rdquo; }</a>.liveRegion)。</li>
<li>告知用户重要UI变化，使用<a href="https://developer.android.com/reference/android/view/View#setAccessibilityLiveRegion(int">setAccessibilityLiveRegion(int)</a>)。在Compose中，用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/semantics/package-summary#(androidx.compose.ui.semantics.SemanticsPropertyReceiver">Modifier.semantics { liveRegion = LiveRegionMode.[Polite|Assertive]}</a>.liveRegion)。这些也要小心使用，因为每当View刷新就会触发一个无障碍事件。</li>
<li>通知用户有错误，发送一个类型为<a href="https://developer.android.com/reference/android/view/accessibility/AccessibilityEvent#CONTENT_CHANGE_TYPE_ERROR">AccessibilityEvent#CONTENT_CHANGE_TYPE_ERROR</a>的无障碍事件，并且设置<a href="https://developer.android.com/reference/android/view/accessibility/AccessibilityNodeInfo#setError(java.lang.CharSequence">AccessibilityNodeInfo#setError(CharSequence)</a>)，或者<a href="https://developer.android.com/reference/android/widget/TextView#setError(java.lang.CharSequence">TextView#setError(CharSequence)</a>)。</li>
</ul>


<p>可以<a href="https://developer.android.com/reference/android/view/View#announceForAccessibility(java.lang.CharSequence">看文档</a>)以了解废弃announceForAccessibility的细节以及推荐的替代方案。</p>

<h2>适配建议</h2>

<p>到目前为止，我们能了解到的Android 16的变化就这么多，总的来看增量变化并不多，新的API 都是一些小的细节上的增强；行为的变更也很少很少，只涉及后台任务和无障碍。新的API不会影响现有的应用，行为变更也不多，可以说对于绝大多数应用来说影响甚微。</p>

<p>现在仍是开发者Preview阶段，只有亲儿子Pixel系列会收到OTA版本，我们了解一下就可以了。即使是应用可能会受到行为变更的影响，也不用着急，建议再等2～3个月，等到有更多的厂商发出Beta版本了，并且API也稳定了时再做适配也不迟。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/about/versions/16/features">Features and APIs</a></li>
<li><a href="https://android-developers.googleblog.com/2024/11/the-first-developer-preview-android16.html">The First Developer Preview of Android 16</a></li>
<li><a href="https://android-developers.googleblog.com/2024/12/second-developer-preview-android16.html">The Second Developer Preview of Android 16</a></li>
<li><a href="https://developer.android.com/about/versions/16/behavior-changes-16">Behavior changes: Apps targeting Android 16 or higher</a></li>
<li><a href="https://developer.android.com/about/versions/16/behavior-changes-all">Behavior changes: all apps</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[群星闪耀的大前端开发]]></title>
    <link href="https://alexhilton.github.io/blog/2024/12/10/a-brief-history-of-cross-platform-development/"/>
    <updated>2024-12-10T22:01:05+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/12/10/a-brief-history-of-cross-platform-development</id>
    <content type="html"><![CDATA[<p>乔帮主发布iPhone以降，把世界推向了智能手机时代，随之而来的是移动互联网大潮，一时间移动应用开发变得炙手可热起来，渐渐的超越了传统桌面端和传统前端，成为了主流。随之而来的就是重复开发的问题，同样的业务需要在Android上面实现一次，在iOS上面实现一次，通常也需要在Mobile Web（移动端H5）实现一次，自此跨端开发成了移动互联时代一个必须要攻克的难题。</p>

<p><a href="https://alexhilton.github.io/blog/2024/12/10/a-brief-history-of-cross-platform-development/"><img src="https://www.ropstam.com/wp-content/uploads/2023/09/Best-Cross-Platform-App-Development-Frameworks.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>大前端开发简史</h2>

<p>工程师的使命是<strong>把不可能变可能，把可能变简单，把简单变优雅</strong>。如果能用同一套代码在不同的端侧都运行，那将是再美好不过的了，毕竟对于端侧业务逻辑一样的，但却要用不同的编程语言，不同的框架，不同的平台，不同的团队各开发一次。如果能够做到「开发一次，多端运行」，将极大的节省人力物力和财力，开发效率也将大大提升。遂业界一直在探索如何跨移动端开发，也即只用一套代码，开发一次，就可以在Android端，iOS端和移动Web端三端运行。</p>

<h3>史前时代：Hybrid app</h3>

<p>最先出来的框架是Hybrid app（<a href="https://phonegap.com/">PhoneGap</a>和<a href="https://cordova.apache.org/docs/en/latest/">Cordova</a>），利用Android端和iOS端都对WebView有较好的支持，因此用移动前端（也即网页）的方式来开发应用，绝大多数的业务逻辑都在网页里，Android端和iOS端都是用WebView去展示网页，对于JavaScript在网页中无法实现的，与平台强相关的事情可以通过JavaScript Bridge来调用平台实现的API，称之为JsBridge。</p>

<p>这种架构非常简单，对于Android和iOS来说，使用一个WebView，再实现一些native API就可以了，其余的都是标准的移动前端。得益于平台对HTML 5的支持，以及像jQuery Mobile等优秀的前端库的加持，无论是开发体验还是使用体验，Hybrid app并不差。最重的是它跨平台性特别好，性价比超高，对于UI部分很重，交互 也不复杂的以展示为主的页面来说，这是性价比超高的实现方式。</p>

<p>这个可以称之为史前时代。</p>

<h3>黑暗时代：不成熟的各种尝试</h3>

<p>Hybrid app方式虽然可行，但在不同的终端上面体验差距很明显。对于性能较好的中高端设备，因为设备整体性能较好，Hybrid app体验尚可，虽然与原生UI相比仍有差距，但属于可接受范围。但对于中低端设备来说，WebView不但性能差，而且兼容性不好，体验严重差于原生UI。另外，如果UI交互变得复杂，或者对体验和实时性操作要求比较高（如文档编辑类等）Hybrid方式与原生更是相距甚远。工程师们开始尝试新的方案。</p>

<p>比如坊间有用json格式来定义UI，定义好格式后，每个端拿到一坨json数据解析，然后生成UI。这其实都算不上是框架，其实就是用json来描述一个页面，解析与构建UI仍是由每个端自己搞，顶多算是一种UI描述格式。但难以通用，并且只能描述UI的静态结构，无法有动态的行为之类的。这种方案也曾有不少大厂用过，它非常适用于局部的，并不复杂的UI，业务逻辑固定，但UI排版样式可能随时会变页面。但要说用它来写整个应用，是不现实的。</p>

<p>这期间Google也做了尝试，搞出一个叫做<a href="https://developers.google.com/j2objc">j2objc的工具</a>，它能把Java代码翻译 成为Objective&#45;C代码，转换后的Objective-C代码无需修改可以直接编译运行。显然，这个工具并不适用于UI，因为UI都是与平台强相关的，需要大量的依赖于平台的SDK，并不是把代码「翻译」过来就完事了。这个工具适用于非UI部分的业务逻辑代码，效果也非常的好，经其转换后的代码可以直接编译运行。据说Google自己也在用，当时的GMS产品Google Inbox等都用j2objc达到了70%代码共用。</p>

<p>这是大前端的一个黑暗时代，虽然大家都在尝试，但始终没有一个比较理想的完整的解决方案。</p>

<h3>黎明的署光：划时代的ReactNative</h3>

<p>Hybrid方式最大的问题在于WebView是性能和体验的瓶颈，WebView之所以是瓶颈 在于它是一个完全的浏览器，它要完全支持JavaScript，HTML和CSS。但随着HTML5和Web前端技术的发展，有很多库可能只用JavaScript来实现。JavaScript独立出来与Node.js结合（严谨的说是JS引挚），同样可以做前端，但却少了HTML和CSS的拖累，沿着这个思路非死不可（彼时叫做Facebook，现在叫做Meta）推出了一个跨移动端平台的开发框架ReactNative。它是基于Facebook的React框架，做了面向移动端的延伸。它的主要实现方法是用React来写页面，这是一个基于JavaScript语言的声明式UI框架，加入了一个虚拟DOM层，用以屏蔽频繁的DOM改动，然后再把虚拟DOM转成一个渲染树，最后由Node开出口子，把渲染树用Native的API去实现，由此实现了原生UI。</p>

<p>ReactNative可以实现跨三端，页面用React写好后，不用修改就可以在Web，Android和iOS上运行。一经发布引发了巨大反响，坊间众人皆拍大腿「卧草，还可以这样玩儿啊！」。</p>

<p>ReactNative是划时代的，因为它确定了跨端框架的基本结构：声明式UI，虚拟DOM和渲染树，用原生API去实现渲染树（映射为Native的组件，或者用Native graphics API去实现渲染树）。后续的跨端框架基本上都是这个路子。</p>

<h3>群星闪耀的当下</h3>

<p>时光荏苒，移动互联大潮已经过了十几年，技术也层出不穷，新的框架在不断的涌现。现如今跨端这一领域百花齐放，群星闪耀，各大框架经过几年的沉淀与发展已经比较成熟。除了<a href="https://reactnative.dev/">ReactNative</a>以外，还有了NativeScript，Flutter以及CMP。这其中<a href="https://nativescript.org/">NativeScript</a>其实与ReactNative差不多，唯一的区别在于它允许用JavaScript家族语言（如<a href="https://www.typescriptlang.org/">TypeScript</a>和<a href="https://coffeescript.org/">CoffeeScript</a>），以及不限制开发框架，可以用Vue.js或者Angular.js来写UI。</p>

<p>当然，最为广泛流行，业界使用最多的当属于Flutter和ReactNative，CMP作为一颗新星也越来越受关注。</p>

<h2>流行框架对比</h2>

<p>这里简要对比一下最为流行的ReactNative和Flutter以及新星CMP，以方便使用者做出更好的选择。</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 框架 </th>
<th style="text-align:center;"> 开发者 </th>
<th style="text-align:center;"> 开发语言 </th>
<th style="text-align:center;"> UI开发库 </th>
<th style="text-align:center;"> 支持的端 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> ReactNative </td>
<td style="text-align:center;"> Meta </td>
<td style="text-align:center;"> JavaScript </td>
<td style="text-align:center;"> React </td>
<td style="text-align:center;"> Android, iOS, Web </td>
</tr>
<tr>
<td style="text-align:center;"> Flutter </td>
<td style="text-align:center;"> Google </td>
<td style="text-align:center;"> Dart </td>
<td style="text-align:center;"> </td>
<td style="text-align:center;"> Android, iOS, Desktop, Web </td>
</tr>
<tr>
<td style="text-align:center;"> CMP </td>
<td style="text-align:center;"> JetBrains </td>
<td style="text-align:center;"> Kotlin </td>
<td style="text-align:center;"> Jetpack Compose </td>
<td style="text-align:center;"> Android, iOS, Desktop, Web </td>
</tr>
</tbody>
</table>


<p>ReactNative和Flutter都相对较成熟和稳定了，使用者也较多，社区很活跃。ReactNative更适合移动端，而Flutter能跨的端和CMP要更多一些。此外，Flutter和CMP与其他框架最大的区别在于它使用Skia库构建了一个渲染引挚，可以直接把渲染树渲染成为平台支持的更为底层的canvas，直接接入native层的graphics API而不是映射成native组件，为此，它的渲染效率更为高效一些，进而性能更优一些，可以把它们想像成为一个浏览器。</p>

<p>技术栈也不一样，ReactNative是基于Node和JavaScript，属于前端技术栈，与前端融合更为紧密一些；而CMP是基于Kotlin和JVM与Android更为紧密一些，属于Java派系；而Flutter自成一派。</p>

<h2>选择是痛苦的</h2>

<p>实事求是的来说<a href="https://flutter.dev/">Flutter</a>是当前最为成熟 也最为完备的一个跨端框架，只不过可能学习成本略大，对于大部分同学来说Dart是一门小众的编程语言。而ReactNative最大的问题就在于React，它太前端化了，对于客户端同学来说写一坨HTML式的标签还是相当难受的。</p>

<p>应该说Flutter已经非常成功了，达到了它应该有高度，实现了它的价值，换句话说它的前景也不是特别明朗了，因为它已经很成熟了，所以有传言谷歌内部也在裁撤Flutter的研发资源。ReactNative也一样，这么多年了，版本还没有到1.0。</p>

<p><img src="https://blog.droidchef.dev/content/images/size/w1000/2022/11/Flutter-vs-Jetpack-Compose-Header--2-.png" alt="图1. Flutter vs CMP" /></p>

<p>而CMP刚刚兴起，使用起来非常的方便和简单，它的安装与配置是所有框架之中最为简便的（只需要安装一个Android Studio的插件，其余的都是编译插件和依赖，并不像Flutter和ReactNative都需要在开发机器上安装其他东西），前途无量，非常值得投入。并且Flutter对于谷歌来说九牛一毛，是非常不起眼的东西，谷歌毕竟家大业大，像谷歌和Meta等巨头现在都在狂卷AI，其他的小业务都不受重视。</p>

<p>但CMP不一样，JetBrains本身就是专门搞开发工具的，这是他们的主业肯定 会好好搞，把CMP与其IDE深度结合，对于开发者使用起来那就相当的方便了。事实上JetBrains已经开始弄了，它的最新的<a href="https://www.jetbrains.com/fleet/">IDE Fleet</a>（一个通用的IDE）将会深度绑定CMP，非常值得期待。</p>

<p>综合考虑，给出的建议就是如果是<strong>一个纯新的项目，特别是MVP阶段，不要犹豫就是用Flutter</strong>。而如果是<strong>现有项目，想要跨端，就选择CMP</strong>，它是对现有项目最为友好的一个。除非你是资源前端且是React粉，否则不要考虑ReactNative。</p>

<h2>框架只能解决一部分问题</h2>

<p>最后想说的是，对于跨端开发，框架只能解决一小部分问题。</p>

<p>跨端开发最难的地方在于合理的架构和团队的协同。架构需要做好层与层的隔离，特别是把与平台强相关的API做好隔离层，以最大限度 的共用代码，如果到处都是粗粒度的平台相关的实现，复杂度将急剧上升，那最后会变成多端的拼盘而非一个跨端项目。人员的协作应该以功能为单位来划分而不能再以端的维度，要彻底消灭端的思维，要以UI，功能和业务逻辑角度来思考问题，这样才能更好的协作。总之跨端对团队的要求更高，否则只会制造更多的问题。</p>

<p>人的问题永远要比技术问题要复杂一些，举个最简单的例子，以往每个端各自为政，Android端某个同学犯了错，顶多就是Android端不能用了，可能最多就3.25。真跨端了以后，再犯错那可就是所有端都搞挂了，可能最少是3.25起步，这里头的差别还是相当大的，如果没有强有力的大一点的老板来推，是很难推得动的。</p>

<p>研发同学都喜欢折腾，光完成业务是很无聊的，也不可能出成绩，都想方设法的搞出点「技术产出」（俗称造轮子）。记得ReactNative刚出来时，坊间很热情都在把其引入到各自的业务中去，但最终的结果是，没有人会真的在业务中重点使用，而是都花心思搞出了一套属于自己的跨端框架，并且向其他团队推广。年终汇报时，PPT很漂亮：「老板您看，我们不光完成了业务，还搞了一套跨端框架，它比ReactNative好在哪里，已经在我们的业务使用了，也给其他团队推广了」。相反，假如你真的使用了跨端，你咋 汇报？「老板，您看，我们用了别人的跨端技术，成功的实现了跨端，原来三个端15个人能做完的事情，现在只需要8个人！」。老板听了，很激动，3.25终于找到人选了，开猿节流也有着落了！</p>

<p>Anyway，总的来说跨端开发更适合业务不复杂，UI交互也不重的中小型App，或者那种UI占比较小非UI逻辑占比大的应用（最典型的就是浏览器），才能发挥出最大的价值。一个比较简单的判断标准就是，如果每个端的研发人员都超过10个人，可能就不太适合用跨平台的开发方式。</p>

<h2>References</h2>

<ul>
<li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/cross-platform-frameworks.html">The Six Most Popular Cross-Platform App Development Frameworks</a></li>
<li><a href="https://developers.google.com/j2objc">What J2ObjC is</a></li>
<li><a href="https://github.com/google/j2objc">A Java to iOS Objective-C translation tool and runtime.</a></li>
<li><a href="https://hackernoon.com/getting-started-with-react-native-for-windows-and-macos">Getting started with React Native for Windows &amp; macOS</a></li>
<li><a href="https://medium.com/@ankit-detroja/react-native-or-flutter-in-2024-7cfb0605698f">React native or Flutter in 2024</a></li>
<li><a href="https://leancode.co/blog/flutter-vs-react-native">Flutter vs. React Native: A Detailed Comparison for 2024</a></li>
<li><a href="https://nateshmbhat.medium.com/flutter-vs-react-native-performance-benchmarks-you-cant-miss-%EF%B8%8F-2e31905df9b4">Flutter Vs React Native : Performance Benchmarks you can’t miss ! 🔥⚡️ [Part -1]</a></li>
<li><a href="https://medium.com/newsoft-official/compose-multiplatform-vs-flutter-771673612c61">Compose Multiplatform VS. Flutter</a></li>
<li><a href="https://infinitelambda.com/flutter-kotlin-multiplatform-native-comparison/">FLUTTER VS KOTLIN MULTIPLATFORM VS NATIVE</a></li>
<li><a href="https://www.miquido.com/blog/kotlin-multiplatform-vs-flutter/">Flutter vs. Kotlin Multiplatform Mobile</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实战：把一个现有的Compose项目转化为CMP项目]]></title>
    <link href="https://alexhilton.github.io/blog/2024/12/09/migrate-existing-project-to-cmp/"/>
    <updated>2024-12-09T22:09:28+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/12/09/migrate-existing-project-to-cmp</id>
    <content type="html"><![CDATA[<p>通过<a href="https://juejin.cn/column/7367555191338467337">前面两篇文章</a>的学习，我们已经对CMP有了一定的了解，接下来要进入实战阶段。在现实的世界中极小数项目会从0开始，今天重点研究一下如何把一个现成的用Jetpack Compose开发的Android项目转成CMP项目。</p>

<p><a href="https://alexhilton.github.io/blog/2024/12/09/migrate-existing-project-to-cmp/"><img src="https://www.mouritech.com/wp-content/uploads/2024/01/Compose-Multiplatform.png" title="auto auto" ></a></p>

<!-- more -->


<h2>总体思路</h2>

<p>在前面的文章<a href="https://juejin.cn/post/7439251025385996307">Compose大前端从上车到起飞</a>里面我们学习到了，CMP对Android开发同学是相当友好的，CMP项目与Android项目在项目结构上面是非常相似的。并且因为CMP的开发IDE就是Android Studio，因此，可以直接把一个Android项目改造成为CMP项目，而不是创建一个全新的CMP项目之后把项目代码移动进去。</p>

<p>具体的步骤如下：</p>

<ol>
<li>添加CMP的插件，添加源码集合，配置CMP的依赖</li>
<li>把代码从「androidMain」移动到「commonMain」中去</li>
<li>把资源转换成为CMP方式</li>
<li>添加并适配其他平台</li>
</ol>


<p><strong>小贴士：</strong> 针对 不同的类型的任务需要采取 不同的策略，比如开发功能的时候使用「自上而下」的方式要更为好一些，因为先关注大粒度的组件，类与方法，不被细节拖住，更有利于我们看清架构和优先解决掉重点问题；但当做移植任务时，应该采用「自下而上」，因为依赖是一层套一层，先把下面的移好，上面的自然就会更加容易。</p>

<p>这里选用的项目是先前用纯Jetpack Compose开发的<a href="https://github.com/alexhilton/Aeolus">一款天气应用</a>，项目比较简单，依赖不多，完全是用Jetpack Compose实现的UI，也符合<a href="https://juejin.cn/post/7411812014047461387">现代应用开发架构原则</a>，非常适合当作案例。</p>

<p><strong>注意：</strong> 其实这里的项目并没有严格要求，只要是一个能运行的Android项目即可，其他的（是不是Jetpack Compose实现的，用的是不是Kotlin）并不是最关键的。因为CMP项目对于每个源码集合本身并没有明确的要求，前面的文章也讲了，每个平台的源码集合，其实就是其平台的完整的项目。移植的目的就是把 <strong>可共用共享</strong> 的代码从现有项目中抽出来放进「commonMain」中，即可以是原有的业务逻辑，也可以是新开发的代码。采用新技术或者新工具的一个非常重要的原则 就是要循序渐进，不搞一刀切。如果时间不充裕，完全可以新功能和新代码先用CMP方式开发，老代码暂且不动它，待日后慢慢再移植。当然了，纯Jetpack Compose实现的项目移植过程会相对容易一些。</p>

<p>下面我们进行详细的一步一步的实践。</p>

<h2>配置CMP的插件，源码集合和依赖</h2>

<p>首先要做的是配置Gradle构建插件（这是把Gradle常用的Tasks等打包成为一个构建 插件，是编译过程中使用的）：</p>

<ul>
<li>使用Kotlin Multiplatform（「org.jetbrains.kotlin.multiplatform」）替换Kotlin Android（「org.jetbrains.kotlin.android」），这个主要是Kotlin语言的东西，版本号就是Kotlin的版本号，注意要与其他（如KSP，如Coroutines）版本进行匹配；</li>
<li>添加Compose compiler（「org.jetbrains.kotlin.plugin.compose」）的插件，版本号要与Kotlin版本号保持一致；</li>
<li>以及添加Compose Multiplatform（org.jetbrains.compose」）插件，版本号是CMP的版本号。</li>
</ul>


<p>注意，构建插件配置是修改项目根目录的那个build.gradle.kts：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="c1">// Top-level build file where you can add configuration options common to all sub-projects/modules.</span>
</span><span class='line'><span class="n">plugins</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">id</span><span class="p">(</span><span class="s">&quot;com.android.application&quot;</span><span class="p">)</span> <span class="n">version</span> <span class="s">&quot;8.1.4&quot;</span> <span class="n">apply</span> <span class="k">false</span>
</span><span class='line'>    <span class="n">id</span><span class="p">(</span><span class="s">&quot;com.android.library&quot;</span><span class="p">)</span> <span class="n">version</span> <span class="s">&quot;8.1.4&quot;</span> <span class="n">apply</span> <span class="k">false</span>
</span><span class='line'>    <span class="n">id</span><span class="p">(</span><span class="s">&quot;org.jetbrains.kotlin.multiplatform&quot;</span><span class="p">)</span> <span class="n">version</span> <span class="s">&quot;2.0.21&quot;</span> <span class="n">apply</span> <span class="k">false</span>
</span><span class='line'>    <span class="n">id</span><span class="p">(</span><span class="s">&quot;com.google.devtools.ksp&quot;</span><span class="p">)</span> <span class="n">version</span> <span class="s">&quot;2.0.21-1.0.28&quot;</span> <span class="n">apply</span> <span class="k">false</span>
</span><span class='line'>    <span class="n">id</span><span class="p">(</span><span class="s">&quot;org.jetbrains.kotlin.plugin.compose&quot;</span><span class="p">)</span> <span class="n">version</span> <span class="s">&quot;2.0.21&quot;</span> <span class="n">apply</span> <span class="k">false</span>
</span><span class='line'>    <span class="n">id</span><span class="p">(</span><span class="s">&quot;org.jetbrains.compose&quot;</span><span class="p">)</span> <span class="n">version</span> <span class="s">&quot;1.7.0&quot;</span> <span class="n">apply</span> <span class="k">false</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>之后是修改module的build.gradle.kts，先是启用需要的插件，然后是添加kotlin相关的配置（即DSL kotlin {&hellip;}），在其中指定需要编译的目标，源码集合以及其依赖，具体的可以仿照着CMP的demo去照抄就好了。对于依赖，可以把其都从顶层DSL dependencies中移动到androidMain.dependencies里面，如果有无法移动的就先放在原来的位置，暂不动它，最终build.gradle.kts会是酱紫：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">plugins</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">id</span><span class="p">(</span><span class="s">&quot;com.android.application&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">id</span><span class="p">(</span><span class="s">&quot;com.google.devtools.ksp&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">id</span><span class="p">(</span><span class="s">&quot;org.jetbrains.kotlin.multiplatform&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">id</span><span class="p">(</span><span class="s">&quot;org.jetbrains.kotlin.plugin.compose&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">id</span><span class="p">(</span><span class="s">&quot;org.jetbrains.compose&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">kotlin</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">androidTarget</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">@OptIn</span><span class="p">(</span><span class="n">org</span><span class="p">.</span><span class="n">jetbrains</span><span class="p">.</span><span class="n">kotlin</span><span class="p">.</span><span class="n">gradle</span><span class="p">.</span><span class="n">ExperimentalKotlinGradlePluginApi</span><span class="o">::</span><span class="k">class</span><span class="p">)</span>
</span><span class='line'>        <span class="n">compilerOptions</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">jvmTarget</span><span class="p">.</span><span class="k">set</span><span class="p">(</span><span class="n">org</span><span class="p">.</span><span class="n">jetbrains</span><span class="p">.</span><span class="n">kotlin</span><span class="p">.</span><span class="n">gradle</span><span class="p">.</span><span class="n">dsl</span><span class="p">.</span><span class="n">JvmTarget</span><span class="p">.</span><span class="n">JVM_17</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">sourceSets</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">androidMain</span><span class="p">.</span><span class="n">dependencies</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// Jetpack</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;androidx.core:core-ktx:1.15.0&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;androidx.appcompat:appcompat:1.7.0&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;androidx.activity:activity-compose:1.9.3&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="k">val</span> <span class="py">lifecycleVersion</span> <span class="p">=</span> <span class="s">&quot;2.8.7&quot;</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;androidx.lifecycle:lifecycle-runtime-ktx:$lifecycleVersion&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;androidx.lifecycle:lifecycle-runtime-compose:$lifecycleVersion&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;androidx.lifecycle:lifecycle-viewmodel-compose:$lifecycleVersion&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="k">val</span> <span class="py">navVersion</span> <span class="p">=</span> <span class="s">&quot;2.8.4&quot;</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;androidx.navigation:navigation-runtime-ktx:$navVersion&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;androidx.navigation:navigation-compose:$navVersion&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;androidx.datastore:datastore-preferences:1.1.1&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// Google Play Services</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;com.google.android.gms:play-services-location:21.3.0&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// Compose</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="n">compose</span><span class="p">.</span><span class="n">preview</span><span class="p">)</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="n">project</span><span class="p">.</span><span class="n">dependencies</span><span class="p">.</span><span class="n">platform</span><span class="p">(</span><span class="s">&quot;androidx.compose:compose-bom:2024.02.00&quot;</span><span class="p">))</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;androidx.compose.ui:ui&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;androidx.compose.ui:ui-graphics&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;androidx.compose.ui:ui-tooling-preview&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;androidx.compose.material3:material3&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;androidx.compose.material:material&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// Network</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;com.google.code.gson:gson:2.10.1&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;com.squareup.retrofit2:converter-gson:2.9.0&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;com.squareup.okhttp3:logging-interceptor:4.12.0&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// Accompanist</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;com.google.accompanist:accompanist-permissions:0.32.0&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">commonMain</span><span class="p">.</span><span class="n">dependencies</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="n">compose</span><span class="p">.</span><span class="n">runtime</span><span class="p">)</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="n">compose</span><span class="p">.</span><span class="n">foundation</span><span class="p">)</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="n">compose</span><span class="p">.</span><span class="n">material</span><span class="p">)</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="n">compose</span><span class="p">.</span><span class="n">ui</span><span class="p">)</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="n">compose</span><span class="p">.</span><span class="n">components</span><span class="p">.</span><span class="n">resources</span><span class="p">)</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="n">compose</span><span class="p">.</span><span class="n">components</span><span class="p">.</span><span class="n">uiToolingPreview</span><span class="p">)</span>
</span><span class='line'>            <span class="k">val</span> <span class="py">lifecycleVersion</span> <span class="p">=</span> <span class="s">&quot;2.8.3&quot;</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;org.jetbrains.androidx.lifecycle:lifecycle-viewmodel:$lifecycleVersion&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;org.jetbrains.androidx.lifecycle:lifecycle-runtime-compose:$lifecycleVersion&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">android</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">dependencies</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后，把DSL android {&hellip;}中不支持的字段删除掉即可，如kotlinOptions，它用来指定Kotlin JVM target的，现改在DSL kotlin中的androidTarget()中指定了，但要注意Kotlin的JVM target要与android中的compileOptions的sourceCompatibility以及targetCompatibility版本保持一致，比如都是17或者都是11，否则会有编译错误。</p>

<p>需要特别注意的是DSL kotlin中的源码集合名字要与真实的目录一致，否则编译会出错。建议的方式就是依照CMP的demo那样在module中去创建androidMain和commonMain即可。另外，可以把module名字从「app」改为「composeApp」，然后把运行配置从「app」改为「androidApp」，这下就齐活儿了：</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/migrate-struct.png" alt="图1. 重命名后的项目结构" /></p>

<p>CMP的插件和依赖配置好了以后，运行「androidApp」应该就可以正常运行。因为仅是配置一些依赖，这仍是一个完整的Android应用，应该能够正常运行。这时第一步就做完了，虽然看起来貌似啥也没干，但这已经是一个CMP项目了，基础打好了，可以大步向前了。</p>

<p><strong>小贴士：</strong> 通过配置依赖可以发现，CMP的artifact依赖都是以org.jetbrans.*开头的，哪怕是对于Compose本身，纯Android上面Jetpack Compose的依赖是「&#8221;androidx.compose.ui:ui&#8221;」，而CMP中的则是「&#8221;org.jetbrains.compose.ui:ui&#8221;」。虽然都是Jetpack Compose，代码是兼容的，但技术上来讲是两个不同的实现。确切地说JetBrains的Compose是从谷歌的上面fork出来的一个分支，以让其更好的适用于CMP，但完全兼容，标准的Compose代码都是能正常跑的。</p>

<h2>把代码从「androidMain」移动到「commonMain」</h2>

<p>这是最关键的一步了，也是最难啃的硬骨头，具体的难度取决于项目中使用了多少「不兼容」的库和API。Compose和Jetpack中的绝大多数库都是支持的，可以在CMP中使用，可以无缝切换，这是JetBrains和Google共同努力的结果，谷歌现在对CMP/KMP的态度非常的积极，给与「第一优先支持（First class support）」。所以对于依赖于room，navigation，material和viewmodel的代码都可以直接移到common中。</p>

<p>也就是说对于data部分，model部分以及domain部分（即view models）都可以直接先移到common中，因为这些层，从架构角度来说都属于业务逻辑，都应该是平台独立的，它们的主要依赖应该是Jetpack以及三方的库，这些库大多也都可以直接跨平台。</p>

<p>当然，不可能这么顺利，因为或多或少会用到与平台强相关的API，比如最为常见的就是上下文对象（Context）以及像权限管理和硬件资源（如位置信息），这就需要用到平台定制机制（即expect/actual）来进行定制。</p>

<p>可能有同学会很奇怪，为啥UI层还不移动到common中，UI是用Compose写的啊，而Compose是可以直接在CMP上跑的啊。Compose写的UI确实可以直接跑，但UI必然会用到资源，必须 先把资源从android中移到common中，否则UI是跑不起来的。</p>

<h2>把资源转化成为CMP方式</h2>

<p>在前一篇文章<a href="https://juejin.cn/post/7439251025385996307">Compose大前端从上车到起飞</a>有讲过CMP用一个库resources来专门处理资源，规则与Android开发管理资源的方式很像，所以可以把UI用到的资源移动到common中的composeResources里面，就差不多了。</p>

<p>但需要特别注意，不要把全部的资源都从androidMain中移出，只需要把UI层用到的那部分资源移出即可。androidMain中至少要把Android强相关的资源留下，如应用的icon，应用的名字，以及一些关键的需要在manifest中使用的xml等。这是因为这些资源是需要在Android应用的配置文件AndroidManifest中使用的，所以必须还放在android源码集中。</p>

<p>资源文件移动好后，就可以把UI移动到common中了，最后一步就是使用CMP的资源类Res代替Android的资源类R即可。</p>

<p>到此，就完成了从Android项目到CMP项目的转变。</p>

<h2>添加并适配其他平台</h2>

<p>前面的工作做好后，再适配其他的平台就非常容易了，添加其他平台的target和入口（可以仿照CMP的demo），然后实现相关的expect接口即可。由此，一个大前端 项目就彻底大功告成了。</p>

<h2>总结</h2>

<p>CMP对项目结构中源码 集合 的限制 并不多，每个平台相关的sourceSet可以保持其原来的样子，这对现有项目是非常友好的，可以让现有的项目轻松的转成为CMP项目，这也是CMP最大的一个优势。</p>

<h2>References</h2>

<ul>
<li><a href="https://touchlab.co/compose-multiplatform-transition-guide">Jetpack Compose to Compose Multiplatform: Transition Guide</a></li>
<li><a href="https://stackoverflow.com/questions/71510247/how-to-convert-kotlin-project-to-kotlin-multiplatform-mobile-after-the-project-c">How to convert Kotlin project to Kotlin Multiplatform Mobile after the project completion?</a></li>
<li><a href="https://markonovakovic.medium.com/from-android-to-multiplatform-migrating-real-100-jetpack-compose-app-to-fully-multiplatform-app-2d65dc9e212e">From Android to Multiplatform: Migrating real 100% Jetpack Compose App to fully Multiplatform App. Intro</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compose大前端从上车到起飞]]></title>
    <link href="https://alexhilton.github.io/blog/2024/11/24/master-compose-multiplatform/"/>
    <updated>2024-11-24T08:45:46+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/11/24/master-compose-multiplatform</id>
    <content type="html"><![CDATA[<p>在前面的一篇文章<a href="https://juejin.cn/post/7436648335380496434">赶紧上车开启Compose大前端之路</a>中我们学习了CMP的基本概念以及如何创建一个CMP项目。今天将继续学习CMP，深入研究项目的配置方法，了解CMP的内部机制并总结一些CMP开发的最佳实践。</p>

<p><a href="https://alexhilton.github.io/blog/2024/11/24/master-compose-multiplatform/"><img src="https://repository-images.githubusercontent.com/293498508/6469be07-159b-49de-9ffe-56340d5dfd07" title="auto auto" ></a></p>

<!-- more -->


<h2>深入了解项目结构</h2>

<p>CMP的基础结构与一个标准的Android应用的项目结构基本一样，只不过主module名字变成了「composeApp」。项目根目录下的build.gradle.kts是整个项目的配置，主要是指定使用的插件；settings.gradle.kts指定项目的依赖仓库，以及项目包含哪些module；gradle/wrapper/libs.version.toml定义着依赖的版本信息。模块「composeApp」包含着源码集合（source sets）以及一个build.gradle.kts，这是描述这个模块如何构建的脚本。</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/project-view.png" alt="图1. 项目结构" /></p>

<p>对于Android开发同学来说，这样的项目结构非常熟悉，事实上如果把项目视图切换到「Android」，就会发现，这比起常规的Android项目，无非就是多了一些源码集合。</p>

<p>仔细看一下源码集合「androidMain」它就是一个标准的Android项目，里面有AndroidManifest文件，以及一个入口MainActivity，它会调用「commonMain」中定义的composable App()，由此就进入到了「commonMain」中。</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/android-entry.png" alt="图2. Android源码关系" /></p>

<p>虽然并不在源码集合中，iosApp子目录其实是一个标准的Xcode项目，里面全是Xcode项目的配置文件，可以用Xcode直接打开。它是iOS应用的入口，它的调用顺序是iOSApp，到ContentView，这两个是标准的iOS的代码，用的是Swift。然后会进入到「iosMain」中的MainConntroller，这里就到了Kotlin地界了，MainController，再进入到common中的composable App()，由此进入了「commonMain」中。</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/ios-entry.png" alt="图3. iOS源码关系" /></p>

<h2>依赖配置方法</h2>

<p>现代的软件不可能全都是从零开始，有很多现成的代码库可以使用，这就需要为项目配置依赖。CMP中依赖配置方法与常规的Android略不一样，视依赖的使用，以及依赖的平台依赖性，需要分别针对不同的源码集合配置。</p>

<p>需要注意的就是依赖的作用域，如果是在commonMain中配置的，那就会对所有的平台生效；如果是为androidMain配置的依赖，只能在Android中生效，以次类推。</p>

<h3>在源码集合中配置依赖</h3>

<p>最直接的方式就是针对每个源码集合配置其依赖：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">kotlin</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">sourceSets</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">commonMain</span><span class="p">.</span><span class="n">dependencies</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;com.example:my-library:1.0&quot;</span><span class="p">)</span> <span class="c1">// 所有平台共享的依赖</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>在顶层DSL dependencies中配置</h3>

<p>除了在源码集合处配置依赖，也可以在顶层DSL dependencies中配置，本质都是一样的，只不过是方式略有不同。具体的格式是<strong> &lt;源码集合&gt;&lt;具体的依赖&gt; </strong>，比如上面酱紫写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">dependencies</span> <span class="p">{</span>
</span><span class='line'>    <span class="s">&quot;commonMainImplementation&quot;</span><span class="p">(</span><span class="s">&quot;com.example:my-library:1.0&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这与像上面在源码集合commonMain中配置是一样的。在顶层配置依赖的好处在于这里可以配置一些源码集合中找不到的依赖，如testing等等。</p>

<h3>本地module如何相互依赖</h3>

<p>如果是本地的库（module），可以通过project方式引入，同样的如果是共享的库加在common里，如果是某个平台特有的，或者只想在某个平台使用就单独加到它上面：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">kotlin</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">sourceSets</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">commonMain</span><span class="p">.</span><span class="n">dependencies</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="n">project</span><span class="p">(</span><span class="s">&quot;:some-other-multiplatform-module&quot;</span><span class="p">))</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>如何共享和定制代码</h2>

<p>CMP的终极目的是要尽可能的共享代码，让一套代码能够跑在多个平台上面。但现实的世界是不完美的，平台的差异是不可忽视的。像存储，I/O，硬件资源等等都是平台强相关的。我们只能尽可能多的共享我们自己写的业务逻辑，对于实现业务逻辑而需要的系统平台相关的API，肯定还是需要每个平台定制化的去实现。</p>

<p>CMP通过Kotlin中的关键字expect和actual来处理平台定制API。</p>

<p>具体的做法就是在common中定义一个用关键字expect修饰的类型（函数，类，接口枚举，属性等），然后在每个平台的源码集合中去具体实现，并用关键字actual来修饰。注意，这里的类型没有限制，可以是函数，可以是类/接口/枚举，也可以是属性，尽管绝大多数情况下都是函数。</p>

<p><img src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/expect-functions-properties.svg" alt="图4. 用expect和actual来定制API" /></p>

<p>可以理解为OO中的接口，但又不完全一样。区别在于，common中的expect函数不能有默认实现代码，并且函数的声明要在同一个包下面。编译的时候，编译器会用平台代码里面的actual去替换common中的expect函数。也就是说这是发生在编译时的行为，所以它要求包名和函数的签名完全一致。</p>

<h2>资源管理</h2>

<p>CMP是能构建跨平台UI的，而UI必然会涉及资源，最常见的资源就是图片和字符串，资源的复杂地方在于它会有限定属性，比如不同屏幕分辨率要用不同的图片，比如不同的地区语言要用不同的字符串，所以资源是相当复杂的，而且平台强相关。</p>

<p>为此CMP提供了一个专门的库用于管理资源，可以屏蔽平台特定，以统一的方式来管理资源。只需要在commonMain中引入依赖即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">kotlin</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">sourceSets</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">commonMain</span><span class="p">.</span><span class="n">dependencies</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">implementation</span><span class="p">(</span><span class="n">compose</span><span class="p">.</span><span class="n">components</span><span class="p">.</span><span class="n">resources</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>资源是放在commonMain中与kotlin同级别的目录中：</p>

<p><img src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/compose-resources-qualifiers.png" alt="图5. 资源文件管理" /></p>

<p>资源可以分为几种类型，图片应该放在子目录drawable中，字体资源放在fonts中，字符串放在values中，其他文件放在files中。</p>

<p>资源文件还可以有限定符以支持定制化，如屏幕分辨率（xhdpi，xxhdpi等），区域语言（en，zh-rCN等）和主题（dark，light等）。可以发现，规则与Android平台资源管理规则是非常接近的。</p>

<p>图片字体等直接添加文件即可，字符串的话放在一个xml文件中，根Tag是resources，每个字符串的Tag是string，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="p">&lt;</span><span class="n">resources</span><span class="p">&gt;</span>
</span><span class='line'>    <span class="p">&lt;</span><span class="n">string</span> <span class="n">name</span><span class="p">=</span><span class="s">&quot;app_name&quot;</span><span class="p">&gt;</span><span class="n">My</span> <span class="n">awesome</span> <span class="n">app</span><span class="p">&lt;/</span><span class="n">string</span><span class="p">&gt;</span>
</span><span class='line'>    <span class="p">&lt;</span><span class="n">string</span> <span class="n">name</span><span class="p">=</span><span class="s">&quot;title&quot;</span><span class="p">&gt;</span><span class="n">Some</span> <span class="n">title</span><span class="p">&lt;/</span><span class="n">string</span><span class="p">&gt;</span>
</span><span class='line'><span class="p">&lt;/</span><span class="n">resources</span><span class="p">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意资源的命名，与Android的资源规则一样，要是小写字符，可以有数字和下划线。</p>

<p>添加好资源后，编译插件会自动生成一个类Res，通过它就可以引用各种资源，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">Image</span><span class="p">(</span>
</span><span class='line'>    <span class="n">painter</span> <span class="p">=</span> <span class="n">painterResource</span><span class="p">(</span><span class="n">Res</span><span class="p">.</span><span class="n">drawable</span><span class="p">.</span><span class="n">my_icon</span><span class="p">),</span>
</span><span class='line'>    <span class="n">contentDescription</span> <span class="p">=</span> <span class="k">null</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">Text</span><span class="p">(</span><span class="n">stringResource</span><span class="p">(</span><span class="n">Res</span><span class="p">.</span><span class="n">string</span><span class="p">.</span><span class="n">app_name</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<h2>一些开发实践建议</h2>

<p>CMP是为了构建跨平台应用的，那么应该尽最大的可能去共享代码。虽然有平台定制机制，但只应该用它来定制细粒度的具体的API，而不是业务逻辑。比如说，从一个文件中读文本内容，不应该定义一个getFileContent，而是应该定制细粒度的openFile，closeFile和readLine，这是因为读取文件过程真正不同的是处理文件的API，除打开文件，读出每一行以外，其他的逻辑是一样的，应该共享。</p>

<p>还有，在写业务的时候要注意看Compose文档中以及Kotlin文档中API标注的平台范围，尽可能选择标记为「Common」或者「Cmn」的API。</p>

<p>另外，因为Kotlin是基于JVM的语言，标准JDK中的API都可以用，但在CMP的iOS（目标是Native）平台和Web（目标是Wasm）却无法使用JDK的API，所以我们应该多使用Kotlin标准库以及Kotlin扩展库（kotlinx），这些API都做了多平台适配。</p>

<h2>总结</h2>

<p>利益于Gradle中的源码集合，CMP对源码的结构是很宽容的，并没有严格的要求，这对于现有项目来说是相当友好的，因为把现有的项目源码搬进来就可以了，不用改太多，然后通过源码集合来做具体的指定和逻辑上的关系处理。每个源码集合其实都是其平台的一个标准项目，把common作为其依赖而已，关系就这么简单，甚至还可以用其平台的原生方式去写UI，写逻辑，这都是可以的。</p>

<p>虽然这样做貌似会失去共享代码和逻辑的意义，但是这对改造现有项目是十分友好的，比如第一步可能是把Android项目和iOS项目先融合进来，然后再慢慢的把两个平台的共享代码抽离出来入进common。这样做不但能慢慢推进跨端，每个项目各自仍是完整的，如果有紧急 的事情仍可先用原生方式去开发构建。</p>

<h2>References</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/multiplatform-add-dependencies.html">Adding dependencies on multiplatform libraries</a></li>
<li><a href="https://kotlinlang.org/docs/gradle-configure-project.html#configure-dependencies">Configure dependencies</a></li>
<li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-connect-to-apis.html">Use platform-specific APIs</a></li>
<li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-multiplatform-resources.html">Resources overview</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[赶紧上车开启Compose大前端之路]]></title>
    <link href="https://alexhilton.github.io/blog/2024/11/17/compose-multiplatform-made-easy/"/>
    <updated>2024-11-17T20:33:51+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/11/17/compose-multiplatform-made-easy</id>
    <content type="html"><![CDATA[<p>在<a href="https://juejin.cn/column/7367555191338467337">前面的文章中</a>，我们一再强调Jetpack Compose是一个声明式的UI框架，尽管我们都是基于Android开发来实战的，但Compose并不局限于Android开发，它其实与特定的开发平台没有关系，是可以做到跨平台开发的。事实上JetBrains早就已经准备好了一套工具，以让Compose跨平台，开发多端应用，跻身于大前端的一员。今天就来学习一下如何使用Compose进行大前端开发。</p>

<p><a href="https://alexhilton.github.io/blog/2024/11/17/compose-multiplatform-made-easy/"><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/j9tap6mygsqvxh6aauc8.png" title="auto auto" ></a></p>

<!-- more -->


<h2>缘起</h2>

<p>时光荏苒，白云苍狗，自乔帮主发布iPhone开启移动互网联至今已有十余载。对于互联网应用来说，早已从最初的Android加iOS两端并行，发展到现在的大前端时代。时至今日，不论大厂小厂，多端拉齐（Web，Android, iOS, Desktop，鸿蒙）已经是一个标配和强需求。那么如何减少多端的重复开发，如何跨多端开发就成了一个永不过时的研究方向。从最初的Mobile H5，到Hybrid App，再到React Native，再到后来的Flutter，大前端已经得到了长足的发展。得益于Kotlin Multiplatform（KMP），Compose也有了跨端的能力，跻身于大前端工具之列。</p>

<p>在深入主题学习之前，我们先来理解一下重要的概念。</p>

<h2>概念理解</h2>

<p>为了避免混淆和加强理解，需要对一些概念进行澄清。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 概念 </th>
<th style="text-align:left;"> 缩写 </th>
<th style="text-align:left;"> 说明 </th>
<th style="text-align:left;"> 开发者 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> Jetpack Compose </td>
<td style="text-align:left;"> Compose </td>
<td style="text-align:left;"> 基于Kotlin语言的声明式UI开发框架，与平台无关，源于以及主要用于Android开发 </td>
<td style="text-align:left;"> Google </td>
</tr>
<tr>
<td style="text-align:left;"> Compose Multiplatform </td>
<td style="text-align:left;"> CMP </td>
<td style="text-align:left;"> 用于把Compose转化为多端的一个框架 </td>
<td style="text-align:left;"> JetBrains </td>
</tr>
<tr>
<td style="text-align:left;"> Kotlin Multiplatform </td>
<td style="text-align:left;"> KMP </td>
<td style="text-align:left;"> 把Kotlin编译为多端的框架，这是Compose能跨平台的根基 </td>
<td style="text-align:left;"> JetBrains </td>
</tr>
</tbody>
</table>


<p>为了简便，在后文以及以后的文章中将使用缩写。虽然严格来说CMP专指把Compose转化为多端的UI框架，但大部分场合也用它来代指Compose跨端开发，后面也会这样用。</p>

<p><strong>注意：</strong> 在早些时候，也就是在JetBrains刚推出KMP的时候，仅针对和支持Android和iOS两个平台，所以当时就叫做Kotlin Multiplatform Mobile，缩写为KMM，后来也能编译出桌面（Desktop）和Web端了，就把Mobile去掉了，就是现在的KMP，代表Kotlin Multiplatform。所以，如果 在其他地方看到了KMM，把它当成KMP就可以了。</p>

<h2>Compose大前端技术栈</h2>

<p>在继续深入之前，捋捋技术栈，从大的角度来了解一下用到的技术工具的关系是很有必要的。</p>

<p>仍是用Jetpack Compose来写UI，用Kotlin来写业务逻辑，这是个是没有变的。而Compose Multiplatform（CMP）相当于是一个转换工具，能把Compose写的UI转变成为不同平台的UI实现。编程语言用的是都是Kotlin，最终要依赖KMM编译出具体平台的目标文件（Target）。所以，它们三个是依赖关系Compose依赖CMP，它们又都依赖KMM。</p>

<p>最先出现的当然是编程语言Kotlin，之后Google推出了声明式UI框架Jetpack Compose，采用了Kotlin语言。随着Kotlin的发展，JetBrains推出了KMP，让Kotlin实现跨多端，在这之后又基于Compose，推出了CMP，因为都是Kotlin语言，与KMP一起凑成了Compose/Kotlin的跨端。现在谷歌也与JetBrains紧密的合作，一起努力把Compose往前推进，去挑战React Native和Flutter。</p>

<p>学习成本并不高，因为对于开发者来说仍旧是Compose和Kotlin，CMP和KMP是透明的，它们以插件和依赖库的形式存在，没有额外的学习成本。当然，这对Android开发同学来说更为友好一些，因为大部分Android开发同学早已掌握了Compose和Kotlin。</p>

<h2>开发环境搭建</h2>

<p>CMP的技术栈并不复杂，如果已具备Android开发环境，那基本上就齐活儿了，这再次说明CMP对Android开发同学是相当友好的。开发用的IDE就是Android Studio，编译工具用的是Gradle，这对Android同学来说已经是标配了，不熟悉的同学可自行Google。</p>

<p>唯一需要安装的就是KMP的插件（plugin），也即Android Studio中，到插件市场搜索Kotlin Multiplatform，这是JetBrains官方提供的插件，找到后可放心安装，之后重启AS即可。</p>

<p>以上是通用开发配置，但如果目标平台是iOS就略麻烦一些。此小节后面的内容，仅当目标平台包含iOS时需要，否则可以跳过。</p>

<p><strong>注意：</strong> Mac虽然也是水果系统，但Mac属于桌面端（Desktop），如果为Mac构建应用要选择Desktop为目标平台。</p>

<p>因为水果的生态是封闭的，要想构建iOS就必须要用Xcode，而Xcode只在Mac上面才能用，所以要想构建iOS端应用，必须要用Mac来开发，而且要是新一点的Mac（三年以内）。然后安装最新的Xcode就差不多了，官方提供了一个Mac上为iOS环境的检查工具kdoctor（用brew install kdoctor来安装），但其实如果配置了Android开发环境后，再装上Xcode就够了。</p>

<p><strong>注意：</strong> 如果是比较旧的Mac，Big Sur以前的，就不用再折腾了，无法构建iOS，因为构建iOS需要Xcode 12.5，而<a href="https://developer.apple.com/support/xcode/">Xcode 12.5又至少需要macOS 11.7（即Big Sur）</a>。环境检查工具kdoctor本身也是要求Xcode 12.5以上，建议在安装之前可以先用brew info kdoctor来检查一下。水果就这点不好，硬件和软件更新都特别快，向后兼容又不友好，最多支持三个版本（时间跨度在3年左右）。</p>

<h2>创建一个多端应用</h2>

<p>环境配置好后，就可以开始创建CMP了，官方提供了一个<a href="https://kmp.jetbrains.com/?_gl=1*271nsz*_gcl_au*MTE5MzE4NTY0NS4xNzMxMzIzNDU3*_ga*MzUyNjc2MzcuMTU5NDM3NDQ0MA..*_ga_9J976DJZ68*MTczMTQwMDc1MC4xOC4wLjE3MzE0MDA3NTAuNjAuMC4w">KMP项目创建向导</a>可以方便的生成一个项目模板。需要注意的是就是，如果要构建iOS，一定要勾选『Share UI』。</p>

<p><strong>注意：</strong> 要想构建iOS目标需要较新的Mac才可以，如果开发环境不是Mac，或者Mac较旧，就不用钩选iOS了，因为选了也无法构建出来和运行目标产物。</p>

<p><img src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/multiplatform-web-wizard.png" alt="图1. CMP项目创建向导" /></p>

<p>在创建向导中配置好后，点击下载就可以了。解压之后，用Android Studio打开（File | Open）项目文件，就可以开始CMP的开发了。注意，要直接打开解压出来的根目录，而不是里面的某个子目录。因为AS打开的项目默认使用专为Android开发优化后的视图结构「Android」，为了更方便需要切换为「Project」。</p>

<p>可以看一眼项目结构，与常规的Android项目相比差不多，包含了两个模块（module）：</p>

<ul>
<li>composeApp 这是最主要的模块，可以说东西都在这里面。它是一个Kotlin模块（Kotlin module），包含了多端共用代码，以及不同平台的定制代码。使用Gradle来构建，用Gradle的脚本来描述构建方式。</li>
<li>iosApp 这是一个完整的Xcode项目，主要用于构建iOS目标，它会依赖于composeApp。</li>
</ul>


<p><strong>注意：</strong> 如果在<a href="https://kmp.jetbrains.com/?_gl=1*zmaxre*_gcl_au*NDM5ODU1NDAyLjE3Mjc1OTk1MDU.*_ga*MzEyMDU2NTg5LjE2NzQwMDg5NjM.*_ga_9J976DJZ68*MTczMTQwMTE0NC45NC4xLjE3MzE0MDExNDguNTYuMC4w">项目创建向导</a>中没有钩选iOS，将不会有模块iosApp，以及composeApp中的iosMain。</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/cmp-structure.png" alt="图2. 项目结构" /></p>

<p>重点需要关注<strong>composeApp</strong>，它包含了几个源码集合（source sets）：</p>

<ul>
<li>commonMain 这是最主要的集合，包含共享代码，由一个composable函数作为入口开始（如App()）开始。这里应该是项目的主要代码集合。</li>
<li>androidMain 包含与Android平台相关的代码，包括入口（如Android manifest和Activity），入口会调用commonMain中的入口composable。以及提供平台特定的定制化实现。</li>
<li>desktopMain 桌面端的入口，以及定制化实现。</li>
<li>iosMain 水果移动端的入口，以及定制化实现。</li>
<li>wasmJsMain Web端的入口，以及定制化实现。</li>
</ul>


<p><strong>注意：</strong> 源码集的具体数量取决于创建项目时钩选的目标平台。</p>

<p>源码集合（source set）构建工具Gradle的一个概念，它包含逻辑上相关的一坨源码文件，资源文件，以及其依赖，对于Android开发同学来说这个概念并不陌生。</p>

<p><img src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/module-structure.png" alt="图3. 项目源码集合关系" /></p>

<p>这种项目源码集合关系是由KMP定义的，编译构建的时候common部分会编译成为一个依赖组件，平台部分把common当成一个依赖使用，然后最终构建出目标产物，详细的过程可以<a href="https://kotlinlang.org/docs/multiplatform-discover-project.html">看KMP的文档</a>。</p>

<p>这个模板有默认的页面，可以看一下，打开文件commonMain中的App.kt，它包含一个composable函数App()，这就是CMP的入口，可以从这里开始用Compose写应用了。</p>

<h2>构建与运行</h2>

<p>项目创建向导创建出来的模板项目，包含了基本的页面，可以直接构建和运行。</p>

<p><strong>注意：</strong> 首次打开项目会比较慢，这是因为要下载Gradle工具链以及项目的依赖，视网络情况，可能需要几分钟到十几分钟不等，之后就能秒开。</p>

<p><strong>注意：</strong> 创建出来的项目依赖用的都比较新，比如像Android开发插件AGP可能会用8.5.2，但AGP的版本受制于Android Studio，<a href="https://developer.android.com/build/releases/gradle-plugin#android_gradle_plugin_and_android_studio_compatibility">AGP与AS的兼容对应关系可以看这里</a>。如果使用的AS版本较旧，需要调整AGP的版本。</p>

<p>待Gradle sync完成之后，就可以运行了。</p>

<h3>运行Android app</h3>

<p>对于Android app来说可以直接运行，在运行配置那里选择「composeApp」，连上手机（或者模拟器），运行就可以了。</p>

<p><img src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/compose-run-android.png" alt="图4. 运行Android app" /></p>

<h3>运行桌面端（Desktop）App</h3>

<p>桌面端没有默认运行配置，需要创建一个。在菜单中编辑运行配置（Run | Edit Configurations），点左上的加号，选择「Gradle」，输入个名字如「desktopRun」，然后在配置那一侧中的「Tasks and arguments」输入：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Bash'><span class='line'>composeApp:run
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/compose-run-desktop-temp.png" alt="图5. 运行桌面端App" />
之后，选择「desktopRun」运行即可。</p>

<h3>运行iOS app</h3>

<p>如果选择了iOS的话，也有默认运行配置，可直接运行。但水果的东西必须依赖于水果的工具，所以要先打开Xcode，打开就行，放在一边不用做啥。然后回到AS，选择「iosApp」，运行，如果顺利，在Xcode那头就会启动iOS的模拟器，并运行App了。</p>

<p><img src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/compose-run-ios.png" alt="图6. 运行iOS app" /></p>

<p><strong>注意：</strong> 要想运行iOS，Xcode版本必须要在12.5以上，因为iOS构建方式是基于Xcode 12.5的。</p>

<h2>运行Web app</h2>

<p>Web端也没有默认配置，需要像桌面端那样创建一个，同样是Gradle，区别在于命令不一样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Bash'><span class='line'>wasmJsBrowserRun -t --quiet
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/compose-run-web.png" alt="图7. 运行Web app" />
然后，运行，这会开启一个本地server，如果浏览器没有自动打开的话，就手动打开浏览器，并输入「localhost:8080」，就能看到。</p>

<p><strong>注意：</strong> 如果开发平台是Mac，运行Web app时会有编译错误：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Bash'><span class='line'>Continuous build does not work when file system watching is disabled
</span></code></pre></td></tr></table></div></figure>


<p>可以通过修改构建指令参数，添加&#45;&#45;watch&#45;fs来解决：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Bash'><span class='line'>wasmJsBrowserRun -t --quiet --watch-fs
</span></code></pre></td></tr></table></div></figure>


<p>或者添加Gradle选项，以对所有的构建配置命令都生效：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Bash'><span class='line'>org.gradle.vfs.watch<span class="o">=</span><span class="nb">true</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是，无论是&#45;&#45;watch&#45;fs，还是Gradle选项，对于macOS 12（Monterey）以后才生效，详见<a href="https://docs.gradle.org/current/userguide/file_system_watching.html">Gradle文档</a>。</p>

<p>到此，应该说CMP的开发已经完全就位了。</p>

<h2>总结</h2>

<p>CMP配置简单，上手较快，前景光明，相信通过本文的学习可以了解并完全上车CMP开发了，还等啥呢赶紧上手撸一撸吧！</p>

<h2>References</h2>

<ul>
<li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/get-started.html">Get started with Kotlin Multiplatform</a></li>
<li><a href="https://kotlinlang.org/docs/multiplatform-intro.html">Introduction to Kotlin Multiplatform</a></li>
<li><a href="https://getstream.io/blog/build-app-kotlin-multiplatform/">Build Your First Android and iOS Mobile App With Kotlin Multiplatform</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用Compose中的CompositionLocal来暗渡陈仓]]></title>
    <link href="https://alexhilton.github.io/blog/2024/11/10/understanding-composition-local/"/>
    <updated>2024-11-10T23:17:56+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/11/10/understanding-composition-local</id>
    <content type="html"><![CDATA[<p>通过<a href="https://juejin.cn/column/7367555191338467337">前面的学习</a>我们知道Jetpack Compose是一个声明式的UI框架，采用的是函数式编程思想，直观上来看就是一坨函数从上调到下。当函数需要数据时，会通过函数调用的参数来传递，一般来说这也没有什么问题。但当需要的数据特别多时，特别是对于一些非业务逻辑本身的数据（输入与输出），如上下文环境变量（Context，或者主题之类），都通过函数调用的参数传递就难免会让代码变得非常的庞杂和臃肿。这时候就可以使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/CompositionLocal">CompositionLocal</a>，一种在组合树中隐式的从上到下传递数据的方法，我们来具体地看一下。</p>

<p><a href="https://alexhilton.github.io/blog/2024/11/10/understanding-composition-local/"><img src="file:///Users/alexhilton/Downloads/compose_libs/compositionlocal.png" title="auto auto" ></a></p>

<!-- more -->


<p><strong>注意：</strong> Compose中的函数通常叫做composable，可以简单的理解为同一个东西。从根composable开始，一个套一个的调用，自上而下的意思就是指composable的调用顺序，根函数在上，被调用的函数在下。函数调用是可以传递参数的，正常的从上到下的数据传递都是通过函数调用时的参数。</p>

<p>废话不多说，我们先来看一下什么是CompositionLocal以及它能做什么事情。</p>

<h2>什么是CompositionLocal</h2>

<p>CompositionLocal提供一种<strong>自上而下</strong>的数据传递方式，<strong>隐式的传递</strong>，也就是说，不用把数据放在参数里传递给子函数，子函数像在类中的方法访问域变量那样直接访问。我们来看一个粟子。</p>

<p>比如说，页面中有一个文案，可能需要定制字体颜色，常规方式是这样子写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">MyApp</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">colors</span> <span class="p">=</span> <span class="n">colors</span><span class="p">()</span>
</span><span class='line'>    <span class="n">SomeTextLabel</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">colors</span><span class="p">.</span><span class="n">onPrimary</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">SomeTextLabel</span><span class="p">(</span><span class="n">labelText</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">color</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>        <span class="n">text</span> <span class="p">=</span> <span class="n">labelText</span><span class="p">,</span>
</span><span class='line'>        <span class="n">color</span> <span class="p">=</span> <span class="n">color</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>文案的颜色，以及像背景等等这些东西是与整个App的配置相关的，或者与运行环境（如手机）的主题风格有关的，它并不是应用程序的业务逻辑。它属于上下文环境变量，其变化往往是由于运行环境变化而变化，或者是由于用户更改了应用的配置。这就非常适合使用CompositionLocal来转化为隐式数据传递，进而简化代码，使用后就变成酱婶儿的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">MyApp</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 在上级函数中定义主题相关的颜色，并定义为CompositionLocal</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">colors</span> <span class="p">=</span> <span class="n">staticCompositionLocalOf</span><span class="p">(</span> <span class="n">colors</span><span class="p">()</span> <span class="p">)</span>
</span><span class='line'>    <span class="n">CompositionLocalProvider</span><span class="p">(</span><span class="n">LocalColors</span> <span class="n">provides</span> <span class="n">colors</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">SomeTextLabel</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 被调用的子函数</span>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">SomeTextLabel</span><span class="p">(</span><span class="n">labelText</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>        <span class="n">text</span> <span class="p">=</span> <span class="n">labelText</span><span class="p">,</span>
</span><span class='line'>        <span class="n">color</span> <span class="p">=</span> <span class="n">LocalColors</span><span class="p">.</span><span class="n">onPrimary</span> <span class="c1">// 可以直接访问定义好的颜色</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过这个示例可以看出，定义了CompositionLocal以后，在被调用到的所有子函数中（desendants）都可以直接使用，就像访问全局变量那样。这就是CompositionLocal的作用，在指定的作用域中提供隐式的数据。</p>

<h2>如何使用CompositionLocal</h2>

<p>使用起来非常的方便，就像在类的方法中使用域变量那样，或者像使用全局变量那样，找到上级所定义的的CompositionLocal实例，然后引用其中的变量即可。</p>

<p>其实，已经在不知不觉中经常地使用了CompositionLocal，主题风格相关的<a href="https://developer.android.com/reference/kotlin/androidx/compose/material3/MaterialTheme">MaterialTheme</a>，Android的上下文<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/package-summary#LocalContext(">LocalContext</a>)以及像绘制时常用的<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/package-summary#LocalDensity(">LocalDensity</a>)，这些都是CompositionLocal实例，是由Compose定义好的顶层实例，在所有的composables中都可以直接使用。</p>

<p>需要理解的是CompositionLocal实例，本身并不是一个数据，它更像是一个集装箱，它本身是一个数据传递的机制，会在后面定义CompositionLocal实例时详细讲解。</p>

<p>另外，需要特别注意的是CompositionLocal是有作用域的，对其所有的子函数生效，并且也可以嵌套的，<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/CompositionLocal#current(">属性current</a>)引用的是最近一层父函数（closest ancestor）中绑定的值。比如说：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">CompositionLocalExample</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">MaterialTheme</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 绑定一个值到LocalContentColor</span>
</span><span class='line'>        <span class="n">CompositionLocalProvider</span><span class="p">(</span><span class="n">LocalContentColor</span> <span class="n">provides</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">colorScheme</span><span class="p">.</span><span class="n">primary</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">Surface</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">Column</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">Text</span><span class="p">(</span><span class="s">&quot;Uses Surface&#39;s provided content color&quot;</span><span class="p">)</span>
</span><span class='line'>                    <span class="c1">// 重新绑定一个值到LocalContentColor</span>
</span><span class='line'>                    <span class="n">CompositionLocalProvider</span><span class="p">(</span><span class="n">LocalContentColor</span> <span class="n">provides</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">colorScheme</span><span class="p">.</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                        <span class="n">DescendantExample</span><span class="p">()</span>
</span><span class='line'>                    <span class="p">}</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">DescendantExample</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// current会指向最后绑定的值，即MaterialTheme.colorScheme.error</span>
</span><span class='line'>    <span class="n">Text</span><span class="p">(</span><span class="n">text</span> <span class="p">=</span> <span class="s">&quot;This Text uses the error color now&quot;</span><span class="p">,</span> <span class="n">color</span> <span class="p">=</span> <span class="n">LocalContentColor</span><span class="p">.</span><span class="n">current</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>如何定义一个CompositionLocal</h2>

<p>大部分时候Compose中定义好的就够我们用了，但也可以针对具体的场景来自定义一个CompositionLocal。分为两个步骤，创建实例，和绑定数据。</p>

<p>CompositionLocal实例是一个集装箱，用以封装需要从顶层往底层传递的数据，这些数据也不一定非要是常量，也是会改变的，比如应用或者页面上下文环境变化时，或者整个应用的配置发生变化时。</p>

<h3>创建CompositionLocal实例</h3>

<p>第一步是先创建一个实例，有两种方法创建一个CompositionLocal实例，这两种方式的主要区别就在于当数据变化时如何影响着重组（reComposition）：</p>

<ul>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#compositionLocalOf(androidx.compose.runtime.SnapshotMutationPolicy,kotlin.Function0">compositionLocalOf</a>) 当数据发生变化时仅会影响读取数据函数的重组；</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#staticCompositionLocalOf(kotlin.Function0">staticCompositionLocalOf</a>) 当数组变化时，提供数据的所有子函数都会被重组。</li>
</ul>


<p>可以发现，这两个方法的区别就在于影响重组的范围，前一个是影响着读取数据的地方，这与状态（State）一样；后一个则是影响着所有的被调用的composables。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="c1">// LocalElevations.kt file</span>
</span><span class='line'>
</span><span class='line'><span class="n">data</span> <span class="k">class</span> <span class="nc">Elevations</span><span class="p">(</span><span class="k">val</span> <span class="py">card</span><span class="p">:</span> <span class="n">Dp</span> <span class="p">=</span> <span class="m">0.</span><span class="n">dp</span><span class="p">,</span> <span class="k">val</span> <span class="py">default</span><span class="p">:</span> <span class="n">Dp</span> <span class="p">=</span> <span class="m">0.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 使用Elevations的默认值构造一个全局的CompositinLocal实例</span>
</span><span class='line'><span class="c1">// 这个实例可以被应用中的所有composables访问得到</span>
</span><span class='line'><span class="k">val</span> <span class="py">LocalElevations</span> <span class="p">=</span> <span class="n">compositionLocalOf</span> <span class="p">{</span> <span class="n">Elevations</span><span class="p">()</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>注意：</strong> 为了更好的可读性和可维护性，CompositionLocal实例的命名应该以Local开头，如LocalColors。</p>

<h3>把数据绑定到实例中去</h3>

<p>光创建实例没什么用，创建完实例后，还需要把数组绑定到CompositionLocal实例中去，并<strong>同时指定作用域</strong>，这是非常关键的一步，不但决定了CompositionLocal中有什么数据，还决定了谁可以使用这些数据。使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#CompositionLocalProvider(kotlin.Array,kotlin.Function0">CompositionLocalProvider</a>)来绑定数据：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="c1">// MyActivity.kt file</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">MyActivity</span> <span class="p">:</span> <span class="n">ComponentActivity</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="n">Bundle</span><span class="p">?)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">super</span><span class="p">.</span><span class="n">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">setContent</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// 基于系统主题来计算具体的elevation</span>
</span><span class='line'>            <span class="k">val</span> <span class="py">elevations</span> <span class="p">=</span> <span class="k">if</span> <span class="p">(</span><span class="n">isSystemInDarkTheme</span><span class="p">())</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">Elevations</span><span class="p">(</span><span class="n">card</span> <span class="p">=</span> <span class="m">1.</span><span class="n">dp</span><span class="p">,</span> <span class="n">default</span> <span class="p">=</span> <span class="m">1.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">Elevations</span><span class="p">(</span><span class="n">card</span> <span class="p">=</span> <span class="m">0.</span><span class="n">dp</span><span class="p">,</span> <span class="n">default</span> <span class="p">=</span> <span class="m">0.</span><span class="n">dp</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="c1">// 把上面计算得到的elevation绑定到LocalElevations</span>
</span><span class='line'>            <span class="n">CompositionLocalProvider</span><span class="p">(</span><span class="n">LocalElevations</span> <span class="n">provides</span> <span class="n">elevations</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">// ... Content goes here ...</span>
</span><span class='line'>                <span class="c1">// 这里的子composables都可以直接访问LocalElevations.current</span>
</span><span class='line'>                <span class="c1">// 以得到elevation</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>函数CompositionLocalProvider接收一个CompositionLocal实例和一个composable lambda，这个lambda就是这个实例的作用域，也即此lambda所调用的所有composables都可以使用访问此实例的数据。参数LocalElevations就是实例，可以看前面的创建代码。LocalElevations provides elevation这是infix符号式写法，相当于LocalElevations.provides(elevation)，elevation则是具体的数据，这意思就是在此lambda的作用域中，CompositionLocal实例LocalElevations会提供数据elevation。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">SomeComposable</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 使用的地方直接通过LocalElevations.current就能访问到</span>
</span><span class='line'>    <span class="n">MyCard</span><span class="p">(</span><span class="n">elevation</span> <span class="p">=</span> <span class="n">LocalElevations</span><span class="p">.</span><span class="n">current</span><span class="p">.</span><span class="n">card</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// Content</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里多说一下，compositionLocalOf是更为精细化的控制（fine-grained control），因为，当数据发生变化时，在作用域中只有读取了数据的composables才会被重组；而staticCompositionLocalOf影响范围较大，因为（当数据发生变化 时）整个作用域内（即CompositionLocalProvider的lambda）的composables都会被重组。</p>

<h2>什么时候该用CompositionLocal</h2>

<p>CompositionLocal提供了一种新的数据传递方式，当数据需要在一定作用域内（Scoped）分享时，就可以考虑使用它。但并不是所有的场景都适用，具体来说，要符合以下标准：</p>

<ul>
<li>数据要是非业务逻辑数据，也就是非代码所直接需要的输入和输出。</li>
<li>数据要有一个极其合理的初始值（默认值）。</li>
<li>数据不一定要是常量，也可以变化，但是业务逻辑并不是数据变化的原因。</li>
<li>数据的使用有一定的作用域。并且在作用域内<strong>所有的composables都可能会</strong>使用此数据。这一点很重要，如果仅仅是某个特定的composable使用，那就直接传参就好了。</li>
</ul>


<p>适合使用CompositionLocal的数据有应用的主题风格，应用的配置信息，平台提供的上下文变量，平台的配置信息，或者对于一个局部来说是上下文变量的数据（比如说一个Dialog用到的数据）。除此之外，绝大部分时候不应该使用CompositionLocal。特别是涉及业务逻辑代码本身强相关的数据（输入与输出），一定不能使用CompositionLocal，这会让代码极难理解和维护，造成极难调试的Bug。</p>

<p>CompositionLocal的一个大的特点就是有明确的作用域，那么如何选择合适的作用域呢？总的来说应该让作用域越小越好。视数据的 影响范围和使用范围来决定其作用域：</p>

<ul>
<li>整个应用级别的（App level），如主题风格，应用配置，平台的配置信息，或者会话数据（user sessions）。应该在根composable，即setContent处绑定数据。</li>
<li>整个页面级别的（Screen level），如平台上下文变量（Context或者Density），导航，或者页面内部的定制参数。</li>
<li>组件级别的（Component level），页面中某一个局部，比如Dialog的主题风格，或者Dialog并不直接操作，但却依赖的数据。</li>
</ul>


<p>任何工具都是为了适合其的场景而生的，要了解清楚什么场景适合使用非常重要，切忌滥用。</p>

<h2>它与状态（State）的区别是什么</h2>

<p>从前面的文章<a href="https://juejin.cn/post/7376094685495001139">降Compose十八掌之『鸿渐于陆』| State</a>我们了解到，状态（State）是为了重组时数据不丢失，也就是说在composable多次运行时，数据能够得以留存。反过来状态变化了，也会触发重组，因为要刷新UI。状态是时间上的概念（使用此状态的composables）多次运行，状态持有的数据都得以保存，不会变成初始值。如果想要使用状态，必须当作参数传递过去。</p>

<p>而CompositionLocal是为了能在不同的composables中共享数据，不用参数传递，它是空间上的概念。</p>

<p>它们是为了解决不同的问题而设计出来的。可以把状态绑定到CompositionLocal中去，但其实没必要这么做，因为内部实现上已经会把绑定的数据封装为状态，因为CompositionLocal的数据是可能发生变化的，并且当变化时，也是要触发重组的。</p>

<h2>它与全局变量的区别是什么</h2>

<p>Kotlin语言是支持顶级全局变量（Top level globals）的，也就是与class平齐，在任何class之外的全局变量，其作用域是整个进程，任何导入（import）此变量的地方都可以访问。Compose是基于Kotlin语言的，所以Compose也是可以使用全局变量的。</p>

<p>全局变量的缺点是没有作用域，容易失控，仅应该用于常量，并且它也不能用于composables的重组。虽然全局变量可以跨越空间，让所有函数都能访问。全局变量是编程语言层面的东西，仅适用于常量的定义，也即整个应用程序运行期间确定不会发生改变的值。</p>

<p>这正是CompositionLocal有价值的地方，它能限定作用域，又可以触发重组，允许数据值改变，又可以跨越空间。这是Compose框架层面提供的工具，自然更适合在Compose中使用。</p>

<h2>总结</h2>

<p>调用函数时传递参数可谓是『明修栈道』，而CompositionLocal则是『暗渡陈仓』，提供了一种在组合（Composition）中自上而下隐式传递数据的一种方式，可以让函数调用只关心与逻辑相关的输入数据。恰当的使用CompositionLocal可以有效的管控上下文环境变量，并极大地简化代码，让代码更加的优雅和简洁。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/compositionlocal">Locally scoped data with CompositionLocal</a></li>
<li><a href="https://www.valueof.io/blog/compose-compositionlocal-compositionlocalprovider">Passing data using CompositionLocal</a></li>
<li><a href="https://www.kodeco.com/34513206-compositionlocal-in-jetpack-compose">CompositionLocal in Jetpack Compose</a></li>
<li><a href="https://medium.com/mobile-innovation-network/understanding-composition-local-jetpack-compose-4546605df5e1">Understanding Composition Local: Jetpack Compose</a></li>
<li><a href="https://medium.com/@ramadan123sayed/composition-local-in-jetpack-compose-4d0a54afa67c">Composition Local in Jetpack Compose</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给Jetpack Compose添加Native支持]]></title>
    <link href="https://alexhilton.github.io/blog/2024/11/08/android-jni-made-easy/"/>
    <updated>2024-11-08T22:40:32+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/11/08/android-jni-made-easy</id>
    <content type="html"><![CDATA[<p>Jetpack Compose是一个声明式的UI框架，但一个项目不可能光有UI，还需要有业务逻辑。Compose所用的编程语言是Kotlin，一种基于JVM的多范式通用编程语言，尽管非常强大，但因为现代的项目都非常复杂，多语言混合，有些东西用Kotlin没法实现，或者有些现成的C/C++代码可以复用，这时就需要能把native代码集成到Compose项目中去。</p>

<p><a href="https://alexhilton.github.io/blog/2024/11/08/android-jni-made-easy/"><img src="https://questdot.com/wp-content/uploads/2016/07/ndkjni-720x340.png" title="auto auto" ></a></p>

<!-- more -->


<p>想要在Compose中使用native代码是完全可行的，这是因为Compose是基于Kotlin的，而Kotlin本质上是JVM的字节码，也就是运行在虚拟机之上的语言。Java的Native接口，即JNI其实是虚拟机开出的口子，只要能在JVM上运行就可以用JNI，所以标准的Java JNI是完全可以用在Compose里面的。</p>

<p><strong>注意：</strong> native代码（原生代码）在不同的语境有不同的意思，它通常指操作系统直接支持的可执行程序。Java（字节码）是运行在虚拟机上的，操作系统被虚拟机给隔离了，对Java是透明的，这时像可以编译为直接在操作系统上运行的代码（如C/C++）称为native代码；假如换个语境，如运行在WebView中的Web前端，则可以直接运行在Android上的或者iOS上的原生SDK代码则称为native代码。</p>

<p>先来看一下如何在Compose项目中添加native支持。</p>

<h2>新项目</h2>

<p>新的项目在创建项目的时候可以选择C++，无论是Kotlin的类，以及C++的实现，以及配置文件都会有模板。但除了demo以外，一般不会有新建项目的机会，极少项目是从0开始。绝大多数情况都是在现有项目中添加native支持，所以我们重点看看如何在现有项目中添加native支持。</p>

<h2>现有项目添加JNI支持</h2>

<p>现在的Android Studio已经对JNI有了很好的支持，AGP中也提供了支持，所以可以不用NDK中命令行式的ndk-build了。对于现有项目想添加JNI支持也不麻烦，有两种方式：一种是添加一个native的Module，新建Module时选择native library就可以了，这个Module里面与新建的Native项目是差不多的。这种方式适合于比较独立的一个新的需要native支持的模块，然后此模块再作为主模块的依赖，比较合适的场景是一个独立的功能模块；</p>

<p>第二种方式就是，像新建 的native项目那样，直接添加native支持：</p>

<h3>Step 1 添加C/C++源码目录</h3>

<p>先在对应的module如app中添加cpp源码目录，要放在与java或者kotlin同级别的目录，如app/src/main/下面，之后所有native层的东西都在app/src/main/cpp下面。</p>

<h3>Step 2 设置CMake</h3>

<p>在建 好的目录下面添加源码LocalJNI.cpp和编译文件CMakeLists.txt。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='Bash'><span class='line'>cmake_minimum_required<span class="o">(</span>VERSION 3.22.1<span class="o">)</span>
</span><span class='line'>
</span><span class='line'>project<span class="o">(</span><span class="s2">&quot;effectivejni&quot;</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>add_library<span class="o">(</span><span class="k">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="k">}</span> SHARED
</span><span class='line'>        <span class="c"># List C/C++ source files with relative paths to this CMakeLists.txt.</span>
</span><span class='line'>        LocalJNI.cpp<span class="o">)</span>
</span><span class='line'>target_link_libraries<span class="o">(</span><span class="k">${</span><span class="nv">CMAKE_PROJECT_NAME</span><span class="k">}</span>
</span><span class='line'>        <span class="c"># List libraries link to the target library</span>
</span><span class='line'>        android
</span><span class='line'>        log<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>CMake是一个跨平台的C/C++编译系统，可以参考 <a href="https://cmake.org/">其官文档</a>了解详细信息。</p>

<h3>Step 3 在Gradle脚本中添加native build关联</h3>

<p>在android块中加入externalNativeBuild：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">android</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>    <span class="n">externalNativeBuild</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">cmake</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">path</span><span class="p">(</span><span class="s">&quot;src/main/cpp/CMakeLists.txt&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="n">version</span> <span class="p">=</span> <span class="s">&quot;3.22.1&quot;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Step 4 添加带有native方法的类</h3>

<p>这一步要特别注意，因为JNI是Java Native Interface，所以必须要严格符合Java的方式，native方法的声明必须是某个类的方法；另外，JNI调用Java时也必须先找到某个类，然后再调用它的方法。所以必须 要有一个Java的public类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">package</span> <span class="nn">net.toughcoder.effectivejni</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">LocalJNI</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">external</span> <span class="k">fun</span> <span class="nf">stringFromLocal</span><span class="p">():</span> <span class="n">String</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">companion</span> <span class="k">object</span> <span class="err">{</span>
</span><span class='line'>        <span class="n">init</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">System</span><span class="p">.</span><span class="n">loadLibrary</span><span class="p">(</span><span class="s">&quot;effectivejni&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然，这个类可以放在任何文件中。因为Kotlin放宽了Java的限制，在Java中每一个public的类必须要放在一个名字一样的文件中，但Kotlin的文件与类没有对应的关系，所以可以把这个类放在任何文件中，当然了package要指明，因为在JNI中查找class时，要指定package name。</p>

<h3>Step 5 实现native方法</h3>

<p>具体native方法的实现就看具体要做什么了。这里只是演示所以简单返回一个字符串。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='C++'><span class='line'><span class="cp">#include &lt;jni.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;string&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="n">JNIEXPORT</span> <span class="n">jstring</span> <span class="n">JNICALL</span>
</span><span class='line'><span class="n">Java_net_toughcoder_effectivejni_LocalJNI_stringFromJNI</span><span class="p">(</span>
</span><span class='line'>        <span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span>
</span><span class='line'>        <span class="n">jobject</span> <span class="cm">/* this */</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">hello</span> <span class="o">=</span> <span class="s">&quot;Hello from C++ with static mapping&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">NewStringUTF</span><span class="p">(</span><span class="n">hello</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>注意：</strong> 虽然Compose使用的编程语言是Kotlin，但毕竟Kotlin是JVM语言，也与Java可以相互替换。对于JNI来说，Kotlin与Java无区别，所以后面会以Java来统一当作native的另一端。</p>

<h2>JNI注册</h2>

<p>无论是用C/C++去实现native接口，还是复用现成的native方法，都需要要把native方法与Java层声明的方法进行关联映射，以让JVM能找到此方法的实现，这也即所谓的JNI注册。有两种方式进行JNI注册。</p>

<p>静态方式，其实就是Java默认支持的方式，它要求Native的实现函数是纯C的，要用『extern C』包裹起来，还有就是方法的名字要是Java&#95;包名&#95;类名&#95;方法名，比较严格。前面的示例用的就是静态注册。</p>

<p>动态注册的原理是加载so的时候，当虚拟机在找到so以后，会查找里面一个叫做JNI&#95;OnLoad的函数指针，然后执行此函数。那么，在so的实现中，写一个叫做JNI&#95;OnLoad的函数，在里面手动进行Native方法注册，然后当so被加载时JNI&#95;OnLoad就会被执行，JNI方法就注册好了。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='C++'><span class='line'><span class="cp">#include &lt;jni.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;string&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Method declaration</span>
</span><span class='line'><span class="n">jstring</span> <span class="nf">dynamicString</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">thiz</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// JNI wrapper</span>
</span><span class='line'><span class="k">const</span> <span class="kt">char</span> <span class="n">className</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;net/toughcoder/effectivejni/LocalJNI&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">const</span> <span class="n">JNINativeMethod</span> <span class="n">methods</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">{</span><span class="s">&quot;stringFromJNI&quot;</span><span class="p">,</span> <span class="s">&quot;()Ljava/lang/String;&quot;</span><span class="p">,</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">dynamicString</span><span class="p">)}</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="n">JNIEXPORT</span> <span class="n">jint</span> <span class="n">JNICALL</span> <span class="nf">JNI_OnLoad</span><span class="p">(</span><span class="n">JavaVM</span> <span class="o">*</span><span class="n">vm</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">reserved</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">vm</span><span class="o">-&gt;</span><span class="n">GetEnv</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="o">**&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">env</span><span class="p">),</span> <span class="n">JNI_VERSION_1_6</span><span class="p">)</span> <span class="o">!=</span> <span class="n">JNI_OK</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">JNI_ERR</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">jclass</span> <span class="n">clazz</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">FindClass</span><span class="p">(</span><span class="n">className</span><span class="p">);</span>
</span><span class='line'>    <span class="n">env</span><span class="o">-&gt;</span><span class="n">RegisterNatives</span><span class="p">(</span><span class="n">clazz</span><span class="p">,</span> <span class="n">methods</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">methods</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">methods</span><span class="p">[</span><span class="mi">0</span><span class="p">])));</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">JNI_VERSION_1_6</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// The implementation</span>
</span><span class='line'><span class="n">jstring</span> <span class="nf">dynamicString</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">thiz</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">&quot;String from JNI via dynamic mapping.&quot;</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">NewStringUTF</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个JNI&#95;OnLoad的方法的参数很有意思是一个JavaVM对象指针，JavaVM对象每个应用进程只有一个，可以认为就是应用的虚拟机。但每个JNI方法都有一个JNIEnv对象指针，它给native方法提供一个JNI上下文，这个则是每个线程都有一个。</p>

<p>推荐使用动态注册方式进行JNI注册，这是因为这种方式更为灵活，不必写繁琐的方法声明，也不必用extern C限制，可以是常规的C++函数。</p>

<h2>JNI是一个接口层</h2>

<p>JNI是一个口子，可以让Java调用native代码，也能让native代码调用Java代码，调用Java代码就相当于反射。JNI是一个传送门，虽然入口处有一些限制，但深入到native里面就是完全的C和C++世界了，只要是C和C++能实现的事情都可以做。</p>

<p><img src="file:///Users/alexhilton/Downloads/JNI.svg" alt="图1. JNI是一个传送门" /></p>

<h2>JNI线程</h2>

<p>需要注意的是结构体JavaVM是所有线程共享，它代表着进程所在的虚拟机。但结构体JNIEnv则是代表着栈中的执行环境（因为JNI仅一个方法，而方法必然运行在某个线程之中），每个线程有一个。创建的局部引用也不能跨线程使用。</p>

<p>从JNIEnv获取JavaVM：env->GetJavaVM(&amp;vm)</p>

<p>从JavaVM获得当前JNIENV：vm->AttachCurrentThread(&amp;env, null)</p>

<p>最好都从Java层来管理线程，JNI只是某些方法的实现。</p>

<p>如果JNI的native代码也很复杂需要线程的话，也可以用pthread创建线程，但也应该维持在一定的作用域范围内，不应该再从此线程去调用Java。这样只会制造混乱。</p>

<h2>两个世界的对象连接</h2>

<p>需要注意JNI是纯C接口，没有对象的概念，入口处的native方法不属于任何C++对象。假如native深入层足够复杂也有一套对象，如何建立起 Java层对象和native对象的连接呢？可以参考Android frameworks的作法，它通常会给Java层的对象有一个整形域变量，用以存放native层对象指针，这样就能建立起来对象与对象的一一对应关系。</p>

<h2>添加已编译好的native库</h2>

<p>JNI是连接Java层与C/C++层的传送门，除了新写的native代码，也可以直接使用已编译好的C/C++的库，静态库libxxx.a和动态库libxxx.so。</p>

<p>预编译的库通常作为JNI的依赖，当然也可以直接加载，前提是so里面已包含了JNI接口。但需要特别注意的是静态的库.a是无法直接在Java中加载的，也即无法通过System.loadLibrary()来加载native的静态库。因此静态库只能作为依赖，要包一层，写一个Wrapper层编译为so，静态库作为so的依赖，然后把so加载为JNI。</p>

<p>通过CMake中的add_library指令来添加预编译好的库，具体可以 <a href="https://cmake.org/cmake/help/latest/command/add_library.html">参考其文档</a>。</p>

<h2>NDK的版本</h2>

<p>在项目的配置gradle文件中可以指定具体的NDK版本：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">android</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">ndkVersion</span> <span class="p">=</span> <span class="s">&quot;28.0.12433566&quot;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>NDK的版本可以看<a href="https://developer.android.com/ndk/downloads/revision_history">官方发布历史</a>，NDK主要是指Android提供的native API（C/C++ API），主要是一些系统提供的能力，如音频视频能力，图形图像能力等，可以看<a href="https://developer.android.com/ndk/guides/stable_apis">其接口说明文档</a>，以及<a href="https://developer.android.com/ndk/reference">NDK开发文档</a>。</p>

<h2>C/C++的版本指定</h2>

<p>C++语言自从其诞生，在Java和新一代编程语言出现后，曾一度长期停滞，在泛型，函数式编程，并发上面落后于其他语言，并被诟病。但从C++11开始，（C++语言的版本以年份的后两位来命名，如C++11是指2011年发布的版本，C++17指2017年发布的，以此类推）这门古老的语言焕然一新，增加了很多新时代编程语言的特性，其后的C++17继续前进，到现在的C++20已经完全是一个现代化的编程语言了，lambda，函数式，泛型和并发都有了非常好的支持，甚至已经超越了老对手Java。因此，C++11以后的版本也称为『现代C++（Modern C++）』。</p>

<p>都4202年了，肯定要用最新的C++20才行啊。CMake使用的是LLVM编译器，而LLVM已经完全支持C++20了，但默认的版本使用的是C++17，想要特别的版本，就需要在CMakefile.txt中进行指定，也即通过添加编译选项来指定C++的版本：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Bash'><span class='line'><span class="nb">set</span><span class="o">(</span>CMAKE_ANDROID_STL_TYPE <span class="s2">&quot;c++_shared&quot;</span><span class="o">)</span>
</span><span class='line'><span class="nb">set</span><span class="o">(</span>CMAKE_C_FLAGS <span class="s2">&quot;${CMAKE_C_FLAGS} -std=c99&quot;</span><span class="o">)</span>
</span><span class='line'><span class="nb">set</span><span class="o">(</span>CMAKE_CXX_FLAGS <span class="s2">&quot;${CMAKE_CXX_FLAGS} -std=c++20&quot;</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>JNI内存管理</h2>

<p>Java层是自动档（自动内存管理），但C/C++是手动档，因此穿过JNI后就需要特别小心内存管理。有一些注意事项：</p>

<ul>
<li>Java 层传过来的对象，不需要手动去释放。比如说传过来的数组或者字符串。</li>
<li>传回给Java层的对象，也不需要手动释放。比如像上面的例子新创建出来的字符串，尽管使用了New，但不需要管。GC会追踪。而且你也没法释放，创建完对象交给Java层了，不确定Java还在不在使用中呢，你咋delete？</li>
<li>只应该管理生命周期全都在native的new出来的对象，和引用。</li>
<li>需要特别注意方法运行的上下文，也即JNIEnv，这个东西每个线程有一个，且是不同的。要保证在同一个JNIEnv中管理内存，不同的JNIEnv无法共享创建出来的对象和引用，不能交叉使用，更不能交叉式的释放。</li>
</ul>


<h2>JNI能做什么</h2>

<p>JNI是一个接口层，能够让Java进入C/C++世界，调用C/C++的代码，包括现有代码。所以只要编译出来了目标平台（ARM）的so，就可以在JNI中用。</p>

<p>当然了，为了兼容性，使用的so最好用NDK进行编译。</p>

<p>因为Android是Linux内核的，所以，理论上Linux系统调用支持的东西全都能在JNI里面搞。当然，使用native最为正确的体位是使用NDK来实现想要的功能，可以查看<a href="https://developer.android.com/ndk/reference">NDK的开发文档</a>来明确可以做哪些事情。</p>

<h2>使用JNI的正确姿式</h2>

<p>JNI虽好，但不要滥用，不能单单以『C/C++语言性能高于Java（JVM）』为理由就去使用JNI。JNI本身是一个口子，单从方法调用角度讲，从Java层调用过来要有历经查询和数据转换，不见得会比Java方法高效到哪里去。而且JNI在线程调度，异常管理和内存管理上面都较Java层相比非常的不方便，那点看起来的性能优势的代价是很大的，所以说能不用JNI就别用。</p>

<p>使用JNI的正确理由：</p>

<ol>
<li>做一些Java层无法做到的事情，比如一些底层的系统调用（System calls），Java层做不到，那自然得用C/C++</li>
<li>使用一些现有的C/C++代码，这个是最为正统的理由</li>
<li>基于安全角度考量，把一些关键的实现放在C/C++层，这个也合理，因为C/C++相较于Java字节码要略难破解一些</li>
<li>基于跨平台角度考虑，把一些与平台关联密切的，且独立的模块用C/C++实现，比如像通信协议，或者加密，或者压缩之类的非常独立的功能模块，用C/C++来实现，屏蔽名个平台的不同，这会让Java层更加的简单</li>
</ol>


<p>除此之外，似乎没有理由使用JNI。另外，在使用的时候也要注意尽可能的单进单出，也就是说从Java层调用native方法，进去后一直在native运算，得到结果后返回给Java。而不应该频繁的有交互，比如说Java层调用进了native方法，但在native中又频繁 的调用Java层的方法。这明显是设计不合理，应该在Java层把需要的数据准备齐全后，再调用native层。</p>

<h2>References</h2>

<ul>
<li><a href="https://juejin.cn/post/7382893339098906665">Android JNI入门</a></li>
<li><a href="https://juejin.cn/post/7302684536148230194">一、Android-JNI开发</a></li>
<li><a href="https://juejin.cn/post/6844903933375152136">Android NDK-深入理解JNI</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1666741">JNI线程相关</a></li>
<li><a href="https://developer.android.com/studio/projects/add-native-code">Add C and C++ code to your project</a></li>
<li><a href="https://developer.android.com/training/articles/perf-jni">JNI tips</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让Activity更加优雅地跳转]]></title>
    <link href="https://alexhilton.github.io/blog/2024/10/14/activity-result-launcher/"/>
    <updated>2024-10-14T22:24:55+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/10/14/activity-result-launcher</id>
    <content type="html"><![CDATA[<p>有过Android开发经验的小伙伴对<a href="https://developer.android.com/reference/android/app/Activity#startActivityForResult(android.content.Intent,%20int">startActivityForResult</a>)以及<a href="https://developer.android.com/reference/android/app/Activity#onActivityResult(int,%20int,%20android.content.Intent,%20android.app.ComponentCaller">onActivityResult</a>)一定不陌生，正是这一对API让组件 的复用变成可能。今天就来学习一下如何在函数式的范式中驾驭Activity的跳转。</p>

<p><a href="https://alexhilton.github.io/blog/2024/10/14/activity-result-launcher/"><img src="https://akexorcist.dev/content/images/size/w2000/2021/12/activity_result_api-header.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>缘起</h2>

<p>系统组件复用，特别是Activity的复用，是Android系统中非常重要的一个设计理念。组件复用打破了应用程序之间的壁垒，在整个系统范围内可以共享和复用一些公共的组件，比如像打开网页，拍照片，查看图片等等，开发者不必再用原始API去实现一套，直接使用startActivityForResult和onActivityResult就可以取到需要的资源。</p>

<p>这套API最大的问题在于它并不是常规的异步式的回调，调用了startActivityForResult后，结果的处理，必须要在Activity的继承体系内覆写onActivityResult，并且因为Activity实例只能由系统创建，这就导致了组件复用的逻辑必须都在Activity内部。这就导致了Activity的体积通常会相当的臃肿，上千行，甚至大几千行的Activity随处可见。理想的情况下Activity，作为一个系统的容器和接口，应该越薄越好，但要能把逻辑移出Activity才行。</p>

<p>另一方面，onActivityResult无法在函数式的情境中使用，因为它会跑到函数外面去，比如在Jetpack Compose中就无法直接使用startActivityForResult和onActivityResult。</p>

<p>为了解决这两个问题，就需要使用到Jetpack中的<a href="https://developer.android.com/reference/androidx/activity/result/package-summary">Activity Result API</a>了。</p>

<h2>Activity Result API的使用方法</h2>

<p>在Jetpack的AndroidX中的<a href="https://developer.android.com/jetpack/androidx/releases/activity">Activity</a>和<a href="https://developer.android.com/jetpack/androidx/releases/fragment">Fragment</a>中，可以像常规的回调那样向系统注册一个处理result的回调，一旦系统派发了activity result就能被系统回调到。</p>

<p><strong>注意：</strong> 这里提到的方法都在AndroidX中的<a href="https://developer.android.com/reference/androidx/activity/ComponentActivity">ComponentActivity</a>和<a href="https://developer.android.com/reference/androidx/fragment/app/Fragment">Fragment</a>里面，也就是说要继承AndroidX中的组件才可以。</p>

<h3>注册一个activity result回调</h3>

<p>这套API的方式是在ComponentActivity和Fragment中，提供了一个<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultCaller#public-methods_1">registerForActivityResult</a>方法用于注册activity result的回调。参数是一个<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContract">ActivityResultContract</a>实例和一个<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultCallback">ActivityResultCallback</a>实例。返回的是一个<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultLauncher">ActivityResultLauncher</a>，这个launcher可以用来启动目标Activity，也即触发获取资源的流程，相当于原来的startActivityForResult：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">getContent</span> <span class="p">=</span> <span class="n">registerForActivityResult</span><span class="p">(</span><span class="n">GetContent</span><span class="p">())</span> <span class="p">{</span> <span class="n">uri</span><span class="p">:</span> <span class="n">Uri</span><span class="p">?</span> <span class="p">-&gt;</span>
</span><span class='line'>    <span class="c1">// 处理结果</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>一个ActivityResultContract，如它的名字所示，定义着组件复用的的接口，即输入类型和输出类型。API中定义了<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContracts">大量的现成可用的，也是常见的接口</a>，比如拍照，权限请求等等。当然也可以创建<a href="https://developer.android.com/training/basics/intents/result#custom">自定义接口</a>。</p>

<p>回调ActivityResultCallback是只有一个方法onActivityResult()的接口，此方法的参数由ActivityResultContract来定义。</p>

<h3>启动目标Activity</h3>

<p>当调用registerForActivityResult时，能拿到一个launcher，但此API仅是向系统注册一个回调，这时还没有启动目标（即还没有发起请求）。发起请求需要使用ActivityResultLauncher来完成。</p>

<p>调用其<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultLauncher#launch(I">方法launch</a>)就会发起请求，启动目标Activity，开启获取结果的流程。如果给launch传递了参数，会依据ActivityResultContract做进一步的匹配（其实这些输入最终会转化为Intent对象提供给startActivityForResult）。用户在目标Activity页面完成了操作后，就会返回到当前页面，回调ActivityResultCallback的方法onActivityResult就会被执行：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">getContent</span> <span class="p">=</span> <span class="n">registerForActivityResult</span><span class="p">(</span><span class="n">GetContent</span><span class="p">())</span> <span class="p">{</span> <span class="n">uri</span><span class="p">:</span> <span class="n">Uri</span><span class="p">?</span> <span class="p">-&gt;</span>
</span><span class='line'>    <span class="c1">// 处理结果，即返回的Uri</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="n">Bundle</span><span class="p">?)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">val</span> <span class="py">selectButton</span> <span class="p">=</span> <span class="n">findViewById</span><span class="p">&lt;</span><span class="n">Button</span><span class="p">&gt;(</span><span class="n">R</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">select_button</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">selectButton</span><span class="p">.</span><span class="n">setOnClickListener</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 接口是获取内空，这里传mime type作为参数，那么就是要获取一个图片内容</span>
</span><span class='line'>        <span class="n">getContent</span><span class="p">.</span><span class="n">launch</span><span class="p">(</span><span class="s">&quot;image/*&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果需要多个组件复用，那就传递不同的参数多次调用registerForActivityResult。并且registerForActivityResult可以在任何时候调用，在onCreate之前调用也是安全的，所以可以在声明ActivityResultLauncher的时候就直接调用，这样可以直接初始化。</p>

<p>但是要特别注意，使用launcher来启动Activity则必须在onCreate之后。</p>

<p>还有一点需要特别注意，因为launch之后，onActivityResult之前这段时间会离开当前的Activity，这个时间内Activity可能会被系统回收，也即触发了状态恢复。所以处理结果时，也即onActivityResult中的逻辑，如果有依赖其他状态，这些状态需要在onSaveInstanceState中进行保存。</p>

<h3>处理结果</h3>

<p>结果的处理就在ActivityResultCallback中的方法onActivityResult，这里使用返回的参数就可以了。</p>

<h2>在Activity之外使用</h2>

<p>如前面所述，使用这套Result API的最大的好处在于把结果的处理从Activity中解耦出来，因此，最为理想的方式是能在独立的class中做这些事情。</p>

<p>这就需要使用<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultRegistry">ActivityResultRegistry</a>，它才是核心，另外三个类（launcher，contract和callback）都是一些封装，事实上Activity和Fragment里面的方法registerForActivityResult其实也是使用这个registry来实现的。从Activity中可以拿到registry的实例，以此作为参数，就可以在自定义的class中使用Result APIs了。</p>

<p>比如单独封装获取图片的流程可以这样写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">MyLifecycleObserver</span><span class="p">(</span><span class="k">private</span> <span class="k">val</span> <span class="py">registry</span> <span class="p">:</span> <span class="n">ActivityResultRegistry</span><span class="p">)</span>
</span><span class='line'>        <span class="p">:</span> <span class="n">DefaultLifecycleObserver</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">lateinit</span> <span class="k">var</span> <span class="py">getContent</span> <span class="p">:</span> <span class="n">ActivityResultLauncher</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">owner</span><span class="p">:</span> <span class="n">LifecycleOwner</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">getContent</span> <span class="p">=</span> <span class="n">registry</span><span class="p">.</span><span class="n">register</span><span class="p">(</span><span class="s">&quot;key&quot;</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">GetContent</span><span class="p">())</span> <span class="p">{</span> <span class="n">uri</span> <span class="p">-&gt;</span>
</span><span class='line'>            <span class="c1">// Handle the returned Uri</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">fun</span> <span class="nf">selectImage</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">getContent</span><span class="p">.</span><span class="n">launch</span><span class="p">(</span><span class="s">&quot;image/*&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">MyFragment</span> <span class="p">:</span> <span class="n">Fragment</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">lateinit</span> <span class="k">var</span> <span class="py">observer</span> <span class="p">:</span> <span class="n">MyLifecycleObserver</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="n">Bundle</span><span class="p">?)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// ...</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">observer</span> <span class="p">=</span> <span class="n">MyLifecycleObserver</span><span class="p">(</span><span class="n">requireActivity</span><span class="p">().</span><span class="n">activityResultRegistry</span><span class="p">)</span>
</span><span class='line'>        <span class="n">lifecycle</span><span class="p">.</span><span class="n">addObserver</span><span class="p">(</span><span class="n">observer</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onViewCreated</span><span class="p">(</span><span class="n">view</span><span class="p">:</span> <span class="n">View</span><span class="p">,</span> <span class="n">savedInstanceState</span><span class="p">:</span> <span class="n">Bundle</span><span class="p">?)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">selectButton</span> <span class="p">=</span> <span class="n">view</span><span class="p">.</span><span class="n">findViewById</span><span class="p">&lt;</span><span class="n">Button</span><span class="p">&gt;(</span><span class="n">R</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">select_button</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">selectButton</span><span class="p">.</span><span class="n">setOnClickListener</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// 触发获取图片的流程</span>
</span><span class='line'>            <span class="n">observer</span><span class="p">.</span><span class="n">selectImage</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个示例把获取图片的流程（发起和结果处理）都封装在了一个单独的类中，同时又是明是监听了Activity组件的生命周期。谷歌是强烈建议同时要<a href="https://developer.android.com/reference/kotlin/androidx/lifecycle/LifecycleObserver">监听生命周期</a>（通过扩展LifecycleObserver），这是因为<a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner">LifecycleOwner</a>会在destroy时自动帮你反注册ActivityResultLauncher，不然的话就要手动的<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultLauncher#unregister(">反注册</a>)。</p>

<h2>自定义Contract</h2>

<p>尽管谷歌已经在<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContracts">ActivityResultContracts</a>中已经预定义了大量的contracts可以使用，但仍然会有一些特殊的场景因预定义的contract无法满足需求而需要自定义一个contract。这个contract实际上就是约定了组件复用的接口，就像普通的interface一样，定义好输入与输出的类型就可以了，所以需要给contract提供输入输出的类型，如果不需要输入或者输出就使用Void?或者Unit。</p>

<p>此外还需要实现一个<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContract#createIntent(android.content.Context,kotlin.Any">createIntent方法</a>)，这个方法接收一个Context和其他输入（即contract约定的输入，最终是由ActivityResultLauncher中方法launch时提供）作为参数并返回一个Intent对象，此Intent会是startActivityForResult的输入参数。同时还需要实现另外一个<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContract#parseResult(kotlin.Int,android.content.Intent">方法parseIntent</a>)，此方法将<a href="https://developer.android.com/reference/android/app/Activity#onActivityResult(int,%20int,%20android.content.Intent,%20android.app.ComponentCaller">Activity的标准钩子onActivityResult</a>)中的参数resultCode和Intent转化为contract中约定的输出（此输出会作为回调ActivityResultCallback函数方法onActivityResult的输入参数）。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">PickRingtone</span> <span class="p">:</span> <span class="n">ActivityResultContract</span><span class="p">&lt;</span><span class="n">Int</span><span class="p">,</span> <span class="n">Uri</span><span class="p">?&gt;()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">override</span> <span class="k">fun</span> <span class="nf">createIntent</span><span class="p">(</span><span class="n">context</span><span class="p">:</span> <span class="n">Context</span><span class="p">,</span> <span class="n">ringtoneType</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">=</span>
</span><span class='line'>        <span class="n">Intent</span><span class="p">(</span><span class="n">RingtoneManager</span><span class="p">.</span><span class="n">ACTION_RINGTONE_PICKER</span><span class="p">).</span><span class="n">apply</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">putExtra</span><span class="p">(</span><span class="n">RingtoneManager</span><span class="p">.</span><span class="n">EXTRA_RINGTONE_TYPE</span><span class="p">,</span> <span class="n">ringtoneType</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">override</span> <span class="k">fun</span> <span class="nf">parseResult</span><span class="p">(</span><span class="n">resultCode</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="n">result</span><span class="p">:</span> <span class="n">Intent</span><span class="p">?)</span> <span class="p">:</span> <span class="n">Uri</span><span class="p">?</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">resultCode</span> <span class="p">!=</span> <span class="n">Activity</span><span class="p">.</span><span class="n">RESULT_OK</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="k">null</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">result</span><span class="o">?.</span><span class="n">getParcelableExtra</span><span class="p">(</span><span class="n">RingtoneManager</span><span class="p">.</span><span class="n">EXTRA_RINGTONE_PICKED_URI</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果现有的contracts不满足需求，且也无具体的输入输出要求，那么可以用一个万用contract，即<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContracts.StartActivityForResult">StartActivityForResult</a>。这个万用contract的输入是一个Intent，输出是一个<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResult">ActivityResult</a>，在回调方法onActivityResult中可以直接从ActivityResult实例中取出resultCode和目标返回的Intent对象：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">startForResult</span> <span class="p">=</span> <span class="n">registerForActivityResult</span><span class="p">(</span><span class="n">StartActivityForResult</span><span class="p">())</span> <span class="p">{</span> <span class="n">result</span><span class="p">:</span> <span class="n">ActivityResult</span> <span class="p">-&gt;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">resultCode</span> <span class="p">==</span> <span class="n">Activity</span><span class="p">.</span><span class="n">RESULT_OK</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">intent</span> <span class="p">=</span> <span class="n">result</span><span class="p">.</span><span class="n">data</span>
</span><span class='line'>        <span class="c1">// 处理目标返回的Intent</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="n">Bundle</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">val</span> <span class="py">startButton</span> <span class="p">=</span> <span class="n">findViewById</span><span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">start_button</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">startButton</span><span class="p">.</span><span class="n">setOnClickListener</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 传入想要启动的Intent对象</span>
</span><span class='line'>        <span class="n">startForResult</span><span class="p">.</span><span class="n">launch</span><span class="p">(</span><span class="n">Intent</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">ResultProducingActivity</span><span class="o">::</span><span class="k">class</span><span class="p">.</span><span class="n">java</span><span class="p">))</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从这里我们可以看出，这套Result API本质上仍是依赖于原始的startActivityForResult和onActivityResult。</p>

<h2>在Compose中使用Result API</h2>

<p>接下来我们看看如何在Jetpack Compose使用这套API，这套API与Activity彻底解耦且支持函数式写法，所以可以在Compose中使用。这套API的核心是ActivityResultRegistry，有了它其他几个就可以使用起来了，而它的实例可以直接从Activity中取出来，所以这套API在Compose中完全可以用起来，与前面讲到的在Activity之外的逻辑完全一样：获取此对象用于register一个contract，同时得到一个launcher对象，在回调中处理结果，在合适的时机触发launch。</p>

<p>幸运的是完全用不着自己折腾，Compose中已经做好了封装，直接使用<a href="https://developer.android.com/reference/kotlin/androidx/activity/compose/package-summary#rememberlauncherforactivityresult">rememberLauncherForActivityResult</a>即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">GetContentExample</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">imageUri</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">&lt;</span><span class="n">Uri</span><span class="p">?&gt;(</span><span class="k">null</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">launcher</span> <span class="p">=</span> <span class="n">rememberLauncherForActivityResult</span><span class="p">(</span><span class="n">ActivityResultContracts</span><span class="p">.</span><span class="n">GetContent</span><span class="p">())</span> <span class="p">{</span> <span class="n">uri</span><span class="p">:</span> <span class="n">Uri</span><span class="p">?</span> <span class="p">-&gt;</span>
</span><span class='line'>        <span class="n">imageUri</span> <span class="p">=</span> <span class="n">uri</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">Column</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Button</span><span class="p">(</span><span class="n">onClick</span> <span class="p">=</span> <span class="p">{</span> <span class="n">launcher</span><span class="p">.</span><span class="n">launch</span><span class="p">(</span><span class="s">&quot;image/*&quot;</span><span class="p">)</span> <span class="p">})</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">Text</span><span class="p">(</span><span class="n">text</span> <span class="p">=</span> <span class="s">&quot;Load Image&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">Image</span><span class="p">(</span>
</span><span class='line'>            <span class="n">painter</span> <span class="p">=</span> <span class="n">rememberAsyncImagePainter</span><span class="p">(</span><span class="n">imageUri</span><span class="p">),</span>
</span><span class='line'>            <span class="n">contentDescription</span> <span class="p">=</span> <span class="s">&quot;My Image&quot;</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>今天我们学习了Jetpack中提供的新式处理activity result的方法，这不仅能让在函数式编程范式中复用组件变成可能，也可以把很多逻辑从Activity中抽离出来，能给Activity瘦身，让组件跳转变得更为优雅。</p>

<h2>References</h2>

<ul>
<li><a href="https://blog.dogukangun.de/the-usage-of-activity-result-launcher-9c3d2241ec8">The Usage of Activity Result Launcher</a></li>
<li><a href="https://developer.android.com/training/basics/intents/result">Get a result from an activity</a></li>
<li><a href="https://stackoverflow.com/questions/64721218/jetpack-compose-launch-activityresultcontract-request-from-composable-function">Jetpack Compose: Launch ActivityResultContract request from Composable function</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/libraries">Compose and other libraries</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[喜迎国庆，用Compose赶制一面五星红旗]]></title>
    <link href="https://alexhilton.github.io/blog/2024/10/11/waving-flag-with-compose/"/>
    <updated>2024-10-11T22:38:22+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/10/11/waving-flag-with-compose</id>
    <content type="html"><![CDATA[<p>我们学习Jetpack Compose已经有一段时间了，通过前面的学习已能掌握足够的技巧以在实战中应用。恰逢普天庆国庆，利用我们学过的知识，使用Jetpack Compose来画一个迎风飘扬的五星红旗吧！废话不多说，先来看一眼效果图。</p>

<p><a href="https://alexhilton.github.io/blog/2024/10/11/waving-flag-with-compose/"><img src="file:///Users/alexhilton/Downloads/compose_libs/red_flag.gif" title="auto auto" ></a></p>

<!-- more -->


<h2>五星红旗的设计标准</h2>

<p>需要特别注意，五星红旗有明确的设计标准的，在<a href="https://www.gov.cn/xinwen/2020-12/24/content_5572913.htm">国旗法中有明确的制法说明</a>。</p>

<p>总结一下要点：宽与高之比为3比2，五颗星都在左上四分之一小矩形内，最大五角星直径约为高的十分之一，四个小五角星的一个角要指向大五角星的中心。</p>

<h2>如何画五角星</h2>

<p>五星红旗并不是特别复杂，拆解一下，其组成图案就是矩形和五角星了，矩形是基本的图形可以直接画。需要研究一下五角星怎么画。</p>

<p>画对称多边形的方法都要借助圆，因为几何图形最容易画的同时也是最标准的就是圆了，再借助角度从圆上取点，把点连成线就是多边形。多边形的顶角度数不一样，因此把圆分成多少份，就能画出不同的多边形了。</p>

<p>五角星也要借助圆，把五角星五个顶点连线就是一个正五边形了，所以在圆上取5个等分点，也即每隔72度取一个点，然后把这5个点每隔一点连成线，就是五角星了。如下图所示：</p>

<p><img src="https://www.algebra.com/cgi-bin/plot-formula.mpl?expression=drawing%28330%2C330%2C-6.6%2C6.6%2C-6.6%2C6.6%2Cgrid%280%29%2C%0D%0Ared%28circle%280%2C0%2C6%29%29%2Cline%280%2C6%2C3.527%2C-4.854%29%2Clocate%285.8%2C1.9%2CP%29%2C%0D%0Aline%280%2C6%2C-3.527%2C-4.854%29%2Cline%28-3.527%2C-4.854%2C5.706%2C1.854%29%2C%0D%0Aline%28-5.706%2C1.854%2C5.706%2C1.854%29%2Cline%28-5.706%2C1.854%2C3.527%2C-4.854%29%2C%0D%0Ared%28arrow%280%2C0%2C6.562%2C2.132%29%29%2Cred%28arc%280%2C0%2C4.4%2C4.4%2C-18%2C0%29%29%2C%0D%0Alocate%282.2%2C1%2Cred%2890%5Eo-72%5Eo=18%5Eo%29%29%2Cred%28arc%280%2C0%2C8%2C8%2C-90%2C-18%29%29%2C%0D%0Alocate%282.8%2C3.5%2Cred%2872%5Eo%29%29%2Cgreen%28arrow%280%2C0%2C3.879%2C5.34%29%29%2C%0D%0Agreen%28arc%280%2C0%2C2.2%2C2.2%2C-90%2C-54%29%29%2Clocate%280.1%2C2%2Cgreen%2836%5Eo%29%29%0D%0A%29" alt="图2. 五角星画法" /></p>

<p>这种画法对手工尺规作图很友好，对程序来说，就没那么友好了。程序化的API需要明确的坐标点，把点串连成路径（Path）。这里需要的五角星是填充的，所以如果能知道5个顶点，和凹进来的五个点，只要把这10个点串起来，就能组成一个闭合的图形，得到我们想要五角星了。</p>

<p>五角星的外面五个点和内部五个点能组成两个正五边形，这两个正五边形的外接圆是两个同心圆，外顶点与内顶点刚好相差36度，正五边形的顶点之间是72度。所以，我们通过画两个半径不同的同心圆，每个圆分成5份，大圆的点与小圆的点交错开，就能画出一个五角星了。圆心和半径是关键的参数，通过圆心与半径，就能精细调整五角星的形状。</p>

<p><img src="https://mathalino.com/sites/default/files/images/005-planegeom-pentagram.jpg" alt="图3. 填充式五角星" /></p>

<p>因为五角星是填充色，所以我们把最外层的五个点与内层的五个点连串一起组成一个闭合的图形。通过前面的<a href="https://juejin.cn/post/7381826917086920742">降Compose十八掌之『利涉大川』| Canvas</a>学习，我们知道可以用路径（Path）来画图形，一共10个点把圆分成10分，所以角度是36度，半径是一大一小交错开来：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'>   <span class="k">val</span> <span class="py">path</span> <span class="p">=</span> <span class="n">Path</span><span class="p">().</span><span class="n">apply</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">pointNumber</span> <span class="p">=</span> <span class="m">5</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">angle</span> <span class="p">=</span> <span class="n">PI</span><span class="p">.</span><span class="n">toFloat</span><span class="p">()</span> <span class="p">/</span> <span class="n">pointNumber</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">innerRadius</span> <span class="p">=</span> <span class="n">radius</span> <span class="p">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="p">/</span> <span class="m">2f</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="n">pointNumber</span> <span class="p">*</span> <span class="m">2</span> <span class="n">downTo</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">val</span> <span class="py">r</span> <span class="p">=</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="p">%</span> <span class="m">2</span> <span class="p">==</span> <span class="m">1</span><span class="p">)</span> <span class="n">radius</span> <span class="k">else</span> <span class="n">innerRadius</span>
</span><span class='line'>            <span class="k">val</span> <span class="py">omega</span> <span class="p">=</span> <span class="n">angle</span> <span class="p">*</span> <span class="n">i</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">val</span> <span class="py">x</span> <span class="p">=</span> <span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="p">+</span> <span class="n">r</span> <span class="p">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>
</span><span class='line'>            <span class="k">val</span> <span class="py">y</span> <span class="p">=</span> <span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="p">+</span> <span class="n">r</span> <span class="p">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>
</span><span class='line'>            <span class="n">lineTo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">drawPath</span><span class="p">(</span>
</span><span class='line'>        <span class="n">path</span> <span class="p">=</span> <span class="n">path</span><span class="p">,</span>
</span><span class='line'>        <span class="n">color</span> <span class="p">=</span> <span class="n">color</span><span class="p">,</span>
</span><span class='line'>        <span class="n">style</span> <span class="p">=</span> <span class="n">Fill</span>
</span><span class='line'>    <span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>画五星红旗</h2>

<p>根据制法以及画五角星的方法，我们总结一下设计要点：</p>

<ol>
<li>用一个高height作为主要参数，那么宽就是其1.5倍，其他的参数都与height有关系，所以改变height就可以完全控制整个旗子的大小；</li>
<li>大五星圆心x是宽的1/6，y是height的1/4，可以看出比例是一致的，所以可以先计算y，再乘1.5就是x；</li>
<li>大五星的外接圆直径约是height的3/10，半径就是高度的3/20，这样大五星就完全确定了；</li>
<li>小五星的直径是高的1/10，半径就是1/20；从上到下命名为a，b，c，d；</li>
<li>小五星a的圆心x在宽的1/3，y在高的1/10</li>
<li>小五星b的圆心x在宽的2/5，y在高的1/5</li>
<li>小五星c的圆心x在宽的2/5，y在高的7/20</li>
<li>小五星d的圆心x在宽的1/3，y在高的9/20</li>
<li>小五星的角要对着大五星的圆心，也就是要把小五星旋转一下。一个办法对Path做变幻，但其实不用那么复杂。我们在画五角星时，选择点时加上一个偏移角度beta就可以了，这样尖角就有旋转角度了。这个旋转角度可以用小五星的圆心与alpha的圆心来求得，就是这两个圆心连线与水平x轴的夹角，用反正切atan来求。</li>
</ol>


<p>综上，就可以写代码啦：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">FiveStarsRedFlag</span><span class="p">(</span><span class="n">height</span><span class="p">:</span> <span class="n">Dp</span> <span class="p">=</span> <span class="m">200.</span><span class="n">dp</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">stickWidth</span> <span class="p">=</span> <span class="m">10.</span><span class="n">dp</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">flagWidth</span> <span class="p">=</span> <span class="n">height</span><span class="p">.</span><span class="n">times</span><span class="p">(</span><span class="m">1.5f</span><span class="p">)</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">flagHeight</span> <span class="p">=</span> <span class="n">height</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">canvasWidth</span> <span class="p">=</span> <span class="n">flagWidth</span><span class="p">.</span><span class="n">plus</span><span class="p">(</span><span class="n">stickWidth</span><span class="p">)</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">canvasHeight</span> <span class="p">=</span> <span class="n">height</span><span class="p">.</span><span class="n">times</span><span class="p">(</span><span class="m">2f</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Canvas</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="n">canvasWidth</span><span class="p">,</span> <span class="n">canvasHeight</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// The background</span>
</span><span class='line'>        <span class="n">drawRect</span><span class="p">(</span><span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Red</span><span class="p">,</span> <span class="n">size</span> <span class="p">=</span> <span class="n">Size</span><span class="p">(</span><span class="n">flagWidth</span><span class="p">.</span><span class="n">toPx</span><span class="p">(),</span> <span class="n">flagHeight</span><span class="p">.</span><span class="n">toPx</span><span class="p">()))</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// The stick</span>
</span><span class='line'>        <span class="n">drawRect</span><span class="p">(</span><span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">LightGray</span><span class="p">,</span> <span class="n">size</span> <span class="p">=</span> <span class="n">Size</span><span class="p">(</span><span class="n">stickWidth</span><span class="p">.</span><span class="n">toPx</span><span class="p">(),</span> <span class="n">canvasHeight</span><span class="p">.</span><span class="n">toPx</span><span class="p">()))</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">val</span> <span class="py">centerY</span> <span class="p">=</span> <span class="n">flagHeight</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">/</span> <span class="m">4f</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">centerX</span> <span class="p">=</span> <span class="n">flagWidth</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">/</span> <span class="m">6f</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">radius</span> <span class="p">=</span> <span class="n">flagHeight</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">*</span> <span class="m">3f</span> <span class="p">/</span> <span class="m">20f</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">smallRadius</span> <span class="p">=</span> <span class="n">flagHeight</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">/</span> <span class="m">20f</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">alphaCenter</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">centerX</span><span class="p">,</span> <span class="n">centerY</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 大五角星 alpha</span>
</span><span class='line'>        <span class="n">drawStar</span><span class="p">(</span>
</span><span class='line'>            <span class="n">alphaCenter</span> <span class="p">=</span> <span class="n">alphaCenter</span><span class="p">,</span>
</span><span class='line'>            <span class="n">center</span> <span class="p">=</span> <span class="n">alphaCenter</span><span class="p">,</span>
</span><span class='line'>            <span class="n">radius</span> <span class="p">=</span> <span class="n">radius</span><span class="p">,</span>
</span><span class='line'>            <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Yellow</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 小五星 a</span>
</span><span class='line'>        <span class="n">drawStar</span><span class="p">(</span>
</span><span class='line'>            <span class="n">alphaCenter</span> <span class="p">=</span> <span class="n">alphaCenter</span><span class="p">,</span>
</span><span class='line'>            <span class="n">center</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">flagWidth</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">/</span> <span class="m">3f</span><span class="p">,</span> <span class="n">flagHeight</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">/</span> <span class="m">10f</span><span class="p">),</span>
</span><span class='line'>            <span class="n">radius</span> <span class="p">=</span> <span class="n">smallRadius</span><span class="p">,</span>
</span><span class='line'>            <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Yellow</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 小五星 b</span>
</span><span class='line'>        <span class="n">drawStar</span><span class="p">(</span>
</span><span class='line'>            <span class="n">alphaCenter</span> <span class="p">=</span> <span class="n">alphaCenter</span><span class="p">,</span>
</span><span class='line'>            <span class="n">center</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">flagWidth</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">*</span> <span class="m">0.4f</span><span class="p">,</span> <span class="n">flagHeight</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">/</span> <span class="m">5f</span><span class="p">),</span>
</span><span class='line'>            <span class="n">radius</span> <span class="p">=</span> <span class="n">smallRadius</span><span class="p">,</span>
</span><span class='line'>            <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Yellow</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 小五星 c</span>
</span><span class='line'>        <span class="n">drawStar</span><span class="p">(</span>
</span><span class='line'>            <span class="n">alphaCenter</span> <span class="p">=</span> <span class="n">alphaCenter</span><span class="p">,</span>
</span><span class='line'>            <span class="n">center</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">flagWidth</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">*</span> <span class="m">0.4f</span><span class="p">,</span> <span class="n">flagHeight</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">*</span> <span class="m">7</span> <span class="p">/</span> <span class="m">20f</span><span class="p">),</span>
</span><span class='line'>            <span class="n">radius</span> <span class="p">=</span> <span class="n">smallRadius</span><span class="p">,</span>
</span><span class='line'>            <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Yellow</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 小五星 d</span>
</span><span class='line'>        <span class="n">drawStar</span><span class="p">(</span>
</span><span class='line'>            <span class="n">alphaCenter</span> <span class="p">=</span> <span class="n">alphaCenter</span><span class="p">,</span>
</span><span class='line'>            <span class="n">center</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">flagWidth</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">/</span> <span class="m">3f</span><span class="p">,</span> <span class="n">flagHeight</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">*</span> <span class="m">9</span> <span class="p">/</span> <span class="m">20f</span><span class="p">),</span>
</span><span class='line'>            <span class="n">radius</span> <span class="p">=</span> <span class="n">smallRadius</span><span class="p">,</span>
</span><span class='line'>            <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Yellow</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>   <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">fun</span> <span class="nf">DrawScope</span><span class="p">.</span><span class="n">drawStar</span><span class="p">(</span><span class="n">alphaCenter</span><span class="p">:</span> <span class="n">Offset</span><span class="p">,</span> <span class="n">center</span><span class="p">:</span> <span class="n">Offset</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="n">Float</span><span class="p">,</span> <span class="n">color</span><span class="p">:</span> <span class="n">Color</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">pointNumber</span> <span class="p">=</span> <span class="m">5</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">angle</span> <span class="p">=</span> <span class="n">PI</span><span class="p">.</span><span class="n">toFloat</span><span class="p">()</span> <span class="p">/</span> <span class="n">pointNumber</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">innerRadius</span> <span class="p">=</span> <span class="n">radius</span> <span class="p">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span> <span class="p">/</span> <span class="m">2f</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">val</span> <span class="py">beta</span> <span class="p">=</span> <span class="k">if</span> <span class="p">(</span><span class="n">alphaCenter</span> <span class="p">==</span> <span class="n">center</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="m">0f</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">PI</span><span class="p">.</span><span class="n">toFloat</span><span class="p">()</span> <span class="p">/</span> <span class="m">2f</span> <span class="p">-</span> <span class="n">atan</span><span class="p">((</span><span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="p">-</span> <span class="n">alphaCenter</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="p">/</span> <span class="p">(</span><span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="p">-</span> <span class="n">alphaCenter</span><span class="p">.</span><span class="n">x</span><span class="p">))</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">val</span> <span class="py">path</span> <span class="p">=</span> <span class="n">Path</span><span class="p">().</span><span class="n">apply</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">0</span> <span class="p">..</span> <span class="n">pointNumber</span> <span class="p">*</span> <span class="m">2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">val</span> <span class="py">r</span> <span class="p">=</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="p">%</span> <span class="m">2</span> <span class="p">==</span> <span class="m">1</span><span class="p">)</span> <span class="n">radius</span> <span class="k">else</span> <span class="n">innerRadius</span>
</span><span class='line'>            <span class="k">val</span> <span class="py">omega</span> <span class="p">=</span> <span class="n">angle</span> <span class="p">*</span> <span class="n">i</span> <span class="p">+</span> <span class="n">beta</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">val</span> <span class="py">x</span> <span class="p">=</span> <span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="p">+</span> <span class="n">r</span> <span class="p">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>
</span><span class='line'>            <span class="k">val</span> <span class="py">y</span> <span class="p">=</span> <span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="p">+</span> <span class="n">r</span> <span class="p">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">omega</span><span class="p">)</span>
</span><span class='line'>            <span class="n">lineTo</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">close</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">drawPath</span><span class="p">(</span>
</span><span class='line'>        <span class="n">path</span> <span class="p">=</span> <span class="n">path</span><span class="p">,</span>
</span><span class='line'>        <span class="n">color</span> <span class="p">=</span> <span class="n">color</span><span class="p">,</span>
</span><span class='line'>        <span class="n">style</span> <span class="p">=</span> <span class="n">Fill</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>为了检查画图结果是否符合设计，我们可以画出制法中的那样的格子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">DEBUG</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">strokeWidth</span> <span class="p">=</span> <span class="m">0.8</span><span class="p">.</span><span class="n">dp</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Slice</span>
</span><span class='line'>        <span class="n">drawLine</span><span class="p">(</span>
</span><span class='line'>            <span class="n">Color</span><span class="p">.</span><span class="n">Black</span><span class="p">,</span>
</span><span class='line'>            <span class="n">Offset</span><span class="p">(</span><span class="n">stickWidth</span><span class="p">.</span><span class="n">toPx</span><span class="p">(),</span> <span class="n">flagHeight</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">/</span> <span class="m">2f</span><span class="p">),</span>
</span><span class='line'>            <span class="n">Offset</span><span class="p">(</span><span class="n">flagWidth</span><span class="p">.</span><span class="n">toPx</span><span class="p">(),</span> <span class="n">flagHeight</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">/</span> <span class="m">2f</span><span class="p">),</span>
</span><span class='line'>            <span class="n">strokeWidth</span> <span class="p">=</span> <span class="n">strokeWidth</span> <span class="p">*</span> <span class="m">2f</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">drawLine</span><span class="p">(</span>
</span><span class='line'>            <span class="n">Color</span><span class="p">.</span><span class="n">Black</span><span class="p">,</span>
</span><span class='line'>            <span class="n">Offset</span><span class="p">(</span><span class="n">flagWidth</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">/</span> <span class="m">2f</span><span class="p">,</span> <span class="m">0f</span><span class="p">),</span>
</span><span class='line'>            <span class="n">Offset</span><span class="p">(</span><span class="n">flagWidth</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">/</span> <span class="m">2f</span><span class="p">,</span> <span class="n">flagHeight</span><span class="p">.</span><span class="n">toPx</span><span class="p">()),</span>
</span><span class='line'>            <span class="n">strokeWidth</span> <span class="p">=</span> <span class="n">strokeWidth</span> <span class="p">*</span> <span class="m">2f</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Grid</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">1</span> <span class="n">until</span> <span class="m">10</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">drawLine</span><span class="p">(</span>
</span><span class='line'>                <span class="n">Color</span><span class="p">.</span><span class="n">Black</span><span class="p">,</span>
</span><span class='line'>                <span class="n">Offset</span><span class="p">(</span><span class="n">stickWidth</span><span class="p">.</span><span class="n">toPx</span><span class="p">(),</span> <span class="n">flagHeight</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">*</span> <span class="n">i</span> <span class="p">/</span> <span class="m">20f</span><span class="p">),</span>
</span><span class='line'>                <span class="n">Offset</span><span class="p">(</span><span class="n">flagWidth</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">/</span> <span class="m">2f</span><span class="p">,</span> <span class="n">flagHeight</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">*</span> <span class="n">i</span> <span class="p">/</span> <span class="m">20f</span><span class="p">),</span>
</span><span class='line'>                <span class="n">strokeWidth</span> <span class="p">=</span> <span class="n">strokeWidth</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="m">1</span> <span class="n">until</span> <span class="m">14</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">drawLine</span><span class="p">(</span>
</span><span class='line'>                <span class="n">Color</span><span class="p">.</span><span class="n">Black</span><span class="p">,</span>
</span><span class='line'>                <span class="n">Offset</span><span class="p">(</span><span class="n">stickWidth</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">+</span> <span class="n">flagWidth</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">*</span> <span class="n">i</span> <span class="p">/</span> <span class="m">30f</span><span class="p">,</span> <span class="m">0f</span><span class="p">),</span>
</span><span class='line'>                <span class="n">Offset</span><span class="p">(</span><span class="n">stickWidth</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">+</span> <span class="n">flagWidth</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">*</span> <span class="n">i</span> <span class="p">/</span> <span class="m">30f</span><span class="p">,</span> <span class="n">flagHeight</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">/</span> <span class="m">2f</span><span class="p">),</span>
</span><span class='line'>                <span class="n">strokeWidth</span> <span class="p">=</span> <span class="n">strokeWidth</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>   <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>拿带格子的效果图，与制法设计图对比，可以发现一模一样，完全符合设计。</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/flag_with_grid.png" alt="图4. 带格子的效果图" /></p>

<p>好了，到这里，我们的五星红旗就画完了。未完，别走啊，我们还要让旗子飘扬起来。</p>

<h2>让五星红旗飘扬起来</h2>

<p>旗子飘扬的真实形态是三维的曲面，比如用三角函数曲面计算每一个坐标点x, y, z，就像<a href="https://juejin.cn/post/7206950454098247736">这篇文章</a>中的做法那样。</p>

<p>但在Compose中无法实现，因为Compose，虽然也可以做三维的变幻，但都是针对整个图层的，没有办法针对图形中的每个坐标点去单独做变幻，这也是与三维图形库如OpenGL ES的最大区别。</p>

<p>在Compose中要想每个坐标点都不一样，只能绘制曲线，曲线 的点再由动画动态的去改变，这样就会有类似波动一样的效果，但都局限在二维。为此，我们需要用Path来画背景，上边和下边都用曲线，曲线的点用动画来不断的波动，这样就能有点波动的感觉了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">infiniteTransition</span> <span class="p">=</span> <span class="n">rememberInfiniteTransition</span><span class="p">(</span><span class="n">label</span> <span class="p">=</span> <span class="s">&quot;infinite transition&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="py">amplitude</span> <span class="p">=</span> <span class="n">with</span><span class="p">(</span><span class="n">LocalDensity</span><span class="p">.</span><span class="n">current</span><span class="p">)</span> <span class="p">{</span> <span class="n">height</span><span class="p">.</span><span class="n">div</span><span class="p">(</span><span class="m">8f</span><span class="p">).</span><span class="n">toPx</span><span class="p">()</span> <span class="p">}</span>
</span><span class='line'><span class="k">val</span> <span class="py">heightPx</span> <span class="p">=</span> <span class="n">with</span><span class="p">(</span><span class="n">LocalDensity</span><span class="p">.</span><span class="n">current</span><span class="p">)</span> <span class="p">{</span> <span class="n">height</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="py">waveDuration</span> <span class="p">=</span> <span class="m">2000</span>
</span><span class='line'><span class="k">val</span> <span class="py">ya</span> <span class="k">by</span> <span class="n">infiniteTransition</span><span class="p">.</span><span class="n">animateFloat</span><span class="p">(</span>
</span><span class='line'>    <span class="n">initialValue</span> <span class="p">=</span> <span class="n">amplitude</span> <span class="p">/</span> <span class="m">2f</span><span class="p">,</span>
</span><span class='line'>    <span class="n">targetValue</span> <span class="p">=</span> <span class="p">-</span><span class="n">amplitude</span> <span class="p">/</span> <span class="m">2f</span><span class="p">,</span>
</span><span class='line'>    <span class="n">animationSpec</span> <span class="p">=</span> <span class="n">infiniteRepeatable</span><span class="p">(</span><span class="n">tween</span><span class="p">(</span><span class="n">waveDuration</span><span class="p">),</span> <span class="n">RepeatMode</span><span class="p">.</span><span class="n">Reverse</span><span class="p">),</span>
</span><span class='line'>    <span class="n">label</span> <span class="p">=</span> <span class="s">&quot;ya&quot;</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'><span class="k">val</span> <span class="py">yb</span> <span class="k">by</span> <span class="n">infiniteTransition</span><span class="p">.</span><span class="n">animateFloat</span><span class="p">(</span>
</span><span class='line'>    <span class="n">initialValue</span> <span class="p">=</span> <span class="p">-</span><span class="n">amplitude</span> <span class="p">/</span> <span class="m">2f</span><span class="p">,</span>
</span><span class='line'>    <span class="n">targetValue</span> <span class="p">=</span> <span class="n">amplitude</span> <span class="p">/</span> <span class="m">2f</span><span class="p">,</span>
</span><span class='line'>    <span class="n">animationSpec</span> <span class="p">=</span> <span class="n">infiniteRepeatable</span><span class="p">(</span><span class="n">tween</span><span class="p">(</span><span class="n">waveDuration</span><span class="p">),</span> <span class="n">RepeatMode</span><span class="p">.</span><span class="n">Reverse</span><span class="p">),</span>
</span><span class='line'>    <span class="n">label</span> <span class="p">=</span> <span class="s">&quot;yb&quot;</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'><span class="k">val</span> <span class="py">yc</span> <span class="k">by</span> <span class="n">infiniteTransition</span><span class="p">.</span><span class="n">animateFloat</span><span class="p">(</span>
</span><span class='line'>    <span class="n">initialValue</span> <span class="p">=</span> <span class="n">amplitude</span> <span class="p">/</span> <span class="m">2f</span><span class="p">,</span>
</span><span class='line'>    <span class="n">targetValue</span> <span class="p">=</span> <span class="p">-</span><span class="n">amplitude</span> <span class="p">/</span> <span class="m">2f</span><span class="p">,</span>
</span><span class='line'>    <span class="n">animationSpec</span> <span class="p">=</span> <span class="n">infiniteRepeatable</span><span class="p">(</span><span class="n">tween</span><span class="p">(</span><span class="n">waveDuration</span><span class="p">),</span> <span class="n">RepeatMode</span><span class="p">.</span><span class="n">Reverse</span><span class="p">),</span>
</span><span class='line'>    <span class="n">label</span> <span class="p">=</span> <span class="s">&quot;yc&quot;</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="py">ye</span> <span class="k">by</span> <span class="n">infiniteTransition</span><span class="p">.</span><span class="n">animateFloat</span><span class="p">(</span>
</span><span class='line'>    <span class="n">initialValue</span> <span class="p">=</span> <span class="n">heightPx</span> <span class="p">+</span> <span class="n">amplitude</span> <span class="p">/</span> <span class="m">2f</span><span class="p">,</span>
</span><span class='line'>    <span class="n">targetValue</span> <span class="p">=</span> <span class="n">heightPx</span> <span class="p">-</span> <span class="n">amplitude</span> <span class="p">/</span> <span class="m">2f</span><span class="p">,</span>
</span><span class='line'>    <span class="n">animationSpec</span> <span class="p">=</span> <span class="n">infiniteRepeatable</span><span class="p">(</span><span class="n">tween</span><span class="p">(</span><span class="n">waveDuration</span><span class="p">),</span> <span class="n">RepeatMode</span><span class="p">.</span><span class="n">Reverse</span><span class="p">),</span>
</span><span class='line'>    <span class="n">label</span> <span class="p">=</span> <span class="s">&quot;ye&quot;</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'><span class="k">val</span> <span class="py">yf</span> <span class="k">by</span> <span class="n">infiniteTransition</span><span class="p">.</span><span class="n">animateFloat</span><span class="p">(</span>
</span><span class='line'>    <span class="n">initialValue</span> <span class="p">=</span> <span class="n">heightPx</span> <span class="p">-</span> <span class="n">amplitude</span> <span class="p">/</span> <span class="m">2f</span><span class="p">,</span>
</span><span class='line'>    <span class="n">targetValue</span> <span class="p">=</span> <span class="n">heightPx</span> <span class="p">+</span> <span class="n">amplitude</span> <span class="p">/</span> <span class="m">2f</span><span class="p">,</span>
</span><span class='line'>    <span class="n">animationSpec</span> <span class="p">=</span> <span class="n">infiniteRepeatable</span><span class="p">(</span><span class="n">tween</span><span class="p">(</span><span class="n">waveDuration</span><span class="p">),</span> <span class="n">RepeatMode</span><span class="p">.</span><span class="n">Reverse</span><span class="p">),</span>
</span><span class='line'>    <span class="n">label</span> <span class="p">=</span> <span class="s">&quot;yf&quot;</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'><span class="k">val</span> <span class="py">yg</span> <span class="k">by</span> <span class="n">infiniteTransition</span><span class="p">.</span><span class="n">animateFloat</span><span class="p">(</span>
</span><span class='line'>    <span class="n">initialValue</span> <span class="p">=</span> <span class="n">heightPx</span> <span class="p">+</span> <span class="n">amplitude</span> <span class="p">/</span> <span class="m">2f</span><span class="p">,</span>
</span><span class='line'>    <span class="n">targetValue</span> <span class="p">=</span> <span class="n">heightPx</span> <span class="p">-</span> <span class="n">amplitude</span> <span class="p">/</span> <span class="m">2f</span><span class="p">,</span>
</span><span class='line'>    <span class="n">animationSpec</span> <span class="p">=</span> <span class="n">infiniteRepeatable</span><span class="p">(</span><span class="n">tween</span><span class="p">(</span><span class="n">waveDuration</span><span class="p">),</span> <span class="n">RepeatMode</span><span class="p">.</span><span class="n">Reverse</span><span class="p">),</span>
</span><span class='line'>    <span class="n">label</span> <span class="p">=</span> <span class="s">&quot;yg&quot;</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">Canvas</span><span class="p">(</span>
</span><span class='line'>    <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="n">canvasWidth</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">stickOffset</span> <span class="p">=</span> <span class="n">Offset</span><span class="p">(</span><span class="n">stickWidth</span><span class="p">.</span><span class="n">toPx</span><span class="p">(),</span> <span class="m">0f</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// The background</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">pathBG</span> <span class="p">=</span> <span class="n">Path</span><span class="p">().</span><span class="n">apply</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">moveTo</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">0f</span><span class="p">)</span>
</span><span class='line'>        <span class="n">cubicTo</span><span class="p">(</span><span class="n">flagWidth</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">/</span> <span class="m">3f</span><span class="p">,</span> <span class="n">ya</span><span class="p">,</span> <span class="n">flagWidth</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">*</span> <span class="m">2f</span> <span class="p">/</span> <span class="m">3f</span><span class="p">,</span> <span class="n">yb</span><span class="p">,</span> <span class="n">flagWidth</span><span class="p">.</span><span class="n">toPx</span><span class="p">(),</span> <span class="n">yc</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">lineTo</span><span class="p">(</span><span class="n">flagWidth</span><span class="p">.</span><span class="n">toPx</span><span class="p">(),</span> <span class="n">ye</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">cubicTo</span><span class="p">(</span><span class="n">flagWidth</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">*</span> <span class="m">2f</span> <span class="p">/</span> <span class="m">3f</span><span class="p">,</span> <span class="n">yf</span><span class="p">,</span> <span class="n">flagWidth</span><span class="p">.</span><span class="n">toPx</span><span class="p">()</span> <span class="p">/</span> <span class="m">3f</span><span class="p">,</span> <span class="n">yg</span><span class="p">,</span> <span class="m">0f</span><span class="p">,</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">lineTo</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">0f</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">translate</span><span class="p">(</span><span class="n">stickOffset</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">drawPath</span><span class="p">(</span><span class="n">path</span> <span class="p">=</span> <span class="n">pathBG</span><span class="p">,</span> <span class="n">color</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Red</span><span class="p">,</span> <span class="n">style</span> <span class="p">=</span> <span class="n">Fill</span><span class="p">)</span>
</span><span class='line'>   <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>也可以用GraphicsLayer，再添加一点点Y轴和Z轴的旋转，就更像那么回事了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">rotateY</span> <span class="k">by</span> <span class="n">infiniteTransition</span><span class="p">.</span><span class="n">animateFloat</span><span class="p">(</span>
</span><span class='line'>        <span class="n">initialValue</span> <span class="p">=</span> <span class="p">-</span><span class="m">3f</span><span class="p">,</span>
</span><span class='line'>        <span class="n">targetValue</span> <span class="p">=</span> <span class="m">6f</span><span class="p">,</span>
</span><span class='line'>        <span class="n">animationSpec</span> <span class="p">=</span> <span class="n">infiniteRepeatable</span><span class="p">(</span><span class="n">tween</span><span class="p">(</span><span class="m">3000</span><span class="p">),</span> <span class="n">RepeatMode</span><span class="p">.</span><span class="n">Reverse</span><span class="p">),</span>
</span><span class='line'>        <span class="n">label</span> <span class="p">=</span> <span class="s">&quot;rotateY&quot;</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="n">Canvas</span><span class="p">(</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>            <span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="n">canvasWidth</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>
</span><span class='line'>            <span class="p">.</span><span class="n">graphicsLayer</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">transformOrigin</span> <span class="p">=</span> <span class="n">TransformOrigin</span><span class="p">(</span><span class="m">0f</span><span class="p">,</span> <span class="m">0f</span><span class="p">)</span>
</span><span class='line'>                <span class="n">rotationZ</span> <span class="p">=</span> <span class="m">2f</span>
</span><span class='line'>                <span class="n">rotationY</span> <span class="p">=</span> <span class="n">rotateY</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>至此，我们的五星红旗就算做完了，当然了可对背景的左边和右边也加上波动，就会更像一些了，完整代码可以<a href="https://github.com/alexhilton/EffectiveCompose/blob/main/app/src/main/java/net/toughcoder/effectivecompose/WavingFlag.kt">看这里</a>。</p>

<p>让我们小结一下，看似简单的一个五星红旗，实现起来其实并不容易，用到了好多数学知识，书到用时方恨少，数学真的太重要了，无处不在。UI开发会涉及大量的数学（特别是几何）知识，要想做好UI必须 要有良好的数学功底，难度并不小。</p>

<h2>仅供娱乐，请勿参考</h2>

<p>以上的实现方式其实仅供娱乐，在真实的项目中不建议这样一笔一笔的用Canvas来画。建议的实现方式应该是找一个（或者让设计师提供）现成的五星红旗图形资源，然后当成图片来展示 出来。</p>

<p>这样做的好处是把设计与代码实现分离开来，当需要调整设计效果时，不必去修改代码，毕竟替换一个资源比起修改代码的风险要小很多，虽然说可能也只是调整一个整数（颜色），但毕竟是改代码了，风险还是有的。再者，分离开来能让设计工作由更为专业的人士来做，而不必受到（或者考虑）代码实现的限制。还有就是，用代码一笔一笔的画，无论研发效率还是运行效率其实都不高，远不如显示一张图片性能好。</p>

<h2>最后</h2>

<p>祝愿伟大的祖国繁荣昌盛，国泰民安！祝愿所有的朋友国庆快乐，天天开心！</p>

<h2>References</h2>

<ul>
<li><a href="https://codepen.io/jonkemp/pen/EVgaLR">Five-pointed star using CSS</a></li>
<li><a href="https://stackoverflow.com/questions/14580033/algorithm-for-drawing-a-5-point-star">Algorithm for drawing a 5 point star</a></li>
<li><a href="https://www.instructables.com/How-to-draw-a-5-point-star/">How to Draw a 5-point Star</a></li>
<li><a href="https://codepen.io/udit007/pen/XWJooNQ">Waving Flag animation with CSS</a></li>
<li><a href="https://codepen.io/christopheschwyzer/pen/nMoWBa">CSS3 Waving Flags</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搞定在Jetpack Compose中优雅地申请运行时权限]]></title>
    <link href="https://alexhilton.github.io/blog/2024/09/27/handle-permissions-in-compose/"/>
    <updated>2024-09-27T08:36:47+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/09/27/handle-permissions-in-compose</id>
    <content type="html"><![CDATA[<p>随着安全与隐私问题越来越被人们所重视，操作系统对应用程序的限制也越来越严格。一个非常明显的控制就是对于运行时权限（Runtime permissions）的管控是越来越严格，很多原本不需要权限的地方也需要了权限。这就要求应用程序必须能够灵活的处理运行时权限。Jetpack Compose作为一个独立于平台的声明式UI框架，本身并没有权限的概念，权限是平台强相关的，本文将研究一下如何在Compose中优雅的申请运行时权限。</p>

<p><a href="https://alexhilton.github.io/blog/2024/09/27/handle-permissions-in-compose/"><img src="https://img-blog.csdnimg.cn/9f802deb822f45a794a15fd9de4bc42d.png" title="auto auto" ></a></p>

<!-- more -->


<p><strong>注意：</strong> 这里提到的权限都是运行时权限，也就是需要在访问某些API之前动态地向用户申请授权许可。</p>

<h2>运行时权限申请用例</h2>

<p>有过Android开发经验的同学对运行时权限申请一定不陌生。自从Android Marshmallow（6.0，API Level 23）开始，对于一些敏感的权限，除了在应用的Manifest中声明以外，还需要在运行时动态的<a href="https://developer.android.com/training/permissions/requesting">向用户申请使用权限</a>，只有在用户同意授权后才可以使用相关的功能，当然用户也可能会拒绝。自此，运行时的权限申请就变成了应用开发的一个标配了。</p>

<p>比如以相机权限为例，第一步，要先在AndroidManifest中声明权限使用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;manifest</span> <span class="na">xmlns:android=</span><span class="s">&quot;http://schemas.android.com/apk/res/android&quot;</span>
</span><span class='line'>    <span class="na">xmlns:tools=</span><span class="s">&quot;http://schemas.android.com/tools&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>    <span class="nt">&lt;uses-permission</span> <span class="na">android:name=</span><span class="s">&quot;android.permission.CAMERA&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>    <span class="nt">&lt;application</span>
</span><span class='line'>        <span class="err">...</span>
</span><span class='line'>    <span class="err">&lt;/application</span><span class="nt">&gt;</span>
</span><span class='line'><span class="nt">&lt;/manifest&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>之后第二步，在要使用相机的入口地方，也就是要访问相机API的入口处先进行权限检查，如果已授予，则走正常的逻辑（如打开相机），否则进行权限申请：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="c1">// 调用相机的入口处</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">ContextCompat</span><span class="p">.</span><span class="n">checkSelfPermission</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">Manifest</span><span class="p">.</span><span class="n">permission</span><span class="p">.</span><span class="n">CAMERA</span><span class="p">)</span> <span class="p">==</span> <span class="n">PackageManager</span><span class="p">.</span><span class="n">PERMISSION_GRANTED</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">happyWithCamera</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 提示用户需要权限，然后申请权限</span>
</span><span class='line'>    <span class="n">ActivityCompat</span><span class="p">.</span><span class="n">requestPermissions</span><span class="p">(</span><span class="n">context</span><span class="p">,</span>  <span class="n">arrayOf</span><span class="p">(</span><span class="n">Manifest</span><span class="p">.</span><span class="n">permission</span><span class="p">.</span><span class="n">CAMERA</span><span class="p">),</span> <span class="m">1024</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>权限申请会离开当前的页面，进入到系统的权限处理逻辑。然后第三步，在系统权限回调中（类似于onActivityResult）检查用户权限授予结果，如果已授予则走第二步中的正常逻辑，否则，弹窗提示用户，解释权限对于应用程序的必要性，视权限的必要程度和交互逻辑，可以再次申请权限或者走无权限的逻辑（假如部分功能还可用）或者直接退出：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="c1">// 系统权限回调，类似于onActivityResult</span>
</span><span class='line'><span class="n">@Override</span>
</span><span class='line'><span class="k">public</span> <span class="n">void</span> <span class="n">onRequestPermissionResult</span><span class="p">(</span><span class="n">int</span> <span class="n">reqCode</span><span class="p">,</span> <span class="n">@NonNull</span> <span class="n">String</span><span class="p">[]</span> <span class="n">perms</span><span class="p">,</span> <span class="n">@NonNull</span> <span class="n">int</span><span class="p">[]</span> <span class="n">results</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">super</span><span class="p">.</span><span class="n">onRequestPermissionResult</span><span class="p">(</span><span class="n">reqCode</span><span class="p">,</span> <span class="n">perms</span><span class="p">,</span> <span class="n">results</span><span class="p">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">reqCode</span> <span class="p">==</span> <span class="m">1024</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">results</span><span class="p">.</span><span class="n">length</span> <span class="p">&gt;</span> <span class="m">1</span> <span class="p">&amp;&amp;</span> <span class="n">results</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">==</span> <span class="n">PackageManager</span><span class="p">.</span><span class="n">PERMISSION_GRANTED</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// 用户授权了，可以使用相机了</span>
</span><span class='line'>            <span class="n">happyWithCamera</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// 权限被用户拒绝，有三种做法：</span>
</span><span class='line'>            <span class="c1">// 1. 如果是必须的权限，可再次申请；</span>
</span><span class='line'>            <span class="c1">// 2. 如果已被拒绝多次，或者不想再次申请，那就提示用户然后退出</span>
</span><span class='line'>            <span class="c1">// 3. 如果是非必须权限，那就走剩余的流程</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果是多个权限，处理的方式也是一样的，因为申请权限以及权限回调中都是数组，也即是可以处理多个权限。</p>

<p>对于在何时着手处理权限，要视权限对业务逻辑的重要程度，如果是必须的权限（如Location于地图应用，Camera于相机应用）那应该在应用启动时，加载任何页面之前作为第一件事情去做；如果不是，非主要业务逻辑，如微信或者支付宝的扫码功能，绝大多数应用都有扫码功能但都非其主要业务逻辑，那应该在用户启动扫码功能时去处理相机权限。</p>

<h2>以原生方式申请运行时权限</h2>

<p>让我们回到Compose世界，因为在Jetpack Compose中没有权限的概念，因此要把原生的权限处理方式在Composable中完成。第一步权限的声明仍需要在应用程序的Manifest中来做，这一步是没有变化的。</p>

<p>第二步和第三步有些麻烦，Compose是由一坨坨的composable函数组成的，我们只能调用其他的函数，没有办法处理权限回调，这是Activity的一个public方法，不是可以设置的常规回调，因为我们没有办法创建Activity的实例。另外前面的例子中请求权限会用到Activity，而在Compossable中不应该去尝试获取Activity，虽然是可以拿到实例的，但作为一个独立的UI框架不应该去拿平台强相关的且生命周期不可控的对象实例。</p>

<p>这里就可以通过一个叫做<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultLauncher">ActivityResultLancher</a>来对Activity的跳转和onActivityResult进行封装，创建一个ActivityResultLancher实例，设置一个onResult回调来处理onActivityResult，这个launcher也可以用来启动新的Activity。本质上与覆写Activity的方法也是一样的，但最重要的是我们可以自主的创建ActivityResultLancher对象，这样就可以在纯函数式的composable中使用了。ActivityResultLancher可以应对很多跳转场景，由<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContract">ActivityResultContract</a>对象来定义，已经有很多预定义类型了，对于申请权限要使用<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContracts.RequestPermission">RequestPermission</a>。</p>

<p>仍是以相机权限为例，假定是一个相机权限强必须的拍照应用，可以在应用的入口处定义PermissionInterceptor来处理权限：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">MainActivity</span> <span class="p">:</span> <span class="n">ComponentActivity</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="n">Bundle</span><span class="p">?)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">super</span><span class="p">.</span><span class="n">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">)</span>
</span><span class='line'>        <span class="n">setContent</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">HelloComposeTheme</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">// A surface container using the &#39;background&#39; color from the theme</span>
</span><span class='line'>                <span class="n">Surface</span><span class="p">(</span>
</span><span class='line'>                    <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">(),</span>
</span><span class='line'>                    <span class="n">color</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">colorScheme</span><span class="p">.</span><span class="n">background</span>
</span><span class='line'>                <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">PermissionInterceptor</span><span class="p">(</span>
</span><span class='line'>                        <span class="n">content</span> <span class="p">=</span> <span class="p">{</span>
</span><span class='line'>                            <span class="n">Text</span><span class="p">(</span><span class="s">&quot;Happy with Camera!&quot;</span><span class="p">)</span>
</span><span class='line'>                        <span class="p">},</span>
</span><span class='line'>                        <span class="n">noPermission</span> <span class="p">=</span> <span class="p">{</span>
</span><span class='line'>                            <span class="n">Text</span><span class="p">(</span><span class="s">&quot;To use this app, you must grant CAMERA permission!&quot;</span><span class="p">)</span>
</span><span class='line'>                        <span class="p">}</span>
</span><span class='line'>                    <span class="p">)</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">@SuppressLint</span><span class="p">(</span><span class="s">&quot;LaunchDuringComposition&quot;</span><span class="p">)</span>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">PermissionInterceptor</span><span class="p">(</span>
</span><span class='line'>    <span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">,</span>
</span><span class='line'>    <span class="n">content</span><span class="p">:</span> <span class="n">@Composable</span> <span class="n">BoxScope</span><span class="p">.()-&gt;</span><span class="n">Unit</span><span class="p">,</span>
</span><span class='line'>    <span class="n">noPermission</span><span class="p">:</span> <span class="n">@Composable</span> <span class="n">BoxScope</span><span class="p">.()-&gt;</span><span class="n">Unit</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">context</span> <span class="p">=</span> <span class="n">LocalContext</span><span class="p">.</span><span class="n">current</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">permission</span> <span class="p">=</span> <span class="n">Manifest</span><span class="p">.</span><span class="n">permission</span><span class="p">.</span><span class="n">CAMERA</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">var</span> <span class="py">isGranted</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">&lt;</span><span class="n">Boolean</span><span class="p">?&gt;(</span><span class="k">null</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">permissionLauncher</span> <span class="p">=</span> <span class="n">rememberLauncherForActivityResult</span><span class="p">(</span>
</span><span class='line'>        <span class="n">ActivityResultContracts</span><span class="p">.</span><span class="n">RequestPermission</span><span class="p">()</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span> <span class="n">granted</span> <span class="p">-&gt;</span>
</span><span class='line'>        <span class="n">isGranted</span> <span class="p">=</span> <span class="n">granted</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Box</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">modifier</span><span class="p">,</span> <span class="n">contentAlignment</span> <span class="p">=</span> <span class="n">Alignment</span><span class="p">.</span><span class="n">Center</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">isGranted</span> <span class="p">==</span> <span class="k">true</span> <span class="p">||</span>
</span><span class='line'>            <span class="n">ContextCompat</span><span class="p">.</span><span class="n">checkSelfPermission</span><span class="p">(</span>
</span><span class='line'>                <span class="n">context</span><span class="p">,</span>
</span><span class='line'>                <span class="n">permission</span>
</span><span class='line'>            <span class="p">)</span> <span class="p">==</span> <span class="n">PackageManager</span><span class="p">.</span><span class="n">PERMISSION_GRANTED</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">content</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">isGranted</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">LaunchedEffect</span><span class="p">(</span><span class="n">permissionLauncher</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">permissionLauncher</span><span class="p">.</span><span class="n">launch</span><span class="p">(</span><span class="n">permission</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">noPermission</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意是如果是像上面例子这样在应用的入口处时就检查并申请权限，需要把launcher包裹在副作用函数LauncherEffect中，否则会有『IllegalStateException: Launcher has not been initialized』，这是因为初始化工作并未做完，但如果是用户点击之后才会触发权限申请则不需要。</p>

<p>在实际项目中，可能不止一个权限需要申请。申请多个动态权限，流程逻辑也一样的，需要传入<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContracts.RequestMultiplePermissions">RequestMultiplePermissions</a>，以及参数和结果都是数组：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">MultiplePermissionsInterceptor</span><span class="p">(</span>
</span><span class='line'>    <span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">,</span>
</span><span class='line'>    <span class="n">content</span><span class="p">:</span> <span class="n">@Composable</span> <span class="n">BoxScope</span><span class="p">.()-&gt;</span><span class="n">Unit</span><span class="p">,</span>
</span><span class='line'>    <span class="n">noPermission</span><span class="p">:</span> <span class="n">@Composable</span> <span class="n">BoxScope</span><span class="p">.()-&gt;</span><span class="n">Unit</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">context</span> <span class="p">=</span> <span class="n">LocalContext</span><span class="p">.</span><span class="n">current</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">permissions</span> <span class="p">=</span> <span class="n">arrayOf</span><span class="p">(</span>
</span><span class='line'>                        <span class="n">Manifest</span><span class="p">.</span><span class="n">permission</span><span class="p">.</span><span class="n">CAMERA</span><span class="p">,</span>
</span><span class='line'>                        <span class="n">Manifest</span><span class="p">.</span><span class="n">permission</span><span class="p">.</span><span class="n">ACCESS_COARSE_LOCATION</span><span class="p">,</span>
</span><span class='line'>                        <span class="n">Manifest</span><span class="p">.</span><span class="n">permission</span><span class="p">.</span><span class="n">ACCESS_FINE_LOCATION</span>
</span><span class='line'>                    <span class="p">)</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">isGranted</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">&lt;</span><span class="n">Boolean</span><span class="p">?&gt;(</span><span class="k">null</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">permissionLauncher</span> <span class="p">=</span> <span class="n">rememberLauncherForActivityResult</span><span class="p">(</span>
</span><span class='line'>        <span class="n">ActivityResultContracts</span><span class="p">.</span><span class="n">RequestMultiplePermissions</span><span class="p">()</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span> <span class="n">granted</span> <span class="p">-&gt;</span>
</span><span class='line'>        <span class="n">isGranted</span> <span class="p">=</span> <span class="n">granted</span><span class="p">.</span><span class="n">all</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="n">value</span> <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Box</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">modifier</span><span class="p">,</span> <span class="n">contentAlignment</span> <span class="p">=</span> <span class="n">Alignment</span><span class="p">.</span><span class="n">Center</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">isGranted</span> <span class="p">==</span> <span class="k">true</span> <span class="p">||</span>
</span><span class='line'>            <span class="n">permissions</span><span class="p">.</span><span class="n">all</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">ContextCompat</span><span class="p">.</span><span class="n">checkSelfPermission</span><span class="p">(</span>
</span><span class='line'>                    <span class="n">context</span><span class="p">,</span>
</span><span class='line'>                    <span class="n">it</span>
</span><span class='line'>                <span class="p">)</span> <span class="p">==</span> <span class="n">PackageManager</span><span class="p">.</span><span class="n">PERMISSION_GRANTED</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">content</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">isGranted</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">LaunchedEffect</span><span class="p">(</span><span class="n">permissionLauncher</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">permissionLauncher</span><span class="p">.</span><span class="n">launch</span><span class="p">(</span><span class="n">permissions</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">noPermission</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>使用Accompanist-permissions</h2>

<p>事实上谷歌也在着手解决Compose中的权限处理问题，在<a href="https://google.github.io/accompanist/permissions/">accompanist库中有处理权限</a>的API。</p>

<blockquote><p><a href="https://google.github.io/accompanist/">Accompanist</a>是一个由谷歌提供的Jetpack Compose的补充库，也就是说一些开发者强烈需求的API，但还未正式放入Compose中，但谷歌也有意要提供，那么就会先放放Accompanist中，等开发完成试用很好，可能就会移入到Jetpack Compose中变成正式的API。Accompanist中能找到很多新奇的东西，比如像下拉刷新，流式布局，权限处理，WebView等等。但需要注意的是Accompanist多半是试验性的，API很不稳定，说变就变，说没就没，使用之前要三思。</p></blockquote>

<h3>配置accompanist-permission</h3>

<p>Accompanist是一个独立的库，而且拆分的很细，权限处理是一个独立的包：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">dependencies</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Accompanist permission</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">accompanistVersion</span> <span class="p">=</span> <span class="s">&quot;0.32.0&quot;</span>
</span><span class='line'>    <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;com.google.accompanist:accompanist-permissions:$accompanistVersion&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>使用Accompanist-permission</h3>

<p>既然是API自然在封装上会做的更好，使用起来更加的方便。Accompanist使用<a href="https://google.github.io/accompanist/api/permissions/com.google.accompanist.permissions/remember-permission-state.html">rememberPermissionState</a>和<a href="https://google.github.io/accompanist/api/permissions/com.google.accompanist.permissions/remember-multiple-permissions-state.html">rememberMultiplePermissionsState</a>返回一个状态<a href="https://google.github.io/accompanist/api/permissions/com.google.accompanist.permissions/-permission-state/index.html">PermissionState</a>，这个状态既可以检查权限申请结果，也可以去申请权限，体验丝般顺滑：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@OptIn</span><span class="p">(</span><span class="n">ExperimentalPermissionsApi</span><span class="o">::</span><span class="k">class</span><span class="p">)</span>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">AccompanistInterceptor</span><span class="p">(</span>
</span><span class='line'>    <span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">,</span>
</span><span class='line'>    <span class="n">content</span><span class="p">:</span> <span class="n">@Composable</span> <span class="n">BoxScope</span><span class="p">.()-&gt;</span><span class="n">Unit</span><span class="p">,</span>
</span><span class='line'>    <span class="n">noPermission</span><span class="p">:</span> <span class="n">@Composable</span> <span class="n">BoxScope</span><span class="p">.()-&gt;</span><span class="n">Unit</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">permissionState</span> <span class="p">=</span> <span class="n">rememberPermissionState</span><span class="p">(</span><span class="n">permission</span> <span class="p">=</span> <span class="n">Manifest</span><span class="p">.</span><span class="n">permission</span><span class="p">.</span><span class="n">CAMERA</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Box</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">modifier</span><span class="p">,</span> <span class="n">contentAlignment</span> <span class="p">=</span> <span class="n">Alignment</span><span class="p">.</span><span class="n">Center</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">permissionState</span><span class="p">.</span><span class="n">status</span><span class="p">.</span><span class="n">isGranted</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">content</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">permissionState</span><span class="p">.</span><span class="n">status</span><span class="p">.</span><span class="n">shouldShowRationale</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">noPermission</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">LaunchedEffect</span><span class="p">(</span><span class="n">permissionState</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">permissionState</span><span class="p">.</span><span class="n">launchPermissionRequest</span><span class="p">()</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>处理多个权限时用带有multiple字样的接口就可以了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@OptIn</span><span class="p">(</span><span class="n">ExperimentalPermissionsApi</span><span class="o">::</span><span class="k">class</span><span class="p">)</span>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">MultipleAccompanistInterceptor</span><span class="p">(</span>
</span><span class='line'>    <span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">,</span>
</span><span class='line'>    <span class="n">content</span><span class="p">:</span> <span class="n">@Composable</span> <span class="n">BoxScope</span><span class="p">.()-&gt;</span><span class="n">Unit</span><span class="p">,</span>
</span><span class='line'>    <span class="n">noPermission</span><span class="p">:</span> <span class="n">@Composable</span> <span class="n">BoxScope</span><span class="p">.()-&gt;</span><span class="n">Unit</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">permissions</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span>
</span><span class='line'>                        <span class="n">Manifest</span><span class="p">.</span><span class="n">permission</span><span class="p">.</span><span class="n">CAMERA</span><span class="p">,</span>
</span><span class='line'>                        <span class="n">Manifest</span><span class="p">.</span><span class="n">permission</span><span class="p">.</span><span class="n">ACCESS_COARSE_LOCATION</span><span class="p">,</span>
</span><span class='line'>                        <span class="n">Manifest</span><span class="p">.</span><span class="n">permission</span><span class="p">.</span><span class="n">ACCESS_FINE_LOCATION</span>
</span><span class='line'>                    <span class="p">)</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">permissionState</span> <span class="p">=</span> <span class="n">rememberMultiplePermissionsState</span><span class="p">(</span><span class="n">permissions</span> <span class="p">=</span> <span class="n">permissions</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Box</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">modifier</span><span class="p">,</span> <span class="n">contentAlignment</span> <span class="p">=</span> <span class="n">Alignment</span><span class="p">.</span><span class="n">Center</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">permissionState</span><span class="p">.</span><span class="n">allPermissionsGranted</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">content</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">permissionState</span><span class="p">.</span><span class="n">shouldShowRationale</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">noPermission</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">LaunchedEffect</span><span class="p">(</span><span class="n">permissionState</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">permissionState</span><span class="p">.</span><span class="n">launchMultiplePermissionRequest</span><span class="p">()</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p><strong>注意：</strong> 因为Accompanist库是实验性质的，所以它的API都要求带上注解&#64;OptIn(ExperimentalPermissionsApi::class)。</p></blockquote>

<p>扩展阅读：</p>

<ul>
<li><a href="https://medium.com/@rzmeneghelo/how-to-request-permissions-in-jetpack-compose-a-step-by-step-guide-7ce4b7782bd7">How to Request Permissions in Jetpack Compose: A Step-by-Step Guide</a></li>
<li><a href="https://www.paleblueapps.com/rockandnull/how-to-request-permissions-in-jetpack-compose/">Jetpack Compose Permissions: A Quick and Easy Guide</a></li>
<li><a href="https://blog.stackademic.com/the-best-way-of-managing-runtime-permissions-using-permissionhandler-in-jetpack-compose-adb8057577d4">The best way to manage the Runtime permissions using PermissionHandler in Jetpack Compose</a></li>
<li><a href="https://www.composables.com/tutorials/permissions">A comprehensive guide to Android runtime permissions using Jetpack Compose</a></li>
<li><a href="https://stackoverflow.com/questions/73898807/how-to-handle-runtime-permissions-in-jetpack-compose-properly-by-accompanist">How to handle runtime permissions in jetpack compose properly by accompanist?</a></li>
</ul>


<h2>总结</h2>

<p>本文详细了介绍了目标平台是Android时，Compose的两种运行时权限申请方式。推荐使用Accompanist库中的permission模块，虽然这会引入一个新的依赖，虽然它只是实验性的，毕竟用起来方便啊。当然，如果想要精细化的处理权限的各种结果就直接用原生方式，也并没有麻烦多少。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/training/permissions/requesting">Request runtime permissions</a></li>
<li><a href="https://betterprogramming.pub/jetpack-compose-request-permissions-in-two-ways-fd81c4a702c">2 Ways to Request Permissions in Jetpack Compose</a></li>
<li><a href="https://www.howtodoandroid.com/runtime-permission-on-jetpack-compose/">Best ways to handle runtime permission on jetpack compose</a></li>
<li><a href="https://www.freecodecamp.org/news/requesting-location-permissions-in-jetpack-compose/">How to Request Location Permissions in Jetpack Compose</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[轻松解决Jetpack Compose中的一些痛点问题]]></title>
    <link href="https://alexhilton.github.io/blog/2024/09/21/compose-best-practices/"/>
    <updated>2024-09-21T10:59:35+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/09/21/compose-best-practices</id>
    <content type="html"><![CDATA[<p>暑去秋来，金桂飘香，不知不觉中我们已经练完了<a href="https://juejin.cn/column/7367555191338467337">『降Compose十八掌』</a>，相信通过这一系列文章能够对Jetpack Compose有足够的理解，并能在实际项目中进行运用。今天将继续Compose之旅，总结一下Compose使用过程中经常会遇到的一些痛点问题，并学会如何优雅的解决这些问题。</p>

<p><a href="https://alexhilton.github.io/blog/2024/09/21/compose-best-practices/"><img src="https://innovationm.co/wp-content/uploads/2021/05/Jetpack-compose.png" title="auto auto" ></a></p>

<!-- more -->


<h2>定义slot时要注明布局作用域</h2>

<p>先来看一个比较常规的问题，Compose开发过程中，非常鼓励开发者把可以复用的部分抽象成为一个函数，然后接收一个尾部lambda作为参数进行差异化的定制。这种范式叫做<a href="https://developer.android.com/develop/ui/compose/layouts/basics#slot-based-layouts">slot模式</a>，slot模式的好处在于能够大大加强代码复用，开发者在构建UI的时候，像搭积木那样把一个一个的slot叠在一起。Compose自己的API中都大量的采用了这种模式。</p>

<p>为了让slot更加的通用，我们需要<strong>明确传入的lambda与slot之间的约定</strong>，这就要求我们对lamdba的类型进行严格的限制。</p>

<p>首先要添加注解&#64;Composable，这个是显而易见的，因为slot是为了绘制一些自定义UI元素而准备的，所以肯定是要加上&#64;Composable，否则在lambda中无法写UI，因为非Composable不能调用Compose的方法。</p>

<p>另外，不是那么明显的就是这个lamdba的类型，要指定<a href="https://kotlinlang.org/docs/lambdas.html#function-literals-with-receiver">其Receiver</a>，以限定它所在的布局。比如说slot是用在一个Column里面的，那么要给lamdba指定ColumnScope作为receiver，这样在实现lambada的时候就知道是作为Column的一部分，并且可以使用Column布局的特有相关参数，如左右居中和垂直排列：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="n">MyLayout</span><span class="p">(</span>
</span><span class='line'>     <span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span><span class="p">,</span>
</span><span class='line'>     <span class="n">content</span><span class="p">:</span> <span class="n">@Composable</span> <span class="n">ColumnScope</span><span class="p">.()-&gt;</span><span class="n">Unit</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="n">Column</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>          <span class="c1">// 共用的一部分</span>
</span><span class='line'>
</span><span class='line'>          <span class="n">content</span><span class="p">()</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 调用的地方</span>
</span><span class='line'><span class="n">MyLayout</span> <span class="p">{</span> <span class="c1">// this = ColumnScope</span>
</span><span class='line'>     <span class="c1">// 隐式this指针指向一个ColumnScope对象，就像在一个Column中一样</span>
</span><span class='line'>     <span class="c1">// 定制的部分</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>UI元素很多都会涉及到居中，对齐的调整，以及内部元素的排列，而对齐和排列又会明确的受到所在父布局的影响，比如说Box与Column的对齐和排列方式就是不同的。所以在使用slot时一定要明确 标注它所在的布局，以让调用者能够明确地知道lambda所在的布局作用域。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://chrisbanes.me/posts/slotting-in-with-compose-ui/">Slotting in with Compose UI</a></li>
<li><a href="https://www.valueof.io/blog/compose-slot-api-example-composable-content-lambda">Practical Compose Slot API example</a></li>
<li><a href="https://proandroiddev.com/designing-slot-apis-in-jetpack-compose-4a981ddbc776">Designing Slot APIs in Jetpack Compose</a></li>
<li><a href="https://tech.pic-collage.com/%E5%88%9D%E6%8E%A2-jetpack-compose-slot-api-8d3f153f77e3">初探 Jetpack Compose — Slot API</a></li>
</ul>


<h2>如何在ViewModel中使用平台相关的资源</h2>

<p>我们在<a href="https://juejin.cn/post/7411812014047461387">降Compose十八掌之『神龙摆尾』| Architecture</a>中讨论过，ViewModel作为Domain层，目的是把逻辑尽可能的从UI层中抽出来，让UI尽可能的只做UI渲染。ViewModel也要做到平台独立，这样才方便移植和测试。ViewModel中吐出来的数据要是加工过的可以直接方便地在UI层展示的数据，如字符串或者图片。</p>

<p>但有一个问题，资源文件如何管理都是平台强相关的。对于要展示给用户的文案，也不可能直接把字符串传给UI，因为UI语言都要能够本地化以适应不同的国家和地区，当然了如果说不需要考虑多语言的问题，比如我的应用只给某一个语言使用，那当然也可以直接把处理好的字符串当作UiState传给UI层。</p>

<p>最为理想的解决方案就是ViewModel层定义一些<strong>状态码</strong>，对应着不同的提示语言，由UI负责一一对应的，把状态码再转成字符串。对于其他的资源也可以采用类似方式处理。这是从ViewModel输出到UI层的情况。</p>

<p>还会反过来，对于需要从UI层输入到ViewModel的资源，也是要<strong>去除平台的相关性</strong>，比如转成ViewModel中定义的状态码，或者转成原始数据类型String，或者转成平台无关的输入输出流等等。</p>

<h3>字符串资源</h3>

<p>对于Android平台来说，可以用一个简单的方式来解决字符串资源问题，因为资源的引用是一个整数，所以可以直接把资源的ID当作字段传给UI，Compose拿到后直接用函数stringResource取出来就可以了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">data</span> <span class="k">class</span> <span class="nc">UiState</span><span class="p">(</span>
</span><span class='line'>     <span class="k">val</span> <span class="py">loading</span><span class="p">:</span> <span class="n">Boolean</span> <span class="p">=</span> <span class="k">false</span><span class="p">,</span>
</span><span class='line'>     <span class="n">@StringRes</span> <span class="k">val</span> <span class="py">errorMsg</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">HomeViewModel</span> <span class="p">{</span>
</span><span class='line'>     <span class="k">val</span> <span class="py">timeout</span> <span class="p">=</span> <span class="n">UiState</span><span class="p">(</span><span class="k">false</span><span class="p">,</span> <span class="n">R</span><span class="p">.</span><span class="n">string</span><span class="p">.</span><span class="n">error_message_timeout</span><span class="p">)</span>
</span><span class='line'>     <span class="n">_state</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 在Compose中</span>
</span><span class='line'><span class="n">HomeScreen</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Text</span><span class="p">(</span><span class="n">stringResource</span><span class="p">(</span><span class="n">uiState</span><span class="p">.</span><span class="n">errorMsg</span><span class="p">))</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>虽然说这并不太通用，因为换成其他平台时可能不是用资源ID来获取资源，但转成状态码的方式也会很容易，所以问题不大。</p>

<p>如果是输入的话，在Compose中直接读取资源变成String传给ViewModel就好了。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://stackoverflow.com/questions/47628646/how-should-i-get-resourcesr-string-in-viewmodel-in-android-mvvm-and-databindi">How should I get Resources(R.string) in viewModel in Android (MVVM and databinding)</a></li>
<li><a href="https://medium.com/@margin555/using-string-resources-in-a-viewmodel-e334611b73da">Using String Resources in a ViewModel</a></li>
</ul>


<h3>图片资源</h3>

<p>图片资源一般来说都是UI自己指定，但有些时候可能会有逻辑，比如一些需要经过运算才能得到的复杂的状态，其代表的Icon，由ViewModel来直接指定要好一些。图片资源也可以直接使用资源ID，然后在Compose中使用painterResource来获取：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">data</span> <span class="k">class</span> <span class="nc">UiState</span><span class="p">(</span>
</span><span class='line'>     <span class="n">@DrawableRes</span> <span class="k">val</span> <span class="py">icon</span><span class="p">:</span> <span class="n">Int</span> <span class="p">=</span> <span class="m">0</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// in ViewModel</span>
</span><span class='line'><span class="k">val</span> <span class="py">state</span> <span class="p">=</span> <span class="n">UiState</span><span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">drawable</span><span class="p">.</span><span class="n">ic_windy</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// in Compose</span>
</span><span class='line'><span class="n">Icon</span><span class="p">(</span><span class="n">painterResource</span><span class="p">(</span><span class="n">uiState</span><span class="p">.</span><span class="n">icon</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果是输入的话，可以在Compose中把图片资源转成输入流传给ViewModel去处理。</p>

<h3>其他资源</h3>

<p>其他资源如dimen或者color，也可以如法炮制。</p>

<p>输入的话，对于普通的资源像字符串资源，dimen或者color等读出来转成基础数据类型String，Int或者Array传给ViewModel就好。而像比较麻烦的资源，如Assets中的资源，就转成输入流传给ViewModel处理。</p>

<h2>如何在常规函数中调用Composables</h2>

<p>在Compose的开发过程中最为令人不爽的地方在于Compose 的API，只能在被注解&#64;Composable标注的函数中调用，其他地方是无法调用的。一般来说，这个问题也不大，因为Compose的入口是肯定是一个composable啊，一坨坨的composables的调用最终<a href="https://juejin.cn/post/7407643004490956810">会生成UI树</a>。</p>

<p>但有些地方却跑出了Composable之外，比如像很多UI元素的事件响应，比如<a href="https://developer.android.com/develop/ui/compose/components/button">Button</a>，它的事件响应onClick接收的就是一个普通的lambda：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">MainContent</span><span class="p">(</span>
</span><span class='line'>    <span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">,</span>
</span><span class='line'>    <span class="n">serviceOn</span><span class="p">:</span> <span class="n">Boolean</span><span class="p">,</span>
</span><span class='line'>    <span class="n">context</span><span class="p">:</span> <span class="n">Context</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Column</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Button</span><span class="p">(</span>
</span><span class='line'>            <span class="n">onClick</span> <span class="p">=</span> <span class="p">{</span> <span class="n">AccessibilityHelper</span><span class="p">.</span><span class="n">gotoChronosSettings</span><span class="p">(</span><span class="n">context</span><span class="p">)</span> <span class="p">},</span>
</span><span class='line'>        <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">Text</span><span class="p">(</span><span class="n">stringResource</span><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">serviceOn</span><span class="p">)</span> <span class="n">R</span><span class="p">.</span><span class="n">string</span><span class="p">.</span><span class="n">turn_off_service</span> <span class="k">else</span> <span class="n">R</span><span class="p">.</span><span class="n">string</span><span class="p">.</span><span class="n">enable_service</span><span class="p">))</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在Button的onClick里面可以执行一些普通函数调用，比如调用ViewModel等，但是不可以调用Compose的API，因为它是非Composable的，已经跑到了Composable之外。有些场景，这会带来比较大的不方便。</p>

<p>响应点击按扭的方式可能有很多，有些是执行一些普通函数调用，但有些时候也会修改UI，大部分时候也会创建新UI，比如说会弹出对话框。对于修改UI，可以直接通过修改状态的值，状态的值发生改变会触发重组，进而UI状态就会改变（通过读取状态的值显示 不同的UI）。</p>

<p>对话框<a href="https://developer.android.com/develop/ui/compose/components/dialog">Dialog</a>也是一个Composable，它只能被Composable调用，无法在Button的onClick中直接调用Dialog。解决的办法依旧是借助状态，用一个Boolean型值的状态，当其为true时显示Dialog，在Button的onClick中更改此状态为true，状态变了触发重组，在重组时值为true就会显示Dialog了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">InputSettingsEntry</span><span class="p">(</span>
</span><span class='line'>    <span class="n">label</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span>
</span><span class='line'>    <span class="n">description</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span>
</span><span class='line'>    <span class="n">value</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span>
</span><span class='line'>    <span class="n">onChange</span><span class="p">:</span> <span class="p">(</span><span class="n">String</span><span class="p">)-&gt;</span><span class="n">Unit</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">showing</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="k">false</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>     <span class="n">Button</span><span class="p">(</span><span class="n">onClick</span> <span class="p">=</span> <span class="p">{</span> <span class="n">showing</span> <span class="p">=</span> <span class="k">true</span> <span class="p">})</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">Text</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">showing</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">InputDialog</span><span class="p">(</span>
</span><span class='line'>            <span class="n">title</span> <span class="p">=</span> <span class="n">label</span><span class="p">,</span>
</span><span class='line'>            <span class="n">message</span> <span class="p">=</span> <span class="n">description</span><span class="p">,</span>
</span><span class='line'>            <span class="n">value</span> <span class="p">=</span> <span class="n">value</span><span class="p">,</span>
</span><span class='line'>            <span class="n">onDismiss</span> <span class="p">=</span> <span class="p">{</span> <span class="n">showing</span> <span class="p">=</span> <span class="k">false</span> <span class="p">},</span>
</span><span class='line'>            <span class="n">onConfirm</span> <span class="p">=</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">onChange</span><span class="p">(</span><span class="n">it</span><span class="p">)</span>
</span><span class='line'>                <span class="n">showing</span> <span class="p">=</span> <span class="k">false</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>另外，其实Dialog本身的一些事件响应也都是非Composable的，都是通过状态来控制Dialog的显示与否。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://stackoverflow.com/questions/66952179/not-able-to-show-alertdialog-from-onclick-in-jetpack-compose">Not able to show AlertDialog from onClick in Jetpack Compose</a></li>
<li><a href="https://medium.com/@esthcarelle/alert-dialog-with-jetpack-compose-a-step-by-step-guide-04dc3e9dfc1d">Alert Dialog with Jetpack compose: A Step-by-Step Guide</a></li>
</ul>


<h2>总结</h2>

<p>Jetpack Compose博大精深，看似简单就是一坨函数，但在实际项目使用中会遇到各种细节问题。遇到问题也不用慌，用我们的<a href="https://juejin.cn/column/7367555191338467337">『降Compose十八掌』</a>都能解决，没事就多读一读，理解了Compose的思想与原理，做到心中无剑，很多问题都能迎刃而解。</p>

<h2>References</h2>

<ul>
<li><a href="https://climbtheladder.com/10-android-jetpack-compose-best-practices/">10 Android Jetpack Compose Best Practices</a></li>
<li><a href="https://getstream.io/blog/jetpack-compose-guidelines/">6 Jetpack Compose Best Practices for Optimizing Your App Performance</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sub Array and Seb Sequences Made Easy]]></title>
    <link href="https://alexhilton.github.io/blog/2024/09/18/sub-array-and-seb-sequences-made-easy/"/>
    <updated>2024-09-18T22:11:15+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/09/18/sub-array-and-seb-sequences-made-easy</id>
    <content type="html"><![CDATA[<p>子数组和子序列，特别是在一个区间内，或者一个窗口内的子数组个数或者子序列个数问题是非常常见的一类题目，与其他算法结合在一起，求子数组或者子序列数量是非常常见的题目，今天就来总结 一下。</p>

<p><a href="https://alexhilton.github.io/blog/2024/09/18/sub-array-and-seb-sequences-made-easy/"><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/20220620163127/subarray.png" title="auto auto" ></a></p>

<!-- more -->


<h2>如何统计区间内子数组数量</h2>

<p>子数组的数量只与区间长度有关系，对于一个区间长度为n的数组，其非空子数组数量为n * (n+1)/2。</p>

<p>具体计算过程，可以用子数组长度来递推：</p>

<p>1). 长度为1，这时子数组数量为n个
2). 长度为2时，这时子数组数量为n - 1个
3). 长度为n - 1时，这时子数组数量为2
4). 长度为n时，这时子数组数量只有一个1，为1</p>

<p>可以发现， 这是一个等差数列，求和之后就是n*(n+1)/2。</p>

<h2>如何统计区间内子序列数量</h2>

<p>子序列是子数组的特殊形式，它不要求保留在原数组中的顺序。一个长度为k的区间内所有子序列的个数就是一个幂集，每个元素都有「选」和「不选」，因此这个区间所有子序列个数是2<sup>k</sup>个，包括空子序列，如果要求非空，那就再减去一个1。</p>

<p>具体计算过程，需要用到组合数学：</p>

<p>1). 一个都不选C(n, 0) = 1
2). 一个一个的选，C(n, 1) = n
2). 两个选，C(n,2)
3). n - 1个，C(n, n - 1)
4). n个，C(n, n) = 1</p>

<p>求和就是2<sup>n</sup>，如果非空就是2<sup>n</sup> - 1。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-subsequences-that-satisfy-the-given-sum-condition/description/">1498. 满足条件的子序列数目</a> </td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>References</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/array-subarray-subsequence-and-subset/">Subarrays, Subsequences, and Subsets in Array</a></li>
<li><a href="https://www.geeksforgeeks.org/count-distinct-subsequences/">Count Distinct Subsequences</a></li>
<li><a href="https://www.geeksforgeeks.org/count-of-subarrays-in-an-array-containing-numbers-from-1-to-the-length-of-subarray/">Count of Subarrays in an array containing numbers from 1 to the length of subarray</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『神龙摆尾』| Architecture]]></title>
    <link href="https://alexhilton.github.io/blog/2024/09/12/architecture-in-compose/"/>
    <updated>2024-09-12T22:27:58+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/09/12/architecture-in-compose</id>
    <content type="html"><![CDATA[<p>通过前面的<a href="https://juejin.cn/column/7367555191338467337">一系列文章</a>，我们已经掌握了足够的Jetpack Compose的开发基础。为了更好的在实际项目中使用Compose，我们还需要了解一下现代应用开发的架构原则，以及使用Jetpack Compose时如何更好的遵循这些原则。这篇文章将聚焦于架构原则这一话题，进行一些探讨和总结。</p>

<p><a href="https://alexhilton.github.io/blog/2024/09/12/architecture-in-compose/"><img src="https://www.sixt.tech/assets/jetpack-compose/jetpack-compose.png" title="auto auto" ></a></p>

<!-- more -->


<h2>现代Android应用开发的架构方式</h2>

<p>Jetpack Compose是一个声明式的UI框架，用它来开发应用程序，因此根本上仍是在做应用程序开发，所以需要遵循现代应用程序的架构原则。</p>

<p>一提到架构自然会想到Bob大叔的<a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">The Clean Architecture</a>，这里面的最主要的核心思想就是分层，把不同的概念按照抽象的层次进行分离，层与层之间有特定的依赖规则，也即只能从控制层往业务逻辑依赖。分层最大的益处就是方便移植和替换，降低维护成本，这也是架构的意义所在。</p>

<p><img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg" alt="图1. The Clean Architecture" /></p>

<p>对于移动应用开发，谷歌也给出比较实用的<a href="https://developer.android.com/topic/architecture#common-principles">现代应用架构原则</a>，其中有四个核心原则：</p>

<ol>
<li>远离系统组件，系统组件（Activity，Service和Fragment等）仅能作为一个入口和必要的依赖对象，以及协调和连接不同的对象。深层次的原因是系统组件实例不可控，系统随时会重新创建实例，所以应该把对系统组件的依赖降到最低；</li>
<li>由数据来驱动UI，且数据最好是不可变的（Immutable data）。这个原则要求把逻辑尽可能的放在数据层而非UI层，UI层就是展示数据层，处理用户事件和UI自己的逻辑，但不应该做的业务逻辑处理。比如说新闻类应用，数据层把一坨列表传过来，UI就展示，如果列表为空，那显示加载错误，用户点击刷新就让数据层刷新数据。但不应该对列表中的数据做更新或者更改，比如说把不同的列表融合为一个，这些都是业务逻辑，应该由数据层来做。这样的好处是能让UI层尽可能的简单，方便移植，方便测试。而且这符合响应式的数据流，可以使用响应式编程范式（MVVM或者MVI）；</li>
<li>单一数据源（Single Source Of Truth），也就是说任何数据都应该只由它的生产者来修改，其他模块只是使用不能修改，因此每一层返回的数据都应该是不可修改类型（Immutable objects）;</li>
<li>单向数据流动（Unidirectional Data Flow），UI层展示数据，获得用户事件，调用业务逻辑层处理事件，业务逻辑层再去数据层请求新的数据，新的数据再来驱动刷新UI，而不可以业务逻辑层修改数据后一边去刷新UI，一边再去让数据层修改数据，这会导致难以调试的bug。</li>
</ol>


<p><img src="https://developer.android.com/static/topic/libraries/architecture/images/mad-arch-overview.png" alt="图2. 现代应用典型架构" /></p>

<p>下面我们围绕Jetpack Compose来深入探讨一下如何把这些架构原则落到实处。</p>

<h2>使用Jetpack Compose落实架构原则</h2>

<p>Jetpack Compose是声明式UI框架，所以它只能出现在UI层，用UI元素展示数据， 以及获取用户事件。其余的部分，如业务逻辑层（ViewModels）和数据层（Models and Data）都与Compose没有关系，也不应该受到Compose的影响。这就是架构分层带来的好处，不同层之间通过约定 的接口进行协作，每一层都可以用不同的技术栈去实现，不会对其他层造成影响。</p>

<p><img src="https://developer.android.com/static/topic/libraries/architecture/images/mad-arch-overview-ui.png" alt="图3. 应用架构中的UI层的角色" /></p>

<h3>典型的项目结构</h3>

<p>按照架构原则，一个典型的项目模块结构应该是酱紫的：</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/project_org.png" alt="图4. 典型项目模块结构" /></p>

<p>Activity（对应着Activity实例）和AndroidApp（对应着Application实例）是应用程序的入口，可能需要在里面做一些必要的初始化工作，比如有些三方的库可能需要在Application#onCreate中去做初始化工作。ui package对应着UI层，负责UI的展示；package model对应着Model层，里面定义着供UI层使用的数据类型，以及获取 这些数据的接口；package data对应着数据层（data layer），实现着model中的接口定义。当然也可以把model与data合并成一个package，不过，单独把数据的定义和数据层的接口拿出来放在一个包里，会更清晰一些，因为UI层只需关心有哪些接口可以获得什么数据，它只需要知道model就够了。</p>

<p>Jetpack Compose的入口应该用一个名字为App的函数，在这里做初始化工作，比如创建数据层的实例，进行弹窗，创建导航等等。此处作为一个桥接，用以把Android的组件与Compose连接起来，创建必要的实例并把各实例协调起来。当然也可以直接把这些事情放入Activity中，但独立出来更方便测试和移植，让系统组件变得更为简单。Activity直接调用App即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">MainActivity</span> <span class="p">:</span> <span class="n">AppCompatActivity</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="n">Bundle</span><span class="p">?)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">super</span><span class="p">.</span><span class="n">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">)</span>
</span><span class='line'>        <span class="n">setContent</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">AeolusApp</span><span class="p">(</span><span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxWidth</span><span class="p">())</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">AeolusApp</span><span class="p">(</span>
</span><span class='line'>    <span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">AeolusTheme</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// A surface container using the &#39;background&#39; color from the theme</span>
</span><span class='line'>        <span class="n">Surface</span><span class="p">(</span>
</span><span class='line'>            <span class="n">modifier</span> <span class="p">=</span> <span class="n">modifier</span><span class="p">,</span>
</span><span class='line'>            <span class="n">color</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">colorScheme</span><span class="p">.</span><span class="n">background</span>
</span><span class='line'>        <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">CurrentLocationPermission</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">val</span> <span class="py">dataContainer</span> <span class="p">=</span> <span class="n">DataContainerImpl</span><span class="p">(</span><span class="n">LocalContext</span><span class="p">.</span><span class="n">current</span><span class="p">)</span>
</span><span class='line'>                <span class="n">AeolusNavGraph</span><span class="p">(</span><span class="n">appContainer</span> <span class="p">=</span> <span class="n">dataContainer</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>创建导航</h3>

<p>导航是把所有的UI页面组织在一起形成一个逻辑清晰的交互整体，可以参照之前的文章<a href="https://juejin.cn/post/7398728505872908315">降Compose十八掌之『密云不雨』| Navigation</a>来创建导航。</p>

<p>需要注意的就是页面应该命名为Screen，其ViewModel应该作为参数传递给Screen，Screen和ViewModel的实例创建都在导航中来完成。</p>

<h3>ViewModel应该保持独立</h3>

<p>ViewModel作为UI层与数据层的中间层而存在，目的是让UI层专注于数据展示。为了更好的可移植性，ViewModel不应该有平台相关的依赖，比如<a href="https://juejin.cn/post/7409869765177147430">平台的生命周期</a>或者Context，它只应该依赖model层。并且为了方便依赖注入，应该把Model层的数据接口对象（通常是Repository）作为参数传递给ViewModel：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">FavoritesViewModel</span><span class="p">(</span>
</span><span class='line'>    <span class="k">private</span> <span class="k">val</span> <span class="py">locationRepo</span><span class="p">:</span> <span class="n">LocationRepository</span><span class="p">,</span>
</span><span class='line'>    <span class="k">private</span> <span class="k">val</span> <span class="py">weatherRepo</span><span class="p">:</span> <span class="n">WeatherRepository</span>
</span><span class='line'><span class="p">)</span> <span class="p">:</span> <span class="n">ViewModel</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>具体的Repository对象可以在导航创建ViewModel时创建，或者用依赖注入框架（如Hilt）来注入实例。</p>

<h3>并发原则</h3>

<p>现代的应用肯定都会用并发，无论是协程还是Flow，为了能让并发更加的结构化和可控，应该遵循以下原则：</p>

<ol>
<li>Model层的方法都应该是suspend，对于所有Model层公开出来的方法都应该用suspend来修饰。</li>
<li>Repository（即Data层）的每个方法的实现都要指定明确的Dispatcher，最好接收一个Dispatcher作为构造参数，以方便进行注入或者测试。</li>
<li>ViewModel要把所有对Model的方法调用包裹在协程作用域viewModelScope中。</li>
</ol>


<h3>层与层之间的交互要定义接口</h3>

<p>比如Model层提供给ViewModel的能力要定义为接口，然后在Data层中去实现这些接口。接口的最大好处是方便替换具体的实现，比如换个实现方式时，或者Mock测试时都能很方便的进行替换，甚至还可以使用动态代理在运行时进行替换。</p>

<h3>对外部的依赖要作为构造器参数传入</h3>

<p>作为构造参数传入外部依赖，而不是在内部直接创建，这样做的好处在于方便替换实例，无论是日后更换一种实现实例，还是Mock测试，都可以在不修改类本身的情况下进行实例替换。甚至可以使用依赖注入框架（如Hilt）做到让具体使用的实例可配置化。</p>

<h2>Compose与ViewModel的交互原则</h2>

<p>这部分我们具体谈一谈Compose与ViewModel在交互时的一些原则和建议。ViewModel暴露UiState给Compose展示，Compose则把事件（Event）给ViewModel去处理（可以是MVI式的把事件封装成Intent塞给ViewModel，也可以直接调用ViewModel的接口）。</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/state-unidirectional-flow.png" alt="图5. Compose与ViewModel的UDF" /></p>

<p>比如说一个典型的登录场景，其Composable和ViewModel应该像这样的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">class</span> <span class="nc">MyViewModel</span> <span class="p">:</span> <span class="n">ViewModel</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">private</span> <span class="k">val</span> <span class="py">_uiState</span> <span class="p">=</span> <span class="n">mutableStateOf</span><span class="p">&lt;</span><span class="n">UiState</span><span class="p">&gt;(</span><span class="n">UiState</span><span class="p">())</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">uiState</span><span class="p">:</span> <span class="n">State</span><span class="p">&lt;</span><span class="n">UiState</span><span class="p">&gt;</span>
</span><span class='line'>        <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="n">_uiState</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">data</span> <span class="k">class</span> <span class="nc">UiState</span><span class="p">(</span>
</span><span class='line'>    <span class="n">loading</span><span class="p">:</span> <span class="n">Boolean</span> <span class="p">=</span> <span class="k">false</span><span class="p">,</span>
</span><span class='line'>    <span class="n">signedIn</span><span class="p">:</span> <span class="n">Boolean</span> <span class="p">=</span> <span class="k">false</span><span class="p">,</span>
</span><span class='line'>    <span class="n">error</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="s">&quot;&quot;</span>
</span><span class='line'><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">MyComposable</span><span class="p">(</span><span class="n">viewModel</span><span class="p">:</span> <span class="n">MyViewModel</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">uiState</span> <span class="p">=</span> <span class="n">viewModel</span><span class="p">.</span><span class="n">uiState</span><span class="p">.</span><span class="n">collectAsStateWithLifecycle</span><span class="p">()</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">uiState</span><span class="p">.</span><span class="n">loading</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// show loading</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">uiState</span><span class="p">.</span><span class="n">signedIn</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// show signed in status</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// show uiState.error</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>一定要定义专用的UiState数据对象</h3>

<p>从ViewModel给UI的数据要封装成一个不可变的数据对象（data class）作为UiState，即使其数据与从Model处获得的数据没有变化，也应该定义并做基本转换。</p>

<p>原因就是让UI层和Model不会相互影响，假如直接把Model的数据传给UI，那假如以后Model层的数据有变动，这就会影响到UI。架构分层的目的就是要封装和隔离，每一层都应该定义自己的输出数据类型，把依赖和耦合降到最低。</p>

<h3>当数据特别多时，分成多个UiState对象</h3>

<p>如果页面较复杂，需要的字段特别多，这时应该把页面分成几个区域，同时UiState也应该分成几个不同的对象，而不是大一统的装在一个对象里面。</p>

<p>原因在于Compose会把从ViewModel处获得的UiState装在一个状态里面，从<a href="https://juejin.cn/post/7376094685495001139">前面的文章中</a>我们知道，状态是用于触发重组的，状态发生变化就会触发重组。因为数据多半部分变化的，甚至有些业务逻辑总是某几个字段在变化。因为字段都放在了一个对象中，那么即使只有一个字段变了，对于Compose来说，也是状态变化了，就要进行重组。</p>

<p>把字段按其变化的性质进行拆分，用几个UiState来表示，这样能把变化降到最低，只让真正有变化的UiState触发重组进而刷新UI。</p>

<h3>Compose中要尽可能拆解为无状态函数</h3>

<p>这里的意思是说我们应该把从ViewModel处获得的UiState拆解开来，变成具体的参数用无状态函数去展示，而不应该全都把UiState当成参数传给每一个composables。比如说对于一个新闻页面，对于标题元素就应该只接受两个String作为参数，而不应该把整个NewsUiState作为参数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">Header</span><span class="p">(</span><span class="n">title</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span> <span class="n">subtitle</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 只有当title和subtitle发生变化时才会重组</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">Header</span><span class="p">(</span><span class="n">news</span><span class="p">:</span> <span class="n">NewsUiState</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 只要状态变了就会重组，哪怕有关的title和subtitle没有变化</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样做的目的也是为了尽可能减少重组。</p>

<h3>ViewModel塞给UI的数据要能够直接展示</h3>

<p>UI层负责数据展示，不应该有过多的逻辑，特别是不能有涉及非UI直接相关的逻辑。ViewModel存在的意义就是为了把非UI相关的业务逻辑全从UI中拿走，把UI做的尽可能薄一些，这里薄的意思是逻辑要少。背后的核心原因在于方便测试和移植，众所周知UI是与每个平台强相关的，每个平台的UI构建方式都不一样，并且UI是极难做单元测试的，依赖太多很难Mock。</p>

<p>UI层很薄，仅是数据的展示，逻辑都放在ViewModel中，但ViewModel依赖很少，没有对平台和依赖，它的依赖对象都是可以Mock的，那么ViewModel就很容易做测试，只要测试保证ViewModel没什么问题，那么就基本上可以认为UI也不会有问题，毕竟光做展示一般不会出问题。</p>

<p>这里的最重要的一点就是要保证ViewModel递给UI的数据要是经过逻辑处理后的，可以直接展示的数据。举个粟子，比如说展示时间间隔的字段，类似于『100 ms』，『10 seconds』，『2 mins 10ms』或者『1 hour 10 mins』 这种，那么就不可以直接把一个Int或者Long传给UI，让UI去换算，而是让ViewModel做换算，把结果String传给UI，UI用一个Text直接显示String。这样一来就可测试了，我们Mock几个不同的字段值给ViewModel，再检查它吐出来的UiState中的时长String字段是否符合预期，就能保证这段逻辑没有问题。对于UI可以不用测试了，一个Text显示一个String出错的可能性不大，可以忽略了。</p>

<h2>总结</h2>

<p>架构最难的地方在于它是<strong>形而上学（Metaphysics）</strong>的，不会像算法或者设计模式那样有非常明确的和具体的实施步骤，仅是有一些抽象的指导原则。在实际的项目中就要从实际的业务场景出发，使用可用的技术工具，把指导原则进行落地，要<strong>把『神似』而非『形似』</strong>作为目标。切忌生搬硬套网上一些所谓的应用架构框架，假如真的有通用的架构框架，那谷歌为啥不写在SDK里面？不同的业务，不同的规模，不同的技术栈，不同的版本策略都会影响架构的方式。比如像第一部分提到的四大原则，难道只有用MVVM或者MVI才能做到么？即使用了MVVM，你在ViewModel直接把未处理的数据丢给UI，UI中仍有大量的处理数据的if-else，ViewModel把数据改了后两头更新，这明显不符合架构原则，最后仍是维护一坨巨大的shi山难解的Bug满天飞。所以对于网上的各种架构框架看看就好，一定不能生搬硬套。</p>

<p>可以通过谷歌提供的一些非常好的<a href="https://github.com/android/architecture-samples/tree/main">案例</a>来学习架构，仔细研读这些案例的源码，以深刻理解架构指导原则的内在涵义。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/topic/architecture">Guide to app architecture</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/architecture">Architecting your Compose UI</a></li>
<li><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">The Clean Architecture</a></li>
<li><a href="https://www.geeksforgeeks.org/separation-of-concerns-soc/">Separation of Concerns (SoC)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『羝羊触蕃』| Handle Platform Lifecycles]]></title>
    <link href="https://alexhilton.github.io/blog/2024/09/06/compose-interact-with-platforms/"/>
    <updated>2024-09-06T22:21:49+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/09/06/compose-interact-with-platforms</id>
    <content type="html"><![CDATA[<p>Jetpack Compose是一个独立的声明式UI框架，它并不受限于任何操作系统平台，从框架定位的角度来讲，它是跨平台的，也应该要跨平台。但是我们的应用程序必然是为某些操作系统平台（后面简称平台Platform）构建的，也就是说要运行在某些平台上面。这就免不了要与平台进行打交道。这篇文章将以Android平台为例，学习在Compose中如何处理平台的生命周期事件。</p>

<p><a href="https://alexhilton.github.io/blog/2024/09/06/compose-interact-with-platforms/"><img src="https://www.ericthecoder.com/wp-content/uploads/2020/05/feature.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>感知平台生命周期事件</h2>

<p>对于移动应用程序来说，感知平台的生命周期是非常重要的，比如最为典型的场景，对于一个新闻消息类的应用来说，当首次进入页面的时候肯定 要刷新拉取最新的消息，当用户切换到另外一个应用时，比如接了个电话，或者分享，之后再回到你的应用页面，这时也应该主动刷新消息，而不是要等着用户手动的去点击刷新按扭；再比如说当使用了硬件资源（位置，Camera或者Sensors等）时，更是要当离开应用页面的时候就应该立即释放硬件，以停止对硬件资源的占用。</p>

<p>从前面的文章<a href="https://juejin.cn/post/7401358349877346338">降Compose十八掌之『损则有孚』| Lifecycle</a>中我们了解到Composable本身的生命周期与平台是无关的且非常不一致，光靠Compose自己的节奏是无法感知到在平台生命周期事件的。这就需要我们使用一些桥接工具来感知平台生命周期事件，以能让我们针对感兴趣的事件执行一些操作。</p>

<h3>生命周期事件副作用函数（LifecycleEffects）</h3>

<p>幸运的是Jetpack组件中的lifecycle已经添加了<a href="https://developer.android.com/topic/libraries/architecture/compose">对Compose的支持</a>，定义了一些<a href="https://developer.android.com/reference/kotlin/androidx/lifecycle/compose/package-summary#LifecycleEventEffect(androidx.lifecycle.Lifecycle.Event,androidx.lifecycle.LifecycleOwner,kotlin.Function0">生命周期副作用函数</a>)，在这些副作用函数中可以针对 不同的事件设置代码块，当相应的生命周期发生时就会执行这些代码块：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">LifecycleEventEffect</span><span class="p">(</span><span class="n">Lifecycle</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">ON_START</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// onStar时执行一些操作</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码就是指定要在onStart时做一些事情。需要<strong>注意</strong>的是，无法监听onDestroy（即事件Lifecycle.Event.ON_DESTROY），因为Compose的<strong>组合会在onDestroy之前就结束</strong>了。</p>

<p>除了上面的用法之外，还有更为为方便的<a href="https://developer.android.com/reference/kotlin/androidx/lifecycle/compose/package-summary#LifecycleStartEffect(kotlin.Any,androidx.lifecycle.LifecycleOwner,kotlin.Function1">LifecycleStartEffect</a>)和<a href="https://developer.android.com/reference/kotlin/androidx/lifecycle/compose/package-summary#LifecycleResumeEffect(kotlin.Any,androidx.lifecycle.LifecycleOwner,kotlin.Function1">LifecycleResumeEffect</a>)可以直接使用，它们是针对onStart/onStop和onResume/onPause两对事件的，因为生命周期中最为常用的就是这四个事件了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">LifecycleStartEffect</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// onStart中需要做的事情</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">onStopOrDispose</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// onStop需要做的事情</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">LifecycleResumeEffect</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// onResume需要做的事情</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">onPauseOrDispose</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// onPause需要做的事</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>需要注意，这两个副作用函数是针对事件对的，也就是说必须要带着后面的onStopOrDispose和onPauseOrDispose。如果仅对onStart感兴趣，而无须在onStop中做清理，那么应该直接使用LifecycleEventEffect(Lifecycle.Event.ON_START) {}（对于onResume也是同理）。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://medium.com/@nirazv/managing-lifecycles-events-on-jetpack-compose-bbecf804b43d">Managing Lifecycles Events on Jetpack Compose</a></li>
<li><a href="https://developer.android.com/topic/libraries/architecture/compose">Integrate Lifecycle with Compose</a></li>
</ul>


<h3>监听生命周期事件</h3>

<p>除了直接使用生命周期副作用函数以外，也可以用lifecycle原生的方式，直接向<a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner">LifecycleOwner</a>注册一个<a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleEventObserver">LifecycleEventObserver</a>来监听生命周期。通过Compose提供的LifeCycleOwner.current可以获得当前的LifecycleOwner，然后向其注册一个LifecycleEventObserver，当平台生命周期发生变化时，就会带着事件类型回调给监听者，监听者可以针对感兴趣的事件做操作。还需要注意的是，需要在组合结束（离开）时反注册observer，因此这里要用DisposableEffect。对于副作用函数不熟悉的同学可以去复习一下<a href="https://juejin.cn/post/7405158681078104127">降Compose十八掌之『龙战于野』| Side Effects</a>。</p>

<p>来看个简单的示例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">lifecycleOwner</span> <span class="p">=</span> <span class="n">LocalLifecycleOwner</span><span class="p">.</span><span class="n">current</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">DisposableEffect</span><span class="p">(</span><span class="n">lifecycleOwner</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">observer</span> <span class="p">=</span> <span class="n">LifecycleEventObserver</span> <span class="p">{</span> <span class="n">_</span><span class="p">,</span> <span class="n">event</span> <span class="p">-&gt;</span>
</span><span class='line'>            <span class="k">when</span> <span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">Lifecycle</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">ON_CREATE</span> <span class="p">-&gt;</span> <span class="p">{</span> <span class="cm">/* onCreate */</span> <span class="p">}</span>
</span><span class='line'>                <span class="n">Lifecycle</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">ON_START</span> <span class="p">-&gt;</span> <span class="p">{</span> <span class="cm">/* onStart */</span> <span class="p">}</span>
</span><span class='line'>                <span class="n">Lifecycle</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">ON_RESUME</span> <span class="p">-&gt;</span> <span class="p">{</span> <span class="cm">/* onResume */</span> <span class="p">}</span>
</span><span class='line'>                <span class="n">Lifecycle</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">ON_PAUSE</span> <span class="p">-&gt;</span> <span class="p">{</span> <span class="cm">/* onPause */</span> <span class="p">}</span>
</span><span class='line'>                <span class="n">Lifecycle</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">ON_STOP</span> <span class="p">-&gt;</span> <span class="p">{</span> <span class="cm">/* onStop */</span> <span class="p">}</span>
</span><span class='line'>                <span class="n">Lifecycle</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">ON_DESTROY</span> <span class="p">-&gt;</span> <span class="p">{</span> <span class="cm">/* onDestroy */</span> <span class="p">}</span>
</span><span class='line'>                <span class="n">Lifecycle</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">ON_ANY</span> <span class="p">-&gt;</span> <span class="p">{</span> <span class="cm">/* Any event */</span> <span class="p">}</span>
</span><span class='line'>                <span class="k">else</span> <span class="p">-&gt;</span> <span class="p">{}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">lifecycleOwner</span><span class="p">.</span><span class="n">lifecycle</span><span class="p">.</span><span class="n">addObserver</span><span class="p">(</span><span class="n">observer</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">onDispose</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">lifecycleOwner</span><span class="p">.</span><span class="n">lifecycle</span><span class="p">.</span><span class="n">removeObserver</span><span class="p">(</span><span class="n">observer</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样就可以监听到生命周期事件，然后针对不同的事件做相应的操作。</p>

<p>当然，如果事件不止做一件事情，或者说对事件的响应不光光是执行一些函数，可能还会有页面的修改，那么这时最好就是把事件保存为一个状态（State），更为方便：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">lifecycleOwner</span> <span class="p">=</span> <span class="n">LocalLifecycleOwner</span><span class="p">.</span><span class="n">current</span>
</span><span class='line'>
</span><span class='line'><span class="k">var</span> <span class="py">lifecycleEvent</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="n">Lifecycle</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">ON_ANY</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">DisposableEffect</span><span class="p">(</span><span class="n">lifecycleOwner</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">observer</span> <span class="p">=</span> <span class="n">LifecycleEventObserver</span> <span class="p">{</span> <span class="n">_</span><span class="p">,</span> <span class="n">event</span> <span class="p">-&gt;</span>
</span><span class='line'>        <span class="n">lifecycleEvent</span> <span class="p">=</span> <span class="n">event</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">lifecycleOwner</span><span class="p">.</span><span class="n">lifecycle</span><span class="p">.</span><span class="n">addObserver</span><span class="p">(</span><span class="n">observer</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">onDispose</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">lifecycleOwner</span><span class="p">.</span><span class="n">lifecycle</span><span class="p">.</span><span class="n">removeObserver</span><span class="p">(</span><span class="n">observer</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">LaunchedEffect</span><span class="p">(</span><span class="n">lifecycleEvent</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">lifecycleEvent</span> <span class="p">==</span> <span class="n">Lifecycle</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">ON_RESUME</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">viewModel</span><span class="p">.</span><span class="n">refresh</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">Column</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">lifecycleEvent</span> <span class="p">==</span> <span class="n">Lifecycle</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">ON_RESUME</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span><span class="s">&quot;Welcome back&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>扩展阅读：</p>

<ul>
<li><a href="https://stackoverflow.com/questions/74780546/android-handle-lifecycle-event-on-jetpack-compose-screen">Android handle lifecycle event on Jetpack Compose Screen</a></li>
<li><a href="https://proandroiddev.com/jetpack-compose-making-composable-lifecycle-aware-bde67437d2d0">Jetpack Compose — Making Composable lifecycle-aware</a></li>
<li><a href="https://betterprogramming.pub/jetpack-compose-with-lifecycle-aware-composables-7bd5d6793e0">Jetpack Compose with Lifecycle-Aware Composables</a></li>
</ul>


<h3>以数据流的方式来处理生命周期事件</h3>

<p>生命周期是由系统控制，不时发生变化，每次变化会向监听者回调一个事件，如果以一定的时间跨度来看待，这些事件就形成了一个数据流。因此，Lifecycle还提供了一个Flow接口，用以发送Lifecycle事件。可以当作状态（State）来收集此Flow，这样事件的变化就能驱动Compose的重组，进而感知到最新的生命周期事件：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">lifecycleOwner</span> <span class="p">=</span> <span class="n">LocalLifecycleOwner</span><span class="p">.</span><span class="n">current</span>
</span><span class='line'><span class="k">val</span> <span class="py">stateFlow</span> <span class="p">=</span> <span class="n">lifecycleOwner</span><span class="p">.</span><span class="n">lifecycle</span><span class="p">.</span><span class="n">currentStateFlow</span>
</span><span class='line'><span class="k">val</span> <span class="py">currentLifecycleState</span> <span class="k">by</span> <span class="n">stateFlow</span><span class="p">.</span><span class="n">collectAsState</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 或者</span>
</span><span class='line'><span class="k">val</span> <span class="py">lifecycleOwner</span> <span class="p">=</span> <span class="n">LocalLifecycleOwner</span><span class="p">.</span><span class="n">current</span>
</span><span class='line'><span class="k">val</span> <span class="py">currentLifecycleState</span> <span class="p">=</span> <span class="n">lifecycleOwner</span><span class="p">.</span><span class="n">lifecycle</span><span class="p">.</span><span class="n">currentStateAsState</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>注意：</strong> 对于Flow不熟悉的同学可以复习一下<a href="https://juejin.cn/post/7336751931375648820">包教包会的Kotlin Flow教程</a>。</p>

<h3>不要在ViewModel中感知生命周期</h3>

<p>根据<a href="https://developer.android.com/topic/architecture">现代安卓开发架构原则</a>，ViewModel应该处理与UI相关的业务逻辑，它应该独立于平台，因此，千万不要在ViewModel去感知生命周期，事实上你也做不到，因为ViewModel是没任何对平台的依赖的，非常独立的一个类型，也即拿不到LifecycleOwner。</p>

<p>当然了，有同学说，我可以从Compose的Composable中把LifecycleOwner当作参数传给ViewModel，但仍然强烈不建议这样做。深层的原因在于，ViewModel是独立于平台的，它有自己的生命周周期，平台的组件（如Activity）是由系统控制的，但ViewModel是由我们自己控制的，它的生命周期要长于平台的组件，也就是说ViewModel的生命周期要长于它持有的LifecycleOwner，故LifecycleOwner可能会变得过时（非当前的Activity了），同时因为被更长生命的ViewModel持有，原LifecycleOwner可能无法被回收而引发内存泄漏。</p>

<p>ViewModel只应该负责业务逻辑相关的事情，在Composable中监听生命周期事件很方便，也很合适，然后调用ViewModel的相应的接口（如refresh()）即可。</p>

<h2>总结</h2>

<p>得益于Jetpack中的Lifecycle组件，在Compose中感知生命周期没有想像中的那样难。在实际项目中，推荐使用更符合Compose的方式，也即生命周期副作用函数以及事件数据流。如果仅是在某些生命周期事件发生时执行一些操作，那就用LifecycleEventEffect函数；如果不止一处需要使用事件，那就用事件数据流。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『履霜冰至』| Phases]]></title>
    <link href="https://alexhilton.github.io/blog/2024/08/30/jetpack-compose-phases/"/>
    <updated>2024-08-30T08:02:41+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/08/30/jetpack-compose-phases</id>
    <content type="html"><![CDATA[<blockquote><p>这篇文章译自<a href="https://developer.android.com/develop/ui/compose/phases">Jetpack Compose phases</a></p></blockquote>

<p>就像大多数其他的UI工具集一样，Compose渲染一帧也要经过几个不同的阶段。就比如说Android view系统，主要有三个阶段：测量（measure），版面编排（layout）和绘制（drawing）。Compose也非常的类似，但有一个特别重要的额外的阶段起始时的组合（composition）阶段。</p>

<p><a href="https://alexhilton.github.io/blog/2024/08/30/jetpack-compose-phases/"><img src="https://pbs.twimg.com/media/F3l9aWwWUAEDYxS.jpg:large" title="auto auto" ></a></p>

<!-- more -->


<p>组合在我们前面的文章中有详细的描述，包括<a href="https://juejin.cn/post/7379437165486112805">降Compose十八掌之『潜龙勿用』| Thinking in Compose</a>和<a href="https://juejin.cn/post/7376094685495001139">降Compose十八掌之『鸿渐于陆』| State</a>。</p>

<h2>每一帧的三个阶段</h2>

<p>Compose有三个主要的阶段：</p>

<ol>
<li>组合（Composition）：要显示什么。Compose运行composable函数并创建UI的一个描述。</li>
<li>版面编排（Layout）：在哪里显示。这个阶段包含两个步骤：测量（measurement）和放置（placement）。给布局树中的每个节点，在二维坐标中，布置元素的测量然后放置它们和它们的子元素。</li>
<li>绘制（Drawing）：如何渲染。把UI元素绘制进一个Canvas，也就是设备的屏幕上。</li>
</ol>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/compose-phases.png" alt="three_phases" /></p>

<blockquote><p>图1. Compose把数据转化为UI的三个阶段</p></blockquote>

<p>这三个阶段的执行顺序是相同的，能够让数据从组合到版面编排再到绘制沿着一个方向流动，以生成一帧（也就是<a href="https://developer.android.com/develop/ui/compose/architecture#udf">「单向数据流」</a>）。需要特别注意的例外是<a href="https://developer.android.com/develop/ui/compose/layouts/basics#constraints">BoxWithConstraints</a>，<a href="https://developer.android.com/develop/ui/compose/lists#lazy">LazyColumn</a>和<a href="https://developer.android.com/develop/ui/compose/lists#lazy">LazyRow</a>，它们子节点的组合依赖于父节点的排版阶段。</p>

<p>可以假定每一帧都会这三个阶段，但是基于性能的考量，在所有的阶段里，Compose会避免相同输入时计算结果相同的重复工作。如果一个composable函数能复用前一次的结果，Compose会跳过它的执行，并且如果没有必要，Compose UI并不会重新排版或者重新绘制整个UI树。Compose仅会做更新UI所必要的最少工作。因为Compose会在不同的阶段追踪状态读取，所以这种优化是可行的。</p>

<h3>理解不同的阶段</h3>

<p>这部分将详细的描述composables的三个渲染阶段是如何进行的。</p>

<h4>组合（Composition）</h4>

<p>在组合阶段，Compose运行时会执行composable函数然后输出一个能代表UI的树形结构。这个树形结构由包含着下一阶段所需要的信息的布局节点组成，如下面这个视频所示：</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/composition-ezgif.gif" alt="" /></p>

<blockquote><p>图2. 在组合阶段创建的代表着你的UI的树形结构。</p></blockquote>

<p>一小段代码和其树形会如下所示：</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/code-subsection.png" alt="ui_tree_vs_code" /></p>

<blockquote><p>图3. UI树的一部分与其对应的代码。</p></blockquote>

<p>在这些例子中，代码中的每个composable函数映射为一UI树中的一个布局节点。在更复杂的例子中，composables可包含逻辑和控制流程，在不同的状态下生成不同的树。</p>

<h4>排版（Layout）</h4>

<p>在排版阶段，Compose使用组合阶段生成的UI树作为输入。布局节点的集合包含了需要确定2D空间下每个节点大小和位置的所有需要的信息。</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/layout-ezgif.gif" alt="" /></p>

<blockquote><p>图4. 在排版阶段UI树中每个布局节点的测量和放置。</p></blockquote>

<p>在排版阶段，树用下面三步算法进行遍历：</p>

<ol>
<li>测量子节点：节点会测量其存在的子节点。</li>
<li>决定自身大小：基于前面的测量，一个节点能决定它自身的大小。</li>
<li>放置子节点：每个子节点以节点为参考进行放置。</li>
</ol>


<p>在这个阶段的最后，每个布局节点都有：</p>

<ul>
<li>一个确定的宽度（width）和高度（height）</li>
<li>一个绘制的位置坐标x，y</li>
</ul>


<p>对于前一部分提到的UI树：</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/code-subsection.png" alt="" /></p>

<p>对于这颗树，算法是这样工作的：</p>

<ol>
<li>Row测量它的子节点：Image和Column。</li>
<li>Image测量过后。因为它没有子节点，所它决定自己的大小并把其大小报告给Row。</li>
<li>接下来测量Column。它先测量它的两个子节点（两个Text函数）。</li>
<li>第一个Text被测量。它没有子节点，所以决定自己大小并告诉给Column

<ol type="a">
<li>第二个Text被测量。它也没有子节点，所以决定自己大小后告诉给Column。</li>
</ol>
</li>
<li>Column使用子节点的测量结果决定自己的大小。它用子节点的最大宽度（作为宽度）和高度之和（作为高度）。</li>
<li>Column相对于自己来放置子节点，把它们垂直地放在下面。</li>
<li>Row使用子节点的测量结果来决定自身大小。它使用子节点的最大高度作为高度，子节点宽度之和作为宽度。然后旋转子节点。</li>
</ol>


<p>注意每个节点仅访问一次。测量和放置所有节点时，Compose运行时仅需要访问一次UI树，这样做能提升性能。当树中的节点数量增加时，遍历所需要的时间仅线性增长。相反，如果每个节点访问多次，遍历时间将呈指数增长。</p>

<h4>绘制（Drawing）</h4>

<p>在绘制阶段，将从上到下的再次遍历树，每个节点依次的在屏幕上绘制其自身。</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/drawing-ezgif.gif" alt="" /></p>

<blockquote><p>图5. 绘制阶段在屏幕上绘制像素点。</p></blockquote>

<p>继续前面的例子，以如下方式绘制出树的内容：</p>

<ol>
<li>Row绘制它有的所有内容，如背景。</li>
<li>Image绘制它自己。</li>
<li>Column绘制它自己。</li>
<li>第一个和第二个Text各自绘制它们自己。</li>
</ol>


<p><img src="file:///Users/alexhilton/Downloads/compose_libs/drawing-ui-tree-ezgif.gif" alt="" /></p>

<blockquote><p>图6. UI树和它的渲染展示。</p></blockquote>

<h2>状态读取</h2>

<p>当你在上面列出的一个阶段中读取状态的值时，Compose会自动追踪值被读取时它在做的事情。这种追踪允许Compose在状态发生变化时重新执行读取者，这是Compose中状态的可观测性的基础。</p>

<p>状态通常都是由mutableStateOf来创建的然后通过两种方式访问：直接读取其属性value或者通过Kotlin的属性委托。可以在文章<a href="https://juejin.cn/post/7376094685495001139">降Compose十八掌之『鸿渐于陆』| State</a>中了解更多的细节。在本文中，「状态读取」通指两种方法中的任意一种。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="c1">// 直接读取状态的value</span>
</span><span class='line'><span class="k">val</span> <span class="py">paddingState</span><span class="p">:</span> <span class="n">MutableState</span><span class="p">&lt;</span><span class="n">Dp</span><span class="p">&gt;</span> <span class="p">=</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="m">8.</span><span class="n">dp</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="n">Text</span><span class="p">(</span>
</span><span class='line'>    <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;Hello&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="n">paddingState</span><span class="p">.</span><span class="n">value</span><span class="p">)</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="c1">// 通过属性委托来读取</span>
</span><span class='line'><span class="k">var</span> <span class="py">padding</span><span class="p">:</span> <span class="n">Dp</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="m">8.</span><span class="n">dp</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="n">Text</span><span class="p">(</span>
</span><span class='line'>    <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;Hello&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>属性委托的背后，「getter」和「setter」函数用来访问和更新状态的value。这些getter和setter函数仅当你把属性当作一个值来引用时才会被调用，而不是委托被创建时，所以这就是上面两种方式是等价的原因。</p>

<p>当一个被读取状态发生变化时都会被重新执行的每一个代码块都是一个重启作用域（restart scope）。在不同的阶段，Compose会追踪状态值的变化然后重启作用域。</p>

<h2>分阶段的状态读取</h2>

<p>如上面所提及，Compose中有三个主要的阶段，在每个阶段中，Compose会追踪哪些状态被读取了。这让Compose能够仅通知针对UI中受影响的元素需要采取措施的特定阶段。</p>

<blockquote><p>注意：状态实例被创建和存储的地方对阶段几乎无影响，只有状态被读取的时间和地点才有重要影响。</p></blockquote>

<p>我们来仔细检查每一个阶段，然后描述一下在其中当状态被读取时所发生的事情。</p>

<h3>阶段一：组合</h3>

<p>在一个&#64;Composable标注的函数里或者lambda代码块里读取状态会影响组合和后续阶段。当状态值发生变化，重组器（recomposer）会安排所有读取状态的composable函数的重新运行。注意如果函数的输入没有变化，运行时可能会跳过一些甚至所有的composable函数。想了解更多可以看文章<a href="https://juejin.cn/post/7401358349877346338">降Compose十八掌之『损则有孚』| Lifecycle</a>。</p>

<p>取决于组合的结果，Compose UI在执行排版和绘制阶段，如果内容始终相同和大小以及布局未发生变化，它也许会跳过这些阶段。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">var</span> <span class="py">padding</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="m">8.</span><span class="n">dp</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="n">Text</span><span class="p">(</span>
</span><span class='line'>    <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;Hello&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="c1">// 当对象Modifier被构建时，状态`paddin`在组合阶段读取。</span>
</span><span class='line'>    <span class="c1">// 状态`padding`的变化会触发重组</span>
</span><span class='line'>    <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>阶段二：排版</h3>

<p>排版阶段由两个步骤组成：测量和放置。测量步骤运行传递给composable函数的测量lambda，也即诸如接口LayoutModifier的MeasureScope.measure方法等的代码。放置步骤运行layout函数的放置代码块，也即诸如Modifier.offset {&hellip;}的代码块。</p>

<p>这些步骤中的状态读取影响排版编排和后续的绘制阶段。当状态值发生变化，Compose UI会安排排版阶段。如果大小和位置发生变化，它也会执行绘制阶段。</p>

<p>更准确的说，测量步骤和放置步骤有不同的重启作用域（restart scope），也就是说放置步骤中的状态读取不会重新触发它前面测量步骤。然而，这些步骤经常绞在一起，所以放置步骤中的状态读取可能会影响属于测量步骤中的其他重启作用域。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">var</span> <span class="py">offsetX</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="m">8.</span><span class="n">dp</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="n">Text</span><span class="p">(</span>
</span><span class='line'>    <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;Hello&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">offset</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 当offset被计算时，状态`offsetX`在排版阶段中的放置步骤读取</span>
</span><span class='line'>        <span class="c1">// `offsetX`的变化会重启排版</span>
</span><span class='line'>        <span class="n">IntOffset</span><span class="p">(</span><span class="n">offsetX</span><span class="p">.</span><span class="n">roundToPx</span><span class="p">(),</span> <span class="m">0</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>阶段三：绘制</h3>

<p>绘制过程中的状态读取影响绘制阶段。常见的例子包括Canvas()，Modifier.drawBehind和Modifer.drawWithContent函数。当状态值发生变化，Compose UI仅执行绘制阶段。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">var</span> <span class="py">color</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">Red</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="n">Canvas</span><span class="p">(</span><span class="n">modifier</span> <span class="p">=</span> <span class="n">modifier</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 当canvas被渲染时，状态`color`在绘制阶段读取</span>
</span><span class='line'>    <span class="c1">// 状态`color`变化重启绘制</span>
</span><span class='line'>    <span class="n">drawRect</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/phases-state-read-draw.svg" alt="phase_state_read_draw" /></p>

<h2>优化状态读取</h2>

<p>因为Compose进行本地化的状态读取追踪，我们可以通过在合适的阶段读取状态以最小化渲染工作量。</p>

<p>我们来看一下下面的例子。这里有一个Image，使用了offset modifier来作为最终布局位置的偏移，实现一个用户滑动时的平行视觉差的效果：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">Box</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">listState</span> <span class="p">=</span> <span class="n">rememberLazyListState</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Image</span><span class="p">(</span>
</span><span class='line'>        <span class="c1">// ...</span>
</span><span class='line'>        <span class="c1">// 这不是一个最优的实现方式</span>
</span><span class='line'>        <span class="n">Modifier</span><span class="p">.</span><span class="n">offset</span><span class="p">(</span>
</span><span class='line'>            <span class="n">with</span><span class="p">(</span><span class="n">LocalDensity</span><span class="p">.</span><span class="n">current</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="c1">// 在组合中读取状态firstVisibleItemScrollOffset</span>
</span><span class='line'>                <span class="p">(</span><span class="n">listState</span><span class="p">.</span><span class="n">firstVisibleItemScrollOffset</span> <span class="p">/</span> <span class="m">2</span><span class="p">).</span><span class="n">toDp</span><span class="p">()</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">LazyColumn</span><span class="p">(</span><span class="n">state</span> <span class="p">=</span> <span class="n">listState</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// ...</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这个代码能行，但性能并不是最优的。上面的代码读取状态firstVisibleItemScrollOffset然后把它传给函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary#(androidx.compose.ui.Modifier">Modifier.offset</a>.offset(androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp))。当用户滑动时firstVisibleItemScrollOffset的值会变化。我们知道，Compose会追踪任何状态读取以便它能重新执行进行读取的代码，也即例子中函数Box中的内容。</p>

<p>这是一个在组合阶段读取状态的例子。这也并不是一无事处，因为这是重组的基础，让数据变化刷新UI。</p>

<p>但这个例子不是最优做法，因为每次滚动都会导致整个composable函数被重新运行，也会重新测量，重新排版，然后最终重新绘制。尽管要显示的内容并没有真正变化，仅是要显示的位置在变化，但我们每个滚动都会触发Compose的所有阶段。我们可以优化状态读取以仅触发排版阶段。</p>

<p>有offset modifier另外一个版本：<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary#(androidx.compose.ui.Modifier">Modifier.offset(offset: Density.()-> IntOffset)</a>.offset(kotlin.Function1))。这个函数接收一个lambda作为参数，lambda代码块的返回结果作为最终的偏移量。我们来改一下前面的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">Box</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">listState</span> <span class="p">=</span> <span class="n">rememberLazyListState</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Image</span><span class="p">(</span>
</span><span class='line'>        <span class="c1">// ...</span>
</span><span class='line'>        <span class="n">Modifier</span><span class="p">.</span><span class="n">offset</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// 在排版阶段读取状态firstVisibleItemScrollOffset</span>
</span><span class='line'>            <span class="n">IntOffset</span><span class="p">(</span><span class="n">x</span> <span class="p">=</span> <span class="m">0</span><span class="p">,</span> <span class="n">y</span> <span class="p">=</span> <span class="n">listState</span><span class="p">.</span><span class="n">firstVisibleItemScrollOffset</span> <span class="p">/</span> <span class="m">2</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">LazyColumn</span><span class="p">(</span><span class="n">state</span> <span class="p">=</span> <span class="n">listState</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// ...</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>为何这样就性能更优呢？我们提供给modifier的lambda代码块仅在排版阶段调用（具体来说是在排版阶段中的放置步骤），也就是说在组合阶段状态firstVisibleItemScrollOffset不用再被读取了。因为Compose追踪状态什么时候被读取，这次改动意味着如果状态firstVisibleItemScrollOffset值发生变化，Compose仅会重启排版和绘制阶段。</p>

<blockquote><p><strong>注意：</strong> 你也许很好奇接收一个lambda作为参数与接收一个普通值参数相比是否有额外的开销。确实有。然而，在这个场景中，限制状态读取到排版阶段带来的收益要超过参数的开销。在滑动中firstVisibleItemScrollOffset的值每一帧都会发生变化，把状态读取延迟到排版阶段，能避免很多次重组。</p></blockquote>

<p>虽然这个例子靠有不同的offset modifiers可以用来优化最终代码，但思路是通用的：尽可能把状态读取限制到最少的阶段中，让Compose做最少量的渲染工作。</p>

<p>当然了，在组合阶段也常常绝对有必要读取状态。尽管如此，通过过滤状态变化，还是有可以最小化重组发生的场景。想要了解更多的这方面信息，可以读文章<a href="https://juejin.cn/post/7405158681078104127">降Compose十八掌之『龙战于野』| Side Effects</a>。</p>

<h2>重组循环（循环阶段依赖）</h2>

<p>早些时候我们提到过Compose的阶段总会以相同的顺序被调用，并且在一帧中是没有办法往回走的。然而，不同帧之间组合循环依然会发生。看这个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">Box</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">imageHeightPx</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="m">0</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Image</span><span class="p">(</span>
</span><span class='line'>        <span class="n">painter</span> <span class="p">=</span> <span class="n">painterResource</span><span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">drawable</span><span class="p">.</span><span class="n">rectangle</span><span class="p">),</span>
</span><span class='line'>        <span class="n">contentDescription</span> <span class="p">=</span> <span class="s">&quot;I&#39;m above the text&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span>
</span><span class='line'>            <span class="p">.</span><span class="n">fillMaxWidth</span><span class="p">()</span>
</span><span class='line'>            <span class="p">.</span><span class="n">onSizeChanged</span> <span class="p">{</span> <span class="n">size</span> <span class="p">-&gt;</span>
</span><span class='line'>                <span class="c1">// 不要这样做</span>
</span><span class='line'>                <span class="n">imageHeightPx</span> <span class="p">=</span> <span class="n">size</span><span class="p">.</span><span class="n">height</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Text</span><span class="p">(</span>
</span><span class='line'>        <span class="n">text</span> <span class="p">=</span> <span class="s">&quot;I&#39;m below the image&quot;</span><span class="p">,</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span>
</span><span class='line'>            <span class="n">top</span> <span class="p">=</span> <span class="n">with</span><span class="p">(</span><span class="n">LocalDensity</span><span class="p">.</span><span class="n">current</span><span class="p">)</span> <span class="p">{</span> <span class="n">imageHeightPx</span><span class="p">.</span><span class="n">toDp</span><span class="p">()</span> <span class="p">}</span>
</span><span class='line'>        <span class="p">)</span>
</span><span class='line'>    <span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里我们（以不好的方式）实现了一个垂直的列，图片在上面文字在其下面。使用Modifier.onSizeChanged感知图片的实际尺寸，然后通过Modifier.padding作用于文字以让其向下偏移。从Px到Dp的不自然转换已经表明了这段代码有问题。</p>

<p>这个例子的问题在于无法通过一帧就达到最终的排列布局。代码依赖于多帧的绘制，进行了不必要的工作，导致UI会在屏幕上跳跃。</p>

<p>让我们一帧帧的检查来看发生了什么：</p>

<p>在第1帧的组合阶段，imageHeightPx值为0，文字拿到的是Modifier.padding(top = 0)。然后，到了排版阶段，modifier的onSizeChanged回调会被调用。这时imageHeightPx会被更新成为图片的实际高度。Compose为下一帧安排重组。在绘制阶段，文字使用padding 0来渲染，因为这时状态的值还没有被更新。</p>

<p>然后Compose会启动因imageHeightPx的值变化而安排的第2帧渲染。状态是在Box内容代码块中读取，并且是在组合阶段调用的。这回，给到Text的padding是真实的图片的高度。在排版阶段，代码再次修改了imageHeightPx的值，但因为值没有发生变化，所以不会安排重组。</p>

<p>最终，我们得到的text的期望的padding，但是耗费额外的一帧来传递padding值到不同的阶段并不是最优的做法，这会导致带有重叠内容的一帧。</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/phases-recomp-loop.svg" alt="" /></p>

<p>这个例子也许显得有点做作，但要小心这种通用的模式：</p>

<ul>
<li>Modifier.onSizeChanged，onGloballyPositioned，或者一些其他的排版操作</li>
<li>更新一些状态</li>
<li>把状态当作排版modifier（padding(), height()或者类似的）的输入</li>
<li>潜在的重复</li>
</ul>


<p>上面示例的修复办法是使用合适的排版原语。上面例子可以用一个普通的Column()来实现，但你也许会有需要一些定制的更复杂的场景，这些场景可能需要写一些定制化的布局。可以看<a href="https://developer.android.com/develop/ui/compose/layouts/custom">定制布局</a>文档以了解更多。</p>

<p>这里通用的原则是对于需要相互之间测量和旋转的多个UI元素要保持单一数据来源。使用合适的排版原语或者创建一个定制化的布局就意味着最少化的共享父节点可以当作可以协调多个元素之间关联的单一数据源。而引入动态的状态会打破这一原则。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『龙战于野』| Side Effects]]></title>
    <link href="https://alexhilton.github.io/blog/2024/08/23/jetpack-compose-side-effects/"/>
    <updated>2024-08-23T07:56:53+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/08/23/jetpack-compose-side-effects</id>
    <content type="html"><![CDATA[<blockquote><p>主要翻译自官方文档<a href="https://developer.android.com/develop/ui/compose/side-effects">Side-effects in Compose</a>，并不是直译，有些细微调整。</p></blockquote>

<p>一个<strong>副作用</strong>是指发生在composable函数范围之外的应用状态的一个变化。由于composable函数的生命周期和诸如不可预测的重组，以不同的顺序执行composable的重组，或者重组可能会被跳过等性质，理论上composable应该<a href="https://juejin.cn/post/7379437165486112805">要是无副作用</a>的。</p>

<p><a href="https://alexhilton.github.io/blog/2024/08/23/jetpack-compose-side-effects/"><img src="https://ac.appcircle.io/wp-content/uploads/2022/10/compose-side-effects-state.png" title="auto auto" ></a></p>

<!-- more -->


<p>然而，有些时候副作用是必要的，例如，触发一些诸如显示一个非干扰性提示（snackbar）或者在一定状态条件下跳转到另一个页面，等的一次性的事件时。这些行为应该在一个能够感知composable生命周期的可控的环境中调用。在本文中，你将学习Jetpack Compose提供的几种不同的副作用函数（side effect APIs）。</p>

<h2>副作用的具体使用场景</h2>

<p>如在文章<a href="https://juejin.cn/post/7379437165486112805">降Compose十八掌之『潜龙勿用』| Thinking in Compose</a>中提到的，composables应该尽可能的做到无副作用。当需要对应用状态进行修改时，应该使用副作用API，以便副作用函数以可预测的方式运行。</p>

<blockquote><p><strong>关键点：</strong> 一个作用（effect）是指一个composable函数不会生成UI元素，而是当组合完成时生成副作用。</p></blockquote>

<p>由于Compose中有多种作用，很容易被滥用。要确保在副作用中做的事情是UI相关的并且没有违反『单一数据流原则』。</p>

<blockquote><p><strong>注意：</strong> 一个可响应的UI应该是异步的，Jetpack Compose解决异步的办法是在API级别结合协程而不是使用回调。想要了解更多的协程知识，可以参看<a href="https://juejin.cn/post/7329767824200826918">之前的文章</a>。</p></blockquote>

<h3>LaunchedEffect：在composable的作用域内运行挂起函数</h3>

<p>想要在一个composable的生命周期中执行操作并且需要调用挂起函数，就可以使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#LaunchedEffect(kotlin.Any,kotlin.coroutines.SuspendFunction1">LaunchedEffect</a>)。当LaunchedEffect进入组合时，它会使用作为参数传入的代码块来启动一个协程。如果LaucnhedEffect离开了组合协程会被取消。如果因不同的key LaunchedEffect被重组了（副作用的重启机制会在后面进行讲解），运行中的协程会被取消掉，一个新的协程会被启动以运行新的挂起函数。</p>

<p>例如，一个可调节延迟的脉冲式透明度的动画：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="c1">// 变化的速率可以调节，可以加快动画（减少间隔）</span>
</span><span class='line'><span class="k">var</span> <span class="py">pulseRateMs</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="m">3000L</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="k">val</span> <span class="py">alpha</span> <span class="p">=</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">Animatable</span><span class="p">(</span><span class="m">1f</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="n">LaunchedEffect</span><span class="p">(</span><span class="n">pulseRateMs</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 速度作为key，这样速度变化时，会重启副作用，动画也会重启</span>
</span><span class='line'>    <span class="k">while</span> <span class="p">(</span><span class="n">isActive</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="n">pulseRateMs</span><span class="p">)</span> <span class="c1">// 一定间隔之后显示脉冲动画</span>
</span><span class='line'>        <span class="n">alpha</span><span class="p">.</span><span class="n">animateTo</span><span class="p">(</span><span class="m">0f</span><span class="p">)</span>
</span><span class='line'>        <span class="n">alpha</span><span class="p">.</span><span class="n">animateTo</span><span class="p">(</span><span class="m">1f</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中，动画使用了挂起函数<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html">delay</a>来等待一定的时间。然后，它依次使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Animatable#animateTo(kotlin.Any,androidx.compose.animation.core.AnimationSpec,kotlin.Any,kotlin.Function1">animateTo</a>)展现动画到不可见，再到可见。并在composable的生命周期中不断重复。</p>

<h3>rememberCoroutineScope：获取一个可以在composable之外启动协程的可感知组合的协程作用域</h3>

<p>因为LaunchedEffect是一个composable函数，所以它只能在其他composable函数中调用。如果想要在composable作用域之外启动协程，但又希望限制协程在一定的范围内，以便能在离开组合时协程自动被取消，可以使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#rememberCoroutineScope(kotlin.Function0">rememberCoroutineScope</a>)。在任何需要手动操控一个或者多个协程的生命周期的时候都应该使用rememberCorountineScope，比如说当用户事件发生时需要取消动画。</p>

<p>rememberCoroutineScope是一个composable函数，返回一个协程作用域（CoroutineScope），这个作用域会被绑定到经组合中它被调用的地点。当离开组合时，这个协程作用域会被取消。</p>

<blockquote><p><strong>译注：</strong> 如果对协程作用域不太熟悉的同学，可以参看<a href="https://juejin.cn/post/7324351711660048411">之前的文章</a>。</p></blockquote>

<p>例如，可以用下面的代码，当点击按扭时显示一个Snackbar（译注：非干扰式提示，类似于Toast）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">MoviesScreen</span><span class="p">(</span><span class="n">snackbarHostState</span><span class="p">:</span> <span class="n">SnackbarHostState</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 创建一个绑定到MoviesScreen生命周期的协程作用域</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">scope</span> <span class="p">=</span> <span class="n">rememberCoroutineScope</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Scaffold</span><span class="p">(</span>
</span><span class='line'>        <span class="n">snackbarHost</span> <span class="p">=</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">SnackbarHost</span><span class="p">(</span><span class="n">hostState</span> <span class="p">=</span> <span class="n">snackbarHostState</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span> <span class="n">contentPadding</span> <span class="p">-&gt;</span>
</span><span class='line'>        <span class="n">Column</span><span class="p">(</span><span class="n">Modifier</span><span class="p">.</span><span class="n">padding</span><span class="p">(</span><span class="n">contentPadding</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">Button</span><span class="p">(</span>
</span><span class='line'>                <span class="n">onClick</span> <span class="p">=</span> <span class="p">{</span>
</span><span class='line'>                    <span class="c1">// 在作用域中创建一个协程来显示提示。</span>
</span><span class='line'>                    <span class="n">scope</span><span class="p">.</span><span class="n">launch</span> <span class="p">{</span>
</span><span class='line'>                        <span class="n">snackbarHostState</span><span class="p">.</span><span class="n">showSnackbar</span><span class="p">(</span><span class="s">&quot;Something happened!&quot;</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">}</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">Text</span><span class="p">(</span><span class="s">&quot;Press me&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>rememberUpdateState：指向即使值发生变化也不会重启的作用中的一个值</h3>

<p>当参数key中的任何一个发生变化时LaunchedEffect就会重启。然而，在有些情况下我们希望捕获这样作用中的一个值，这个作用不会随着值变化而重启。为了达到这样的效果，需要使用rememberUpdatedState创建一个能被捕获和更新的值的引用。这个方式对于那些含有长时间运行，且重新创建或者重启都非常昂贵之类的操作的副作用是很有用的。</p>

<p>例如，假设你的应用有一个一段时间内消失的加载页面（LandingScreen）。即使这个加载页面被重组了，等待时间副作用和通知已过去了多少时间副作用都不应该被重新启动：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">LandingScreen</span><span class="p">(</span><span class="n">onTimeout</span><span class="p">:</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 这个状态永远指向LandingScreen重组后最新的onTimeout函数</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">currentOnTimeout</span> <span class="k">by</span> <span class="n">rememberUpdatedState</span><span class="p">(</span><span class="n">onTimeout</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 创建一个与LandingScreen生命周期一致的副作用。即使LandingScreen被重组了，这里的延迟不应该重新开始.</span>
</span><span class='line'>    <span class="n">LaunchedEffect</span><span class="p">(</span><span class="k">true</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">delay</span><span class="p">(</span><span class="n">SplashWaitTimeMillis</span><span class="p">)</span>
</span><span class='line'>        <span class="n">currentOnTimeout</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* 加载页面的内容 */</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>想要创建一个与调用点生命周期一至的副作用，可以把像Unit或者true等永不会改变的常量当作参数。在上面的例子中，使用了LaunchedEffect(true)。为了保证lambda onTimeout中总是包含LandingScreen被重组后的最新值，onTimeout需要使用rememberUpdatedState来包装。返回值，就是代码中的currentOnTimeout应该在副作用中使用。</p>

<blockquote><p><strong>注意：</strong> LaunchedEffect(true)就像while(true)一样诡异。即使有具体的使用场景，也要三思后行，确保确实需要这样做。</p></blockquote>

<h3>DisposableEffect：需要清理工作的副作用</h3>

<p>对于当离开组合或者key发生变化时需要清朝工作的副作用，使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#DisposableEffect(kotlin.Any,kotlin.Function1">DisposableEffect</a>)。如果DisposableEffect的key发生变化，调用的composable需要进行清理副作用，并且重新调用。</p>

<p>作为一个示例，通过使用<a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleObserver">LifecycleObserver</a>，你也许想要发送基于平台生命周期事件（Lifecycle events）统计事件数据（译注：这里的生命周期是指Android平台组件的生命周期）。想要在Compose中监听这些事件，使用一个DisposableEffect来在需要时注册和反注册观察者：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">HomeScreen</span><span class="p">(</span>
</span><span class='line'>    <span class="n">lifecycleOwner</span><span class="p">:</span> <span class="n">LifecycleOwner</span> <span class="p">=</span> <span class="n">LocalLifecycleOwner</span><span class="p">.</span><span class="n">current</span><span class="p">,</span>
</span><span class='line'>    <span class="n">onStart</span><span class="p">:</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">,</span> <span class="c1">// 发送&#39;started&#39; 事件</span>
</span><span class='line'>    <span class="n">onStop</span><span class="p">:</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Unit</span> <span class="c1">// 发磅 &#39;stopped&#39; 事件</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 保证当前的lambda是最新的</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">currentOnStart</span> <span class="k">by</span> <span class="n">rememberUpdatedState</span><span class="p">(</span><span class="n">onStart</span><span class="p">)</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">currentOnStop</span> <span class="k">by</span> <span class="n">rememberUpdatedState</span><span class="p">(</span><span class="n">onStop</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 如果 `lifecycleOwner` 发生变化，清理并重置副作用函数</span>
</span><span class='line'>    <span class="n">DisposableEffect</span><span class="p">(</span><span class="n">lifecycleOwner</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 创建一个观察者以触发我们的事件发送回调lambda</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">observer</span> <span class="p">=</span> <span class="n">LifecycleEventObserver</span> <span class="p">{</span> <span class="n">_</span><span class="p">,</span> <span class="n">event</span> <span class="p">-&gt;</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="p">==</span> <span class="n">Lifecycle</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">ON_START</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">currentOnStart</span><span class="p">()</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">event</span> <span class="p">==</span> <span class="n">Lifecycle</span><span class="p">.</span><span class="n">Event</span><span class="p">.</span><span class="n">ON_STOP</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">currentOnStop</span><span class="p">()</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 把观察者添加到生命周期观察者列表里</span>
</span><span class='line'>        <span class="n">lifecycleOwner</span><span class="p">.</span><span class="n">lifecycle</span><span class="p">.</span><span class="n">addObserver</span><span class="p">(</span><span class="n">observer</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 当离开组合时，进行清理工作，即把观察者从其列表中移除</span>
</span><span class='line'>        <span class="n">onDispose</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">lifecycleOwner</span><span class="p">.</span><span class="n">lifecycle</span><span class="p">.</span><span class="n">removeObserver</span><span class="p">(</span><span class="n">observer</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="cm">/* Home screen content */</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中，副作用会添加一个观察者observer到lifecycleOwner上。如果lifecycleOwner有变动，副作用函数会被清理并且使用新的lifecycleOwner重启。</p>

<p>一个DispoableEffect必须要包含一个onDispose语句作为其代码块的最后一个语句。否则会有编译错误。</p>

<blockquote><p><strong>注意：</strong> 使用一个空的onDispose并不是一个好的做法。要多思考一下是否有更加符合使用场景的副作用函数。</p></blockquote>

<h3>SideEffect：向非Comopse代码发布Compose的状态</h3>

<p>要与非Compose管理的对象共享Compose状态时，使用composable <a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#SideEffect(kotlin.Function0">SideEffect</a>)。使用SideEffect能够保证副作用在每次成功重组后都能得到执行。另一方面，在一个重组保证成功之前执行一个副作用是不正确的，这种场景就会直接在composable中写入副作用。</p>

<p>例如，你的分析库也许允许你通过给后面的统计数据添加自定义的meta data（在此例中是『user properties』）的方式来给用户数据分段。为了建立当前用户的用户类型与统计库之间的联系，可以使用SideEffect来更新此值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">rememberFirebaseAnalytics</span><span class="p">(</span><span class="n">user</span><span class="p">:</span> <span class="n">User</span><span class="p">):</span> <span class="n">FirebaseAnalytics</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">analytics</span><span class="p">:</span> <span class="n">FirebaseAnalytics</span> <span class="p">=</span> <span class="n">remember</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">FirebaseAnalytics</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 每次成功组合，用当前用户的用户类型来更新 FirebaseAnalytics，保证</span>
</span><span class='line'>    <span class="c1">// 后面的统计事件能带上userType</span>
</span><span class='line'>    <span class="n">SideEffect</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">analytics</span><span class="p">.</span><span class="n">setUserProperty</span><span class="p">(</span><span class="s">&quot;userType&quot;</span><span class="p">,</span> <span class="n">user</span><span class="p">.</span><span class="n">userType</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">analytics</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>produceState：把非Compose状态转化为Compose状态</h3>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#produceState(kotlin.Any,kotlin.coroutines.SuspendFunction1">produceState</a>)启动一个受组合管控的协程作用域，其中可以把值转化为状态。用它可以把非Compose状态转化为Compose状态，例如把外部由订阅驱动 的值如Flow，LiveData或者RxJava转化到组合中。</p>

<p>当produceState进入组合时生产者就会被启动，然后当离开组合时被取消。返回的状态会合并：就是说相同的值不会再次触发重组。</p>

<p>尽管produceState会创建协程，它也能用来监听非挂起数据。想要移除对数据的订阅，使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/ProduceStateScope#awaitDispose(kotlin.Function0">awaitDispose</a>)函数。</p>

<p>下面的例子展示如何使用produceState来从网络加载图片。Composable函数loadNextworkImage返回一个可以用在其他composables中的状态：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">loadNetworkImage</span><span class="p">(</span>
</span><span class='line'>    <span class="n">url</span><span class="p">:</span> <span class="n">String</span><span class="p">,</span>
</span><span class='line'>    <span class="n">imageRepository</span><span class="p">:</span> <span class="n">ImageRepository</span> <span class="p">=</span> <span class="n">ImageRepository</span><span class="p">()</span>
</span><span class='line'><span class="p">):</span> <span class="n">State</span><span class="p">&lt;</span><span class="n">Result</span><span class="p">&lt;</span><span class="n">Image</span><span class="p">&gt;&gt;</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// 用 Result.Loading 作为初值，创建一个状态 State&lt;T&gt;</span>
</span><span class='line'>    <span class="c1">// 如果 「url」或者「imageRepository」任何一个发生变化，运行中的生产者会被取消</span>
</span><span class='line'>    <span class="c1">// 使用新的输入被重启。</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">produceState</span><span class="p">&lt;</span><span class="n">Result</span><span class="p">&lt;</span><span class="n">Image</span><span class="p">&gt;&gt;(</span><span class="n">initialValue</span> <span class="p">=</span> <span class="n">Result</span><span class="p">.</span><span class="n">Loading</span><span class="p">,</span> <span class="n">url</span><span class="p">,</span> <span class="n">imageRepository</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 在协程里，可以调用挂起函数</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">image</span> <span class="p">=</span> <span class="n">imageRepository</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 使用成功或者失败作为结果 来更新状态</span>
</span><span class='line'>        <span class="c1">// 这会触发读取此状态的composable的重组</span>
</span><span class='line'>        <span class="n">value</span> <span class="p">=</span> <span class="k">if</span> <span class="p">(</span><span class="n">image</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">Result</span><span class="p">.</span><span class="n">Error</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">Result</span><span class="p">.</span><span class="n">Success</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<blockquote><p><strong>注意：</strong> 带有返回值的composable函数应该以常规的Kotlin函数命名规范进行命名，以小写字符开头的驼峰式。</p></blockquote>

<p><br/></p>

<blockquote><p><strong>关键点：</strong> 进一步的了解，produceState使用了其他的副作用函数！它使用remember { mutableStateOf(initialValue) }来持有返回结果，然后在一个LaunchedEffect中触发生产者代码块。每当生产者代码块中更新了value的值，相应的状态也会被更新。
开发者也可以基于现有的API来创造想要的副作用函数</p></blockquote>

<h3>derivedStateOf：把一个或者多个状态对象转化为另一个状态</h3>

<p>在Compose中，每次当被观察的状态对象发生变化或者composable的输入有变化时重组就会发生。状态对象或者输入可能变化次数的超过了UI实际的需要，导致了不必要的重组。</p>

<p>当一个composable的输入变化超过了重组所需要时就应该使用函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#derivedStateOf(kotlin.Function0">deriveStateOf</a>)。比较觉的场景是当有些变量频繁的变动，比如滚动位置，但composable仅需要变动超过一定阈值时才需要对其响应。derivedStateOf创建一个新的仅在需要时更新的可观察Compose状态。这样，它就类似于Kotlin Flow中的操作符<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/distinct-until-changed.html">distinctUntilChanged</a>。</p>

<blockquote><p><strong>注意：</strong> derivedStateOf是比较昂贵的（也即性能开销比较大），应该仅用来减少结果未变化时的不必要的重组。</p></blockquote>

<h4>正确的使用</h4>

<p>下面的代码片段展示一个恰当的使用derivedStateOf的场景：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="c1">// 当参数 messages 变化时, MessageList会被重组. derivedStateOf不会影响这个重组</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">MessageList</span><span class="p">(</span><span class="n">messages</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Message</span><span class="p">&gt;)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Box</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">listState</span> <span class="p">=</span> <span class="n">rememberLazyListState</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">LazyColumn</span><span class="p">(</span><span class="n">state</span> <span class="p">=</span> <span class="n">listState</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// ...</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// 当第一个可见的元素不是第一个元素时显示按扭。用一个被记忆的衍生状态来最小化不必要的重组</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">showButton</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">derivedStateOf</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">listState</span><span class="p">.</span><span class="n">firstVisibleItemIndex</span> <span class="p">&gt;</span> <span class="m">0</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">AnimatedVisibility</span><span class="p">(</span><span class="n">visible</span> <span class="p">=</span> <span class="n">showButton</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">ScrollToTopButton</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这个代码片段中，每次第一个可见的元素变化时firstVisibleItemIndex都会变化。当滚动时，它的值会变成0，1，2，3，4，5等等。然而，仅当值大于0时才需要重组。这个更新频次的不匹配意味着是一个使用derivedStateOf的好的场景。</p>

<h4>错误的使用</h4>

<p>一个常见的错误是想当然的认为当需要合并两个状态时，就需要使用derivedStateOf，因为在创建衍生状态。然而这完全是凭空想像的也不是必须的，如下面代码所展示：</p>

<blockquote><p><strong>注意：</strong> 下面的代码展示derivedStateOf不正确的用例。不要这样使用。</p></blockquote>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="c1">// 不要这样用，不正确的derivedStateOf的用法</span>
</span><span class='line'><span class="k">var</span> <span class="py">firstName</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="k">var</span> <span class="py">lastName</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">mutableStateOf</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="py">fullNameBad</span> <span class="k">by</span> <span class="n">remember</span> <span class="p">{</span> <span class="n">derivedStateOf</span> <span class="p">{</span> <span class="s">&quot;$firstName $lastName&quot;</span> <span class="p">}</span> <span class="p">}</span> <span class="c1">// 很糟糕</span>
</span><span class='line'><span class="k">val</span> <span class="py">fullNameCorrect</span> <span class="p">=</span> <span class="s">&quot;$firstName $lastName&quot;</span> <span class="c1">// 不正确</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码中，fullName的更新频次与firstName和lastName是一样的。因此，不会有不必要的重组发生，使用derivedStateOf是多余的。</p>

<h3>snapshotFlow</h3>

<p>使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#snapshotFlow(kotlin.Function0">snapshotFlow</a>)能把状态对象（<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/State">State<T></a> objects）转化为一个冷流（cold Flow）。当被订阅（collected）时snapshotFlow会运行代码块在其中发送它读取到的状态对象。当在snapshotFlow代码块中读取的状态对象发生变化时，Flow会发送新的数据给它的订阅者，如果这个新的数据没有被发送过（这个行为与<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/distinct-until-changed.html">Flow.distinctUntilChanged</a>是类似的）。</p>

<blockquote><p><strong>译注：</strong> 对Flow不熟悉的同学可以参看<a href="https://juejin.cn/post/7336751931375648820">之前的文章</a>。</p></blockquote>

<p>下面的例子展示一个副作用，用以记录当用户滑动超过列表中首个元素时的统计信息：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">listState</span> <span class="p">=</span> <span class="n">rememberLazyListState</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="n">LazyColumn</span><span class="p">(</span><span class="n">state</span> <span class="p">=</span> <span class="n">listState</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">LaunchedEffect</span><span class="p">(</span><span class="n">listState</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">snapshotFlow</span> <span class="p">{</span> <span class="n">listState</span><span class="p">.</span><span class="n">firstVisibleItemIndex</span> <span class="p">}</span>
</span><span class='line'>        <span class="p">.</span><span class="n">map</span> <span class="p">{</span> <span class="n">index</span> <span class="p">-&gt;</span> <span class="n">index</span> <span class="p">&gt;</span> <span class="m">0</span> <span class="p">}</span>
</span><span class='line'>        <span class="p">.</span><span class="n">distinctUntilChanged</span><span class="p">()</span>
</span><span class='line'>        <span class="p">.</span><span class="n">filter</span> <span class="p">{</span> <span class="n">it</span> <span class="p">==</span> <span class="k">true</span> <span class="p">}</span>
</span><span class='line'>        <span class="p">.</span><span class="n">collect</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">MyAnalyticsService</span><span class="p">.</span><span class="n">sendScrolledPastFirstItemEvent</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中，listState.firstVisibleItemIndex会被转化为一个Flow，方便使用Flow操作符带来的便利。</p>

<h2>副作用的重启</h2>

<p>Compose中的一些副作用，像LaunchedEffect，produceState，DispoableEffect，接收不定数量的参数keys，这些参数用于取消正在进行中的副作用和使用新的参数启动新的副作用。</p>

<p>这些API的典型形式是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">EffectName</span><span class="p">(</span><span class="n">restartIfThisKeyChanges</span><span class="p">,</span> <span class="n">orThisKey</span><span class="p">,</span> <span class="n">orThisKey</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span> <span class="n">block</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>由于这个行为的细微性质，如果用于重启副作用的参数并不是正确的参数时，就会产生问题：</p>

<ul>
<li>副作用重启次数少于预期可能会产生bug</li>
<li>重启次数多于预期是冗余的，影响性能</li>
</ul>


<p>首要的原则是，在副作用代码块中使用的可变的和不可变的变量都应该当成composable函数的参数。此外，也可以添加更多的参数以强制重启副作用。如果一个变量的变化不应该导致重启副作用，那这个变量应该用rememberUpdateState包裹起来。如果一个变量因为包裹在remember时没有key而永远不会变化，那么这个变量就应该作为key传给副作用函数。</p>

<blockquote><p><strong>关键点：</strong> 在副作用函数中使用的变量应该添加为函数的参数，或者使用rememberUpdateState包裹起来。</p></blockquote>

<p>在上面展示的DisposbaleEffect代码中，在代码块中使用的变量lifecycleOwner作为副作用函数的一个参数，因为它们的任何变化都会引发重启副作用。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">HomeScreen</span><span class="p">(</span>
</span><span class='line'>    <span class="n">lifecycleOwner</span><span class="p">:</span> <span class="n">LifecycleOwner</span> <span class="p">=</span> <span class="n">LocalLifecycleOwner</span><span class="p">.</span><span class="n">current</span><span class="p">,</span>
</span><span class='line'>    <span class="n">onStart</span><span class="p">:</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">,</span> <span class="c1">// Send the &#39;started&#39; analytics event</span>
</span><span class='line'>    <span class="n">onStop</span><span class="p">:</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Unit</span> <span class="c1">// Send the &#39;stopped&#39; analytics event</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// 这些值在组合中永不会变化，因此用remember包裹起来，以免引发冗余重启</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">currentOnStart</span> <span class="k">by</span> <span class="n">rememberUpdatedState</span><span class="p">(</span><span class="n">onStart</span><span class="p">)</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">currentOnStop</span> <span class="k">by</span> <span class="n">rememberUpdatedState</span><span class="p">(</span><span class="n">onStop</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">DisposableEffect</span><span class="p">(</span><span class="n">lifecycleOwner</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">observer</span> <span class="p">=</span> <span class="n">LifecycleEventObserver</span> <span class="p">{</span> <span class="n">_</span><span class="p">,</span> <span class="n">event</span> <span class="p">-&gt;</span>
</span><span class='line'>            <span class="cm">/* ... */</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">lifecycleOwner</span><span class="p">.</span><span class="n">lifecycle</span><span class="p">.</span><span class="n">addObserver</span><span class="p">(</span><span class="n">observer</span><span class="p">)</span>
</span><span class='line'>        <span class="n">onDispose</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">lifecycleOwner</span><span class="p">.</span><span class="n">lifecycle</span><span class="p">.</span><span class="n">removeObserver</span><span class="p">(</span><span class="n">observer</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>currentOnState和currentOnStop不需要作为DisposableEffect的参数key，因为使用了rememberUpdateState它们在组合中始终不会变化。如果不把lifecycleOwner作为参数传递，然后它又发生了变化，HomeScreen会重组，但DisposableEffect不会被清理和重启。这会导致之后使用的都是错误的lifecyleOwner（译注：因为lifecycleOwner可能会发生变化）。</p>

<h3>常量作为key</h3>

<p>可以使用像true这样的常量当作副作用的key，以让它跟它所在的调用点有一样的生命周期。有一些场景适合这样用：比如前面例子中的LaunchedEffect。但是，在这样做之前还是要三思是否真的要这样。</p>

<h2>总结</h2>

<p>函数式编程的理想情况是每个函数都没有副作用，但实际情况副作用却是必须的。通过本文我们学习了如何使用Jetpack Compose提供的副作用函数以解决修改composable范围以外的状态的问题。副作用问题比较难以实现且容易产生难以debug的问题，要仔细分析问题的场景，根据场景选择合适的副作用函数。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[贡献法算法总结]]></title>
    <link href="https://alexhilton.github.io/blog/2024/08/18/credit-algorithm-made-easy/"/>
    <updated>2024-08-18T12:57:52+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/08/18/credit-algorithm-made-easy</id>
    <content type="html"><![CDATA[<p>贡献法是一种比较偏门的算法，与贪心类似，并没有固定的范式，思路也非常的清奇。用朴素的方式通常会超时，或者甚至整理不出来思路，无法实现编码。</p>

<p>这类算法题型，更多的还是要靠经验和思维，遇到类似的题目就往贡献法上想。</p>

<p><a href="https://alexhilton.github.io/blog/2024/08/18/credit-algorithm-made-easy/"><img src="https://www.investopedia.com/thmb/J33BG-Cf03bW8-O4kXJfuht3gHA=/1500x0/filters:no_upscale\(\):max_bytes\(150000\):strip_icc\(\)/algorithm-df9b57e8ea7c494b891da25987643fab.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>总的来说，贡献法就是不直接思考如何做运算，而是运算之后净增量或者净减少量，或者当前元素在运行过后对净增量或者净减量的贡献值是多少，从这个角度去思考。</p>

<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sum-of-subsequence-widths/description/">891. 子序列宽度之和</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sum-of-subsequence-widths/solutions/2809957/xi-you-yuan-su-891-zi-xu-lie-kuan-du-zhi-igda/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sum-of-subarray-minimums/description/">907. 子数组的最小值之和</a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/distribute-coins-in-binary-tree/description/">979. 在二叉树中分配硬币</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/distribute-coins-in-binary-tree/solutions/2770062/xi-you-yuan-su-979-zai-er-cha-shu-zhong-xg0ef/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-subarray-min-product/description/">1856. 子数组最小乘积的最大值</a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sum-of-subarray-ranges/description/">2104. 子数组范围和</a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sum-of-total-strength-of-wizards/description/">2281. 巫师的总力量和</a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/power-of-heroes/description/">2681. 英雄的力量</a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://blog.csdn.net/weixin_60033897/article/details/136580127">算法学习系列（四十）：贡献法</a></li>
<li><a href="https://blog.csdn.net/qq_43406895/article/details/131514319">【算法】贡献法相关题目练习</a></li>
<li><a href="https://juejin.cn/post/7350185416652275712">贡献法（总体之和等于个体贡献度之和）（蓝桥杯）</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『损则有孚』| Lifecycle]]></title>
    <link href="https://alexhilton.github.io/blog/2024/08/18/jetpack-compose-lifecycle/"/>
    <updated>2024-08-18T12:14:35+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/08/18/jetpack-compose-lifecycle</id>
    <content type="html"><![CDATA[<blockquote><p>这篇文章大部分是<a href="https://developer.android.com/develop/ui/compose/lifecycle">官方文档</a>的翻译，但并不是严格的翻译，同时也加入了笔者自己的理解。</p></blockquote>

<p>通过前面的一系列文章我们已经基本掌握了使用Jetpack Compose来构建UI的方法，在接下来的几篇文章中将重点转移到Compose本身，理解一下Compose是如何把一坨坨的函数（Composables）转化成为目标平台UI的。先从composable的生命周期开始。</p>

<p><a href="https://alexhilton.github.io/blog/2024/08/18/jetpack-compose-lifecycle/"><img src="https://koenig-media.raywenderlich.com/uploads/2022/05/LifecycleOfComposablesInJetpackCompose-twitter.png" title="auto auto" ></a></p>

<!-- more -->


<p><strong>注意：</strong> 这里的生命周期是指Compose中的基本单元composable函数的生命周期，与目标平台（如Android）的生命周期不是一个概念，没有关系。</p>

<h2>概述</h2>

<p>在前面<a href="https://juejin.cn/post/7376094685495001139">讲解状态（State）的文章</a>中提到过，composable函数是Jetpack Compose的基本单元，运行composables就是组合（Composition），组合将会变成应用的UI。</p>

<p>当Jetpack Compose首次运行composables时，也即首次组合（Initial composition），它会追踪在组合中用来描述UI的composables。之后，当有状态变化时，Jetpack Compose会安排重组。重组就是重新执行状态发生变化的composables以作为对状态变化的响应，然后再更新组合体现变更。</p>

<p>组合仅能在首次组合过程中生成然后在重组中更新。修改组合的唯一方式就是通过重组。</p>

<h2>生命周期定义</h2>

<p>一个composable的生命周期可以用三个事件来定义：进入组合，重组，离开组合。</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-composition.png" alt="lifecycle" /></p>

<blockquote><p>图1. 组合中的一个composable的生命周期：进入组合，没有重组或者重组多次，最后离开组合。</p></blockquote>

<p>重组通常都是由状态对象发生变化触发的。Compose会追踪这些状态然后执行在组合中读取这些状态的所有composables，以及被这些composables调用的且无法被跳过的composables。</p>

<p><strong>注意：</strong> Composable的生命周期较View系统和Android平台的Activity以及Fragment要相对简单一些。如果一个composable需要处理外部的资源或者管理更为复杂的生命周期，可以使用副作用（Side Effects）。</p>

<p>如果一个composable被调用了多次，就会有多个实例被放入到组合之中。每一次调用都有独立的属于它自己的生命周期。来看一个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">MyComposable</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Column</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span><span class="s">&quot;Hello&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="n">Text</span><span class="p">(</span><span class="s">&quot;World&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-hierarchy.png" alt="composition" /></p>

<blockquote><p>图2. 在组合中MyComposable的可视化表示。如果一个composable被调用了多次，会在组合中生成多个实例。图中不同颜色的元素代表不同的实例。</p></blockquote>

<h2>剖析组合中的composables</h2>

<p>组合中一个composable实例是用其调用点来标识的。Compose编译器认为每个调用点都是不一样的。从多个调用点调用composables会在组合中创建多个实例。</p>

<p><strong>关键术语：</strong> 调用点指的是composable被调用的代码位置。调用点会影响组合，进而影响最终UI。</p>

<p>在重组过程中，如果一个composable调用了与其上一次重组中调用的不同的composables，Compose会标识出哪些composables已调用过，哪些还未被调用过，对于两次组合中都调用了的composables，如果它们的输入没有变化则Compose不会予以执行。</p>

<p>因此，给关联到composable的副作用（各种Side Effects）指定标识就显得龙为重要，这样它们能成功的执行完成，而不是每次重组时都重新启动。</p>

<p>对于下面这个例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">LoginScreen</span><span class="p">(</span><span class="n">showError</span><span class="p">:</span> <span class="n">Boolean</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">showError</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">LoginError</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="n">LoginInput</span><span class="p">()</span> <span class="c1">// This call site affects where LoginInput is placed in Composition</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">LoginInput</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">LoginError</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码中，函数LoginScreen会在一定条件下调用函数LogginError，并且总是会调用函数LoginInput。每个调用都有一个独一无二的调用点和代码位置，编译器正是用这些信息来独一无二的标识每个composable。
<img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-showerror.png" alt="recomposition" /></p>

<blockquote><p>图3. 在组合中，当有状态变化和重组发生时，LoginScreen的可视化展示。相同的颜色元素代表没有被重组。</p></blockquote>

<p>尽管LoginInput从第一个被调用的函数变成了第二个被调用的函数，它的实例在重组中得以留存。并且，因为LoginInput并没有在重组之间发生变化的参数，Compose会跳过对LoginInput的再次调用。</p>

<h2>提供额外的信息以优化重组</h2>

<p>多次调用一个composable会在组合中添加多个实例。当在同一个调用点多次调用同一个composable时，因为Compose没有可用的信息来独一无二的标识每个调用，所以composable的执行顺序被用以区别这些composable实例。有些时候这也够用了，但有些时候这会导致一些非预期的行为。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">MoviesScreen</span><span class="p">(</span><span class="n">movies</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Movie</span><span class="p">&gt;)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Column</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">movie</span> <span class="k">in</span> <span class="n">movies</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// MovieOverview composables are placed in Composition given its</span>
</span><span class='line'>            <span class="c1">// index position in the for loop</span>
</span><span class='line'>            <span class="n">MovieOverview</span><span class="p">(</span><span class="n">movie</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在上面的代码中，Compose会用执行顺序来区别调用的composable实例。如果一个新的数据元素movie被添加到了列表的底部（最后面），Compose可以复用已经在组合中的实例，因为它们的位次没有变化，故而这些composable的输入数据元素movie并不会变化，也就是说因为只在最后添加，先前存在的实例与其数据还是能够对应得上的。</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-newelement-bottom.png" alt="no_key" /></p>

<blockquote><p>图4. 当一个新数据元素moviei添加到列表底部后时，组合中MovieScreen的可视化表示。组合中函数MovieOverview的实例会被复用。相同颜色的元素表示未被重组。</p></blockquote>

<p>然而，如果输入列表的变化是在其顶部添加新元素，或者在中间添加新元素，或者有移除，或者变化元素顺序时，就会对列表中位置发生变化的所有MovieOverview进行重组。如果有储如在MovieOverview中获取电影图片的副作用函数的话，这些仅因位置改变而发生的重组就特别重要了。因为重组会影响副作用函数，如果副作用正在进行中，会被取消然后重新启动。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">MovieOverview</span><span class="p">(</span><span class="n">movie</span><span class="p">:</span> <span class="n">Movie</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Column</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// Side effect explained later in the docs. If MovieOverview</span>
</span><span class='line'>        <span class="c1">// recomposes, while fetching the image is in progress,</span>
</span><span class='line'>        <span class="c1">// it is cancelled and restarted.</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">image</span> <span class="p">=</span> <span class="n">loadNetworkImage</span><span class="p">(</span><span class="n">movie</span><span class="p">.</span><span class="n">url</span><span class="p">)</span>
</span><span class='line'>        <span class="n">MovieHeader</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="cm">/* ... */</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-newelement-top-all-recompose.png" alt="side_effect" /></p>

<blockquote><p>图5. 新元素添加到列表中时组合中MovieScreen的可视化表示。MovieScreen实例无法复用，所有的副作用会重启。不同的颜色代表发生了重组。</p></blockquote>

<p>理想情况下，应该让函数MovieScreen的实例标识与其数据项的标识联系起来。如果列表数据项顺序有变化，最为想理的办法是也把组合树中的对应的函数实例进行次序调整，而不是进行重组（前面说了次序作为函数实例的标识，次序变了，就要使用新位置的数据项调用composable进行重组）。Compose给我们提供了一个方法用以标识组会树中的函数实例：即<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#key(kotlin.Array,kotlin.Function0">函数key</a>)。</p>

<p>把代码块放入函数key里面，再传给函数key一些数据，这些数据会被组合起来以标识组合中的函数实例。传给函数key的数据不必是全局唯一的，它只需要在key所在的调用点是唯一的就行。比如在前面例子中，每个数据项movie需要有一个唯一的标识，它能在这个列表中唯一标识一部电影就可以了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">MoviesScreenWithKey</span><span class="p">(</span><span class="n">movies</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Movie</span><span class="p">&gt;)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">Column</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">for</span> <span class="p">(</span><span class="n">movie</span> <span class="k">in</span> <span class="n">movies</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">key</span><span class="p">(</span><span class="n">movie</span><span class="p">.</span><span class="n">id</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Unique ID for this movie</span>
</span><span class='line'>                <span class="n">MovieOverview</span><span class="p">(</span><span class="n">movie</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>像上面用了key以后，无论列表怎么变化，Compose都能辩识出具体composable实例，然后加以复用：
<img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-newelement-top-keys.png" alt="key" /></p>

<blockquote><p>图6. 当新数据元素添加到列表时组合中MovieScreen的可视化展示。因为有了唯一标识，Compose能识别出哪些实例未发生变化，加以复用，它们附带的副作用会继续执行。</p></blockquote>

<p><strong>关键点：</strong> 适度的使用函数key来帮助Compose唯一标识函数实例。特别是针对在同一个调用点大量调用同一个composable时，比如在各种集合性布局中。</p>

<p>有些composable有更为友好的key支持方法。比如像LazyColumn它可以直接在其items DSL中传入一个lambda作为key：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">MoviesScreenLazy</span><span class="p">(</span><span class="n">movies</span><span class="p">:</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Movie</span><span class="p">&gt;)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">LazyColumn</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">items</span><span class="p">(</span><span class="n">movies</span><span class="p">,</span> <span class="n">key</span> <span class="p">=</span> <span class="p">{</span> <span class="n">movie</span> <span class="p">-&gt;</span> <span class="n">movie</span><span class="p">.</span><span class="n">id</span> <span class="p">})</span> <span class="p">{</span> <span class="n">movie</span> <span class="p">-&gt;</span>
</span><span class='line'>            <span class="n">MovieOverview</span><span class="p">(</span><span class="n">movie</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>重组时跳过composable的策略</h2>

<p>在重组过程中，一些具备条件的composable函数可以让Compose跳过他们的执行，如果它们的输入参数较前一次组合时没有任何变化。
除了以下情况外，就可以说一个composable函数具备跳过条件：</p>

<ul>
<li>函数有返回值（non-Unit return type）</li>
<li>函数使用了注解&#64;NonRestartableComposable或者&#64;NonSkippableComposable修饰</li>
<li>必需的参数是一个非稳定类型（non-stable type）</li>
</ul>


<p>前两个都好理解，接下来重点看第三个情况。一个类型要想成为稳定的（stable），必须符合以下约定：</p>

<ul>
<li>对于两个相内实例来说，对其们使用equals方法的返回值必须永远相同</li>
<li>如果一个类型的公开属性发生变化，组合会得到通知</li>
<li>所有公开属性类型也必须是稳定的</li>
</ul>


<p>有一些重要的常见类型符合这个约定，Compose编译器会把它们当成稳定的类型，尽管他们并没有使用注解&#64;Stable显式地标注为稳定的：</p>

<ul>
<li>所有的基础数据类型：布尔（Boolean），整数（Int），长整数（Long），浮点（Float），字符（Char）等</li>
<li>字符串（String）</li>
<li>所有的函数类型（lambdas）</li>
</ul>


<p>所有这些类型都能符合稳定约定，因为他们都是不可变类型。因为不可变类型实例不会改变，它们不会通知组合说值有所改变，因此就能符合上述约定。</p>

<p><strong>注意：</strong> 所有的整体不可变类型都可以安全地当成稳定的类型。</p>

<p>一个值得注意的类型是可变状态类型（MutableState），虽然是稳定的但却可变可修改。如果MutableState中持有一个值，这个状态对象被认为是稳定的，因为State属性.value发生的任何变化都会通知给Compose。</p>

<p>当作为传递给一个composable函数参数的所有类型都是稳定的（stable）时，这些参数的值会基于它们在UI树中的函数位置进行等值比较（equality）。从前一次组合起如果值未变化就会跳过其重组。换句话说输入参数的类型是稳定的（stable）是一个大前提，只有稳定的类型比较等值才有意义。</p>

<p><strong>关键点：</strong> 如果一个composable的输入是稳定的且未有变化，Compose就会跳过它的重组。等值比较使用的是方法equals。</p>

<p>仅当Compose能够证明一个类型是稳定的时，才会把一个类型当作稳定的。例如，接口（interface）通常认为是不稳定的，拥有可变公开属性的类型，虽然这些属性的实现可以是不可变的，但这种类型也认为是不稳定的。</p>

<p>如果Compose无法推断出一个类型是不是稳定的，但是想强制它被当作稳定的类型，可以使用注解&#64;Stable来标注。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="c1">// Marking the type as stable to favor skipping and smart recompositions.</span>
</span><span class='line'><span class="n">@Stable</span>
</span><span class='line'><span class="n">interface</span> <span class="n">UiState</span><span class="p">&lt;</span><span class="n">T</span> <span class="p">:</span> <span class="n">Result</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">value</span><span class="p">:</span> <span class="n">T</span><span class="p">?</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">exception</span><span class="p">:</span> <span class="n">Throwable</span><span class="p">?</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">val</span> <span class="py">hasError</span><span class="p">:</span> <span class="n">Boolean</span>
</span><span class='line'>        <span class="k">get</span><span class="p">()</span> <span class="p">=</span> <span class="n">exception</span> <span class="p">!=</span> <span class="k">null</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面的代码片段中，因为UiState是一个接口，会被当成不稳定的类型。通过添加注解&#64;Stable，告诉Compose它是稳定的，让Compose进行智能重组。这也意味着，当接口类型用于参数类型时，Compose会把接口的所有具体实现当成稳定的类型。</p>

<p><strong>关键点：</strong> 如果Compose无法推断出类型的稳定性，使用注解&#64;Stable来标注以让Compose进行智能重组。</p>

<h2>总结</h2>

<p>Composable函数是Compose的基本单元，通过此文我们理解了一个composable的生命周期，并对Compose的重组机制做了介绍，以及如何更好的让Compose做智能重组。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/lifecycle">Lifecycle of composables</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『密云不雨』| Navigation]]></title>
    <link href="https://alexhilton.github.io/blog/2024/08/12/navigation-with-compose/"/>
    <updated>2024-08-12T07:46:31+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/08/12/navigation-with-compose</id>
    <content type="html"><![CDATA[<p>除了一些玩具性的Demo以外，相信任何一个应用程序不可能只有一个页面，最为极简的应用也至少会有两个页面，一个主页和一个设置页。对于传统的View系统来说对于导航这块没有专门的API，一般都是自己写逻辑跳Activity，或者跳到Fragment，然后再反向的Back，所以有了很多三方的各种Router类库（如大阿里的ARouter，货拉拉的TheRouter）。其实谷歌已经提供了解决方案，在Jetpack中提供了<a href="https://developer.android.com/guide/navigation">Navigation组件</a>，专门用于解决应用内部各种页面之间跳转的问题。</p>

<p><a href="https://alexhilton.github.io/blog/2024/08/12/navigation-with-compose/"><img src="https://blog.mindorks.com/images/banner-jetpack-compose-navigation-657edc7b323cafdf.png" title="auto auto" ></a></p>

<!-- more -->


<p>对于Jetpack Compose来说，因为是全新的框架，在设计之初就考虑到了导航的问题，但也不是重新开发了一套新库，而是把Jetpack中的组件Navigation深度的结合了进来。换句话说，在Jetpack Compose中可以直接使用Navigation组件来进行页面之间的跳转，并且有非常符合Compose的粘合API，使用起来非常的丝滑顺手。</p>

<h2>基本概念</h2>

<p>在深入之前有必要先澄清Navigation中的一些概念，了解了一些基本的概念和术语之后，会有助于理解组件的设计理念，也会更容易上手使用。</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 术语 </th>
<th style="text-align:left;"> 用途 </th>
<th style="text-align:left;"> 具体的Composable </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> Host </td>
<td style="text-align:left;"> 包含了当前导航页面的容器。应该把它理解成为导航的容器，包含着当前的页面， 以及一个NavController。 </td>
<td style="text-align:left;"> <a href="https://developer.android.com/reference/kotlin/androidx/navigation/compose/package-summary#NavHost(androidx.navigation.NavHostController,androidx.navigation.NavGraph,androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1">NavHost</a>) </td>
</tr>
<tr>
<td style="text-align:center;"> Graph </td>
<td style="text-align:left;"> 静态的数组结构，定义着一个应用中的所有页面，以及它们之间应该如何跳转。 </td>
<td style="text-align:left;"> <a href="https://developer.android.com/reference/androidx/navigation/NavGraph">NavGraph</a> </td>
</tr>
<tr>
<td style="text-align:center;"> Controller </td>
<td style="text-align:left;"> 页面之间导航的核心管理者。它封装着如何在页面之间跳转的方法，处理链接的方法，以及返回堆栈的方法。 </td>
<td style="text-align:left;"> <a href="https://developer.android.com/reference/androidx/navigation/NavController">NavController</a> </td>
</tr>
<tr>
<td style="text-align:center;"> Destination </td>
<td style="text-align:left;"> 在Graph中的一个节点。当跳转到这个节点时，Host中就包含并展示它的页面。在实际项目中，往往是一个Fragment或者一个Composable，也就是一个页面。 </td>
<td style="text-align:left;"> <a href="https://developer.android.com/reference/androidx/navigation/NavDestination">NavDestination</a> </td>
</tr>
<tr>
<td style="text-align:center;"> Route </td>
<td style="text-align:left;"> Destination的全局唯一标识，包括其所需要的参数。大部分时候，特别是在Compose中，这就是一坨类似于Uri一样的String </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p>还需要说明一下的就是导航的基本的操作对象是一个页面，一个页面可以理解为一个全屏的，逻辑上内聚，内容上互相关联，自成一家的一个UI页面，比如说一个应用的主页是一个页面，文章列表是一个页面，文章详情是一个页面，设置是一个页面，用户页又是一个页面。当然，这里全屏并不是直观的全屏，意思是说（特别是对于Compose）一个页面的大小是受系统控制的，并不能像普通的Composable那样随意设置大小，对于手机就是全屏的，对于平板可能会一个占据三分之一（列表页），一个占据三分之二（详情页）。</p>

<h2>使用Navigation</h2>

<p>Jetpack Compose是声明式UI，是函数式编程，每一个Composable都是一个函数，所以在Compose中使用Navigation略微的有点不一样。核心原理和核心的规则肯定与Navigation是一样一样的，只是使用上的API略不一样，其实是更简单更方便了（这是声明式UI带来的收益）。</p>

<h3>添加依赖</h3>

<p>在使用之前先要添加Navigation库作为项目的依赖：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">dependencies</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">navVersion</span> <span class="p">=</span> <span class="s">&quot;2.7.7&quot;</span>
</span><span class='line'>    <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;androidx.navigation:navigation-runtime-ktx:$navVersion&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="n">implementation</span><span class="p">(</span><span class="s">&quot;androidx.navigation:navigation-compose:$navVersion&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>使用Navigation的方法</h3>

<p>可以通过以下步骤来使用Navigation：</p>

<ul>
<li>创建NavHost，并设置为应用的入口，通过Composable函数<a href="https://developer.android.com/reference/kotlin/androidx/navigation/compose/package-summary#NavHost(androidx.navigation.NavHostController,androidx.navigation.NavGraph,androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1">NavHost</a>)。</li>
<li>创建NavController，可以直接创建，但推荐的方式是使用Compose提供的状态构造函数<a href="https://developer.android.com/reference/kotlin/androidx/navigation/compose/package-summary#rememberNavController(kotlin.Array">rememberNavController</a>)，它的好处在于当前导航会提升为一个状态。</li>
<li>定义Destination和Route，其实对于Compose来说都是用类似于Uri的String来作为Destination，每一个Destition唯一对应着一个页面。</li>
<li>添加页面，通过函数NavHost的尾部lambda，它实际上是一个<a href="https://developer.android.com/reference/kotlin/androidx/navigation/NavGraphBuilder">NavGraphBuilder</a>的扩展函数，这里调用函数<a href="https://developer.android.com/reference/kotlin/androidx/navigation/compose/package-summary#(androidx.navigation.NavGraphBuilder">composable</a>.composable(kotlin.collections.Map,kotlin.collections.List,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function2))来添加页面。</li>
<li>配置跳转，通过前面创建的navController来实现跳转，用<a href="https://developer.android.com/reference/kotlin/androidx/navigation/NavController#navigate(android.net.Uri">navController.navigate</a>)来跳转到指定的Destination，用<a href="https://developer.android.com/reference/androidx/navigation/NavController#popBackStack(">navController.popBackStack</a>)来返回到前一个页面。而触发的入口肯定是在具体的页面之中，所以页面要把其跳转函数作为参数，在NavGraphBuilder时，再用NavController去实现，这样所有的跳转逻辑就都在NavGraph中，便于管理。</li>
</ul>


<h3>具体实例</h3>

<p>说了那么多貌似挺烦杂的，让我们看一个实例就会瞬间明白。</p>

<p>一个简单的应用有4个页面，先定义Destinations：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">object</span> <span class="nc">Destinations</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">const</span> <span class="k">val</span> <span class="py">APP_URI</span> <span class="p">=</span> <span class="s">&quot;http://toughcoder.net/chronos&quot;</span>
</span><span class='line'>    <span class="n">const</span> <span class="k">val</span> <span class="py">HOME_ROUTE</span> <span class="p">=</span> <span class="s">&quot;home&quot;</span> <span class="c1">// 主页</span>
</span><span class='line'>    <span class="n">const</span> <span class="k">val</span> <span class="py">HISTORY_ROUTE</span> <span class="p">=</span> <span class="s">&quot;history&quot;</span> <span class="c1">// 历史记录页面</span>
</span><span class='line'>    <span class="n">const</span> <span class="k">val</span> <span class="py">SETTINGS</span> <span class="p">=</span> <span class="s">&quot;settings&quot;</span> <span class="c1">// 设置页</span>
</span><span class='line'>    <span class="n">const</span> <span class="k">val</span> <span class="py">ARTICLES</span> <span class="p">=</span> <span class="s">&quot;articles&quot;</span> <span class="c1">// 文章页</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>那么就可以如此配置Navigation：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">@Composable</span>
</span><span class='line'><span class="k">fun</span> <span class="nf">ChronosNavGraph</span><span class="p">(</span>
</span><span class='line'>    <span class="n">modifier</span><span class="p">:</span> <span class="n">Modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">,</span>
</span><span class='line'>    <span class="n">navController</span><span class="p">:</span> <span class="n">NavHostController</span> <span class="p">=</span> <span class="n">rememberNavController</span><span class="p">(),</span>
</span><span class='line'>    <span class="n">start</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="n">Destinations</span><span class="p">.</span><span class="n">HOME_ROUTE</span> <span class="c1">// 默认的初始页面为主页</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">NavHost</span><span class="p">(</span>
</span><span class='line'>        <span class="n">modifier</span> <span class="p">=</span> <span class="n">modifier</span><span class="p">,</span>
</span><span class='line'>        <span class="n">navController</span> <span class="p">=</span> <span class="n">navController</span><span class="p">,</span>
</span><span class='line'>        <span class="n">startDestination</span> <span class="p">=</span> <span class="n">start</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">composable</span><span class="p">(</span>
</span><span class='line'>            <span class="n">route</span> <span class="p">=</span> <span class="n">Destinations</span><span class="p">.</span><span class="n">HOME_ROUTE</span><span class="p">,</span>
</span><span class='line'>            <span class="n">deepLinks</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span>
</span><span class='line'>                <span class="n">navDeepLink</span> <span class="p">{</span> <span class="n">uriPattern</span> <span class="p">=</span> <span class="s">&quot;${Destinations.APP_URI}/${Destinations.HOME_ROUTE}&quot;</span> <span class="p">}</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>        <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">ChronosScreen</span><span class="p">(</span>
</span><span class='line'>                <span class="n">gotoSettings</span> <span class="p">=</span> <span class="p">{</span> <span class="n">navController</span><span class="p">.</span><span class="n">navigate</span><span class="p">(</span><span class="n">Destinations</span><span class="p">.</span><span class="n">SETTINGS</span><span class="p">)</span> <span class="p">},</span>
</span><span class='line'>                <span class="n">gotoHistory</span> <span class="p">=</span> <span class="p">{</span> <span class="n">navController</span><span class="p">.</span><span class="n">navigate</span><span class="p">(</span><span class="n">Destinations</span><span class="p">.</span><span class="n">HISTORY_ROUTE</span><span class="p">)</span> <span class="p">},</span>
</span><span class='line'>                <span class="n">gotoArticles</span> <span class="p">=</span> <span class="p">{</span> <span class="n">navController</span><span class="p">.</span><span class="n">navigate</span><span class="p">(</span><span class="n">Destinations</span><span class="p">.</span><span class="n">ARTICLES</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">composable</span><span class="p">(</span>
</span><span class='line'>            <span class="n">route</span> <span class="p">=</span> <span class="n">Destinations</span><span class="p">.</span><span class="n">HISTORY_ROUTE</span><span class="p">,</span>
</span><span class='line'>            <span class="n">deepLinks</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span>
</span><span class='line'>                <span class="n">navDeepLink</span> <span class="p">{</span> <span class="n">uriPattern</span> <span class="p">=</span> <span class="s">&quot;${Destinations.APP_URI}/${Destinations.HISTORY_ROUTE}&quot;</span> <span class="p">}</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>        <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">HistoryScreen</span><span class="p">(</span>
</span><span class='line'>                <span class="n">viewModel</span> <span class="p">=</span> <span class="n">viewModel</span><span class="p">()</span>
</span><span class='line'>            <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">navController</span><span class="p">.</span><span class="n">popBackStack</span><span class="p">()</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">composable</span><span class="p">(</span>
</span><span class='line'>            <span class="n">route</span> <span class="p">=</span> <span class="n">Destinations</span><span class="p">.</span><span class="n">SETTINGS</span><span class="p">,</span>
</span><span class='line'>            <span class="n">deepLinks</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span>
</span><span class='line'>                <span class="n">navDeepLink</span> <span class="p">{</span> <span class="n">uriPattern</span> <span class="p">=</span> <span class="s">&quot;${Destinations.APP_URI}/${Destinations.SETTINGS}&quot;</span> <span class="p">}</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>        <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">SettingsScreen</span><span class="p">(</span>
</span><span class='line'>                <span class="n">viewModel</span> <span class="p">=</span> <span class="n">viewModel</span><span class="p">()</span>
</span><span class='line'>            <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">navController</span><span class="p">.</span><span class="n">popBackStack</span><span class="p">()</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">composable</span><span class="p">(</span>
</span><span class='line'>            <span class="n">route</span> <span class="p">=</span> <span class="n">Destinations</span><span class="p">.</span><span class="n">ARTICLES</span><span class="p">,</span>
</span><span class='line'>            <span class="n">deepLinks</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span>
</span><span class='line'>                <span class="n">navDeepLink</span> <span class="p">{</span> <span class="n">uriPattern</span> <span class="p">=</span> <span class="s">&quot;${Destinations.APP_URI}/${Destinations.ARTICLES}&quot;</span> <span class="p">}</span>
</span><span class='line'>            <span class="p">)</span>
</span><span class='line'>        <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">ArticlesScreen</span><span class="p">(</span>
</span><span class='line'>                <span class="n">viewModel</span> <span class="p">=</span> <span class="n">viewModel</span><span class="p">()</span>
</span><span class='line'>            <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">navController</span><span class="p">.</span><span class="n">popBackStack</span><span class="p">()</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以看到每一个composable函数用以创建一个导航页面，里面有其Route，具体的页面，以及跳转的入口函数。deepLinks是每个页面的Uri式的链接，后面会详细的讲解。</p>

<p>最后就是把这个NavGraph作为应用的入口页面：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="n">Bundle</span><span class="p">?)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">super</span><span class="p">.</span><span class="n">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">)</span>
</span><span class='line'>        <span class="n">setContent</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">ChronosTheme</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">Surface</span><span class="p">(</span>
</span><span class='line'>                    <span class="n">modifier</span> <span class="p">=</span> <span class="n">Modifier</span><span class="p">.</span><span class="n">fillMaxSize</span><span class="p">(),</span>
</span><span class='line'>                    <span class="n">color</span> <span class="p">=</span> <span class="n">MaterialTheme</span><span class="p">.</span><span class="n">colorScheme</span><span class="p">.</span><span class="n">background</span>
</span><span class='line'>                <span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                    <span class="n">ChronosNavGraph</span><span class="p">()</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>在页面之间传递参数</h2>

<p>页面跳转还必然会涉及参数的传递，比如具有递进关系的两个页面，核心参数肯定要由前一个页传递过去，最为典型的场景就是列表类页面到详情页面的跳转，比如文章列表要把文章的Id传给详情页，这样详情页才知道去展示哪个文章，用户列表要把用户Id传给详情页，详情页才知道展示哪个用户。</p>

<p>Navigation提供了传递参数的方法，在创建导航页面时传入的Route可以加入占位符形参，然后在跳转navController.navigate时可以传入实参，只不过参数的类型有限制，只能是基础数据类型如字串或者数字。目标页面使用时通过backStackEntry.arguments来获得参数。来具体看一下，比如说传递用户Id的场景：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">NavHost</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">composable</span><span class="p">(</span>
</span><span class='line'>          <span class="s">&quot;profile/{userId}&quot;</span><span class="p">,</span>
</span><span class='line'>          <span class="n">arguments</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="n">navArgument</span><span class="p">(</span><span class="s">&quot;userId&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="k">type</span> <span class="p">=</span> <span class="n">NavType</span><span class="p">.</span><span class="n">StringType</span> <span class="p">}</span> <span class="c1">// 这句可以省略，因为默认类型都当成是字符串</span>
</span><span class='line'>    <span class="p">)</span> <span class="p">{</span> <span class="n">backStackEntry</span> <span class="p">-&gt;</span>
</span><span class='line'>          <span class="n">Profile</span><span class="p">(</span><span class="n">navController</span><span class="p">,</span> <span class="n">backStackEntry</span><span class="p">.</span><span class="n">arguments</span><span class="o">?.</span><span class="n">getString</span><span class="p">(</span><span class="s">&quot;userId&quot;</span><span class="p">))</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面参数类型的声明，其实可以省略，因为默认的类型都当成String来解析和处理，如果是其他类型则需要显式地声明。这样目标页面的参数就声明好了，我们在跳转的时候传入实参就可以了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">navController</span><span class="p">.</span><span class="n">navigate</span><span class="p">(</span><span class="s">&quot;profile/user1234&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>大部分时候参数都是<strong>必填参数</strong>，像上面这样写userId是必填的参数。但有些时候一些非核心的参数，可能不是每次跳转都会传，这就需要页面把参数声明为<strong>可选参数</strong>。可选参数在声明的时候Uri中必须使用查询式语句，如（&#8221;?argName={argName}&ldquo;），另外必须 设置默认值，或者类型是nullable的。这也意味着我们不能省略导航页面构建composable函数中的arguments参数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">composable</span><span class="p">(</span>
</span><span class='line'>    <span class="s">&quot;profile?userId={userId}&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="n">arguments</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="n">navArgument</span><span class="p">(</span><span class="s">&quot;userId&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="n">defaultValue</span> <span class="p">=</span> <span class="s">&quot;user1234&quot;</span> <span class="p">})</span> <span class="c1">// 注意这里的默认值，当调用navigate时如果不传userId就用这个默认值</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span> <span class="n">backStackEntry</span> <span class="p">-&gt;</span>
</span><span class='line'>    <span class="n">Profile</span><span class="p">(</span><span class="n">navController</span><span class="p">,</span> <span class="n">backStackEntry</span><span class="p">.</span><span class="n">arguments</span><span class="o">?.</span><span class="n">getString</span><span class="p">(</span><span class="s">&quot;userId&quot;</span><span class="p">))</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>注意：</strong> 要尽可能的使用基本的数据类型，如String，Int或者Long，而不传递复杂的数据。复杂的数据通常都是业务逻辑数据，而业务逻辑数据应该使用基本的参数，再从数据源处（通常是通过ViewModel从Repo处）去主动获取，这样才能保证数据的真实有效。这是设计原则中的『单一数据源原则Single Source of Truth』。复杂数据从Repo处获取后，可能会变得过时或者失真，而且在页面之间传递会有拷贝，效率也不高，因此要避免在页面之间传递复杂数据。</p>

<h2>处理DeepLinks</h2>

<p>DeepLinks是Uri式的链接跳转范式，能够以字符串形式的Uri精准的定位到某个应用的具体某个页面，就犹如互联网中的Uri一样。它的好处在于形成了一个统一的标准，形式简单方便，一个字符串就能定位到一个页面。</p>

<p>使用导航页面构建函数composable在构建页面的时候可以传入<a href="https://developer.android.com/reference/androidx/navigation/NavDeepLink">NavDeepLink</a>对象，更为方便的是使用其构建函数<a href="https://developer.android.com/reference/kotlin/androidx/navigation/package-summary#navDeepLink(kotlin.Function1">navDeepLink</a>)：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="k">val</span> <span class="py">uri</span> <span class="p">=</span> <span class="s">&quot;https://www.example.com&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">composable</span><span class="p">(</span>
</span><span class='line'>    <span class="s">&quot;profile?id={id}&quot;</span><span class="p">,</span>
</span><span class='line'>    <span class="n">deepLinks</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="n">navDeepLink</span> <span class="p">{</span> <span class="n">uriPattern</span> <span class="p">=</span> <span class="s">&quot;$uri/{id}&quot;</span> <span class="p">})</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span> <span class="n">backStackEntry</span> <span class="p">-&gt;</span>
</span><span class='line'>    <span class="n">Profile</span><span class="p">(</span><span class="n">navController</span><span class="p">,</span> <span class="n">backStackEntry</span><span class="p">.</span><span class="n">arguments</span><span class="o">?.</span><span class="n">getString</span><span class="p">(</span><span class="s">&quot;id&quot;</span><span class="p">))</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>从示例中可以看出Uri中还可以带有参数，形参的声明，以及参数的获取与前面提到的页面参数是一样一样的，如果实际传过来的Uri是&#8221;<a href="https://www.example.com/user123">https://www.example.com/user123</a>&#8220;，到此页面后，就能解析出参数id为user123。</p>

<p>正常情况下这些DeepLinks只能在应用内部使用，如果要对应用外开放，则需要在应用的AndroidManifest文件中进行声明，声明为intent filter：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;activity</span> <span class="err">…</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;intent-filter&gt;</span>
</span><span class='line'>    ...
</span><span class='line'>    <span class="nt">&lt;data</span> <span class="na">android:scheme=</span><span class="s">&quot;https&quot;</span> <span class="na">android:host=</span><span class="s">&quot;www.example.com&quot;</span> <span class="nt">/&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/intent-filter&gt;</span>
</span><span class='line'><span class="nt">&lt;/activity&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>页面跳转过渡动画</h2>

<p>页面跳转可以指定具体的过渡动画，具体的可以参考<a href="https://juejin.cn/post/7385758285960609831#heading-10">前面专门讲动画的那篇文章</a>，这里就不再重复了。</p>

<h2>Route的类型安全</h2>

<p>通常情况下Route都是使用Uri式的String，但这明显不够安全，因为调用navController#navigate的时候，可能会传一个不认识的页面Route，或者参数传错了（比如数字参数传了String），等等。轻则跳转失败，因为找不到Destination页面，重则会Crash。要想类型安全，就不能使用String式的Uri，需要把Ruote定义为类型（也即class），但要使用注解&#64;Serializeable标记一下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="c1">// 主页面，不带任何参数</span>
</span><span class='line'><span class="n">@Serializable</span>
</span><span class='line'><span class="k">object</span> <span class="nc">Home</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// 用户页面，参数是用户Id，其类型是一个String</span>
</span><span class='line'><span class="n">@Serializable</span>
</span><span class='line'><span class="n">data</span> <span class="k">class</span> <span class="nc">Profile</span><span class="p">(</span><span class="k">val</span> <span class="py">id</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在构建导航页面的时候，函数composable其实是一个泛型函数，它可以指定Route的参数类型：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">NavHost</span><span class="p">(</span><span class="n">navController</span><span class="p">,</span> <span class="n">startDestination</span> <span class="p">=</span> <span class="n">Home</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>     <span class="n">composable</span><span class="p">&lt;</span><span class="n">Home</span><span class="p">&gt;</span> <span class="p">{</span> <span class="c1">// 泛型函数，可以指定参数类型</span>
</span><span class='line'>         <span class="n">HomeScreen</span><span class="p">(</span><span class="n">onNavigateToProfile</span> <span class="p">=</span> <span class="p">{</span> <span class="n">id</span> <span class="p">-&gt;</span>
</span><span class='line'>             <span class="n">navController</span><span class="p">.</span><span class="n">navigate</span><span class="p">(</span><span class="n">Profile</span><span class="p">(</span><span class="n">id</span><span class="p">))</span> <span class="c1">// 跳转的时候传入的实参是一个对象，类型就是上面定义的Route</span>
</span><span class='line'>         <span class="p">})</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>     <span class="n">composable</span><span class="p">&lt;</span><span class="n">Profile</span><span class="p">&gt;</span> <span class="p">{</span> <span class="n">backStackEntry</span> <span class="p">-&gt;</span>
</span><span class='line'>         <span class="k">val</span> <span class="py">profile</span><span class="p">:</span> <span class="n">Profile</span> <span class="p">=</span> <span class="n">backStackEntry</span><span class="p">.</span><span class="n">toRoute</span><span class="p">()</span>  <span class="c1">// 获取参数的时候，用toRoute来获得Route对象，类型就是我们定义的那个</span>
</span><span class='line'>         <span class="n">ProfileScreen</span><span class="p">(</span><span class="n">profile</span><span class="p">.</span><span class="n">id</span><span class="p">)</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在跳转的时候就可以把Route对象作为实参传进去：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='Kotlin'><span class='line'><span class="n">navController</span><span class="p">.</span><span class="n">navigate</span><span class="p">(</span><span class="n">Profile</span><span class="p">(</span><span class="n">id</span> <span class="p">=</span> <span class="m">123</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样因为都是定义的类型，所以编译器会做编译时检查，虚拟机也会做运行时的类型检查，保证类型安全。</p>

<p><strong>注意：</strong> 不要混淆，这里Route虽然是自定义类型，但并不算是在页面之间传递复杂的业务数据，因为具体的参数仍是诸如String和Int之类的基础数值。把Route定义为类型（class），而不是直接使用String，是为了让编译器帮忙我们保证类型安全，减少出错。</p>

<h2>总结</h2>

<p>使用Navigation可以非常轻松的把应用的各个页面组织连接起来，形成一个完整的交互闭环。谷歌也提供了相应的<a href="https://developer.android.com/codelabs/jetpack-compose-navigation#0">CodeLab</a>可以学习一下。此外，谷歌的一些Sample app，像<a href="https://github.com/android/sunflower/tree/main">Sunflower</a>和<a href="https://github.com/android/compose-samples/tree/main/JetNews">JetNews</a>也是使用Navigation来实现导航的，是非常好的学习案例。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/navigation">Navigation with Compose</a></li>
<li><a href="https://developer.android.com/guide/navigation">Navigation</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
