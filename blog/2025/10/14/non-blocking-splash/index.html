
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>突破速度障碍：非阻塞启动画面如何将Android 应用启动时间缩短90% - 稀有猿诉</title>
  <meta name="author" content="Alex Hilton">

  
  <meta name="description" content="本文论述如何通过架构创新优化Android应用启动画面性能的案例研究，其中包括你需要了解的权衡因素（trade-offs）。">
  <meta name="keywords" content="Splash, NonBlocking, Concurrency">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="https://alexhilton.github.io/blog/2025/10/14/non-blocking-splash">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="稀有猿诉" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="https://code.jquery.com/jquery-3.6.4.min.js" integrity="sha256-oP6HI9z1XaZNBrJURtCoUT5SUnxFr8s3BzRl+cbzUq8=" crossorigin="anonymous"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/toolbar.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.lug.ustc.edu.cn/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.lug.ustc.edu.cn/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

<!-- for Gitment -->
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">

<!-- for favicon -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">稀有猿诉</a></h1>
  
    <h2>十年磨一剑，历炼出锋芒，说话千百句，不如码二行。</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com.hk/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:alexhilton.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Home</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/donation">Donation</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">突破速度障碍：非阻塞启动画面如何将Android 应用启动时间缩短90%</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2025-10-14T22:41:32+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2025</span></span> <span class='time'>10:41 pm</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><blockquote><p>本文译自「Breaking the Speed Barrier: How Non-Blocking Splash Screens Cut Android App Launch Time by 90%」，原文链接<a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90">https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90</a>，由Sankalp Chauhan发布于2025年9月28日。</p></blockquote>

<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#overview">概述</a></h2>

<p>正值佳节期间，我们在每个应用上都能看到精美的启动画面和自定义徽标。在开发这些应用时，每个 Android 开发者都会面临启动画面的困境：用户期望获得美观且品牌化的启动体验，但 Google 原生的启动画面 API 却存在明显的局限性。创建自定义 <strong>SplashActivity</strong> 的常见解决方案看似合理，但却会引入隐藏的性能损失，导致应用运行缓慢且响应迟钝。</p>

<p><a href="/blog/2025/10/14/non-blocking-splash/"><img src="https://sankalpchauhan.com/2db6f13d4b8881938f2fccacd47ff90b/untitled-design-1-.mp4.gif" title="auto auto" ></a></p>

<!-- more -->


<p>为了应对这一挑战，我开发了一个名为<strong>EventSplash</strong>的测试库，该库实现了一种非阻塞启动画面方法。完整的实现和基准测试代码可在 GitHub 上获取：<a href="https://github.com/sankalpchauhan-me/fast-splash-experiment">fast-splash-experiment</a>（链接：<a href="https://github.com/sankalpchauhan-me/fast-splash-experiment%EF%BC%89%E3%80%82">https://github.com/sankalpchauhan-me/fast-splash-experiment%EF%BC%89%E3%80%82</a></p>

<p>本案例研究通过一项对照实验，比较了传统的基于活动的启动画面和创新的基于视图的启动画面方法，并提供了实证证据。使用<strong>保守的同类比较</strong>，结果显示：<strong>页面加载时间缩短 90%</strong>，<strong>首次内容绘制时间提升 78%</strong>，<strong>完全绘制时间缩短 41%</strong>。</p>

<p>我们将探索 Lottie 等复杂动画可能带来的显著优势，同时明确并发处理的利弊权衡和资源成本。</p>

<ul>
<li><strong>首次内容绘制 (FCP)</strong>：屏幕上出现第一个有意义内容的时间</li>
<li><strong>完全绘制时间 (FPT)</strong>：屏幕完全渲染并可交互的时间</li>
<li><strong>冷启动</strong>：应用在进程未运行时启动（性能影响最大）</li>
<li><strong>卡顿</strong>：用户认为性能不佳的卡顿或掉帧</li>
<li><strong>TTID/TTFD</strong>：初始显示时间/完全绘制时间（Android 官方指标）</li>
<li><strong>内存压力</strong>：可用内存极低时的系统状态</li>
<li><strong>低内存终止程序 (LMK)</strong>：在内存压力下终止进程的 Android 守护进程</li>
<li><strong>Choreographer.doFrame</strong>：Android 的帧协调系统，用于管理动画、输入和绘制</li>
</ul>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#the-problem-statement">问题声明</a></h3>

<p>Google 原生的 Android 12+ SplashScreen API 性能出色，但自定义选项有限 <a href="https://developer.android.com/develop/ui/views/launch/splash-screen">[1]</a>。它不支持：</p>

<ul>
<li>视频背景</li>
<li>Lottie 动画</li>
<li>复杂的品牌元素</li>
<li>促销/活动期间的促销内容</li>
<li>自定义过渡效果</li>
</ul>


<p>这迫使开发者不得不进行自定义实现，通常使用专用的“SplashActivity”。虽然这种方法提供了创作自由，但它会创建一个<strong>阻塞序列</strong>，从而延迟应用主内容的显示。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#why-traditional-splash-activities-hurt-performance">为什么传统的闪屏活动会损害性能</a></h3>

<p>Android 文档强调，应用应该针对冷启动进行优化，因为这“也可以提高温启动和热启动的性能”<a href="https://developer.android.com/topic/performance/vitals/launch-time">[2]</a>。然而，传统的闪屏实现方式违背了这一原则。</p>

<p>当你使用单独的“SplashActivity”时，系统必须：</p>

<ol>
<li>创建并初始化启动画面 Activity</li>
<li>扩展启动画面视图</li>
<li>运行启动画面动画直至完成</li>
<li>销毁启动画面 Activity</li>
<li>创建并初始化主 Activity</li>
<li>扩展主内容视图</li>
</ol>


<p>这种顺序流程意味着你的主内容在启动画面完成之前无法开始加载，这是一个影响用户感知性能的根本架构缺陷。</p>

<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#the-journey-exploring-different-approaches">折腾：探索不同的方法</a></h2>

<p>在最终确定 EventSplash 实现方案之前，我探索了几种方法。了解这些探索为最终的设计决策提供了宝贵的背景，并展示了性能优化的迭代本质。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#discarded-approach-the-translucent-activity-overlay">弃用的方法：半透明 Activity 覆盖</a></h3>

<p>最初的想法是使用带有半透明主题的“SplashActivity”覆盖“MainActivity”。理论上，MainActivity 可以在后台加载，而启动画面则显示在最上面。</p>

<p><strong>启动顺序：</strong></p>

<ol>
<li>应用以具有半透明主题的 SplashActivity 启动</li>
<li>SplashActivity 显示在 MainActivity 之上，但不会完全遮挡 MainActivity</li>
<li>短暂延迟或初始化完成后，SplashActivity 结束，MainActivity 显露出来</li>
</ol>


<p><strong>弃用原因：</strong></p>

<p>这种方法导致<strong>14% 的性能下降</strong>。问题在于 Android 处理 Activity 生命周期和渲染的方式。系统并非真正并行启动两个 Activity。相反，它创建了一种顺序依赖关系，GPU 被迫组合两个独立的 Activity 缓冲区，这会在 RAM 和电池方面造成巨大的开销，有时甚至会禁用窗口过渡动画。</p>

<p>正如 Android 文档中关于半透明 Activity 的说明 <a href="https://medium.com/androiddevelopers/the-android-lifecycle-cheat-sheet-part-iv-49946659b094">[3]</a>：</p>

<blockquote><p>“窗口管理器会保持原先的屏幕表面按 Z 轴顺序排列，并将新的屏幕表面混合在其上方。原先的 Activity 仍然可以通过新窗口中任何透明或部分透明的像素看到。”</p></blockquote>

<p>正是这种混合操作导致了性能下降。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#the-winning-approach-the-gated-splash-screen-mechanism">制胜之道：门控启动画面机制</a></h3>

<p>我最终找到了一种更复杂的方法，它采用了<strong>门控启动画面机制</strong>。此方法使用“ViewTreeObserver.OnPreDrawListener”来阻止所有 UI 渲染，直到满足特定条件为止。</p>

<p><strong>工作原理：</strong></p>

<ol>
<li>启动时，会立即将 <code>OnPreDrawListener</code> 附加到 Activity 的 <code>decorView</code> 上。</li>
<li>监听器的 <code>onPreDraw()</code> 方法返回 <code>false</code>，从而有效阻止所有绘制操作。</li>
<li>监听器仅在所有条件都满足时才返回 <code>true</code>，允许内容渲染。</li>
</ol>


<p><strong>关键实现：</strong></p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="c1">// The gate mechanism</span>
</span><span class='line'>
</span><span class='line'><span class="n">gate</span><span class="p">.</span><span class="n">onPreDraw</span><span class="p">()</span> <span class="err">→</span> <span class="n">returns</span> <span class="k">false</span> <span class="p">=</span> <span class="n">BLOCK</span> <span class="n">all</span> <span class="n">drawing</span>
</span><span class='line'>
</span><span class='line'><span class="n">gate</span><span class="p">.</span><span class="n">onPreDraw</span><span class="p">()</span> <span class="err">→</span> <span class="n">returns</span> <span class="k">true</span> <span class="p">=</span> <span class="n">ALLOW</span> <span class="n">drawing</span> <span class="n">to</span> <span class="n">proceed</span>
</span></code></pre></td></tr></table></div></figure>


<p>这种方法完全符合 Android 官方文档中关于延长启动画面在屏幕上停留时间的建议 <a href="https://developer.android.com/develop/ui/views/launch/splash-screen">[1]</a>:</p>

<blockquote><p>“如果你需要加载少量数据，例如从本地磁盘异步加载应用内设置，可以使用 ViewTreeObserver.OnPreDrawListener 暂停应用以绘制其第一帧。”</p></blockquote>

<p>EventSplash 库扩展了这一概念，在应用启动时提供对用户可见内容的帧完美控制，防止任何内容闪烁，确保无缝体验。</p>

<p><img src="https://sankalpchauhan.com/static/6810168ee26fb4ae7c236e03fbdd71bc/e5715/view-hirearchy.png" alt="DecorView 将包含我们的 SplashView 和 ContentView" /></p>

<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#the-experiment-measuring-real-world-impact">实验：测量实际影响</a></h2>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#test-environment">测试环境</a></h3>

<ul>
<li><strong>设备</strong>：小米 POCO F1，Android 10</li>
<li><strong>构建</strong>：发布配置</li>
<li><strong>方法</strong>：每个配置 35 次冷启动，每次运行之间暂停 2 秒</li>
<li><strong>指标</strong>：自定义 PerfTracker 库，用于测量页面加载时间、FCP 和 FPT</li>
<li><strong>脚本</strong>：通过 <code>perf_loop.sh</code> 自动执行可重复性</li>
</ul>


<p>所有测试代码和脚本均可在 <a href="https://github.com/sankalpchauhan-me/fast-splash-experiment">GitHub 代码库</a> （链接：<a href="https://github.com/sankalpchauhan-me/fast-splash-experiment%EF%BC%89%E8%8E%B7%E5%8F%96%EF%BC%8C%E4%BB%A5%E7%A1%AE%E4%BF%9D%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7%E3%80%82">https://github.com/sankalpchauhan-me/fast-splash-experiment%EF%BC%89%E8%8E%B7%E5%8F%96%EF%BC%8C%E4%BB%A5%E7%A1%AE%E4%BF%9D%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7%E3%80%82</a></p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#implementation-approaches-tested">测试的实现方法</a></h3>

<ol>
<li><strong>默认阻塞闪屏</strong>：简单的 <code>SplashActivity</code> 和基本路由（保守的基准）</li>
<li><strong>默认非阻塞闪屏</strong>：EventSplash 库和简单的叠加层</li>
<li><strong>Lottie 阻塞闪屏</strong>：传统方法和复杂的动画</li>
<li><strong>Lottie 非阻塞闪屏</strong>：EventSplash 与 Lottie 动画并行运行</li>
</ol>


<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#results-conservative-claims-with-dramatic-potential">结果：保守的声明，但效果显著潜力</a></h2>

<p><img src="https://sankalpchauhan.com/static/b4c51a8a6d8ebb0f3f12161c0441e89d/e5715/performance_comparison.png" alt="性能对比" /></p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#the-honest-comparison-default-splash-performance">真实对比：默认闪屏性能</a></h3>

<p>为了进行<strong>同类比较</strong>，我们重点关注在默认的闪屏实现中，阻塞方法只是简单地为了路由目的而扩大 Activity：</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 方法 </th>
<th style="text-align:center;"> 页面加载时间 (毫秒) </th>
<th style="text-align:center;"> FCP (毫秒) </th>
<th style="text-align:center;"> FPT (毫秒) </th>
<th style="text-align:center;"> 用户影响 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> <strong>默认阻塞</strong> </td>
<td style="text-align:center;"> 366 </td>
<td style="text-align:center;"> 744 </td>
<td style="text-align:center;"> 2,195 </td>
<td style="text-align:center;"> 明显的延迟 </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>默认非阻塞</strong> </td>
<td style="text-align:center;"> 37 </td>
<td style="text-align:center;"> 164 </td>
<td style="text-align:center;"> 1,295 </td>
<td style="text-align:center;"> 流畅、响应迅速 </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>提升</strong> </td>
<td style="text-align:center;"> <strong>90%</strong> </td>
<td style="text-align:center;"> <strong>78%</strong> </td>
<td style="text-align:center;"> <strong>41%</strong> </td>
<td style="text-align:center;"> <strong>显著提升</strong> </td>
</tr>
</tbody>
</table>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#the-lottie-animation-advantage">Lottie 动画的优势</a></h3>

<p>当我们引入复杂的 Lottie 动画时，架构上的差异会更加明显发音：</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 方法 </th>
<th style="text-align:center;"> 页面加载时间 (毫秒) </th>
<th style="text-align:center;"> FCP (毫秒) </th>
<th style="text-align:center;"> FPT (毫秒) </th>
<th style="text-align:center;"> 备注 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> <strong>Lottie 阻塞</strong> </td>
<td style="text-align:center;"> 2,228 </td>
<td style="text-align:center;"> 2,347 </td>
<td style="text-align:center;"> 3,524 </td>
<td style="text-align:center;"> <em>包含动画时长</em> </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>Lottie 非阻塞</strong> </td>
<td style="text-align:center;"> 109 </td>
<td style="text-align:center;"> 312 </td>
<td style="text-align:center;"> 1,467 </td>
<td style="text-align:center;"> <em>动画并行运行</em> </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>提升</strong> </td>
<td style="text-align:center;"> <strong>95%</strong> </td>
<td style="text-align:center;"> <strong>87%</strong> </td>
<td style="text-align:center;"> <strong>58%</strong> </td>
<td style="text-align:center;"> <strong>显著提升</strong> </td>
</tr>
</tbody>
</table>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#understanding-the-lottie-numbers">理解 Lottie 数值</a></h3>

<p><strong>重要提示</strong>：Lottie 阻塞数值在设计上包含动画时长，用户必须等待整个动画完成后才能看到任何主要内容。在非阻塞方法中，<strong>动画和内容加载并行运行</strong>，因此当 Lottie 动画完成时，FPT 通常已经完成或接近完成。</p>

<p>这种并行执行是其关键的架构优势：<strong>无需牺牲性能即可获得精美的动画</strong>。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#performance-improvements-breakdown">性能改进细分</a></h3>

<p><img src="https://sankalpchauhan.com/static/620f7ce36b7f1d75840820adb257fa7f/e5715/improvement_chart.png" alt="改进图表" />
改进图表</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#recap-what-happened">回顾：发生了什么</a></h3>

<p>即使与保守的默认启动画面相比，非阻塞方法也实现了<strong>90% 的页面加载速度提升次</strong>。用户体验从“明显的延迟”转变为“流畅且响应迅速”。</p>

<p>对于像 Lottie 这样的复杂动画，其优势更加显著，因为传统方法迫使用户等待整个动画序列，然后才会出现任何有意义的内容。</p>

<p><img src="https://sankalpchauhan.com/6f6ac6fcfed426f343bb76cd31f4694e/comparison.mp4.gif" alt="旧用户体验与新用户体验对比" /></p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#why-the-technical-mechanism">原因：技术机制</a></h3>

<p>性能提升源于<strong>并行执行</strong>。传统方法<strong>顺序</strong>运行启动画面和主内容，而基于视图的方法<strong>并发</strong>运行它们：</p>

<p><strong>传统（顺序）</strong>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nt">Splash</span> <span class="nt">Activity</span> <span class="err">→</span> <span class="nt">Animation</span> <span class="err">→</span> <span class="nt">Destroy</span> <span class="err">→</span> <span class="nt">Main</span> <span class="nt">Activity</span> <span class="err">→</span> <span class="nt">Content</span> <span class="nt">Load</span> <span class="err">→</span> <span class="nt">Display</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>非阻塞（并行）</strong>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='css'><span class='line'><span class="nt">Main</span> <span class="nt">Activity</span> <span class="o">+</span> <span class="nt">Content</span> <span class="nt">Load</span> <span class="o">(</span><span class="nt">background</span><span class="o">)</span>
</span><span class='line'>     <span class="err">↓</span>
</span><span class='line'><span class="nt">Splash</span> <span class="nt">View</span> <span class="o">(</span><span class="nt">overlay</span><span class="o">)</span> <span class="err">→</span> <span class="nt">Remove</span> <span class="nt">overlay</span> <span class="err">→</span> <span class="nt">Display</span> <span class="nt">loaded</span> <span class="nt">content</span>
</span></code></pre></td></tr></table></div></figure>


<p>这种架构差异彻底消除了阻塞瓶颈。</p>

<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#deep-dive-understanding-the-technical-implementation">深入探究：理解技术实现</a></h2>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#traditional-splash-activity-implementation">传统的 Splash Activity 实现</a></h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">class</span> <span class="nc">SplashActivity</span> <span class="p">:</span> <span class="n">ComponentActivity</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="n">Bundle</span><span class="p">?)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">super</span><span class="p">.</span><span class="n">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">)</span>
</span><span class='line'>        <span class="n">installSplashScreen</span><span class="p">()</span>
</span><span class='line'>        <span class="n">enableEdgeToEdge</span><span class="p">()</span>
</span><span class='line'>        <span class="n">setContent</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">Loader</span> <span class="p">{</span> <span class="c1">// Blocks until animation completes</span>
</span><span class='line'>                <span class="n">startActivity</span><span class="p">(</span><span class="n">Intent</span><span class="p">(</span><span class="k">this</span><span class="n">@SplashActivity</span><span class="p">,</span> <span class="n">MainActivity</span><span class="o">::</span><span class="k">class</span><span class="p">.</span><span class="n">java</span><span class="p">))</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">@Composable</span>
</span><span class='line'>    <span class="k">fun</span> <span class="nf">Loader</span><span class="p">(</span><span class="n">onComplete</span><span class="p">:</span> <span class="p">()</span> <span class="p">-&gt;</span> <span class="n">Unit</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">composition</span> <span class="k">by</span> <span class="n">rememberLottieComposition</span><span class="p">(</span><span class="n">LottieCompositionSpec</span><span class="p">.</span><span class="n">RawRes</span><span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">raw</span><span class="p">.</span><span class="n">sale_tags</span><span class="p">))</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">progress</span> <span class="k">by</span> <span class="n">animateLottieCompositionAsState</span><span class="p">(</span><span class="n">composition</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Animation blocks main content loading</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">progress</span> <span class="p">==</span> <span class="m">1.0f</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">onComplete</span><span class="p">.</span><span class="n">invoke</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#event-splash-non-blocking-implementation">EventSplash：非阻塞实现</a></h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">class</span> <span class="nc">EventSplash</span><span class="p">(</span>
</span><span class='line'>    <span class="k">private</span> <span class="k">val</span> <span class="py">activity</span><span class="p">:</span> <span class="n">ComponentActivity</span><span class="p">,</span>
</span><span class='line'>    <span class="k">private</span> <span class="k">val</span> <span class="py">config</span><span class="p">:</span> <span class="n">EventSplashConfig</span><span class="p">,</span>
</span><span class='line'><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">private</span> <span class="k">val</span> <span class="py">decorView</span><span class="p">:</span> <span class="n">ViewGroup</span> <span class="p">=</span> <span class="n">activity</span><span class="p">.</span><span class="n">window</span><span class="p">.</span><span class="n">decorView</span> <span class="k">as</span> <span class="n">ViewGroup</span>
</span><span class='line'>    <span class="k">private</span> <span class="k">var</span> <span class="py">composeView</span><span class="p">:</span> <span class="n">ComposeView</span><span class="p">?</span> <span class="p">=</span> <span class="k">null</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Gate prevents premature display until main content ready</span>
</span><span class='line'>    <span class="k">private</span> <span class="k">val</span> <span class="py">gate</span> <span class="p">=</span> <span class="k">object</span> <span class="err">: </span><span class="nc">ViewTreeObserver</span><span class="p">.</span><span class="n">OnPreDrawListener</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">override</span> <span class="k">fun</span> <span class="nf">onPreDraw</span><span class="p">():</span> <span class="n">Boolean</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="k">if</span> <span class="p">(</span><span class="n">isReady</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">decorView</span><span class="p">.</span><span class="n">viewTreeObserver</span><span class="p">.</span><span class="n">removeOnPreDrawListener</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
</span><span class='line'>                <span class="k">true</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="k">false</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">init</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">decorView</span><span class="p">.</span><span class="n">viewTreeObserver</span><span class="p">.</span><span class="n">addOnPreDrawListener</span><span class="p">(</span><span class="n">gate</span><span class="p">)</span>
</span><span class='line'>        <span class="n">setupSplashCompose</span><span class="p">()</span> <span class="c1">// Non-blocking overlay</span>
</span><span class='line'>        <span class="n">isReady</span> <span class="p">=</span> <span class="k">true</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">private</span> <span class="k">fun</span> <span class="nf">setupSplashCompose</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">view</span> <span class="p">=</span> <span class="n">ComposeView</span><span class="p">(</span><span class="n">activity</span><span class="p">).</span><span class="n">apply</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">layoutParams</span> <span class="p">=</span> <span class="n">ViewGroup</span><span class="p">.</span><span class="n">LayoutParams</span><span class="p">(</span><span class="n">MATCH_PARENT</span><span class="p">,</span> <span class="n">MATCH_PARENT</span><span class="p">)</span>
</span><span class='line'>            <span class="n">setContent</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">getProvider</span><span class="p">(</span><span class="n">config</span><span class="p">).</span><span class="n">Content</span><span class="p">(</span><span class="n">onFinish</span> <span class="p">=</span> <span class="p">{</span> <span class="n">dismiss</span><span class="p">()</span> <span class="p">})</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">composeView</span> <span class="p">=</span> <span class="n">view</span>
</span><span class='line'>        <span class="n">decorView</span><span class="p">.</span><span class="n">addView</span><span class="p">(</span><span class="n">view</span><span class="p">)</span> <span class="c1">// Overlay on main content</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#usage-comparison">使用情况比较</a></h3>

<p><strong>传统方法</strong>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="c1">// Requires separate activity, blocks main content</span>
</span><span class='line'><span class="k">class</span> <span class="nc">MainActivity</span> <span class="p">:</span> <span class="n">ComponentActivity</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Main content only loads after splash completes</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>EventSplash 方法</strong>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">class</span> <span class="nc">MainActivity</span> <span class="p">:</span> <span class="n">ComponentActivity</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="n">Bundle</span><span class="p">?)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">super</span><span class="p">.</span><span class="n">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Non-blocking: splash displays while content loads</span>
</span><span class='line'>        <span class="n">EventSplashApi</span><span class="p">.</span><span class="n">attachTo</span><span class="p">(</span><span class="k">this</span><span class="p">).</span><span class="n">with</span><span class="p">(</span><span class="n">getSaleConfig</span><span class="p">()).</span><span class="n">show</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">setContent</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// Main content loads immediately in parallel</span>
</span><span class='line'>            <span class="n">MainAppContent</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#recap-implementation-differences">回顾：实现差异</a></h3>

<p>传统方法需要单独的 Activity 生命周期，而 EventSplash 会注入一个与主内容加载过程共存的视图叠加层。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#why-architectural-advantages">原因：架构优势</a></h3>

<ol>
<li><strong>单一 Activity 上下文</strong>：消除 Activity 转换开销</li>
<li><strong>并行处理</strong>：主内容在启动画面显示时加载</li>
<li><strong>减少内存占用</strong>：没有重复的 Activity 对象</li>
<li><strong>减少 Choreographer.doFrame 循环</strong>：减少渲染管线压力</li>
<li><strong>优化视图层级</strong>：使用单一装饰视图，而非多个独立的 Activity</li>
</ol>


<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#the-choreographer-do-frame-problem">Choreographer.doFrame 问题</a></h2>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#understanding-frame-rendering-issues">理解帧渲染问题</a></h3>

<p>Android 的渲染系统依赖于 <code>Choreographer.doFrame</code> 来协调动画、输入和绘制 <a href="https://developer.android.com/topic/performance/vitals/render">[4]</a>。文档警告：</p>

<blockquote><p>“如果 Systrace 显示 Choreographer#doFrame 的布局部分工作过多或过于频繁，则意味着你遇到了布局性能问题”</p></blockquote>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#why-splash-activities-cause-jank">为什么闪屏 Activity 会导致卡顿</a></h3>

<p>传统的闪屏实现会造成多个性能瓶颈：</p>

<ol>
<li><strong>双重布局传递</strong>：每个 Activity 都需要单独的视图填充和布局</li>
<li><strong>上下文切换开销</strong>：操作系统必须管理多个 Activity 上下文</li>
<li><strong>内存压力</strong>：重复的视图层次结构会消耗额外的 RAM</li>
<li><strong>帧时序问题</strong>：Activity 转换会触发额外的 doFrame 周期</li>
</ol>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#perfetto-analysis-insights">Perfetto 分析洞察</a></h3>

<p>使用 Perfetto 分析轨迹时，传统的启动画面会显示：</p>

<ul>
<li><code>Choreographer.doFrame</code> 执行时间延长</li>
<li>布局膨胀多次峰值</li>
<li>垃圾回收压力增加</li>
<li>主线程可用性延迟</li>
</ul>


<p>基于视图的方法通过在整个启动过程中维护单一渲染上下文来消除这些问题。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#critical-consideration-concurrent-processing-isnt-free">⚠️ 关键考虑：并发处理并非免费</a></h3>

<p>虽然我们的结果显示性能显著提升，但<strong>非阻塞方法也带来了一系列挑战</strong>，必须仔细考虑。同时运行启动动画和主内容加载会带来额外的资源压力，而顺序加载方法则不会出现这种压力。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#memory-pressure-the-primary-concern">内存压力：主要问题</a></h3>

<p><strong>峰值内存使用量增加</strong>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='nix'><span class='line'><span class="o">//</span> Memory usage pattern comparison
</span><span class='line'>Traditional Approach<span class="p">:</span>
</span><span class='line'>Splash<span class="p">:</span> <span class="mi">50</span>MB <span class="err">→</span> <span class="mi">0</span>MB <span class="err">→</span> Main Content<span class="p">:</span> <span class="mi">120</span><span class="ss">MB =</span> Peak<span class="p">:</span> <span class="mi">120</span>MB
</span><span class='line'>
</span><span class='line'>Non-blocking Approach<span class="p">:</span>
</span><span class='line'>Splash <span class="o">+</span> Main Content<span class="p">:</span> <span class="mi">50</span>MB <span class="o">+</span> <span class="mi">120</span><span class="ss">MB =</span> Peak<span class="p">:</span> <span class="mi">170</span>MB
</span></code></pre></td></tr></table></div></figure>


<p><strong>实际影响</strong>：</p>

<ul>
<li><strong>简单的闪屏叠加</strong>在并发执行期间会增加 20-50MB 的内存</li>
<li><strong>Lottie 动画</strong>在渲染期间可能会消耗 50-100MB 以上的内存</li>
<li><strong>综合峰值使用量</strong>可能比顺序加载方法高出 40-70%</li>
<li><strong>低端设备</strong>（1-2GB RAM）容易受到内存压力的影响</li>
</ul>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#low-memory-killer-risk">低内存杀手风险</a></h3>

<p>Android 的低内存终止守护进程会监控系统内存，并可能在压力下终止应用 <a href="https://source.android.com/docs/core/perf/lmkd">[5]</a>:</p>

<blockquote><p>“内存压力是指系统内存不足的状态，需要 Android 通过限制或终止不重要的进程来释放内存”</p></blockquote>

<p><strong>风险因素</strong>:</p>

<ul>
<li>启动过程中终止应用进程会导致糟糕的用户体验</li>
<li>后台应用被更频繁地终止</li>
<li>并发分配导致的内存碎片</li>
<li>在预算设备上尤其成问题</li>
</ul>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#cpu-and-battery-implications">CPU 和电池影响</a></h3>

<p><strong>CPU 开销增加</strong>：</p>

<ul>
<li><code>Choreographer.doFrame</code> 处理多个并发操作</li>
<li>主线程因 UI 工作重叠而变得更加繁忙</li>
<li>GPU 渲染管线同时处理启动画面和内容</li>
</ul>


<p><strong>功耗问题</strong>：研究表明，“智能手机上的 UI 渲染需要强大的 CPU 和 GPU 才能满足用户感知的流畅度，并且这占了相当一部分的功耗”<a href="https://www.sciencedirect.com/science/article/abs/pii/S1383762122001540">[6]</a>。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#device-compatibility-challenges">设备兼容性挑战</a></h3>

<p><strong>低端设备注意事项</strong>:</p>

<ul>
<li>单核或双核处理器难以并行化</li>
<li>有限的 RAM 使得内存压力至关重要</li>
<li>较慢的存储速度加剧加载延迟</li>
<li>优势可能无法转化为低端设备的优势</li>
</ul>


<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#when-not-to-use-non-blocking-approach">何时不应使用非阻塞方法</a></h2>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#scenarios-where-traditional-approach-may-be-better">传统方法可能更佳的场景：</a></h3>

<ol>
<li><strong>资源极其受限的设备</strong>（&lt; 2GB RAM）</li>
<li><strong>电池关键型应用</strong>，功耗至关重要</li>
<li><strong>简单的启动画面</strong>，没有复杂的动画</li>
<li><strong>启动处理繁重的应用</strong>，已经给应用带来了压力系统</li>
<li><strong>遗留代码库</strong>，重构风险大于收益</li>
</ol>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#risk-mitigation-strategies">风险缓解策略</a></h3>

<p><strong>自适应实施</strong>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">class</span> <span class="nc">AdaptiveSplashStrategy</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">fun</span> <span class="nf">chooseSplashApproach</span><span class="p">():</span> <span class="n">SplashConfig</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">when</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">isLowEndDevice</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">SimpleSplashConfig</span><span class="p">()</span>
</span><span class='line'>            <span class="n">isBatteryLow</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">ReducedAnimationConfig</span><span class="p">()</span>
</span><span class='line'>            <span class="n">isHighPerformanceDevice</span><span class="p">()</span> <span class="p">-&gt;</span> <span class="n">FullLottieConfig</span><span class="p">()</span>
</span><span class='line'>            <span class="k">else</span> <span class="p">-&gt;</span> <span class="n">DefaultConfig</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">private</span> <span class="k">fun</span> <span class="nf">isLowEndDevice</span><span class="p">():</span> <span class="n">Boolean</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">val</span> <span class="py">activityManager</span> <span class="p">=</span> <span class="n">getSystemService</span><span class="p">(</span><span class="n">Context</span><span class="p">.</span><span class="n">ACTIVITY_SERVICE</span><span class="p">)</span> <span class="k">as</span> <span class="n">ActivityManager</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">activityManager</span><span class="p">.</span><span class="n">isLowRamDevice</span> <span class="p">||</span>
</span><span class='line'>               <span class="n">Runtime</span><span class="p">.</span><span class="n">getRuntime</span><span class="p">().</span><span class="n">maxMemory</span><span class="p">()</span> <span class="p">&lt;</span> <span class="m">256</span> <span class="p">*</span> <span class="m">1024</span> <span class="p">*</span> <span class="m">1024</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>内存监控</strong>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">private</span> <span class="k">fun</span> <span class="nf">monitorMemoryPressure</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">memoryInfo</span> <span class="p">=</span> <span class="n">ActivityManager</span><span class="p">.</span><span class="n">MemoryInfo</span><span class="p">()</span>
</span><span class='line'>    <span class="n">activityManager</span><span class="p">.</span><span class="n">getMemoryInfo</span><span class="p">(</span><span class="n">memoryInfo</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">memoryInfo</span><span class="p">.</span><span class="n">lowMemory</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// Fallback to simpler splash</span>
</span><span class='line'>        <span class="n">simplifyOrDismissSplash</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#industry-context-and-validation">行业背景和验证</a></h2>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#alignment-with-industry-best-practices">与行业最佳做法保持一致实践</a></h3>

<p>EventSplash 方法符合最新的行业趋势和官方建议。像 Turo 这样的公司通过消除专用的启动活动也取得了类似的效果。正如他们的案例研究 <a href="https://medium.com/androiddevelopers/turo-reduced-its-app-startup-time-by-77-using-android-developer-tools-and-best-practices-bcf82f596bcf">[7]</a> 中所述：</p>

<blockquote><p>“最初，我们使用专用的 SplashActivity 来运行所有启动工作，然后再将应用路由到 HomeActivity。然而，最新的指南建议不要采用这种方法。因此，我们移除了多余的 SplashActivity，并将所有启动逻辑转移到了根 Activity。”</p></blockquote>

<p>Turo 使用类似的原理实现了<strong>77% 的启动时间缩短</strong>。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#validation-through-official-documentation">通过官方文档验证</a></h3>

<p>Android 官方文档明确建议使用“ViewTreeObserver.OnPreDrawListener”进行启动画面管理，<a href="https://developer.android.com/develop/ui/views/launch/splash-screen">[1]</a>，这进一步验证了该方法，而这正是 EventSplash 的核心实现。</p>

<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#best-practices-and-common-pitfalls">最佳实践和常见陷阱</a></h2>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#dos">建议✅</a></h3>

<ul>
<li>在性能强大的设备上，<strong>使用基于视图的启动画面实现</strong>自定义动画</li>
<li>根据设备性能<strong>实施自适应策略</strong></li>
<li>使用真实设备**测量性能，并跨设备层级发布版本</li>
<li>监控内存使用情况**并实施内存泄漏预防</li>
<li>针对最坏情况进行冷启动优化</li>
<li>在低端设备上进行广泛测试**以确保广泛的兼容性</li>
<li><strong>为启动画面实施适当的生命周期管理</strong></li>
</ul>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#donts">注意事项❌</a></h3>

<ul>
<li><strong>不要想当然地认为一刀切</strong>：设备性能差异巨大</li>
<li><strong>不要忽视内存压力</strong>：监控并适应系统限制</li>
<li><strong>不要在未考虑替代方案的情况下使用单独的 SplashActivity</strong></li>
<li><strong>不要用启动画面动画阻碍主内容加载</strong></li>
<li><strong>不要忽略 Play 管理中心内的 Android Vitals 指标</strong></li>
<li><strong>不要只在高端设备</strong>或调试版本上进行测试</li>
<li><strong>不要在启动画面中创建复杂的视图层次结构</strong></li>
<li><strong>不要在启动画面中执行繁重的操作</strong></li>
<li><strong>不要忘记清理启动画面</strong>并清除缓存</li>
</ul>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#common-pitfalls">常见陷阱</a></h3>

<ol>
<li><strong>内存泄漏</strong>：未能清除 LottieCompositionCache</li>
<li><strong>设备能力假设</strong>：未适应低端设备限制</li>
<li><strong>生命周期问题</strong>：未正确处理 Activity 状态变化</li>
<li><strong>动画冲突</strong>：闪屏动画干扰主内容</li>
<li><strong>测试偏差</strong>：仅在快速设备或调试版本上进行测试</li>
<li><strong>指标误解</strong>：关注动画时长而非用户感知的性能</li>
<li><strong>资源监控疏忽</strong>：未监控内存和 CPU 使用模式</li>
</ol>


<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#making-informed-architectural-decisions">制定明智的架构决策</a></h2>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#decision-framework">决策框架</a></h3>

<p>在选择启动画面方案时，请考虑以下因素：</p>

<p><strong>设备受众特征</strong>：</p>

<ul>
<li>你的用户中有多少比例使用低端设备？</li>
<li>你支持的最低 RAM 配置是多少？</li>
<li>你是否瞄准了拥有廉价设备的新兴市场？</li>
</ul>


<p><strong>应用特性</strong>：</p>

<ul>
<li>你的主要内容加载复杂度如何？</li>
<li>你是否对网络依赖性很强？</li>
<li>你当前的内存占用是多少？</li>
</ul>


<p><strong>业务需求</strong>：</p>

<ul>
<li>自定义启动动画对你的品牌有多重要？</li>
<li>你能实现渐进式增强吗？</li>
<li>你的开发和测试能力如何？</li>
</ul>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#recommended-strategy">推荐策略</a></h3>

<p><strong>渐进式增强方法</strong>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="n">EventSplashApi</span><span class="p">.</span><span class="n">attachTo</span><span class="p">(</span><span class="k">this</span><span class="p">)</span>
</span><span class='line'>    <span class="p">.</span><span class="n">withFallback</span><span class="p">(</span><span class="n">SimpleSplashConfig</span><span class="p">())</span>
</span><span class='line'>    <span class="c1">// Low-end devices</span>
</span><span class='line'>    <span class="p">.</span><span class="n">withStandard</span><span class="p">(</span><span class="n">ImageSplashConfig</span><span class="p">())</span>
</span><span class='line'>    <span class="c1">// Mid-range devices</span>
</span><span class='line'>    <span class="p">.</span><span class="n">withEnhanced</span><span class="p">(</span><span class="n">LottieConfig</span><span class="p">())</span>
</span><span class='line'>    <span class="c1">// High-end devices</span>
</span><span class='line'>    <span class="p">.</span><span class="n">adaptToDevice</span><span class="p">()</span>
</span><span class='line'>    <span class="c1">// Automatic selection</span>
</span><span class='line'>    <span class="p">.</span><span class="n">show</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>此方法提供：</p>

<ul>
<li>适用于所有设备的<strong>基本功能</strong></li>
<li>在资源允许的情况下<strong>增强体验</strong></li>
<li>根据设备性能<strong>自动适配</strong></li>
<li>在内存压力下<strong>优雅降级</strong></li>
</ul>


<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#insights-recommendations">见解与建议</a></h2>

<p>非阻塞启动画面方法<strong>显著提升性能</strong>（保守测试中页面加载速度提升 90%，复杂动画下最高可达 95%），但也存在一些不足。<strong>并发处理会增加峰值内存使用量和 CPU 开销</strong>，这在低端设备上可能会造成问题。</p>

<p><strong>关键见解</strong>：其优势显著且可衡量，但也伴随着资源成本，必须通过自适应的实施策略进行管理。</p>

<p><strong>诚挚建议</strong>：使用非阻塞方法并结合设备感知回退机制。即使是保守估计，也能显​​示出显著的性能提升，其架构优势也令人信服。然而，该实现必须足够复杂，才能支持所有 Android 设备。</p>

<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#conclusion">结论</a></h2>

<p>_本案例研究表明，性能优化需要在保持诚实声明的同时平衡相互竞争的约束条件。非阻塞、基于视图的方法提供了显著且可衡量的优势，但成功实施需要深入了解其收益和成本。</p>

<p>通过摆脱传统的“SplashActivity”模式，采用更复杂、更并发的架构，我们可以构建速度更快、响应更灵敏的 Android 应用，并在整个生态系统中可靠地运行。</p>

<p><strong>我们的目标不仅仅是构建更快的应用，而是构建使用体验即时、愉悦的应用，因为最终，性能是用户能够注意到并欣赏的功能。</strong></p>

<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#references">参考</a></h2>

<ol>
<li><a href="https://developer.android.com/develop/ui/views/launch/splash-screen">闪屏 | 视图 | Android 开发者</a></li>
<li><a href="https://developer.android.com/topic/performance/vitals/launch-time">应用启动时间 | 应用质量 | Android 开发者</a></li>
<li><a href="https://medium.com/androiddevelopers/the-android-lifecycle-cheat-sheet-part-iv-49946659b094">Android 生命周期速查表 — 第四部分：ViewModel、半透明 Activity 和启动模式 | 作者：Jose Alcérreca</a></li>
<li><a href="https://developer.android.com/topic/performance/vitals/render">渲染缓慢 | 应用质量 | Android 开发者</a></li>
<li><a href="https://source.android.com/docs/core/perf/lmkd">低内存终止守护进程 (lmkd) | Android 开源项目</a></li>
<li><a href="https://www.sciencedirect.com/science/article/abs/pii/S1383762122001540">移动 UI 渲染功耗研究</a></li>
<li><a href="https://medium.com/androiddevelopers/turo-reduced-its-app-startup-time-by-77-using-android-developer-tools-and-best-practices-bcf82f596bcf">Turo 利用 Android 开发者工具和最佳实践将其应用启动时间缩短了 77%</a></li>
</ol>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Alex Hilton</span></span>

      




<time class='entry-date' datetime='2025-10-14T22:41:32+08:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2025</span></span> <span class='time'>10:41 pm</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/effectiveandroid/'>effectiveandroid</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
  
    <!-- JiaThis Button BEGIN -->
<div class="jiathis_style_32x32">
	<a class="jiathis_button_qzone"></a>
	<a class="jiathis_button_tsina"></a>
	<a class="jiathis_button_tqq"></a>
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_renren"></a>
	<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2025/10/13/a-flexible-modern-android-app-architecture/" title="Previous Post: 灵活、现代的Android应用架构：完整分步指南">&laquo; 灵活、现代的Android应用架构：完整分步指南</a>
      
      
        <a class="basic-alignment right" href="/blog/2025/10/15/kotlin-mutex/" title="Next Post: Kotlin互斥锁(Mutex)：协程的线程安全守护神">Kotlin互斥锁(Mutex)：协程的线程安全守护神 &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="comments"></div>
    <!-- Duoshuo COMMENT BEGIN -->
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    var clientId = 'bc66a01ef24d14fc282b'
    var clientSecret = 'c7fd5e55db1776204fe201fe20c050b140982884'
    var gitment = new Gitment({
      id: 'toughcoder.net',
      owner: 'alexhilton',
      repo: 'alexhilton.github.io',
      oauth: {
        client_id: clientId,
        client_secret: clientSecret,
      },
    })

    gitment.render('comments')
</script>
<!-- Duoshuo COMMENT END -->

  </section>

</div>

<aside class="sidebar">
  
    <section>
    <div class="
        col-lg-2 col-lg-offset-0
        visible-lg-block
        sidebar-container
        catalog-container">
        <div class="side-catalog">
            <hr class="hidden-sm hidden-xs">
            <h3>
                <a class="catalog-toggle" href="#">CATALOG</a>
            </h3>
            <ul class="catalog-body"></ul>
        </div>
    </div>
</section>
<!-- Back to top and Scroll to bottom -->
<a href="#" class="cd-top"></a>
<a href="#" class="cd-bottom"></a>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2025 - Alex Hilton -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  









<script type="text/javascript">
    //async load function 
    function async(u, c) {
        var d = document, t = 'script',
            o = d.createElement(t),
            s = d.getElementsByTagName(t)[0];
        o.src = u;
        if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
        s.parentNode.insertBefore(o, s);
    }

    function generateCatalog (selector) {
        var P = $('article'),a,n,t,l,i,c, id;
        a = P.find('h2,h3,h4,h5,h6');
        var index = 0;
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            id = $(this).prop('id');
            if (!id) {
                var nid = 'catalog-section-' + index;
                $(this).attr('id', nid);
                i = '#' + nid;
            } else {
                i = '#' + id;
            }
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
            index++;
        });
        return true;
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/javascripts/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });

// Navigation Scripts to Show Header on Scroll-Up
jQuery(document).ready(function($) {
    var MQL = 1170;

    //primary navigation slide-in effect
    if ($(window).width() > MQL) {
        // We do not have the sticky nav bar so, first can be zero
        var headerHeight = 0;
        $('nav').each(function() {
            var h = $(this).outerHeight(true);
            headerHeight += h;
        });
        $('header').each(function() {
            var h = $(this).outerHeight(true);
            headerHeight += h;
        });
        $(window).on('scroll', {
                previousTop: 0
            },
            function() {
                var currentTop = $(window).scrollTop(),
                    $catalog = $('.side-catalog');

                this.previousTop = currentTop;

                //adjust the appearance of side-catalog
                $catalog.show()
                if (currentTop > (headerHeight + 42)) {
                    $catalog.addClass('fixed')
                } else {
                    $catalog.removeClass('fixed')
                }
            });
    }
});
</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3fab3b1bae08e6d4a5e638d9e8c6f40a";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>


</body>
</html>
