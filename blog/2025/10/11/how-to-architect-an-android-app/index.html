
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>如何构建Android应用：深入探讨原则而非规则 - 稀有猿诉</title>
  <meta name="author" content="Alex Hilton">

  
  <meta name="description" content="本文探讨如何构建一个优秀的应用架构，从一般的设计原则，到整洁架构，再到谷歌的现代应用架构，并总结身为开发者该如何选择。">
  <meta name="keywords" content="Android app, Architecture, Clean Architecture">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="https://alexhilton.github.io/blog/2025/10/11/how-to-architect-an-android-app">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="稀有猿诉" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="https://code.jquery.com/jquery-3.6.4.min.js" integrity="sha256-oP6HI9z1XaZNBrJURtCoUT5SUnxFr8s3BzRl+cbzUq8=" crossorigin="anonymous"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/toolbar.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.lug.ustc.edu.cn/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.lug.ustc.edu.cn/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

<!-- for Gitment -->
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">

<!-- for favicon -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">稀有猿诉</a></h1>
  
    <h2>十年磨一剑，历炼出锋芒，说话千百句，不如码二行。</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com.hk/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:alexhilton.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Home</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/donation">Donation</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">如何构建Android应用：深入探讨原则而非规则</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2025-10-11T13:34:02+00:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2025</span></span> <span class='time'>1:34 pm</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><blockquote><p>本文译自「How to architect Android apps: a deep dive into principles, not rules」，原文链接<a href="https://proandroiddev.com/how-to-architect-android-apps-a-deep-dive-into-principles-not-rules-2f1eb7f26402">https://proandroiddev.com/how-to-architect-android-apps-a-deep-dive-into-principles-not-rules-2f1eb7f26402</a>，由Tom Colvin发布于2023年5月25日。</p></blockquote>

<p><a href="/blog/2025/10/11/how-to-architect-an-android-app/"><img src="https://miro.medium.com/v2/resize:fit:2000/0*kT0PbUHF8ld0sU0t" title="auto auto" ></a></p>

<!-- more -->


<p>大多数 Android 开发者都经历过这样的场景……你被要求为应用添加一个简单的功能，但这样做会迫使你修改其他部分，然后又修改其他部分，直到你的修改变得非常繁琐，无法测试。</p>

<p>你可能也开发过这样的应用，用一些不靠谱的方式进行修改比弄清楚如何正确地做某件事要容易得多。或者，应用某个部分的修改会导致数百个完全不相关的 bug 突然出现。</p>

<p>这些都是糟糕架构的标志。</p>

<p>因此，本文基于我的演讲《别跟架构作对》探讨如何构建优秀的应用架构。</p>

<h3>正确的方法</h3>

<p>因为当你构建了优秀的应用架构后，你会发现它安全可靠、可测试且易于维护。你将能够推迟诸如使用哪个后端之类的决策，并在之后相对轻松地撤销这些决策。对我们开发者来说，最重要的是，有一个明确的“正确方法”，可以正确地隔离需要隔离的部分，这意味着即使是最初级的开发者也能在团队中发挥作用。</p>

<p>关于构建软件架构的“正确”方法有很多建议，其中很多都相互矛盾。因此，在本文中，我将为你提供架构背后的“原则”，以便你能够自行决定什么架构适合你自己的应用。所以，本文探讨的是原则，而不是规则。</p>

<blockquote><p>要成为一名优秀的架构师，学习原则，而不是规则。这样，你就可以根据你的软件和团队定制合适的架构。</p></blockquote>

<h2>SOLID 规则</h2>

<p>SOLID 规则是许多架构框架的基础，因此必须完全理解。我不会深入探讨这些规则，因为其他人已经在这方面做得很好。不过，我们先简单回顾一下：</p>

<h3>S = 责任分离</h3>

<p>该原则规定，一个类或模块<em>应该只有一个更改理由</em>。或者说，它应该只对一个<em>参与者</em>负责。这本质上意味着：将那些将单独演进的事物隔离开来。</p>

<h3>O = 开放-封闭</h3>

<p>你的代码应该允许你通过添加代码而不是修改现有代码来添加新功能。</p>

<h3>L = 里氏替换</h3>

<p>以麻省理工学院计算机科学家 Barbara Liskov 的名字命名。该原则规定，你应该能够使用任何派生类来替换基类。最重要的是，在派生基类时，不应尝试更改其含义。</p>

<h3>I = 接口隔离</h3>

<p>不应强迫客户端使用不适合他们的接口。拥有多个包含一两个方法的小型接口，而不是一个大型接口，这并没有什么坏处。</p>

<h3>D = 依赖倒置</h3>

<p>高级类不应依赖于低级类。相反，它们应该都依赖于抽象。</p>

<p>正确应用依赖倒置原则可以正确形成架构边界。让我们更深入地了解其工作原理。</p>

<h2>架构边界和依赖倒置</h2>

<p>假设我们有一个应用允许用户创建和保存个人资料。我们使用 Firebase 来实现这一点。以下是一个简单的实现：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:800/1*qORZctRds2AE60uxiH4w5Q.png" alt="流程图显示 User 类的 saveProfile 方法直接调用 FirebaseProfileSaver 类，这是错误的，因为违反了依赖倒置原则" /></p>

<p>这里，User 类调用了 FirebaseProfileSaver 类中的方法，该方法使用 Firebase 保存个人资料。User 类被称为<em>高级</em>类，因为它包含业务逻辑（即，它是纯逻辑，而不是关于数据如何读写到系统的具体细节）。相比之下，“FirebaseProfileSaver”是一个<em>低级</em>类，之所以这样称呼是因为它包含实现细节，即为特定技术编写的代码。</p>

<p>这种布局违反了依赖倒置原则，因为高级的东西依赖于低级的东西。我所说的依赖，是指严格的源代码含义：在“User”类中，有一行代码写着“import x.y.FirebaseProfileSaver”或类似的代码。也许依赖关系被移除了几层——比如“User”导入了“X”，而“X”又导入了“Y”，而“Y”又导入了“FirebaseProfileSaver”——但关键在于，你可以沿着依赖关系的方向画一组箭头，最终从“User”指向“FirebaseProfileSaver”。</p>

<p>为什么这会是个问题？一个问题是Firebase的变更并不是孤立的。如果Firebase SDK有一天发生了变化，那么显然“FirebaseProfileSaver”也需要随之改变；但没有什么可以阻止这种情况发生，因为它会影响“User”及其依赖的任何内容。测试更改意味着测试所有内容。</p>

<p>而且它也不太灵活。如果我们想从 Firebase 迁移到其他远程存储提供商，我们最终可能不得不重写应用程序的大部分内容。</p>

<h3>依赖倒置：“插头插座”解决方案</h3>

<p>解决方案是将“FirebaseProfileSaver”设置为一种“插头”，将“User”类设置为一种“插座”。“User”类必须对“FirebaseProfileSaver”一无所知；但它可以在抽象中了解保存配置文件的过程。无论我们将什么“插头”插入“User”的“套接字”（可以是“FirebaseProfileSaver”、“RoomDatabaseProfileSaver”或“MyProprietaryAPIProfileSaver”），“套接字”都知道如何与之通信，因为从“套接字”的角度来看，它们的操作方式都相同。</p>

<p>因此，“FirebaseProfileSaver”被重构为适合该套接字的插头。</p>

<p>它看起来像这样：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1000/1*oZXp4UqYwNb2Rhdo2I0_cQ.png" alt="流程图展示了一个 User 类，其中包含一个 saveProfile 方法，它调用了 ProfileSaver 接口上的 saveProfile 方法。另外，FirebaseProfileSaver 类实现了该接口。右图：正确应用了依赖倒置原则" /></p>

<p>这里，<code>User</code> 类只知道如何抽象地与“<code>ProfileSaver</code>”交互。重要的是，它没有提及任何与 Firebase 相关的内容。</p>

<p>然后，<code>FirebaseProfileSaver</code> 实现了 <code>ProfileSaver</code> 接口。<code>User</code> 类对此一无所知，因此，至关重要的是，它的任何逻辑都不基于 Firebase 的工作方式。</p>

<p>这隔离了 Firebase 逻辑。我们可以像上图一样在低级代码和高级代码之间画一条红线。这条红线就是架构边界。</p>

<p>注意依赖关系箭头现在是如何从低级指向高级的。不再存在任何可以遵循的从“User”类开始到 Firebase 结束的依赖箭头序列。</p>

<h2>架构边界应该放在哪里？</h2>

<p>显然，正确设置架构边界对于良好的架构至关重要。从上文来看，边界似乎越多越好——但事实并非如此。</p>

<p>架构边界会带来维护开销。它们会产生更多代码，而且一旦设置了边界，每个未来的开发人员都必须遵守它。</p>

<p>而且，带有边界的代码可读性会大大降低。从上文来看，<code>User</code> 类的 <code>profileSaver.saveProfile()</code> 调用实际上触发了 Firebase 逻辑，这一点并不明显。因此，新开发人员的入职培训会变得更加棘手，代码审查也会更加困难。</p>

<p>整洁架构 (Clean Architecture) 是合理化架构边界的一种尝试。</p>

<h2>Android 应用的整洁架构怎么样？</h2>

<p>整洁架构是由资深架构师 Robert C Martin 整理的一套原则，它在一定程度上提供了一种将软件合理化为一组选定层级的方法，这些层级由架构边界划分。</p>

<p>其著名的图表如下所示：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*iq1PK8t-7rusKw4r" alt="著名的整洁架构图，出自罗伯特·C·马丁的著作《整洁架构》。整洁架构图由一系列同心圆组成。最内圈标记为实体，其次是用例，然后是接口适配器，最外圈是框架和驱动程序" /></p>

<p>这张分层图的中心是高级代码（即纯逻辑），外围是低级代码。它遵循依赖规则（本质上是 SOLID 依赖倒置原则的产物），该规则规定低级代码可以依赖于高级代码，但反过来则不行。因此，上图中表示依赖关系的箭头始终指向内部。</p>

<p>那么，这些层级由什么组成呢？</p>

<h3>用例和实体（黄色和红色圆圈）</h3>

<p>在清晰架构图的正中央，我们可以看到用例层和实体层。它们包含应用的业务逻辑。这些逻辑是控制应用行为的纯逻辑，与具体的实现细节无关。</p>

<p>这种区别可能会造成混淆，因此我们来举个例子。</p>

<p>一个保存用户个人资料的用例会执行以下操作：</p>

<ol>
<li>运行一些安全性/一致性检查。确保正在保存的个人资料包含有效数据，并且用户有权执行此操作。</li>
<li>远程保存数据</li>
<li>在本地缓存新的个人资料</li>
<li>通知 UI 需要更新</li>
</ol>


<p>你可以说这些都是业务逻辑，因为它们与“我们在做什么”有关，而不是“我们如何做”。例如，在步骤 2 中，我们不会说明使用哪个远程 API 来保存数据；在步骤 4 中，我们也不关心要更新的 UI 是 Android 手机屏幕、网页还是 PDF。</p>

<p>一个用例代表来自单个参与者的单一需求（请参阅上文 SOLID 的单一职责原则）。它也是一个完整的步骤列表——你无需执行任何其他操作即可保存配置文件，并且尝试仅运行其中的一部分步骤毫无意义。</p>

<h3>接口适配器（绿色圆圈）</h3>

<p>这是用例细节的体现。例如，当一个用例要求在本地缓存一些数据时，我们可以在这里讨论 SQL 数据库。我们仍然不会讨论特定品牌的 SQL 数据库——任何专有技术都应放在后面讨论。如果有多个数据源，则接口适配器层应该对它们进行整理并管理差异。</p>

<p>几乎所有 MVVM、MVC、MVP 等拓扑结构都应该放在这里。同样，这里不涉及专有技术——所以我们这里不讨论 Jetpack Compose 或 Android XML——但我们确实保存了这些部分将要使用的状态。</p>

<h3>框架和驱动程序（蓝色圆圈）</h3>

<p>所有使用专有技术的内容都放在这里。这些是<em>实现细节</em>。</p>

<p>Jetpack Compose 的 <code>@Composable</code> 代码也放在这里。HTML 代码也放在这里。此外，Firebase 代码、任何 API 的具体细节、SQL 命令以及任何标有 Room 注解（例如 <code>@Entity</code>）的内容也放在这里……</p>

<p>此层的代码很难测试，因为它通常依赖于专有技术。例如，Jetpack Compose 测试依赖于专门为 Jetpack Compose 编写的工具（或者可能是为 Android 编写的工具，但重点依然存在）。因此，请尽可能精简此层。逻辑应该放在更高的层级。这只是将接口适配器的要求“翻译”到你正在使用的特定技术所需的最低限度。</p>

<p>这一层也是<em>易失性的</em>。它可能会在没有你输入的情况下发生变化和中断。例如，如果你正在使用的 API 突然需要不同类型的身份验证，你将不得不修改代码以适应，无论时机是否合适或你是否愿意接受这种变化。同样，尽可能精简这一层可以减少此类更改对代码库其余部分的影响。</p>

<h2>Android 专用代码在 Clean Architecture 中位于何处？</h2>

<p>根据 Clean Architecture 的官方定义，Android 是一项专有技术，因此应将其限制在框架和驱动程序（蓝色）层。任何带有“import android.x.y”或“import androidx.x.y”的代码都不应超出此层。</p>

<p>这在实践中可能非常难以实现。</p>

<p>一个例子是权限请求，有时在视图模型（即接口适配器区域）中提及会更方便（且更具可读性）。</p>

<p>因此，这完美地诠释了为什么我希望本文关注的是“原则”而​​非“规则”。如果你为了遵循某条规则而费尽心思，那么请考虑其背后的原则——它们可能与你的情况相关，也可能不相关。</p>

<p>就此示例而言，我个人认为允许在接口适配器中提及 Android 是可以接受的。毕竟，你正在构建一款 Android 应用，除非你未来有相当大的可能性会与 iOS 或 Web 应用共享完全相同的代码库，否则你没有必要为了避免 Android 而修改代码。显然，iOS 和 Web 应用通常都有各自独立的代码库。</p>

<h2>什么造就了一款优秀的应用？我们如何构建它？</h2>

<p>一款应用应该专注于一件事，并且做好它。它的目的不会随着时间的推移而发生太大变化，尽管它在其生命周期中可能会推出许多新功能，但它的目标受众几乎从未改变（根据单一职责原则，它的角色始终相同）。事实上，如果利益相关者开始要求你的应用迎合其他类型的用户，你通常最好为他们创建一个新的应用，以便更好地满足他们的需求。微软并没有单一的 Office 应用；相反，它有独立的 Word、Excel 和 Powerpoint 应用，每个应用都由不同的用户使用，有着不同的需求。</p>

<p>所以你可能会说，整洁架构（Clean Architecture）——其中许多原则旨在保护你免受 Android 应用中不太可能发生的此类更改的影响——对于我们的目的来说实在太过繁琐。在很多情况下，我同意你的观点。</p>

<p>谷歌似乎也同意这一点。它自己的架构建议——称之为“现代应用架构”（Modern App Architecture）——是整洁架构的一个略微宽松的版本。</p>

<h2>Google 的现代应用架构</h2>

<p>Google 将其架构简化为三层：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:938/1*Y9TFujbKQzLtY1rJynlmSA.png" alt="Google 现代应用架构的拓扑结构：流程图展示了 Google 现代应用架构的三个层级。UI 层指向领域层（标记为可选）。数据层也指向领域层。" /></p>

<p>广义上讲，UI 层用于处理用户的输入和输出，并更新显示内容。领域层用于处理业务逻辑——几乎与 Clean Architecture 的用例完全相同。数据层用于从应用的存储机制读取和写入数据。</p>

<p>这是一种单向架构。状态仅向上流动，事件仅向下流动。</p>

<p>让我们更详细地了解这一切的含义。</p>

<h3>UI 层：UI 元素和状态持有者</h3>

<p><img src="https://miro.medium.com/v2/resize:fit:950/1*81Y6jlUs43MnvwwvBu7zzw.png" alt="现代应用架构的 UI 层：上图中 UI 层的扩展，显示它由 UI 元素和状态持有者组成" /></p>

<p>UI 层分为 UI 元素和状态持有者。</p>

<p>UI 元素部分仅包含为专有技术编写的代码。如果你使用的是 Jetpack Compose，请将你的 @Composable 代码放在此处。如果你使用的是 Fragments 和 XML，那么 @Composable 代码也放在此处。除此之外，没有其他内容。没有逻辑，也没有数据。</p>

<p>（“无逻辑”规则有时对于 XML 数据绑定的用户来说很困难。例如，数据绑定允许你完全在 XML 代码中实现摄氏度/华氏度切换。不要这样做。）</p>

<p>相比之下，逻辑和数据则放在状态持有者中。它们之所以被称为“领域层”，是因为它们保存着 UI 的状态。想想视图控制器。它们包含支持 UI 控件的变量——所以，假设你的 UI 有一个文本字段，那么包含该文本字段内容的变量就放在这里。</p>

<p>一个很好的建议是将这样的状态变量暴露给 Kotlin Flows。这巧妙地封装了它们的动态特性，并提供了一种内置机制来向 UI 发出需要更新的信号。</p>

<h3>领域层：用例</h3>

<p>领域层包含的用例与“清晰架构”中的用例完全相同。也就是说，它是由单个参与者执行单个任务所需步骤的完整列表。</p>

<p>但在 Google 的架构中，这一层是可选的。这意味着将纯业务逻辑放在状态持有者（比如视图模型）中并没有错。</p>

<p>当业务逻辑在多个状态持有者之间重用时，将业务逻辑提取到领域层中可以避免代码重复。比如说，应用程序的多个部分允许更新用户的个人资料；在这种情况下，你可以创建一个 <code>UpdateUserProfileUseCase</code> 并在需要的地方引用它。</p>

<h3>数据层：存储库和数据源</h3>

<p>数据层分为存储库和数据源。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:950/1*gmZwdLcQrrLRkSGnR3PL1w.png" alt="现代应用架构的数据层：现代应用架构图的扩展，显示数据层分为存储库和数据源" /></p>

<p>存储库负责提供数据和保存数据。它包含 <code>getUserProfile()</code> 和 <code>saveUserProfile(…)</code> 方法。</p>

<p>数据源执行专有工作，例如通过调用 API 或编写 SQL 命令。</p>

<p>通常，一个存储库负责多个数据源。例如，你可能将数据存储在远程存储库和相同的本地缓存中。每个存储库都将作为单独的数据源实现。然后，在读取用户个人资料时，存储库可能会尝试从本地缓存读取，如果缓存为空，则回退到远程数据库。这样，负责多个数据源的存储库必须协调使用哪个数据源以及如何同步它们。</p>

<p>再次强调，使用 Kotlin Flows 向调用者提供数据是一种很好的做法。</p>

<h2>比较 Google 的现代应用架构与 Clean Architecture</h2>

<p>你可能已经注意到，现代应用架构和 Clean Architecture 各自使用“层”一词来表示略有不同的含义。以下是它们之间的对应关系：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*9Ds8N-6LZNDNclnZEyX48w.png" alt="现代应用架构如何与 Clean Architecture 相适应：现代应用架构和 Clean Architecture 图表的比较，显示：UI 层与 Clean Architecture 的 UI 和 Presenter 对应（分别位于框架和驱动程序层以及接口适配器层）。领域层与 Clean Architecture 的用例层和实体层对应。数据层与 Clean Architecture 的存储库和 Presenter 对应（分别位于接口适配器层以及框架和驱动程序层）。" /></p>

<p>Google 的 UI 层与其数据层一样，位于 Clean Architecture 的外层两层（接口适配器、框架和驱动程序）。它的领域层完全等同于 Clean Architecture 的用例和实体。</p>

<p>其中一些界限比上图显示的要模糊一些。例如，Google 并不反对你将业务逻辑放置在 UI 层，这就是为什么它自己的领域层被标记为可选的原因。</p>

<p>UI 层和数据层都等同于 Clean Architecture 的接口适配器层和框架/驱动程序层。</p>

<h2>总结……</h2>

<p>本文深入探讨了良好架构背后的原则，并以两种常见范式为灵感：Clean Architecture 和 Google 的现代应用架构。</p>

<p>当然，你需要自行决定哪种架构最适合你的应用程序。我希望通过提供思路而不是僵化的框架，为你提供一个工具包，以便你自行做出决定。</p>

<p>我喜欢回答关于架构的具体问题，所以请随时在这里留下你的答案，我会尽快回复。当没有唯一的“正确”答案，而我们可以进行讨论时，这才是最有趣的。</p>

<p>在以后的文章中，我将使用上述内容逐步指导你使用 Kotlin 和 Compose 创建架构良好的示例应用程序。</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Alex Hilton</span></span>

      




<time class='entry-date' datetime='2025-10-11T13:34:02+00:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2025</span></span> <span class='time'>1:34 pm</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/architecture/'>architecture</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
  
    <!-- JiaThis Button BEGIN -->
<div class="jiathis_style_32x32">
	<a class="jiathis_button_qzone"></a>
	<a class="jiathis_button_tsina"></a>
	<a class="jiathis_button_tqq"></a>
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_renren"></a>
	<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2025/09/24/system-design-for-developers/" title="Previous Post: 面向开发者的系统设计：像建筑师一样思考">&laquo; 面向开发者的系统设计：像建筑师一样思考</a>
      
      
        <a class="basic-alignment right" href="/blog/2025/10/13/a-flexible-modern-android-app-architecture/" title="Next Post: 灵活、现代的Android应用架构：完整分步指南">灵活、现代的Android应用架构：完整分步指南 &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="comments"></div>
    <!-- Duoshuo COMMENT BEGIN -->
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    var clientId = 'bc66a01ef24d14fc282b'
    var clientSecret = 'c7fd5e55db1776204fe201fe20c050b140982884'
    var gitment = new Gitment({
      id: 'toughcoder.net',
      owner: 'alexhilton',
      repo: 'alexhilton.github.io',
      oauth: {
        client_id: clientId,
        client_secret: clientSecret,
      },
    })

    gitment.render('comments')
</script>
<!-- Duoshuo COMMENT END -->

  </section>

</div>

<aside class="sidebar">
  
    <section>
    <div class="
        col-lg-2 col-lg-offset-0
        visible-lg-block
        sidebar-container
        catalog-container">
        <div class="side-catalog">
            <hr class="hidden-sm hidden-xs">
            <h3>
                <a class="catalog-toggle" href="#">CATALOG</a>
            </h3>
            <ul class="catalog-body"></ul>
        </div>
    </div>
</section>
<!-- Back to top and Scroll to bottom -->
<a href="#" class="cd-top"></a>
<a href="#" class="cd-bottom"></a>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2026 - Alex Hilton -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  









<script type="text/javascript">
    //async load function 
    function async(u, c) {
        var d = document, t = 'script',
            o = d.createElement(t),
            s = d.getElementsByTagName(t)[0];
        o.src = u;
        if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
        s.parentNode.insertBefore(o, s);
    }

    function generateCatalog (selector) {
        var P = $('article'),a,n,t,l,i,c, id;
        a = P.find('h2,h3,h4,h5,h6');
        var index = 0;
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            id = $(this).prop('id');
            if (!id) {
                var nid = 'catalog-section-' + index;
                $(this).attr('id', nid);
                i = '#' + nid;
            } else {
                i = '#' + id;
            }
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
            index++;
        });
        return true;
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/javascripts/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });

// Navigation Scripts to Show Header on Scroll-Up
jQuery(document).ready(function($) {
    var MQL = 1170;

    //primary navigation slide-in effect
    if ($(window).width() > MQL) {
        // We do not have the sticky nav bar so, first can be zero
        var headerHeight = 0;
        $('nav').each(function() {
            var h = $(this).outerHeight(true);
            headerHeight += h;
        });
        $('header').each(function() {
            var h = $(this).outerHeight(true);
            headerHeight += h;
        });
        $(window).on('scroll', {
                previousTop: 0
            },
            function() {
                var currentTop = $(window).scrollTop(),
                    $catalog = $('.side-catalog');

                this.previousTop = currentTop;

                //adjust the appearance of side-catalog
                $catalog.show()
                if (currentTop > (headerHeight + 42)) {
                    $catalog.addClass('fixed')
                } else {
                    $catalog.removeClass('fixed')
                }
            });
    }
});
</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3fab3b1bae08e6d4a5e638d9e8c6f40a";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>


</body>
</html>
