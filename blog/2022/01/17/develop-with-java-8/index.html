
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>拥抱新时代的Java - 稀有猿诉</title>
  <meta name="author" content="Alex Hilton">

  
  <meta name="description" content="Java作为面向对象编程的王牌语言，曾经风靡一时，在Web领域是绝对的老大。随着时间的推移，一些新的编程范式不断的涌现，如函数式编程，响应式编程，以及对函数的全力支持（Lambda函数）变成了大家经常谈论的话题。移动互联网的出现，以及前端的流行，让新一代的编程语言如Scala，Groovy， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://toughcoder.net/blog/2022/01/17/develop-with-java-8">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="稀有猿诉" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="http://libs.baidu.com/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/toolbar.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.lug.ustc.edu.cn/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.lug.ustc.edu.cn/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

<!-- for Gitment -->
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">

<!-- for favicon -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">稀有猿诉</a></h1>
  
    <h2>十年磨一剑，历炼出锋芒，说话千百句，不如码二行。</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com.hk/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:toughcoder.net" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Home</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/donation">Donation</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">拥抱新时代的Java</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2022-01-17T22:55:19+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>17</span><span class='date-suffix'>th</span>, <span class='date-year'>2022</span></span> <span class='time'>10:55 pm</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p>Java作为面向对象编程的王牌语言，曾经风靡一时，在Web领域是绝对的老大。随着时间的推移，一些新的编程范式不断的涌现，如函数式编程，响应式编程，以及对函数的全力支持（Lambda函数）变成了大家经常谈论的话题。移动互联网的出现，以及前端的流行，让新一代的编程语言如Scala，Groovy，Swift以及Kotlin都大受欢迎。以函数式编程为核心的新一代编程范式慢慢变成了主流。曾经的王者Java，一度被人垢病，因为对函数支持不友好，（其实最主要的原因是如何保持好向后兼容），但也与时俱进，终于在Java 8版本迈出了重大的一步，完全支持了函数式编程。本篇将重点讨论Java 8的新特性，以及如何用Java 8来实践函数式编程。</p>

<p><a href="/blog/2022/01/17/develop-with-java-8/"><img src="https://cdn.educba.com/academy/wp-content/uploads/2020/01/java-8-features.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>Lambda表达式</h2>

<p>也即匿名函数，称之为lambda。具体数学上的定义比较复杂就不多说了。为了便于理解，我们先从匿名内部类说起。</p>

<p><img src="https://www.callicoder.com/static/a42462af7361c61f46c6ef49f0a5bb26/c1b63/java-lambda-expressions-tutorial.png" alt="" /></p>

<p>Java早就支持匿名内部类，这是在当年相比较C++一个重要大的提升，它在一些需要提供行为实现的地方还是非常方便的，典型的例子就是UI中的点击事件的处理：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">button</span><span class="o">.</span><span class="na">addActionListener</span><span class="o">(</span><span class="k">new</span> <span class="nf">ActionListener</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kt">void</span> <span class="nf">actionPerformed</span><span class="o">(</span><span class="n">ActionEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Button is clicked: &quot;</span> <span class="o">+</span> <span class="n">e</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">});</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里的要点就是我们向button传递的是一个行为，也就是说按扭点击了时，要执行什么样的行为。对比其他现代语言，这还是显得有些笨重，没有简单明了的说明意图。用Java 8，这就好办多了，可以这样写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">button</span><span class="o">.</span><span class="na">addActionListener</span><span class="o">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Button is clicked: &quot;</span> <span class="o">+</span> <span class="n">e</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>括号里面这一坨就是一个Lambda表达式，它是一个行为（严格来说是一个函数），用以直接向目标对象传递一个行为，对比前面的例子，可以发现，这种场景下使用Lambda更加的简洁高效。</p>

<h3>Lambda表达式的语法</h3>

<p>它的通用语法是：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="o">(</span><span class="n">p1</span><span class="o">,</span> <span class="n">p2</span><span class="o">....)</span> <span class="o">-&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">statements</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>括号里面是参数列表，当只有一个参数时，括号可省略，但当参数多于1个时，或者显示声明了参数类型时，括号不能省略，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">names</span><span class="o">.</span><span class="na">sort</span><span class="o">((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">b</span><span class="o">.</span><span class="na">compareTo</span><span class="o">(</span><span class="n">a</span><span class="o">));</span>
</span><span class='line'><span class="n">button</span><span class="o">.</span><span class="na">addActionListener</span><span class="o">((</span><span class="n">ActionEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Button is clicked: &quot;</span> <span class="o">+</span> <span class="n">e</span><span class="o">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>花括号中就是语句块了，这跟常规语句块（如if， while等）是一样的，如果有返回值就return，把它理解为常规方法的实体就可以了，像写常规函数实现那样去写就好了。如果只有一个语句，或者一条表达式，可以省略花括号。</p>

<h3>类型推断</h3>

<p>Lambda表达是匿名函数，主要用以向目标对象传递行为，既然匿名，当然是图简洁和清晰，因此就不要弄的太复杂。所以，参数的类型，以及表达式的返回值（如有）的类型，都是编译器通过上下文来推断出来的，因此，不用给参数写类型，如果因为实现的接口不明确，编译器看不懂的话，会有编译报错的。</p>

<p>关于类型推断可以看《Java 8函数式编程》的第2章第5节有详细的讨论。</p>

<h3>闭包</h3>

<p>也就是closure，严格的数学定义就不说了，有点复杂和难于理解，简单来说就是Lambda表达中使用了一个其定义域外的变量的值（称作捕获外部变量），lambda即变成了一个闭包。还是有点绕，这个其实并不陌生，以前的匿名内部就是可以使用外部变量的，只不过编译器要强加final修饰，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">final</span> <span class="kt">int</span> <span class="n">numberOfStudents</span> <span class="o">=</span> <span class="n">countStudents</span><span class="o">();</span>
</span><span class='line'><span class="n">button</span><span class="o">.</span><span class="na">addActionListener</span><span class="o">(</span><span class="k">new</span> <span class="nf">ActionListener</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">actionPerformed</span><span class="o">(</span><span class="n">ActionEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Number of students is &quot;</span> <span class="o">+</span> <span class="n">numberOfStudents</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里其实就是一个闭包了，匿名内部类中捕获了外部的变量numberOfStudents，只不过要强加final修饰，这是因为这里要传值。</p>

<p>Java 8里面呢，外部变量不必用final修饰了，但是，它也必须实际上是final的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">numberOfStudents</span> <span class="o">=</span> <span class="n">countStudents</span><span class="o">();</span>
</span><span class='line'><span class="n">button</span><span class="o">.</span><span class="na">addActionListener</span><span class="o">(</span><span class="n">e</span> <span class="o">-&gt;</span> <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Number of students is &quot;</span> <span class="o">+</span> <span class="n">numberOfStudents</span><span class="o">));</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为，之前啊，假如捕获了一个外部变量，不是final的，会有编译错误，但如果你用IDE的建议时，它就直接再声明一个final变量，用原变量赋值，然后把新的final变量传给匿名内部类，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kt">int</span> <span class="n">numberOfStudents</span> <span class="o">=</span> <span class="n">countStudents</span><span class="o">();</span>
</span><span class='line'><span class="kd">final</span> <span class="kt">int</span> <span class="n">finalNumberOfStudents</span> <span class="o">=</span> <span class="n">numberOfStudents</span><span class="o">;</span>
</span><span class='line'><span class="n">button</span><span class="o">.</span><span class="na">addActionListener</span><span class="o">(</span><span class="k">new</span> <span class="nf">ActionListener</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">actionPerformed</span><span class="o">(</span><span class="n">ActionEvent</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Number of students is &quot;</span> <span class="o">+</span> <span class="n">finalNumberOfStudents</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>到此就明白了，Java 8对于闭包的支持，其实较之前没有实质的变化，只不过编译器帮你做了这个final变量的定义而已。</p>

<p>这部分可以参考《Java 8函数式编程》中第2章第3节的内容。</p>

<h2>接口方法默认实现</h2>

<p>Java 8中，可以给接口interface，添加一个方法的默认实现，这样在实现此接口时，子类可以选择重新实现，或者不实现，直接调用此方法即可，从语法上来说，是比较简单的，用default关键字来修饰方法即可，如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">interface</span> <span class="nc">Formula</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">double</span> <span class="nf">calculate</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">default</span> <span class="kt">double</span> <span class="nf">sqrt</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">class</span> <span class="nc">ComplexFormula</span> <span class="kd">implements</span> <span class="n">Formula</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">double</span> <span class="nf">calculate</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>         <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">real</span><span class="o">)</span> <span class="o">+</span> <span class="kd">super</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">imaginary</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里面，子类ComplexFormula是可以正常编译和运行的。</p>

<p><strong>注意</strong>：接口是支持多重继承的，比如一个类可以实现多个接口，这就有可能存在接口中有相同的默认方法，最好的处理方法就是子类重新实现一下此方法，然后可以用接口的名字+super来具体指定父类中的方法。这一具体的规则比较复杂，可以看《Java 8函数式编程》这本书中的第4章第7节，有比较详细的论述。</p>

<p>另外，需要注意，实际运用中，接口的默认方法并不常用，因为这本身就是比较奇怪的，与最初Java的设计有冲突，接口策重于行为的高级抽象，而抽象类侧重对象的高级抽象（多半涉及状态属性）。这东西的出现主要是为了解决向后兼容，比如说当你一个被广泛使用的接口添加了一个新的方法时，所有实现此接口的类必须全部要改一遍，要实现此接口，这会影响大量的现存代码，而默认方法就是为了解决这个问题的，给新添加的方法标记为default，就不会影响现存代码了。</p>

<h2>函数接口</h2>

<p>支持函数式编程范式的语言一般来说呢，会把函数作为语义上的一级类型，比如像Python或者Kotlin都有专门用于声明函数的关键字。另外，需要澄清一下函数的概念，简单来说函数就是给定一些输入，然后给出输出，输出随输入改变而改变，<strong>不会产生副作用，也就是不会修改全局变量，修改环境变量</strong>。且<strong>具有幂等性，即针对 同一组输入，多次调用，结果仍是一样的</strong>，这就是函数。</p>

<p>对于Java，这事儿就有点难办了，因为前面的版本根本就没有把方法独立成为函数，方法必须存在于类中。为了支持函数，函数是函数式编程的基本要素，所以要想支持函数式编程，必须以某种方式来支持函数的定义。Java 8中就提出了函数接口的概念。</p>

<p><strong>函数接口是只有一个抽象方法的接口</strong>，这里有两个关键信息，首先，<strong>语义上的类型必须是一个interface</strong>，其次，<strong>它只能有一个抽象方法</strong>，放在以前的版本，其实意思就是说只有能一个方法，但还要注意的是前面提到的默认方法。那么这里的要求就是<strong>除了默认方法以外，只能有一个方法</strong>。</p>

<p>函数接口必须用<em>@FunctionalInterface</em>注解来标注，编译器会对它做特别的关注，一旦有超过1个抽象接口，就会编译报错。为啥要用注解而不是增加关键字（如function），或者创建一级类型（如function interface），目的仍是向后兼容。注解仅需要在编译阶段做一些额外的事情即可，这即实现了扩展，又保持了兼容性。</p>

<p>前面提到的Lambda表达式必须是一个函数接口的实例，这样说太抽象了，慢慢来解释下。Lambda是一个匿名函数，可以把它理解为一个对象，它所实现的必须是一个函数接口。换句话说，只有声明为函数接口的地方，也就是方法的参数类型或者变量的类型要声明为函数接口，只有这里才可以传入lambda表达式。</p>

<p>接着前面的Formula例子，假如有如下应用场景：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">class</span> <span class="nc">Number</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">payload</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Number</span> <span class="nf">transform</span><span class="o">(</span><span class="n">Formula</span> <span class="n">formula</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>         <span class="k">return</span> <span class="n">formula</span><span class="o">.</span><span class="na">calculate</span><span class="o">(</span><span class="n">payload</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在调用transform方法时如果直接传递lambda，是会报错的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">number</span><span class="o">.</span><span class="na">transform</span><span class="o">(</span><span class="n">a</span> <span class="o">-&gt;</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span><span class="o">);</span> <span class="c1">// won&#39;t compile</span>
</span></code></pre></td></tr></table></div></figure>


<p>解决方法，就是要给Formula添加函数接口注解：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@FunctionalInterface</span>
</span><span class='line'><span class="kd">interface</span> <span class="nc">Formula</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">double</span> <span class="nf">calculate</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">default</span> <span class="kt">double</span> <span class="nf">sqrt</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>关于函数接口，可以参阅《Java 8函数式编程》中第2章第4节和第4章第4节。</p>

<h3>常用的函数接口</h3>

<p>Java 8 定义了一些非常常胜的函数接口，这里做一下简单的介绍。</p>

<h4>Predict<T></h4>

<p>断言，给定一个类型为T的输入，给出boolean的输出（true of false）。通常用于过滤操作之中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Predict</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">isEmpty</span> <span class="o">=</span> <span class="nl">String:</span><span class="o">:</span><span class="n">isEmpty</span><span class="o">;</span>
</span><span class='line'><span class="n">students</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>    <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">name</span> <span class="o">-&gt;</span> <span class="o">!</span><span class="n">name</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">());</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Function&lt;T, R></h4>

<p>通用的函数操作，给定类型为T的输入，返回类型为R的输出，通常用于map之中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Function</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">length</span> <span class="o">=</span> <span class="n">name</span> <span class="o">-&gt;</span> <span class="n">name</span><span class="o">.</span><span class="na">length</span><span class="o">();</span>
</span></code></pre></td></tr></table></div></figure>


<p>其实，Predict可视为一种特殊的Function，它的返回类型是boolean。</p>

<h4>Consumer<T></h4>

<p>消费类型为T的对象，无输出，作为调用链的终点，通常用于生成终值，如前面例子中传给button的lambda就一个Consumer。</p>

<h4>Supplier<T></h4>

<p>返回一个类型为T的对象，也即生产者，通常都是用于工厂方法，用来生成新的对象。</p>

<h4>UnaryOperator<T></h4>

<p>一元操作符，输入类型是T的对象，返回类型是T的对象：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">UnaryOperator</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">square</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<h4>BinaryOperator<T></h4>

<p>二元操作符，输入参数是类型同为T的a和b两个参数，输出是一个类型为T的结果：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">BinaryOperator</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">join</span> <span class="o">=</span> <span class="o">(</span><span class="n">first</span><span class="o">,</span> <span class="n">second</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">first</span> <span class="o">+</span> <span class="s">&quot;, &quot;</span> <span class="o">+</span> <span class="n">second</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里例子不是很多，因为单独写这些函数接口的lambda不太好写，且意义不够实用，会在后面结合Stream API，给出更多示例。</p>

<h2>Stream API</h2>

<p><img src="https://miro.medium.com/max/1400/0*QCmZZpGs_rcF5y2-.png" alt="" /></p>

<h2>优质书籍</h2>

<p>编程范式的学习曲线都是非常陡峭的，函数式编程注重的是行为的抽象，以行为（函数）为第一要素来构建解决方案，这需要思维的转变。并不是说你用了一个lambda就是函数式编程了。因此需要系统化的学习。而系统化的学习，最好的方式就是去啃书（没说看，是要啃书）。</p>

<p>下面列出关于函数式编程，特别是用Java 8进行实践函数式编程的几本非优质的书籍：</p>

<h3><a href="https://www.oreilly.com/library/view/functional-thinking/9781449365509/">Functional Thinking</a></h3>

<p>中译名是《函数式编程思维》，是由Neal Ford出品的佳作，专门讲述如何Thinking in Functional Programming。这本书也不是很厚，非常值得看。因为是重点讲解函数式编程思维 的，所以它用了Java/Scala和Groovy，并且Java的版本还不是Java 8的。</p>

<p>这里也要说一下，编程范式跟语言是否直接支持没有关系，它更是一种思维抽象方法，比如用C也能写出完全符合面向对象的代码；用Java 7以前的版本也能写出函数式程序。</p>

<h3><a href="https://www.amazon.com/Java-Lambdas-Functional-Programming-Masses/dp/1449370772">Java 8 Lambdas: Functional Programming For The Masses</a></h3>

<p>中译名是《Java 8函数式编程》，由Richard Warburton写的。里面有丰富的实例和练习题，也不厚，专注于讲解如何用Java 8来实践函数式编程。</p>

<h3><a href="https://www.manning.com/books/java-8-in-action">Java 8 in Action</a></h3>

<p>中译名《Java 8实战》，由三位作者Raoul-Gabriel Urma, Mario Fusco, and Alan Mycroft合著。内容其实与前面那个差不多，但略有不同，这本书是重点讲解Java 8的新特性的，当然大量篇幅也是讲用Java 8实践函数式编程的（因为Java 8最重要的改进就是对函数式编程的支持），但还有其他的内容。并且这本书较厚，里面各种知识点讲解比较详细。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://stackify.com/streams-guide-java-8/">A Guide to Java Streams in Java 8: In-Depth Tutorial With Examples</a></li>
<li><a href="https://www.exception.site/java8/java8-new-features">Java8 新特性教程</a></li>
<li><a href="https://juejin.cn/post/6844903830254010381">[译] 一文带你玩转 Java8 Stream 流，从此操作集合 So Easy</a></li>
<li><a href="https://segmentfault.com/a/1190000022791696">Java8 Stream完全使用指南</a></li>
<li><a href="https://www.baeldung.com/java-8-streams">The Java 8 Stream API Tutorial</a></li>
</ul>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Alex Hilton</span></span>

      




<time class='entry-date' datetime='2022-01-17T22:55:19+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>17</span><span class='date-suffix'>th</span>, <span class='date-year'>2022</span></span> <span class='time'>10:55 pm</span></time>
      


    </p>
    
      <div class="sharing">
  
  
  
  
    <!-- JiaThis Button BEGIN -->
<div class="jiathis_style_32x32">
	<a class="jiathis_button_qzone"></a>
	<a class="jiathis_button_tsina"></a>
	<a class="jiathis_button_tqq"></a>
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_renren"></a>
	<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2022/01/14/android-cpu-optimization-made-easy/" title="Previous Post: 玩转安卓运行速度优化">&laquo; 玩转安卓运行速度优化</a>
      
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="comments"></div>
    <!-- Duoshuo COMMENT BEGIN -->
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    var clientId = 'bc66a01ef24d14fc282b'
    var clientSecret = 'c7fd5e55db1776204fe201fe20c050b140982884'
    var gitment = new Gitment({
      id: 'toughcoder.net',
      owner: 'alexhilton',
      repo: 'alexhilton.github.io',
      oauth: {
        client_id: clientId,
        client_secret: clientSecret,
      },
    })

    gitment.render('comments')
</script>
<!-- Duoshuo COMMENT END -->

  </section>

</div>

<aside class="sidebar">
  
    <section>
    <div class="
        col-lg-2 col-lg-offset-0
        visible-lg-block
        sidebar-container
        catalog-container">
        <div class="side-catalog">
            <hr class="hidden-sm hidden-xs">
            <h3>
                <a class="catalog-toggle" href="#">CATALOG</a>
            </h3>
            <ul class="catalog-body"></ul>
        </div>
    </div>
</section>
<!-- Back to top and Scroll to bottom -->
<a href="#" class="cd-top"></a>
<a href="#" class="cd-bottom"></a>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2022 - Alex Hilton -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  









<script type="text/javascript">
    //async load function 
    function async(u, c) {
        var d = document, t = 'script',
            o = d.createElement(t),
            s = d.getElementsByTagName(t)[0];
        o.src = u;
        if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
        s.parentNode.insertBefore(o, s);
    }

    function generateCatalog (selector) {
        var P = $('article'),a,n,t,l,i,c, id;
        a = P.find('h2,h3,h4,h5,h6');
        var index = 0;
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            id = $(this).prop('id');
            if (!id) {
                var nid = 'catalog-section-' + index;
                $(this).attr('id', nid);
                i = '#' + nid;
            } else {
                i = '#' + id;
            }
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
            index++;
        });
        return true;
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/javascripts/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });

// Navigation Scripts to Show Header on Scroll-Up
jQuery(document).ready(function($) {
    var MQL = 1170;

    //primary navigation slide-in effect
    if ($(window).width() > MQL) {
        // We do not have the sticky nav bar so, first can be zero
        var headerHeight = 0;
        $('nav').each(function() {
            var h = $(this).outerHeight(true);
            headerHeight += h;
        });
        $('header').each(function() {
            var h = $(this).outerHeight(true);
            headerHeight += h;
        });
        $(window).on('scroll', {
                previousTop: 0
            },
            function() {
                var currentTop = $(window).scrollTop(),
                    $catalog = $('.side-catalog');

                this.previousTop = currentTop;

                //adjust the appearance of side-catalog
                $catalog.show()
                if (currentTop > (headerHeight + 42)) {
                    $catalog.addClass('fixed')
                } else {
                    $catalog.removeClass('fixed')
                }
            });
    }
});
</script>

<script>
    var _hmt = _hmt || [];
    (function() {
         var hm = document.createElement("script");
         hm.src = "//hm.baidu.com/hm.js?3b8ca71d801a2f5af0a456e0b4635bae";
         var s = document.getElementsByTagName("script")[0];
         s.parentNode.insertBefore(hm, s);
    })();
</script>


</body>
</html>
