
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>务实的模块化：连接模块(wiring Modules)的妙用 - 稀有猿诉</title>
  <meta name="author" content="Alex Hilton">

  
  <meta name="description" content="本文将讨论为什么在模块中`:app` 直接依赖其他模块会减慢增量构建速度，以及如何用连接模块(wiring modules)解决这个问题。">
  <meta name="keywords" content="Modularization, Modules, Wiring">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="https://alexhilton.github.io/blog/2026/01/03/pragmatic-modularization">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="稀有猿诉" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="https://code.jquery.com/jquery-3.6.4.min.js" integrity="sha256-oP6HI9z1XaZNBrJURtCoUT5SUnxFr8s3BzRl+cbzUq8=" crossorigin="anonymous"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <script src="/javascripts/toolbar.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.lug.ustc.edu.cn/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.lug.ustc.edu.cn/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

<!-- for Gitment -->
<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">

<!-- for favicon -->
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">稀有猿诉</a></h1>
  
    <h2>十年磨一剑，历炼出锋芒，说话千百句，不如码二行。</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com.hk/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:alexhilton.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Home</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/donation">Donation</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">务实的模块化：连接模块(wiring Modules)的妙用</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2026-01-03'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2026</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><blockquote><p>本文译自「Pragmatic Modularization: The Case for Wiring Modules」，原文链接<a href="https://proandroiddev.com/pragmatic-modularization-the-case-for-wiring-modules-c936d3af3611">https://proandroiddev.com/pragmatic-modularization-the-case-for-wiring-modules-c936d3af3611</a>，由Alex Krafts发布于2025年11月22日。</p></blockquote>

<p><a href="/blog/2026/01/03/pragmatic-modularization/"><img src="https://miro.medium.com/v2/resize:fit:1400/0*9waVavO74e0cqQg6" title="auto auto" ></a></p>

<!-- more -->


<p>如果你正在经历漫长的模块化之旅，你应该已经阅读过官方的<a href="https://developer.android.com/topic/modularization">Google 开发者指南</a>。你可能已经见过关于提供依赖项的这种具体建议：</p>

<blockquote><p>“……app 模块通常是添加依赖项的好地方。要提供实现，请将其指定为所选构建变体或测试源集的依赖项。”</p></blockquote>

<p>下图展示了这种模式的一个常见示例，其中 <code>:app</code> 模块使用 <code>:database:impl:room</code> 作为其 <code>main</code> 源集，并使用 <code>:database:impl:mock</code> 作为 <code>androidTest</code> 源集。这是一种强大且正确的测试依赖项管理方法。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1304/0*Q3MP_6C6i4qhNhQr.png" alt="图 1. App 模块提供实际实现。" /></p>

<p>但这种模式存在一个<strong>微妙之处</strong>。当这种逻辑应用于大型项目中所有功能实现时，可能会<strong>无意中造成构建速度瓶颈</strong>，尤其是在处理遗留应用模块时。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="c1">// :app/build.gradle.kts</span>
</span><span class='line'><span class="n">dependencies</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">implementation</span><span class="p">(</span><span class="n">project</span><span class="p">(</span><span class="s">&quot;:database:api&quot;</span><span class="p">))</span>
</span><span class='line'>    <span class="n">implementation</span><span class="p">(</span><span class="n">project</span><span class="p">(</span><span class="s">&quot;:database:impl:room&quot;</span><span class="p">))</span> <span class="c1">// &lt;--- This is the trap for incremental builds</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>代码是模块化的，但你的 <code>:app</code> 模块现在与 <code>:database:impl:room</code> 模块<strong>构建耦合</strong>。这意味着任何<strong>资源更改</strong>（例如添加字符串）或对<strong>实现自身的公共接口</strong>的任何更改（例如在 <code>:impl</code> 内部添加一个不属于官方 <code>:api</code> 模块的新的 <code>public</code> 辅助类）都会破坏编译避免机制，并强制整个 <code>:app</code> 模块重新编译，从而抵消模块化带来的主要速度优势。</p>

<blockquote><p>即使启用了非传递 R 类等优化，直接依赖关系通常也会强制构建系统验证使用者是否与生产者的新资源符号匹配。布线模块充当防火墙，防止频繁的资源检查影响到庞大的 App 模块。</p></blockquote>

<h2>“精简应用”的理想状态与“臃肿应用”的现实</h2>

<p>官方建议让 <code>:app</code> 模块提供实现，这非常有效，尤其是在 Google 指南中展示的场景下：为不同的构建版本（例如 <code>main</code> 和 <code>androidTest</code>）替换依赖项。</p>

<p>但是，如果将此模式误用作所有功能实现的<em>通用规则</em>，尤其是在包含<strong>“臃肿应用”模块</strong>的项目中，就会出现一个微妙的陷阱。</p>

<p>官方指南通常会隐含地假设一种架构理想：<strong>“精简应用”模块</strong>。“精简应用”只是一个轻量级的汇编器。它几乎不包含任何代码或资源。它<em>唯一</em>的任务是应用 <code>com.android.application</code> 插件并将所有功能模块打包成一个 APK 文件。如果你的 <code>:app</code> 模块很精简，重新编译它既快速又便宜，因此它依赖于 <code>:impl</code> 模块并无大碍。</p>

<p>但对我们大多数人来说，现实情况是<strong>“厚应用”模块</strong>。它是最初的单体应用，仍然充斥着遗留代码、资源和半模块化的功能。</p>

<p>当你的“厚应用”模块直接依赖于某个功能的 <code>:impl</code> 时，例如 <code>:app</code> -> &ldquo;:database:impl:room&rdquo;<code>，你就创建了一个会拖慢构建速度的瓶颈。你最大、最复杂的模块现在与该功能的内部细节**构建耦合**了。任何对</code>:impl<code>中资源或实现自身公共接口的更改都会破坏编译规避机制，并强制整个</code>:app` 模块重新编译。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1304/1*su8uLnwQsJMVWsUxrlVBSg.png" alt="图 2. “厚应用”瓶颈。由于庞大的 :app 模块直接依赖于实现，因此底层任何 ABI 更改都会触发顶层的完全重新编译。红色箭头展示了功能模块中的一个微小改动如何迫使资源密集型的 `:app` 模块重新构建，从而破坏了避免编译的策略。" /></p>

<p>“现在，一个纯粹主义者可能会说：‘你应该更加自律，永远不要让你的 <code>:app</code> 模块从 <code>:impl</code> 导入任何东西，即使是公共的。’</p>

<p>他们的说法没错。但是，在一个拥有数十位贡献者的‘厚应用’单体应用中，‘自律’是一种脆弱的防御手段。而连接模块模式<strong>在构建系统层面强制执行了这种自律。</strong>它使得开发者<em>不可能</em>意外地将 <code>:app</code> 模块与某个功能的实现细节耦合在一起，从而默认地保证了构建速度。”</p>

<h2>“理想”方案 vs. “赋能”方案</h2>

<p>这让团队面临两条道路：</p>

<ol>
<li>“理想”（但缓慢）方案：纯粹主义者的解决方案是将“臃肿的应用”模块重构为真正“精简”的模块……这才是正确的长期目标，但这需要数年时间，循序渐进。</li>
<li>“赋能”（但快速）方案：这是“连接模块”模式。这种模式并非理想方案的替代方案，而是实现理想方案的催化剂。它提供了团队所需的构建速度和稳定性，使团队有时间和信心真正执行长期的增量重构。</li>
</ol>


<p>虽然这会增加“模块蔓延”，但它以架构的纯粹性换取了工程速度。在大型团队中，速度通常是更关键的指标。</p>

<p>但这种观点将问题简单地二元化了。实际上，这种模式是一种<strong>务实的权衡</strong>。你是在<strong>有意识地做出权衡</strong>。你接受了新的、可控的成本（增加模块数量和配置），以解决一个令人头疼的日常问题（缓慢的增量构建）。这种新的、明确的“连接”债务通常远比“臃肿应用”的单体架构债务成本低得多，后者正在扼杀团队的开发速度。这种构建速度往往正是团队能够拥有时间和稳定性来进行更大规模、更长期的重构的关键所在。</p>

<p>像 Slack、Spotify 和 Uber 这样的大型 Android 代码库都公开讨论过一些模式，这些模式大量依赖于将实现细节隐藏在稳定的 API 之后。这并非权宜之计；这是大型团队保持构建速度快和代码库可维护性的根本方法。</p>

<h2>解决方案：“连接模块”模式</h2>

<blockquote><p>这种模式有时被称为聚合模块，但我们更倾向于使用“连接”，因为它更能体现其在连接架构中的积极作用。</p></blockquote>

<p>此解决方案引入了一个新的轻量级<strong>“连接模块”</strong>（例如，<code>:database:wiring</code>）。该模块充当“守门人”或该功能的稳定外观。</p>

<p>其原理很简单：</p>

<ol>
<li><code>:app</code> 模块<em>仅</em>依赖于新的、稳定的 <code>:database:wiring</code> 模块。</li>
<li>连接模块<em>是唯一</em>了解其自身内部 <code>:impl</code>（以及 <code>:ui</code>、<code>:domain</code> 等）模块的模块。</li>
</ol>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="c1">// :app/build.gradle.kts (Corrected)</span>
</span><span class='line'><span class="n">dependencies</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// ...</span>
</span><span class='line'>    <span class="n">implementation</span><span class="p">(</span><span class="n">project</span><span class="p">(</span><span class="s">&quot;:database:wiring&quot;</span><span class="p">))</span> <span class="c1">// NOW it&#39;s decoupled!</span>
</span><span class='line'>    <span class="n">implementation</span><span class="p">(</span><span class="n">project</span><span class="p">(</span><span class="s">&quot;:feature:home&quot;</span><span class="p">))</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="c1">// :database:wiring/build.gradle.kts (The new &quot;Wiring Module&quot;)</span>
</span><span class='line'><span class="n">plugins</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">id</span><span class="p">(</span><span class="s">&quot;com.android.library&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">android</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">namespace</span> <span class="p">=</span> <span class="s">&quot;com.example.database.wiring&quot;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">dependencies</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1">// Link the bindings internally without exposing the API transitively</span>
</span><span class='line'>    <span class="n">implementation</span><span class="p">(</span><span class="n">project</span><span class="p">(</span><span class="s">&quot;:database:api&quot;</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// Hide the implementation details from the :app module</span>
</span><span class='line'>    <span class="n">implementation</span><span class="p">(</span><span class="n">project</span><span class="p">(</span><span class="s">&quot;:database:impl:room&quot;</span><span class="p">))</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这种模式并非免费。这是一个务实的步骤，它能实现你承诺的快速增量构建，赋予你的团队速度和稳定性，从而支持那些规模更大、周期更长的重构。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1304/1*H2gD-qUVVI2r7CsTtMSt6Q.png" alt="图 3. 使用 :impl:room 模块 ABI 更改后的增量构建仅触发轻量级 :wiring 模块重建" /></p>

<p>现在，<code>:app</code> 模块仅依赖于稳定的 wiring 模块。</p>

<p><strong>关于依赖注入的说明：</strong></p>

<p>这个“wiring 模块”不仅仅是一个提升构建速度的技巧；它是你功能<strong>依赖注入绑定</strong>（例如 Dagger 或 Hilt 的 <code>@Module</code>）的理想存放位置。它的唯一职责就是将抽象的 <code>:api</code> 连接到具体的 <code>:impl</code>，这正是清晰依赖注入 (DI) 的精髓所在。</p>

<p>这种模式能够确保良好的架构，而构建速度的提升则是这种清晰分离带来的一个绝佳附加效果。</p>

<h2>为什么速度如此之快：理解编译避免</h2>

<p>这种结构并非权宜之计；它是启用 Gradle 最强大的构建速度提升功能——<strong>编译避免</strong>——的<em>正确</em>方法。</p>

<p>Gradle 团队在其精彩博文“<a href="https://blog.gradle.org/our-approach-to-faster-compilation">我们实现更快编译的方法</a>”中对此进行了解释。以下是关键要点：</p>

<ol>
<li><strong>Gradle 检查的是 ABI，而不是实现：</strong> 正如博文所述，Gradle 检查的是依赖项的<strong>应用程序二进制接口 (ABI)</strong>。ABI 是模块的“公共契约”或“公共结构”——即其公共类和方法签名。它<strong>不</strong>包含方法体等私有实现细节。</li>
<li><strong>旧方法会破坏这一点：</strong> 当你的 <code>:app</code> 模块直接依赖于 <code>:database:impl:room</code> 时，你实际上是在强制 Gradle 将整个实现都视为应用构建的一部分。正如我们之前提到的，<code>:database:impl:room</code> 中任何<strong>资源更改</strong>或对实现本身的<strong>公共接口</strong>（例如新增的 <code>public</code> 辅助函数）的更改，对于 <code>:app</code> 来说都是 ABI 不兼容的更改，从而导致需要完全重新编译。</li>
<li><p><strong>新方法可以解决这个问题：</strong> 使用我们的 <code>:database:wiring</code> 模块后：</p></li>
<li><p>开发人员更改了 <code>:database:impl:room</code> 中的一个文件。</p></li>
<li><code>:database:wiring</code> 模块重新编译（由于它很小，所以速度很快）。</li>
<li><strong>至关重要的是</strong>，正如 Gradle 博客文章中所解释的，这是一个 <strong>ABI 兼容的更改</strong>。连接模块的<em>公共结构</em>（即其 <code>api</code> 依赖项）并未改变。</li>
<li>Gradle 会检查 <code>:app</code>，发现其依赖项的 ABI 完全相同，因此<strong>完全跳过重新编译</strong> <code>:app</code>。</li>
</ol>


<p>这篇博文将此称为<strong>编译避免(Compilation Avoidance)</strong>（完全跳过模块的编译），并将其与<em>增量编译</em>（重新编译模块中的<em>某些</em>文件）区分开来。这种模式是实现主应用程序模块真正避免编译的最有效方法之一。</p>

<h2>实际应用：效果如何</h2>

<p>这并非纸上谈兵。我们在生产应用中使用 Gradle Profiler 来测试这种模式旨在解决的具体场景：在某个功能的 <code>:impl</code> 模块中进行破坏 ABI 的更改（例如，添加一个新的公共方法），然后运行增量 <code>:app:assembleDebug</code> 构建。</p>

<p>我们对八个不同的功能模块重复了此操作，并在引入连接模块前后分别对每个功能模块进行了平均 10 次运行。在旧配置中，<code>:app</code> 直接依赖于 <code>:feature:impl</code>，这些增量构建平均耗时约 <strong>99 秒</strong>。引入连接模块后，<code>:app</code> 仅依赖于 <code>:feature:wiring</code>，相同场景下的平均耗时降至约 <strong>63 秒</strong>。</p>

<p>在这八个功能模块中，速度提升幅度约为 <strong>29%</strong> 到 <strong>45%</strong>，在这种特定的增量构建场景下，平均提升幅度约为 <strong>36%</strong>。</p>

<p>在进行此次重构时，我恰好在研究是否值得将我的 MacBook 升级到更新的 Apple Silicon 机型。这个对比让我恍然大悟：对于这种工作负载，此次连接模块的更改所带来的构建速度提升，与升级到性能更强劲的高端 MacBook 机型**的效果不相上下。区别在于，这种重构能够有效地让参与项目的每个开发者都感受到“新机器”般的体验——而这仅仅是通过一个小的、有针对性的 Gradle 修改实现的，而非硬件升级。</p>

<h2>要点</h2>

<p>官方文档的建议在理论上是正确的，但理解实践中的权衡取舍至关重要。</p>

<p>对于任何实际的<strong>“厚应用”模块</strong>而言，直接依赖 <code>:impl</code> 模块通常会导致构建速度瓶颈，因为它将最大的模块与某个功能的内部变更耦合在一起。</p>

<p>保护构建速度至关重要。“模块连接”模式是一种非常实用且低成本的重构方式，它能显著提升日常工作流程的构建速度，而成本通常仅为完整 <code>:app</code> 模块重构的一小部分。</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Alex Hilton</span></span>

      




<time class='entry-date' datetime='2026-01-03'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>3</span><span class='date-suffix'>rd</span>, <span class='date-year'>2026</span></span> <span class='time'>12:00 am</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/effectiveandroid/'>effectiveandroid</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
  
    <!-- JiaThis Button BEGIN -->
<div class="jiathis_style_32x32">
	<a class="jiathis_button_qzone"></a>
	<a class="jiathis_button_tsina"></a>
	<a class="jiathis_button_tqq"></a>
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_renren"></a>
	<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script>
<!-- JiaThis Button END -->

  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2025/12/31/inside-jetpack-viewmodel/" title="Previous Post: Jetpack ViewModel内幕：内部机制与跨平台设计">&laquo; Jetpack ViewModel内幕：内部机制与跨平台设计</a>
      
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="comments"></div>
    <!-- Duoshuo COMMENT BEGIN -->
<script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script>
<script>
    var clientId = 'bc66a01ef24d14fc282b'
    var clientSecret = 'c7fd5e55db1776204fe201fe20c050b140982884'
    var gitment = new Gitment({
      id: 'toughcoder.net',
      owner: 'alexhilton',
      repo: 'alexhilton.github.io',
      oauth: {
        client_id: clientId,
        client_secret: clientSecret,
      },
    })

    gitment.render('comments')
</script>
<!-- Duoshuo COMMENT END -->

  </section>

</div>

<aside class="sidebar">
  
    <section>
    <div class="
        col-lg-2 col-lg-offset-0
        visible-lg-block
        sidebar-container
        catalog-container">
        <div class="side-catalog">
            <hr class="hidden-sm hidden-xs">
            <h3>
                <a class="catalog-toggle" href="#">CATALOG</a>
            </h3>
            <ul class="catalog-body"></ul>
        </div>
    </div>
</section>
<!-- Back to top and Scroll to bottom -->
<a href="#" class="cd-top"></a>
<a href="#" class="cd-bottom"></a>

  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2026 - Alex Hilton -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  









<script type="text/javascript">
    //async load function 
    function async(u, c) {
        var d = document, t = 'script',
            o = d.createElement(t),
            s = d.getElementsByTagName(t)[0];
        o.src = u;
        if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
        s.parentNode.insertBefore(o, s);
    }

    function generateCatalog (selector) {
        var P = $('article'),a,n,t,l,i,c, id;
        a = P.find('h2,h3,h4,h5,h6');
        var index = 0;
        a.each(function () {
            n = $(this).prop('tagName').toLowerCase();
            id = $(this).prop('id');
            if (!id) {
                var nid = 'catalog-section-' + index;
                $(this).attr('id', nid);
                i = '#' + nid;
            } else {
                i = '#' + id;
            }
            t = $(this).text();
            c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>');
            l = $('<li class="'+n+'_nav"></li>').append(c);
            $(selector).append(l);
            index++;
        });
        return true;
    }

    generateCatalog(".catalog-body");

    // toggle side catalog
    $(".catalog-toggle").click((function(e){
        e.preventDefault();
        $('.side-catalog').toggleClass("fold")
    }))

    /*
     * Doc: https://github.com/davist11/jQuery-One-Page-Nav
     * Fork by Hux to support padding
     */
    async("/javascripts/jquery.nav.js", function () {
        $('.catalog-body').onePageNav({
            currentClass: "active",
            changeHash: !1,
            easing: "swing",
            filter: "",
            scrollSpeed: 700,
            scrollOffset: 0,
            scrollThreshold: .2,
            begin: null,
            end: null,
            scrollChange: null,
            padding: 80
        });
    });

// Navigation Scripts to Show Header on Scroll-Up
jQuery(document).ready(function($) {
    var MQL = 1170;

    //primary navigation slide-in effect
    if ($(window).width() > MQL) {
        // We do not have the sticky nav bar so, first can be zero
        var headerHeight = 0;
        $('nav').each(function() {
            var h = $(this).outerHeight(true);
            headerHeight += h;
        });
        $('header').each(function() {
            var h = $(this).outerHeight(true);
            headerHeight += h;
        });
        $(window).on('scroll', {
                previousTop: 0
            },
            function() {
                var currentTop = $(window).scrollTop(),
                    $catalog = $('.side-catalog');

                this.previousTop = currentTop;

                //adjust the appearance of side-catalog
                $catalog.show()
                if (currentTop > (headerHeight + 42)) {
                    $catalog.addClass('fixed')
                } else {
                    $catalog.removeClass('fixed')
                }
            });
    }
});
</script>

<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?3fab3b1bae08e6d4a5e638d9e8c6f40a";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>


</body>
</html>
