<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Compose | ç¨€æœ‰çŒ¿è¯‰]]></title>
  <link href="https://alexhilton.github.io/blog/categories/compose/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2025-12-05T12:02:15+00:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Jetpack Composeä¸­çš„é˜´å½±è‰ºæœ¯]]></title>
    <link href="https://alexhilton.github.io/blog/2025/11/24/the-art-of-shadows-in-jetpack-compose/"/>
    <updated>2025-11-24T00:00:00+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/11/24/the-art-of-shadows-in-jetpack-compose</id>
    <content type="html"><![CDATA[<blockquote><p>æœ¬æ–‡è¯‘è‡ªã€ŒThe Art of Shadows in Jetpack Composeã€ï¼ŒåŸæ–‡é“¾æ¥<a href="https://medium.com/proandroiddev/the-art-of-shadows-in-jetpack-compose-63a75070882f">https://medium.com/proandroiddev/the-art-of-shadows-in-jetpack-compose-63a75070882f</a>ï¼Œç”±Stefano Nataliå‘å¸ƒäº2025å¹´10æœˆ4æ—¥ã€‚</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/1*UjyqMyVg002OIDJ1Hdee8Q.png" title="auto auto" ></a></p>

<!-- more -->


<p>UI ä¸­çš„é˜´å½±å‘æŒ¥ç€è‡³å…³é‡è¦çš„ä½œç”¨ï¼šå®ƒä»¬åœ¨è§†è§‰ä¸Š<strong>æå‡</strong>å…ƒç´ ï¼ŒæŒ‡ç¤ºç€<strong>äº¤äº’æ€§</strong>ï¼Œå¹¶æä¾›ç”¨æˆ·æ“ä½œçš„å³æ—¶<strong>åé¦ˆ</strong>ã€‚å¤šå¹´æ¥ï¼Œæˆ‘ä»¬ä¸€ç›´ä¾èµ–äº<strong>é«˜åº¦</strong>å±æ€§ï¼Œä½† Jetpack Compose ç°åœ¨æä¾›äº†ä¸€å¥—å¼ºå¤§çš„å·¥å…·ï¼Œå¯ä»¥å¯¹<strong>é˜´å½±æ¸²æŸ“</strong>è¿›è¡Œç²¾ç»†æ§åˆ¶ã€‚</p>

<p>Google æœ€è¿‘æ–°å¢äº†ä¸€ä¸ª<a href="https://developer.android.com/develop/ui/compose/graphics/draw/shadows">æ–‡æ¡£é¡µé¢</a>ï¼Œå…¶ä¸­åŒ…å«ä¸€ç³»åˆ—æœ‰è¶£çš„ç”¨ä¾‹ã€‚æœ¬æ–‡å°†æ¢ç´¢ Compose ä¸­çš„ä¸»è¦é˜´å½±ä¿®æ”¹å™¨ï¼Œå¹¶æ·±å…¥è®²è§£åˆ›å»ºæ¸å˜å’Œç‚«é…·ç‰¹æ•ˆç­‰é«˜çº§æŠ€å·§ï¼Œä»è€Œæå‡åº”ç”¨çš„é£æ ¼ã€‚</p>

<p>æœ¬æ–‡è®¨è®ºçš„æ‰€æœ‰æŠ€å·§çš„å®Œæ•´ä»£ç ç¤ºä¾‹éƒ½å¯ä»¥åœ¨æˆ‘çš„ GitHub ä»“åº“ <a href="https://github.com/stefanoq21/ComposePlayground"><strong>Compose Playground</strong></a> ä¸­æ‰¾åˆ°ã€‚</p>

<h2>é˜´å½±ä¿®æ”¹å™¨ï¼ˆShadow Modifiersï¼‰</h2>

<p>æ·»åŠ é˜´å½±æœ€ç®€å•ä½†è‡ªå®šä¹‰ç¨‹åº¦æœ€ä½çš„æ–¹æ³•æ˜¯ä½¿ç”¨ <strong>Modifier.shadow()</strong>ã€‚ä¸ä»¥å¾€ä¸€æ ·ï¼Œå®ƒçš„è¡Œä¸ºä¾èµ–äº<strong>åŸºäºé«˜åº¦çš„é˜´å½±</strong>ï¼Œæ¨¡æ‹Ÿæ¥è‡ªä¸Šæ–¹çš„å…‰æºï¼Œé˜´å½±æ·±åº¦ç›´æ¥å–å†³äºä½ æä¾›çš„é«˜åº¦å€¼ã€‚å…¶ä¸»è¦é™åˆ¶åœ¨äºé˜´å½±å§‹ç»ˆè¢«è£å‰ªåˆ°å¯åˆæˆå¯¹è±¡çš„å½¢çŠ¶å†…ï¼Œå¹¶ä¸”ä½ æ— æ³•è‡ªå®šä¹‰æ‰©å±•ã€é¢œè‰²è‰²è°ƒæˆ–åç§»ç­‰å±æ€§ã€‚</p>

<pre><code class="kotlin">Box(
    Modifier
        .size(100.dp)
        .shadow(
            elevation = 10.dp, 
            shape = RectangleShape
        )
        .background(Color.White)
)
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:704/1*7Nkm6z8Ls4FyvDqCcKToDw.png" alt="" /></p>

<p>è®©æˆ‘ä»¬ä»ä¸€äº›æ–°åŠŸèƒ½å¼€å§‹ï¼Œè¿™äº›åŠŸèƒ½èµ‹äºˆæˆ‘ä»¬æ›´å¼ºå¤§çš„åŠ›é‡ã€‚ä½¿ç”¨ <strong>dropShadow()</strong>ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å†…å®¹åé¢åˆ›å»ºè‡ªå®šä¹‰é˜´å½±ã€‚è¿™ä¸ªä¿®é¥°ç¬¦æ˜¯åˆ›å»ºå¤æ‚é˜´å½±çš„å…³é”®ï¼Œå®ƒå…è®¸å¯¹å†…å®¹åé¢çš„é˜´å½±è¿›è¡Œç²¾ç»†æ§åˆ¶ï¼Œä½¿å…ƒç´ çœ‹èµ·æ¥åƒæ˜¯è¢«æŠ¬å‡äº†ä¸€æ ·ã€‚</p>

<pre><code class="kotlin"> .dropShadow(
    shape = RoundedCornerShape(20.dp), shadow = Shadow(
            radius = 6.dp,
            spread = 2.dp,
            color = Color.Black.copy(alpha = 0.3f),
            offset = DpOffset(2.dp, 2.dp)
              )
            )
 .background(
    color = Color.White, shape = RoundedCornerShape(20.dp)
            )
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:990/1*kENF6x3L985dO65DSY0Zng.png" alt="" /></p>

<p>å®ƒä½¿ç”¨ <strong>Shadow</strong> å‚æ•°ï¼Œå¯ä»¥ç²¾ç¡®æ§åˆ¶è§†è§‰æ•ˆæœã€‚è¿™ä¸ªå‚æ•°å…è®¸ä½ ä½¿ç”¨å‡ ä¸ªå…³é”®å±æ€§æ¥å¡‘é€ é˜´å½±ã€‚ <strong>åŠå¾„</strong> å†³å®šäº†è¾¹ç¼˜çš„æŸ”å’Œåº¦å’Œæ‰©æ•£ï¼ˆæ¨¡ç³Šï¼‰ç¨‹åº¦ã€‚<strong>æ‰©æ•£</strong> å€¼æ§åˆ¶é˜´å½±å‡ ä½•å½¢çŠ¶ç›¸å¯¹äºå¯ç»„åˆå…ƒç´ å¤§å°çš„æ‰©å±•æˆ–æ”¶ç¼©ã€‚æœ€åï¼Œ<strong>åç§»</strong> æ²¿ <strong>X è½´å’Œ Y è½´</strong>å®šä½é˜´å½±ï¼Œä»è€Œç¡®å®šå…‰æºçš„è§†è§‰æ–¹å‘ã€‚ç»“åˆé˜´å½±çš„<strong>é¢œè‰²</strong>ï¼Œè¿™äº›å±æ€§å¯ä»¥å®ç°å®Œå…¨è‡ªå®šä¹‰ã€‚</p>

<p>ğŸ’¡ <strong>é¡ºåºå¾ˆé‡è¦ï¼š</strong>åœ¨ä¿®æ”¹å™¨é“¾ä¸­ï¼Œ<strong>dropShadow()</strong> ä¿®æ”¹å™¨å¿…é¡»å‡ºç°åœ¨ <strong>background()</strong> ä¿®æ”¹å™¨<strong>ä¹‹å‰</strong>ï¼Œå› ä¸ºé˜´å½±å…ˆç»˜åˆ¶ï¼ŒèƒŒæ™¯ç»˜åˆ¶åœ¨å…¶ä¸Šæ–¹ã€‚</p>

<p><strong>innerShadow()</strong> ä¿®æ”¹å™¨æ˜¯ <strong>dropShadow()</strong> çš„é€†æ“ä½œï¼Œå®ƒåœ¨å¯ç»„åˆå…ƒç´ è¾¹ç•Œçš„<strong>å†…éƒ¨</strong>åˆ›å»ºé˜´å½±ï¼Œä»è€Œå®ç°å…ƒç´ å‡¹é™·æˆ–å‹å…¥è¡¨é¢çš„è§†è§‰æ•ˆæœã€‚ä¸å®ƒçš„å¯¹åº”é¡¹ä¸€æ ·ï¼Œå®ƒä¹Ÿä½¿ç”¨å¯è‡ªå®šä¹‰çš„<strong>Shadow</strong>å¯¹è±¡ï¼Œå…è®¸ä½ ä½¿ç”¨<strong>åŠå¾„</strong>ã€<strong>é¢œè‰²</strong>ã€<strong>åç§»</strong>å’Œ<strong>æ‰©æ•£</strong>æ¥å¾®è°ƒæ•ˆæœã€‚</p>

<pre><code class="kotlin">.background(
    Color.White, shape = RoundedCornerShape(20.dp)
)
.innerShadow(
    shape = RoundedCornerShape(20.dp), shadow = Shadow(
        radius = 6.dp,
        spread = 2.dp,
        color = Color.Black.copy(alpha = 0.3f),
        offset = DpOffset(2.dp, 2.dp)
    )
)
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1108/1*a7KFFaTXCk4KC-sm9AYUoQ.png" alt="" /></p>

<p>ğŸ’¡<strong>å†æ¬¡å¼ºè°ƒï¼Œé¡ºåºå¾ˆé‡è¦ï¼š</strong><strong>innerShadow()</strong>ä¿®æ”¹å™¨<strong>å¿…é¡»</strong>æ”¾åœ¨<strong>background()</strong>ä¿®æ”¹å™¨<strong>ä¹‹å</strong>ã€‚å¦‚æœå°†å…¶æ”¾åœ¨èƒŒæ™¯ä¹‹å‰ï¼Œå†…å®¹å°†ç»˜åˆ¶åœ¨é˜´å½±ä¹‹ä¸Šï¼Œå®Œå…¨é®ç›–é˜´å½±ã€‚</p>

<p>è¿™äº›ä¿®æ”¹å™¨çš„çœŸæ­£å¼ºå¤§ä¹‹å¤„åœ¨äºå®ƒä»¬çš„è‡ªå®šä¹‰å’Œç»„åˆã€‚é€šè¿‡å åŠ <strong>innerShadow()</strong>å’Œ<strong>dropShadow()</strong>ï¼Œä½ å¯ä»¥åˆ›å»ºå¤æ‚è€Œé€¼çœŸçš„è§†è§‰æ•ˆæœã€‚æˆ‘ä»¬æ¥çœ‹ä¸€äº›é«˜çº§ç”¨ä¾‹ã€‚</p>

<h2>é«˜çº§æŠ€å·§ï¼šç»„åˆå’Œè‡ªå®šä¹‰é˜´å½±</h2>

<h3>è‡ªå®šä¹‰é˜´å½±</h3>

<p>å½“ä½ åœ¨ <strong>dropShadow()</strong> å‡½æ•°ä¸­å°† <strong>Brush</strong> å¯¹è±¡è€Œéçº¯è‰²ä¼ é€’ç»™ <strong>Shadow</strong> å¯¹è±¡æ—¶ï¼Œè‡ªå®šä¹‰çš„å¼ºå¤§åŠŸèƒ½ä¾¿æ˜¾è€Œæ˜“è§ã€‚æ­¤åŠŸèƒ½å…è®¸ä½ ä½¿ç”¨ <strong>Brush.sweepGradient</strong> åˆ›å»ºæ¸å˜æ•ˆæœã€‚æ­¤å¤–ï¼Œæ— è®ºä½ ä½¿ç”¨æ ‡å‡†å½¢çŠ¶è¿˜æ˜¯å®Œå…¨è‡ªå®šä¹‰çš„å‡ ä½•ä½“ï¼Œé˜´å½±å§‹ç»ˆä¼šè´´åˆå¯ç»„åˆå¯¹è±¡çš„å½¢çŠ¶ã€‚</p>

<pre><code class="kotlin">.dropShadow(
    shape = MaterialShapes.Cookie12Sided.toShape(), shadow = Shadow(
        radius = 10.dp,
        spread = 6.dp,
        brush = Brush.sweepGradient(
            listOf(Color.Green, Color.Blue, Color.Yellow, Color.Green)
        ),
        offset = DpOffset(2.dp, 2.dp)
    )
)
.background(
    color = Color.White,
    shape = MaterialShapes.Cookie12Sided.toShape(),
)
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1122/1*a8xMvXOb3hS6icdGU0p1gg.png" alt="" /></p>

<h3>æ–°ç²—çŠ·ä¸»ä¹‰é˜´å½±</h3>

<p>è¿™ç§é£æ ¼å®Œç¾åœ°å±•ç°äº† <strong>dropShadow()</strong> ä¿®æ”¹å™¨åœ¨å®ç°æè‡´é«˜å¯¹æ¯”åº¦æ•ˆæœæ–¹é¢çš„å¼ºå¤§åŠŸèƒ½ã€‚è¦å®ç°æ–°ç²—çŠ·ä¸»ä¹‰ï¼ˆNeobrutalismï¼‰é‚£ç§ç²—çŠ·ã€æ£±è§’åˆ†æ˜çš„è§†è§‰æ•ˆæœï¼Œä½ å¿…é¡»ä½¿ç”¨ <code>dropShadow()</code> å‡½æ•°ï¼Œå¹¶è®¾ç½®æ¨¡ç³Šåº¦ä¸ºé›¶ï¼Œåç§»é‡è¦æ˜æ˜¾ï¼Œé€šå¸¸è¿˜è¦é…åˆç²—è¾¹æ¡†ã€‚å…·ä½“æ¥è¯´ï¼Œä½ éœ€è¦åŒæ—¶è®¾ç½® <code>radius = 0.dp</code> å’Œ <code>spread = 0.dp</code> æ¥æ¶ˆé™¤æ‰©æ•£ï¼Œç„¶ååº”ç”¨é²œè‰³çš„è‰²å½©ï¼Œå¹¶è®¾ç½®ä¸€ä¸ªæ˜æ˜¾çš„åç§»é‡ï¼Œä»è€Œåˆ›å»ºå‡ºæ ‡å¿—æ€§çš„é”åˆ©è½®å»“ã€‚</p>

<pre><code class="kotlin"> .dropShadow(
     shape = RoundedCornerShape(0.dp),
     shadow = Shadow(
        radius = 0.dp,
        spread = 0.dp,
        color = dropShadowColor,
        offset = DpOffset(x = 8.dp, 8.dp)
                    )
        )
 .border(
    8.dp, borderColor
        )
 .background(
    color = Color.White,
    shape = RoundedCornerShape(0.dp)
        )
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*bdPpm0XYPfTXMuoNrVQuZw.png" alt="" /></p>

<h3>å…·æœ‰åŠ¨æ•ˆçš„é˜´å½±</h3>

<p>é˜´å½±å¹¶éåªæ˜¯é™æ€çš„ï¼›å®ƒä»¬å¯ä»¥åˆ¶ä½œæˆåŠ¨ç”»ï¼Œä»è€Œæä¾›å³æ—¶çš„ç”¨æˆ·åé¦ˆã€‚æˆ‘ä»¬å°†è¦æ¢ç´¢çš„æœ€åä¸€ä¸ªé«˜çº§æŠ€å·§æ˜¯åˆ›å»ºäº¤äº’å¼é˜´å½±ï¼Œä½¿å…¶åœ¨ç‰¹å®šæ“ä½œï¼ˆä¾‹å¦‚ç‚¹å‡»æˆ–æŒ‰ä¸‹ï¼‰æ—¶å¹³æ»‘è¿‡æ¸¡ã€‚è¿™é¡¹æŠ€æœ¯å¯¹äºæ¨¡æ‹Ÿç‰©ç†äº¤äº’è‡³å…³é‡è¦ï¼Œå®ƒèƒ½ç›´è§‚åœ°ç¡®è®¤å…ƒç´ çš„æŠ¬å‡æˆ–çŠ¶æ€å‘ç”Ÿäº†å˜åŒ–ã€‚</p>

<pre><code class="kotlin"> Box(Modifier.fillMaxSize()) {
        val interactionSource = remember { MutableInteractionSource() }
        val isPressed by interactionSource.collectIsPressedAsState()

        // Create transition with pressed state
        val transition = updateTransition(
            targetState = isPressed, label = "button_press_transition"
        )

        fun &lt;T&gt; buttonPressAnimation() = tween&lt;T&gt;(
            durationMillis = 400, easing = Ease
        )

        // Animate all properties using the transition
        val shadowAlpha by transition.animateFloat(
            label = "shadow_alpha", transitionSpec = { buttonPressAnimation() }) { pressed -&gt;
            if (pressed) 0f else 1f
        }

        //to animate the color
        val colorDropShadow by transition.animateColor(
            label = "shadow_color", transitionSpec = { buttonPressAnimation() }) { pressed -&gt;
            if (pressed) Color.Transparent else Color.Green.copy(alpha = (0.5f))
        }
        val innerShadowAlpha by transition.animateFloat(
            label = "inner_shadow_alpha", transitionSpec = { buttonPressAnimation() }) { pressed -&gt;
            if (!pressed) 0f else 1f
        }

        Box(
            Modifier
                .clickable(
                    interactionSource, indication = null
                ) {
                    //...
                }
                .width(300.dp)
                .height(200.dp)
                .align(Alignment.Center)
                .dropShadow(
                    shape = RoundedCornerShape(70.dp), shadow = Shadow(
                        radius = 10.dp,
                        spread = 0.dp,
                        color = Color.Green.copy(alpha = (0.5f)),
                        offset = DpOffset(x = 0.dp, 0.dp),
                        alpha = shadowAlpha
                    )
                )
                // note that the background needs to be defined before defining the inner shadow
                .background(
                    color = Color(0xFFFFFFFF), shape = RoundedCornerShape(70.dp)
                )
                .innerShadow(
                    shape = RoundedCornerShape(70.dp), shadow = Shadow(
                        radius = 8.dp,
                        spread = 4.dp,
                        color = Color.Green.copy(alpha = (0.5f)),
                        alpha = innerShadowAlpha,
                        offset = DpOffset(x = 0.dp, 0.dp)
                    )
                )
        ) {
            //...
        }
    }
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*idzAQ4lII7JweFZdCyfNqg.gif" alt="" /></p>

<p>å¥½çš„ï¼Œæˆ‘ä»¬å·²ç»äº†è§£äº†å¦‚ä½•ä½¿ç”¨ <strong>updateTransition</strong> API æ¥åˆ›å»ºæµç•…çš„äº¤äº’åé¦ˆã€‚å®ƒé¦–å…ˆä½¿ç”¨ <strong>MutableInteractionSource</strong> è·Ÿè¸ªæŒ‰ä¸‹çŠ¶æ€ã€‚è¯¥çŠ¶æ€ä¼šé©±åŠ¨ä¸€ä¸ª <strong>400 æ¯«ç§’çš„è¿‡æ¸¡åŠ¨ç”»</strong>ï¼ŒåŒæ—¶ä¸ºä¸¤ä¸ªæ–¹å‘ç›¸åçš„é˜´å½±æ·»åŠ åŠ¨ç”»æ•ˆæœã€‚å¤–éƒ¨çš„ <strong>dropShadow</strong> åœ¨æŒ‰ä¸‹æ—¶ä¼šæ·¡å‡ºï¼Œè€Œå†…éƒ¨çš„ <strong>innerShadow</strong> åˆ™ä¼šæ·¡å…¥ã€‚è¿™ç§åŒé˜´å½±åŠ¨ç”»ä½¿ç»„ä»¶ä» <strong>æŠ¬å‡</strong> çŠ¶æ€å¹³æ»‘è¿‡æ¸¡åˆ° <strong>å‡¹é™·</strong> çŠ¶æ€ï¼Œä»è€Œåœ¨ç”¨æˆ·äº¤äº’æ—¶æä¾›æ¸…æ™°ä¸”åŠ¨æ€çš„åé¦ˆã€‚</p>

<h2>ç»“è®º</h2>

<p>Compose å…¨æ–°çš„é˜´å½± API æ ‡å¿—ç€å¯¹ä¼ ç»Ÿ <strong>elevation</strong> å±æ€§å±€é™æ€§çš„é‡å¤§çªç ´ã€‚å®ƒå°†æ ¸å¿ƒæ¦‚å¿µæ‹†åˆ†ä¸º <strong>dropShadow()</strong> å’Œ <strong>innerShadow()</strong>ï¼Œå¹¶èµ‹äºˆæˆ‘ä»¬å¯¹ <strong>Shadow</strong> å¯¹è±¡å±æ€§çš„å®Œå…¨æ§åˆ¶æƒã€‚</p>

<p>æ— è®ºä½ æ˜¯æ‰“é€ ç®€å•çš„æ¸å˜æ•ˆæœã€æ¨¡æ‹Ÿç‰©ç†æ·±åº¦ï¼Œè¿˜æ˜¯å®ç°æ–°ç²—é‡ä¸»ä¹‰çš„é«˜å¯¹æ¯”åº¦è§†è§‰å†²å‡»ï¼Œè¿™ç§å…¨æ–°çš„è‡ªå®šä¹‰ç¨‹åº¦éƒ½æ„å‘³ç€ä½ çš„ <strong>UI ç»ˆäºå¯ä»¥å……åˆ†å±•ç°ä½ è®¾è®¡çš„è‰ºæœ¯æ„¿æ™¯</strong>ã€‚</p>

<p>ä¸å¦¨å°è¯•è¿™äº›ä¿®é¥°ç¬¦ï¼Œä¸ºä½ çš„ Jetpack Compose åº”ç”¨æ³¨å…¥å…¨æ–°çš„åˆ›æ„ç»´åº¦ï¼</p>

<p>å¦‚æœä½ è§‰å¾—è¿™ç¯‡æ–‡ç« æœ‰è¶£ï¼Œæ¬¢è¿å…³æ³¨æˆ‘ï¼Œè·å–æ›´å¤šå…³äº Android å¼€å‘å’Œ Jetpack Compose çš„ç²¾å½©å†…å®¹ã€‚æˆ‘ä¼šå®šæœŸå‘å¸ƒç›¸å…³ä¸»é¢˜çš„æ–‡ç« ã€‚æ¬¢è¿éšæ—¶åˆ†äº«ä½ çš„è¯„è®ºï¼Œæˆ–é€šè¿‡ <a href="https://bsky.app/profile/stefanoq21.bsky.social"><strong>Bluesky</strong></a> æˆ– <a href="http://www.linkedin.com/in/stefano-natali-q21"><strong>LinkedIn</strong></a> ä¸æˆ‘è”ç³»ï¼Œè¿›è¡Œæ›´æ·±å…¥çš„è®¨è®ºã€‚</p>

<p>ç¥ä½ å¼€å¿ƒï¼Œç¼–ç¨‹å¿«ä¹ï¼</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[åœ¨Jetpack Composeä¸­åˆ›å»ºCRTå±å¹•æ•ˆæœ]]></title>
    <link href="https://alexhilton.github.io/blog/2025/11/12/crt-effects/"/>
    <updated>2025-11-12T13:42:48+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/11/12/crt-effects</id>
    <content type="html"><![CDATA[<blockquote><p>æœ¬æ–‡è¯‘è‡ªã€ŒCreating a CRT Screen Effect in Jetpack Composeã€ï¼ŒåŸæ–‡é“¾æ¥<a href="https://www.sinasamaki.com/creating-a-crt-screen-effect-in-jetpack-compose/">https://www.sinasamaki.com/creating-a-crt-screen-effect-in-jetpack-compose/</a>ï¼Œç”±sinasamakiå‘å¸ƒäº2025å¹´11æœˆ7æ—¥ã€‚</p></blockquote>

<p><a href=""><img src="https://www.sinasamaki.com/content/images/size/w2000/2025/11/CRT.png" title="auto auto" ></a></p>

<!-- more -->


<p>CRT æ˜¾ç¤ºå™¨å…·æœ‰ç‹¬ç‰¹è€Œæ€€æ—§çš„å¤–è§‚ï¼šæ¨¡ç³Šçš„è¾¹ç¼˜ã€æ‰«æçº¿å’Œè½»å¾®çš„è‰²å½©æº¢å‡ºã€‚è®©æˆ‘ä»¬å°è¯•ä½¿ç”¨ <code>GraphicsLayer</code> å’Œä¸€äº›å·§å¦™çš„å›¾å±‚æŠ€å·§åœ¨ Jetpack Compose ä¸­é‡ç°è¿™ç§æ•ˆæœã€‚</p>

<h2>GraphicsLayer</h2>

<p>ä¸ä¸Šä¸€ç¯‡æ–‡ç« ä¸€æ ·ï¼Œæ­¤æ•ˆæœçš„åŸºç¡€æ˜¯ <code>GraphicsLayer</code>ã€‚å®ƒå…è®¸æˆ‘ä»¬å°†å†…å®¹ç»˜åˆ¶ä¸€æ¬¡åˆ°å±å¹•å¤–ç¼“å†²åŒºã€‚ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥ä»¥æä½çš„æ€§èƒ½å¼€é”€å¤šæ¬¡ä½¿ç”¨ä¸åŒçš„æ•ˆæœé‡æ–°ç»˜åˆ¶å®ƒã€‚</p>

<pre><code class="kotlin">val graphicsLayer = rememberGraphicsLayer()

Box(Modifier.drawWithContent {
    graphicsLayer.record { 
        this@drawWithContent.drawContent() 
    }
}) {
    content()
}
</code></pre>

<p>ä¸€æ—¦æˆ‘ä»¬å°†å†…å®¹è®°å½•åˆ° <code>graphicsLayer</code> ä¸­ï¼Œå°±å¯ä»¥ä½¿ç”¨ <code>drawLayer(graphicsLayer)</code> æ ¹æ®éœ€è¦å¤šæ¬¡ç»˜åˆ¶å®ƒã€‚</p>

<p>æˆ‘å–œæ¬¢åœ¨é»‘è‰²èƒŒæ™¯ä¸Šç»˜åˆ¶è‰²å½©é²œè‰³ã€é¥±å’Œåº¦é«˜çš„å†…å®¹ï¼Œå¹¶è¿ç”¨è¿™ç§æ•ˆæœã€‚ä»¥ä¸‹æ˜¯æˆ‘ä»¬å°†åº”ç”¨æ­¤æ•ˆæœçš„åŸºç¡€å¯ç»„åˆå¯¹è±¡ã€‚</p>

<p><img src="https://www.sinasamaki.com/content/images/2025/11/Screenshot-2025-11-07-at-09.39.28.png" alt="" /></p>

<h2>æ·»åŠ æ‰«æçº¿</h2>

<p>ä¸ºäº†æ¨¡æ‹Ÿ CRT æ˜¾ç¤ºå™¨ä¸Šçš„æ°´å¹³æ‰«æçº¿ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨é‡å¤æ¸å˜ã€‚è®©æˆ‘ä»¬å°†å…¶æ”¾å…¥ä¸€ä¸ªæ‰©å±•å‡½æ•°ä¸­ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š</p>

<pre><code class="kotlin">private fun DrawScope.drawScanLines(alpha: Float, blendMode: BlendMode) {
    val color = Colors.Black.copy(alpha = alpha)
    drawRect(
        brush = Brush.verticalGradient(
            0f to color,
            0.4f to color,
            0.4f to Colors.Transparent,
            1f to Colors.Transparent,
            tileMode = TileMode.Repeated,
            startY = 0f,
            endY = 10f,
        ),
        blendMode = blendMode
    )
    drawRect(
        brush = Brush.horizontalGradient(
            0f to color,
            0.1f to color,
            0.1f to Colors.Transparent,
            1f to Colors.Transparent,
            tileMode = TileMode.Repeated,
            startX = 0f,
            endX = 10f,
        ),
        blendMode = blendMode
    )
}
</code></pre>

<p>æˆ‘ä»¬æ‰‹åŠ¨å®šä¹‰é¢œè‰²åœæ­¢ç‚¹ï¼Œä»¥ä¾¿åœ¨é¢œè‰²ä¹‹é—´å½¢æˆæ¸…æ™°çš„è¾¹ç¼˜ï¼Œç„¶åå°† <code>tileMode</code> è®¾ç½®ä¸º <code>Repeated</code>ã€‚è¿™æ ·ï¼Œå†åŠ ä¸Šè¾ƒçŸ­çš„èµ·ç‚¹å’Œç»ˆç‚¹ï¼Œå°±èƒ½å¾—åˆ°è®¸å¤šé‡å¤çš„å¹³è¡Œçº¿ã€‚</p>

<p>æ‰©å±•å‡½æ•°è¿˜ä¼šæ¥æ”¶æˆ‘ä»¬æ‰€éœ€çš„é€æ˜åº¦å’Œ <code>BlendMode</code> å‚æ•°ã€‚</p>

<p>ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ­¤å‡½æ•°åœ¨ <code>graphicsLayer</code> ä¸Šç»˜åˆ¶æ‰«æçº¿ã€‚</p>

<pre><code class="kotlin">.drawBehind {
    layer {
        drawLayer(graphicsLayer)
        drawScanLines(alpha = 1f, blendMode = BlendMode.DstOut)
    }
}
</code></pre>

<p>å°†æ··åˆæ¨¡å¼è®¾ç½®ä¸º <code>DstOut</code> ä¼šä»ç»˜åˆ¶çš„å†…å®¹ä¸­â€œå‡å»â€æˆ‘ä»¬çš„æ¸å˜ï¼Œä»è€Œäº§ç”Ÿè¿™ç§æ•ˆæœã€‚</p>

<p><img src="https://www.sinasamaki.com/content/images/2025/11/Screenshot-2025-11-07-at-09.39.55.png" alt="" /></p>

<h2>æ„å»ºæ¨¡ç³Šå›¾å±‚</h2>

<p>ä¸ºäº†å®ç° CRT å±å¹•å¸¸è§çš„å‘å…‰æ•ˆæœï¼Œæˆ‘ä»¬å°†å¤šæ¬¡ç»˜åˆ¶ <code>graphicsLayer</code> å›¾å±‚ï¼Œæ¯æ¬¡ç»˜åˆ¶æ—¶åˆ†åˆ«è®¾ç½®ä¸åŒçš„æ¨¡ç³ŠåŠå¾„ã€é€æ˜åº¦å’Œç¼©æ”¾æ¯”ä¾‹ã€‚</p>

<pre><code class="kotlin">val blurLayers = remember {
    listOf(
        Triple(1.dp, 0.2f, 1.02f to 1.03f),
        Triple(0.dp, .2f, 1f to 1f),
        Triple(1.dp, 0.9f, 1f to 1f),
        Triple(10.dp, 1f, 1f to 1f),
        Triple(40.dp, 1f, 1f to 1f),
    )
}
</code></pre>

<p>æˆ‘ä»¬å°†ä½¿ç”¨ä¸€ä¸ª <code>Triple</code> åˆ—è¡¨æ¥å­˜å‚¨æ¯ä¸ªå›¾å±‚çš„æ•°æ®ã€‚è¯¥åˆ—è¡¨çš„é¡ºåºä¹Ÿå®šä¹‰äº†å®ƒä»¬çš„ç»˜åˆ¶é¡ºåºã€‚æˆ‘å»ºè®®ä½ å°è¯•è°ƒæ•´è¿™äº›å€¼å’Œé¡ºåºï¼Œä»¥è·å¾—æ‰€éœ€çš„æ•ˆæœã€‚ä½†è¿™æ˜¯æˆ‘ç›®å‰ä½¿ç”¨çš„æ–¹æ³•ã€‚</p>

<pre><code class="kotlin">blurLayers.forEach { (blur, alpha, scale) -&gt;  
    Box(  
        Modifier  
            .matchParentSize()  
            .blur(blur, BlurredEdgeTreatment.Unbounded)  
            .graphicsLayer {  
                scaleX = scale.first  
                scaleY = scale.second  
                this.alpha = alpha  
            }  
            .drawBehind {  
                layer {  
                    drawLayer(graphicsLayer)  
                    drawScanLines(alpha = 1f, blendMode = BlendMode.DstOut)  
                }  
            }    
    )  
}
</code></pre>

<p>ç„¶åï¼Œæˆ‘ä»¬ä½¿ç”¨åˆ—è¡¨ä¸­çš„å€¼ç»˜åˆ¶æ¯ä¸ªå›¾å±‚ã€‚åœ¨ <code>drawBehind</code> ä¿®æ”¹å™¨ä¸Šæ–¹ï¼Œæˆ‘ä»¬å°†å›¾å±‚å¤§å°è®¾ç½®ä¸ºä¸çˆ¶å›¾å±‚åŒ¹é…ï¼Œå¹¶åº”ç”¨æ¨¡ç³Šã€ç¼©æ”¾å’Œé€æ˜åº¦ã€‚è¯·è®°ä½å°†æ¨¡ç³Šè®¾ç½®ä¸º <code>Unbounded</code>ï¼Œä½¿å…¶è¶…å‡ºåŒ…å«å®ƒçš„å¯ç»„åˆå¯¹è±¡çš„è¾¹ç•Œã€‚</p>

<p><img src="https://www.sinasamaki.com/content/images/2025/11/Screenshot-2025-11-07-at-08.33.20.png" alt="" /></p>

<h2>å±å¹•æŠ–åŠ¨</h2>

<p>æœ€åï¼Œæˆ‘ä»¬æ¥æ·»åŠ å±å¹•æŠ–åŠ¨æ•ˆæœï¼Œä»¥æ¨¡æ‹Ÿ CRT æ˜¾ç¤ºå™¨ç‰¹æœ‰çš„æŠ–åŠ¨ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡åˆ›å»ºä¸€ä¸ª <code>Offset</code> å¯¹è±¡ï¼Œå¹¶ç”¨ -1 åˆ° 1 ä¹‹é—´çš„éšæœºæµ®ç‚¹å€¼æ¥æ›´æ–°å®ƒã€‚</p>

<pre><code class="kotlin">var shake by remember { mutableStateOf(Offset.Zero) }

LaunchedEffect(Unit) {
    while (true) {
        shake = Offset(
            Random.nextInt(-1, 1) * Random.nextFloat(),
            Random.nextInt(-1, 1) * Random.nextFloat(),
        )
        delay(32)
    }
}
</code></pre>

<p>è¿™é‡Œåªéœ€åœ¨ä¸€ä¸ª while å¾ªç¯ä¸­å³å¯å®Œæˆã€‚å¯ä»¥è°ƒæ•´å»¶è¿Ÿæ—¶é—´æ¥æ§åˆ¶é—ªçƒçš„é—´éš”é¢‘ç‡ã€‚</p>

<pre><code class="kotlin">modifier = modifier  
    .graphicsLayer {  
        translationX = shake.x  
        translationY = shake.y  
    }
</code></pre>

<p>ç„¶åå¯ä»¥ä½¿ç”¨ä¿®é¥°ç¬¦æ¥åº”ç”¨æ­¤åç§»é‡ã€‚</p>

<p><img src="file:///Users/alexhilton/Downloads/crt_opt.gif" alt="" /></p>

<h2>æ•´åˆæ‰€æœ‰åŠŸèƒ½</h2>

<p>è®©æˆ‘ä»¬å°†æ‰€æœ‰è¿™äº›åŠŸèƒ½ç»„åˆæˆä¸€ä¸ªå¯è½»æ¾ä½¿ç”¨çš„ç»„åˆã€‚å®ƒä¼šæ¥æ”¶ <code>content</code> å‚æ•°ä»¥åŠ <code>flickerDelay</code> å‚æ•°ï¼Œåè€…ç”¨äºæ§åˆ¶é—ªçƒé¢‘ç‡ã€‚</p>

<pre><code class="kotlin">@Composable  
fun CRTBox(  
    modifier: Modifier = Modifier,  
    flickerDelay: Int = 32,  
    content: @Composable () -&gt; Unit,  
) {  
    var shake by remember { mutableStateOf(Offset.Zero) }  

    LaunchedEffect(Unit) {  
        while (flickerDelay &gt; 0) {  
            shake = Offset(  
                Random.nextInt(-1, 1) * Random.nextFloat(),  
                Random.nextInt(-1, 1) * Random.nextFloat(),  
            )  
            delay(flickerDelay.toLong())  
        }  
    }  

    val graphicsLayer = rememberGraphicsLayer()  

    Box(  
        modifier = modifier  
            .graphicsLayer {  
                translationX = shake.x  
                translationY = shake.y  
            }  
    ) {  
        Box(Modifier.drawWithContent {  
            graphicsLayer.record { this@drawWithContent.drawContent() }  
        }) {  
            content()  
        }  

        val blurLayers = remember {  
            listOf(  
                Triple(5.dp, .3f, 1.02f to 1.03f),  
                Triple(0.dp, .8f, 1f to 1f),  
                Triple(1.dp, .9f, 1f to 1f),  
                Triple(10.dp, .6f, 1.001f to 1f),  
                Triple(40.dp, .7f, 1f to 1f),  
            )  
        }  

        blurLayers.forEach { (blur, alpha, scale) -&gt;  
            Box(  
                Modifier  
                    .matchParentSize()  
                    .blur(blur, BlurredEdgeTreatment.Unbounded)  
                    .graphicsLayer {  
                        scaleX = scale.first  
                        scaleY = scale.second  
                        this.alpha = alpha  
                    }  
                    .drawBehind {  
                        layer {  
                            drawLayer(graphicsLayer)  
                            drawScanLines(alpha = 1f, blendMode = BlendMode.DstOut)  
                        }  
                    }            
            )  
        }  
    }}  

private fun DrawScope.layer(  
    bounds: Rect = size.toRect(),  
    block: DrawScope.() -&gt; Unit  
) =  
    drawIntoCanvas { canvas -&gt;  
        canvas.withSaveLayer(  
            bounds = bounds,  
            paint = Paint(),  
        ) { block() }  
    }  

private fun DrawScope.drawScanLines(alpha: Float, blendMode: BlendMode) {  
    val color = Colors.Black.copy(alpha = alpha)  
    drawRect(  
        brush = Brush.verticalGradient(  
            0f to color,  
            0.4f to color,  
            0.4f to Colors.Transparent,  
            1f to Colors.Transparent,  
            tileMode = TileMode.Repeated,  
            startY = 0f,  
            endY = 10f,  
        ),  
        blendMode = blendMode  
    )  
    drawRect(  
        brush = Brush.horizontalGradient(  
            0f to color,  
            0.1f to color,  
            0.1f to Colors.Transparent,  
            1f to Colors.Transparent,  
            tileMode = TileMode.Repeated,  
            startX = 0f,  
            endX = 10f,  
        ),  
        blendMode = blendMode  
    )  
}
</code></pre>

<p>ç„¶åï¼Œä½ å¯ä»¥åƒä½¿ç”¨å…¶ä»–å¯ç»„åˆç»„ä»¶ä¸€æ ·ä½¿ç”¨å®ƒï¼š</p>

<pre><code class="kotlin">CRTBox {
    Text("GAME OVER")
}
</code></pre>

<h2>Sweeper æ›´æ–°</h2>

<p>å¦‚æœä½ æƒ³æŸ¥çœ‹å®é™…æ•ˆæœï¼Œè¯·æŸ¥çœ‹æœ€æ–°çš„ Sweeper æ›´æ–°ï¼Œè¯¥æ›´æ–°ä½¿ç”¨ CRT æ•ˆæœåˆ›å»ºäº†ä¸€ä¸ªä»¤äººæ¯›éª¨æ‚šç„¶çš„ä¸‡åœ£èŠ‚ä¸»é¢˜ã€‚</p>

<p><img src="https://www.sinasamaki.com/content/images/2025/11/IMG_9612-Edited-copy.jpeg" alt="" /></p>

<p><a href="https://play.google.com/store/apps/details?id=com.sinasamaki.chroma.sweeper&amp;ref=sinasamaki.com">https://play.google.com/store/apps/details?id=com.sinasamaki.chroma.sweeper</a></p>

<p><a href="https://apps.apple.com/us/app/sweeper-by-sinasamaki/id6752220495?ref=sinasamaki.com">https://apps.apple.com/us/app/sweeper-by-sinasamaki/id6752220495</a></p>

<p>æ„Ÿè°¢é˜…è¯»ï¼Œç¥ä½ å¥½è¿ï¼</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compose CameraXç°å·²ç¨³å®šï¼šç»™Composerçš„ç«¯åˆ°ç«¯æŒ‡å—]]></title>
    <link href="https://alexhilton.github.io/blog/2025/11/02/compose-camerax-is-stable/"/>
    <updated>2025-11-02T14:10:34+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/11/02/compose-camerax-is-stable</id>
    <content type="html"><![CDATA[<blockquote><p>æœ¬æ–‡è¯‘è‡ªã€ŒCompose-Native CameraX Is Now Stable: End-to-End Guide for Jetpack Composeã€ï¼ŒåŸæ–‡é“¾æ¥<a href="https://proandroiddev.com/goodbye-androidview-camerax-goes-full-compose-4d21ca234c4e">https://proandroiddev.com/goodbye-androidview-camerax-goes-full-compose-4d21ca234c4e</a>ï¼Œç”±Ioannis Anifantakiså‘å¸ƒäº20251026ã€‚</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/1*sizZteIZmrzNr4X1BeXcJg.png" title="auto auto" ></a></p>

<!-- more -->


<h2>ç®€ä»‹</h2>

<p>è¿˜è®°å¾—ä½ åœ¨ Jetpack Compose ä¸­çš„ç¬¬ä¸€ä¸ªç›¸æœºé¡µé¢å—ï¼Ÿçº¯ç²¹çš„å£°æ˜å¼ä¹è¶£â€¦â€¦ç›´åˆ°é¢„è§ˆã€‚ç„¶åæ˜¯ç†Ÿæ‚‰çš„ <code>AndroidView(PreviewView)</code> ç»•é“ã€‚å®ƒç¡®å®æœ‰æ•ˆï¼Œä½†æ€»æ„Ÿè§‰ä¸å¯¹ï¼šcomposablesä¸­é—´æœ‰ä¸€ä¸ª View å½¢çŠ¶çš„ç©ºæ´ï¼ˆç±»ä¼¼äº <code>_iFrame_</code>_ â€¦â€¦ï¼‰ï¼Œè€Œä¸”ç‚¹å‡»å¯¹ç„¦çš„æ•°å­¦è®¡ç®—æ€»æ˜¯è®©äººæ„Ÿè§‰ä¸å¤ªå¯é ã€‚</p>

<p>åœ¨ I/O 25 ä¹‹åï¼Œè¿™ç§å¦¥åå·²ç»ç»“æŸã€‚</p>

<ul>
<li><strong>ä¸å†</strong> ä½¿ç”¨ <code>**AndroidView(PreviewView)**</code> è¿›è¡Œç›¸æœºé¢„è§ˆã€‚</li>
<li><strong>æ–°å¢</strong> <code>**CameraXViewfinder**</code> å¯ç»„åˆé¡¹ï¼Œå¯åœ¨ Compose ä¸­ç›´æ¥æ¸²æŸ“ CameraX <code>SurfaceRequest</code>ã€‚</li>
<li><strong>ä¿®æ­£äº†å†…ç½®åæ ‡å˜æ¢</strong>ï¼ˆç‚¹å‡»å¯¹ç„¦ã€å åŠ å±‚ï¼‰ï¼Œå¹¶å»ºç«‹äº†æ›´ç®€æ´ã€æ›´å…·å£°æ˜æ€§çš„å¿ƒæ™ºæ¨¡å‹ã€‚</li>
</ul>


<blockquote><p><strong><em>æ³¨æ„ï¼š</em></strong></p>

<p><em>â€œ</em>åœ¨ I/O 25 å¤§ä¼šä¸Šï¼ŒCompose æ”¯æŒå·²å‘å¸ƒ <strong>alpha/beta</strong> ç‰ˆæœ¬ï¼Œç¨³å®šç‰ˆå·²äº 9 æœˆå‘å¸ƒâ€”â€”ç°åœ¨æ˜¯æ—¶å€™äº†è§£ä¸€ä¸‹äº†ã€‚â€_</p></blockquote>

<h2>é…å¥—é¡¹ç›®</h2>

<p>ä½ å¯ä»¥åœ¨ <a href="https://github.com/ioannisa/CameraX-Composable-Demo/"><strong>GitHub ä¸Šçš„é…å¥—é¡¹ç›®</strong></a> æ‰¾åˆ°æœ¬æ–‡çš„é…å¥—é¡¹ç›®ï¼Œè¯¥é¡¹ç›®æ¼”ç¤ºäº† CameraX ä¸­ Jetpack Compose çš„æ–°åŠŸèƒ½ã€‚</p>

<h3>æƒé™ç”¨æˆ·ä½“éªŒï¼ˆç®€è¦è¯´æ˜ï¼‰</h3>

<p>æœ¬æ–‡å°†é‡ç‚¹ä»‹ç» Compose + CameraX çš„åŠŸèƒ½ã€‚<strong>é…å¥—é¡¹ç›®</strong> å®ç°äº†å®Œæ•´çš„è¿è¡Œæ—¶æµç¨‹ï¼š</p>

<ul>
<li>åœ¨é¢„è§ˆå…¥å£ç‚¹è¯·æ±‚ <code>**CAMERA**</code>ã€‚</li>
<li>ä»…åœ¨ç”¨æˆ·å¼€å§‹å½•åˆ¶æ—¶ï¼ˆæŒ‰éœ€éº¦å…‹é£ï¼‰è¯·æ±‚ <code>**RECORD_AUDIO**</code>ã€‚</li>
<li>ä¸€ä¸ªå°å‹çš„ <code>PermissionGate</code> å¯ç»„åˆå‡½æ•°è´Ÿè´£å¤„ç† Compose æ ‘ä¸­çš„æˆæƒ/æ‹’ç»/é‡æ–°è¯·æ±‚ã€‚</li>
<li>ä¸ºäº†æ»¡è¶³ Lint å¯¹ <code>@RequiresPermission</code> çš„è¦æ±‚ï¼Œè°ƒç”¨ç‚¹è¿˜ä¼šåœ¨è°ƒç”¨ä¸éº¦å…‹é£ç›¸å…³çš„ API ä¹‹å‰æ‰§è¡Œæ˜¾å¼ <code>checkSelfPermission(...)</code>ã€‚</li>
</ul>


<p>è¯·å‚é˜…ä»£ç åº“ï¼Œäº†è§£å…·ä½“çš„ <code>PermissionGate</code> ä»¥åŠæˆ‘ä»¬å¦‚ä½•å°†å…¶è¿æ¥åˆ° Capture é¡µé¢ã€‚</p>

<h2>å®é™…å˜åŒ–æ˜¯ä»€ä¹ˆï¼Ÿ</h2>

<p>CameraX å›¢é˜Ÿæ”¾å¼ƒäº† <code>androidx.camera:camera-compose</code>ï¼Œå–è€Œä»£ä¹‹çš„æ˜¯çœ‹ä¼¼ç®€å•çš„ APIï¼š<code>**CameraXViewfinder**</code>ã€‚ä½†è¿™ä¸ä»…ä»…æ˜¯â€œå°† <code>PreviewView</code> å°è£…åœ¨å¯ç»„åˆé¡¹ä¸­â€ã€‚è¿™æ˜¯å¯¹ Compose çš„å½»åº•é‡å†™ï¼Œä¹Ÿæ˜¯å¯¹ç›¸æœº Surface ä¸ Compose é›†æˆæ–¹å¼çš„æ ¹æœ¬æ€§é‡æ–°æ€è€ƒã€‚</p>

<p>ä»¥ä¸‹æ˜¯æ¶æ„å±‚é¢çš„å˜åŒ–ï¼š</p>

<p><strong>Compose ç›®æ ‡ä¼˜å…ˆ</strong>
å–æ™¯å™¨æ¸²æŸ“ç®¡é“ç°åœ¨å°† Compose è§†ä¸ºä¸»è¦å¹³å°ã€‚Surface ç”Ÿå‘½å‘¨æœŸã€æ—‹è½¬å¤„ç†å’Œç¼©æ”¾éƒ½ä»¥ Compose æƒ¯ç”¨çš„æ–¹å¼è¿›è¡Œã€‚</p>

<p><strong>å¼€ç®±å³ç”¨çš„æ­£ç¡®åæ ‡å˜æ¢</strong>
è¿˜è®°å¾—è®¡ç®—é¢„è§ˆä¸­çš„ç‚¹å‡»å®é™…æ˜ å°„åˆ°ç›¸æœºä¼ æ„Ÿå™¨çš„ä½ç½®ï¼Œå¹¶è€ƒè™‘æ—‹è½¬ã€å®½é«˜æ¯”è£å‰ªå’Œç¼©æ”¾æ¨¡å¼å—ï¼Ÿ<code>MutableCoordinateTransformer</code> å¯ä»¥å¤„ç†è¿™äº›ã€‚ç‚¹å‡»å¯¹ç„¦ç°åœ¨â€¦â€¦å¯ä»¥æ­£å¸¸å·¥ä½œäº†ã€‚</p>

<p><strong>çœŸæ­£çš„å¯ç»„åˆè¯­ä¹‰</strong>
æƒ³è¦å°†é¢„è§ˆ <code>clip()</code> è½¬æ¢ä¸ºè‡ªå®šä¹‰å½¢çŠ¶ï¼Ÿåº”ç”¨ <code>graphicsLayer</code> å˜æ¢ï¼Ÿä½¿ç”¨ <code>AnimatedContent</code> ä¸ºå…¶æ·»åŠ åŠ¨ç”»æ•ˆæœï¼Ÿç°åœ¨ï¼Œä½ å¯ä»¥è½»æ¾å®Œæˆæ‰€æœ‰è¿™äº›æ“ä½œï¼Œè€Œæ— éœ€ä¸æ¸²æŸ“å™¨å†²çªã€‚å®ƒä¸å…¶ä»–å¯ç»„åˆç»„ä»¶ä¸€æ ·ã€‚</p>

<p><strong>CameraX 1.5.x æˆç†Ÿåº¦</strong>
æ•´ä¸ªæŠ€æœ¯æ ˆéƒ½å¾—åˆ°äº†å®Œå–„ï¼šé€‚ç”¨äº Kotlin åç¨‹çš„ <code>ProcessCameraProvider.awaitInstance()</code>ã€å…¨é¢ç¨³å®šçš„æ„ä»¶ä»¥åŠæ›´å®Œå–„çš„æ–‡æ¡£ã€‚è¿™å¹¶é Beta æµ‹è¯•â€¦â€¦å®ƒå·²å‡†å¤‡å¥½æŠ•å…¥ç”Ÿäº§ã€‚</p>

<h2>ä¸ºä»€ä¹ˆè¿™çœŸçš„å¾ˆé‡è¦</h2>

<p>å¦‚æœä½ ä¸€ç›´åœ¨æ„å»ºç›¸æœºåŠŸèƒ½ï¼Œ<strong>ä½ å°±ä¼šçŸ¥é“å…¶ä¸­çš„ç—›ç‚¹</strong>ï¼š</p>

<ul>
<li><strong>å¿ƒæ™ºæ¨¡å‹åˆ†è£‚</strong>ï¼šâ€œç”¨ Compose æ€è€ƒ UIï¼Œç”¨ View æ€è€ƒç›¸æœºï¼Œå¹¶åœ¨ä¸¤è€…ä¹‹é—´ä¸æ–­è½¬æ¢ã€‚â€</li>
<li><strong>æ‰‹åŠ¿åè°ƒçš„å™©æ¢¦</strong>ï¼šåœ¨ Compose ä¸­å¤„ç†è§¦æ‘¸äº‹ä»¶ï¼Œåœ¨ View åæ ‡ç³»ä¸­æµ‹å…‰å¯¹ç„¦ï¼Œç¥ˆç¥·ä½ çš„è®¡ç®—å‡†ç¡®æ— è¯¯ã€‚</li>
<li><strong>Z è½´é¡ºåºéš¾é¢˜</strong>ï¼šâ€œPreviewViewâ€ ç»å¸¸ä½¿ç”¨åœ¨å•ç‹¬å›¾å±‚ä¸­æ¸²æŸ“çš„â€œSurfaceViewâ€ã€‚Compose å åŠ å±‚æ— æ³•å¯é åœ°ä½äºé¡¶éƒ¨ï¼Œå› æ­¤åå­—çº¿ã€å‚è€ƒçº¿å’ŒæŒ‰é’®å¯èƒ½ä¼šæ¶ˆå¤±åœ¨é¢„è§ˆå±‚åé¢ã€‚</li>
<li><strong>ç”Ÿå‘½å‘¨æœŸä¹‹èˆ</strong>ï¼šä½¿ç”¨ CameraX ç”¨ä¾‹ç»‘å®šå°† Compose é‡ç»„ä¸ View ç”Ÿå‘½å‘¨æœŸåŒæ­¥</li>
</ul>


<p>æ‰€æœ‰è¿™äº›æ‘©æ“¦ï¼Ÿéƒ½æ¶ˆå¤±äº†ã€‚</p>

<blockquote><p><strong>â€œç°åœ¨ï¼Œä½ å¯ä»¥åƒç¼–å†™å…¶ä»–ç°ä»£ Android åº”ç”¨ä¸€æ ·ç¼–å†™ç›¸æœº UIã€‚ä¸€ä¸ªèŒƒä¾‹ã€‚ä¸€ä¸ªå¿ƒæ™ºæ¨¡å‹ã€‚çº¯ç²¹çš„ Composeã€‚â€</strong></p></blockquote>

<h2>ä»£ç æ¼”ç¤º</h2>

<p>è®©æˆ‘ä»¬ä»æœ€åŸºæœ¬çš„å¼€å§‹â€”â€”ä¸€ä¸ªå¯ä»¥å·¥ä½œçš„ç›¸æœºé¢„è§ˆï¼ˆå›ºå®šçŠ¶æ€æ¨¡å¼ï¼šå°†<strong>å†™å…¥å™¨</strong> <code>MutableStateFlow</code> ä¸<strong>è¯»å–å™¨</strong> <code>collectAsState</code> åˆ†ç¦»ï¼‰ã€‚</p>

<pre><code class="kotlin">@Composable
fun CameraPreview(modifier: Modifier = Modifier) {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current

    // Writer: MutableStateFlow we can update from CameraX callbacks
    val surfaceRequests = remember { MutableStateFlow&lt;SurfaceRequest?&gt;(null) }

    // Reader: Compose state derived from the flow
    val surfaceRequest by surfaceRequests.collectAsState(initial = null)

    // Bind CameraX use cases once
    LaunchedEffect(Unit) {
        val provider = ProcessCameraProvider.awaitInstance(context)

        val preview = Preview.Builder().build().apply {
            // When CameraX needs a surface, publish it to Compose
            setSurfaceProvider { request -&gt;
                surfaceRequests.value = request
            }
        }

        provider.unbindAll()
        provider.bindToLifecycle(
            lifecycleOwner,
            CameraSelector.DEFAULT_BACK_CAMERA,
            preview
        )
    }

    // The actual Compose viewfinder
    surfaceRequest?.let { request -&gt;
        CameraXViewfinder(
            surfaceRequest = request,
            modifier = modifier.fillMaxSize()
        )
    }
}
</code></pre>

<p>å°±æ˜¯è¿™æ ·ã€‚æ²¡æœ‰ <code>AndroidView</code>ã€‚æ²¡æœ‰ <code>PreviewView</code>ã€‚åªæœ‰ä¸€ä¸ªå¯ç»„åˆç»„ä»¶ï¼Œå®ƒæ¥æ”¶ <code>SurfaceRequest</code> å¹¶è¿›è¡Œæ¸²æŸ“ã€‚</p>

<blockquote><p><strong><em>æ¨¡å¼å¾ˆç®€æ´ï¼šâ€œ</em></strong>CameraX å‘å¸ƒ Surface è¯·æ±‚ï¼ŒCompose å¤„ç†å®ƒä»¬ã€‚å•å‘ã€‚æ²¡æœ‰å›è°ƒåœ¨å„ä¸ªä¸–ç•Œä¹‹é—´æ¥å›åˆ‡æ¢ã€‚â€</p></blockquote>

<h3>å¯é€‰ï¼šä½¿ç”¨é•œå¤´åˆ‡æ¢æŒ‰é’®ï¼ˆFABï¼‰è¿›è¡Œé¢„è§ˆï¼ˆå‰/åï¼‰</h3>

<pre><code class="kotlin">@Composable
fun PreviewWithLensSwitch(modifier: Modifier = Modifier) {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current

    val surfaceRequests = remember { MutableStateFlow&lt;SurfaceRequest?&gt;(null) }
    val surfaceRequest by surfaceRequests.collectAsState(initial = null)

    // remember current lens
    var useFront by rememberSaveable { mutableStateOf(false) }
    val selector = if (useFront) CameraSelector.DEFAULT_FRONT_CAMERA else CameraSelector.DEFAULT_BACK_CAMERA

    // bind when camera selector changes (front/back camera)
    LaunchedEffect(selector) {
        val provider = ProcessCameraProvider.awaitInstance(context)
        val preview = Preview.Builder().build().apply {
            setSurfaceProvider { req -&gt; surfaceRequests.value = req }
        }
        provider.unbindAll()
        provider.bindToLifecycle(lifecycleOwner, selector, preview)
    }

    Box(Modifier.fillMaxSize()) {
        surfaceRequest?.let { req -&gt;
            CameraXViewfinder(surfaceRequest = req, modifier = Modifier.fillMaxSize())
        }
        FloatingActionButton(
            onClick = { useFront = !useFront },
            modifier = Modifier.align(Alignment.BottomEnd).padding(16.dp)
        ) { Icon(Icons.Rounded.Cameraswitch, contentDescription = "Switch camera") }
    }
}
</code></pre>

<h2>çœŸæ­£çš„è€ƒéªŒï¼šäº¤äº’å¼ç›¸æœºæ§ä»¶</h2>

<p>æ—§æ–¹æ³•çš„å¤±è´¥ä¹‹å¤„å°±åœ¨è¿™é‡Œã€‚è®©æˆ‘ä»¬å®ç°ç‚¹å‡»å¯¹ç„¦å’Œæåˆç¼©æ”¾â€¦â€¦è¿™äº›åŠŸèƒ½è¿‡å»éœ€è¦å¯¹è§†å›¾åæ ‡ç³»è¿›è¡Œä¸€äº› hackï¼ˆåŒæ ·ä½¿ç”¨å›ºå®šçš„å†™å…¥/è¯»å–æ¨¡å¼ï¼‰ï¼š</p>

<pre><code class="kotlin">@Composable
fun InteractiveCameraPreview(

modifier: Modifier = Modifier,

onFocusTap: (success: Boolean) -&gt; Unit = {}) {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current

    var camera by remember { mutableStateOf&lt;Camera?&gt;(null) }

    val surfaceRequests = remember { MutableStateFlow&lt;SurfaceRequest?&gt;(null) }
    val surfaceRequest by surfaceRequests.collectAsState(initial = null)

    // Bind camera once
    LaunchedEffect(Unit) {
        val provider = ProcessCameraProvider.awaitInstance(context)
        val preview = Preview.Builder().build().apply {
            setSurfaceProvider { req -&gt; surfaceRequests.value = req }
        }

        camera = provider.bindToLifecycle(
            lifecycleOwner,
            CameraSelector.DEFAULT_BACK_CAMERA,
            preview
        )
    }

    // Coordinate transformer: Compose UI â†’ Camera surface
    val coordinateTransformer = remember { MutableCoordinateTransformer() }

    surfaceRequest?.let { request -&gt;
        CameraXViewfinder(
            surfaceRequest = request,
            coordinateTransformer = coordinateTransformer,
            modifier = modifier
                .fillMaxSize()
                .pointerInput(camera) {
                    // Tap-to-focus
                    detectTapGestures { offset -&gt;
                        val cam = camera ?: return@detectTapGestures

                        // Transform Compose coordinates to camera surface
                        val surfacePoint = with(coordinateTransformer) {
                            offset.transform()
                        }

                        val meteringFactory = SurfaceOrientedMeteringPointFactory(
                            request.resolution.width.toFloat(),
                            request.resolution.height.toFloat()
                        )

                        val focusPoint = meteringFactory.createPoint(
                            surfacePoint.x,
                            surfacePoint.y
                        )

                        val action = FocusMeteringAction.Builder(
                            focusPoint,
                            FocusMeteringAction.FLAG_AF or FocusMeteringAction.FLAG_AE
                        ).setAutoCancelDuration(3, TimeUnit.SECONDS).build()

                        cam.cameraControl
                            .startFocusAndMetering(action)
                            .addListener(
                                { onFocusTap(true) },
                                ContextCompat.getMainExecutor(context)
                            )
                    }
                }
                .pointerInput(camera) {
                    // Pinch-to-zoom
                    detectTransformGestures { _, _, zoom, _ -&gt;
                        val cam = camera ?: return@detectTransformGestures
                        val zoomState = cam.cameraInfo.zoomState.value ?: return@detectTransformGestures

                        val newRatio = (zoomState.zoomRatio * zoom).coerceIn(
                            zoomState.minZoomRatio,
                            zoomState.maxZoomRatio
                        )

                        cam.cameraControl.setZoomRatio(newRatio)
                    }
                }
        )
    }
}
</code></pre>

<p>çœ‹çœ‹è¿™ä¸ªç‚¹å‡»å¯¹ç„¦çš„å®ç°ã€‚æ³¨æ„ä½ <strong>æ²¡æœ‰</strong>åšçš„äº‹æƒ…ï¼š</p>

<ul>
<li>æ— éœ€æ‰‹åŠ¨æ—‹è½¬è¡¥å¿</li>
<li>æ— éœ€è¿›è¡Œåæ ‡æ˜ å°„çš„å®½é«˜æ¯”è®¡ç®—</li>
<li>æ— éœ€è¿›è¡Œè§†å›¾ â†’ è¡¨é¢ â†’ ä¼ æ„Ÿå™¨åæ ‡é“¾è®¡ç®—</li>
<li>æ— éœ€è¿›è¡Œâ€œç¥ˆç¥·å®ƒåœ¨æ¨ªå‘æ¨¡å¼ä¸‹èƒ½æ­£å¸¸å·¥ä½œâ€çš„æ¼«é•¿æµ‹è¯•</li>
</ul>


<p><code>MutableCoordinateTransformer</code> å¯ä»¥å¤„ç†æ‰€æœ‰è¿™äº›ã€‚ä½ ç‚¹å‡» Compose åæ ‡ç³»ï¼Œå®ƒä¼šè½¬æ¢ä¸ºç›¸æœºåæ ‡ç³»ï¼Œå°±å®Œæˆäº†ã€‚</p>

<p>è¿™å°±æ˜¯â€œæŠ€æœ¯ä¸Šå¯è¡Œâ€å’Œâ€œå®é™…æ˜“äºå®ç°â€ä¹‹é—´çš„åŒºåˆ«ã€‚</p>

<h2>æ‹æ‘„ç…§ç‰‡å’Œè§†é¢‘</h2>

<p>æ·»åŠ æ‹æ‘„åŠŸèƒ½éµå¾ªç›¸åŒçš„ç®€æ´æ¨¡å¼â€”â€”ç»‘å®šå…¶ä»–ç”¨ä¾‹ï¼Œå¹¶ä» Compose ç•Œé¢è§¦å‘å®ƒä»¬ã€‚</p>

<p>æˆ‘ä»¬è¿˜å°†ä»…åœ¨å°è¯•å½•åˆ¶æ—¶è¯·æ±‚<strong>éº¦å…‹é£</strong>ï¼Œå¹¶ä½¿ç”¨ç®€å•çš„â€œPermissionGateâ€æ¨¡å¼ï¼ˆä¸æˆ‘ä»¬é¡¹ç›®åœ¨éœ€è¦æ—¶ä»…è¯·æ±‚éŸ³é¢‘çš„æ–¹æ³•ä¸€è‡´ï¼‰ã€‚</p>

<pre><code class="kotlin">@Composable
fun CameraScreen() {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current

    var camera by remember { mutableStateOf&lt;Camera?&gt;(null) }
    var imageCapture by remember { mutableStateOf&lt;ImageCapture?&gt;(null) }
    var videoCapture by remember { mutableStateOf&lt;VideoCapture&lt;Recorder&gt;?&gt;(null) }
    var activeRecording by remember { mutableStateOf&lt;Recording?&gt;(null) }

    val surfaceRequests = remember { MutableStateFlow&lt;SurfaceRequest?&gt;(null) }
    val surfaceRequest by surfaceRequests.collectAsState(initial = null)

    // Bind all use cases
    LaunchedEffect(Unit) {
        val provider = ProcessCameraProvider.awaitInstance(context)

        val preview = Preview.Builder().build().apply {
            setSurfaceProvider { req -&gt; surfaceRequests.value = req }
        }

        imageCapture = ImageCapture.Builder()
            .setCaptureMode(ImageCapture.CAPTURE_MODE_MINIMIZE_LATENCY)
            .build()

            val recorder = Recorder.Builder()
            .setQualitySelector(QualitySelector.from(Quality.FHD))
            .build()
        videoCapture = VideoCapture.withOutput(recorder)

        camera = provider.bindToLifecycle(
            lifecycleOwner,
            CameraSelector.DEFAULT_BACK_CAMERA,
            preview,
            imageCapture!!,
            videoCapture!!
        )
    }

    Box(modifier = Modifier.fillMaxSize()) {
        // Camera preview
        surfaceRequest?.let { request -&gt;
            CameraXViewfinder(
                surfaceRequest = request,
                modifier = Modifier.fillMaxSize()
            )
        }

        // Compose UI controls
        Row(
            modifier = Modifier
                .align(Alignment.BottomCenter)
                .padding(bottom = 32.dp)
        ) {
            // Capture photo button
            IconButton(
                onClick = { capturePhoto(context, imageCapture) }
            ) {
                Icon(Icons.Default.PhotoCamera, "Take Photo")
            }

            Spacer(modifier = Modifier.width(32.dp))

            // Video record toggle (mic requested only when needed)
            PermissionGate(
                permission = Permission.RECORD_AUDIO,
                // Optional: custom UI if permission is not yet granted
                contentNonGranted = { missing, humanReadable, requestPermissions -&gt;
                    // Minimal, inline UX: re-request directly
                    Button(onClick = { requestPermissions(missing) }) {
                        Text("Grant $humanReadable")
                    }
                }
            ) {
                IconButton(
                    onClick = {
                        activeRecording = toggleRecording(
                            context,
                            videoCapture,
                            activeRecording
                        )
                    }
                ) {
                    Icon(
                        if (activeRecording == null) Icons.Default.RadioButtonUnchecked
                        else Icons.Default.Stop,
                        "Record Video"
                    )
                }
            }
        }
    }
}

private fun capturePhoto(context: Context, imageCapture: ImageCapture?) {
    val capture = imageCapture ?: return

    val name = "IMG_${System.currentTimeMillis()}.jpg"
    val contentValues = ContentValues().apply {
        put(MediaStore.Images.Media.DISPLAY_NAME, name)
        put(MediaStore.Images.Media.MIME_TYPE, "image/jpeg")
        // On Android 10+ you could also set RELATIVE_PATH = "DCIM/CameraX"
    }

    val outputOptions = ImageCapture.OutputFileOptions.Builder(
        context.contentResolver,
        MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
        contentValues
    ).build()

    capture.takePicture(
        outputOptions,
        ContextCompat.getMainExecutor(context),
        object : ImageCapture.OnImageSavedCallback {
            override fun onImageSaved(output: ImageCapture.OutputFileResults) {
                // Success: output.savedUri
            }
            override fun onError(exception: ImageCaptureException) {
                // Handle error
            }
        }
    )
}

private fun toggleRecording(
    context: Context,
    videoCapture: VideoCapture&lt;Recorder&gt;?,
    currentRecording: Recording?
): Recording? {
    val capture = videoCapture ?: return null

    // Stop if already recording
    if (currentRecording != null) {
        currentRecording.stop()
        return null
    }

    // Start new recording
    val name = "VID_${System.currentTimeMillis()}.mp4"
    val contentValues = ContentValues().apply {
        put(MediaStore.Video.Media.DISPLAY_NAME, name)
        // On Android 10+ you could also set RELATIVE_PATH = "DCIM/CameraX"
    }

    val outputOptions = MediaStoreOutputOptions.Builder(
        context.contentResolver,
        MediaStore.Video.Media.EXTERNAL_CONTENT_URI
    ).setContentValues(contentValues).build()

    return capture.output
        .prepareRecording(context, outputOptions)
        .withAudioEnabled() // mic permission is ensured by PermissionGate above
        .start(ContextCompat.getMainExecutor(context)) { event -&gt;
            // Handle recording events (e.g., finalize, error)
        }
}
</code></pre>

<p>è¿™æ˜¯çº¯ç²¹çš„ Compose UI æ„å»ºã€‚ä½ çš„ç›¸æœºæŒ‰é’®ä¸é¢„è§ˆä½äºåŒä¸€ä¸ªå¯ç»„åˆæ ‘ä¸­ã€‚æ²¡æœ‰æ¡¥æ¥é€»è¾‘ã€‚æ— éœ€ç®¡ç†å•ç‹¬çš„ View å±‚æ¬¡ç»“æ„ã€‚</p>

<h2>è¿ç§»ç­–ç•¥ï¼šPreviewView â†’ CameraXViewfinder</h2>

<p>å¦‚æœä½ ç°æœ‰çš„ç›¸æœºä»£ç ä½¿ç”¨â€œPreviewViewâ€ï¼Œåˆ™è¿ç§»è·¯å¾„å¦‚ä¸‹ï¼š</p>

<p><strong>è¿ç§»å‰ï¼ˆæ—§æ–¹æ³•ï¼‰ï¼š</strong></p>

<pre><code class="kotlin">@Composable
fun OldCameraPreview() {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current
    val previewView = remember { PreviewView(context) }

    LaunchedEffect(previewView) {
        val provider = ProcessCameraProvider.getInstance(context).get()
        val preview = Preview.Builder().build()
        preview.setSurfaceProvider(previewView.surfaceProvider)
        provider.bindToLifecycle(lifecycleOwner, CameraSelector.DEFAULT_BACK_CAMERA, preview)
    }

    AndroidView(
        factory = { previewView },
        modifier = Modifier.fillMaxSize()
    )
}
</code></pre>

<p><strong>è¿ç§»åï¼ˆCompose åŸç”Ÿæ–¹æ³•ï¼‰ï¼š</strong></p>

<pre><code class="kotlin">@Composable
fun NewCameraPreview() {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current
    val selector = CameraSelector.DEFAULT_BACK_CAMERA

    val surfaceRequests = remember { MutableStateFlow&lt;SurfaceRequest?&gt;(null) }
    val surfaceRequest by surfaceRequests.collectAsState(initial = null)

    LaunchedEffect(Unit) {
        val provider = ProcessCameraProvider.awaitInstance(context)
        val preview = Preview.Builder().build().apply {
            setSurfaceProvider { req -&gt; surfaceRequests.value = req }
        }
        provider.unbindAll()
        provider.bindToLifecycle(lifecycleOwner, selector, preview)
    }

    surfaceRequest?.let {
        CameraXViewfinder(
            surfaceRequest = it,
            modifier = Modifier.fillMaxSize()
        )
    }
}
</code></pre>

<p>å…³é”®çš„æ€ç»´è½¬å˜ï¼šä¸å†å°† View çš„â€œSurfaceProviderâ€èµ‹äºˆ CameraXï¼Œè€Œæ˜¯å°†â€œSurfaceRequestâ€å¯¹è±¡å‘å¸ƒåˆ° Compose çŠ¶æ€ï¼Œå¹¶ä½¿ç”¨â€œCameraXViewfinderâ€è¿›è¡Œæ¸²æŸ“ã€‚</p>

<h2>æ‰€éœ€ä¾èµ–é¡¹</h2>

<p>æ·»åŠ åˆ°ä½ çš„ <code>build.gradle.kts</code> ä¸­ï¼š</p>

<pre><code class="kotlin">val cameraxVersion = "1.5.1"dependencies {
    implementation("androidx.camera:camera-core:$cameraxVersion")
    implementation("androidx.camera:camera-camera2:$cameraxVersion")
    implementation("androidx.camera:camera-lifecycle:$cameraxVersion")
    implementation("androidx.camera:camera-video:$cameraxVersion")

    // The new Compose-native viewfinder
    implementation("androidx.camera:camera-compose:$cameraxVersion")
}
</code></pre>

<p>æ¸…å•æƒé™ï¼š</p>

<pre><code class="xml">&lt;uses-permission android:name="android.permission.CAMERA" /&gt;
&lt;uses-permission android:name="android.permission.RECORD_AUDIO" /&gt;
</code></pre>

<h2><strong>å®ç°æ¨¡å¼ï¼ˆæ€§èƒ½ vs. åˆæˆï¼‰</strong></h2>

<p><code>CameraXViewfinder</code> å¯ä»¥é€šè¿‡ä¸¤ç§æ–¹å¼æ¸²æŸ“é¢„è§ˆï¼š</p>

<h3><strong>EXTERNALï¼ˆSurfaceView æ”¯æŒï¼‰</strong></h3>

<p>ç›¸æœºå¸§åœ¨å…¶<strong>è‡ªå·±çš„ Surface</strong> ä¸Šæ¸²æŸ“ï¼Œç”±ç³»ç»Ÿåœ¨ Compose ç»˜åˆ¶é€šé“<strong>ä¹‹å¤–</strong>åˆæˆã€‚å¯ä»¥æƒ³è±¡æˆâ€œUI èƒŒåçš„å®æ—¶è§†é¢‘å±‚â€ã€‚é€šå¸¸å¯ç”¨ç¡¬ä»¶å åŠ  â†’ æœ€ä½³æ€§èƒ½/å»¶è¿Ÿã€‚éå¸¸é€‚åˆåœ¨æ ‡å‡† UI åæ–¹æ˜¾ç¤ºå…¨å±çŸ©å½¢é¢„è§ˆã€‚ç”±äºå®ƒæ˜¯ä¸€ä¸ªå•ç‹¬çš„å±‚ï¼Œå› æ­¤å¯¹<em>ç›¸æœºåƒç´ </em>çš„é€åƒç´ æ•ˆæœï¼ˆå¤æ‚çš„è£å‰ª/æ¨¡ç³Šï¼‰ä¸é€‚ç”¨ã€‚</p>

<ul>
<li>ä¼˜ç‚¹ï¼šå»¶è¿Ÿæ›´ä½ï¼ŒGPU è´Ÿè½½æ›´å°‘ï¼Œéå¸¸é€‚åˆå…¨å±é¢„è§ˆ/å½•åˆ¶ã€‚</li>
<li>ç¼ºç‚¹ï¼šä¸å—é€åƒç´ ç•Œé¢ç‰¹æ•ˆï¼ˆåœ†è§’è’™ç‰ˆ/æ¨¡ç³Šï¼‰çš„å½±å“ï¼Œä¸ä¼šæ˜¾ç¤ºåœ¨ Compose å±å¹•æˆªå›¾ä¸­ã€‚</li>
</ul>


<h3><strong>åµŒå…¥å¼ï¼ˆTextureView æ”¯æŒï¼‰</strong></h3>

<p>ç›¸æœºå¸§ä½œä¸º<strong>GPU çº¹ç†</strong>ç»˜åˆ¶åœ¨ Compose æ¸²æŸ“é€šé“<strong>å†…éƒ¨</strong>â€”â€”ç±»ä¼¼äº<strong>å¯é‡ç»˜é¢æ¿</strong>ï¼Œå…¶è¡Œä¸ºä¸å…¶ä»–å¯ç»„åˆé¡¹ç±»ä¼¼ã€‚ä½ å¯ä»¥è·å¾—æ·±åº¦è£å‰ª/è’™ç‰ˆ/åŠ¨ç”»/æ¨¡ç³Š/Z è½´æ’åºï¼Œä½†ä»£ä»·æ˜¯ GPU å·¥ä½œé‡å¢åŠ ï¼Œå»¶è¿Ÿç•¥é«˜ã€‚</p>

<ul>
<li>ä¼˜ç‚¹ï¼šè¡Œä¸ºç±»ä¼¼äºæ™®é€šç•Œé¢ï¼›è£å‰ªã€Alpha é€šé“ã€æ¨¡ç³Šã€ç‰¹æ®Šå½¢çŠ¶å’Œå¤æ‚ Z è½´æ’åºå‡æ­£å¸¸ã€‚</li>
<li>ç¼ºç‚¹ï¼šGPU å·¥ä½œé‡å¢åŠ  â†’ åœ¨ç¹é‡çš„ç•Œé¢æˆ–ä¸­ç«¯è®¾å¤‡ä¸Šï¼Œå»¶è¿Ÿ/å¡é¡¿é£é™©ç•¥é«˜ã€‚</li>
</ul>


<h3><strong>ç»éªŒæ³•åˆ™</strong></h3>

<ul>
<li>å…¨å±/é«˜æ€§èƒ½ â†’ <strong>å¤–éƒ¨</strong></li>
<li>ç‰¹æ®Šæ„å›¾/ç‰¹æ•ˆ â†’ <strong>åµŒå…¥å¼</strong>ã€‚</li>
</ul>


<p>å¦‚æœä½ æœªæŒ‡å®šæ¨¡å¼ï¼Œåº“å°†é€‰æ‹©ä¸€ä¸ªåˆç†çš„é»˜è®¤æ¨¡å¼ã€‚å¼ºåˆ¶ä½¿ç”¨ä»¥ä¸‹æ–¹å¼ï¼š</p>

<pre><code class="kotlin">import androidx.camera.viewfinder.core.ImplementationMode

CameraXViewfinder(
    surfaceRequest = request,
    implementationMode = ImplementationMode.EXTERNAL // or ImplementationMode.EMBEDDED
)
</code></pre>

<h2>å®é™…æ“ä½œä¸­çš„é™·é˜±</h2>

<p><strong>åæ ‡å˜æ¢å¹¶éå¯é€‰</strong>
ä¸è¦å°†åŸå§‹ Compose åç§»é‡ä¼ é€’ç»™æµ‹é‡å·¥å‚ã€‚åŠ¡å¿…ä½¿ç”¨åæ ‡å˜æ¢å™¨ã€‚æ•°å­¦è¿ç®—çœ‹èµ·æ¥å¾ˆç®€å•ï¼Œç›´åˆ°ä½ åœ¨æ¨ªå±ã€å¯æŠ˜å è®¾å¤‡æˆ–éæ ‡å‡†å®½é«˜æ¯”è®¾å¤‡ä¸Šè¿›è¡Œæµ‹è¯•ã€‚</p>

<p><strong>å‰ç½®æ‘„åƒå¤´æ˜¯é•œåƒçš„</strong>
å¦‚æœä½ æ­£åœ¨ç»˜åˆ¶å åŠ å±‚æˆ–å¤„ç†æ‹æ‘„çš„å›¾åƒï¼Œè¯·è®°ä½å‰ç½®æ‘„åƒå¤´é¢„è§ˆé»˜è®¤æ˜¯é•œåƒçš„ï¼Œä½†æ‹æ‘„çš„å›¾åƒä¸æ˜¯ã€‚åœ¨ä½ çš„ç•Œé¢/å¤„ç†é€»è¾‘ä¸­è€ƒè™‘åˆ°è¿™ä¸€ç‚¹ã€‚</p>

<p><strong>åœ¨çœŸå®è®¾å¤‡ä¸Šæµ‹è¯•</strong>
ä¸åŒ OEM çš„ç›¸æœºè¡Œä¸ºæœ‰æ‰€ä¸åŒã€‚åœ¨ Pixel ä¸Šå®Œç¾è¿è¡Œçš„åŠŸèƒ½åœ¨ä¸‰æ˜Ÿæˆ–å°ç±³ä¸Šå¯èƒ½å­˜åœ¨é—®é¢˜ã€‚åœ¨ä»£è¡¨æ€§ç¡¬ä»¶ä¸Šæµ‹è¯•ä½ çš„å…³é”®æµç¨‹ã€‚</p>

<p><strong>æƒé™ç”¨æˆ·ä½“éªŒ</strong>
åœ¨å…¥å£ç‚¹è¯·æ±‚ <code>CAMERA</code>ï¼›ä»…åœ¨å¼€å§‹å½•åˆ¶æ—¶è¯·æ±‚ <code>RECORD_AUDIO</code>ï¼ˆè¿™æ˜¯ä¸€ç§è‰¯å¥½åšæ³•ï¼‰ã€‚ä¸Šé¢çš„å†…è” <code>PermissionGate</code> æ¨¡å¼å°†è¯¥é€»è¾‘ä¿ç•™åœ¨ä½ çš„ Compose æ ‘ä¸­ã€‚</p>

<h2>é«˜çº§åŠŸèƒ½ï¼šå¯æŠ˜å å’Œè‡ªé€‚åº” UI</h2>

<p>ç”±äº <code>CameraXViewfinder</code> åªæ˜¯å¦ä¸€ä¸ªå¯ç»„åˆé¡¹ï¼Œå› æ­¤å¯æŠ˜å æ”¯æŒéå¸¸ç®€å•ã€‚ç®€å•çš„åŒçª—æ ¼å¸ƒå±€æˆ–å…¨å±å¸ƒå±€é€šå¸¸å°±è¶³å¤Ÿäº†ï¼›å¦‚æœéœ€è¦ï¼Œå¯ä»¥ä½¿ç”¨ <code>AnimatedContent</code> æ¥åœ¨çŠ¶æ€ä¹‹é—´æ·»åŠ åŠ¨ç”»ã€‚</p>

<pre><code class="kotlin">@Composable
fun AdaptiveCameraScreen(surfaceRequest: SurfaceRequest?) {
    val expanded = remember { mutableStateOf(false) } // pretend this reflects window size/hinge state

    AnimatedContent(targetState = expanded.value, label = "layout") { isExpanded -&gt;
        if (isExpanded) {
            Row(Modifier.fillMaxSize()) {
                surfaceRequest?.let {
                    CameraXViewfinder(
                        surfaceRequest = it,
                        modifier = Modifier
                            .weight(1f)
                            .aspectRatio(9f / 16f)
                    )
                }
                Box(Modifier.weight(1f)) { /* CameraControls(Modifier.align(Alignment.Center)) */ }
            }
        } else {
            Box(Modifier.fillMaxSize()) {
                surfaceRequest?.let {
                    CameraXViewfinder(
                        surfaceRequest = it,
                        modifier = Modifier.fillMaxSize()
                    )
                }
                /* CameraControls(Modifier.align(Alignment.BottomCenter)) */
            }
        }
    }
}
</code></pre>

<h2>æµ‹è¯•æ¸…å•ï¼ˆå®ç”¨ï¼‰</h2>

<ul>
<li>éªŒè¯çºµå‘/æ¨ªå‘ä»¥åŠ <code>ContentScale.Crop/Fit</code> æ¨¡å¼ä¸‹çš„ç‚¹å‡»å¯¹ç„¦ç²¾åº¦ã€‚</li>
<li>æµ‹è¯•ç¼©æ”¾é™åˆ¶ï¼›ç¡®ä¿æåˆå’Œç¨‹åºåŒ–ç¼©æ”¾è¿‡æ¸¡æµç•…ã€‚</li>
<li>åˆ‡æ¢æ‘„åƒå¤´ï¼ˆå‰/åï¼‰å¹¶é‡æ–°éªŒè¯å˜æ¢ + é•œåƒè¡Œä¸ºã€‚</li>
<li>å¯¼èˆªç¦»å¼€/åé€€ã€æ—‹è½¬å’Œå¤„ç†é…ç½®æ›´æ”¹ï¼›é¢„è§ˆåº”èƒ½å¤Ÿæ¢å¤ä¸”ä¸é—ªçƒã€‚</li>
<li>åœ¨å¯¹ç„¦/ç¼©æ”¾æ—¶å½•åˆ¶è§†é¢‘ï¼›ç¡®ä¿æ²¡æœ‰è¡¨é¢æ‰è½ã€‚</li>
</ul>


<h2>å…¨å±€å±•æœ›</h2>

<p>æ­¤ç‰ˆæœ¬çš„é‡è¦æ€§ä¸ä»…åœ¨äºå®ƒå¸¦æ¥çš„åŠŸèƒ½ï¼Œè¿˜åœ¨äºå®ƒæ‰€ä¼ é€’çš„ä¿¡æ¯ã€‚</p>

<p>å¤šå¹´æ¥ï¼ŒAndroid ä¸­çš„ç›¸æœºå¼€å‘ä¸€ç›´æ„Ÿè§‰åƒæ˜¯äºŒç­‰å…¬æ°‘ã€‚é™¤äº†ç›¸æœºé¡µé¢ä¹‹å¤–ï¼Œä½ å¯ä»¥åœ¨ä»»ä½•åœ°æ–¹ä½¿ç”¨ Compose æ„å»ºç°ä»£ UIï¼Œè€Œç›¸æœºé¡µé¢åˆ™éœ€è¦ä½ å‹‰å¼ºæ‰èƒ½ä¸ View è¿›è¡Œäº’æ“ä½œã€‚è™½ç„¶ Compose ç¡®å®æœ‰æ•ˆï¼Œä½†ç¼–å†™ä»£ç æ—¶æ€»æ„Ÿè§‰åƒæ˜¯è¢«æŸç¼šäº†ä¸€åªæ‰‹ã€‚</p>

<p><code>camera-compose</code> ä¸ä»…ä»…æ˜¯ä¸€ä¸ªæ–°äº§ç‰©ã€‚CameraX å›¢é˜Ÿæ›¾è¯´è¿‡ï¼šâ€œCompose ç°åœ¨æ˜¯ä¸€æµçš„ç›¸æœºå¼€å‘å¹³å°ã€‚â€</p>

<p>è¿™æ„å‘³ç€ï¼š</p>

<ul>
<li>æœªæ¥çš„ç›¸æœºåŠŸèƒ½å°†åœ¨è®¾è®¡æ—¶å……åˆ†è€ƒè™‘ Composeï¼Œè€Œä¸æ˜¯å¯¹å…¶è¿›è¡Œæ”¹é€ ã€‚</li>
<li>ç¤¾åŒºå°†æ„å»ºä»¥ Compose ä¸ºå…ˆçš„ç›¸æœºåº“å’Œç»„ä»¶ã€‚</li>
<li>æœ€ä½³å®è·µå°†å›´ç»•å¯ç»„åˆç›¸æœº UI ä¸æ–­å‘å±•ã€‚</li>
<li>æ–‡æ¡£å’Œç¤ºä¾‹å°†åæ˜ ç°ä»£ Android å¼€å‘ã€‚</li>
</ul>


<p>æˆ‘ä»¬åœ¨æ•´ä¸ª Android ç”Ÿæ€ç³»ç»Ÿä¸­éƒ½çœ‹åˆ°äº†è¿™ç§æ¨¡å¼â€”â€”æœ€åˆä»¥ View ä¸ºä¸­å¿ƒçš„ API æ­£åœ¨é€æ¸è·å¾— Compose åŸç”Ÿçš„å¯¹åº”ç‰ˆæœ¬ã€‚<code>camera-compose</code> å°±æ˜¯è¿„ä»Šä¸ºæ­¢æœ€å…·å½±å“åŠ›çš„ä¾‹å­ä¹‹ä¸€ã€‚</p>

<h2>ä½ ç°åœ¨åº”è¯¥åšä»€ä¹ˆ</h2>

<p><strong>å¦‚æœä½ æ­£åœ¨å¼€å‘ä¸€ä¸ªæ–°çš„ç›¸æœºåŠŸèƒ½ï¼š</strong>
ä»ä¸€å¼€å§‹å°±ä½¿ç”¨ <code>CameraXViewfinder</code>ã€‚ç”šè‡³ä¸éœ€è¦è€ƒè™‘ <code>PreviewView</code>ã€‚å®ƒçš„ä»£ç æ›´ç®€æ´ï¼Œæ€ç»´æ¨¡å‹æ›´ç®€å•ï¼Œä½ ä»¥åä¼šæ„Ÿè°¢è‡ªå·±çš„ã€‚</p>

<p><strong>å¦‚æœä½ å·²ç»æœ‰ç›¸æœºä»£ç ï¼š</strong>
å°† <code>camera-compose</code> æ·»åŠ åˆ°ä½ çš„ä¾èµ–é¡¹ä¸­ï¼Œå¹¶ä¸€æ¬¡è¿ç§»ä¸€ä¸ªé¡µé¢ã€‚ä»æœ€ç®€å•çš„ç›¸æœº UIï¼ˆå¯èƒ½æ˜¯åŸºæœ¬çš„çº¯é¢„è§ˆé¡µé¢ï¼‰å¼€å§‹ï¼Œç†Ÿæ‚‰æ–°çš„ APIã€‚ç„¶åå†å¤„ç†å¤æ‚çš„éƒ¨åˆ†ã€‚</p>

<p><strong>å¦‚æœä½ æ­£åœ¨æ„å»ºä¸€ä¸ªåº“ï¼š</strong>
ç°åœ¨æ˜¯æ—¶å€™å°† Compose åŸç”Ÿç›¸æœºç»„ä»¶æ·»åŠ åˆ°ä½ çš„ SDK ä¸­äº†ã€‚å¼€å‘è€…æ­£åœ¨å¯»æ‰¾å¯ç»„åˆçš„ç›¸æœºè§£å†³æ–¹æ¡ˆï¼Œè€Œç”Ÿæ€ç³»ç»Ÿå·²ç»ä¸ºä»–ä»¬åšå¥½äº†å‡†å¤‡ã€‚</p>

<h2>å»¶ä¼¸é˜…è¯»</h2>

<ul>
<li><a href="https://developer.android.com/jetpack/androidx/releases/camera">CameraX å‘è¡Œè¯´æ˜</a> â€” å®˜æ–¹æ›´æ–°æ—¥å¿—å’Œå·¥ä»¶</li>
<li><a href="https://developer.android.com/jetpack/androidx/releases/camera-viewfinder">Camera Viewfinder æ–‡æ¡£</a> â€” å®ç°æ¨¡å¼ã€ç¼©æ”¾å’Œå¯¹é½</li>
<li><a href="https://github.com/androidx/androidx/tree/androidx-main/camera">CameraX GitHub ç¤ºä¾‹</a> â€” çœŸå®ä»£ç ç¤ºä¾‹</li>
</ul>


<h2>å›½ç‹å·²æ­» / å›½ç‹ä¸‡å²</h2>

<p>â€œAndroidViewâ€ç›¸æœºé¢„è§ˆçš„æ—¶ä»£å·²ç»ç»“æŸã€‚å¦‚æœä½ è¦åœ¨ 2025 å¹´åŠä»¥åæ„å»ºç›¸æœºåŠŸèƒ½ï¼Œé‚£ä¹ˆä½ å°†ä½¿ç”¨ Compose æ¥æ„å»ºå®ƒä»¬ã€‚ç°åœ¨ç»ˆäºæœ‰äº†å¯ä»¥æ­£ç¡®æ”¯æŒè¿™äº›åŠŸèƒ½çš„å·¥å…·ã€‚</p>

<p>ç°åœ¨ï¼Œç”©æ‰é‚£ä¸ªâ€œAndroidViewâ€åŒ…è£…å™¨ï¼Œç¼–å†™ä¸€äº›æ¼‚äº®çš„ç›¸æœº UI å§ã€‚</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ç†è§£retain{}çš„å†…éƒ¨æœºåˆ¶ï¼šJetpack Composeä¸­åŸºäºä½œç”¨åŸŸçš„çŠ¶æ€ä¿å­˜]]></title>
    <link href="https://alexhilton.github.io/blog/2025/10/22/understanding-retrain-internals/"/>
    <updated>2025-10-22T14:29:55+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/10/22/understanding-retrain-internals</id>
    <content type="html"><![CDATA[<blockquote><p>æœ¬æ–‡è¯‘è‡ªã€ŒUnderstanding retain{} internals: A Scope-based State Preservation in Jetpack Composeã€ï¼ŒåŸæ–‡é“¾æ¥<a href="https://proandroiddev.com/understanding-retain-internals-a-new-way-to-preserve-state-in-jetpack-compose-54471a32fd05">https://proandroiddev.com/understanding-retain-internals-a-new-way-to-preserve-state-in-jetpack-compose-54471a32fd05</a>ï¼Œç”±Jaewoong Eumå‘å¸ƒäº2025å¹´10æœˆ15æ—¥ã€‚</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/1*yQo3amM25om4TWkUzgxjvQ.jpeg" title="auto auto" ></a></p>

<!-- more -->


<p>Jetpack Compose æ˜¯ä¸€ç§ç°ä»£ Android UI å¼€å‘æ–¹å¼ï¼Œæ‹¥æœ‰å£°æ˜å¼æ–¹æ³•å’Œå¼ºå¤§çš„çŠ¶æ€ç®¡ç†åŸè¯­ã€‚è™½ç„¶ <code>remember{}</code> èƒ½å¤Ÿå¾ˆå¥½åœ°åœ¨é‡ç»„è¿‡ç¨‹ä¸­ä¿å­˜çŠ¶æ€ï¼Œä½†å®ƒæœ‰ä¸€ä¸ªæ ¹æœ¬æ€§çš„å±€é™æ€§ï¼šå®ƒæ— æ³•åœ¨é…ç½®æ›´æ”¹æˆ–å¯¼èˆªè½¬æ¢åç»§ç»­ç”Ÿæ•ˆã€‚å¼•å…¥ <code>retain{}</code>ï¼Œè¿™æ˜¯ä¸€ç§åœ¨ç¬æ—¶é”€æ¯åœºæ™¯ä¸‹ä¿å­˜çŠ¶æ€çš„æ–°æ–¹æ³•ï¼ŒåŒæ—¶ä¿æŒå¯ç»„åˆæ€§ã€‚</p>

<p>åœ¨æœ¬æ–‡ä¸­ï¼Œä½ å°†æ·±å…¥äº†è§£ <code>retain{}</code>ã€<code>RetainScope</code>ã€<code>RetainObserver</code> å’Œ <code>RetainedEffect</code> çš„å†…éƒ¨æœºåˆ¶ï¼Œæ¢ç´¢å®ƒä»¬çš„åº•å±‚å·¥ä½œåŸç†ï¼Œä»¥åŠä½¿ Retention æ—¢å†…å­˜å®‰å…¨åˆæ€§èƒ½å“è¶Šçš„ä¼˜åŒ–æ–¹æ³•ã€‚</p>

<p>å¦‚æœä½ å°šæœªé˜…è¯»ä»¥ä¸‹ä¹‹å‰çš„æ–‡ç« ï¼Œç†è§£ä»¥ä¸‹éƒ¨åˆ†å°†å¯¹ä½ æœ‰æ‰€å¸®åŠ©ï¼š</p>

<ul>
<li><a href="https://medium.com/proandroiddev/exploring-retain-api-a-new-way-to-persist-state-in-jetpack-compose-bfb2fe2eae43">é¢„è§ˆ retain{} APIï¼šJetpack Compose ä¸­æŒä¹…åŒ–çŠ¶æ€çš„æ–°æ–¹æ³•</a></li>
<li><a href="https://medium.com/proandroiddev/previewing-retainedeffect-a-new-side-effect-to-bridge-between-composition-and-retention-lifecycles-685b9e543de7">é¢„è§ˆ RetainedEffectï¼šæ¡¥æ¥ Composition å’Œ Retention ç”Ÿå‘½å‘¨æœŸçš„æ–° Side Effect</a></li>
</ul>


<h2>å¯¼å…¥ Compose è¿è¡Œæ—¶ retain åº“</h2>

<p>ä½ å¯ä»¥ä½¿ç”¨ä»¥ä¸‹ä¾èµ–é¡¹å¯¼å…¥ Compose è¿è¡Œæ—¶ retain åº“ï¼š</p>

<pre><code class="kotlin">implementation("androidx.compose.runtime:runtime-retain:1.10.0-alpha05")
</code></pre>

<p>è¯·æ³¨æ„ï¼Œæ­¤åº“ç›®å‰å¤„äºå®éªŒé˜¶æ®µï¼Œæœªæ¥å°†ä¸æ–­å®Œå–„å’Œç¨³å®šå‘å¸ƒã€‚</p>

<h2>ç†è§£æ ¸å¿ƒé—®é¢˜ï¼šä¸ºä»€ä¹ˆ remember{} è¿˜ä¸å¤Ÿ</h2>

<p>ä»æœ¬è´¨ä¸Šè®²ï¼Œ<code>remember{}</code> å¯ä»¥åœ¨å•ä¸ªç»„åˆç”Ÿå‘½å‘¨æœŸå†…è·¨é‡ç»„ä¿ç•™çŠ¶æ€ã€‚ä½†æ˜¯ï¼Œå½“ä½ çš„ Activity å› é…ç½®æ›´æ”¹è€Œé‡æ–°åˆ›å»ºæ—¶ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿæˆ–è€…å½“å¯¼èˆªç›®æ ‡ä»è¿”å›å †æ ˆä¸­ç§»é™¤æ—¶ï¼ŸçŠ¶æ€ä¼šä¸¢å¤±ï¼Œä½ çš„å¯ç»„åˆé¡¹ä¼šé‡æ–°å¼€å§‹ã€‚</p>

<p>ä¼ ç»Ÿçš„ Android è§£å†³æ–¹æ¡ˆæ¶‰åŠ <code>ViewModel</code> å’Œ <code>SavedStateHandle</code>ï¼Œä½†å®ƒä»¬æœ¬èº«ä¹Ÿå…·æœ‰å¤æ‚æ€§ï¼šåºåˆ—åŒ–è¦æ±‚ã€æ‰‹åŠ¨çŠ¶æ€æ¢å¤ä»¥åŠåœ¨å¯ç»„åˆé¡¹å±‚æ¬¡ç»“æ„ä¹‹å¤–ç®¡ç†çŠ¶æ€çš„è®¤çŸ¥å¼€é”€ã€‚å¦‚æœæˆ‘ä»¬å¯ä»¥æ‹¥æœ‰ä¸€ä¸ªåƒ <code>remember{}</code> ä¸€æ ·å·¥ä½œï¼Œä½†åˆèƒ½åœ¨è¿™äº›ç¬æ—¶é”€æ¯åç»§ç»­å­˜åœ¨çš„ä¸œè¥¿ï¼Œé‚£ä¼šæ€æ ·ï¼Ÿ</p>

<pre><code class="kotlin">// With remember: state lost on configuration change
@Composable
fun VideoPlayer() {
    val player = remember { MediaPlayer() } // Lost on rotation!
}

// With retain: state preserved across configuration changes
@Composable
fun VideoPlayer() {
    val player = retain { MediaPlayer() } // Survives rotation!
}
</code></pre>

<p><code>retain{}</code> èƒŒåçš„å…³é”®æ´å¯Ÿæ˜¯ï¼ŒçŠ¶æ€é”€æ¯å¹¶ä¸æ€»æ˜¯æ°¸ä¹…æ€§çš„ã€‚é€šå¸¸ï¼Œå®ƒæ˜¯æš‚æ—¶çš„ï¼›å†…å®¹ä¼šè¢«é‡æ–°åˆ›å»ºï¼Œæ¢å¤ä¹‹å‰çš„çŠ¶æ€ä¼šå¯¹æˆ‘ä»¬æœ‰åˆ©ã€‚è¿™å°±æ˜¯â€œRetainScopeâ€å‘æŒ¥ä½œç”¨çš„åœ°æ–¹ã€‚</p>

<h2>retain{} API åŠå…¶ç”Ÿå‘½å‘¨æœŸ</h2>

<p>å¦‚æœä½ æ£€æŸ¥ retain å‡½æ•°ç­¾åï¼Œä¼šå‘ç°å®ƒä¸ <code>remember</code> API ç±»ä¼¼ï¼Œä½†å­˜åœ¨ä»¥ä¸‹åŒºåˆ«ï¼š</p>

<pre><code class="kotlin">@Composable
public inline fun &lt;reified T&gt; retain(noinline calculation: () -&gt; T): T

@Composable
public inline fun &lt;reified T&gt; retain(vararg keys: Any?, noinline calculation: () -&gt; T): T
</code></pre>

<p>å¸¦æœ‰ <code>reified</code> ç±»å‹å‚æ•°çš„ inline ä¿®é¥°ç¬¦æ— éœ€æ˜¾å¼ç±»å‚æ•°å³å¯å®ç°ç±»å‹å®‰å…¨çš„ä¿ç•™ã€‚ä½†çœŸæ­£çš„é­”åŠ›åœ¨äºå…¶å®ç°ï¼š</p>

<pre><code class="kotlin">@Composable
private fun &lt;T&gt; retainImpl(key: RetainKeys, calculation: () -&gt; T): T {
    val retainScope = LocalRetainScope.current
    val holder = remember(key) {
        val retainedValue = retainScope.getExitedValueOrDefault(key, RetainScopeMissingValue)
        if (retainedValue !== RetainScopeMissingValue) {
            RetainedValueHolder(
                key = key,
                value = @Suppress("UNCHECKED_CAST") (retainedValue as T),
                owner = retainScope,
                isNewlyRetained = false,
            )
        } else {
            RetainedValueHolder(
                key = key,
                value = calculation(),
                owner = retainScope,
                isNewlyRetained = true,
            )
        }
    }

    if (holder.owner !== retainScope) {
        SideEffect { holder.readoptUnder(retainScope) }
    }
    return holder.value
}
</code></pre>

<p>æ­¤å®ç°æ­ç¤ºäº†ä¿ç•™çš„ä¸¤ä¸ªé˜¶æ®µç‰¹æ€§ï¼š</p>

<p><strong>é˜¶æ®µ 1ï¼šè®°å¿†é˜¶æ®µ</strong>ã€‚<code>retain{}</code> é¦–å…ˆä½¿ç”¨ <code>remember{}</code> åˆ›å»ºä¸€ä¸ª <code>RetainedValueHolder</code>ã€‚è¯¥æŒæœ‰è€…åŒ…è£…å®é™…å€¼å¹¶è·Ÿè¸ªå…¶ç”Ÿå‘½å‘¨æœŸã€‚</p>

<p><strong>é˜¶æ®µ 2ï¼šä¿ç•™é˜¶æ®µ</strong>ã€‚å½“æŒæœ‰è€…ç¦»å¼€ç»„åˆæ—¶ï¼Œ<code>RetainScope</code> ä¸ä¼šç«‹å³å°†å…¶ä¸¢å¼ƒï¼Œè€Œæ˜¯å†³å®šæ˜¯å¦å°†å…¶ä¿ç•™ä»¥å¤‡å°†æ¥æ¢å¤ã€‚</p>

<h2>RetainedValueHolder å’Œ RetainScope</h2>

<p>é¦–å…ˆï¼Œå¦‚æœä½ ä»”ç»†ç ”ç©¶ <code>RetainedValueHolder</code> çš„å†…éƒ¨ä»£ç ï¼Œä½ ä¼šå‘ç°å®ƒæ˜¯ç”Ÿå‘½å‘¨æœŸç®¡ç†å‘ç”Ÿçš„åœ°æ–¹ã€‚å®ƒå®ç°äº† <code>RememberObserver</code> æ¥å£ï¼Œä»¥ä¾¿ä¸ Compose çš„ç”Ÿå‘½å‘¨æœŸæŒ‚é’©ï¼š</p>

<pre><code class="kotlin">internal class RetainedValueHolder&lt;out T&gt; internal constructor(
    val key: Any,
    val value: T,
    owner: RetainScope,
    private var isNewlyRetained: Boolean,
) : RememberObserver {

    override fun onRemembered() {
        if (value is RetainObserver) {
            if (isNewlyRetained) {
                isNewlyRetained = false
                value.onRetained()
            }
            value.onEnteredComposition()
        }
    }

    override fun onForgotten() {
        if (owner.isKeepingExitedValues) {
            owner.saveExitingValue(key, value)
        }

        if (value is RetainObserver) {
            value.onExitedComposition()
            if (!owner.isKeepingExitedValues) value.onRetired()
        }
    }

    override fun onAbandoned() {
        if (owner.isKeepingExitedValues) {
            if (value is RetainObserver) value.onRetained()
            owner.saveExitingValue(key, value)
        } else if (value is RetainObserver) {
            value.onUnused()
        }
    }
}
</code></pre>

<p>é‡è¦çš„ä¸€ç‚¹æ˜¯ï¼Œè¯¥æŒæœ‰è€…ä¼šæ‹¦æˆªç»„åˆç”Ÿå‘½å‘¨æœŸäº‹ä»¶å¹¶å°†å…¶è½¬æ¢ä¸ºä¿ç•™äº‹ä»¶ã€‚å½“ <code>onForgotten()</code> è¢«è°ƒç”¨æ—¶ï¼ˆå€¼ç¦»å¼€ç»„åˆï¼‰ï¼Œå®ƒä¼šæ£€æŸ¥ <code>RetainScope</code> æ˜¯å¦ä¿ç•™äº†å·²é€€å‡ºçš„å€¼ã€‚å¦‚æœæ˜¯ï¼Œå®ƒä¼šä¿å­˜è¯¥å€¼ä»¥ä¾›å°†æ¥æ¢å¤ï¼Œè€Œä¸æ˜¯ä¸¢å¼ƒå®ƒã€‚</p>

<p><code>RetainScope</code> æ˜¯ä¿ç•™ç³»ç»Ÿçš„æ ¸å¿ƒæ¦‚å¿µã€‚å®ƒç®¡ç†ä½•æ—¶ä¿ç•™å€¼ã€å¦‚ä½•å­˜å‚¨å®ƒä»¬ä»¥åŠä½•æ—¶æ¢å¤æˆ–é€€å‡ºå®ƒä»¬ã€‚è®©æˆ‘ä»¬æ¥çœ‹çœ‹å®ƒçš„ç»†èŠ‚ï¼š</p>

<pre><code class="kotlin">public abstract class RetainScope : RetainStateProvider {
    protected var keepExitedValuesRequests: Int = 0
        private set

    final override val isKeepingExitedValues: Boolean
        get() = keepExitedValuesRequests &gt; 0

    public abstract fun getExitedValueOrDefault(key: Any, defaultIfAbsent: Any?): Any?
    protected abstract fun saveExitingValue(key: Any, value: Any?)
    protected abstract fun onStartKeepingExitedValues()
    protected abstract fun onStopKeepingExitedValues()
}
</code></pre>

<p>ä½œç”¨åŸŸæœ‰ä¸¤ç§è¿è¡Œæ¨¡å¼ï¼š</p>

<ol>
<li><strong>æ™®é€šæ¨¡å¼</strong> (<code>isKeepingExitedValues = false</code>)ï¼šå€¼ç¦»å¼€ç»„åˆæ—¶ä¼šè¢«ä¸¢å¼ƒï¼Œå°±åƒ <code>remember{}</code> ä¸€æ ·ã€‚</li>
<li><strong>ä¿ç•™æ¨¡å¼</strong> (<code>isKeepingExitedValues = true</code>)ï¼šå€¼é€€å‡ºæ—¶ä¼šè¢«ä¿ç•™ï¼Œä»¥ä¾¿å°†æ¥æ¢å¤ã€‚</li>
</ol>


<p>é‚£ä¹ˆï¼Œä¿ç•™ç”Ÿå‘½å‘¨æœŸæ˜¯å¦‚ä½•è¿ä½œçš„å‘¢ï¼Ÿé€šè¿‡åŸå§‹æºä»£ç ä¸­åµŒå…¥çš„å›¾è¡¨å¯ä»¥æœ€å¥½åœ°ç†è§£ä¿ç•™ç”Ÿå‘½å‘¨æœŸï¼š</p>

<pre><code class="bash">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      â”‚
â”‚ retain(keys) { ... } â”‚
â”‚        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¤  value: T  â”œâ”˜
         â””â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚   â–²
        Exitâ”‚   â”‚Enter
 compositionâ”‚   â”‚composition
   or changeâ”‚   â”‚
        keysâ”‚   â”‚                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚   â”œâ”€â”€â”€No retained valueâ”€â”€â”€â”€â”€â”¤   calculation: () -&gt; T   â”‚
            â”‚   â”‚   or different keys     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚   â”‚                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚   â””â”€â”€â”€Re-enter compositionâ”€â”€â”¤    Local RetainScope     â”‚
            â”‚       with the same keys    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                                           â–²   â”‚
            â”‚                      â”Œâ”€Yesâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ value not
            â”‚                      â”‚                        â”‚ restored and
            â”‚   .â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€.     â”‚ scope stops
            â””â”€â–¶(   RetainScope.isKeepingExitedValues   )    â”‚ keeping exited
                `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€'     â”‚ values
                                   â”‚                        â–¼
                                   â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                   â””â”€Noâ”€â”€â–¶â”‚     value is retired     â”‚
                                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>

<p>æ­¤æµç¨‹æ­ç¤ºäº†å‡ ä¸ªå…³é”®çš„è§è§£ï¼š</p>

<ol>
<li><strong>ä¿ç•™æ˜¯æœ‰æ¡ä»¶çš„</strong>ï¼šåªæœ‰å½“ <code>isKeepingExitedValues</code> ä¸º <code>true</code> æ—¶ï¼Œå€¼æ‰ä¼šè¢«ä¿ç•™ã€‚</li>
<li><strong>é”®å¾ˆé‡è¦</strong>ï¼šå³ä½¿åœ¨ä¿ç•™æœŸé—´ï¼Œæ›´æ”¹çš„é”®ä¹Ÿä¼šå¯¼è‡´ç«‹å³é€€å‡ºã€‚</li>
<li><strong>æ¢å¤æ˜¯è‡ªåŠ¨çš„</strong>ï¼šå½“å†…å®¹ä½¿ç”¨ç›¸åŒçš„é”®é‡æ–°è¾“å…¥æ—¶ï¼Œä¿ç•™çš„å€¼å°†è¢«æ¢å¤ã€‚</li>
<li><strong>é€€å‡ºæ˜¯æœ€ç»ˆçš„</strong>ï¼šä¿ç•™åœæ­¢æ—¶æœªæ¢å¤çš„å€¼å°†è¢«é€€å‡ºã€‚</li>
</ol>


<h2>ControlledRetainScopeï¼šå¯å˜å®ç°</h2>

<p>è™½ç„¶ <code>RetainScope</code> æä¾›äº†æŠ½è±¡ï¼Œä½† <code>ControlledRetainScope</code> æ‰æ˜¯ä¸»è¦çš„å®ç°ï¼š</p>

<pre><code class="kotlin">public class ControlledRetainScope : RetainScope() {
    private val keptExitedValues = SafeMultiValueMap&lt;Any, Any?&gt;()

    override fun saveExitingValue(key: Any, value: Any?) {
        keptExitedValues.add(key, value)
    }

    @Suppress("UNCHECKED_CAST")
    override fun getExitedValueOrDefault(key: Any, defaultIfAbsent: Any?): Any? {
        return keptExitedValues.removeLast(key, defaultIfAbsent)
    }

    override fun onStopKeepingExitedValues() {
        keptExitedValues.forEachValue { value -&gt;
            if (value is RetainObserver) value.onRetired()
        }
        keptExitedValues.clear()
    }
}
</code></pre>

<p>è¯¥å®ç°ä½¿ç”¨ <code>SafeMultiValueMap</code> è¿›è¡Œå­˜å‚¨æ˜¯ä¸€ä¸ªé‡è¦çš„è®¾è®¡é€‰æ‹©ã€‚ä¸ºä»€ä¹ˆï¼Ÿå› ä¸ºå¤šä¸ª retain è°ƒç”¨å¯ä»¥å…·æœ‰ç›¸åŒçš„é”®ï¼š</p>

<pre><code class="kotlin">@Composable
fun Example() {
    // Both have the same positional key!
    val value1 = retain { "First" }
    val value2 = retain { "Second" }
}
</code></pre>

<p>è¯¥æ˜ å°„æŒ‰ LIFOï¼ˆåè¿›å…ˆå‡ºï¼‰é¡ºåºå­˜å‚¨æ¯ä¸ªé”®çš„å€¼ã€‚æ¢å¤æ—¶ï¼Œ<code>removeLast()</code> ç¡®ä¿å€¼æŒ‰å…¶å­˜å‚¨çš„ç›¸åé¡ºåºæ¢å¤ï¼Œä»è€Œä¿æŒ retain è°ƒç”¨ä¸å…¶å€¼ä¹‹é—´çš„æ­£ç¡®é…å¯¹ã€‚</p>

<p>æ­¤å¤–ï¼Œ<code>ControlledRetainScope</code> æ”¯æŒåµŒå¥—åœ¨çˆ¶çº§ <code>RetainStateProvider</code> ä¸‹ï¼š</p>

<pre><code class="kotlin">public fun setParentRetainStateProvider(parent: RetainStateProvider) {
    val oldParent = parentScope
    parentScope = parent

    parent.addRetainStateObserver(parentObserver)
    oldParent.removeRetainStateObserver(parentObserver)

    if (parent.isKeepingExitedValues) startKeepingExitedValues()
    if (oldParent.isKeepingExitedValues) stopKeepingExitedValues()
}
</code></pre>

<p>è¿™æ”¯æŒæœ‰åºçš„å±‚æ¬¡ç»“æ„ï¼Œå…¶ä¸­å­ä½œç”¨åŸŸä»çˆ¶çº§ç»§æ‰¿ä¿ç•™çŠ¶æ€ã€‚ä½ å¯ä»¥åˆ©ç”¨æ­¤åŠŸèƒ½ä½¿æ‰€æœ‰ <code>RetainScopes</code> åœ¨é…ç½®æ›´æ”¹æœŸé—´ä¿ç•™ï¼Œæ ¹ä½œç”¨åŸŸä¼šæ£€æµ‹åˆ°é…ç½®æ›´æ”¹ï¼Œå¹¶æ²¿å±‚æ¬¡ç»“æ„å‘ä¸‹çº§è”ä¿ç•™ã€‚</p>

<h2>RetainObserverï¼šä¿ç•™å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸå›è°ƒ</h2>

<p>éœ€è¦äº†è§£å…¶ä¿ç•™ç”Ÿå‘½å‘¨æœŸçš„å¯¹è±¡éœ€è¦å®ç° <code>RetainObserver</code>ï¼š</p>

<pre><code class="kotlin">@Suppress("CallbackName")
public interface RetainObserver {
    public fun onRetained()

    // Successfully retained
    public fun onEnteredComposition() // Entered composition
    public fun onExitedComposition()  // Exited composition
    public fun onRetired()

    // No longer retained
    public fun onUnused()

    // Created but never used
}
</code></pre>

<p>è¿™äº›å›è°ƒå®ç°äº† <code>remember{}</code> æ— æ³•å®ç°çš„èµ„æºç®¡ç†æ¨¡å¼ã€‚è®¾æƒ³ä¸€ä¸ªåª’ä½“æ’­æ”¾å™¨ï¼Œå½“å±å¹•æœªæ˜¾ç¤ºæ—¶åº”è¯¥æš‚åœï¼Œä½†å¦‚æœå¯èƒ½å†æ¬¡æ˜¾ç¤ºï¼Œåˆ™ä¸åº”é‡Šæ”¾èµ„æºï¼š</p>

<pre><code class="kotlin">class RetainableMediaPlayer : RetainObserver {
    private var player: MediaPlayer? = null

    override fun onRetained() {
        player = MediaPlayer()
    }

    override fun onEnteredComposition() {
        player?.play()
    }

    override fun onExitedComposition() {
        player?.pause() // Just pause, don't release
    }

    override fun onRetired() {
        player?.release() // Now we can release
        player = null
    }

    override fun onUnused() {
        // Never entered composition, clean up
        player?.release()
        player = null
    }
}
</code></pre>

<p>è¿˜åº”è®°ä½ï¼Œå›è°ƒéµå¾ªä¸¥æ ¼çš„é¡ºåºä¿è¯ã€‚å½“å¤šä¸ª <code>RetainObserver</code> åŒæ—¶è¿›å…¥ç»„åˆçŠ¶æ€æ—¶ï¼Œå®ƒä»¬çš„ <code>onEnteredComposition</code> å›è°ƒå°†æŒ‰é¡ºåºè§¦å‘ã€‚é€€å‡ºæ—¶ï¼Œ<code>onExitedComposition</code> å°†æŒ‰ç›¸åé¡ºåºè§¦å‘<strong>ï¼Œ</strong>ä»¥ç¡®ä¿æ­£ç¡®æ¸…ç†åµŒå¥—èµ„æºã€‚</p>

<h2>RememberObserver é™åˆ¶</h2>

<p>ä½ å¯ä»¥åœ¨ <code>RetainedValueHolder</code> ä¸­æ‰¾åˆ°ä¸€ä¸ªæœ‰è¶£çš„å®‰å…¨æ£€æŸ¥ï¼š</p>

<pre><code class="kotlin">init {
    if (value is RememberObserver &amp;&amp; value !is RetainObserver) {
        throw IllegalArgumentException(
            "Retained a value that implements RememberObserver but not RetainObserver. " +
            "To receive the correct callbacks, the retained value '$value' must also " +
            "implement RetainObserver."
        )
    }
}
</code></pre>

<p>ä¸ºä»€ä¹ˆæœ‰è¿™ä¸ªé™åˆ¶ï¼Ÿ<code>RememberObserver</code> å›è°ƒï¼ˆ<code>onRemembered</code>ã€<code>onForgotten</code>ã€<code>onAbandoned</code>ï¼‰ä¸ä¿ç•™è¯­ä¹‰ä¸ä¸€è‡´ã€‚æš‚æ—¶è„±ç¦»ç»„åˆçš„ä¿ç•™å€¼ä¸ä¼šè¢«â€œé—å¿˜â€ï¼Œè€Œæ˜¯å¤„äºä¸ç¡®å®šçŠ¶æ€ï¼Œå¯èƒ½ä¼šå†æ¬¡è¿”å›ã€‚ä½¿ç”¨ <code>RememberObserver</code> ä¼šå¯¼è‡´é”™è¯¯çš„ç”Ÿå‘½å‘¨æœŸå›è°ƒï¼Œå› æ­¤åº“å¼ºåˆ¶ä½¿ç”¨ <code>RetainObserver</code>ã€‚</p>

<h2>RetainedEffectï¼šä¿ç•™åä»å­˜åœ¨çš„å‰¯ä½œç”¨</h2>

<p><code>RetainedEffect</code> å°†ä¿ç•™çš„æ¦‚å¿µæ‰©å±•åˆ°å‰¯ä½œç”¨ï¼š</p>

<pre><code class="kotlin">@Composable
public fun RetainedEffect(key1: Any?, effect: RetainedEffectScope.() -&gt; RetainedEffectResult) {
    retain(key1) { RetainedEffectImpl(effect) }
}

private class RetainedEffectImpl(
    private val effect: RetainedEffectScope.() -&gt; RetainedEffectResult
) : RetainObserver {
    private var onRetire: RetainedEffectResult? = null

    override fun onRetained() {
        onRetire = InternalRetainedEffectScope.effect()
    }

    override fun onRetired() {
        onRetire?.retire()
        onRetire = null
    }

    // Other callbacks are no-ops
}
</code></pre>

<p>å®ç°éå¸¸ç®€å•ï¼šå®ƒå°† effect åŒ…è£…åœ¨ä¸€ä¸ª <code>RetainObserver</code> ä¸­ï¼Œè¯¥ <code>RetainObserver</code> åœ¨ä¿ç•™æ—¶æ‰§è¡Œ effectï¼Œå¹¶åœ¨é€€å‡ºæ—¶è¿›è¡Œæ¸…ç†ã€‚ä¸ DisposableEffect ä¸åŒï¼ŒDisposableEffect åœ¨ç¦»å¼€ç»„åˆæ—¶è¿è¡Œå…¶å¤„ç½®ï¼Œè€Œ RetainedEffect ä»…åœ¨çœŸæ­£é€€å‡ºæ—¶å¤„ç½®ï¼š</p>

<pre><code class="kotlin">@Composable
fun VideoPlayer(mediaUri: String) {
    val player = retain(mediaUri) { MediaPlayer(mediaUri) }

    // DisposableEffect would dispose on every hide/show
    // RetainedEffect only disposes when truly done
    RetainedEffect(player) {
        player.initialize()
        onRetire {
            player.close() // Only called when player is retired
        }
    }
}
</code></pre>

<p>è¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„ä¾‹å­ï¼Œè¯´æ˜åœ¨çŸ­æš‚çš„ UI å˜åŒ–æœŸé—´ä¸åº”é‡æ–°åˆ›å»ºæ˜‚è´µçš„èµ„æºã€‚</p>

<h2>RetainedContentHost å’Œ RetainScopeHolder</h2>

<p><code>compose-runtime-retain</code> åº“æä¾›äº†åŸºäºè¿™äº›åŸè¯­æ„å»ºçš„æ›´é«˜çº§åˆ«çš„æŠ½è±¡ã€‚<code>RetainedContentHost</code> ç®¡ç†æ˜¾ç¤º/éšè—åœºæ™¯ï¼š</p>

<pre><code class="kotlin">@Composable
public fun RetainedContentHost(active: Boolean, content: @Composable () -&gt; Unit) {
    val retainScope = retainControlledRetainScope()
    if (active) {
        CompositionLocalProvider(LocalRetainScope provides retainScope, content)

        val composer = currentComposer
        DisposableEffect(retainScope) {
            val cancellationHandle =
                if (retainScope.keepExitedValuesRequestsFromSelf &gt; 0) {
                    composer.scheduleFrameEndCallback {
                        retainScope.stopKeepingExitedValues()
                    }
                } else {
                    null
                }

            onDispose {
                cancellationHandle?.cancel()
                retainScope.startKeepingExitedValues()
            }
        }
    }
}
</code></pre>

<p>è¯¥å®ç°æ­ç¤ºäº†ä¸€äº›æ—¶é—´æ§åˆ¶ï¼š</p>

<p><strong>å˜ä¸ºæ´»åŠ¨çŠ¶æ€</strong>ï¼šå®‰æ’åœ¨å¸§ç»“æŸæ—¶åœæ­¢ä¿ç•™ï¼Œç¡®ä¿æ‰€æœ‰å†…å®¹éƒ½é¦–å…ˆæ¢å¤å…¶å€¼ã€‚</p>

<p><strong>å˜ä¸ºéæ´»åŠ¨çŠ¶æ€</strong>ï¼šåœ¨å†…å®¹è¢«ç§»é™¤ä¹‹å‰ç«‹å³å¼€å§‹ä¿ç•™ã€‚</p>

<p>è¿™ç¡®ä¿äº†å€¼åœ¨éœ€è¦æ—¶è¢«å‡†ç¡®ä¿ç•™ï¼Œä¸ä¼šå¤ªæ—©ï¼ˆè¿™ä¼šé˜»æ­¢æ¢å¤ï¼‰ï¼Œä¹Ÿä¸ä¼šå¤ªæ™šï¼ˆè¿™ä¼šä¸¢å¤±å€¼ï¼‰ã€‚</p>

<p>å¯¹äºåˆ—è¡¨ç­‰åŠ¨æ€å†…å®¹ï¼Œ<code>RetainScopeHolder</code> è´Ÿè´£ç®¡ç†æ¯ä¸ªé¡¹ç›®çš„ä¿ç•™ï¼š</p>

<pre><code class="kotlin">public class RetainScopeHolder() {
    private val childScopes = MutableScatterMap&lt;Any?, ControlledRetainScope&gt;()

    public fun getOrCreateRetainScopeForChild(key: Any?): RetainScope {
        return childScopes.getOrPut(key) {
            ControlledRetainScope().apply {
                if (isParentKeepingExitedValues) startKeepingExitedValues()
            }
        }
    }

    @Composable
    public fun RetainScopeProvider(key: Any?, content: @Composable () -&gt; Unit) {
        CompositionLocalProvider(
            LocalRetainScope provides getOrCreateRetainScopeForChild(key)
        ) {
            content()
            PresenceIndicator(key)
        }
    }

    @Composable
    private fun PresenceIndicator(key: Any?) {
        val composer = currentComposer
        DisposableEffect(key) {
            val endRetainHandle =
                if (keepExitedValuesRequestsFor(key) &gt; 0) {
                    composer.scheduleFrameEndCallback {
                        stopKeepingExitedValues(key)
                    }
                } else {
                    null
                }
            onDispose {
                endRetainHandle?.cancel()
                startKeepingExitedValues(key)
            }
        }
    }
}
</code></pre>

<p><code>PresenceIndicator</code> å¯ç»„åˆé¡¹æ˜¯ä¸€ç§å·§å¦™çš„æ¨¡å¼ã€‚å®ƒæŒ‰ç»„åˆé¡ºåºæ”¾ç½®åœ¨å†…å®¹<strong>ä¹‹å</strong>ï¼Œä»¥ç¡®ä¿æ­£ç¡®çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€‚ç§»é™¤æ—¶ï¼Œå®ƒä¼šè§¦å‘ä¿ç•™ã€‚æ·»åŠ æ—¶ï¼Œå®ƒä¼šå®‰æ’åœ¨å¸§å®Œæˆååœæ­¢ä¿ç•™ã€‚</p>

<h2>å†…å­˜å’Œæ€§èƒ½è€ƒé‡</h2>

<p>è¯¥å®ç°ä¸­è¿›è¡Œäº†å€¼å¾—ç†è§£çš„æƒè¡¡ï¼š</p>

<p><strong>å†…å­˜ä¼˜å…ˆäº CPU</strong>ï¼šä¿ç•™å€¼åœ¨å†…å­˜ä¸­ä¿ç•™çš„æ—¶é—´æ¯” <code>remember{}</code> æ›´é•¿ã€‚è¿™ç”¨å†…å­˜æ¢å–äº†é‡æ–°åˆ›å»ºæ—¶çš„ CPU å¼€é”€ã€‚å¯¹äºå¼€é”€è¾ƒå¤§çš„å¯¹è±¡ï¼ˆä¾‹å¦‚ä½å›¾ã€åª’ä½“æ’­æ”¾å™¨ï¼‰ï¼Œè¿™é€šå¸¸æ˜¯å€¼å¾—çš„ã€‚</p>

<p><strong>O(n) èŒƒå›´æ“ä½œ</strong>ï¼šæŸ¥æ‰¾è¦æ¢å¤æˆ–é€€å‡ºçš„å€¼éœ€è¦è¿­ä»£å­˜å‚¨çš„å€¼ã€‚å¯¹äºåŒ…å«æ•°åä¸ªä¿ç•™å€¼çš„å…¸å‹ç”¨ä¾‹ï¼Œè¿™å¯ä»¥å¿½ç•¥ä¸è®¡ã€‚</p>

<p><strong>æƒ°æ€§åˆ†é…</strong>ï¼šä»…åœ¨éœ€è¦æ—¶åˆ†é…ç¼“å†²åŒºå’Œå­˜å‚¨ç©ºé—´ã€‚æœªä½¿ç”¨çš„ <code>RetainScope</code> å¼€é”€æå°ã€‚</p>

<p><strong>é€šè¿‡å…·ä½“åŒ–å®ç°ç±»å‹å®‰å…¨</strong>ï¼šå†…è”/å…·ä½“åŒ–æ¨¡å¼æ¶ˆé™¤äº†è¿è¡Œæ—¶ç±»å‹æ£€æŸ¥çš„éœ€è¦ï¼ŒåŒæ—¶ä¿æŒäº†ç±»å‹å®‰å…¨ã€‚</p>

<p><strong>é»˜è®¤ä¸ºç»„åˆèŒƒå›´</strong>ï¼šä¸ ViewModelï¼ˆåº”ç”¨èŒƒå›´ï¼‰æˆ– rememberSaveableï¼ˆActivityèŒƒå›´ï¼‰ä¸åŒï¼Œretain æ˜¯ç»„åˆèŒƒå›´çš„ï¼Œå¯ä»¥å¯¹ä¿ç•™è¾¹ç•Œè¿›è¡Œç»†ç²’åº¦çš„æ§åˆ¶ã€‚</p>

<p>å¦å¤–ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¸è¦å°†é•¿æœŸå­˜æ´»çš„å¯¹è±¡ä¿ç•™åœ¨å…¶é¢„æœŸä½œç”¨åŸŸä¹‹å¤–ï¼Œä»¥å…é€ æˆå†…å­˜æ³„æ¼ï¼Œæ­£å¦‚ Compose åº“ä¸­çš„ä»¥ä¸‹æ³¨é‡Šæ‰€ç¤ºã€‚</p>

<pre><code class="kotlin">/**
 * é‡è¦æç¤ºï¼šä¿ç•™å€¼çš„ä¿å­˜æ—¶é—´æ¯”å…¶æ‰€å…³è”çš„å¯ç»„åˆé¡¹çš„ç”Ÿå‘½å‘¨æœŸé•¿ã€‚
 * å¦‚æœä¿ç•™å¯¹è±¡çš„ä¿å­˜æ—¶é—´è¶…è¿‡å…¶é¢„æœŸçš„
 * ç”Ÿå‘½å‘¨æœŸï¼Œåˆ™å¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼ã€‚è¯·è°¨æ…é€‰æ‹©ä¿ç•™çš„æ•°æ®ç±»å‹ã€‚åˆ‡å‹¿ä¿ç•™ Android ä¸Šä¸‹æ–‡æˆ–
 * ç›´æ¥æˆ–é—´æ¥å¼•ç”¨ä¸Šä¸‹æ–‡ï¼ˆåŒ…æ‹¬è§†å›¾ï¼‰çš„å¯¹è±¡ã€‚
 */
</code></pre>

<h2>æµ‹è¯•ä¿ç•™æœºåˆ¶</h2>

<p>ä¸€ä¸ªæœ‰è¶£çš„<a href="https://github.com/androidx/androidx/blob/942319dfe9d751390febcef640d43290886f1a0b/compose/runtime/runtime-retain/src/commonTest/kotlin/androidx/compose/runtime/retain/RetainTests.kt#L866">å†…éƒ¨å•å…ƒæµ‹è¯•ç”¨ä¾‹</a> è¡¨æ˜ï¼Œè¯¥åº“å¯ä»¥å¤„ç†è¾¹ç¼˜æƒ…å†µå¹¶ä¿è¯ï¼š</p>

<pre><code class="kotlin">@Test
fun retain_duplicateRetainKeys() = compositionTest {
    val scope = ControlledRetainScope().apply { startKeepingExitedValues() }
    var showContent = true

    compose {
        CompositionLocalProvider(value = LocalRetainScope provides scope) {
            if (showContent) {
                // All have same key!
                retain { CountingRetainObject() }
                retain { CountingRetainObject() }
                retain { CountingRetainObject() }
            }
        }
    }

    // Hide and show content
    showContent = false
    recomposeScope.invalidate()
    advance()

    showContent = true
    recomposeScope.invalidate()
    advance()

    // All values correctly restored despite duplicate keys
}
</code></pre>

<p>æµ‹è¯•éªŒè¯äº†å³ä½¿å­˜åœ¨é‡å¤çš„é”®ï¼ˆåœ¨å¾ªç¯æˆ–ç”Ÿæˆçš„å†…å®¹ä¸­å¾ˆå¸¸è§ï¼‰ï¼Œå€¼ä¹Ÿèƒ½é€šè¿‡åè¿›å…ˆå‡º (LIFO) é¡ºåºä¸å…¶ä¿ç•™è°ƒç”¨æ­£ç¡®é…å¯¹ã€‚</p>

<h2>ç»“è®º</h2>

<p>åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬æ¢ç´¢äº† <code>retain{}</code>ã€<code>RetainScope</code>ã€<code>RetainObserver</code> å’Œ <code>RetainedEffect</code> API çš„å·¥ä½œåŸç†åŠå…¶å†…éƒ¨æœºåˆ¶ã€‚äº†è§£è¿™äº›å†…éƒ¨æœºåˆ¶æœ‰åŠ©äºæˆ‘ä»¬æ›´å¥½åœ°å†³å®šä½•æ—¶ä½¿ç”¨ <code>retain{}</code>ã€<code>remember{}</code> å’Œ <code>rememberSaveable{}</code>ï¼Œå¦‚ä½•æ„å»ºä¿ç•™èµ„æºï¼Œä»¥åŠé¢„æœŸçš„æ€§èƒ½ç‰¹å¾ã€‚</p>

<p>æ— è®ºæ˜¯æ„å»ºå¯æ—‹è½¬çš„è§†é¢‘æ’­æ”¾å™¨ã€ä¿ç•™æ»šåŠ¨ä½ç½®çš„å¯¼èˆªç³»ç»Ÿï¼Œè¿˜æ˜¯åœ¨é…ç½®æ›´æ”¹åä¿æŒçŠ¶æ€çš„å¤æ‚è¡¨å•ï¼Œ<code>retain{}</code> éƒ½èƒ½åœ¨ Jetpack Compose ä¸­æä¾›åŸºäºä½œç”¨åŸŸçš„çŠ¶æ€ä¿å­˜åŠŸèƒ½ã€‚</p>

<p>å¦‚æœä½ æƒ³äº†è§£æœ€æ–°çš„æŠ€èƒ½ã€æ–°é—»ã€æŠ€æœ¯æ–‡ç« ã€é¢è¯•é—®é¢˜å’Œå®ç”¨ä»£ç æŠ€å·§ï¼Œè¯·æŸ¥çœ‹ <a href="https://github.com/doveletter/">Dove Letter</a>ã€‚å¦‚æœä½ æƒ³æ·±å…¥äº†è§£é¢è¯•å‡†å¤‡ï¼Œåƒä¸‡ä¸è¦é”™è¿‡ç»ˆæ Android é¢è¯•æŒ‡å—ï¼š<a href="https://www.android.skydoves.me/">Manifest Android Interview</a>ã€‚</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compose Unstyledï¼šCompose UIä¸­å¤±ä¼ â€‹â€‹çš„è®¾è®¡ç³»ç»Ÿå±‚]]></title>
    <link href="https://alexhilton.github.io/blog/2025/09/10/compose-unstyled/"/>
    <updated>2025-09-10T16:17:33+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/09/10/compose-unstyled</id>
    <content type="html"><![CDATA[<blockquote><p>æœ¬æ–‡è¯‘è‡ªã€ŒCompose Unstyled: The missing Design System layer for Compose UIã€ï¼ŒåŸæ–‡é“¾æ¥<a href="https://composables.com/blog/introducing-compose-unstyled">https://composables.com/blog/introducing-compose-unstyled</a>ï¼Œç”±Alex Stylå‘å¸ƒäº2025å¹´8æœˆ7æ—¥ã€‚</p></blockquote>

<p><a href=""><img src="https://composables.com/og_unstyled.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>ä½¿ç”¨ Compose UI æ„å»ºåº”ç”¨çš„æœ€å¤§é—®é¢˜æ˜¯ Material Compose çš„çµæ´»æ€§ä¸è¶³ã€‚Material Compose çš„å¯å®šåˆ¶æ€§ä¸è¶³ä»¥è®©ä½ åœ¨å…¶ä¸Šæ„å»ºè‡ªå·±çš„è®¾è®¡ç³»ç»Ÿï¼Œå› æ­¤ä½ æœ€ç»ˆåªèƒ½å¯¹å…¶ç»„ä»¶è¿›è¡Œä¿®æ”¹ã€‚å¦ä¸€æ–¹é¢ï¼ŒCompose Foundation åˆè¿‡äºâ€œåŸå§‹â€â€”â€”å®ƒæœ‰è¡Œå’Œåˆ—ï¼Œä½†æ²¡æœ‰æŒ‰é’®æˆ–åº•éƒ¨è¡¨å•ã€‚è€Œä¸”ï¼Œç”±äºä¸»é¢˜è®¾ç½®ä¸ Material ç»‘å®šï¼Œå¦‚æœä¸å®Œå…¨éµå¾ª Material çš„è®¾è®¡å†³ç­–ï¼Œä½ ç”šè‡³æ— æ³•ä¸ºä½ çš„åº”ç”¨è®¾ç½®ä¸»é¢˜ã€‚</p>

<p>ä½ å¯ä»¥ä»å¤´å¼€å§‹æ„å»ºæ‰€æœ‰å†…å®¹ï¼Œä½†è°æœ‰æ—¶é—´è¿™æ ·åšå‘¢ï¼Ÿè€ƒè™‘åˆ°ä¸åŒçš„çŠ¶æ€ã€å¯è®¿é—®æ€§å’Œè¾¹ç¼˜æƒ…å†µï¼Œåƒåº•éƒ¨è¡¨å•è¿™æ ·çš„å•ä¸ªç»„ä»¶å¯èƒ½éœ€è¦ 3-4 å‘¨æ‰èƒ½å®Œæˆã€‚è¿™ä¸ªé—®é¢˜åœ¨ Compose Multiplatform ä¸­å˜å¾—æ›´åŠ ä¸¥é‡â€”â€”Material åœ¨ iOS ä¸Šçœ‹èµ·æ¥ç¬¨æ‹™ï¼Œåœ¨æ¡Œé¢ä¸Šæ˜¾å¾—ä¸æˆæ¯”ä¾‹ã€‚</p>

<p>æˆ‘éœ€è¦ä¸€ä¸ªçµæ´»çš„è§£å†³æ–¹æ¡ˆï¼Œå¯ä»¥åœ¨ä»»ä½•å¹³å°ä¸Šä½¿ç”¨ï¼Œè€Œä¸å— Material çš„é™åˆ¶ã€‚äºæ˜¯æˆ‘æ’¸èµ·è¢–å­ï¼Œè‡ªå·±åŠ¨æ‰‹æ„å»ºäº†ä¸€ä¸ªï¼š</p>

<p><strong><a href="https://composables.com/docs/com.composables/core">Compose Unstyled</a> æ˜¯åŸºäº Compose Foundation çš„ APIï¼Œå¯è½»æ¾æ„å»ºä»»ä½•è®¾è®¡ç³»ç»Ÿ</strong> ï¼ˆé“¾æ¥ï¼š<a href="https://composables.com/docs/com.composables/core%EF%BC%89%E3%80%82%E5%AE%83%E6%8F%90%E4%BE%9B%E6%97%A0%E6%A0%B7%E5%BC%8F%E3%80%81%E5%8F%AF%E8%AE%BF%E9%97%AE%E7%9A%84%E7%BB%84%E4%BB%B6%EF%BC%8C%E5%B9%B6%E9%85%8D%E6%9C%89%E7%81%B5%E6%B4%BB%E7%9A%84%E4%B8%BB%E9%A2%98">https://composables.com/docs/com.composables/core%EF%BC%89%E3%80%82%E5%AE%83%E6%8F%90%E4%BE%9B%E6%97%A0%E6%A0%B7%E5%BC%8F%E3%80%81%E5%8F%AF%E8%AE%BF%E9%97%AE%E7%9A%84%E7%BB%84%E4%BB%B6%EF%BC%8C%E5%B9%B6%E9%85%8D%E6%9C%89%E7%81%B5%E6%B4%BB%E7%9A%84%E4%B8%BB%E9%A2%98</a> APIâ€”â€”æ‰€æœ‰å…³äºç”¨æˆ·ä½“éªŒå’Œå¯è®¿é—®æ€§çš„ç¹çå·¥ä½œéƒ½å·²ä¸ºä½ å¤„ç†ã€‚</p>

<p>Unstyled ä¸­çš„ç»„ä»¶å®Œå…¨æ— éœ€æ¸²æŸ“ï¼Œé»˜è®¤æƒ…å†µä¸‹ä¸ä¼šåœ¨å±å¹•ä¸Šæ˜¾ç¤ºä»»ä½•å†…å®¹ã€‚ä½ å¯ä»¥å°†å®ƒä»¬è§†ä¸ºâ€œç»„ä»¶æ¨¡å¼â€ï¼Œå®ƒä»¬å°†â€œåº•éƒ¨è¡¨å•â€æˆ–â€œè¿›åº¦æ¡â€çš„æ¦‚å¿µå¼•å…¥ä½ çš„åº”ç”¨ï¼Œè€Œæ— éœ€ä½ æ‹…å¿ƒç”¨æˆ·ä½“éªŒã€é”®ç›˜å¯¼èˆªæˆ–å¯è®¿é—®æ€§å®ç°ã€‚åªéœ€æ·»åŠ æ ·å¼å³å¯ã€‚</p>

<h2>ç®€æ´çš„ APIï¼Œæä¾›ä½ æ‰€éœ€çš„æ ·å¼</h2>

<p>Compose Unstyled ä¸æä¾›ä»»ä½•ç‰¹æ®Šçš„æ ·å¼ APIã€‚æ‰€æœ‰æ“ä½œéƒ½é€šè¿‡ <code>Modifier</code> å®Œæˆã€‚å¦‚æœä½ çŸ¥é“å¦‚ä½•è®¾ç½® <code>Box()</code> çš„æ ·å¼ï¼Œé‚£ä¹ˆä½ å°±çŸ¥é“å¦‚ä½•è®¾ç½® Compose Unstyled ä¸­æ¯ä¸ªç»„ä»¶çš„æ ·å¼ã€‚</p>

<p>ä¸‹é¢æ˜¯ä¸€ä¸ªä½¿ç”¨ Compose Unstyled æ„å»ºæ¨¡æ€åº•éƒ¨è¡¨å•çš„ç®€å•ç¤ºä¾‹ï¼Œå…¶ä¸­åŒ…å«è‡ªå®šä¹‰å®šä½ç‚¹ï¼ˆè¡¨å•åœ¨å±å¹•ä¸Šâ€œåœç•™â€çš„ä½ç½®ï¼‰ä»¥åŠä½ é€‰æ‹©çš„æ ·å¼ï¼š</p>

<pre><code class="kotlin">val Peek = SheetDetent("peek") { containerHeight, sheetHeight -&gt;
    containerHeight * 0.6f
}
BoxWithConstraints(modifier = Modifier.fillMaxSize().background(Brush.linearGradient(listOf(Color(0xFF800080), Color(0xFFDA70D6))))) {
    val modalSheetState = rememberModalBottomSheetState(
        initialDetent = Hidden,
        detents = listOf(Hidden, Peek, FullyExpanded)
    )
    LaunchedEffect(Unit) {
        delay(50)
        modalSheetState.targetDetent = Peek
    }
    Button(onClick = { modalSheetState.targetDetent = Peek }, modifier = Modifier.align(Alignment.Center).padding(WindowInsets.navigationBars.only(WindowInsetsSides.Horizontal).asPaddingValues()), shape = RoundedCornerShape(6.dp), contentPadding = PaddingValues(horizontal = 14.dp, vertical = 10.dp), backgroundColor = Color.White) {
        Text("Show Sheet", fontWeight = FontWeight(500))
    }
    val isCompact = maxWidth &lt; 600.dp
    ModalBottomSheet(state = modalSheetState) {
        Scrim(
            scrimColor = Color.Black.copy(0.3f),
            enter = fadeIn(),
            exit = fadeOut()
        )
        Box(Modifier.fillMaxSize().padding(top = 12.dp).let { if (isCompact) it else it.padding(horizontal = 56.dp) }.displayCutoutPadding().statusBarsPadding().padding(WindowInsets.navigationBars.only(WindowInsetsSides.Horizontal).asPaddingValues())) {
            Sheet(
                modifier = Modifier
                    .shadow(4.dp, RoundedCornerShape(topStart = 28.dp, topEnd = 28.dp))
                    .widthIn(max = 640.dp)
                    .fillMaxWidth(),
                shape = RoundedCornerShape(topStart = 28.dp, topEnd = 28.dp),
                backgroundColor = Color.White,
                contentColor = Color.Black
            ) {
                Box(Modifier.fillMaxWidth().height(600.dp), contentAlignment = Alignment.TopCenter) {
                    DragIndication(
                        modifier = Modifier.padding(top = 22.dp)
                            .background(Color.Black.copy(0.4f), RoundedCornerShape(100)).width(32.dp).height(4.dp)
                    )
                }
            }
        }
    }
}
</code></pre>

<p>ç°åœ¨ï¼Œæˆ‘çŸ¥é“ä½ å¯èƒ½ä¼šæƒ³ã€‚â€œAlexï¼è¿™ API çœŸå¥‡æ€ªã€‚ä¸ºä»€ä¹ˆæˆ‘éœ€è¦ä¸€ä¸ª <code>ModalBottomSheet</code> å’Œä¸€ä¸ª <code>Sheet</code>ï¼Ÿä¸ºä»€ä¹ˆä¸ç›´æ¥ç”¨ Slots å‘¢ï¼Ÿâ€</p>

<p>è¿™ä¸ªè®¾è®¡é€‰æ‹©æ˜¯ç»è¿‡æ·±æ€ç†Ÿè™‘çš„ï¼š</p>

<h2>è®¾è®¡ç†å¿µ</h2>

<p>Compose Unstyled ä¸ä¼šæ›¿ä½ åšå‡ºä»»ä½•è®¾è®¡å†³ç­–ï¼Œè€Œæ˜¯è®©ä½ å®Œå…¨æŒæ§å¸ƒå±€ã€‚äº‹å®ä¸Šï¼Œå¦‚æœä½ è¢«è¿«ä½¿ç”¨æ— æ³•æ ¹æ®éœ€æ±‚æ›´æ”¹çš„æ ·å¼ï¼Œåˆ™ä¼šè¢«è§†ä¸ºé”™è¯¯ï¼ˆè¯·æäº¤ GitHub é—®é¢˜ï¼Œä»¥ä¾¿æˆ‘è¿›è¡Œè°ƒæŸ¥ï¼‰ã€‚</p>

<p>ä¾‹å¦‚ï¼Œä½ å¯èƒ½å¸Œæœ›å°†åº•éƒ¨è¡¨å•æ”¾ç½®åœ¨å±å¹•çš„å·¦ä¾§æˆ–å³ä¾§ã€‚å½“ä½ æƒ³è¦æ±‚å¼€å‘è€…æä¾›ä¸€ä¸ªåœ¨å¸ƒå±€ä¸Šå…·æœ‰ä¸¥æ ¼ä½ç½®çš„ç»„ä»¶æ—¶ï¼ŒåŸºäºæ’æ§½çš„ API éå¸¸å®ç”¨ã€‚</p>

<p>åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä½ å¯ä»¥å°† <code>ModalBottomSheet</code> ç»„ä»¶è§†ä¸ºè¡¨å•å¯ä»¥ç§»åŠ¨çš„åŒºåŸŸã€‚<code>Sheet</code> æ˜¯ç”¨æˆ·å¯ä»¥ä¸ä¹‹äº¤äº’çš„å®é™…è¡¨å•ã€‚é€šè¿‡æä¾›è¿™æ ·çš„ç»„ä»¶ï¼Œå®ƒä¸ºå¼€å‘è€…æä¾›äº†æ¸…æ™°çš„ APIï¼Œå¹¶æ¸…æ¥šåœ°è¯´æ˜äº†ç»„ä»¶çš„åŠŸèƒ½ã€‚ä¾‹å¦‚ï¼Œ<code>Scrim()</code> ç»„ä»¶å…·æœ‰ <em>enter</em> å’Œ <em>exit</em> è¿‡æ¸¡å‚æ•°ã€‚ Compose Unstyled ä¼šåœ¨æ°å½“çš„æ—¶æœºä¸ºçº±å¹•æ·»åŠ å’Œéšè—åŠ¨ç”»ï¼Œä»¥å®ç°æœ€ä½³ç”¨æˆ·ä½“éªŒã€‚ä½ åªéœ€æŒ‡å®šâ€œå¦‚ä½•â€å®ç°å³å¯ã€‚</p>

<p>ç”±äº Compose Unstyled åœ¨å¤–è§‚æ–¹é¢éå¸¸å¼€æ”¾ï¼Œå› æ­¤ä¸åŸå§‹çš„ Compose Foundation ç»„ä»¶ç›¸æ¯”ï¼Œå®ƒæ²¡æœ‰ä»»ä½•å¹³å°é™åˆ¶ã€‚Foundation ä¸­çš„â€œå¯¹è¯æ¡†â€å…·æœ‰å›ºå®šçš„æœ€å¤§å°ºå¯¸ï¼Œè¿™ä½¿å¾—å®ƒä»¬åœ¨è¯¸å¦‚å…¨å±å¯¹è¯æ¡†ç­‰æƒ…å†µä¸‹éš¾ä»¥å·¥ä½œã€‚</p>

<p>Compose Unstyled ä¸­çš„æ‰€æœ‰ç»„ä»¶åœ¨æ‰€æœ‰å¹³å°ä¸Šçš„å·¥ä½œæ–¹å¼å®Œå…¨ç›¸åŒã€‚è¿™æ˜¯æœ‰æ„ä¸ºä¹‹ï¼Œå› ä¸ºæ­¤ç±»å†³ç­–åº”è¯¥å±äºè®¾è®¡ç³»ç»Ÿå±‚çš„ä¸€éƒ¨åˆ†ã€‚å°½ç®¡è¿™ä¼šç»™å¼€å‘è€…å¸¦æ¥æ›´å¤šè´Ÿæ‹…ï¼Œä½†ç”±äºæ²¡æœ‰â€œé™·é˜±â€ï¼Œå®ƒå¤§å¤§ç¼©çŸ­äº†å¼€å‘æ—¶é—´ã€‚ç»„ä»¶çš„æ ·å¼ä¸ä½ æè¿°çš„å®Œå…¨ä¸€è‡´ã€‚</p>

<p>è¿™ä¸ä¼šä½¿ Compose Unstyled ä¸åº•å±‚å¹³å°è„±èŠ‚ã€‚åœ¨ä½¿ç”¨å¯¹è¯æ¡†å’Œæ¨¡æ€åº•éƒ¨èœå•ç­‰æ¨¡æ€çª—å£æ—¶ï¼Œè®¾ç½®ç³»ç»Ÿçª—å£çš„æ ·å¼æ˜¯ Android æ ·å¼è®¾ç½®çš„é‡è¦ç»„æˆéƒ¨åˆ†ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒCompose Unstyled æä¾›äº†ä¸€ä¸ª <code>LocalModalWindow</code> ç»„åˆæœ¬åœ°æ¥å£ï¼Œå…è®¸ä½ è®¿é—®æ¸²æŸ“æ¨¡æ€çª—å£çš„ <code>Window</code>ã€‚è¯·æ³¨æ„ï¼Œæ­¤ç±» API ä»…é€‚ç”¨äº Android ç›®æ ‡å¹³å°ï¼Œä¸å±äºé€šç”¨ç›®æ ‡å¹³å° APIã€‚</p>

<p>æœ€åï¼Œæ¯ä¸ªç»„ä»¶çš„ä»£ç éƒ½åŒ…å«åœ¨å…¶è‡ªå·±çš„æ–‡ä»¶ä¸­ï¼Œå³ä½¿ä½ ä¸æ˜¯ Compose ä¸“å®¶ï¼Œä¹Ÿèƒ½è½»æ¾ç†è§£ã€‚ä½ æ— éœ€æ‹…å¿ƒä»»ä½•é™åˆ¶ã€‚å¦‚æœä½ ç°åœ¨éœ€è¦æ›´æ”¹æŸäº›å†…å®¹ï¼Œå¹¶ä¸”è¿«ä¸åŠå¾…åœ°æƒ³è¦æäº¤é”™è¯¯å¹¶åœ¨åº“çº§åˆ«ä¿®å¤å®ƒï¼Œä½ åªéœ€å°†ç»„ä»¶çš„å•ä¸ªæ–‡ä»¶å¤åˆ¶ç²˜è´´åˆ°ä½ çš„ä»£ç åº“ä¸­å³å¯ã€‚è¿™ä¸ºä½ èŠ‚çœäº†é€šå¸¸éœ€è¦ä½ è‡ªå·±å®Œæˆçš„ 4 å‘¨å·¥ä½œæ—¶é—´ã€‚</p>

<h2>æ»‘å—</h2>

<p>ä»¥ä¸‹æ˜¯å¦‚ä½•æ„å»ºä¸€ä¸ªå…·æœ‰ä½ æ‰€é€‰æ ·å¼çš„æ»‘å—ã€‚</p>

<p>å®ƒä¸ Compose çš„â€œInteractionStateâ€é›†æˆï¼Œä»¥ä¾¿ä½ å¯ä»¥æŒ‰ç…§è‡ªå·±æƒ³è¦çš„æ–¹å¼å®Œå–„ç»„ä»¶ã€‚é”®ç›˜äº¤äº’åŠŸèƒ½å¼€ç®±å³ç”¨ï¼Œç”¨æˆ·å¯ä»¥é€šè¿‡æŒ‰ä¸‹é”®ç›˜ä¸Šçš„â€œå‘ä¸Šâ€æˆ–â€œå‘ä¸‹â€é”®æ¥å¢åŠ æˆ–å‡å°‘å€¼ï¼š</p>

<p><img src="file:///Users/alexhilton/Downloads/compose-style-1.png" alt="" /></p>

<pre><code class="kotlin">Box(modifier = Modifier.fillMaxSize().background(Brush.linearGradient(listOf(Color(0xFFED213A), Color(0xFF93291E)))),   contentAlignment = Alignment.Center) {
    val interactionSource = remember { MutableInteractionSource() }
    val isFocused by interactionSource.collectIsFocusedAsState()
    val isPressed by interactionSource.collectIsPressedAsState()
    val state = rememberSliderState(initialValue = 0.7f)
    Row(verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(12.dp), modifier = Modifier.padding(horizontal = 16.dp).widthIn(max = 480.dp).fillMaxWidth()) {
        Button(onClick = { state.value -= 0.1f }, modifier = Modifier.shadow(4.dp, CircleShape), shape = CircleShape, backgroundColor = Color.White, contentPadding = PaddingValues(8.dp),) {
            Icon(VolumeDown, "Decrease")
        }
        Slider(
            interactionSource = interactionSource,
            state = state,
            modifier = Modifier.weight(1f),
            track = {
                Box(Modifier.fillMaxWidth().height(8.dp).padding(horizontal = 16.dp).clip(RoundedCornerShape(100.dp))) {
                    // the 'not yet completed' part of the track
                    Box(Modifier.fillMaxHeight().fillMaxWidth().background(Color(0xFF93291E)))
                    // the 'completed' part of the track
                    Box(Modifier.fillMaxHeight().fillMaxWidth(state.value).background(Color.White))
                }
            },
            thumb = {
                val thumbSize by animateDpAsState(targetValue = if (isPressed) 22.dp else 18.dp)
                val thumbInteractionSource = remember { MutableInteractionSource() }
                val isHovered by thumbInteractionSource.collectIsHoveredAsState()
                val glowColor by animateColorAsState(
                    if (isFocused || isHovered) Color.White.copy(0.33f) else Color.Transparent
                )
                // keep the size fixed to ensure that the resizing animation is always centered
                Box(
                    modifier = Modifier.size(36.dp).clip(CircleShape).background(glowColor),
                    contentAlignment = Alignment.Center
                ) {
                    Thumb(
                        color = Color.White,
                        modifier = Modifier.size(thumbSize).shadow(4.dp, CircleShape).hoverable(thumbInteractionSource),
                        shape = CircleShape,
                    )
                }
            }
        )
        Button(onClick = { state.value += 0.1f }, modifier = Modifier.shadow(4.dp, CircleShape), shape = CircleShape, backgroundColor = Color.White, contentPadding = PaddingValues(8.dp),) {
            Icon(VolumeUp, "Increase")
        }
    }
}
</code></pre>

<h2>ä¸‹æ‹‰èœå•</h2>

<p>ä¸‹æ‹‰èœå•çš„æ­£ç¡®å®ç°éå¸¸å¤æ‚ï¼Œå°¤å…¶æ˜¯åœ¨é”®ç›˜å¯¼èˆªå’Œç„¦ç‚¹ç®¡ç†æ–¹é¢ã€‚</p>

<p>è¦å……åˆ†ä½“éªŒæ­¤ç»„ä»¶ï¼Œè¯·åœ¨æ¡Œé¢ä¸Šè¯•ç”¨ï¼šç‚¹å‡»â€œOptionsâ€æŒ‰é’®ä»¥èšç„¦æ¼”ç¤ºï¼Œç„¶åä½¿ç”¨é”®ç›˜çš„ä¸Šä¸‹ç®­å¤´é”®è¿›è¡Œå¯¼èˆªï¼š</p>

<p><img src="file:///Users/alexhilton/Downloads/compose-style-2.png" alt="" /></p>

<pre><code class="kotlin">class DropdownOption(val text: String, val icon: ImageVector, val enabled: Boolean = true, val dangerous: Boolean = false)
val options = listOf(
    DropdownOption("Select All", Maximize),
    DropdownOption("Copy", Copy),
    DropdownOption("Cut", Scissors, enabled = false),
    DropdownOption("Paste", Clipboard),
    DropdownOption("Delete", Trash2, dangerous = true),
)
var expanded by remember { mutableStateOf(true) }
DropdownMenu(onExpandRequest = { expanded = true }) {
    Button(shape = RoundedCornerShape(6.dp), backgroundColor = Color.White, onClick = { expanded = true }, contentPadding = PaddingValues(horizontal = 14.dp, vertical = 10.dp),) {
        Text("Options", fontWeight = FontWeight(500))
        Spacer(Modifier.width(8.dp))
        Icon(ChevronDown, null)
    }
    DropdownMenuPanel(
        expanded = expanded,
        onDismissRequest = { expanded = false },
        backgroundColor = Color.White,
        shape = RoundedCornerShape(8.dp),
        modifier = Modifier
            .padding(vertical = 4.dp)
            .width(240.dp)
            .shadow(4.dp, RoundedCornerShape(8.dp)),
        enter = scaleIn(
            animationSpec = tween(durationMillis = 120, easing = LinearOutSlowInEasing),
            initialScale = 0.8f,
            transformOrigin = TransformOrigin(0f, 0f)
        ) + fadeIn(tween(durationMillis = 30)),
        exit = scaleOut(animationSpec = tween(durationMillis = 1, delayMillis = 75), targetScale = 1f) + fadeOut(tween(durationMillis = 75))
    ) {
        options.forEachIndexed { index, option -&gt;
            if (index == 1 || index == options.lastIndex) {
                Separator(color = Color(0xFFBDBDBD))
            }
            Button(onClick = { expanded = false }, enabled = option.enabled, modifier = Modifier.padding(4.dp), contentPadding = PaddingValues(horizontal = 8.dp, vertical = 2.dp), contentColor = (if (option.dangerous) Color(0xFFC62828) else LocalContentColor.current).copy(alpha = if (option.enabled) 1f else 0.5f), shape = RoundedCornerShape(8.dp),) {
                Icon(option.icon, null)
                Spacer(Modifier.width(4.dp))
                Text(text = option.text, modifier = Modifier.fillMaxWidth().padding(vertical = 8.dp, horizontal = 4.dp))
            }
        }
    }
}
</code></pre>

<p>ä»¥åŠæ›´å¤šæœªæ ·å¼åŒ–çš„ç»„ä»¶ï¼Œä¾‹å¦‚ï¼š</p>

<ul>
<li><a href="https://composables.com/docs/com.composables/core/textfield">TextField</a>ï¼Œå…¨é¢æ”¯æŒå±å¹•é˜…è¯»å™¨çš„æ— éšœç¢åŠŸèƒ½</li>
<li><a href="https://composables.com/docs/com.composables/core/button">Button</a></li>
<li><a href="https://composables.com/docs/com.composables/core/dialog">Dialog</a></li>
<li><a href="https://composables.com/docs/com.composables/core/radiogroup">Radio Group</a></li>
<li><a href="https://composables.com/docs/com.composables/core/tabgroup">TabGroup</a>ï¼Œç”¨äºæ„å»ºæ ‡ç­¾å¼å¯¼èˆªï¼Œä¾‹å¦‚åº•éƒ¨åº”ç”¨æ æˆ–é¡¶éƒ¨æ ‡ç­¾æ¡Œé¢</li>
<li><a href="https://composables.com/docs/com.composables/core/checkbox">å¤é€‰æ¡†</a></li>
<li><a href="https://composables.com/docs/com.composables/core/tristatecheckbox">ä¸‰æ€å¤é€‰æ¡†</a></li>
<li><a href="https://composables.com/docs/com.composables/core/toggleswitch">åˆ‡æ¢å¼€å…³</a></li>
<li><a href="https://composables.com/docs/com.composables/core/scrollarea">æ»šåŠ¨æ¡</a>ï¼ˆæ²¡é”™ï¼Œå°±æ˜¯æ»šåŠ¨æ¡ã€‚ï¼‰</li>
</ul>


<p>æ¯ä¸ªç»„ä»¶åœ¨æ„å»ºæ—¶éƒ½å……åˆ†è€ƒè™‘äº†å¯è®¿é—®æ€§ï¼ŒåŒ…æ‹¬åˆç†çš„è¯­ä¹‰å’Œå®Œæ•´çš„é”®ç›˜å¯¼èˆªæ”¯æŒã€‚</p>

<p>ä½ å¯ä»¥<a href="https://composables.com/docs/com.composables/core">åœ¨æ–‡æ¡£ä¸­æ‰¾åˆ°å®Œæ•´çš„ç»„ä»¶åˆ—è¡¨ -></a>ï¼ˆé“¾æ¥ï¼š<a href="https://composables.com/docs/com.composables/core%EF%BC%89%E3%80%82">https://composables.com/docs/com.composables/core%EF%BC%89%E3%80%82</a></p>

<h2>ä½¿ç”¨ä½ çš„è®¾è®¡ä»¤ç‰Œè‡ªå®šä¹‰ Compose ä¸»é¢˜</h2>

<p>Compose Unstyled åŒ…å«ä¸€ä¸ªçµæ´»çš„ä¸»é¢˜ç³»ç»Ÿï¼Œå¯ä¸ä»»ä½•è®¾è®¡ç³»ç»Ÿä»¤ç‰Œå…¼å®¹ã€‚</p>

<p>ä»¥ä¸‹æ˜¯å¦‚ä½•ä½¿ç”¨ä½ é€‰æ‹©çš„è®¾è®¡ä»¤ç‰Œåˆ›å»ºå®Œå…¨è‡ªå®šä¹‰çš„ä¸»é¢˜ï¼š</p>

<p>ä»¥ä¸‹æ˜¯åˆ›å»º Compose Theme å‡½æ•°çš„ç¤ºä¾‹ï¼š</p>

<pre><code class="kotlin">// define your theme properties
private val colors = ThemeProperty&lt;Color&gt;("colors")
private val typography = ThemeProperty&lt;TextStyle&gt;("typography")
private val shapes = ThemeProperty&lt;Shape&gt;("shapes")
private val elevation = ThemeProperty&lt;Dp&gt;("elevation")
// define your theme tokens.
// those are the potential values of your theme properties
private val background = ThemeToken&lt;Color&gt;("background")
private val card = ThemeToken&lt;Color&gt;("surface")
private val onCard = ThemeToken&lt;Color&gt;("onCard")
private val outline = ThemeToken&lt;Color&gt;("outline")
private val accent = ThemeToken&lt;Color&gt;("accent")
private val primary = ThemeToken&lt;Color&gt;("primary")
private val onPrimary = ThemeToken&lt;Color&gt;("onPrimary")
private val onSecondary = ThemeToken&lt;Color&gt;("onSecondary")
private val secondary = ThemeToken&lt;Color&gt;("secondary")
private val subtle = ThemeToken&lt;Dp&gt;("subtle")
private val titleMedium = ThemeToken&lt;TextStyle&gt;("titleMedium")
private val bodyMedium = ThemeToken&lt;TextStyle&gt;("bodyMedium")
private val cardShape = ThemeToken&lt;Shape&gt;("cardShape")
private val albumCoverShape = ThemeToken&lt;Shape&gt;("albumCoverShape")
private val buttonShape = ThemeToken&lt;Shape&gt;("buttonShape")
// create your Compose Theme and assign values to each token
private val LightTheme = buildTheme {
    name = "LightTheme"
    properties[colors] = mapOf(
        accent to Color(0xFF3B82F6),
        card to Color.White,
        onCard to Color(0xFF1E293B),
        outline to Color(0xFFE2E8F0),
        primary to Color(0xFF2563EB),
        onPrimary to Color.White,
        secondary to Color(0xFFE2E8F0),
        onSecondary to Color(0xFF64748B),
        background to Color(0xFFF8F9FA),
    )
    properties[typography] = mapOf(
        titleMedium to TextStyle(
            fontSize = 18.sp,
            fontWeight = FontWeight.SemiBold,
            fontFamily = loadInterFont(),
        ),
        bodyMedium to TextStyle(
            fontSize = 14.sp,
            fontWeight = FontWeight.Normal,
            fontFamily = loadInterFont(),
        )
    )
    properties[shapes] = mapOf(
        cardShape to RoundedCornerShape(16.dp),
        albumCoverShape to RoundedCornerShape(12.dp),
        buttonShape to CircleShape
    )
    properties[elevation] = mapOf(
        subtle to 8.dp
    )
}
</code></pre>

<p>ç„¶åï¼Œä½ å¯ä»¥ä½¿ç”¨æ–°çš„ä¸»é¢˜å‡½æ•°åŒ…è£…ä½ çš„åº”ç”¨ï¼š</p>

<pre><code class="kotlin">@Composable
fun MusicPlayerApp() {
    LightTheme {
        MusicPlayerCard()
    }
}
</code></pre>

<p>ç„¶åï¼Œå®ƒä¼šä½¿ç”¨ <code>Theme</code> å¯¹è±¡æˆäºˆå…¶å­ç»„ä»¶å¯¹ä¸»é¢˜çš„è®¿é—®æƒé™ï¼š</p>

<pre><code class="kotlin">@Composable
fun MusicPlayerCard(modifier: Modifier = Modifier) {
    val sliderState = rememberSliderState(initialValue = 0.3f)
    Box(
        modifier = modifier
            .outline(1.dp, Theme[colors][outline], Theme[shapes][cardShape])
            .shadow(Theme[elevation][subtle], Theme[shapes][cardShape])
            .background(Theme[colors][card], Theme[shapes][cardShape])
            .padding(24.dp)
    ) {
        ProvideContentColor(Theme[colors][onCard]) {
            Column(verticalArrangement = Arrangement.spacedBy(20.dp)) {
                Row(verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(16.dp)) {
                    Image(
                        painter = painterResource(Res.drawable.just_hoist_it_cover),
                        modifier = Modifier
                            .clip(Theme[shapes][albumCoverShape])
                            .background(Theme[colors][primary])
                            .size(80.dp),
                        contentDescription = "Album Cover",
                        contentScale = ContentScale.Crop
                    )
                    Column(modifier = Modifier.weight(1f)) {
                        Text("Just hoist it!", style = Theme[typography][titleMedium])
                        Spacer(Modifier.height(4.dp))
                        Text(
                            "The Deprecated",
                            style = Theme[typography][bodyMedium],
                            color = Theme[colors][onSecondary]
                        )
                    }
                }
                Slider(
                    state = sliderState,
                    modifier = Modifier.fillMaxWidth(),
                    track = {
                        Box(Modifier.fillMaxWidth().height(4.dp).clip(RoundedCornerShape(2.dp))) {
                            // the empty part of the track
                            Box(Modifier.fillMaxSize().background(Theme[colors][secondary]))
                            // the filled part of the track
                            Box(
                                Modifier.fillMaxWidth(sliderState.value).fillMaxSize().background(Theme[colors][accent])
                            )
                        }
                    },
                    thumb = {
                        Thumb(
                            color = Theme[colors][accent],
                            modifier = Modifier.size(16.dp),
                            shape = Theme[shapes][buttonShape]
                        )
                    }
                )
                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceEvenly, verticalAlignment = Alignment.CenterVertically) {
                    Button(onClick = { }, contentPadding = PaddingValues(12.dp), shape = Theme[shapes][buttonShape]) {
                        Icon(imageVector = Lucide.SkipBack, contentDescription = "Previous", modifier = Modifier.size(20.dp))
                    }
                    Button(onClick = { }, backgroundColor = Theme[colors][primary], contentColor = Theme[colors][onPrimary], contentPadding = PaddingValues(16.dp), shape = Theme[shapes][buttonShape]) {
                        Icon(imageVector = Lucide.Pause, contentDescription = "Pause", modifier = Modifier.size(24.dp))
                    }
                    Button(onClick = { }, contentPadding = PaddingValues(12.dp), shape = Theme[shapes][buttonShape]) {
                        Icon(imageVector = Lucide.SkipForward, contentDescription = "Next", modifier = Modifier.size(20.dp))
                    }
                }
            }
        }
    }
}
</code></pre>

<h2>è½®å»“ä¿®é¥°ç¬¦</h2>

<p>æœ€åä½†åŒæ ·é‡è¦çš„æ˜¯ï¼ŒCompose Unstyled å¼•å…¥äº†ä¸€äº› Compose Foundation ä¸­ç¼ºå°‘çš„æ ·å¼ <code>Modifier</code>ï¼Œä½†è¿™äº›ä¿®é¥°ç¬¦å¯¹äºæ„å»ºè§†è§‰ä¸°å¯Œçš„ç•Œé¢å¿…ä¸å¯å°‘ï¼š</p>

<h3>è½®å»“</h3>

<p>ä¸ Compose Foundation çš„ <code>border()</code> ä¿®é¥°ç¬¦ä¸åŒï¼Œæ­¤ä¿®é¥°ç¬¦ä¸ä¼šå½±å“å¸ƒå±€ã€‚å®ƒè¿˜ä¼šåœ¨ç»„ä»¶å‘¨å›´è€Œä¸æ˜¯å†…éƒ¨è¿›è¡Œç»˜åˆ¶ã€‚å½“ä½ éœ€è¦ä¸€ä¸ªä¸é˜´å½±å®Œç¾èåˆçš„åŠé€æ˜è½®å»“æ—¶ï¼Œè¿™ä¸ªåŠŸèƒ½éå¸¸æ–¹ä¾¿ï¼š</p>

<p><img src="file:///Users/alexhilton/Downloads/compose-style-3.png" alt="" /></p>

<pre><code class="kotlin">SimpleButton(
  shape = RectangleShape,
  modifier = Modifier.outline(2.dp, Color(0xFF3B82F6), shape = RectangleShape)
)
SimpleButton(
  shape = RoundedCornerShape(8.dp),
  modifier = Modifier.outline(2.dp, Color(0xFF3B82F6), shape = RoundedCornerShape(8.dp))
)
SimpleButton(
  shape = CircleShape,
  modifier = Modifier.outline(2.dp, Color(0xFF3B82F6), shape = CircleShape)
)
</code></pre>

<h3>ç„¦ç‚¹ç¯</h3>

<p>ç„¦ç‚¹ç¯åœ¨å¤„ç†é”®ç›˜å¯¼èˆªå’Œç„¦ç‚¹æ—¶éå¸¸é‡è¦ã€‚å®ƒä»¬åªæœ‰åœ¨è·å¾—ç„¦ç‚¹æ—¶æ‰ä¼šæ¸²æŸ“è½®å»“ã€‚</p>

<pre><code class="kotlin">val interactionSource = remember { MutableInteractionSource() }
SimpleButton(
    modifier = Modifier.focusRing(
        interactionSource = interactionSource,
        width = 2.dp,
        color = Color(0xFF3B82F6),
        shape = RoundedCornerShape(8.dp),
        offset = 2.dp
    ),
    interactionSource = interactionSource
)
</code></pre>

<h2>ç„¶åå‘¢ï¼Ÿ</h2>

<p>å³å°†æ¨å‡ºçš„ç»„ä»¶åŒ…æ‹¬ï¼š</p>

<ul>
<li>ä¾§è¾¹æ </li>
<li>å·¥å…·æç¤º</li>
<li>ä¸Šä¸‹æ–‡èœå•</li>
</ul>


<p>ä»¥åŠæ›´å¤šã€‚</p>

<p>å¦‚æœä½ æ„¿æ„ä¸ºè¯¥é¡¹ç›®æä¾›èµ„é‡‘æ”¯æŒï¼Œæˆ‘ä»¬è¿˜æä¾›<a href="https://composables.com/ui-kit">æ­£åœ¨åˆ¶ä½œä¸­çš„ UI Kit</a>ï¼ˆé“¾æ¥ï¼š<a href="https://composables.com/ui-kit%EF%BC%89%E3%80%82%E8%AF%A5">https://composables.com/ui-kit%EF%BC%89%E3%80%82%E8%AF%A5</a> UI Kit æ˜¯ä¸€å¥—å®Œæ•´çš„è®¾è®¡ç³»ç»Ÿï¼Œé€‚ç”¨äºè§¦æ§å’ŒæŒ‡é’ˆåº”ç”¨ã€‚</p>

<p>ä¸ºäº†ä½¿è¿™äº› API å®Œç¾æ— ç¼ºï¼Œæˆ‘ä»¬æŠ•å…¥äº†å¤§é‡çš„å·¥ä½œå’Œä¸“ä¸šçŸ¥è¯†ã€‚é€šè¿‡èµ„é‡‘æ”¯æŒè¯¥é¡¹ç›®ï¼Œä½ å°†åœ¨æœªæ¥å‡ å¹´è·å¾—æ›´å¤šèµ„æºï¼Œè€Œæˆ‘åˆ™å¯ä»¥ç»§ç»­ä»äº‹å¼€æºå·¥ä½œï¼ŒåŒæ—¶æ”¯ä»˜æˆ¿ç§Ÿã€‚</p>

<p>æƒ³è¦éšæ—¶äº†è§£æœ€æ–°åŠ¨æ€ï¼Ÿè¯·åŠ¡å¿…<a href="https://github.com/composablehorizo%E2%80%8B%E2%80%8Bns/compose-unstyled/">åœ¨ Github ä¸Šå…³æ³¨ Unstyled</a>ï¼ˆé“¾æ¥:<a href="https://github.com/composablehorizo%E2%80%8B%E2%80%8Bns/compose-unstyled/%EF%BC%89%E3%80%82">https://github.com/composablehorizo%E2%80%8B%E2%80%8Bns/compose-unstyled/%EF%BC%89%E3%80%82</a></p>

<p>æƒ³è¦è¯„è®ºè¿™ç¯‡æ–‡ç« å—ï¼Ÿ<a href="https://github.com/composablehorizo%E2%80%8B%E2%80%8Bns/compose-unstyled/discussions/106">åœ¨ GitHub ä¸Šè®¨è®º â†’</a>ï¼ˆé“¾æ¥ï¼š<a href="https://github.com/composablehorizo%E2%80%8B%E2%80%8Bns/compose-unstyled/discussions/106%EF%BC%89">https://github.com/composablehorizo%E2%80%8B%E2%80%8Bns/compose-unstyled/discussions/106%EF%BC%89</a></p>
]]></content>
  </entry>
  
</feed>
