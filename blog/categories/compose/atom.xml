<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Compose | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/compose/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2026-02-02T15:23:36+00:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Compose中的IntrinsicSize实战指南]]></title>
    <link href="https://alexhilton.github.io/blog/2026/02/02/mastering-intrisnicsize/"/>
    <updated>2026-02-02T00:00:00+00:00</updated>
    <id>https://alexhilton.github.io/blog/2026/02/02/mastering-intrisnicsize</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Mastering IntrinsicSize in Jetpack Compose: A Real-World Guide」，原文链接<a href="https://proandroiddev.com/mastering-intrinsicsize-in-jetpack-compose-a-real-world-guide-a57ab90c6556">https://proandroiddev.com/mastering-intrinsicsize-in-jetpack-compose-a-real-world-guide-a57ab90c6556</a>，由Sehaj kahlon发布于2026年1月24日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/1*5575GBQlUI38hH2ThTnGBQ.png" title="auto auto" ></a></p>

<!-- more -->


<p>如果你一直在使用 Jetpack Compose，你可能遇到过布局行为与预期不符的令人沮丧的情况。也许是 <code>Box</code> 中的 <code>weight()</code> 修饰符导致了奇怪的行为，或者你的分层 UI 元素大小不正确。</p>

<p>这时 <strong><code>IntrinsicSize</code></strong> 就派上用场了——相信我，一旦你理解了它，它将成为你 Compose 工具箱中最强大的工具之一。</p>

<h2>问题：一个真实的生产场景</h2>

<p>最近，我正在为一个应用程序构建详情页面。设计要求：</p>

<ol>
<li><p>顶部放置一张<strong>标题图片</strong></p></li>
<li><p>一张<strong>卡片</strong>，与标题图片重叠 56dp</p></li>
<li><p>从标题图片到柔和灰色背景的<strong>平滑过渡</strong></p></li>
</ol>


<p>我们想要实现的效果如下：</p>

<blockquote><p><strong><em>💡 设计目标：</em></strong> <em>创建一个卡片，使其优雅地与标题图片重叠，并实现无缝的背景过渡。</em></p></blockquote>

<p><img src="https://miro.medium.com/v2/resize:fit:904/1*7wqxO7TLyV_oaH9wQxz6pw.png" alt="" /></p>

<h2>挑战</h2>

<p>我需要创建一个包含两层的“盒子Box”：</p>

<ul>
<li><p><strong>图层 1（背景）：</strong> 顶部 56dp 的透明区域，然后是柔和的灰色背景</p></li>
<li><p><strong>图层 2（卡片）：</strong> 绘制在顶部的实际卡片内容</p></li>
</ul>


<p>这是我的第一个作品尝试：</p>

<pre><code class="kotlin">@Composable
fun OverlappingCardContent(overlapHeight: Dp) {
    Box(modifier = Modifier.fillMaxWidth()) {
        // Layer 1: Background
        Column(modifier = Modifier.fillMaxWidth()) {
            Spacer(modifier = Modifier.height(overlapHeight)) // 56dp transparent
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .weight(1f)  // Fill remaining space with soft background
                    .background(color = Color.LightGray)
            )
        }

        // Layer 2: Card
        Card(modifier = Modifier.fillMaxWidth()) {
            // Card content...
        }
    }
}
</code></pre>

<p><strong>但是这行不通！</strong> 😩</p>

<p><code>weight(1f)</code>修饰符导致了问题。布局要么意外地折叠，要么意外地展开。</p>

<h2>了解根本原因</h2>

<p>为了理解为什么会失败，我们先回顾一下 Compose 布局的工作原理。</p>

<h3>Compose 布局：单遍系统</h3>

<p>为了提高性能，Compose 布局采用<strong>单次遍历</strong>方式测量布局。每个可组合元素：</p>

<ol>
<li><p>从父元素接收约束</p></li>
<li><p>测量其子元素</p></li>
<li><p>确定自身大小</p></li>
<li><p>放置其子元素</p></li>
</ol>


<p>问题在于：当像 <code>Box</code> 这样的父元素测量其子元素时，每个子元素都不知道其他子元素的大小。它们是独立测量的。</p>

<h2>为什么 <code>weight(1f)</code> 会失败</h2>

<p><code>weight()</code> 修饰符表示：“占据剩余空间的 X 倍。”</p>

<p>但是剩余空间指的是<strong>什么</strong>？<code>Box</code> 元素尚未确定自身高度——它正在等待子元素告知其自身大小。这会造成循环依赖：</p>

<pre><code class="bash">Box: "Children, how tall are you?"
  ├─ Column: "I need 56dp + whatever weight(1f) gives me"
  │

  "But weight depends on your height, Box!"
  └─ Card: "I need ~180dp for my content"  Box: "I'm confused..." 🤯
</code></pre>

<h2>引入 IntrinsicSize：打破循环依赖</h2>

<p><code>IntrinsicSize</code> 是 Compose 在实际测量之前向子元素询问一个<strong>假设性问题</strong> 的方式：</p>

<blockquote><p><strong><em>“如果我给你无限的空间，你需要的最小（或最大）高度是多少？”</em></strong></p></blockquote>

<h2>IntrinsicSize.Min 与 IntrinsicSize.Max</h2>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*IUoEVdIal11Nwn3WFG6w0A.png" alt="" /></p>

<h2>修复</h2>

<pre><code class="kotlin">Box(
    modifier = Modifier
        .fillMaxWidth()
        .height(IntrinsicSize.Min)  // ← The magic line!
) {
    // Layer 1: Background
    Column(modifier = Modifier.fillMaxWidth()) {
        Spacer(modifier = Modifier.height(56.dp))
        Box(
            modifier = Modifier
                .fillMaxWidth()
                .weight(1f)
                .background(color = Color.LightGray)
        )
    }

    // Layer 2: Card
    Card(modifier = Modifier.fillMaxWidth()) {
        // Card content...
    }
}
</code></pre>

<p>现在布局正常了！原因如下：</p>

<h2>IntrinsicSize.Min 如何解决冲突</h2>

<p>当 <code>Box</code> 使用 <code>height(IntrinsicSize.Min)</code> 时，它会询问每个子元素：</p>

<p><strong>列的最小固有高度：</strong></p>

<pre><code class="bash">Spacer: 56dp (fixed)
Weighted Box: 0dp (minimum, can shrink to nothing)
Total: 56dp
</code></pre>

<p><strong>卡片的最小固有高度：</strong></p>

<pre><code class="bash">Status row + Title + Subtitle + Button + Padding = ~180dp
Total: ~180dp
</code></pre>

<p><strong>Box 选择：</strong> <code>max(56dp, 180dp)</code> = <strong>180dp</strong></p>

<p>为什么是 <code>max()</code>？因为 Box 的高度需要足以容纳<strong>所有</strong>子元素！</p>

<p>现在布局完全知道如何高度要合适，<code>weight(1f)</code> 可以正常工作：</p>

<ul>
<li><p>盒子高度：180dp</p></li>
<li><p>间距：56dp</p></li>
<li><p>加权背景盒子：180dp — 56dp = <strong>124dp</strong></p></li>
</ul>


<h2>完整解决方案：重叠卡片式 UI</h2>

<p>以下是支持此 UI 的最终代码：</p>

<pre><code class="kotlin">private val OVERLAP_HEIGHT = 56.dp
</code></pre>

<pre><code class="kotlin">@Composable
fun HeaderWithOverlappingCard(imageHeight: Dp) {
    LazyColumn {
        // Create overlap: position content before header ends
        item { 
            Spacer(modifier = Modifier.height(imageHeight - OVERLAP_HEIGHT)) 
        }

        item {
            OverlappingCardContent(overlapHeight = OVERLAP_HEIGHT)
        }
    }
}
</code></pre>

<pre><code class="kotlin">@Composable
fun OverlappingCardContent(overlapHeight: Dp) {
    Box(
        modifier = Modifier
            .fillMaxWidth()
            .height(IntrinsicSize.Min)
    ) {
        // Layer 1: Background transition
        Column(modifier = Modifier.fillMaxWidth()) {
            Spacer(modifier = Modifier.height(overlapHeight)) // Transparent over header
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .weight(1f)
                    .background(color = SoftGrayBackground)
            )
        }

        // Layer 2: Card content (drawn on top)
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(horizontal = 8.dp),
            shape = RoundedCornerShape(12.dp)
        ) {
            Column(modifier = Modifier.padding(24.dp)) {
                Text("✓ Success", color = Color.Green)
                Text("₹100 Cashback", style = MaterialTheme.typography.h4)
                Text("Transaction complete")
                Spacer(modifier = Modifier.height(16.dp))
                Button(onClick = {}) { Text("View Details") }
            }
        }
    }
}
</code></pre>

<h2>可视化分解</h2>

<pre><code class="kotlin">imageHeight = 200dp
overlapHeight = 56dp
</code></pre>

<pre><code class="bash">LazyColumn positions:
├─ Spacer: 144dp (200 - 56)
└─ OverlappingCardContent starts at Y = 144dp
</code></pre>

<pre><code class="bash">Inside OverlappingCardContent (height = 180dp via IntrinsicSize.Min):
├─ Column Layer:
│   ├─ Spacer: 56dp (transparent, header shows through)
│   └─ Background Box: 124dp (soft gray)
└─ Card Layer: 180dp (drawn from top, overlaps header)
</code></pre>

<h2>IntrinsicSize 的常见用例</h2>

<h3>1. 一行中高度相同的按钮</h3>

<p><strong>问题：</strong> 文本长度不同的按钮最终高度也不同。</p>

<p><strong>解决方案：</strong></p>

<pre><code class="kotlin">Row(modifier = Modifier.height(IntrinsicSize.Min)) {
    Button(
        modifier = Modifier.weight(1f).fillMaxHeight(),
        onClick = {}
    ) { Text("Short") }

    Button(
        modifier = Modifier.weight(1f).fillMaxHeight(),
        onClick = {}
    ) { Text("This is a much\nlonger button\nwith more text") }
}
</code></pre>

<p><strong>结果：</strong> 两个按钮的高度都与最高的按钮高度相同。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*IubiRLP4sFk4rl-uvLwwKA.png" alt="" /></p>

<h3>2. 分隔线与父元素高度匹配</h3>

<p><strong>问题：</strong> 分隔线无法拉伸以匹配多行内容。</p>

<p><strong>解决方案：</strong></p>

<pre><code class="kotlin">Row(modifier = Modifier.height(IntrinsicSize.Min)) {
    Text("Left content\nwith multiple\nlines")

    Divider(
        modifier = Modifier
            .fillMaxHeight()
            .width(1.dp)
    )

    Text("Right")
}
</code></pre>

<p><strong>结果：</strong> 分隔线可以拉伸以匹配多行文本的高度。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*nFJrnQVIaT7Kfh70JDofOA.png" alt="" /></p>

<h3>3. 带有动态内容和固定覆盖层的卡片</h3>

<p><strong>问题：</strong> 覆盖层需要与卡片宽度匹配，但卡片宽度是动态的。</p>

<p><strong>解决方案：</strong></p>

<pre><code class="kotlin">Box(modifier = Modifier.width(IntrinsicSize.Max)) {
    Card {
        Column {
            Text("Dynamic content here...")
            // More content
        }
    }

    // Badge that should match card width
    Badge(
        modifier = Modifier
            .align(Alignment.TopEnd)
            .fillMaxWidth()
    )
}
</code></pre>

<h2>性能相关注意事项 ⚠️</h2>

<p><code>IntrinsicSize</code> 会触发<strong>两遍测量</strong>：</p>

<ol>
<li><p>第一遍：查询固有尺寸</p></li>
<li><p>第二遍：实际测量和布局</p></li>
</ol>


<p>这会带来一定的性能开销。谨慎使用：</p>

<h2>✅ 适用场景</h2>

<ul>
<li><p>复杂的分层 UI（例如我们的重叠卡片）</p></li>
<li><p>使同级元素大小一致</p></li>
<li><p>使分隔符/分隔线与内容匹配</p></li>
<li><p>需要子元素协调大小时</p></li>
</ul>


<h2>❌ 避免使用场景</h2>

<ul>
<li><p>在可能会重复数百次的 <code>LazyColumn</code>/<code>LazyRow</code> 元素中</p></li>
<li><p>深度嵌套的固有尺寸</p></li>
<li><p>当固定尺寸或 <code>wrapContentHeight()</code> 可以满足需求时</p></li>
<li><p>在性能关键路径中</p></li>
</ul>


<h2>要点</h2>

<ol>
<li><p><strong><code>IntrinsicSize.Min</code></strong> = &ldquo;使用子元素所需的最小高度&rdquo;</p></li>
<li><p><strong><code>IntrinsicSize.Max</code></strong> = &ldquo;使用子元素可能需要的最大高度&rdquo;</p></li>
<li><p>它解决了父元素和子元素尺寸之间的循环依赖关系</p></li>
<li><p>对于子元素使用 <code>weight()</code> 或 <code>fillMaxHeight()</code> 的分层 UI 至关重要</p></li>
<li><p>会带来性能开销——请谨慎使用</p></li>
</ol>


<h2>结论</h2>

<p><code>IntrinsicSize</code> 看似是一个小众的 API，但它对于在 Compose 中构建复杂的 UI 至关重要。我们构建的重叠卡片模式只是其中一个例子——当你需要协调同级元素的大小，或者当分层布局需要“统一”尺寸时，你会发现它非常实用。</p>

<p>下次当你的 Compose 布局在使用 <code>weight()</code> 或 <code>fillMaxHeight()</code> 时出现异常行为时，请记住：<strong>IntrinsicSize 或许能帮你解决问题</strong>。</p>

<p><em>如果你有任何疑问或发现了 IntrinsicSize 的其他创意用法，请在下方留言！</em></p>

<p><strong>关注我，获取更多 Android 开发技巧。</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jetpack Compose重组稳定性分析器]]></title>
    <link href="https://alexhilton.github.io/blog/2026/01/30/compose-stability-analyzer/"/>
    <updated>2026-01-30T00:00:00+00:00</updated>
    <id>https://alexhilton.github.io/blog/2026/01/30/compose-stability-analyzer</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Compose Stability Analyzer: Real-Time Stability Insights for Jetpack Compose」，原文链接<a href="https://medium.com/proandroiddev/compose-stability-analyzer-real-time-stability-insights-for-jetpack-compose-1399924a0a64">https://medium.com/proandroiddev/compose-stability-analyzer-real-time-stability-insights-for-jetpack-compose-1399924a0a64</a>，由Jaewoong Eum发布于2025年11月10日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/0*uLjBHnzVq5vM002Z" title="auto auto" ></a></p>

<!-- more -->


<p>Jetpack Compose 以其声明式编程范式革新了 Android UI 开发，但这种简洁性背后却隐藏着复杂性：理解重组合行为。当一个可组合元素不必要地进行重组合时，就会造成性能损失，CPU 周期会浪费在重新渲染实际上并未改变的 UI 上。挑战不仅在于识别这些问题，更在于理解它们发生的<strong>原因</strong>。</p>

<p>Compose 编译器一直在后台执行稳定性分析，确定哪些可组合元素在输入未发生变化时可以跳过重组合。但这种分析是在编译时静默进行的，开发者无法得知他们的可组合元素是否得到了优化。你可能编写出看似完美稳定的代码，但之后却发现类中一个 <code>var</code> 属性就足以导致整个代码不稳定，并波及整个 UI 树。</p>

<p><a href="https://github.com/skydoves/compose-stability-analyzer">Compose Stability Analyzer</a> 将这种隐藏的分析揭示出来。它是一套全面的工具集，可在 IDE 中提供实时可视化反馈，通过注解进行运行时代码重组追踪，并在 CI 流水线中进行稳定性验证。无需等到性能问题在生产环境中出现，你就能在编码过程中获得即时反馈，使稳定性分析自然而然地融入你的开发工作流程。</p>

<p>本文将探讨 Compose 稳定性分析器的工作原理，包括：IntelliJ 插件（为你的 IDE 提供可视化的稳定性指示器）、编译器插件（启用运行时重组跟踪）以及稳定性验证系统（防止回归问题影响生产环境）。</p>

<h2>理解稳定性问题：为什么可组合函数会重组</h2>

<p>在深入工具之前，值得了解 Compose 编译器实际上分析的内容。编译器会对每个可组合函数执行稳定性推断，回答两个问题：</p>

<p><strong>1. 这个可组合函数可以跳过吗？</strong></p>

<p>当编译器能够证明使用相同的输入重新组合该函数会产生相同的结果时，该可组合函数就是可跳过的。如果所有参数都是稳定的并且没有发生变化，可组合函数可以完全跳过重新组合，这是一个显著的性能优化。</p>

<p><strong>2. 该可组合项是否可重启？</strong></p>

<p>当一个可组合项可以独立重新组合而无需重新组合其父项时，该可组合项是可重启的。这使得重新组合更加细粒度。大多数可组合项都是可重启的，但带有某些修饰符的可组合项可能不是。</p>

<p>这里的关键概念是<strong>参数稳定性</strong>。当 Compose 编译器能够可靠地检测到参数值是否发生变化时，该参数是稳定的。规则非常复杂，如果你想深入了解这些规则，可以参考稳定性研究<a href="https://github.com/skydoves/compose-stability-inference">Compose 稳定性推断</a>。</p>

<h2>在 Android Studio 中进行可视化稳定性分析</h2>

<p>Compose Stability Analyzer IntelliJ 插件可将稳定性分析直接集成到 Android Studio 和 IntelliJ IDEA 中，在你编写代码时提供四层可视化反馈。</p>

<h3>安装和设置</h3>

<p>安装插件非常简单：</p>

<ol>
<li><p>打开 <strong>Android Studio</strong> → <strong>设置</strong> → <strong>插件</strong> → <strong>应用市场</strong>。</p></li>
<li><p>搜索“Compose Stability Analyzer”。</p></li>
<li><p>点击 <strong>安装</strong> 并重启 IDE。</p></li>
</ol>


<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*ukPWg_I6mOo9Drk0.png" alt="图1" /></p>

<p>安装完成后，插件会立即开始分析你的代码。无需任何配置，它可与任何 Compose 项目开箱即用。</p>

<h3>边栏图标：即时视觉反馈</h3>

<p>最直观的功能是边栏图标，即出现在可组合函数左侧边栏的彩色圆点：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*r3BFUwBTNNRfa2Y7.png" alt="图2" /></p>

<ul>
<li><p><strong>绿点</strong>：此可组合函数可跳过。所有参数均稳定，编译器可以优化重新组合。</p></li>
<li><p><strong>黄点</strong>：此可组合函数可重启，但不可跳过。它会在其父函数重新组合时重新组合。</p></li>
<li><p><strong>红点</strong>：此可组合函数的参数不稳定，无法进行优化。</p></li>
</ul>


<p>这种即时视觉反馈是快速发现 Jetpack Compose 性能问题的最佳方法。只需快速浏览左侧边栏，即可了解哪些可组合函数需要关注。如果屏幕上布满红点，则说明需要进行一些优化工作。</p>

<p>边栏图标的计算基于 Compose 编译器执行的相同稳定性分析。该插件会接入编译器的分析阶段并提取稳定性信息，然后在编辑器中以可视化的方式呈现。</p>

<p>但请注意，目前<a href="https://developer.android.com/develop/ui/compose/performance/stability/strongskipping">强跳过模式</a>默认大多已启用，因此所有可组合函数默认都可以跳过。你可以在插件配置中启用或禁用强跳过模式检查（工具 > Compose 稳定性分析器），该功能自 0.5.0 版本起也默认启用。如果你希望更加关注稳定性问题，可以根据实际情况将其关闭。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*UGJB2Jx_JKIv3_l0xrMCoQ.png" alt="图3" /></p>

<h3>悬停提示：了解原因</h3>

<p>边栏图标告诉你<strong>哪里</strong>出了问题，而悬停提示则告诉你<strong>为什么</strong>。当你将鼠标悬停在可组合函数名称上时，会显示详细的提示信息：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*s_KwLNlhbLEsoBko.png" alt="图4" /></p>

<p>提示信息显示：</p>

<ul>
<li><p>可组合函数是否可跳过和可重启</p></li>
<li><p>稳定参数与不稳定参数的总数</p></li>
<li><p>每个参数的详细稳定性信息</p></li>
<li><p>接收器稳定性（针对扩展函数）</p></li>
</ul>


<p>这种细致的反馈对于调试至关重要。你无需猜测哪个参数导致了不稳定，而是可以准确地看到哪些参数存在问题。</p>

<h3>内联参数提示：精细化可见性</h3>

<p>工具提示会在鼠标悬停时提供详细信息，而内联参数提示则无需任何交互即可提供持续可见性：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*g1f1L5ZuagOSKrA8.png" alt="图5" /></p>

<p>函数签名中每个参数类型旁边都会显示小徽章，指示该参数是稳定还是不稳定。这是最详细的反馈级别；每个参数的稳定性一目了然。</p>

<p>对于参数众多的函数，这有助于你快速浏览并识别有问题的参数，而无需打开工具提示。颜色编码与稳定性状态相对应：</p>

<ul>
<li><p>绿色徽章：参数稳定</p></li>
<li><p>红色徽章：参数不稳定</p></li>
<li><p>黄色徽章：稳定性将在运行时决定（因此可能稳定也可能不稳定）</p></li>
</ul>


<h3>代码检查：自动建议</h3>

<p>第四层反馈是主动代码检查。当插件检测到不稳定的组合体时，它可以：</p>

<ol>
<li><p><strong>用警告下划线突出显示问题</strong>。</p></li>
<li><p><strong>通过 Alt+Enter 菜单提供快速修复建议</strong>。</p></li>
<li><p><strong>提供添加注解（例如 <code>@TraceRecomposition</code>）</strong>以进行调试。</p></li>
<li><p><strong>提供抑制选项</strong>（如果不稳定是故意的）。</p></li>
</ol>


<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*o9_zJzFKaKfyLp_hiXCvoA.png" alt="图6" /></p>

<p>插件在此开始主动出击。它不仅会指出问题，还会提供解决方案。在不稳定的组合体上按下 Alt+Enter，你可能会看到如下选项：</p>

<ul>
<li><p>添加 <code>@TraceRecomposition</code> 以监控重新组合。</p></li>
<li><p>使用 <code>@Stable</code> 注解进行标记（请谨慎使用）。</p></li>
<li><p>抑制此函数的稳定性警告。</p></li>
</ul>


<h3>稳定性浏览器：包级分析</h3>

<p>除了单个函数分析之外，稳定性浏览器还提供整个代码库稳定性的概览：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*xPe6l50SxP3DQHEP.png" alt="图7" /></p>

<p>启用方法：</p>

<ol>
<li><p>安装 Compose Stability Analyzer Gradle 插件（下一节将介绍）。</p></li>
<li><p>转到“视图”→“工具窗口”→“Compose Stability Analyzer”。</p></li>
<li><p>构建项目并单击刷新按钮。</p></li>
</ol>


<p>浏览器以树状视图显示包结构，每个可组合函数都带有其稳定性状态的注解。你可以快速深入查找整个代码库中不稳定的函数，从而轻松地确定优化工作的优先级。</p>

<p>这在大型项目中尤其有用，因为手动检查每个可组合组件是不切实际的。该工具会为你的应用程序提供一份稳定性“成绩单”，显示哪些包存在最多的稳定性问题。</p>

<h3>自定义配置</h3>

<p>该插件具有高度可定制性。你可以调整颜色、启用或禁用特定的视觉指示器，并配置分析行为以满足你的偏好。</p>

<p>前往“设置”→“工具”→“Compose Stability Analyzer”（组合稳定性分析器）访问配置选项：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*l2CoGtjreY7XNdyK.png" alt="图8" /></p>

<p>你可以：</p>

<ul>
<li><p>更改边栏图标颜色以匹配你的 IDE 主题</p></li>
<li><p>分别启用或禁用内联提示、警告和边栏图标</p></li>
<li><p>配置强跳过模式分析</p></li>
<li><p>添加忽略类型模式以从分析中排除某些类</p></li>
<li><p>在测试源集中启用分析</p></li>
<li><p>设置自定义稳定性配置文件</p></li>
</ul>


<p>这种灵活性确保插件能够自然地融入你现有的工作流程，无论你偏好最小的视觉干扰还是最大的信息密度。</p>

<h2>Gradle 插件：运行时重组追踪</h2>

<p>IntelliJ 插件提供编译时可见性，而 Gradle 插件则支持<strong>运行时分析</strong>，能够精确追踪可组合组件在运行中的重组时间和原因。这是通过 <code>@TraceRecomposition</code> 注解实现的，该注解是一个编译器插件，它会在可组合组件中添加日志代码。</p>

<h3>安装和设置</h3>

<p>将以下依赖项添加到 <code>libs.versions.toml</code> 文件中：</p>

<pre><code class="toml">stability-analyzer = { id = "com.github.skydoves.compose.stability.analyzer", version = "0.5.0" }
</code></pre>

<p>接下来，将插件应用到根目录下的 <code>build.gradle.kts</code> 文件中，如下所示：</p>

<pre><code class="kotlin">alias(libs.plugins.stability.analyzer)
</code></pre>

<p>完成！该插件会自动将编译器插件应用到项目中的所有 Kotlin 编译任务。基本用法无需额外配置。</p>

<h3>Kotlin 版本兼容性</h3>

<p>该插件与 Kotlin 编译器紧密耦合，因此版本一致性至关重要。截至撰写本文时，<strong>你至少应使用 Kotlin 2.2.21 版本</strong>。使用不匹配的版本可能会导致编译错误。请始终使用与你的稳定性分析器版本完全匹配的 Kotlin 版本。你可以参考 Kotlin 版本映射表（<a href="https://github.com/skydoves/compose-stability-analyzer?tab=readme-ov-file#kotlin-version-mapping%EF%BC%89%E8%8E%B7%E5%8F%96%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E3%80%82">https://github.com/skydoves/compose-stability-analyzer?tab=readme-ov-file#kotlin-version-mapping%EF%BC%89%E8%8E%B7%E5%8F%96%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E3%80%82</a></p>

<h3>@TraceRecomposition 注解</h3>

<p>安装插件后，你可以使用 <code>@TraceRecomposition</code> 注解任何可组合组件，以跟踪其重组行为：</p>

<pre><code class="kotlin">@TraceRecomposition
@Composable
fun ProductCard(
    product: Product,
    onClick: () -&gt; Unit
) {
    Card(onClick = onClick) {
        Text(product.name)
        Text("$${product.price}")
    }
}
</code></pre>

<p>当此可组合组件重组时，你将在 Logcat 中看到详细的日志：</p>

<pre><code class="bash">D/Recomposition: [Recomposition #1] ProductCard  
D/Recomposition:   ├─ product: Product stable (Product@abc123)  
D/Recomposition:   └─ onClick: () -&gt; Unit stable (Function@xyz789)  
D/Recomposition: [Recomposition #2] ProductCard  
D/Recomposition:   ├─ product: Product changed (Product@abc123 → Product@def456)  
D/Recomposition:   └─ onClick: () -&gt; Unit stable (Function@xyz789)
</code></pre>

<p>日志显示：</p>

<ul>
<li><p><strong>重组次数</strong>：此实例已重组的次数</p></li>
<li><p><strong>参数稳定性</strong>：每个参数是稳定还是不稳定</p></li>
<li><p><strong>变更检测</strong>：哪些参数发生了更改，显示新旧值</p></li>
<li><p><strong>身份跟踪</strong>：每个参数值的哈希码</p></li>
</ul>


<p>这些细粒度的信息对于调试至关重要。你可以准确地看到是哪个参数的更改触发了重组，从而帮助你了解应用程序的重组模式。</p>

<h3>使用标签参数进行过滤</h3>

<p>对于包含大量跟踪可组合组件的大型应用程序，日志可能会变得非常庞大。 <code>tag</code> 参数可以帮助你组织和筛选日志：</p>

<pre><code class="kotlin">@TraceRecomposition(tag = "product-list")
@Composable
fun ProductCard(product: Product, onClick: () -&gt; Unit) {
    // ...
}

@TraceRecomposition(tag = "user-profile")
@Composable
fun ProfileHeader(user: User) {
    // ...
}
</code></pre>

<p>现在日志包含以下标签：</p>

<pre><code class="bash">D/Recomposition: [Recomposition #1] ProductCard (tag: product-list)
D/Recomposition: [Recomposition #1] ProfileHeader (tag: user-profile)
</code></pre>

<p>你可以筛选 Logcat 以仅显示特定标签：</p>

<ul>
<li><p>按 <code>tag: product-list</code> 筛选，仅查看与产品相关的重组日志。</p></li>
<li><p>按 <code>tag: user-profile</code> 筛选，仅查看与用户个人资料相关的重组日志。</p></li>
</ul>


<p>这在与自定义日志记录器（将在下文介绍）结合使用时尤其有用，因为你可能只想将某些标签发送到分析服务。</p>

<h3>设置阈值以减少噪音</h3>

<p>大多数可组合组件在初始设置期间会重新组合 1-2 次，这是预期行为，<strong>并非性能问题</strong>。<code>threshold</code> 参数可以过滤掉这些噪音：</p>

<pre><code class="kotlin">@TraceRecomposition(threshold = 3)
@Composable
fun FrequentlyRecomposingScreen() {
    // Logs will only appear after the 3rd recomposition
}
</code></pre>

<p>这样可以将注意力集中在真正的问题上：用户交互期间不断重新组合的可组合组件，而不仅仅是初始设置。</p>

<p>一个实际用例：设置一个较高的阈值，并在超过该阈值时发送分析事件：</p>

<pre><code class="kotlin">@TraceRecomposition(tag = "checkout", threshold = 10)
@Composable
fun CheckoutScreen() {
    // If this recomposes 10+ times, something is wrong
}
</code></pre>

<p>然后在你的自定义日志记录器（参见下一节）中，你可以在超过阈值时发送 Firebase 事件，从而监控生产环境中的性能问题。</p>

<h3>配置日志系统</h3>

<p>默认情况下，<code>@TraceRecomposition</code> 不会记录任何日志，你需要在 <code>Application</code> 类中启用日志记录：</p>

<pre><code class="kotlin">class MyApp : Application() {
    override fun onCreate() {
        super.onCreate()

        // Enable only in debug builds
        ComposeStabilityAnalyzer.setEnabled(BuildConfig.DEBUG)
    }
}
</code></pre>

<p>这一点非常重要，如果你没有自定义日志记录器，<strong>务必使用</strong> <code>**BuildConfig.DEBUG**</code> 包裹，以避免生产构建中潜在的安全问题。</p>

<p><strong>自定义日志记录器：Logcat 之外的选择</strong> 默认日志记录器使用 Logcat，但你可以提供自定义实现，将日志发送到你想要的任何位置：</p>

<pre><code class="kotlin">ComposeStabilityAnalyzer.setLogger(object : RecompositionLogger {  
    override fun log(event: RecompositionEvent) {  
        // Send to Firebase, Crashlytics, custom analytics, etc.  
        if (event.recompositionCount &gt;= 10) {  
            FirebaseAnalytics.getInstance(this).logEvent("excessive\_recomposition") {  
                param("composable", event.composableName)  
                param("count", event.recompositionCount)  
                param("unstable\_params", event.unstableParameters.joinToString())  
            }  
        }  
    }  
})
</code></pre>

<p>因此，你甚至可以根据调试模式或发布模式设置不同的日志记录器。<code>RecompositionEvent</code> 包含：</p>

<ul>
<li><p><code>composableName</code>：函数名称。</p></li>
<li><p><code>tag</code>：来自 <code>@TraceRecomposition</code> 的标签。</p></li>
<li><p><code>recompositionCount</code>：重新组合的次数。</p></li>
<li><p><code>parameterChanges</code>：包含稳定性信息的参数变更列表。</p></li>
<li><p><code>unstableParameters</code>：不稳定参数名称列表。</p></li>
</ul>


<p>这支持强大的监控模式。你可以：</p>

<ul>
<li><p>针对过度重组的组合对象发送分析事件</p></li>
<li><p>在生产环境中跟踪性能指标（并采取适当的隐私保护措施）</p></li>
<li><p>构建显示重组模式的自定义仪表板</p></li>
<li><p>在测试环境中出现性能下降时发出警报</p></li>
</ul>


<p>以下是一个使用标签过滤日志内容的更贴近实际的示例：</p>

<pre><code class="kotlin">val tagsToLog = setOf("checkout", "product-list", "search")
ComposeStabilityAnalyzer.setLogger(object : RecompositionLogger {
    override fun log(event: RecompositionEvent) {
        if (BuildConfig.DEBUG) {
            // In debug, log everything
            Log.d("Recomposition", formatEvent(event))
        } else {
            // In release, only log tagged composables that exceed threshold
            if (event.tag in tagsToLog &amp;&amp; event.recompositionCount &gt;= 5) {
                // Send to analytics
                FirebaseAnalytics.getInstance(this).logEvent("recomposition_issue", ...)
            }
        }
    }
})
</code></pre>

<h3>理解日志</h3>

<p>让我们一起来了解如何解读日志。请看以下示例：</p>

<pre><code class="bash">D/Recomposition: [Recomposition #1] UserCard  
D/Recomposition:   ├─ user: User stable (User@abc123)  
D/Recomposition:   └─ onClick: () -&gt; Unit stable (Function@xyz789)
</code></pre>

<p><strong>这意味着：</strong></p>

<ul>
<li><p>这是此 <code>UserCard</code> 实例的首次重组。</p></li>
<li><p>两个参数都稳定。</p></li>
<li><p>这是初始重组的预期行为。</p></li>
</ul>


<pre><code class="bash">D/Recomposition: [Recomposition #2] UserCard  
D/Recomposition:   ├─ user: User changed (User@abc123 → User@def456)  
D/Recomposition:   └─ onClick: () -&gt; Unit stable (Function@xyz789)
</code></pre>

<p><strong>这意味着：</strong></p>

<ul>
<li><p>第二次重组。</p></li>
<li><p><code>user</code> 参数已更改（新实例）。</p></li>
<li><p><code>onClick</code> 保持不变（相同的 lambda 实例）。</p></li>
<li><p>这是正常现象，参数已更改，因此需要进行重组。</p></li>
</ul>


<pre><code class="bash">D/Recomposition: [Recomposition #3] UserCard (tag: user-profile)  
D/Recomposition:   ├─ user: MutableUser unstable (MutableUser@xyz789)  
D/Recomposition:   └─ Unstable parameters: [user]
</code></pre>

<p><strong>这意味着：</strong></p>

<ul>
<li><p>第三次重组。</p></li>
<li><p><code>user</code> 参数<strong>不稳定</strong>（可能具有 <code>var</code> 属性）。</p></li>
<li><p>即使 <code>user</code> 没有更改，此可组合对象也会在每次父级重组时重新组合。</p></li>
<li><p><strong>需要采取的措施</strong>：将 <code>MutableUser</code> 类修复为不可变。</p></li>
</ul>


<h2>稳定性验证：防止 CI 中的性能退化</h2>

<p>Compose 稳定性分析器最强大的功能并非可视化反馈或运行时跟踪，而是<strong>防止稳定性退化影响生产环境</strong>。稳定性验证系统的作用类似于 git diff，用于检查可组合组件的稳定性，如果稳定性下降，则 CI 构建失败。</p>

<h3>问题：静默的性能退化</h3>

<p>想象一下这样的场景：你花了数周时间优化你的应用。每个可组合组件都稳定、可跳过且运行速度快。然后，一位同事无意中修改了一个数据类：</p>

<pre><code class="kotlin">// Before (stable)
data class User(val name: String, val age: Int)

// After (unstable)
data class User(var name: String, var age: Int)
</code></pre>

<p>这一简单的更改会波及整个 UI 树。数十个原本可跳过的可组合组件变得不可跳过。性能退化了，但代码审查却未能发现，也没有任何明显的迹象表明出了问题。</p>

<p>稳定性验证可以防止这种情况发生。它会跟踪你的可组合组件的稳定性随时间的变化，并在稳定性下降时自动构建失败，强制在合并之前解决问题。</p>

<h3>工作原理：稳定性快照</h3>

<p>验证系统通过两个 Gradle 任务运行：</p>

<ul>
<li><p><code>**stabilityDump**</code>：创建一个包含所有可组合组件稳定性状态的 <code>.stability</code> 文件。</p></li>
<li><p><code>**stabilityCheck**</code>：将当前代码与基线进行比较，如果稳定性下降则构建失败。</p></li>
</ul>


<p>可以这样理解：</p>

<ul>
<li><p><code>stabilityDump</code> = &ldquo;保存当前状态&rdquo;</p></li>
<li><p><code>stabilityCheck</code> = &ldquo;自上次保存以来是否有任何更改？&rdquo;</p></li>
</ul>


<h3>步骤 1：创建基线</h3>

<p>编译项目后，运行：</p>

<pre><code class="bash">./gradlew :app:compileDebugKotlin  
./gradlew :app:stabilityDump
</code></pre>

<p>这将生成 <code>app/stability/app.stability</code> 文件：</p>

<pre><code class="kotlin">@Composable  
public fun com.example.UserCard(user: com.example.User): kotlin.Unit  
  skippable: true  
  restartable: true  
  params:  
    - user: STABLE (immutable data class)  

@Composable  
public fun com.example.ProductList(items: kotlin.collections.List&lt;com.example.Product\&gt;): kotlin.Unit  
  skippable: true  
  restartable: true  
  params:  
    - items: STABLE (immutable collection with stable elements)
</code></pre>

<p>此文件易于阅读，并准确显示了编译器对每个可组合组件的判断结果。它是应用程序稳定性状态的完整快照。</p>

<p><strong>将此文件提交到 Git：</strong></p>

<pre><code class="bash">git add app/stability/app.stability  
git commit -m "Add stability baseline"  
git push
</code></pre>

<p>现在，团队中的每个人都拥有相同的基线。</p>

<h3>步骤 2：检查回归问题</h3>

<p>在你的 CI 流水线中运行：</p>

<pre><code class="bash">./gradlew :app:compileDebugKotlin  
./gradlew :app:stabilityCheck
</code></pre>

<p>如果没有任何变化，任务成功：</p>

<pre><code class="bash">✅ Stability check passed.
</code></pre>

<p>如果稳定性出现回归，任务失败：</p>

<pre><code class="bash">❌ Stability check failed!  

The following composables have changed stability:  

~ com.example.UserCard(user): parameter 'user' changed from STABLE to UNSTABLE  

If these changes are intentional, run './gradlew stabilityDump' to update the baseline.
</code></pre>

<p>构建失败，在问题修复或明确接受回归之前，拉取请求将无法合并。</p>

<h3>检测到的变更类型</h3>

<p>验证器会检测到四种类型的变更：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1374/1*IwkocOj8s1No8lIphL1JIQ.png" alt="图9" /></p>

<p>这种全面的跟踪机制确保<strong>任何</strong>稳定性变更都清晰可见，并需要进行相应的决策。</p>

<h3>CI/CD 集成</h3>

<p>将稳定性验证添加到你的 GitHub Actions 工作流：</p>

<pre><code class="bash">name: Android CI  

on: [push, pull_request]  
jobs:  
  build:  
    runs-on: ubuntu-latest  
    steps:  
      - uses: actions/checkout@v3  
      - name: Set up JDK 17  
        uses: actions/setup-java@v3  
        with:  
          java-version: '17'  
          distribution: 'temurin'  
      - name: Build project  
        run: ./gradlew :app:compileDebugKotlin  
  stability_check:  
    name: Compose Stability Check  
    runs-on: ubuntu-latest  
    needs: build  
    steps:  
      - name: Check out code  
        uses: actions/checkout@v5.0.0  
      - name: Set up JDK  
        uses: actions/setup-java@v5.0.0  
        with:  
          distribution: 'zulu'  
          java-version: 21  
      - name: Run stability check  
        run: ./gradlew stabilityCheck
</code></pre>

<p>现在，每个拉取请求都会自动进行检查。如果稳定性下降，则拉取请求将无法合并。</p>

<h3>配置选项</h3>

<p>你可以自定义要跟踪的内容：</p>

<pre><code class="kotlin">// In your build.gradle.kts
composeStabilityAnalyzer {
    stabilityValidation {
        enabled.set(true)
        outputDir.set(layout.projectDirectory.dir("stability"))
        includeTests.set(false) // Exclude test code

        // Ignore specific packages
        ignoredPackages.set(listOf("com.example.internal"))
        // Ignore specific classes (e.g., previews)
        ignoredClasses.set(listOf("PreviewComposables"))
        // Ignore entire modules
        ignoredProjects.set(listOf("benchmarks", "examples"))
    }
}
</code></pre>

<p>这对于排除不需要稳定性跟踪的代码非常有用，例如预览组合或调试屏幕。</p>

<h3>排除特定组合</h3>

<p>使用 <code>@IgnoreStabilityReport</code> 从验证中排除单个组合：</p>

<pre><code class="kotlin">@IgnoreStabilityReport
@Preview
@Composable
fun UserCardPreview() {
    UserCard(user = User("John", 30))
}
</code></pre>

<p>预览组合不会出现在生产版本中，因此它们的稳定性无关紧要。排除它们可以减少稳定性报告中的噪音。</p>

<h3>多模块项目</h3>

<p>对于包含多个模块的项目，每个模块都会有自己的 <code>.stability</code> 文件：</p>

<pre><code class="bash">project/  
├── app/stability/app.stability  
├── feature-auth/stability/feature-auth.stability  
└── feature-profile/stability/feature-profile.stability
</code></pre>

<p>在根目录运行 <code>stabilityCheck</code> 来检查所有模块：</p>

<pre><code class="bash">./gradlew stabilityCheck
</code></pre>

<p>或者检查单个模块：</p>

<pre><code class="bash">./gradlew :feature-auth:stabilityCheck
</code></pre>

<h3>接受有意为之的回归</h3>

<p>有时稳定性回归是有意为之的，例如你正在重构代码并暂时接受较低的稳定性。在这种情况下，请更新基线：</p>

<pre><code class="bash">./gradlew :app:stabilityDump  
git add app/stability/app.stability  
git commit -m "Accept stability regression for UserCard (refactoring in progress)"  
git push
</code></pre>

<p>这会在 Git 历史记录中创建一个<strong>已记录的决策</strong>。回归不再是默默进行的，而是明确且可跟踪的。</p>

<h2>性能考量和最佳实践</h2>

<p>虽然这些工具功能强大，但仍有一些性能特性和最佳实践需要注意。有人问我是否需要让<em>每个</em>类型都稳定，答案绝对是“不需要”。</p>

<p>由于现在有了强跳过模式，每个可组合函数都可以跳过，这本身就能优化稳定性。即使这个插件可能会提示“不稳定”或“运行时稳定性”，但你实际上并不需要为每个可组合函数都进行修复。我们来看一个简单的例子。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*4ZtAbwb8_5tRAR112kL1HA.png" alt="图10" /></p>

<p>如果你查看 compose-material3 库中的 <code>Icon</code> 可组合函数，这个插件会提示它不稳定，因为它包含运行时参数。但是，<code>painter</code> 参数通常是通过 <code>painterResource</code> 函数初始化的，如下所示：</p>

<pre><code class="kotlin">val painter = painterResource(R.drawable.)
Icon(painter = painter, contentDescription = null)
</code></pre>

<p>如果你查看 <code>painterResource</code> 的内部逻辑，你会发现它本质上是稳定的。它内部使用 <code>remember</code> 将值缓存到内存中，所以你可以把它看作是一个小小的权衡：<em>“我会用一点内存来存储这个不稳定的实例，这样我就不必触发不必要的重新组合。”</em></p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*sRvsZMkusaZuOMjGskhz0A.png" alt="图11" /></p>

<p>关于不可变集合还有一个常见的误解——认为仅仅使用 <code>ImmutableList</code> 而不是普通的 <code>List</code> 就能提升性能。 <strong>并非总是如此。</strong></p>

<p>不妨这样想：如果你有一个包含 1000 个大型对象的列表，然后你将其转换为不可变列表，那么你的可组合组件就变得可以忽略了。但是，每次重新组合时，Compose 都会对列表中的每个元素运行 <code>equals()</code> 函数，以检查新实例是否与之前的实例匹配。在某些情况下，这实际上会比重新渲染一个只显示其中五个元素的轻量级 UI 更<strong>影响性能</strong>。</p>

<p>因此，<strong>稳定性会根据具体情况产生截然不同的影响</strong>，试图让整个 UI 保持稳定通常是不必要的，也是徒劳的。我希望这个插件不会加重你对稳定性的担忧，而是能够帮助你更有效地调试实际的性能问题，并做出更明智、更数据驱动的决策，而无需过度考虑稳定性。</p>

<h2>结论</h2>

<p>在本文中，我们探索了 Compose 稳定性分析器 (Compose Stability Analyzer) (<a href="https://github.com/skydoves/compose-stability-analyzer">https://github.com/skydoves/compose-stability-analyzer</a>)，了解了它如何通过三个互补的工具将 Compose 隐藏的稳定性分析可视化：IntelliJ 插件用于在开发过程中提供可视化反馈，Gradle 插件用于运行时重组追踪，以及稳定性验证系统用于防止持续集成 (CI) 中的回归。</p>

<p>IntelliJ 插件将稳定性从一个不可见的编译时概念转化为可感知的事物，通过边栏图标、工具提示和内联提示，使稳定性问题一目了然。<code>@TraceRecomposition</code> 注解弥合了编译时分析和运行时行为之间的鸿沟，让你可以准确地了解可组合组件何时以及为何重新组合。稳定性验证系统则起到安全网的作用，确保你精心设计的优化不会随着代码库的演进而悄然失效。</p>

<p>这些工具共同作用，使稳定性分析成为你开发工作流程中自然而然的一部分。你无需等待性能问题显现，即可在编码过程中立即发现它们。你无需猜测哪个参数导致了重新组合——日志会准确地告诉你哪些参数发生了变化。你也无需手动审查每个 PR 是否存在稳定性回归，CI 流水线会自动完成这项工作。</p>

<p>理解稳定性是编写高性能 Compose 应用程序的基础。借助 Compose 稳定性分析器，这种理解变得轻松、直观、即时且有效。</p>

<p>祝你编码愉快！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compose GPU加速特效：带缩放的故障效果]]></title>
    <link href="https://alexhilton.github.io/blog/2026/01/22/glitch-at-scale-effects/"/>
    <updated>2026-01-22T00:00:00+00:00</updated>
    <id>https://alexhilton.github.io/blog/2026/01/22/glitch-at-scale-effects</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「GPU-Accelerated Effects: Glitch at Scale」，原文链接<a href="https://medium.com/@konstantinzolotov/gpu-accelerated-effects-glitch-at-scale-e59216afd1e8">https://medium.com/@konstantinzolotov/gpu-accelerated-effects-glitch-at-scale-e59216afd1e8</a>，由Konstantin Zolotov发布于2025年11月9日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l67g57hjllhQ5gkwTLU2nA.gif" title="auto auto" ></a></p>

<!-- more -->


<p>几周前，我看到了Sina Samaki撰写的一篇关于使用Jetpack Compose制作故障效果的<a href="https://www.sinasamaki.com/glitch-effect-in-jetpack-compose/">精彩文章</a>。作为一个喜欢钻研底层技术的人，我看到了使用Android AGSL着色器重现这种效果并比较两种实现方式的绝佳机会。</p>

<p>在图形处理方面，选择合适的工具至关重要，因为很容易达到性能瓶颈，而扩展解决方案则变得困难。这里的情况是否如此呢？让我们一探究竟！</p>

<p>做好准备，我们将深入底层。</p>

<h2>着色器(Shader)的本质</h2>

<p>那么，着色器究竟是什么？</p>

<p>着色器是一种直接在 GPU 上执行的程序，并且可以并行执行。</p>

<p>着色器通常使用一种特殊的类 C 语言编写，在 Android Compose 中，这种语言是 AGSL——Android 图形着色语言。</p>

<p>我不会重复<a href="https://developer.android.com/develop/ui/views/graphics/agsl">官方指南</a>的内容，而是会简单介绍一下 GPU 以及一种新的着色器编程思维模型。</p>

<p>那么，它与 CPU 有什么区别呢？ CPU 和 GPU 的主要区别基本上如下：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1250/1*nNt7dZ0re2yZI33o62kKtg.png" alt="https://developer.nvidia.com/blog/cuda-refresher-reviewing-the-origins-of-gpu-computing/" /></p>

<p>CPU：</p>

<ul>
<li>更复杂</li>
<li>专为执行大量不同任务的大型程序而设计</li>
<li>MIMD（多指令多数据流）</li>
</ul>


<p>GPU：</p>

<ul>
<li>简单得多（没有分支预测，缓存更小）</li>
<li>专为对各种数据执行完全相同操作的小型程序而设计</li>
<li>更多核心 = 更高的并行性</li>
<li>SIMD（单指令多数据流）</li>
</ul>


<p>当然，CPU 也有 SIMD 扩展，但规模远不及 GPU。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*T5jVrRJztzWADaqiAFNwzQ.png" alt="https://developer.nvidia.com/blog/cuda-refresher-reviewing-the-origins-of-gpu-computing/" /></p>

<blockquote><p>GPU 非常适合对数百万像素执行相同的操作</p></blockquote>

<p>这里存在一个非常重要的<strong>思维模型转变</strong>：以前你可以在画布的任意位置绘制，而现在你面对的是一幅图像，你可以对图像的任何部分进行采样（读取），但输出结果始终是一个像素。每个目标像素都会执行相同的着色器。这类似于一个纯函数，不会产生任何副作用，因此像素仅取决于其坐标和提供的 uniform 变量。</p>

<p>让我们开始实现吧，但首先，分析<a href="https://www.sinasamaki.com/glitch-effect/">原始合成版本</a>中的关键点，并将这些想法转化为着色器思维模型。</p>

<p>关键的动画驱动因素是步长。动画器会在 500 毫秒的周期内，将浮点数值从 10 递减到 0。步长状态为整数，由于浮点数会被转换为整数，因此共有 11 个步长。</p>

<pre><code class="kotlin">var step by remember { mutableStateOf(0) }
LaunchedEffect(key) {
   Animatable(10f)
       .animateTo(
           targetValue = 0f,
           animationSpec = tween(
               durationMillis = 500,
               easing = LinearEasing,
           )
       ) {
           step = this.value.roundToInt()
       }
}
</code></pre>

<p>此外，还有一个名为强度的参数，它基于步长计算：</p>

<pre><code class="kotlin">val intensity = step / 10f
</code></pre>

<p>因此，强度是一个数值序列 [1.0, 0.9, …, 0.0]。</p>

<p>下一个关键点是切片：</p>

<pre><code class="kotlin">for (i in 0 until slices) {
    translate(
        left = if (Random.nextInt(5) &lt; step)
            Random.nextInt(-20..20).toFloat() * intensity
        else
            0f,
    ) {
        scale(
            scaleY = 1f,
            scaleX = if (Random.nextInt(10) &lt; step)
                1f + (1f * Random.nextFloat() * intensity)
            else
                1f,
        ) {
            clipRect(
                top = (i / slices.toFloat()) * size.height,
                bottom = (((i + 1) / slices.toFloat()) * size.height) + 1f,
            ) {
                layer {
                    drawLayer(graphicsLayer)
                    if (Random.nextInt(5, 30) &lt; step) {
                        drawRect(
                            color = glitchColors.random(),
                            blendMode = BlendMode.SrcAtop,
                        )
                    }
                }
            }
        }
    }
}
</code></pre>

<p>对于每个切片，都会应用以下变换：</p>

<p><strong>1. 平移</strong></p>

<ul>
<li>在步骤 10 到 5 期间，每个切片会随机移动 -20 到 20 范围内的像素。请注意，每一步操作都会使该范围缩小，因为它会乘以强度。</li>
<li>在步骤 4 到 0 中也会发生类似的情况，但并非每个切片都会移动，有些切片不会被移动。</li>
</ul>


<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LBlZyvahPz-Si5eR3IWjvw.gif" alt="" /></p>

<p><strong>2. 水平缩放</strong> 每个切片都会根据强度乘以 1.0 到 2.0 范围内的随机数进行缩放，每一步操作都会降低缩放的概率和大小。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Q2onueDpzVVChVXfV_QOg.gif" alt="" /></p>

<p><strong>3.彩色条纹</strong></p>

<ul>
<li>在步骤 10 到 5 中，在每个切片上绘制一条随机彩色条纹，初始概率为 0.2，到步骤 5 时降至 0。</li>
<li>步骤 5 之后不再绘制条纹。</li>
</ul>


<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*l67g57hjllhQ5gkwTLU2nA.gif" alt="" /></p>

<p>因此，总体而言，动画在前几个步骤中最具表现力，并在后半部分逐渐趋于稳定。</p>

<p>对于着色器而言，强度应该足以驱动动画，而无需使用步骤。在 Kotlin 代码中，我仍然会使用步骤 + 强度，仅仅是为了尽可能地复现动画效果，并用于未来的性能测试。</p>

<p><strong>思维模型转变：</strong> 着色器是逐像素执行的，但动画会将相同的变换应用于像素组（在本例中为切片）。为了在着色器中实现这一点，我们需要对整个切片进行完全相同的计算。还记得纯函数的相似性吗？它在这里非常有用，因为要得到相同的结果，我们只需要应用相同的参数！</p>

<p>具有相同变换的像素组就是一个切片：</p>

<pre><code class="glsl">uniform shader image;
uniform float2 imageSize; // Shader area size in pixels
uniform float intensity;
uniform int slices;// fragCoord — pixel coordinates
half4 main(float2 fragCoord) {
    // Create horizontal slices
    float sliceHeight = imageSize.y / float(slices); // Height of each slice in pixels
    float sliceY = floor(fragCoord.y / sliceHeight) * sliceHeight; // Start coordinates for each slice

    // ...
}
</code></pre>

<p>让我们一步一步来，从平移开始。</p>

<h2>平移</h2>

<p>步骤 10 到 5 等价于强度从 1.0 到 0.5，每次递减 0.1。因此，我们将以此为基础来移动切片：</p>

<pre><code class="glsl">// Simple random functions
float random(float seed) {
  return fract(sin(seed) * 100000.0);
}

float random(float2 st) {
    return fract(sin(dot(st.xy, float2(12.9898, 78.233))) * 43758.5453123);
}

// Determine how much this slice should be displaced
float displace(float sliceY, float intensity) {
    float rnd = random(float2(sliceY, intensity));

    float shouldDisplace;
    if (intensity &lt; 0.5 &amp;&amp; intensity &gt; rnd * 0.4) {
        shouldDisplace = 0.0;
    } else {
        shouldDisplace = 1.0;
    }

    return (rnd - 0.5) * 40.0 * intensity * shouldDisplace
}
</code></pre>

<p>这里发生了什么？</p>

<p>首先，是随机性。由于着色器本身没有随机性，因此通常使用一些函数来模拟随机性。这两个函数都会返回一个介于 0（含）和 1（不含）之间的浮点值。在这种情况下，“随机”值对于每个切片-帧组合都是唯一的。对于给定帧，均匀强度对于所有调用（= 输出像素）都是相同的，同一组像素的切片坐标也相同。结合切片起始坐标，这个值对于每一帧的每个切片都是不同的。</p>

<p>接下来，如果强度超过 0.5，<code>shouldDisplace</code> 因子会立即设置为 1.0，这意味着切片需要进行位移。否则，<code>intensity &gt; rnd * 0.4</code> 会导致执行位移的概率下降，类似于原始实现中的 <code>Random.nextInt(5) &lt; step</code>。</p>

<p>最后一行只是简单的算术运算。这里我将 0 到 1 的伪随机值转换为 -20 到 20，然后像原始实现一样乘以强度，并在发生位移时应用该因子。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*LBlZyvahPz-Si5eR3IWjvw.gif" alt="" /></p>

<h2>缩放</h2>

<p>屏幕空间缩放本质上是指相对于枢轴点（本例中为水平中心）调整像素采样坐标。由于我们是从源图像读取数据，因此实际上是移动了采样视口。</p>

<pre><code class="glsl">float2 scale(float2 coord, float yMin, float yMax, float screenWidth, float intensity) {
   float rnd = random(float2(yMin, intensity));

   if (coord.y &gt;= yMin &amp;&amp; coord.y &lt;= yMax &amp;&amp; rnd &lt; intensity) {
       float centerX = screenWidth * 0.5;

       float localX = coord.x - centerX;
       float scaleFactor = 1f + (intensity * rnd);
       localX /= scaleFactor;

       float scaledX = localX + centerX;

       return float2(scaledX, coord.y);
   }

   return coord;
}
</code></pre>

<blockquote><p>附注：为了演示，我尽量简化了逻辑。生产环境中的着色器代码通常会使用更高级的技术来避免分支，因为像上面示例中那样的不平衡分支会迫使 GPU 串行执行两条路径，从而破坏并行性。要以优化的方式实现缩放函数并非易事，所以我采用了一种简单的方法。</p></blockquote>

<p>再次强调，对于每一帧的每个切片，随机数都是唯一的，这意味着特定切片中的每个像素都会获得相同的值。因此，<code>rnd &lt; intensity</code> 会降低概率，类似于 <code>Random.nextInt(10) &lt; step</code>。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*5Q2onueDpzVVChVXfV_QOg.gif" alt="" /></p>

<h2>彩色条纹</h2>

<p>最简单的部分。类似地，如果应用了色带，则创建相同的概率，然后选择 3 种颜色中的一种。可以使用非硬编码值，但这需要一些额外的工作，因此 Compose 版本在这方面更灵活。</p>

<pre><code class="glsl">float rnd = random(float2(intensity, sliceY));
if ((rnd * 2.5 + 0.5) &lt; intensity) {
   if (rnd &gt; 0.67) {
       return yellow;
   } else if (rnd &gt; 0.33) {
       return red;
   } else {
       return cyan;
   }
} else {
   float2 scaled = scale(displaced, sliceY, sliceY + sliceHeight, imageSize.y, intensity);
   return image.eval(scaled);
}
</code></pre>

<p>将所有内容组合在一起后，结果如下：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*OPPsJbjpmUd94xsp4vfG9A.gif" alt="" /></p>

<p>存在一个明显的问题：叠加层的颜色始终为青色。这是因为伪随机函数对相同的输入返回相同的值——这是设计上的确定性行为。解决方案：在 Kotlin 端生成真正的随机数，并将其作为 uniform 变量传递。</p>

<pre><code class="glsl">-float rnd = random(float2(intensity, sliceY));
+float rnd = random(float2(intensity * realRandom, sliceY));
 if ((rnd * 2.5 + 0.5) &lt; intensity) {
-if (rnd &gt; 0.67) {
+if (realRandom &gt; 0.67) {
         return yellow;
-} else if (rnd &gt; 0.33) {
+} else if (realRandom &gt; 0.33) {
         return red;
     } else {
         return cyan;
     }
} else {
    float2 scaled = scale(displaced, sliceY, sliceY + sliceHeight, imageSize.y, intensity);
    return image.eval(scaled);
}
</code></pre>

<p>应用适当的随机性后，整个过程与原始行为非常接近：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:640/1*YMfnRYhOSI-v84eR04hHaw.gif" alt="你能猜出哪个是 compose，哪个是 AGSL 吗？" /></p>

<p>完整代码发布于<a href="https://gist.github.com/MightySeal/97687eaaf5eeeb1322a9f6f837dc5c35">此处</a>。</p>

<p>当然，在进行图形编程时，至少需要进行一些粗略的性能观察。为此，我将使用我的 Pixel 7，<a href="https://developer.android.com/topic/performance/rendering/inspect-gpu-rendering">启用 HWUI 渲染图表</a>，并稍作修改代码：使用 <a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/package-summary#infiniteRepeatable(androidx.compose.animation.core.DurationBasedAnimationSpec,androidx.compose.animation.core.RepeatMode,androidx.compose.animation.core.StartOffset)">infiniteRepeatable</a> 规范实现循环动画，并使用发布版本。Pixel 7 实际上非常适合这项任务，因为它并非高端设备，如果它在 Pixel 7 上有效，那么在性能更高的设备上也应该有效。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:960/1*MVOJpYGsNIPWI6n8scBolQ.gif" alt="" /></p>

<p><img src="https://miro.medium.com/v2/resize:fit:960/1*yybZA5FCXvybv6LXD9Uh5Q.gif" alt="" /></p>

<p>左侧为着色器，右侧为Compose</p>

<p>乍一看，这两个图表似乎很相似，但实际上存在一个问题：当前的实现方式隐式地限制了帧速率。动画会将浮点数值从 10 递减到 0，但状态更新时会使用四舍五入为整数的值。这意味着在 500 毫秒内只有 11 帧动画。这对于故障着色器来说非常方便，因为较低的帧速率也会增强故障效果。要消除这个限制，我们只需要将步长类型从整数 (Int) 更改为浮点数 (Float)，并使用不进行四舍五入的可动画值即可。</p>

<pre><code class="kotlin">-var step by remember { mutableStateOf(0) }
+var step by remember { mutableFloatStateOf(0f) }
LaunchedEffect(key) {
   Animatable(10f)
       .animateTo(
           targetValue = 0f,
           animationSpec = tween(
               durationMillis = 500,
               easing = LinearEasing,
           )
       ) {
-          step = this.value.roundToInt()
+          step = this.value
       }
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:960/1*J7Y6FenkNZAPglmKtyvNNA.gif" alt="" /></p>

<p><img src="https://miro.medium.com/v2/resize:fit:960/1*a7xb39t8tXR5APsArXk5aw.gif" alt="" /></p>

<p>左侧为着色器，右侧为Compose，无帧数限制</p>

<p>移除帧数限制后，性能提升已经非常明显。我们来做个压力测试。如果将动画应用于整个列表会发生什么？或者切片数量增加会发生什么？让我们拭目以待！</p>

<p><img src="https://miro.medium.com/v2/resize:fit:800/1*6PkVLOndrbCYVaV8ApJtzA.gif" alt="" /></p>

<p><img src="https://miro.medium.com/v2/resize:fit:800/1*DdiLlkVWT4BMY6sY2mVxVg.gif" alt="" /></p>

<p>左侧着色器，右侧Compose，无帧数限制，应用于整个列表</p>

<p><img src="https://miro.medium.com/v2/resize:fit:800/1*Gv-vtC5MNtcQ4bmYB__4rA.gif" alt="" /></p>

<p><img src="https://miro.medium.com/v2/resize:fit:800/1*BcyPMHcnOc9HvPELpVoF9g.gif" alt="" /></p>

<p>左侧着色器，右侧Compose，无帧数限制，应用于整个列表100 个切片</p>

<h2>结论</h2>

<p>Compose 非常适合用于复杂动画的原型设计，因为它可以使用熟悉的工具轻松实现。此外，值得一提的是，它适用于所有设备。</p>

<p>另一方面，着色器提供了性能更高、更稳定的渲染。在这种情况下，使用的切片数量无关紧要——无论是 20 个还是 500 个，计算量都没有区别，而纯 Compose 版本对此非常敏感，并且会随着切片数量的增加而线性增长。</p>

<p>此外，由于 AGSL 着色器只是在运行时临时编译的文本，因此理论上可以从后端更新这些动画。</p>

<p>但是，还有一个很大的问题：着色器从 Android 13 开始可用，因此根据 Android Studio 操作系统的发行情况，大约一半的设备将能够支持这种方法。当然，这种情况会随着时间的推移而改变，我希望我们能够利用着色器充分发挥图形编程的强大功能！</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1232/1*Eh3q8fmkEx9BdA5FNR11CA.jpeg" alt="" /></p>

<p>这是我的<a href="https://bento.me/mightyseal">bento</a>，如果你想联系我、聊天或讨论，欢迎来找我！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jetpack Compose内部的不同节点类型]]></title>
    <link href="https://alexhilton.github.io/blog/2026/01/12/node-types-in-jetpack-compose/"/>
    <updated>2026-01-12T00:00:00+00:00</updated>
    <id>https://alexhilton.github.io/blog/2026/01/12/node-types-in-jetpack-compose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「The Different Node Types in Jetpack Compose」，原文链接<a href="https://www.grokkingandroid.com/the-different-node-types-in-jetpack-compose/">https://www.grokkingandroid.com/the-different-node-types-in-jetpack-compose/</a>，由Wolfram Rittmeyer发布于2025年12月30日。</p></blockquote>

<p><a href=""><img src="https://www.grokkingandroid.com/wordpress/wp-content/uploads/2025/12/ComposeUiNode-700x389.png" title="auto auto" ></a></p>

<!-- more -->


<p>如果你仔细观察 Compose，你会发现它很奇怪。你会发现很多函数都没有返回值。然而，<a href="https://developer.android.com/develop/ui/compose/mental-model">Android 文档</a>却说：</p>

<blockquote><p>可组合函数会生成 UI 层级结构。</p></blockquote>

<p>这到底是什么意思呢？从函数式编程的角度来看，你那些看似无害的无状态可组合函数实际上会产生大量的<em>副作用[1]</em>。其中就包括创建节点。</p>

<p>有时你可能会创建一些可组合函数来自己创建节点。但更多时候，你会直接委托给其他可组合函数来<em>创建节点[2]</em>。</p>

<p>那么，让我们来看看有哪些节点，它们的创建位置以及它们的用途：</p>

<ul>
<li>ComposeUiNode</li>
<li>LayoutNode</li>
<li>Modifier.Node</li>
<li>SemanticsNode</li>
</ul>


<h2>ComposeUiNode</h2>

<p>当你深入研究<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/layout/package-summary#Layout(androidx.compose.ui.Modifier,androidx.compose.ui.layout.MeasurePolicy)"><code>Layout</code></a>可组合对象时，你会发现它调用了<code>ReusableComposeNode[3]</code>:</p>

<pre><code class="kotlin">@Composable
@UiComposable
inline fun Layout(modifier: Modifier = Modifier, measurePolicy: MeasurePolicy) {
    val compositeKeyHash = currentCompositeKeyHash
    val materialized = currentComposer.materialize(modifier)
    val localMap = currentComposer.currentCompositionLocalMap
    ReusableComposeNode&lt;ComposeUiNode, Applier&gt;(
        factory = ComposeUiNode.Constructor,
        update = {
            set(measurePolicy, SetMeasurePolicy)
            set(localMap, SetResolvedCompositionLocals)
            set(materialized, SetModifier)
            set(compositeKeyHash, SetCompositeKeyHash)
        },
    )
}
</code></pre>

<p><strong><code>ReusableComposeNode</code>本身并不是一个节点。</strong> 上面的代码中并没有构造函数调用，而是对另一个可组合对象的调用。第八行的工厂参数看似无关紧要，但实际上非常重要。因为最终会创建节点的就是这个函数。它会创建一个 <code>ComposeUiNode</code>。</p>

<p><code>ReusableComposeNode</code> Composable 与 Compose 运行时紧密相关。这段代码告诉 Composer 应该启动一个 <code>GroupKind.ReusableNode</code> 类型的新组，然后代码会创建一个新节点，或者在重新组合时重用现有节点。最后，当使用 update 函数参数时，它会设置节点的内容：</p>

<pre><code class="kotlin">@Composable
inline fun &lt;T : Any, reified E : Applier&gt; ReusableComposeNode(
    noinline factory: () -&gt; T,
    update: @DisallowComposableCalls Updater.() -&gt; Unit
) {
    if (currentComposer.applier !is E) invalidApplier()
    currentComposer.startReusableNode()
    if (currentComposer.inserting) {
        currentComposer.createNode(factory)
    } else {
        currentComposer.useNode()
    }
    Updater(currentComposer).update()
    currentComposer.endNode()
}
</code></pre>

<p>我们看到工厂被传递给了 <code>createNode()</code> 调用。此调用会安排在所有插入操作处理完毕后创建节点。Compose 运行时内部会延迟执行许多操作以实现优化。这里我们并不关心具体何时发生，只需知道它<em>将会</em>发生即可。当它发生时，工厂将被调用。</p>

<p>现在让我们更仔细地看一下工厂本身：<code>ComposeUiNode.Constructor</code> 看起来像是 <code>ComposeUiNode</code> 的构造函数。但事实并非如此。实际上，<code>ComposeUiNode</code> 是一个接口，它本身并不执行任何操作。它实际上是 <code>LayoutNode</code> 使用的基接口。至于这个接口和构造函数的用途，在接口声明上方的注释中已经给出：</p>

<pre><code class="kotlin">/** Interface extracted from LayoutNode to not mark the whole LayoutNode class as @PublishedApi. */
@PublishedApi
internal interface ComposeUiNode {
    // ...
    /** Object of pre-allocated lambdas used to make use with ComposeNode allocation-less. */
    companion object {
        val Constructor: () -&gt; ComposeUiNode = LayoutNode.Constructor
        val VirtualConstructor: () -&gt; ComposeUiNode = { LayoutNode(isVirtual = true) }
        // ...
    }
}
</code></pre>

<p><strong>所以 <code>ComposeUiNode</code> 只是 <code>LayoutNode</code> 的一个抽象。</strong></p>

<h2>布局节点（LayoutNode）</h2>

<p>在上一节中，我们已经了解了 <code>LayoutNode</code> 的实际创建时间。基本上，每当调用 <code>Layout</code> 可组合组件时，都会创建 <code>LayoutNode</code>。<code>LayoutNode</code> 是树状结构中的元素，代表屏幕上的内容。它需要被测量，可以在其边界内放置子元素，也可以绘制内容。</p>

<p>每个 <code>LayoutNode</code> 都知道它的子元素和父元素。因此，<code>LayoutNode</code> 构成了一个节点树，代表了已发出的内容。需要明确的是：Compose 创建的树状结构与其他 UI 框架一样——但 Google 更倾向于使用一些更高级的命名方式。<strong>因此，每当你听到/读到有关可组合组件发出内容时，请将其理解为一个 LayoutNode 被创建并插入到树中。</strong></p>

<p><code>LayoutNode</code> 类实际上非常有趣，因此值得单独撰写一篇博文，我将在其中更详细地介绍它的一些方面。</p>

<p>这里有两点值得一提：</p>

<ul>
<li><code>Applier</code> 是调用 <code>LayoutNode</code> 相应树状结构处理方法的实例。 - <code>LayoutNode</code> 持有对 <code>Owner</code> 的引用。</li>
</ul>


<p>由于 <code>Applier</code> 和 <code>Owner</code> 在 Compose 中都是非常重要的概念，我将在单独的博文中分别介绍它们。</p>

<h3>LayoutNode 的用途</h3>

<p><code>LayoutNode</code> 构成 UI 树，并跟踪其父节点和子节点。UI 树本身的管理由 <code>Applier</code> 完成，我将在另一篇文章中介绍它。</p>

<p>另外，需要记住的一点是，<code>LayoutNode</code> 存储在 <code>SlotTable[4]</code> 中。因此，在重新组合时，如果运行时认为树的这一部分不需要更改，则可以重用现有的 <code>LayoutNode</code>。</p>

<p><code>LayoutNode</code> 还会保存其修饰符（参见下一节），并委托这些修饰符来决定该 <code>LayoutNode</code> 需要多少空间（测量）、在屏幕上放置元素的位置（布局）以及最终在屏幕上显示什么内容（绘制）。</p>

<p>还有更多内容——但正如我提到的，那是另一篇文章的一部分。</p>

<h2>Modifier.Node</h2>

<p>修饰符在内部由 <a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier.Node"><code>Modifier.Node</code></a> 对象表示。<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier.Node">根据文档</a>，它是“为应用于 androidx.compose.ui.layout.Layout 的每个 Modifier.Element 创建的生命周期更长的对象”。</p>

<p>这个“生命周期更长”很有意思。基本上，只要 <code>Modifier.Node</code> 属于 <code>LayoutNode</code> 的修饰符链，它就会一直存在。 <code>LayoutNode</code> 持有一个 <code>NodeChain</code> 类型的对象，该对象内部维护着一个修饰符列表，并检查该列表是否发生更改，以及 <code>Modifier.Node</code> 的生命周期方法（例如 <code>onAttach()</code>）是否被调用。</p>

<p><code>Modifier.Node</code> 有许多现有的子类型，例如 <a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/node/LayoutModifierNode"><code>LayoutModifierNode</code></a>（见下文）或 <a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/node/DrawModifierNode?hl=en"><code>DrawModifierNode</code></a>。后者负责实际在屏幕上绘制内容，我计划在另一篇文章中详细介绍。</p>

<p>由于 <code>LayoutNode</code> 是 <code>SlotTable</code> 的一部分，因此附加到 <code>LayoutNode</code> 的 <code>NodeChain</code> 对象的 <code>Modifier.Node</code> 显然也是 <code>SlotTable</code> 的一部分。</p>

<h3>特殊子类型：<code>LayoutModifierNode</code></h3>

<p><code>LayoutModifierNode</code>（<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/node/LayoutModifierNode%EF%BC%89%E6%98%AF%E5%AE%9E%E9%99%85%E8%BF%9B%E8%A1%8C%E6%B5%8B%E9%87%8F%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%AE%83%E4%BB%AC%E4%BC%9A%E5%BD%B1%E5%93%8D%E5%B1%8F%E5%B9%95%E4%B8%8A%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%92%8C%E4%BD%8D%E7%BD%AE%E3%80%82%E6%AD%A3%E5%A6%82%E6%96%87%E6%A1%A3%E6%89%80%E8%BF%B0%EF%BC%9A%E2%80%9C">https://developer.android.com/reference/kotlin/androidx/compose/ui/node/LayoutModifierNode%EF%BC%89%E6%98%AF%E5%AE%9E%E9%99%85%E8%BF%9B%E8%A1%8C%E6%B5%8B%E9%87%8F%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%AE%83%E4%BB%AC%E4%BC%9A%E5%BD%B1%E5%93%8D%E5%B1%8F%E5%B9%95%E4%B8%8A%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%92%8C%E4%BD%8D%E7%BD%AE%E3%80%82%E6%AD%A3%E5%A6%82%E6%96%87%E6%A1%A3%E6%89%80%E8%BF%B0%EF%BC%9A%E2%80%9C</a><code>LayoutModifierNode</code> 会改变其包裹内容的测量和布局方式。”。因此，在测量和布局过程中，每当遍历 <code>ModifierNode</code> 链时，这些节点实际上都会开始进行测量。</p>

<p>因此，所有想要改变其子元素位置或对整个 Composable 元素大小产生任何影响的修饰符都需要实现 <code>LayoutModifierNode</code> 接口。例如，<code>SizeNode</code> 就是一个实现 <code>LayoutModifierNode</code> 接口的例子，它是 <code>height()</code>、<code>width()</code> 或 <code>size()</code> 等修饰符实际使用的节点。</p>

<h2>SemanticsNode</h2>

<p>当你想要向设备的<em>辅助功能服务[5]</em>传递一些信息时，你可以使用 Compose 中的 <a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier).semantics(kotlin.Boolean,kotlin.Function1)"><code>semantics</code></a> 修饰符来告知系统要向用户传达哪些语义属性。</p>

<p>但是辅助功能服务并不了解 Compose。在其他平台上，这一点显而易见，但考虑到 Compose 向后兼容（而且它并非 Android 框架的组成部分），在 Android 上也是如此。</p>

<p>对于辅助功能，前面提到的 <code>Owner</code> 再次发挥作用。它持有一个 <code>SemanticsOwner</code>，该 <code>SemanticsOwner</code> 充当了与相应平台语义框架之间的桥梁。</p>

<p>为此，<code>SemanticsOwner</code> 维护着一个 <code>SemanticNode</code> 对象树，用于向辅助功能服务的用户描述屏幕内容。这也是我未来会更详细介绍的内容之一。</p>

<p>敬请期待更多关于 Compose 内部运作机制的见解。祝你编码愉快！</p>

<h2>脚注</h2>

<ul>
<li>[1] 我在本段中使用“副作用”一词，是因为它在<a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)">计算机科学和函数式编程</a>中由来已久。我这里指的并非官方 Compose 文档中提到的<a href="https://developer.android.com/develop/ui/compose/side-effects">副作用</a>。Compose 文档至少在过去有时会提及副作用的这种用法——尽管实际上 Compose 函数并非纯函数。</li>
<li>[2] 如果在 Compose Compiler 插件完成工作后查看 Composable，你会发现它不仅创建了节点，而且你的函数还会进行大量调用，从而改变应用程序的全局状态。但这些调用并不会实际绘制任何内容。它们最多只会创建一些绘制操作，这些操作会被记录下来，并在系统认为需要绘制时，于未来的某个时间点被调用。我将在以后的两篇文章中分别介绍绘制过程以及编译器对代码所做的更改。</li>
<li>[3] 实际上，布局可组合对象共有三个。但它们最终都会调用 <code>ReusableComposeNode</code>。其他变体的示例也与之非常相似。</li>
<li>[4] 本系列文章中我可能不会介绍 SlotTable。我推荐 Richard Leland 的这篇关于 compose 的文章（<a href="https://medium.com/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd%EF%BC%89%EF%BC%8C%E4%BB%A5%E5%8F%8A">https://medium.com/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd%EF%BC%89%EF%BC%8C%E4%BB%A5%E5%8F%8A</a> Mohit Sarveiya 的关于 slotTable 的视频（<a href="https://codingwithmohit.com/%EF%BC%89%EF%BC%8C%E8%BF%99%E4%BA%9B%E8%A7%86%E9%A2%91%E8%AE%B2%E8%A7%A3%E4%BA%86%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8">https://codingwithmohit.com/%EF%BC%89%EF%BC%8C%E8%BF%99%E4%BA%9B%E8%A7%86%E9%A2%91%E8%AE%B2%E8%A7%A3%E4%BA%86%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8</a> slotTable。</li>
<li>[5] 设备上的辅助功能服务在 Android 系统中是 AccessibilityService 的实现，但在 iOS、桌面或 Web 端则有所不同，因此我在本文中使用“辅助功能服务”这个通用术语。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[学会在Jetpack Compose中加载Lottie动画资源]]></title>
    <link href="https://alexhilton.github.io/blog/2025/12/25/compose-lottie-resources/"/>
    <updated>2025-12-25T00:00:00+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/12/25/compose-lottie-resources</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「From File to Fetch」，原文链接<a href="https://proandroiddev.com/from-file-to-fetch-ed6dca1122c8">https://proandroiddev.com/from-file-to-fetch-ed6dca1122c8</a>，由Katie Barnett发布于2025年11月23日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/1*qaaJ_zFlqmNT3CKeLpsvKw.gif" title="auto auto" ></a></p>

<!-- more -->


<p>_注意：我与 Airbnb 及其 Lottie 项目（Lottie 的 GitHub 仓库）没有任何关联。](<a href="https://github.com/airbnb/lottie-android">https://github.com/airbnb/lottie-android</a>)我最近刚在一个应用中实现了 Lottie，想分享一些示例来佐证<a href="https://lottie.airbnb.tech/#/android-compose">官方文档</a>。</p>

<h2>了解 Lottie</h2>

<p>之前，我写过关于动画的文章<a href="https://medium.com/bilue/expanding-dialog-in-jetpack-compose-a6be40deab86">https://medium.com/bilue/card-flip-animation-with-jetpack-compose-f60aaaad4ac9</a>，也<a href="https://www.youtube.com/watch?v=ol9zpXu3g1U">在</a>上讨论过这个主题，以及我是如何创建原生动画的。但有时，我们想要一些更具艺术性的效果，不需要移动屏幕上的可组合元素；这时，我们就需要一个预先构建好的动画。</p>

<p>Lottie 就派上用场了。</p>

<p>如果你之前没有使用过 Lottie，它是由 Airbnb 开发人员开发的一个库，可以解析 Adob​​e After Effects 动画并将其导出为 JSON 格式。其理念是，设计师可以创建复杂的动画，而无需手动渲染。有很多设计工具的插件可以帮助创建动画，例如 Figma。如果你具备一定的设计天赋（我没有！），上手也很容易。</p>

<p>Lottie 已经存在一段时间了，可以在多个平台上渲染，例如 iOS、Web、Windows，当然还有 Android。它可用于 <a href="https://lottie.airbnb.tech/#/android">XML 视图</a>，但我今天要重点介绍的是它与 Jetpack Compose 的集成。</p>

<p>官方文档在这里 <a href="https://lottie.airbnb.tech/#/android-compose">https://lottie.airbnb.tech/#/android-compose</a>，但它并没有详细介绍如何使用 <code>LottieCompositionSpec</code> 中的多种不同源类​​型，以最便捷的方式提供我们的 Lottie 文件。实际上，某些应用可能需要处理多种源类型，尤其是在后端调用中指定特定动画的情况下。</p>

<p>我们将逐步介绍每种类型，但首先，让我们使用字符串来保存 Lottie 动画数据，从而进行基本设置。</p>

<h2>字符串来源</h2>

<p>使用任何 SDK 的第一步都是添加依赖项：</p>

<pre><code class="kotlin">// build.gradle.kts
...

dependencies {
    ...
    implementation(libs.lottie.compose)
}

// libs.version.toml
[versions]
lottie = "6.6.6"

[libraries]
lottie-compose = { group = "com.airbnb.android", name = "lottie-compose", version.ref = "lottie" }
</code></pre>

<p>然后，在 Composable 中，我们需要创建 <code>LottieCompositionSpec</code>。对于 JSON 字符串，我们可以使用 <code>LottieCompositionSpec.JsonString(val jsonString: String)</code>，</p>

<p>并将字符串传递给它。接下来，使用 <code>rememberLottieComposition</code> 并传入 <code>spec</code> 来记住组合状态。最后，可以将此状态传递给 <code>LottieAnimation</code> 以显示动画。</p>

<pre><code class="kotlin">val lottieCompositionSpec = LottieCompositionSpec.JsonString(JSON_STRING)
val lottieComposition = rememberLottieComposition(
    spec = lottieCompositionSpec
)
LottieAnimation(composition = lottieComposition.value)

const val JSON_STRING = "{\"v\":\"4.10.1\",...\"bm\":0}]}"
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:280/format:webp/1*pILmCNmRVMiswfyiq3yviw.gif" alt="Lottie动画来自 https://github.com/airbnb/lottie-android" /></p>

<p>现在，将动画存储在字符串中并非最易读或可持续的方式，更好的选择是使用Lottie JSON文件。一种方法是将其存储在assets目录中……</p>

<h2>Asset文件</h2>

<p>我们可以将Lottie文件存储为<code>.json</code>或<code>.lottie</code>文件（它们是同一种文件，只是扩展名不同），并将其存储在<code>app/assets</code>目录中。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*RYfpCujExeKM_FC0XOedPA.png" alt="" /></p>

<p>这里唯一的区别是我们需要使用 <code>LottieCompositionSpec.Asset(val assetName: String)</code> 并传递 <code>assets</code> 目录下的路径（你可以根据需要进行组织）。</p>

<pre><code class="kotlin">val lottieCompositionSpecLottieFile = LottieCompositionSpec.Asset("animations/android_wave.lottie")
val lottieCompositionSpecJsonFile = LottieCompositionSpec.Asset("animations/android_wave.json")
</code></pre>

<p>类似地，我们可以使用 <code>LottieCompositionSpec.File(val fileName: String)</code> 从设备文件系统中的任何位置加载动画文件——只需确保应用程序已获得该文件的访问权限即可！</p>

<p>使用资源文件意味着我们无法获得编译时保护来确保文件存在，但我们可以使用 <code>res/raw</code> 目录。</p>

<h2>原始资源文件</h2>

<p>同样，这很简单，只需将文件添加到 <code>raw</code> 目录即可：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*I0jHURry7W04WUibyHvunA.png" alt="" /></p>

<p>现在，我们可以通过使用 <code>LottieCompositionSpec.RawRes</code> 和 <code>R.raw</code> 访问原始资源，从而获得编译时安全性。</p>

<pre><code class="kotlin">val lottieCompositionSpec = LottieCompositionSpec.RawRes(R.raw.android_wave)
</code></pre>

<p>最后，如果我们希望在需要时动态获取 Lottie 文件，而不是将其打包到应用程序中，我们可以从 URL 加载它。</p>

<h2>URL 来源</h2>

<p>与上述类似，我们可以使用 <code>LottieCompositionSpec.Url</code> 加载以 URL 形式存储的 Lottie 文件：</p>

<pre><code class="kotlin">val lottieCompositionSpec = LottieCompositionSpec.Url("https://url/AndroidWave.json")
</code></pre>

<p>如果一切顺利，用户网络连接良好，这当然很好，但我们需要确保能够处理任何错误。</p>

<h3>错误响应和添加加载状态</h3>

<p>动画加载也可能需要一些时间，尤其是在动画文件较大或用户网络连接不佳的情况下。为此，我们可以使用 <code>LottieCompositionResult</code> 来检测动画的状态。</p>

<p>当动画正在下载或解析时，<code>LottieCompositionResult.isLoading</code> 将为 true；当解析成功且合成已准备好显示时，<code>LottieCompositionResult.isSuccess</code> 将为 true。我们还有两个状态：<code>LottieCompositionResult.isComplete</code>，当 <code>isLoading</code> 为 false 时（无论组合是否成功），它将为 true；最后是 <code>LottieCompositionResult.isFailure</code>，当出现不可恢复的错误时（即下文讨论的 <code>onRetry</code> lambda 返回 <code>false</code> 时），它将为 true。</p>

<p>为了展示标准的加载、错误和成功行为，我们可以像这样使用 <code>isLoading</code> 和 <code>isSuccess</code>：</p>

<pre><code class="kotlin">if (lottieComposition.isLoading) {
    Box(
        contentAlignment = Alignment.Center,
        modifier = Modifier.height(100.dp)
    ) {
        CircularProgressIndicator()
    }
} else if (lottieComposition.isSuccess) {
    LottieAnimation(
        composition = lottieComposition.value,
        modifier = Modifier.height(100.dp)
    )
} else {
    Image(
        imageVector = Icons.Filled.Error,
        contentDescription = null,
        modifier = Modifier.height(100.dp)
    )
}
</code></pre>

<h3>重试动画加载错误</h3>

<p>Lottie 提供了一种简单易用的方法，可以使用 <code>rememberLottieComposition</code> 中的 <code>onRetry</code> 来重试动画加载。我们可以通过两种方式使用它：</p>

<p><strong>反复重试直到达到某个限制</strong></p>

<p>在构造 <code>rememberLottieComposition</code> 时，我们可以指定 <code>onRetry</code> lambda，并返回 <code>true</code> 以继续重试，返回 <code>false</code> 以停止重试。 <code>onRetry</code> 包含一个 <code>failCount</code> 参数。这允许应用重试次数限制或指数退避。例如：</p>

<pre><code class="kotlin">val lottieComposition = rememberLottieComposition(
    spec = lottieCompositionSpec,
    onRetry = { failCount, exception -&gt;
        Timber.d(exception, "Error loading animation: ${exception.message}")
        failCount &lt; 5
    }
)
</code></pre>

<p>这里我将动画设置为重试 5 次后停止。你可以在此 lambda 表达式中添加错误消息或其他任何有用的信息（但请使用上面描述的 <code>LottieCompositionResult.isLoading</code> 布尔值来显示加载行为，而不是在此处设置另一个变量）。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:280/format:webp/1*d9gomTwO-kr5K9mufbMinA.gif" alt="" /></p>

<p><strong>等待重试信号</strong></p>

<p>我们还可以允许动画等待重试，直到某个外部条件发生变化，例如按下按钮或恢复网络连接。</p>

<p>为此，我们使用 <code>rememberLottieRetrySignal</code>。</p>

<pre><code class="kotlin">val retrySignal = rememberLottieRetrySignal()
var url by remember { mutableStateOf("https://bad/url") }
val lottieCompositionSpec = LottieCompositionSpec.Url(url)
val lottieComposition = rememberLottieComposition(
    spec = lottieCompositionSpec,
    onRetry = { _, exception -&gt;
        Timber.d(exception, "Error loading animation: ${exception.message}")
        retrySignal.awaitRetry()
        false
    }
)
Column(...) {
    if (lottieComposition.isLoading) {
        ...
    } else if (lottieComposition.isSuccess) {
        LottieAnimation(
            composition = lottieComposition.value,
            modifier = Modifier.height(100.dp)
        )
    } else {
        ...
    }
    TextButton(onClick = {
        url = "https://url/AndroidWave.json"
        retrySignal.retry()
    }) {
        Text("Fix url &amp; retry")
    }
}
</code></pre>

<p>在这个简单的示例中，我将 URL 设置为无效 URL，然后在 <code>onRetry</code> 中，当发生错误时，我们可以使用记住的 <code>retrySignal</code> 来等待重试。 <code>retrySignal.awaitRetry()</code>。动画将保持加载状态，直到按钮点击时调用 <code>retrySignal.retry()</code>。如果你不希望保持加载状态，而是希望在重试之前显示错误信息，你可以完全省略 <code>retrySignal</code>，并更新已记住的 <code>url</code> 状态，这样 <code>LottieCompositionSpec</code> 将重新组合。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:280/format:webp/1*HZRs6-0_sZxmXImH999iVA.gif" alt="" /></p>

<h2>动画配置</h2>

<p>最后，动画加载正确后，我们可以使用一些其他配置项来优化动画效果。</p>

<p>虽然最好在 Lottie 文件本身（创建时完成）中控制这些动画行为，但你也可以通过以下方式调整动画的播放方式： <code>LottieAnimation</code> 本身是可组合的。要了解其功能，最好查看一些可用参数：</p>

<pre><code class="kotlin">// An excerpt from version 6.6.6 of the SDK
@Composable
fun LottieAnimation(
    clipSpec: LottieClipSpec? = null,
    speed: Float = 1f,
    iterations: Int = 1,
    reverseOnRepeat: Boolean = false,
    alignment: Alignment = Alignment.Center,
    contentScale: ContentScale = ContentScale.Fit,
    ... // + others for more advanced use, check out the SDK documentation
) {}
</code></pre>

<p>在这里，我们可以控制：</p>

<ul>
<li><p><code>clipSpec</code>：动画播放的帧</p></li>
<li><p><code>speed</code>：动画速度</p></li>
<li><p><code>iterations</code>：动画运行次数（使用 <code>LottieConstants.IterateForever</code> 可无限循环）</p></li>
<li><p><code>reverseOnRepeat</code>：循环播放后反向播放</p></li>
<li><p><code>alignment</code> 和 <code>contentScale</code>：就像图像一样，我们可以调整动画在指定范围内的布局。</p></li>
</ul>


<p>现在你可以了解 Lottie 的所有用法，请务必为你正在开发的应用程序选择最佳方案，并选择最便捷的方式从你的设计团队获取文件，而无需费力地在不同文件格式之间进行转换。</p>

<p>再见！现在！</p>

<p><img src="https://miro.medium.com/v2/resize:fit:600/1*AbjuxEFO34XUsPCAs-U-Kw.gif" alt="" /></p>

<p>你可以在我的 GitHub 仓库的 <a href="https://github.com/KatieBarnett/Experiments/tree/main/jc-lottie">jc-lottie</a> 模块中找到上述示例代码。</p>
]]></content>
  </entry>
  
</feed>
