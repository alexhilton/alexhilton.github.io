<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Compose | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/compose/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2026-01-30T12:59:19+00:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Jetpack Compose重组稳定性分析器]]></title>
    <link href="https://alexhilton.github.io/blog/2026/01/30/compose-stability-analyzer/"/>
    <updated>2026-01-30T00:00:00+00:00</updated>
    <id>https://alexhilton.github.io/blog/2026/01/30/compose-stability-analyzer</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Compose Stability Analyzer: Real-Time Stability Insights for Jetpack Compose」，原文链接<a href="https://medium.com/proandroiddev/compose-stability-analyzer-real-time-stability-insights-for-jetpack-compose-1399924a0a64">https://medium.com/proandroiddev/compose-stability-analyzer-real-time-stability-insights-for-jetpack-compose-1399924a0a64</a>，由Jaewoong Eum发布于2025年11月10日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/0*uLjBHnzVq5vM002Z" title="auto auto" ></a></p>

<!-- more -->


<p>Jetpack Compose 以其声明式编程范式革新了 Android UI 开发，但这种简洁性背后却隐藏着复杂性：理解重组合行为。当一个可组合元素不必要地进行重组合时，就会造成性能损失，CPU 周期会浪费在重新渲染实际上并未改变的 UI 上。挑战不仅在于识别这些问题，更在于理解它们发生的<strong>原因</strong>。</p>

<p>Compose 编译器一直在后台执行稳定性分析，确定哪些可组合元素在输入未发生变化时可以跳过重组合。但这种分析是在编译时静默进行的，开发者无法得知他们的可组合元素是否得到了优化。你可能编写出看似完美稳定的代码，但之后却发现类中一个 <code>var</code> 属性就足以导致整个代码不稳定，并波及整个 UI 树。</p>

<p><a href="https://github.com/skydoves/compose-stability-analyzer">Compose Stability Analyzer</a> 将这种隐藏的分析揭示出来。它是一套全面的工具集，可在 IDE 中提供实时可视化反馈，通过注解进行运行时代码重组追踪，并在 CI 流水线中进行稳定性验证。无需等到性能问题在生产环境中出现，你就能在编码过程中获得即时反馈，使稳定性分析自然而然地融入你的开发工作流程。</p>

<p>本文将探讨 Compose 稳定性分析器的工作原理，包括：IntelliJ 插件（为你的 IDE 提供可视化的稳定性指示器）、编译器插件（启用运行时重组跟踪）以及稳定性验证系统（防止回归问题影响生产环境）。</p>

<h2>理解稳定性问题：为什么可组合函数会重组</h2>

<p>在深入工具之前，值得了解 Compose 编译器实际上分析的内容。编译器会对每个可组合函数执行稳定性推断，回答两个问题：</p>

<p><strong>1. 这个可组合函数可以跳过吗？</strong></p>

<p>当编译器能够证明使用相同的输入重新组合该函数会产生相同的结果时，该可组合函数就是可跳过的。如果所有参数都是稳定的并且没有发生变化，可组合函数可以完全跳过重新组合，这是一个显著的性能优化。</p>

<p><strong>2. 该可组合项是否可重启？</strong></p>

<p>当一个可组合项可以独立重新组合而无需重新组合其父项时，该可组合项是可重启的。这使得重新组合更加细粒度。大多数可组合项都是可重启的，但带有某些修饰符的可组合项可能不是。</p>

<p>这里的关键概念是<strong>参数稳定性</strong>。当 Compose 编译器能够可靠地检测到参数值是否发生变化时，该参数是稳定的。规则非常复杂，如果你想深入了解这些规则，可以参考稳定性研究<a href="https://github.com/skydoves/compose-stability-inference">Compose 稳定性推断</a>。</p>

<h2>在 Android Studio 中进行可视化稳定性分析</h2>

<p>Compose Stability Analyzer IntelliJ 插件可将稳定性分析直接集成到 Android Studio 和 IntelliJ IDEA 中，在你编写代码时提供四层可视化反馈。</p>

<h3>安装和设置</h3>

<p>安装插件非常简单：</p>

<ol>
<li><p>打开 <strong>Android Studio</strong> → <strong>设置</strong> → <strong>插件</strong> → <strong>应用市场</strong>。</p></li>
<li><p>搜索“Compose Stability Analyzer”。</p></li>
<li><p>点击 <strong>安装</strong> 并重启 IDE。</p></li>
</ol>


<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*ukPWg_I6mOo9Drk0.png" alt="图1" /></p>

<p>安装完成后，插件会立即开始分析你的代码。无需任何配置，它可与任何 Compose 项目开箱即用。</p>

<h3>边栏图标：即时视觉反馈</h3>

<p>最直观的功能是边栏图标，即出现在可组合函数左侧边栏的彩色圆点：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*r3BFUwBTNNRfa2Y7.png" alt="图2" /></p>

<ul>
<li><p><strong>绿点</strong>：此可组合函数可跳过。所有参数均稳定，编译器可以优化重新组合。</p></li>
<li><p><strong>黄点</strong>：此可组合函数可重启，但不可跳过。它会在其父函数重新组合时重新组合。</p></li>
<li><p><strong>红点</strong>：此可组合函数的参数不稳定，无法进行优化。</p></li>
</ul>


<p>这种即时视觉反馈是快速发现 Jetpack Compose 性能问题的最佳方法。只需快速浏览左侧边栏，即可了解哪些可组合函数需要关注。如果屏幕上布满红点，则说明需要进行一些优化工作。</p>

<p>边栏图标的计算基于 Compose 编译器执行的相同稳定性分析。该插件会接入编译器的分析阶段并提取稳定性信息，然后在编辑器中以可视化的方式呈现。</p>

<p>但请注意，目前<a href="https://developer.android.com/develop/ui/compose/performance/stability/strongskipping">强跳过模式</a>默认大多已启用，因此所有可组合函数默认都可以跳过。你可以在插件配置中启用或禁用强跳过模式检查（工具 > Compose 稳定性分析器），该功能自 0.5.0 版本起也默认启用。如果你希望更加关注稳定性问题，可以根据实际情况将其关闭。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*UGJB2Jx_JKIv3_l0xrMCoQ.png" alt="图3" /></p>

<h3>悬停提示：了解原因</h3>

<p>边栏图标告诉你<strong>哪里</strong>出了问题，而悬停提示则告诉你<strong>为什么</strong>。当你将鼠标悬停在可组合函数名称上时，会显示详细的提示信息：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*s_KwLNlhbLEsoBko.png" alt="图4" /></p>

<p>提示信息显示：</p>

<ul>
<li><p>可组合函数是否可跳过和可重启</p></li>
<li><p>稳定参数与不稳定参数的总数</p></li>
<li><p>每个参数的详细稳定性信息</p></li>
<li><p>接收器稳定性（针对扩展函数）</p></li>
</ul>


<p>这种细致的反馈对于调试至关重要。你无需猜测哪个参数导致了不稳定，而是可以准确地看到哪些参数存在问题。</p>

<h3>内联参数提示：精细化可见性</h3>

<p>工具提示会在鼠标悬停时提供详细信息，而内联参数提示则无需任何交互即可提供持续可见性：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*g1f1L5ZuagOSKrA8.png" alt="图5" /></p>

<p>函数签名中每个参数类型旁边都会显示小徽章，指示该参数是稳定还是不稳定。这是最详细的反馈级别；每个参数的稳定性一目了然。</p>

<p>对于参数众多的函数，这有助于你快速浏览并识别有问题的参数，而无需打开工具提示。颜色编码与稳定性状态相对应：</p>

<ul>
<li><p>绿色徽章：参数稳定</p></li>
<li><p>红色徽章：参数不稳定</p></li>
<li><p>黄色徽章：稳定性将在运行时决定（因此可能稳定也可能不稳定）</p></li>
</ul>


<h3>代码检查：自动建议</h3>

<p>第四层反馈是主动代码检查。当插件检测到不稳定的组合体时，它可以：</p>

<ol>
<li><p><strong>用警告下划线突出显示问题</strong>。</p></li>
<li><p><strong>通过 Alt+Enter 菜单提供快速修复建议</strong>。</p></li>
<li><p><strong>提供添加注解（例如 <code>@TraceRecomposition</code>）</strong>以进行调试。</p></li>
<li><p><strong>提供抑制选项</strong>（如果不稳定是故意的）。</p></li>
</ol>


<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*o9_zJzFKaKfyLp_hiXCvoA.png" alt="图6" /></p>

<p>插件在此开始主动出击。它不仅会指出问题，还会提供解决方案。在不稳定的组合体上按下 Alt+Enter，你可能会看到如下选项：</p>

<ul>
<li><p>添加 <code>@TraceRecomposition</code> 以监控重新组合。</p></li>
<li><p>使用 <code>@Stable</code> 注解进行标记（请谨慎使用）。</p></li>
<li><p>抑制此函数的稳定性警告。</p></li>
</ul>


<h3>稳定性浏览器：包级分析</h3>

<p>除了单个函数分析之外，稳定性浏览器还提供整个代码库稳定性的概览：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*xPe6l50SxP3DQHEP.png" alt="图7" /></p>

<p>启用方法：</p>

<ol>
<li><p>安装 Compose Stability Analyzer Gradle 插件（下一节将介绍）。</p></li>
<li><p>转到“视图”→“工具窗口”→“Compose Stability Analyzer”。</p></li>
<li><p>构建项目并单击刷新按钮。</p></li>
</ol>


<p>浏览器以树状视图显示包结构，每个可组合函数都带有其稳定性状态的注解。你可以快速深入查找整个代码库中不稳定的函数，从而轻松地确定优化工作的优先级。</p>

<p>这在大型项目中尤其有用，因为手动检查每个可组合组件是不切实际的。该工具会为你的应用程序提供一份稳定性“成绩单”，显示哪些包存在最多的稳定性问题。</p>

<h3>自定义配置</h3>

<p>该插件具有高度可定制性。你可以调整颜色、启用或禁用特定的视觉指示器，并配置分析行为以满足你的偏好。</p>

<p>前往“设置”→“工具”→“Compose Stability Analyzer”（组合稳定性分析器）访问配置选项：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*l2CoGtjreY7XNdyK.png" alt="图8" /></p>

<p>你可以：</p>

<ul>
<li><p>更改边栏图标颜色以匹配你的 IDE 主题</p></li>
<li><p>分别启用或禁用内联提示、警告和边栏图标</p></li>
<li><p>配置强跳过模式分析</p></li>
<li><p>添加忽略类型模式以从分析中排除某些类</p></li>
<li><p>在测试源集中启用分析</p></li>
<li><p>设置自定义稳定性配置文件</p></li>
</ul>


<p>这种灵活性确保插件能够自然地融入你现有的工作流程，无论你偏好最小的视觉干扰还是最大的信息密度。</p>

<h2>Gradle 插件：运行时重组追踪</h2>

<p>IntelliJ 插件提供编译时可见性，而 Gradle 插件则支持<strong>运行时分析</strong>，能够精确追踪可组合组件在运行中的重组时间和原因。这是通过 <code>@TraceRecomposition</code> 注解实现的，该注解是一个编译器插件，它会在可组合组件中添加日志代码。</p>

<h3>安装和设置</h3>

<p>将以下依赖项添加到 <code>libs.versions.toml</code> 文件中：</p>

<pre><code class="toml">stability-analyzer = { id = "com.github.skydoves.compose.stability.analyzer", version = "0.5.0" }
</code></pre>

<p>接下来，将插件应用到根目录下的 <code>build.gradle.kts</code> 文件中，如下所示：</p>

<pre><code class="kotlin">alias(libs.plugins.stability.analyzer)
</code></pre>

<p>完成！该插件会自动将编译器插件应用到项目中的所有 Kotlin 编译任务。基本用法无需额外配置。</p>

<h3>Kotlin 版本兼容性</h3>

<p>该插件与 Kotlin 编译器紧密耦合，因此版本一致性至关重要。截至撰写本文时，<strong>你至少应使用 Kotlin 2.2.21 版本</strong>。使用不匹配的版本可能会导致编译错误。请始终使用与你的稳定性分析器版本完全匹配的 Kotlin 版本。你可以参考 Kotlin 版本映射表（<a href="https://github.com/skydoves/compose-stability-analyzer?tab=readme-ov-file#kotlin-version-mapping%EF%BC%89%E8%8E%B7%E5%8F%96%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E3%80%82">https://github.com/skydoves/compose-stability-analyzer?tab=readme-ov-file#kotlin-version-mapping%EF%BC%89%E8%8E%B7%E5%8F%96%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%E3%80%82</a></p>

<h3>@TraceRecomposition 注解</h3>

<p>安装插件后，你可以使用 <code>@TraceRecomposition</code> 注解任何可组合组件，以跟踪其重组行为：</p>

<pre><code class="kotlin">@TraceRecomposition
@Composable
fun ProductCard(
    product: Product,
    onClick: () -&gt; Unit
) {
    Card(onClick = onClick) {
        Text(product.name)
        Text("$${product.price}")
    }
}
</code></pre>

<p>当此可组合组件重组时，你将在 Logcat 中看到详细的日志：</p>

<pre><code class="bash">D/Recomposition: [Recomposition #1] ProductCard  
D/Recomposition:   ├─ product: Product stable (Product@abc123)  
D/Recomposition:   └─ onClick: () -&gt; Unit stable (Function@xyz789)  
D/Recomposition: [Recomposition #2] ProductCard  
D/Recomposition:   ├─ product: Product changed (Product@abc123 → Product@def456)  
D/Recomposition:   └─ onClick: () -&gt; Unit stable (Function@xyz789)
</code></pre>

<p>日志显示：</p>

<ul>
<li><p><strong>重组次数</strong>：此实例已重组的次数</p></li>
<li><p><strong>参数稳定性</strong>：每个参数是稳定还是不稳定</p></li>
<li><p><strong>变更检测</strong>：哪些参数发生了更改，显示新旧值</p></li>
<li><p><strong>身份跟踪</strong>：每个参数值的哈希码</p></li>
</ul>


<p>这些细粒度的信息对于调试至关重要。你可以准确地看到是哪个参数的更改触发了重组，从而帮助你了解应用程序的重组模式。</p>

<h3>使用标签参数进行过滤</h3>

<p>对于包含大量跟踪可组合组件的大型应用程序，日志可能会变得非常庞大。 <code>tag</code> 参数可以帮助你组织和筛选日志：</p>

<pre><code class="kotlin">@TraceRecomposition(tag = "product-list")
@Composable
fun ProductCard(product: Product, onClick: () -&gt; Unit) {
    // ...
}

@TraceRecomposition(tag = "user-profile")
@Composable
fun ProfileHeader(user: User) {
    // ...
}
</code></pre>

<p>现在日志包含以下标签：</p>

<pre><code class="bash">D/Recomposition: [Recomposition #1] ProductCard (tag: product-list)
D/Recomposition: [Recomposition #1] ProfileHeader (tag: user-profile)
</code></pre>

<p>你可以筛选 Logcat 以仅显示特定标签：</p>

<ul>
<li><p>按 <code>tag: product-list</code> 筛选，仅查看与产品相关的重组日志。</p></li>
<li><p>按 <code>tag: user-profile</code> 筛选，仅查看与用户个人资料相关的重组日志。</p></li>
</ul>


<p>这在与自定义日志记录器（将在下文介绍）结合使用时尤其有用，因为你可能只想将某些标签发送到分析服务。</p>

<h3>设置阈值以减少噪音</h3>

<p>大多数可组合组件在初始设置期间会重新组合 1-2 次，这是预期行为，<strong>并非性能问题</strong>。<code>threshold</code> 参数可以过滤掉这些噪音：</p>

<pre><code class="kotlin">@TraceRecomposition(threshold = 3)
@Composable
fun FrequentlyRecomposingScreen() {
    // Logs will only appear after the 3rd recomposition
}
</code></pre>

<p>这样可以将注意力集中在真正的问题上：用户交互期间不断重新组合的可组合组件，而不仅仅是初始设置。</p>

<p>一个实际用例：设置一个较高的阈值，并在超过该阈值时发送分析事件：</p>

<pre><code class="kotlin">@TraceRecomposition(tag = "checkout", threshold = 10)
@Composable
fun CheckoutScreen() {
    // If this recomposes 10+ times, something is wrong
}
</code></pre>

<p>然后在你的自定义日志记录器（参见下一节）中，你可以在超过阈值时发送 Firebase 事件，从而监控生产环境中的性能问题。</p>

<h3>配置日志系统</h3>

<p>默认情况下，<code>@TraceRecomposition</code> 不会记录任何日志，你需要在 <code>Application</code> 类中启用日志记录：</p>

<pre><code class="kotlin">class MyApp : Application() {
    override fun onCreate() {
        super.onCreate()

        // Enable only in debug builds
        ComposeStabilityAnalyzer.setEnabled(BuildConfig.DEBUG)
    }
}
</code></pre>

<p>这一点非常重要，如果你没有自定义日志记录器，<strong>务必使用</strong> <code>**BuildConfig.DEBUG**</code> 包裹，以避免生产构建中潜在的安全问题。</p>

<p><strong>自定义日志记录器：Logcat 之外的选择</strong> 默认日志记录器使用 Logcat，但你可以提供自定义实现，将日志发送到你想要的任何位置：</p>

<pre><code class="kotlin">ComposeStabilityAnalyzer.setLogger(object : RecompositionLogger {  
    override fun log(event: RecompositionEvent) {  
        // Send to Firebase, Crashlytics, custom analytics, etc.  
        if (event.recompositionCount &gt;= 10) {  
            FirebaseAnalytics.getInstance(this).logEvent("excessive\_recomposition") {  
                param("composable", event.composableName)  
                param("count", event.recompositionCount)  
                param("unstable\_params", event.unstableParameters.joinToString())  
            }  
        }  
    }  
})
</code></pre>

<p>因此，你甚至可以根据调试模式或发布模式设置不同的日志记录器。<code>RecompositionEvent</code> 包含：</p>

<ul>
<li><p><code>composableName</code>：函数名称。</p></li>
<li><p><code>tag</code>：来自 <code>@TraceRecomposition</code> 的标签。</p></li>
<li><p><code>recompositionCount</code>：重新组合的次数。</p></li>
<li><p><code>parameterChanges</code>：包含稳定性信息的参数变更列表。</p></li>
<li><p><code>unstableParameters</code>：不稳定参数名称列表。</p></li>
</ul>


<p>这支持强大的监控模式。你可以：</p>

<ul>
<li><p>针对过度重组的组合对象发送分析事件</p></li>
<li><p>在生产环境中跟踪性能指标（并采取适当的隐私保护措施）</p></li>
<li><p>构建显示重组模式的自定义仪表板</p></li>
<li><p>在测试环境中出现性能下降时发出警报</p></li>
</ul>


<p>以下是一个使用标签过滤日志内容的更贴近实际的示例：</p>

<pre><code class="kotlin">val tagsToLog = setOf("checkout", "product-list", "search")
ComposeStabilityAnalyzer.setLogger(object : RecompositionLogger {
    override fun log(event: RecompositionEvent) {
        if (BuildConfig.DEBUG) {
            // In debug, log everything
            Log.d("Recomposition", formatEvent(event))
        } else {
            // In release, only log tagged composables that exceed threshold
            if (event.tag in tagsToLog &amp;&amp; event.recompositionCount &gt;= 5) {
                // Send to analytics
                FirebaseAnalytics.getInstance(this).logEvent("recomposition_issue", ...)
            }
        }
    }
})
</code></pre>

<h3>理解日志</h3>

<p>让我们一起来了解如何解读日志。请看以下示例：</p>

<pre><code class="bash">D/Recomposition: [Recomposition #1] UserCard  
D/Recomposition:   ├─ user: User stable (User@abc123)  
D/Recomposition:   └─ onClick: () -&gt; Unit stable (Function@xyz789)
</code></pre>

<p><strong>这意味着：</strong></p>

<ul>
<li><p>这是此 <code>UserCard</code> 实例的首次重组。</p></li>
<li><p>两个参数都稳定。</p></li>
<li><p>这是初始重组的预期行为。</p></li>
</ul>


<pre><code class="bash">D/Recomposition: [Recomposition #2] UserCard  
D/Recomposition:   ├─ user: User changed (User@abc123 → User@def456)  
D/Recomposition:   └─ onClick: () -&gt; Unit stable (Function@xyz789)
</code></pre>

<p><strong>这意味着：</strong></p>

<ul>
<li><p>第二次重组。</p></li>
<li><p><code>user</code> 参数已更改（新实例）。</p></li>
<li><p><code>onClick</code> 保持不变（相同的 lambda 实例）。</p></li>
<li><p>这是正常现象，参数已更改，因此需要进行重组。</p></li>
</ul>


<pre><code class="bash">D/Recomposition: [Recomposition #3] UserCard (tag: user-profile)  
D/Recomposition:   ├─ user: MutableUser unstable (MutableUser@xyz789)  
D/Recomposition:   └─ Unstable parameters: [user]
</code></pre>

<p><strong>这意味着：</strong></p>

<ul>
<li><p>第三次重组。</p></li>
<li><p><code>user</code> 参数<strong>不稳定</strong>（可能具有 <code>var</code> 属性）。</p></li>
<li><p>即使 <code>user</code> 没有更改，此可组合对象也会在每次父级重组时重新组合。</p></li>
<li><p><strong>需要采取的措施</strong>：将 <code>MutableUser</code> 类修复为不可变。</p></li>
</ul>


<h2>稳定性验证：防止 CI 中的性能退化</h2>

<p>Compose 稳定性分析器最强大的功能并非可视化反馈或运行时跟踪，而是<strong>防止稳定性退化影响生产环境</strong>。稳定性验证系统的作用类似于 git diff，用于检查可组合组件的稳定性，如果稳定性下降，则 CI 构建失败。</p>

<h3>问题：静默的性能退化</h3>

<p>想象一下这样的场景：你花了数周时间优化你的应用。每个可组合组件都稳定、可跳过且运行速度快。然后，一位同事无意中修改了一个数据类：</p>

<pre><code class="kotlin">// Before (stable)
data class User(val name: String, val age: Int)

// After (unstable)
data class User(var name: String, var age: Int)
</code></pre>

<p>这一简单的更改会波及整个 UI 树。数十个原本可跳过的可组合组件变得不可跳过。性能退化了，但代码审查却未能发现，也没有任何明显的迹象表明出了问题。</p>

<p>稳定性验证可以防止这种情况发生。它会跟踪你的可组合组件的稳定性随时间的变化，并在稳定性下降时自动构建失败，强制在合并之前解决问题。</p>

<h3>工作原理：稳定性快照</h3>

<p>验证系统通过两个 Gradle 任务运行：</p>

<ul>
<li><p><code>**stabilityDump**</code>：创建一个包含所有可组合组件稳定性状态的 <code>.stability</code> 文件。</p></li>
<li><p><code>**stabilityCheck**</code>：将当前代码与基线进行比较，如果稳定性下降则构建失败。</p></li>
</ul>


<p>可以这样理解：</p>

<ul>
<li><p><code>stabilityDump</code> = &ldquo;保存当前状态&rdquo;</p></li>
<li><p><code>stabilityCheck</code> = &ldquo;自上次保存以来是否有任何更改？&rdquo;</p></li>
</ul>


<h3>步骤 1：创建基线</h3>

<p>编译项目后，运行：</p>

<pre><code class="bash">./gradlew :app:compileDebugKotlin  
./gradlew :app:stabilityDump
</code></pre>

<p>这将生成 <code>app/stability/app.stability</code> 文件：</p>

<pre><code class="kotlin">@Composable  
public fun com.example.UserCard(user: com.example.User): kotlin.Unit  
  skippable: true  
  restartable: true  
  params:  
    - user: STABLE (immutable data class)  

@Composable  
public fun com.example.ProductList(items: kotlin.collections.List&lt;com.example.Product\&gt;): kotlin.Unit  
  skippable: true  
  restartable: true  
  params:  
    - items: STABLE (immutable collection with stable elements)
</code></pre>

<p>此文件易于阅读，并准确显示了编译器对每个可组合组件的判断结果。它是应用程序稳定性状态的完整快照。</p>

<p><strong>将此文件提交到 Git：</strong></p>

<pre><code class="bash">git add app/stability/app.stability  
git commit -m "Add stability baseline"  
git push
</code></pre>

<p>现在，团队中的每个人都拥有相同的基线。</p>

<h3>步骤 2：检查回归问题</h3>

<p>在你的 CI 流水线中运行：</p>

<pre><code class="bash">./gradlew :app:compileDebugKotlin  
./gradlew :app:stabilityCheck
</code></pre>

<p>如果没有任何变化，任务成功：</p>

<pre><code class="bash">✅ Stability check passed.
</code></pre>

<p>如果稳定性出现回归，任务失败：</p>

<pre><code class="bash">❌ Stability check failed!  

The following composables have changed stability:  

~ com.example.UserCard(user): parameter 'user' changed from STABLE to UNSTABLE  

If these changes are intentional, run './gradlew stabilityDump' to update the baseline.
</code></pre>

<p>构建失败，在问题修复或明确接受回归之前，拉取请求将无法合并。</p>

<h3>检测到的变更类型</h3>

<p>验证器会检测到四种类型的变更：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1374/1*IwkocOj8s1No8lIphL1JIQ.png" alt="图9" /></p>

<p>这种全面的跟踪机制确保<strong>任何</strong>稳定性变更都清晰可见，并需要进行相应的决策。</p>

<h3>CI/CD 集成</h3>

<p>将稳定性验证添加到你的 GitHub Actions 工作流：</p>

<pre><code class="bash">name: Android CI  

on: [push, pull_request]  
jobs:  
  build:  
    runs-on: ubuntu-latest  
    steps:  
      - uses: actions/checkout@v3  
      - name: Set up JDK 17  
        uses: actions/setup-java@v3  
        with:  
          java-version: '17'  
          distribution: 'temurin'  
      - name: Build project  
        run: ./gradlew :app:compileDebugKotlin  
  stability_check:  
    name: Compose Stability Check  
    runs-on: ubuntu-latest  
    needs: build  
    steps:  
      - name: Check out code  
        uses: actions/checkout@v5.0.0  
      - name: Set up JDK  
        uses: actions/setup-java@v5.0.0  
        with:  
          distribution: 'zulu'  
          java-version: 21  
      - name: Run stability check  
        run: ./gradlew stabilityCheck
</code></pre>

<p>现在，每个拉取请求都会自动进行检查。如果稳定性下降，则拉取请求将无法合并。</p>

<h3>配置选项</h3>

<p>你可以自定义要跟踪的内容：</p>

<pre><code class="kotlin">// In your build.gradle.kts
composeStabilityAnalyzer {
    stabilityValidation {
        enabled.set(true)
        outputDir.set(layout.projectDirectory.dir("stability"))
        includeTests.set(false) // Exclude test code

        // Ignore specific packages
        ignoredPackages.set(listOf("com.example.internal"))
        // Ignore specific classes (e.g., previews)
        ignoredClasses.set(listOf("PreviewComposables"))
        // Ignore entire modules
        ignoredProjects.set(listOf("benchmarks", "examples"))
    }
}
</code></pre>

<p>这对于排除不需要稳定性跟踪的代码非常有用，例如预览组合或调试屏幕。</p>

<h3>排除特定组合</h3>

<p>使用 <code>@IgnoreStabilityReport</code> 从验证中排除单个组合：</p>

<pre><code class="kotlin">@IgnoreStabilityReport
@Preview
@Composable
fun UserCardPreview() {
    UserCard(user = User("John", 30))
}
</code></pre>

<p>预览组合不会出现在生产版本中，因此它们的稳定性无关紧要。排除它们可以减少稳定性报告中的噪音。</p>

<h3>多模块项目</h3>

<p>对于包含多个模块的项目，每个模块都会有自己的 <code>.stability</code> 文件：</p>

<pre><code class="bash">project/  
├── app/stability/app.stability  
├── feature-auth/stability/feature-auth.stability  
└── feature-profile/stability/feature-profile.stability
</code></pre>

<p>在根目录运行 <code>stabilityCheck</code> 来检查所有模块：</p>

<pre><code class="bash">./gradlew stabilityCheck
</code></pre>

<p>或者检查单个模块：</p>

<pre><code class="bash">./gradlew :feature-auth:stabilityCheck
</code></pre>

<h3>接受有意为之的回归</h3>

<p>有时稳定性回归是有意为之的，例如你正在重构代码并暂时接受较低的稳定性。在这种情况下，请更新基线：</p>

<pre><code class="bash">./gradlew :app:stabilityDump  
git add app/stability/app.stability  
git commit -m "Accept stability regression for UserCard (refactoring in progress)"  
git push
</code></pre>

<p>这会在 Git 历史记录中创建一个<strong>已记录的决策</strong>。回归不再是默默进行的，而是明确且可跟踪的。</p>

<h2>性能考量和最佳实践</h2>

<p>虽然这些工具功能强大，但仍有一些性能特性和最佳实践需要注意。有人问我是否需要让<em>每个</em>类型都稳定，答案绝对是“不需要”。</p>

<p>由于现在有了强跳过模式，每个可组合函数都可以跳过，这本身就能优化稳定性。即使这个插件可能会提示“不稳定”或“运行时稳定性”，但你实际上并不需要为每个可组合函数都进行修复。我们来看一个简单的例子。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*4ZtAbwb8_5tRAR112kL1HA.png" alt="图10" /></p>

<p>如果你查看 compose-material3 库中的 <code>Icon</code> 可组合函数，这个插件会提示它不稳定，因为它包含运行时参数。但是，<code>painter</code> 参数通常是通过 <code>painterResource</code> 函数初始化的，如下所示：</p>

<pre><code class="kotlin">val painter = painterResource(R.drawable.)
Icon(painter = painter, contentDescription = null)
</code></pre>

<p>如果你查看 <code>painterResource</code> 的内部逻辑，你会发现它本质上是稳定的。它内部使用 <code>remember</code> 将值缓存到内存中，所以你可以把它看作是一个小小的权衡：<em>“我会用一点内存来存储这个不稳定的实例，这样我就不必触发不必要的重新组合。”</em></p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*sRvsZMkusaZuOMjGskhz0A.png" alt="图11" /></p>

<p>关于不可变集合还有一个常见的误解——认为仅仅使用 <code>ImmutableList</code> 而不是普通的 <code>List</code> 就能提升性能。 <strong>并非总是如此。</strong></p>

<p>不妨这样想：如果你有一个包含 1000 个大型对象的列表，然后你将其转换为不可变列表，那么你的可组合组件就变得可以忽略了。但是，每次重新组合时，Compose 都会对列表中的每个元素运行 <code>equals()</code> 函数，以检查新实例是否与之前的实例匹配。在某些情况下，这实际上会比重新渲染一个只显示其中五个元素的轻量级 UI 更<strong>影响性能</strong>。</p>

<p>因此，<strong>稳定性会根据具体情况产生截然不同的影响</strong>，试图让整个 UI 保持稳定通常是不必要的，也是徒劳的。我希望这个插件不会加重你对稳定性的担忧，而是能够帮助你更有效地调试实际的性能问题，并做出更明智、更数据驱动的决策，而无需过度考虑稳定性。</p>

<h2>结论</h2>

<p>在本文中，我们探索了 Compose 稳定性分析器 (Compose Stability Analyzer) (<a href="https://github.com/skydoves/compose-stability-analyzer">https://github.com/skydoves/compose-stability-analyzer</a>)，了解了它如何通过三个互补的工具将 Compose 隐藏的稳定性分析可视化：IntelliJ 插件用于在开发过程中提供可视化反馈，Gradle 插件用于运行时重组追踪，以及稳定性验证系统用于防止持续集成 (CI) 中的回归。</p>

<p>IntelliJ 插件将稳定性从一个不可见的编译时概念转化为可感知的事物，通过边栏图标、工具提示和内联提示，使稳定性问题一目了然。<code>@TraceRecomposition</code> 注解弥合了编译时分析和运行时行为之间的鸿沟，让你可以准确地了解可组合组件何时以及为何重新组合。稳定性验证系统则起到安全网的作用，确保你精心设计的优化不会随着代码库的演进而悄然失效。</p>

<p>这些工具共同作用，使稳定性分析成为你开发工作流程中自然而然的一部分。你无需等待性能问题显现，即可在编码过程中立即发现它们。你无需猜测哪个参数导致了重新组合——日志会准确地告诉你哪些参数发生了变化。你也无需手动审查每个 PR 是否存在稳定性回归，CI 流水线会自动完成这项工作。</p>

<p>理解稳定性是编写高性能 Compose 应用程序的基础。借助 Compose 稳定性分析器，这种理解变得轻松、直观、即时且有效。</p>

<p>祝你编码愉快！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compose GPU加速特效：带缩放的故障效果]]></title>
    <link href="https://alexhilton.github.io/blog/2026/01/22/glitch-at-scale-effects/"/>
    <updated>2026-01-22T00:00:00+00:00</updated>
    <id>https://alexhilton.github.io/blog/2026/01/22/glitch-at-scale-effects</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「GPU-Accelerated Effects: Glitch at Scale」，原文链接<a href="https://medium.com/@konstantinzolotov/gpu-accelerated-effects-glitch-at-scale-e59216afd1e8">https://medium.com/@konstantinzolotov/gpu-accelerated-effects-glitch-at-scale-e59216afd1e8</a>，由Konstantin Zolotov发布于2025年11月9日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*l67g57hjllhQ5gkwTLU2nA.gif" title="auto auto" ></a></p>

<!-- more -->


<p>几周前，我看到了Sina Samaki撰写的一篇关于使用Jetpack Compose制作故障效果的<a href="https://www.sinasamaki.com/glitch-effect-in-jetpack-compose/">精彩文章</a>。作为一个喜欢钻研底层技术的人，我看到了使用Android AGSL着色器重现这种效果并比较两种实现方式的绝佳机会。</p>

<p>在图形处理方面，选择合适的工具至关重要，因为很容易达到性能瓶颈，而扩展解决方案则变得困难。这里的情况是否如此呢？让我们一探究竟！</p>

<p>做好准备，我们将深入底层。</p>

<h2>着色器(Shader)的本质</h2>

<p>那么，着色器究竟是什么？</p>

<p>着色器是一种直接在 GPU 上执行的程序，并且可以并行执行。</p>

<p>着色器通常使用一种特殊的类 C 语言编写，在 Android Compose 中，这种语言是 AGSL——Android 图形着色语言。</p>

<p>我不会重复<a href="https://developer.android.com/develop/ui/views/graphics/agsl">官方指南</a>的内容，而是会简单介绍一下 GPU 以及一种新的着色器编程思维模型。</p>

<p>那么，它与 CPU 有什么区别呢？ CPU 和 GPU 的主要区别基本上如下：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1250/1*nNt7dZ0re2yZI33o62kKtg.png" alt="https://developer.nvidia.com/blog/cuda-refresher-reviewing-the-origins-of-gpu-computing/" /></p>

<p>CPU：</p>

<ul>
<li>更复杂</li>
<li>专为执行大量不同任务的大型程序而设计</li>
<li>MIMD（多指令多数据流）</li>
</ul>


<p>GPU：</p>

<ul>
<li>简单得多（没有分支预测，缓存更小）</li>
<li>专为对各种数据执行完全相同操作的小型程序而设计</li>
<li>更多核心 = 更高的并行性</li>
<li>SIMD（单指令多数据流）</li>
</ul>


<p>当然，CPU 也有 SIMD 扩展，但规模远不及 GPU。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*T5jVrRJztzWADaqiAFNwzQ.png" alt="https://developer.nvidia.com/blog/cuda-refresher-reviewing-the-origins-of-gpu-computing/" /></p>

<blockquote><p>GPU 非常适合对数百万像素执行相同的操作</p></blockquote>

<p>这里存在一个非常重要的<strong>思维模型转变</strong>：以前你可以在画布的任意位置绘制，而现在你面对的是一幅图像，你可以对图像的任何部分进行采样（读取），但输出结果始终是一个像素。每个目标像素都会执行相同的着色器。这类似于一个纯函数，不会产生任何副作用，因此像素仅取决于其坐标和提供的 uniform 变量。</p>

<p>让我们开始实现吧，但首先，分析<a href="https://www.sinasamaki.com/glitch-effect/">原始合成版本</a>中的关键点，并将这些想法转化为着色器思维模型。</p>

<p>关键的动画驱动因素是步长。动画器会在 500 毫秒的周期内，将浮点数值从 10 递减到 0。步长状态为整数，由于浮点数会被转换为整数，因此共有 11 个步长。</p>

<pre><code class="kotlin">var step by remember { mutableStateOf(0) }
LaunchedEffect(key) {
   Animatable(10f)
       .animateTo(
           targetValue = 0f,
           animationSpec = tween(
               durationMillis = 500,
               easing = LinearEasing,
           )
       ) {
           step = this.value.roundToInt()
       }
}
</code></pre>

<p>此外，还有一个名为强度的参数，它基于步长计算：</p>

<pre><code class="kotlin">val intensity = step / 10f
</code></pre>

<p>因此，强度是一个数值序列 [1.0, 0.9, …, 0.0]。</p>

<p>下一个关键点是切片：</p>

<pre><code class="kotlin">for (i in 0 until slices) {
    translate(
        left = if (Random.nextInt(5) &lt; step)
            Random.nextInt(-20..20).toFloat() * intensity
        else
            0f,
    ) {
        scale(
            scaleY = 1f,
            scaleX = if (Random.nextInt(10) &lt; step)
                1f + (1f * Random.nextFloat() * intensity)
            else
                1f,
        ) {
            clipRect(
                top = (i / slices.toFloat()) * size.height,
                bottom = (((i + 1) / slices.toFloat()) * size.height) + 1f,
            ) {
                layer {
                    drawLayer(graphicsLayer)
                    if (Random.nextInt(5, 30) &lt; step) {
                        drawRect(
                            color = glitchColors.random(),
                            blendMode = BlendMode.SrcAtop,
                        )
                    }
                }
            }
        }
    }
}
</code></pre>

<p>对于每个切片，都会应用以下变换：</p>

<p><strong>1. 平移</strong></p>

<ul>
<li>在步骤 10 到 5 期间，每个切片会随机移动 -20 到 20 范围内的像素。请注意，每一步操作都会使该范围缩小，因为它会乘以强度。</li>
<li>在步骤 4 到 0 中也会发生类似的情况，但并非每个切片都会移动，有些切片不会被移动。</li>
</ul>


<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LBlZyvahPz-Si5eR3IWjvw.gif" alt="" /></p>

<p><strong>2. 水平缩放</strong> 每个切片都会根据强度乘以 1.0 到 2.0 范围内的随机数进行缩放，每一步操作都会降低缩放的概率和大小。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*5Q2onueDpzVVChVXfV_QOg.gif" alt="" /></p>

<p><strong>3.彩色条纹</strong></p>

<ul>
<li>在步骤 10 到 5 中，在每个切片上绘制一条随机彩色条纹，初始概率为 0.2，到步骤 5 时降至 0。</li>
<li>步骤 5 之后不再绘制条纹。</li>
</ul>


<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*l67g57hjllhQ5gkwTLU2nA.gif" alt="" /></p>

<p>因此，总体而言，动画在前几个步骤中最具表现力，并在后半部分逐渐趋于稳定。</p>

<p>对于着色器而言，强度应该足以驱动动画，而无需使用步骤。在 Kotlin 代码中，我仍然会使用步骤 + 强度，仅仅是为了尽可能地复现动画效果，并用于未来的性能测试。</p>

<p><strong>思维模型转变：</strong> 着色器是逐像素执行的，但动画会将相同的变换应用于像素组（在本例中为切片）。为了在着色器中实现这一点，我们需要对整个切片进行完全相同的计算。还记得纯函数的相似性吗？它在这里非常有用，因为要得到相同的结果，我们只需要应用相同的参数！</p>

<p>具有相同变换的像素组就是一个切片：</p>

<pre><code class="glsl">uniform shader image;
uniform float2 imageSize; // Shader area size in pixels
uniform float intensity;
uniform int slices;// fragCoord — pixel coordinates
half4 main(float2 fragCoord) {
    // Create horizontal slices
    float sliceHeight = imageSize.y / float(slices); // Height of each slice in pixels
    float sliceY = floor(fragCoord.y / sliceHeight) * sliceHeight; // Start coordinates for each slice

    // ...
}
</code></pre>

<p>让我们一步一步来，从平移开始。</p>

<h2>平移</h2>

<p>步骤 10 到 5 等价于强度从 1.0 到 0.5，每次递减 0.1。因此，我们将以此为基础来移动切片：</p>

<pre><code class="glsl">// Simple random functions
float random(float seed) {
  return fract(sin(seed) * 100000.0);
}

float random(float2 st) {
    return fract(sin(dot(st.xy, float2(12.9898, 78.233))) * 43758.5453123);
}

// Determine how much this slice should be displaced
float displace(float sliceY, float intensity) {
    float rnd = random(float2(sliceY, intensity));

    float shouldDisplace;
    if (intensity &lt; 0.5 &amp;&amp; intensity &gt; rnd * 0.4) {
        shouldDisplace = 0.0;
    } else {
        shouldDisplace = 1.0;
    }

    return (rnd - 0.5) * 40.0 * intensity * shouldDisplace
}
</code></pre>

<p>这里发生了什么？</p>

<p>首先，是随机性。由于着色器本身没有随机性，因此通常使用一些函数来模拟随机性。这两个函数都会返回一个介于 0（含）和 1（不含）之间的浮点值。在这种情况下，“随机”值对于每个切片-帧组合都是唯一的。对于给定帧，均匀强度对于所有调用（= 输出像素）都是相同的，同一组像素的切片坐标也相同。结合切片起始坐标，这个值对于每一帧的每个切片都是不同的。</p>

<p>接下来，如果强度超过 0.5，<code>shouldDisplace</code> 因子会立即设置为 1.0，这意味着切片需要进行位移。否则，<code>intensity &gt; rnd * 0.4</code> 会导致执行位移的概率下降，类似于原始实现中的 <code>Random.nextInt(5) &lt; step</code>。</p>

<p>最后一行只是简单的算术运算。这里我将 0 到 1 的伪随机值转换为 -20 到 20，然后像原始实现一样乘以强度，并在发生位移时应用该因子。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*LBlZyvahPz-Si5eR3IWjvw.gif" alt="" /></p>

<h2>缩放</h2>

<p>屏幕空间缩放本质上是指相对于枢轴点（本例中为水平中心）调整像素采样坐标。由于我们是从源图像读取数据，因此实际上是移动了采样视口。</p>

<pre><code class="glsl">float2 scale(float2 coord, float yMin, float yMax, float screenWidth, float intensity) {
   float rnd = random(float2(yMin, intensity));

   if (coord.y &gt;= yMin &amp;&amp; coord.y &lt;= yMax &amp;&amp; rnd &lt; intensity) {
       float centerX = screenWidth * 0.5;

       float localX = coord.x - centerX;
       float scaleFactor = 1f + (intensity * rnd);
       localX /= scaleFactor;

       float scaledX = localX + centerX;

       return float2(scaledX, coord.y);
   }

   return coord;
}
</code></pre>

<blockquote><p>附注：为了演示，我尽量简化了逻辑。生产环境中的着色器代码通常会使用更高级的技术来避免分支，因为像上面示例中那样的不平衡分支会迫使 GPU 串行执行两条路径，从而破坏并行性。要以优化的方式实现缩放函数并非易事，所以我采用了一种简单的方法。</p></blockquote>

<p>再次强调，对于每一帧的每个切片，随机数都是唯一的，这意味着特定切片中的每个像素都会获得相同的值。因此，<code>rnd &lt; intensity</code> 会降低概率，类似于 <code>Random.nextInt(10) &lt; step</code>。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*5Q2onueDpzVVChVXfV_QOg.gif" alt="" /></p>

<h2>彩色条纹</h2>

<p>最简单的部分。类似地，如果应用了色带，则创建相同的概率，然后选择 3 种颜色中的一种。可以使用非硬编码值，但这需要一些额外的工作，因此 Compose 版本在这方面更灵活。</p>

<pre><code class="glsl">float rnd = random(float2(intensity, sliceY));
if ((rnd * 2.5 + 0.5) &lt; intensity) {
   if (rnd &gt; 0.67) {
       return yellow;
   } else if (rnd &gt; 0.33) {
       return red;
   } else {
       return cyan;
   }
} else {
   float2 scaled = scale(displaced, sliceY, sliceY + sliceHeight, imageSize.y, intensity);
   return image.eval(scaled);
}
</code></pre>

<p>将所有内容组合在一起后，结果如下：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*OPPsJbjpmUd94xsp4vfG9A.gif" alt="" /></p>

<p>存在一个明显的问题：叠加层的颜色始终为青色。这是因为伪随机函数对相同的输入返回相同的值——这是设计上的确定性行为。解决方案：在 Kotlin 端生成真正的随机数，并将其作为 uniform 变量传递。</p>

<pre><code class="glsl">-float rnd = random(float2(intensity, sliceY));
+float rnd = random(float2(intensity * realRandom, sliceY));
 if ((rnd * 2.5 + 0.5) &lt; intensity) {
-if (rnd &gt; 0.67) {
+if (realRandom &gt; 0.67) {
         return yellow;
-} else if (rnd &gt; 0.33) {
+} else if (realRandom &gt; 0.33) {
         return red;
     } else {
         return cyan;
     }
} else {
    float2 scaled = scale(displaced, sliceY, sliceY + sliceHeight, imageSize.y, intensity);
    return image.eval(scaled);
}
</code></pre>

<p>应用适当的随机性后，整个过程与原始行为非常接近：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:640/1*YMfnRYhOSI-v84eR04hHaw.gif" alt="你能猜出哪个是 compose，哪个是 AGSL 吗？" /></p>

<p>完整代码发布于<a href="https://gist.github.com/MightySeal/97687eaaf5eeeb1322a9f6f837dc5c35">此处</a>。</p>

<p>当然，在进行图形编程时，至少需要进行一些粗略的性能观察。为此，我将使用我的 Pixel 7，<a href="https://developer.android.com/topic/performance/rendering/inspect-gpu-rendering">启用 HWUI 渲染图表</a>，并稍作修改代码：使用 <a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/package-summary#infiniteRepeatable(androidx.compose.animation.core.DurationBasedAnimationSpec,androidx.compose.animation.core.RepeatMode,androidx.compose.animation.core.StartOffset)">infiniteRepeatable</a> 规范实现循环动画，并使用发布版本。Pixel 7 实际上非常适合这项任务，因为它并非高端设备，如果它在 Pixel 7 上有效，那么在性能更高的设备上也应该有效。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:960/1*MVOJpYGsNIPWI6n8scBolQ.gif" alt="" /></p>

<p><img src="https://miro.medium.com/v2/resize:fit:960/1*yybZA5FCXvybv6LXD9Uh5Q.gif" alt="" /></p>

<p>左侧为着色器，右侧为Compose</p>

<p>乍一看，这两个图表似乎很相似，但实际上存在一个问题：当前的实现方式隐式地限制了帧速率。动画会将浮点数值从 10 递减到 0，但状态更新时会使用四舍五入为整数的值。这意味着在 500 毫秒内只有 11 帧动画。这对于故障着色器来说非常方便，因为较低的帧速率也会增强故障效果。要消除这个限制，我们只需要将步长类型从整数 (Int) 更改为浮点数 (Float)，并使用不进行四舍五入的可动画值即可。</p>

<pre><code class="kotlin">-var step by remember { mutableStateOf(0) }
+var step by remember { mutableFloatStateOf(0f) }
LaunchedEffect(key) {
   Animatable(10f)
       .animateTo(
           targetValue = 0f,
           animationSpec = tween(
               durationMillis = 500,
               easing = LinearEasing,
           )
       ) {
-          step = this.value.roundToInt()
+          step = this.value
       }
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:960/1*J7Y6FenkNZAPglmKtyvNNA.gif" alt="" /></p>

<p><img src="https://miro.medium.com/v2/resize:fit:960/1*a7xb39t8tXR5APsArXk5aw.gif" alt="" /></p>

<p>左侧为着色器，右侧为Compose，无帧数限制</p>

<p>移除帧数限制后，性能提升已经非常明显。我们来做个压力测试。如果将动画应用于整个列表会发生什么？或者切片数量增加会发生什么？让我们拭目以待！</p>

<p><img src="https://miro.medium.com/v2/resize:fit:800/1*6PkVLOndrbCYVaV8ApJtzA.gif" alt="" /></p>

<p><img src="https://miro.medium.com/v2/resize:fit:800/1*DdiLlkVWT4BMY6sY2mVxVg.gif" alt="" /></p>

<p>左侧着色器，右侧Compose，无帧数限制，应用于整个列表</p>

<p><img src="https://miro.medium.com/v2/resize:fit:800/1*Gv-vtC5MNtcQ4bmYB__4rA.gif" alt="" /></p>

<p><img src="https://miro.medium.com/v2/resize:fit:800/1*BcyPMHcnOc9HvPELpVoF9g.gif" alt="" /></p>

<p>左侧着色器，右侧Compose，无帧数限制，应用于整个列表100 个切片</p>

<h2>结论</h2>

<p>Compose 非常适合用于复杂动画的原型设计，因为它可以使用熟悉的工具轻松实现。此外，值得一提的是，它适用于所有设备。</p>

<p>另一方面，着色器提供了性能更高、更稳定的渲染。在这种情况下，使用的切片数量无关紧要——无论是 20 个还是 500 个，计算量都没有区别，而纯 Compose 版本对此非常敏感，并且会随着切片数量的增加而线性增长。</p>

<p>此外，由于 AGSL 着色器只是在运行时临时编译的文本，因此理论上可以从后端更新这些动画。</p>

<p>但是，还有一个很大的问题：着色器从 Android 13 开始可用，因此根据 Android Studio 操作系统的发行情况，大约一半的设备将能够支持这种方法。当然，这种情况会随着时间的推移而改变，我希望我们能够利用着色器充分发挥图形编程的强大功能！</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1232/1*Eh3q8fmkEx9BdA5FNR11CA.jpeg" alt="" /></p>

<p>这是我的<a href="https://bento.me/mightyseal">bento</a>，如果你想联系我、聊天或讨论，欢迎来找我！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jetpack Compose内部的不同节点类型]]></title>
    <link href="https://alexhilton.github.io/blog/2026/01/12/node-types-in-jetpack-compose/"/>
    <updated>2026-01-12T00:00:00+00:00</updated>
    <id>https://alexhilton.github.io/blog/2026/01/12/node-types-in-jetpack-compose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「The Different Node Types in Jetpack Compose」，原文链接<a href="https://www.grokkingandroid.com/the-different-node-types-in-jetpack-compose/">https://www.grokkingandroid.com/the-different-node-types-in-jetpack-compose/</a>，由Wolfram Rittmeyer发布于2025年12月30日。</p></blockquote>

<p><a href=""><img src="https://www.grokkingandroid.com/wordpress/wp-content/uploads/2025/12/ComposeUiNode-700x389.png" title="auto auto" ></a></p>

<!-- more -->


<p>如果你仔细观察 Compose，你会发现它很奇怪。你会发现很多函数都没有返回值。然而，<a href="https://developer.android.com/develop/ui/compose/mental-model">Android 文档</a>却说：</p>

<blockquote><p>可组合函数会生成 UI 层级结构。</p></blockquote>

<p>这到底是什么意思呢？从函数式编程的角度来看，你那些看似无害的无状态可组合函数实际上会产生大量的<em>副作用[1]</em>。其中就包括创建节点。</p>

<p>有时你可能会创建一些可组合函数来自己创建节点。但更多时候，你会直接委托给其他可组合函数来<em>创建节点[2]</em>。</p>

<p>那么，让我们来看看有哪些节点，它们的创建位置以及它们的用途：</p>

<ul>
<li>ComposeUiNode</li>
<li>LayoutNode</li>
<li>Modifier.Node</li>
<li>SemanticsNode</li>
</ul>


<h2>ComposeUiNode</h2>

<p>当你深入研究<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/layout/package-summary#Layout(androidx.compose.ui.Modifier,androidx.compose.ui.layout.MeasurePolicy)"><code>Layout</code></a>可组合对象时，你会发现它调用了<code>ReusableComposeNode[3]</code>:</p>

<pre><code class="kotlin">@Composable
@UiComposable
inline fun Layout(modifier: Modifier = Modifier, measurePolicy: MeasurePolicy) {
    val compositeKeyHash = currentCompositeKeyHash
    val materialized = currentComposer.materialize(modifier)
    val localMap = currentComposer.currentCompositionLocalMap
    ReusableComposeNode&lt;ComposeUiNode, Applier&gt;(
        factory = ComposeUiNode.Constructor,
        update = {
            set(measurePolicy, SetMeasurePolicy)
            set(localMap, SetResolvedCompositionLocals)
            set(materialized, SetModifier)
            set(compositeKeyHash, SetCompositeKeyHash)
        },
    )
}
</code></pre>

<p><strong><code>ReusableComposeNode</code>本身并不是一个节点。</strong> 上面的代码中并没有构造函数调用，而是对另一个可组合对象的调用。第八行的工厂参数看似无关紧要，但实际上非常重要。因为最终会创建节点的就是这个函数。它会创建一个 <code>ComposeUiNode</code>。</p>

<p><code>ReusableComposeNode</code> Composable 与 Compose 运行时紧密相关。这段代码告诉 Composer 应该启动一个 <code>GroupKind.ReusableNode</code> 类型的新组，然后代码会创建一个新节点，或者在重新组合时重用现有节点。最后，当使用 update 函数参数时，它会设置节点的内容：</p>

<pre><code class="kotlin">@Composable
inline fun &lt;T : Any, reified E : Applier&gt; ReusableComposeNode(
    noinline factory: () -&gt; T,
    update: @DisallowComposableCalls Updater.() -&gt; Unit
) {
    if (currentComposer.applier !is E) invalidApplier()
    currentComposer.startReusableNode()
    if (currentComposer.inserting) {
        currentComposer.createNode(factory)
    } else {
        currentComposer.useNode()
    }
    Updater(currentComposer).update()
    currentComposer.endNode()
}
</code></pre>

<p>我们看到工厂被传递给了 <code>createNode()</code> 调用。此调用会安排在所有插入操作处理完毕后创建节点。Compose 运行时内部会延迟执行许多操作以实现优化。这里我们并不关心具体何时发生，只需知道它<em>将会</em>发生即可。当它发生时，工厂将被调用。</p>

<p>现在让我们更仔细地看一下工厂本身：<code>ComposeUiNode.Constructor</code> 看起来像是 <code>ComposeUiNode</code> 的构造函数。但事实并非如此。实际上，<code>ComposeUiNode</code> 是一个接口，它本身并不执行任何操作。它实际上是 <code>LayoutNode</code> 使用的基接口。至于这个接口和构造函数的用途，在接口声明上方的注释中已经给出：</p>

<pre><code class="kotlin">/** Interface extracted from LayoutNode to not mark the whole LayoutNode class as @PublishedApi. */
@PublishedApi
internal interface ComposeUiNode {
    // ...
    /** Object of pre-allocated lambdas used to make use with ComposeNode allocation-less. */
    companion object {
        val Constructor: () -&gt; ComposeUiNode = LayoutNode.Constructor
        val VirtualConstructor: () -&gt; ComposeUiNode = { LayoutNode(isVirtual = true) }
        // ...
    }
}
</code></pre>

<p><strong>所以 <code>ComposeUiNode</code> 只是 <code>LayoutNode</code> 的一个抽象。</strong></p>

<h2>布局节点（LayoutNode）</h2>

<p>在上一节中，我们已经了解了 <code>LayoutNode</code> 的实际创建时间。基本上，每当调用 <code>Layout</code> 可组合组件时，都会创建 <code>LayoutNode</code>。<code>LayoutNode</code> 是树状结构中的元素，代表屏幕上的内容。它需要被测量，可以在其边界内放置子元素，也可以绘制内容。</p>

<p>每个 <code>LayoutNode</code> 都知道它的子元素和父元素。因此，<code>LayoutNode</code> 构成了一个节点树，代表了已发出的内容。需要明确的是：Compose 创建的树状结构与其他 UI 框架一样——但 Google 更倾向于使用一些更高级的命名方式。<strong>因此，每当你听到/读到有关可组合组件发出内容时，请将其理解为一个 LayoutNode 被创建并插入到树中。</strong></p>

<p><code>LayoutNode</code> 类实际上非常有趣，因此值得单独撰写一篇博文，我将在其中更详细地介绍它的一些方面。</p>

<p>这里有两点值得一提：</p>

<ul>
<li><code>Applier</code> 是调用 <code>LayoutNode</code> 相应树状结构处理方法的实例。 - <code>LayoutNode</code> 持有对 <code>Owner</code> 的引用。</li>
</ul>


<p>由于 <code>Applier</code> 和 <code>Owner</code> 在 Compose 中都是非常重要的概念，我将在单独的博文中分别介绍它们。</p>

<h3>LayoutNode 的用途</h3>

<p><code>LayoutNode</code> 构成 UI 树，并跟踪其父节点和子节点。UI 树本身的管理由 <code>Applier</code> 完成，我将在另一篇文章中介绍它。</p>

<p>另外，需要记住的一点是，<code>LayoutNode</code> 存储在 <code>SlotTable[4]</code> 中。因此，在重新组合时，如果运行时认为树的这一部分不需要更改，则可以重用现有的 <code>LayoutNode</code>。</p>

<p><code>LayoutNode</code> 还会保存其修饰符（参见下一节），并委托这些修饰符来决定该 <code>LayoutNode</code> 需要多少空间（测量）、在屏幕上放置元素的位置（布局）以及最终在屏幕上显示什么内容（绘制）。</p>

<p>还有更多内容——但正如我提到的，那是另一篇文章的一部分。</p>

<h2>Modifier.Node</h2>

<p>修饰符在内部由 <a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier.Node"><code>Modifier.Node</code></a> 对象表示。<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier.Node">根据文档</a>，它是“为应用于 androidx.compose.ui.layout.Layout 的每个 Modifier.Element 创建的生命周期更长的对象”。</p>

<p>这个“生命周期更长”很有意思。基本上，只要 <code>Modifier.Node</code> 属于 <code>LayoutNode</code> 的修饰符链，它就会一直存在。 <code>LayoutNode</code> 持有一个 <code>NodeChain</code> 类型的对象，该对象内部维护着一个修饰符列表，并检查该列表是否发生更改，以及 <code>Modifier.Node</code> 的生命周期方法（例如 <code>onAttach()</code>）是否被调用。</p>

<p><code>Modifier.Node</code> 有许多现有的子类型，例如 <a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/node/LayoutModifierNode"><code>LayoutModifierNode</code></a>（见下文）或 <a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/node/DrawModifierNode?hl=en"><code>DrawModifierNode</code></a>。后者负责实际在屏幕上绘制内容，我计划在另一篇文章中详细介绍。</p>

<p>由于 <code>LayoutNode</code> 是 <code>SlotTable</code> 的一部分，因此附加到 <code>LayoutNode</code> 的 <code>NodeChain</code> 对象的 <code>Modifier.Node</code> 显然也是 <code>SlotTable</code> 的一部分。</p>

<h3>特殊子类型：<code>LayoutModifierNode</code></h3>

<p><code>LayoutModifierNode</code>（<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/node/LayoutModifierNode%EF%BC%89%E6%98%AF%E5%AE%9E%E9%99%85%E8%BF%9B%E8%A1%8C%E6%B5%8B%E9%87%8F%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%AE%83%E4%BB%AC%E4%BC%9A%E5%BD%B1%E5%93%8D%E5%B1%8F%E5%B9%95%E4%B8%8A%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%92%8C%E4%BD%8D%E7%BD%AE%E3%80%82%E6%AD%A3%E5%A6%82%E6%96%87%E6%A1%A3%E6%89%80%E8%BF%B0%EF%BC%9A%E2%80%9C">https://developer.android.com/reference/kotlin/androidx/compose/ui/node/LayoutModifierNode%EF%BC%89%E6%98%AF%E5%AE%9E%E9%99%85%E8%BF%9B%E8%A1%8C%E6%B5%8B%E9%87%8F%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%AE%83%E4%BB%AC%E4%BC%9A%E5%BD%B1%E5%93%8D%E5%B1%8F%E5%B9%95%E4%B8%8A%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%92%8C%E4%BD%8D%E7%BD%AE%E3%80%82%E6%AD%A3%E5%A6%82%E6%96%87%E6%A1%A3%E6%89%80%E8%BF%B0%EF%BC%9A%E2%80%9C</a><code>LayoutModifierNode</code> 会改变其包裹内容的测量和布局方式。”。因此，在测量和布局过程中，每当遍历 <code>ModifierNode</code> 链时，这些节点实际上都会开始进行测量。</p>

<p>因此，所有想要改变其子元素位置或对整个 Composable 元素大小产生任何影响的修饰符都需要实现 <code>LayoutModifierNode</code> 接口。例如，<code>SizeNode</code> 就是一个实现 <code>LayoutModifierNode</code> 接口的例子，它是 <code>height()</code>、<code>width()</code> 或 <code>size()</code> 等修饰符实际使用的节点。</p>

<h2>SemanticsNode</h2>

<p>当你想要向设备的<em>辅助功能服务[5]</em>传递一些信息时，你可以使用 Compose 中的 <a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier).semantics(kotlin.Boolean,kotlin.Function1)"><code>semantics</code></a> 修饰符来告知系统要向用户传达哪些语义属性。</p>

<p>但是辅助功能服务并不了解 Compose。在其他平台上，这一点显而易见，但考虑到 Compose 向后兼容（而且它并非 Android 框架的组成部分），在 Android 上也是如此。</p>

<p>对于辅助功能，前面提到的 <code>Owner</code> 再次发挥作用。它持有一个 <code>SemanticsOwner</code>，该 <code>SemanticsOwner</code> 充当了与相应平台语义框架之间的桥梁。</p>

<p>为此，<code>SemanticsOwner</code> 维护着一个 <code>SemanticNode</code> 对象树，用于向辅助功能服务的用户描述屏幕内容。这也是我未来会更详细介绍的内容之一。</p>

<p>敬请期待更多关于 Compose 内部运作机制的见解。祝你编码愉快！</p>

<h2>脚注</h2>

<ul>
<li>[1] 我在本段中使用“副作用”一词，是因为它在<a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)">计算机科学和函数式编程</a>中由来已久。我这里指的并非官方 Compose 文档中提到的<a href="https://developer.android.com/develop/ui/compose/side-effects">副作用</a>。Compose 文档至少在过去有时会提及副作用的这种用法——尽管实际上 Compose 函数并非纯函数。</li>
<li>[2] 如果在 Compose Compiler 插件完成工作后查看 Composable，你会发现它不仅创建了节点，而且你的函数还会进行大量调用，从而改变应用程序的全局状态。但这些调用并不会实际绘制任何内容。它们最多只会创建一些绘制操作，这些操作会被记录下来，并在系统认为需要绘制时，于未来的某个时间点被调用。我将在以后的两篇文章中分别介绍绘制过程以及编译器对代码所做的更改。</li>
<li>[3] 实际上，布局可组合对象共有三个。但它们最终都会调用 <code>ReusableComposeNode</code>。其他变体的示例也与之非常相似。</li>
<li>[4] 本系列文章中我可能不会介绍 SlotTable。我推荐 Richard Leland 的这篇关于 compose 的文章（<a href="https://medium.com/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd%EF%BC%89%EF%BC%8C%E4%BB%A5%E5%8F%8A">https://medium.com/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd%EF%BC%89%EF%BC%8C%E4%BB%A5%E5%8F%8A</a> Mohit Sarveiya 的关于 slotTable 的视频（<a href="https://codingwithmohit.com/%EF%BC%89%EF%BC%8C%E8%BF%99%E4%BA%9B%E8%A7%86%E9%A2%91%E8%AE%B2%E8%A7%A3%E4%BA%86%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8">https://codingwithmohit.com/%EF%BC%89%EF%BC%8C%E8%BF%99%E4%BA%9B%E8%A7%86%E9%A2%91%E8%AE%B2%E8%A7%A3%E4%BA%86%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8</a> slotTable。</li>
<li>[5] 设备上的辅助功能服务在 Android 系统中是 AccessibilityService 的实现，但在 iOS、桌面或 Web 端则有所不同，因此我在本文中使用“辅助功能服务”这个通用术语。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[学会在Jetpack Compose中加载Lottie动画资源]]></title>
    <link href="https://alexhilton.github.io/blog/2025/12/25/compose-lottie-resources/"/>
    <updated>2025-12-25T00:00:00+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/12/25/compose-lottie-resources</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「From File to Fetch」，原文链接<a href="https://proandroiddev.com/from-file-to-fetch-ed6dca1122c8">https://proandroiddev.com/from-file-to-fetch-ed6dca1122c8</a>，由Katie Barnett发布于2025年11月23日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/1*qaaJ_zFlqmNT3CKeLpsvKw.gif" title="auto auto" ></a></p>

<!-- more -->


<p>_注意：我与 Airbnb 及其 Lottie 项目（Lottie 的 GitHub 仓库）没有任何关联。](<a href="https://github.com/airbnb/lottie-android">https://github.com/airbnb/lottie-android</a>)我最近刚在一个应用中实现了 Lottie，想分享一些示例来佐证<a href="https://lottie.airbnb.tech/#/android-compose">官方文档</a>。</p>

<h2>了解 Lottie</h2>

<p>之前，我写过关于动画的文章<a href="https://medium.com/bilue/expanding-dialog-in-jetpack-compose-a6be40deab86">https://medium.com/bilue/card-flip-animation-with-jetpack-compose-f60aaaad4ac9</a>，也<a href="https://www.youtube.com/watch?v=ol9zpXu3g1U">在</a>上讨论过这个主题，以及我是如何创建原生动画的。但有时，我们想要一些更具艺术性的效果，不需要移动屏幕上的可组合元素；这时，我们就需要一个预先构建好的动画。</p>

<p>Lottie 就派上用场了。</p>

<p>如果你之前没有使用过 Lottie，它是由 Airbnb 开发人员开发的一个库，可以解析 Adob​​e After Effects 动画并将其导出为 JSON 格式。其理念是，设计师可以创建复杂的动画，而无需手动渲染。有很多设计工具的插件可以帮助创建动画，例如 Figma。如果你具备一定的设计天赋（我没有！），上手也很容易。</p>

<p>Lottie 已经存在一段时间了，可以在多个平台上渲染，例如 iOS、Web、Windows，当然还有 Android。它可用于 <a href="https://lottie.airbnb.tech/#/android">XML 视图</a>，但我今天要重点介绍的是它与 Jetpack Compose 的集成。</p>

<p>官方文档在这里 <a href="https://lottie.airbnb.tech/#/android-compose">https://lottie.airbnb.tech/#/android-compose</a>，但它并没有详细介绍如何使用 <code>LottieCompositionSpec</code> 中的多种不同源类​​型，以最便捷的方式提供我们的 Lottie 文件。实际上，某些应用可能需要处理多种源类型，尤其是在后端调用中指定特定动画的情况下。</p>

<p>我们将逐步介绍每种类型，但首先，让我们使用字符串来保存 Lottie 动画数据，从而进行基本设置。</p>

<h2>字符串来源</h2>

<p>使用任何 SDK 的第一步都是添加依赖项：</p>

<pre><code class="kotlin">// build.gradle.kts
...

dependencies {
    ...
    implementation(libs.lottie.compose)
}

// libs.version.toml
[versions]
lottie = "6.6.6"

[libraries]
lottie-compose = { group = "com.airbnb.android", name = "lottie-compose", version.ref = "lottie" }
</code></pre>

<p>然后，在 Composable 中，我们需要创建 <code>LottieCompositionSpec</code>。对于 JSON 字符串，我们可以使用 <code>LottieCompositionSpec.JsonString(val jsonString: String)</code>，</p>

<p>并将字符串传递给它。接下来，使用 <code>rememberLottieComposition</code> 并传入 <code>spec</code> 来记住组合状态。最后，可以将此状态传递给 <code>LottieAnimation</code> 以显示动画。</p>

<pre><code class="kotlin">val lottieCompositionSpec = LottieCompositionSpec.JsonString(JSON_STRING)
val lottieComposition = rememberLottieComposition(
    spec = lottieCompositionSpec
)
LottieAnimation(composition = lottieComposition.value)

const val JSON_STRING = "{\"v\":\"4.10.1\",...\"bm\":0}]}"
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:280/format:webp/1*pILmCNmRVMiswfyiq3yviw.gif" alt="Lottie动画来自 https://github.com/airbnb/lottie-android" /></p>

<p>现在，将动画存储在字符串中并非最易读或可持续的方式，更好的选择是使用Lottie JSON文件。一种方法是将其存储在assets目录中……</p>

<h2>Asset文件</h2>

<p>我们可以将Lottie文件存储为<code>.json</code>或<code>.lottie</code>文件（它们是同一种文件，只是扩展名不同），并将其存储在<code>app/assets</code>目录中。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*RYfpCujExeKM_FC0XOedPA.png" alt="" /></p>

<p>这里唯一的区别是我们需要使用 <code>LottieCompositionSpec.Asset(val assetName: String)</code> 并传递 <code>assets</code> 目录下的路径（你可以根据需要进行组织）。</p>

<pre><code class="kotlin">val lottieCompositionSpecLottieFile = LottieCompositionSpec.Asset("animations/android_wave.lottie")
val lottieCompositionSpecJsonFile = LottieCompositionSpec.Asset("animations/android_wave.json")
</code></pre>

<p>类似地，我们可以使用 <code>LottieCompositionSpec.File(val fileName: String)</code> 从设备文件系统中的任何位置加载动画文件——只需确保应用程序已获得该文件的访问权限即可！</p>

<p>使用资源文件意味着我们无法获得编译时保护来确保文件存在，但我们可以使用 <code>res/raw</code> 目录。</p>

<h2>原始资源文件</h2>

<p>同样，这很简单，只需将文件添加到 <code>raw</code> 目录即可：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*I0jHURry7W04WUibyHvunA.png" alt="" /></p>

<p>现在，我们可以通过使用 <code>LottieCompositionSpec.RawRes</code> 和 <code>R.raw</code> 访问原始资源，从而获得编译时安全性。</p>

<pre><code class="kotlin">val lottieCompositionSpec = LottieCompositionSpec.RawRes(R.raw.android_wave)
</code></pre>

<p>最后，如果我们希望在需要时动态获取 Lottie 文件，而不是将其打包到应用程序中，我们可以从 URL 加载它。</p>

<h2>URL 来源</h2>

<p>与上述类似，我们可以使用 <code>LottieCompositionSpec.Url</code> 加载以 URL 形式存储的 Lottie 文件：</p>

<pre><code class="kotlin">val lottieCompositionSpec = LottieCompositionSpec.Url("https://url/AndroidWave.json")
</code></pre>

<p>如果一切顺利，用户网络连接良好，这当然很好，但我们需要确保能够处理任何错误。</p>

<h3>错误响应和添加加载状态</h3>

<p>动画加载也可能需要一些时间，尤其是在动画文件较大或用户网络连接不佳的情况下。为此，我们可以使用 <code>LottieCompositionResult</code> 来检测动画的状态。</p>

<p>当动画正在下载或解析时，<code>LottieCompositionResult.isLoading</code> 将为 true；当解析成功且合成已准备好显示时，<code>LottieCompositionResult.isSuccess</code> 将为 true。我们还有两个状态：<code>LottieCompositionResult.isComplete</code>，当 <code>isLoading</code> 为 false 时（无论组合是否成功），它将为 true；最后是 <code>LottieCompositionResult.isFailure</code>，当出现不可恢复的错误时（即下文讨论的 <code>onRetry</code> lambda 返回 <code>false</code> 时），它将为 true。</p>

<p>为了展示标准的加载、错误和成功行为，我们可以像这样使用 <code>isLoading</code> 和 <code>isSuccess</code>：</p>

<pre><code class="kotlin">if (lottieComposition.isLoading) {
    Box(
        contentAlignment = Alignment.Center,
        modifier = Modifier.height(100.dp)
    ) {
        CircularProgressIndicator()
    }
} else if (lottieComposition.isSuccess) {
    LottieAnimation(
        composition = lottieComposition.value,
        modifier = Modifier.height(100.dp)
    )
} else {
    Image(
        imageVector = Icons.Filled.Error,
        contentDescription = null,
        modifier = Modifier.height(100.dp)
    )
}
</code></pre>

<h3>重试动画加载错误</h3>

<p>Lottie 提供了一种简单易用的方法，可以使用 <code>rememberLottieComposition</code> 中的 <code>onRetry</code> 来重试动画加载。我们可以通过两种方式使用它：</p>

<p><strong>反复重试直到达到某个限制</strong></p>

<p>在构造 <code>rememberLottieComposition</code> 时，我们可以指定 <code>onRetry</code> lambda，并返回 <code>true</code> 以继续重试，返回 <code>false</code> 以停止重试。 <code>onRetry</code> 包含一个 <code>failCount</code> 参数。这允许应用重试次数限制或指数退避。例如：</p>

<pre><code class="kotlin">val lottieComposition = rememberLottieComposition(
    spec = lottieCompositionSpec,
    onRetry = { failCount, exception -&gt;
        Timber.d(exception, "Error loading animation: ${exception.message}")
        failCount &lt; 5
    }
)
</code></pre>

<p>这里我将动画设置为重试 5 次后停止。你可以在此 lambda 表达式中添加错误消息或其他任何有用的信息（但请使用上面描述的 <code>LottieCompositionResult.isLoading</code> 布尔值来显示加载行为，而不是在此处设置另一个变量）。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:280/format:webp/1*d9gomTwO-kr5K9mufbMinA.gif" alt="" /></p>

<p><strong>等待重试信号</strong></p>

<p>我们还可以允许动画等待重试，直到某个外部条件发生变化，例如按下按钮或恢复网络连接。</p>

<p>为此，我们使用 <code>rememberLottieRetrySignal</code>。</p>

<pre><code class="kotlin">val retrySignal = rememberLottieRetrySignal()
var url by remember { mutableStateOf("https://bad/url") }
val lottieCompositionSpec = LottieCompositionSpec.Url(url)
val lottieComposition = rememberLottieComposition(
    spec = lottieCompositionSpec,
    onRetry = { _, exception -&gt;
        Timber.d(exception, "Error loading animation: ${exception.message}")
        retrySignal.awaitRetry()
        false
    }
)
Column(...) {
    if (lottieComposition.isLoading) {
        ...
    } else if (lottieComposition.isSuccess) {
        LottieAnimation(
            composition = lottieComposition.value,
            modifier = Modifier.height(100.dp)
        )
    } else {
        ...
    }
    TextButton(onClick = {
        url = "https://url/AndroidWave.json"
        retrySignal.retry()
    }) {
        Text("Fix url &amp; retry")
    }
}
</code></pre>

<p>在这个简单的示例中，我将 URL 设置为无效 URL，然后在 <code>onRetry</code> 中，当发生错误时，我们可以使用记住的 <code>retrySignal</code> 来等待重试。 <code>retrySignal.awaitRetry()</code>。动画将保持加载状态，直到按钮点击时调用 <code>retrySignal.retry()</code>。如果你不希望保持加载状态，而是希望在重试之前显示错误信息，你可以完全省略 <code>retrySignal</code>，并更新已记住的 <code>url</code> 状态，这样 <code>LottieCompositionSpec</code> 将重新组合。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:280/format:webp/1*HZRs6-0_sZxmXImH999iVA.gif" alt="" /></p>

<h2>动画配置</h2>

<p>最后，动画加载正确后，我们可以使用一些其他配置项来优化动画效果。</p>

<p>虽然最好在 Lottie 文件本身（创建时完成）中控制这些动画行为，但你也可以通过以下方式调整动画的播放方式： <code>LottieAnimation</code> 本身是可组合的。要了解其功能，最好查看一些可用参数：</p>

<pre><code class="kotlin">// An excerpt from version 6.6.6 of the SDK
@Composable
fun LottieAnimation(
    clipSpec: LottieClipSpec? = null,
    speed: Float = 1f,
    iterations: Int = 1,
    reverseOnRepeat: Boolean = false,
    alignment: Alignment = Alignment.Center,
    contentScale: ContentScale = ContentScale.Fit,
    ... // + others for more advanced use, check out the SDK documentation
) {}
</code></pre>

<p>在这里，我们可以控制：</p>

<ul>
<li><p><code>clipSpec</code>：动画播放的帧</p></li>
<li><p><code>speed</code>：动画速度</p></li>
<li><p><code>iterations</code>：动画运行次数（使用 <code>LottieConstants.IterateForever</code> 可无限循环）</p></li>
<li><p><code>reverseOnRepeat</code>：循环播放后反向播放</p></li>
<li><p><code>alignment</code> 和 <code>contentScale</code>：就像图像一样，我们可以调整动画在指定范围内的布局。</p></li>
</ul>


<p>现在你可以了解 Lottie 的所有用法，请务必为你正在开发的应用程序选择最佳方案，并选择最便捷的方式从你的设计团队获取文件，而无需费力地在不同文件格式之间进行转换。</p>

<p>再见！现在！</p>

<p><img src="https://miro.medium.com/v2/resize:fit:600/1*AbjuxEFO34XUsPCAs-U-Kw.gif" alt="" /></p>

<p>你可以在我的 GitHub 仓库的 <a href="https://github.com/KatieBarnett/Experiments/tree/main/jc-lottie">jc-lottie</a> 模块中找到上述示例代码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jetpack Compose 2025年12月版本新增功能]]></title>
    <link href="https://alexhilton.github.io/blog/2025/12/18/compose-december-2025/"/>
    <updated>2025-12-18T00:00:00+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/12/18/compose-december-2025</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「What&rsquo;s new in the Jetpack Compose December &lsquo;25 release」，原文链接<a href="https://android-developers.googleblog.com/2025/12/whats-new-in-jetpack-compose-december.html">https://android-developers.googleblog.com/2025/12/whats-new-in-jetpack-compose-december.html</a>，由Nick Butcher发布于2025年12月3日。</p></blockquote>

<p><a href=""><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjaOFQLkqCBaw0FA8C7XCI7gKe-Z79r2dYH9QUOnWyZq_Qevh-EoHqRs6zTENmzLjHwKk_ECQlN_2EePI8-JyjCVH3PL2rOsbRdfKNZ6T" title="auto auto" ></a></p>

<!-- more -->


<p>现在，<a href="https://developer.android.com/jetpack/androidx/releases/compose">Jetpack Compose 2025年12月版本</a> 正式发布。该版本包含 Compose 核心模块 1.10 版和 Material 3 1.4 版（参见完整的 <a href="https://developer.android.com/develop/ui/compose/bom/bom-mapping">BOM 映射</a>），新增了多项功能并显著提升了性能。</p>

<p>要使用最新的版本，请将 Compose BOM 版本升级到 2025.12.00：</p>

<pre><code class="kotlin">implementation(platform("androidx.compose:compose-bom:2025.12.00"))
</code></pre>

<h2>性能改进</h2>

<p>我们知道应用程序的运行时性能对你和你的用户至关重要，因此性能一直是 Compose 团队的首要任务。此版本带来了一系列改进——你只需升级到最新版本即可获得所有这些改进。我们的内部滚动性能基准测试表明，Compose 现在的性能与使用 Views 时的性能相当：</p>

<p><img src="https://blogger.googleusercontent.com/img/a/AVvXsEhmNWZbGEVpwg-kdd6kw9Ay8TyOjGS226GxU1oNQQCI0IBJ1aj_Pze-SQ0z9LGywbdbzIROkIv6hxKKMIXJ0sBs-q5U_cv-yslsXFRzdRihM0MxWI3q2j-LURfcILGe7i9KodgjuGgUkAoeeZspHUa11iDkAiJTs295rxSDtgSWK0VSEofLt2MWburL7II" alt="滚动性能基准测试比较了 Views 和 Jetpack Compose 在不同 Compose 版本下的性能" /></p>

<h3>延迟预取中的可暂停组合</h3>

<p>延迟预取中的可暂停组合预取功能现已默认启用。这是 Compose 运行时调度机制的一项根本性变革，旨在显著减少高 UI 负载下的卡顿现象。</p>

<p>此前，一旦合成开始，就必须运行至完成。如果合成较为复杂，则可能导致主线程阻塞超过一帧，从而造成 UI 卡顿。而现在，借助可暂停合成功能，运行时可以在时间不足时“暂停”其工作，并在下一帧恢复。当与延迟布局预取结合使用，提前准备帧时，此功能尤为有效。 Compose 1.9 中引入的 LazyLayout<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/lazy/package-summary#rememberLazyListState(androidx.compose.foundation.lazy.layout.LazyLayoutCacheWindow,kotlin.Int,kotlin.Int)">CacheWindow</a> API 可以很好地预取更多内容，并利用可暂停的合成功能来显著提升 UI 性能。</p>

<p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhaE5BKUo2mBxNKAmgD8nnrrbooEAbjCSxsGJbJx6DgTmMPx8BmTWsOg2I2_FXcOODSG8OAX31ueJfgipH2zdF1Y3v6CcIXGW3mWiWcHbemqnmVO-IYWKVJ-V6CiD9LDo_35nqyWrDgK3Y_HOdUDfL8StGnfgg34Ia6wda1bXoDT3xhMQb8w2hn_d2gLhQ/s16000/pausable.gif" alt="可暂停合成结合延迟预取有助于减少卡顿" /></p>

<p>我们还优化了其他方面的性能，例如改进了 Modifier.onPlaced。 Modifier.onVisibilityChanged 和其他修饰符实现。我们将继续投入资源来提升 Compose 的性能。</p>

<h2>新功能</h2>

<h3>Retain</h3>

<p>Compose 提供了一系列 API 来跨不同的生命周期保存和管理状态；例如，<code>remember</code> 可以在组合之间持久化状态，而 <code>rememberSavable</code>/<code>rememberSerializable</code> 可以在 Activity 或进程重建之间持久化状态。<code>retain</code> 是一个介于这些 API 之间的新 API，它允许你在配置更改时持久化值而无需序列化，但不会跨进程终止。由于 <code>retain</code> 不会序列化你的状态，因此你可以持久化诸如 lambda 表达式、流程以及位图等难以序列化的大型对象。例如，你可以使用 <code>retain</code> 来管理媒体播放器（例如 ExoPlayer），以确保媒体播放不会因配置更改而中断。</p>

<pre><code class="kotlin">@Composable
fun MediaPlayer() {
    val applicationContext = LocalContext.current.applicationContext
    val exoPlayer = retain { ExoPlayer.Builder(applicationContext).apply { ... }.build() }
    ...
}
</code></pre>

<p>我们要感谢 AndroidDev 社区（特别是 <a href="https://slackhq.github.io/circuit">Circuit</a> 团队），他们对该功能的设计产生了影响并做出了贡献。</p>

<h3>Material 1.4</h3>

<p>Material3 库的 1.4.0 版本新增了一些组件和增强功能：</p>

<ul>
<li><p>TextField 现在提供了一个基于 TextFieldState 的实验性版本，它提供了一种 <a href="https://developer.android.com/develop/ui/compose/text/user-input">更强大的</a> 方法来管理文本状态。此外，还新增了变体SecureTextField 和 OutlinedSecureTextField。Material Text 可组合元素现在支持自动调整大小功能（autoSize）。</p></li>
<li><p>轮播组件现在提供了一个新的 <a href="https://developer.android.com/reference/kotlin/androidx/compose/material3/carousel/package-summary#Horizo%E2%80%8B%E2%80%8BntalCenteredHeroCarousel(androidx.compose.material3.carousel.CarouselState,androidx.compose.ui.Modifier,androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp,androidx.compose.foundation.gestures.TargetedFlingBehavior,kotlin.Boolean,androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp,androidx.compose.foundation.layout.PaddingValues,kotlin.Function2)">Horizo​​ntalCenteredHeroCarousel</a><a href="https://m3.material.io/components/carousel/specs">variant</a>。</p></li>
<li><p><a href="https://developer.android.com/reference/kotlin/androidx/compose/material3/package-summary?_gl=1*1h4dj5y*_up*MQ..*_ga*NDE1MzI0NzAwLjE3NjQ2MTM1MzU.*_ga_6HH9YJMN9M*czE3NjQ2MTM1MzQkbzEkZzAkdDE3NjQ2MTM1MzQkajYwJGwwJGgxODIyOTM4OTMy#TimePicker(androidx.compose.material3.TimePickerState,androidx.compose.ui.Modifier,androidx.compose.material3.TimePickerColors,androidx.compose.material3.TimePickerLayoutType)">TimePicker</a> 现在支持在选择器模式和输入模式之间切换。</p></li>
<li><p>垂直拖拽手柄（<a href="https://developer.android.com/reference/kotlin/androidx/compose/material3/package-summary#VerticalDragHandle(androidx.compose.ui.Modifier,androidx.compose.material3.DragHandleSizes,androidx.compose.material3.DragHandleColors,androidx.compose.material3.DragHandleShapes,androidx.compose.foundation.interaction.MutableInteractionSource)">VerticalDragHandle</a>）帮助用户更改自适应空格的大小或者位置。</p></li>
</ul>


<p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhTrvNyW_IJgSIqBWYlzweN3mkoZ_Uc3IMNj2Pu0cC1VdVqnja4nHA6kSCO2nk44MBi2diWEPu_oe0ozm2Jxh5jjXyJ7uqHdrdkyTrDaCgIifMpHLK9q3stUhD79QuLc7q_V4EisrNR7t4I3SMAxSq57EVzk8PGqiouXPRc-wI9Pu03vbuDU3_rnrA4THc/s16000/centered-hero-carousel.gif" alt="Horizontal centered hero carousel" /></p>

<p>请注意，<a href="https://m3.material.io/blog/building-with-m3-expressive">Material 3 Expressive</a> API 仍在 Material 3 库的 alpha 版本中持续开发。要了解更多信息，请观看<a href="https://www.youtube.com/embed/t9rrsqfB2tM">最近的演讲</a>。</p>

<h2>新的动画功能</h2>

<p>我们持续扩展动画 API，包括对自定义共享元素动画的更新。</p>

<h3>动态共享元素</h3>

<p>默认情况下，<code>sharedElement()</code> 和 <code>sharedBounds()</code> 动画会在目标状态中找到匹配的键时尝试为布局更改添加动画效果。但是，你可能希望根据某些条件（例如导航方向或当前 UI 状态）动态禁用​​此动画。</p>

<p>要控制共享元素过渡是否发生，你现在可以自定义传递给 <code>rememberSharedContentState()</code> 的 <code>SharedContentConfig</code>。<code>isEnabled</code> 属性决定共享元素是否处于活动状态。</p>

<pre><code class="kotlin">SharedTransitionLayout {
    val transition = updateTransition(currentState)
    transition.AnimatedContent { targetState -&gt;
        // Create the configuration that depends on state changing.
        fun animationConfig() : SharedTransitionScope.SharedContentConfig {
            return object : SharedTransitionScope.SharedContentConfig {
                override val SharedTransitionScope.SharedContentState.isEnabled: Boolean
                        get() =
                            // determine whether to perform a shared element transition
                }
            }
}
</code></pre>

<p>更多信息，请参阅<a href="https://developer.android.com/develop/ui/compose/animation/shared-elements/customize#dynamic-enable-disable">文档</a>。</p>

<h3>Modifier.skipToLookaheadPosition()</h3>

<p>此版本新增了一个修饰符 <a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/SharedTransitionScope?hl=en#(androidx.compose.ui.Modifier).skipToLookaheadPosition(kotlin.Function0)">Modifier.skipToLookaheadPosition()</a>，用于在执行共享元素动画时保持可组合元素的最终位置。这使得可以执行类似“揭示”类型的过渡动画，例如 Androidify 示例中相机的渐进式揭示效果。更多信息，请参阅<a href="https://www.youtube.com/embed/0moEXBqNDZI">此处的视频提示</a>。</p>

<h3>共享元素过渡中的初始速度</h3>

<p>此版本新增了一个共享元素过渡 API：<code>prepareTransitionWithInitialVelocity</code>，允许你将初始速度（例如来自手势）传递给共享元素过渡：</p>

<pre><code class="kotlin">Modifier.fillMaxSize()
    .draggable2D(
            rememberDraggable2DState{offset+=it},
            onDragStopped = { velocity -&gt;
                // Set up the initial velocity for the upcoming shared element
                // transition.
              sharedContentStateForDraggableCat?.prepareTransitionWithInitialVelocity(velocity)
                showDetails = false
            },
)
</code></pre>

<p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi-XdYTEA7H5BokZRoo_npAvjuSLPP3cXifTSHtonoHiuQVtav1w9ZKhIqlxQJKeX9AxyQnR0HjSe3t1Sy02jdMYiWI_mg1VoJST55CAKgBtkvHpgRatXJobhPVoimLQCJ-F6dfLRDt75vJANi46D4MhobglqRG7rSFb3VqglLcE6rNLx3c02Vzqiqr6IY/w288-h640/fling-shared.gif" alt="一个以初始速度开始的共享元素过渡，该初始速度来自手势" /></p>

<h3>面纱过渡动画</h3>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/EnterTransition">EnterTransition</a> 和 <a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/ExitTransition?_gl=1*1m00og2*_up*MQ..*_ga*MjU3NDMyNzc5LjE3NjQ2MTE4NjM.*_ga_6HH9YJMN9M*czE3NjQ2MTE4NjMkbzEkZzAkdDE3NjQ2MTE4NjMkajYwJGwwJGgxMTk2NzM1MDk0">ExitTransition</a> 定义了动画的执行方式。 <a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#AnimatedVisibility">AnimatedVisibility</a>/ <a href="https://developer.android.com/refe%20rence/kotlin/androidx/compose/animation/package-summary#AnimatedContent">AnimatedContent</a> 可组合元素出现或消失。新增的实验性遮罩选项允许你指定颜色来遮盖或修饰内容；例如，在内容上方淡入/淡出半透明黑色图层：</p>

<p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhemyKNMNnK50HVISQJlCz4fXPkkckq-ZdOgB3f8dolMzDe6UgCGq3_nVQhdfNb8au6cL00LHR0EJIQqxOQnnCXNSs8284eIMGroEp1V_F48JHkIk_kzPiYAov-nI3LAIG0_XXNjVQUIXwDvgH_rdMgF9wn_u605WU8oOD-uW-MSVKUHzyekqYsnFrEqms/w304-h640/veil_2.gif" alt="带遮蔽的动画内容 – 注意在动画过程中覆盖在网格内容上的半透明遮蔽层（或幕布）动画" /></p>

<pre><code class="kotlin">AnimatedContent(
    targetState = page,
    modifier = Modifier.fillMaxSize().weight(1f),
    transitionSpec = {
         if (targetState &gt; initialState) {
            (slideInHorizontally { it } togetherWith
                    slideOutHorizontally { -it / 2 } + veilOut(targetColor = veilColor))
        } else {
            slideInHorizontally { -it / 2 } +
                        unveilIn(initialColor = veilColor) togetherWith slideOutHorizontally { it }
        }
    },
) { targetPage -&gt;
    ...
}
</code></pre>

<h2>即将发生的变更</h2>

<h3>弃用 Modifier.onFirstVisible</h3>

<p>Compose 1.9 引入了 <a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#%28androidx.compose.ui.Modifier%29.onVisibilityChanged%28kotlin.Long,kotlin.Float,androidx.compose.ui.layout.LayoutBoundsHolder,kotlin.Function1%29">Modifier.onVisibilityChanged</a> 和 <a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#%28androidx.compose.ui.Modifier%29.onFirstVisible%28kotlin.Long,kotlin.Float,androidx.compose.ui.layout.LayoutBoundsHolder,kotlin.Function0%29">Modifier.onFirstVisible</a>。在审阅了你的反馈后，我们发现 <code>Modifier.onFirstVisible</code> 的约定无法确定性地执行；具体来说，就是无法确定某个元素何时首次可见。例如，Lazy 布局可能会释放滚动出视口的元素，然后在它们滚动回视口时重新组合它们。在这种情况下，<code>onFirstVisible</code> 回调会再次触发，因为它是一个新组合的元素。当导航回之前访问过的包含 <code>onFirstVisible</code> 的屏幕时，也会出现类似的行为。因此，我们决定在下一个 Compose 版本（1.11）中弃用此修饰符，并建议迁移到 <code>onVisibilityChanged</code>。有关更多信息，请参阅<a href="https://developer.android.com/develop/ui/compose/layouts/visibility-modifiers">文档</a>。</p>

<h3>测试中的协程分发</h3>

<p>我们计划更改测试中的协程分发，以改善测试的稳定性并捕获更多问题。目前，测试使用的是 UnconfinedTestDispatcher，这与生产环境的行为有所不同；例如，<a href="https://developer.android.com/develop/ui/compose/side-effects">副作用</a>可能会立即运行，而不是被放入队列。在未来的版本中，我们计划引入一个新的 API，默认使用 StandardTestDispatcher，以匹配生产环境的行为。你现在可以在 1.10 版本中尝试新的行为：</p>

<pre><code class="kotlin">@get:Rule // also createAndroidComposeRule, createEmptyComposeRule
val rule = createComposeRule(effectContext = StandardTestDispatcher())
</code></pre>

<p>使用 StandardTestDispatcher 会将任务放入队列，因此你必须使用同步机制，例如 composeTestRule.waitForIdle() 或 composeTestRule.runOnIdle()。如果你的测试使用了 runTest，则必须确保 runTest 和你的 Compose 规则共享同一个 StandardTestDispatcher 实例以进行同步。</p>

<pre><code class="kotlin">// 1. Create a SINGLE dispatcher instance
valtestDispatcher = StandardTestDispatcher()

// 2. Pass it to your Compose rule
@get:Rule
valcomposeRule = createComposeRule(effectContext = testDispatcher)

@Test
// 3. Pass the *SAME INSTANCE* to runTest
funmyTest() = runTest(testDispatcher) {
    composeRule.setContent{/* ... */}
}
</code></pre>

<h2>工具</h2>

<p>优秀的 API 需要优秀的工具，<a href="http://d.android.com/studio">Android Studio</a> 为 Compose 开发者新增了多项功能：</p>

<ul>
<li><p><a href="https://developer.android.com/studio/preview/features#iterate-ui-agent">变换 UI</a>：右键单击 @Preview，选择“变换 UI”，然后用自然语言描述更改，即可迭代你的设计。</p></li>
<li><p><a href="https://developer.android.com/studio/preview/features#ui-tools-setup">生成 @Preview</a>：右键单击可组合元素，然后选择 Gemini > 生成 [可组合元素名称] 预览。</p></li>
<li><p><a href="https://developer.android.com/studio/preview/features#material-symbols-support">自定义 Material Symbols</a>：矢量资源向导新增了对图标变体的支持。</p></li>
<li><p><a href="https://developer.android.com/studio/preview/features#screen-to-code-agent">从屏幕截图生成代码</a> 或让 Gemini <a href="https://developer.android.com/studio/preview/features#match-ui-agent">将你现有的 UI 与目标图像匹配</a>。这可以与远程 <a href="https://developer.android.com/studio/preview/features#remote-mcp">MCP 支持</a> 结合使用，例如连接到 Figma 文件并从设计生成 Compose UI。</p></li>
<li><p><a href="https://developer.android.com/studio/preview/features#find-and-fix-ui-quality-issues">修复 UI 质量问题</a> 会审核你的 UI 是否存在常见问题，例如辅助功能问题，然后提出修复方案。</p></li>
</ul>


<p>要查看这些工具的实际应用，请观看此 <a href="https://www.youtube.com/embed/jTlW8JeCClA">最新演示</a>。</p>

<h2>尽情创作</h2>

<p>我们持续投入资源开发 Jetpack Compose，为你提供创建美观、丰富的用户界面所需的 API 和工具。我们重视你的反馈，请在我们的<a href="https://issuetracker.google.com/issues/new?component=612128">问题跟踪器</a>中分享你对这些更改的反馈，或你希望看到的后续功能。</p>
]]></content>
  </entry>
  
</feed>
