<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Compose | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/compose/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2025-11-08T18:25:44+08:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Compose CameraX现已稳定：给Composer的端到端指南]]></title>
    <link href="https://alexhilton.github.io/blog/2025/11/02/compose-camerax-is-stable/"/>
    <updated>2025-11-02T22:10:34+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/11/02/compose-camerax-is-stable</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Compose-Native CameraX Is Now Stable: End-to-End Guide for Jetpack Compose」，原文链接<a href="https://proandroiddev.com/goodbye-androidview-camerax-goes-full-compose-4d21ca234c4e">https://proandroiddev.com/goodbye-androidview-camerax-goes-full-compose-4d21ca234c4e</a>，由Ioannis Anifantakis发布于20251026。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/1*sizZteIZmrzNr4X1BeXcJg.png" title="auto auto" ></a></p>

<!-- more -->


<h2>简介</h2>

<p>还记得你在 Jetpack Compose 中的第一个相机页面吗？纯粹的声明式乐趣……直到预览。然后是熟悉的 <code>AndroidView(PreviewView)</code> 绕道。它确实有效，但总感觉不对：composables中间有一个 View 形状的空洞（类似于 <code>_iFrame_</code>_ ……），而且点击对焦的数学计算总是让人感觉不太可靠。</p>

<p>在 I/O 25 之后，这种妥协已经结束。</p>

<ul>
<li><strong>不再</strong> 使用 <code>**AndroidView(PreviewView)**</code> 进行相机预览。</li>
<li><strong>新增</strong> <code>**CameraXViewfinder**</code> 可组合项，可在 Compose 中直接渲染 CameraX <code>SurfaceRequest</code>。</li>
<li><strong>修正了内置坐标变换</strong>（点击对焦、叠加层），并建立了更简洁、更具声明性的心智模型。</li>
</ul>


<blockquote><p><strong><em>注意：</em></strong></p>

<p><em>“</em>在 I/O 25 大会上，Compose 支持已发布 <strong>alpha/beta</strong> 版本，稳定版已于 9 月发布——现在是时候了解一下了。”_</p></blockquote>

<h2>配套项目</h2>

<p>你可以在 <a href="https://github.com/ioannisa/CameraX-Composable-Demo/"><strong>GitHub 上的配套项目</strong></a> 找到本文的配套项目，该项目演示了 CameraX 中 Jetpack Compose 的新功能。</p>

<h3>权限用户体验（简要说明）</h3>

<p>本文将重点介绍 Compose + CameraX 的功能。<strong>配套项目</strong> 实现了完整的运行时流程：</p>

<ul>
<li>在预览入口点请求 <code>**CAMERA**</code>。</li>
<li>仅在用户开始录制时（按需麦克风）请求 <code>**RECORD_AUDIO**</code>。</li>
<li>一个小型的 <code>PermissionGate</code> 可组合函数负责处理 Compose 树中的授权/拒绝/重新请求。</li>
<li>为了满足 Lint 对 <code>@RequiresPermission</code> 的要求，调用点还会在调用与麦克风相关的 API 之前执行显式 <code>checkSelfPermission(...)</code>。</li>
</ul>


<p>请参阅代码库，了解具体的 <code>PermissionGate</code> 以及我们如何将其连接到 Capture 页面。</p>

<h2>实际变化是什么？</h2>

<p>CameraX 团队放弃了 <code>androidx.camera:camera-compose</code>，取而代之的是看似简单的 API：<code>**CameraXViewfinder**</code>。但这不仅仅是“将 <code>PreviewView</code> 封装在可组合项中”。这是对 Compose 的彻底重写，也是对相机 Surface 与 Compose 集成方式的根本性重新思考。</p>

<p>以下是架构层面的变化：</p>

<p><strong>Compose 目标优先</strong>
取景器渲染管道现在将 Compose 视为主要平台。Surface 生命周期、旋转处理和缩放都以 Compose 惯用的方式进行。</p>

<p><strong>开箱即用的正确坐标变换</strong>
还记得计算预览中的点击实际映射到相机传感器的位置，并考虑旋转、宽高比裁剪和缩放模式吗？<code>MutableCoordinateTransformer</code> 可以处理这些。点击对焦现在……可以正常工作了。</p>

<p><strong>真正的可组合语义</strong>
想要将预览 <code>clip()</code> 转换为自定义形状？应用 <code>graphicsLayer</code> 变换？使用 <code>AnimatedContent</code> 为其添加动画效果？现在，你可以轻松完成所有这些操作，而无需与渲染器冲突。它与其他可组合组件一样。</p>

<p><strong>CameraX 1.5.x 成熟度</strong>
整个技术栈都得到了完善：适用于 Kotlin 协程的 <code>ProcessCameraProvider.awaitInstance()</code>、全面稳定的构件以及更完善的文档。这并非 Beta 测试……它已准备好投入生产。</p>

<h2>为什么这真的很重要</h2>

<p>如果你一直在构建相机功能，<strong>你就会知道其中的痛点</strong>：</p>

<ul>
<li><strong>心智模型分裂</strong>：“用 Compose 思考 UI，用 View 思考相机，并在两者之间不断转换。”</li>
<li><strong>手势协调的噩梦</strong>：在 Compose 中处理触摸事件，在 View 坐标系中测光对焦，祈祷你的计算准确无误。</li>
<li><strong>Z 轴顺序难题</strong>：“PreviewView” 经常使用在单独图层中渲染的“SurfaceView”。Compose 叠加层无法可靠地位于顶部，因此十字线、参考线和按钮可能会消失在预览层后面。</li>
<li><strong>生命周期之舞</strong>：使用 CameraX 用例绑定将 Compose 重组与 View 生命周期同步</li>
</ul>


<p>所有这些摩擦？都消失了。</p>

<blockquote><p><strong>“现在，你可以像编写其他现代 Android 应用一样编写相机 UI。一个范例。一个心智模型。纯粹的 Compose。”</strong></p></blockquote>

<h2>代码演示</h2>

<p>让我们从最基本的开始——一个可以工作的相机预览（固定状态模式：将<strong>写入器</strong> <code>MutableStateFlow</code> 与<strong>读取器</strong> <code>collectAsState</code> 分离）。</p>

<pre><code class="kotlin">@Composable
fun CameraPreview(modifier: Modifier = Modifier) {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current

    // Writer: MutableStateFlow we can update from CameraX callbacks
    val surfaceRequests = remember { MutableStateFlow&lt;SurfaceRequest?&gt;(null) }

    // Reader: Compose state derived from the flow
    val surfaceRequest by surfaceRequests.collectAsState(initial = null)

    // Bind CameraX use cases once
    LaunchedEffect(Unit) {
        val provider = ProcessCameraProvider.awaitInstance(context)

        val preview = Preview.Builder().build().apply {
            // When CameraX needs a surface, publish it to Compose
            setSurfaceProvider { request -&gt;
                surfaceRequests.value = request
            }
        }

        provider.unbindAll()
        provider.bindToLifecycle(
            lifecycleOwner,
            CameraSelector.DEFAULT_BACK_CAMERA,
            preview
        )
    }

    // The actual Compose viewfinder
    surfaceRequest?.let { request -&gt;
        CameraXViewfinder(
            surfaceRequest = request,
            modifier = modifier.fillMaxSize()
        )
    }
}
</code></pre>

<p>就是这样。没有 <code>AndroidView</code>。没有 <code>PreviewView</code>。只有一个可组合组件，它接收 <code>SurfaceRequest</code> 并进行渲染。</p>

<blockquote><p><strong><em>模式很简洁：“</em></strong>CameraX 发布 Surface 请求，Compose 处理它们。单向。没有回调在各个世界之间来回切换。”</p></blockquote>

<h3>可选：使用镜头切换按钮（FAB）进行预览（前/后）</h3>

<pre><code class="kotlin">@Composable
fun PreviewWithLensSwitch(modifier: Modifier = Modifier) {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current

    val surfaceRequests = remember { MutableStateFlow&lt;SurfaceRequest?&gt;(null) }
    val surfaceRequest by surfaceRequests.collectAsState(initial = null)

    // remember current lens
    var useFront by rememberSaveable { mutableStateOf(false) }
    val selector = if (useFront) CameraSelector.DEFAULT_FRONT_CAMERA else CameraSelector.DEFAULT_BACK_CAMERA

    // bind when camera selector changes (front/back camera)
    LaunchedEffect(selector) {
        val provider = ProcessCameraProvider.awaitInstance(context)
        val preview = Preview.Builder().build().apply {
            setSurfaceProvider { req -&gt; surfaceRequests.value = req }
        }
        provider.unbindAll()
        provider.bindToLifecycle(lifecycleOwner, selector, preview)
    }

    Box(Modifier.fillMaxSize()) {
        surfaceRequest?.let { req -&gt;
            CameraXViewfinder(surfaceRequest = req, modifier = Modifier.fillMaxSize())
        }
        FloatingActionButton(
            onClick = { useFront = !useFront },
            modifier = Modifier.align(Alignment.BottomEnd).padding(16.dp)
        ) { Icon(Icons.Rounded.Cameraswitch, contentDescription = "Switch camera") }
    }
}
</code></pre>

<h2>真正的考验：交互式相机控件</h2>

<p>旧方法的失败之处就在这里。让我们实现点击对焦和捏合缩放……这些功能过去需要对视图坐标系进行一些 hack（同样使用固定的写入/读取模式）：</p>

<pre><code class="kotlin">@Composable
fun InteractiveCameraPreview(

modifier: Modifier = Modifier,

onFocusTap: (success: Boolean) -&gt; Unit = {}) {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current

    var camera by remember { mutableStateOf&lt;Camera?&gt;(null) }

    val surfaceRequests = remember { MutableStateFlow&lt;SurfaceRequest?&gt;(null) }
    val surfaceRequest by surfaceRequests.collectAsState(initial = null)

    // Bind camera once
    LaunchedEffect(Unit) {
        val provider = ProcessCameraProvider.awaitInstance(context)
        val preview = Preview.Builder().build().apply {
            setSurfaceProvider { req -&gt; surfaceRequests.value = req }
        }

        camera = provider.bindToLifecycle(
            lifecycleOwner,
            CameraSelector.DEFAULT_BACK_CAMERA,
            preview
        )
    }

    // Coordinate transformer: Compose UI → Camera surface
    val coordinateTransformer = remember { MutableCoordinateTransformer() }

    surfaceRequest?.let { request -&gt;
        CameraXViewfinder(
            surfaceRequest = request,
            coordinateTransformer = coordinateTransformer,
            modifier = modifier
                .fillMaxSize()
                .pointerInput(camera) {
                    // Tap-to-focus
                    detectTapGestures { offset -&gt;
                        val cam = camera ?: return@detectTapGestures

                        // Transform Compose coordinates to camera surface
                        val surfacePoint = with(coordinateTransformer) {
                            offset.transform()
                        }

                        val meteringFactory = SurfaceOrientedMeteringPointFactory(
                            request.resolution.width.toFloat(),
                            request.resolution.height.toFloat()
                        )

                        val focusPoint = meteringFactory.createPoint(
                            surfacePoint.x,
                            surfacePoint.y
                        )

                        val action = FocusMeteringAction.Builder(
                            focusPoint,
                            FocusMeteringAction.FLAG_AF or FocusMeteringAction.FLAG_AE
                        ).setAutoCancelDuration(3, TimeUnit.SECONDS).build()

                        cam.cameraControl
                            .startFocusAndMetering(action)
                            .addListener(
                                { onFocusTap(true) },
                                ContextCompat.getMainExecutor(context)
                            )
                    }
                }
                .pointerInput(camera) {
                    // Pinch-to-zoom
                    detectTransformGestures { _, _, zoom, _ -&gt;
                        val cam = camera ?: return@detectTransformGestures
                        val zoomState = cam.cameraInfo.zoomState.value ?: return@detectTransformGestures

                        val newRatio = (zoomState.zoomRatio * zoom).coerceIn(
                            zoomState.minZoomRatio,
                            zoomState.maxZoomRatio
                        )

                        cam.cameraControl.setZoomRatio(newRatio)
                    }
                }
        )
    }
}
</code></pre>

<p>看看这个点击对焦的实现。注意你<strong>没有</strong>做的事情：</p>

<ul>
<li>无需手动旋转补偿</li>
<li>无需进行坐标映射的宽高比计算</li>
<li>无需进行视图 → 表面 → 传感器坐标链计算</li>
<li>无需进行“祈祷它在横向模式下能正常工作”的漫长测试</li>
</ul>


<p><code>MutableCoordinateTransformer</code> 可以处理所有这些。你点击 Compose 坐标系，它会转换为相机坐标系，就完成了。</p>

<p>这就是“技术上可行”和“实际易于实现”之间的区别。</p>

<h2>拍摄照片和视频</h2>

<p>添加拍摄功能遵循相同的简洁模式——绑定其他用例，并从 Compose 界面触发它们。</p>

<p>我们还将仅在尝试录制时请求<strong>麦克风</strong>，并使用简单的“PermissionGate”模式（与我们项目在需要时仅请求音频的方法一致）。</p>

<pre><code class="kotlin">@Composable
fun CameraScreen() {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current

    var camera by remember { mutableStateOf&lt;Camera?&gt;(null) }
    var imageCapture by remember { mutableStateOf&lt;ImageCapture?&gt;(null) }
    var videoCapture by remember { mutableStateOf&lt;VideoCapture&lt;Recorder&gt;?&gt;(null) }
    var activeRecording by remember { mutableStateOf&lt;Recording?&gt;(null) }

    val surfaceRequests = remember { MutableStateFlow&lt;SurfaceRequest?&gt;(null) }
    val surfaceRequest by surfaceRequests.collectAsState(initial = null)

    // Bind all use cases
    LaunchedEffect(Unit) {
        val provider = ProcessCameraProvider.awaitInstance(context)

        val preview = Preview.Builder().build().apply {
            setSurfaceProvider { req -&gt; surfaceRequests.value = req }
        }

        imageCapture = ImageCapture.Builder()
            .setCaptureMode(ImageCapture.CAPTURE_MODE_MINIMIZE_LATENCY)
            .build()

            val recorder = Recorder.Builder()
            .setQualitySelector(QualitySelector.from(Quality.FHD))
            .build()
        videoCapture = VideoCapture.withOutput(recorder)

        camera = provider.bindToLifecycle(
            lifecycleOwner,
            CameraSelector.DEFAULT_BACK_CAMERA,
            preview,
            imageCapture!!,
            videoCapture!!
        )
    }

    Box(modifier = Modifier.fillMaxSize()) {
        // Camera preview
        surfaceRequest?.let { request -&gt;
            CameraXViewfinder(
                surfaceRequest = request,
                modifier = Modifier.fillMaxSize()
            )
        }

        // Compose UI controls
        Row(
            modifier = Modifier
                .align(Alignment.BottomCenter)
                .padding(bottom = 32.dp)
        ) {
            // Capture photo button
            IconButton(
                onClick = { capturePhoto(context, imageCapture) }
            ) {
                Icon(Icons.Default.PhotoCamera, "Take Photo")
            }

            Spacer(modifier = Modifier.width(32.dp))

            // Video record toggle (mic requested only when needed)
            PermissionGate(
                permission = Permission.RECORD_AUDIO,
                // Optional: custom UI if permission is not yet granted
                contentNonGranted = { missing, humanReadable, requestPermissions -&gt;
                    // Minimal, inline UX: re-request directly
                    Button(onClick = { requestPermissions(missing) }) {
                        Text("Grant $humanReadable")
                    }
                }
            ) {
                IconButton(
                    onClick = {
                        activeRecording = toggleRecording(
                            context,
                            videoCapture,
                            activeRecording
                        )
                    }
                ) {
                    Icon(
                        if (activeRecording == null) Icons.Default.RadioButtonUnchecked
                        else Icons.Default.Stop,
                        "Record Video"
                    )
                }
            }
        }
    }
}

private fun capturePhoto(context: Context, imageCapture: ImageCapture?) {
    val capture = imageCapture ?: return

    val name = "IMG_${System.currentTimeMillis()}.jpg"
    val contentValues = ContentValues().apply {
        put(MediaStore.Images.Media.DISPLAY_NAME, name)
        put(MediaStore.Images.Media.MIME_TYPE, "image/jpeg")
        // On Android 10+ you could also set RELATIVE_PATH = "DCIM/CameraX"
    }

    val outputOptions = ImageCapture.OutputFileOptions.Builder(
        context.contentResolver,
        MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
        contentValues
    ).build()

    capture.takePicture(
        outputOptions,
        ContextCompat.getMainExecutor(context),
        object : ImageCapture.OnImageSavedCallback {
            override fun onImageSaved(output: ImageCapture.OutputFileResults) {
                // Success: output.savedUri
            }
            override fun onError(exception: ImageCaptureException) {
                // Handle error
            }
        }
    )
}

private fun toggleRecording(
    context: Context,
    videoCapture: VideoCapture&lt;Recorder&gt;?,
    currentRecording: Recording?
): Recording? {
    val capture = videoCapture ?: return null

    // Stop if already recording
    if (currentRecording != null) {
        currentRecording.stop()
        return null
    }

    // Start new recording
    val name = "VID_${System.currentTimeMillis()}.mp4"
    val contentValues = ContentValues().apply {
        put(MediaStore.Video.Media.DISPLAY_NAME, name)
        // On Android 10+ you could also set RELATIVE_PATH = "DCIM/CameraX"
    }

    val outputOptions = MediaStoreOutputOptions.Builder(
        context.contentResolver,
        MediaStore.Video.Media.EXTERNAL_CONTENT_URI
    ).setContentValues(contentValues).build()

    return capture.output
        .prepareRecording(context, outputOptions)
        .withAudioEnabled() // mic permission is ensured by PermissionGate above
        .start(ContextCompat.getMainExecutor(context)) { event -&gt;
            // Handle recording events (e.g., finalize, error)
        }
}
</code></pre>

<p>这是纯粹的 Compose UI 构建。你的相机按钮与预览位于同一个可组合树中。没有桥接逻辑。无需管理单独的 View 层次结构。</p>

<h2>迁移策略：PreviewView → CameraXViewfinder</h2>

<p>如果你现有的相机代码使用“PreviewView”，则迁移路径如下：</p>

<p><strong>迁移前（旧方法）：</strong></p>

<pre><code class="kotlin">@Composable
fun OldCameraPreview() {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current
    val previewView = remember { PreviewView(context) }

    LaunchedEffect(previewView) {
        val provider = ProcessCameraProvider.getInstance(context).get()
        val preview = Preview.Builder().build()
        preview.setSurfaceProvider(previewView.surfaceProvider)
        provider.bindToLifecycle(lifecycleOwner, CameraSelector.DEFAULT_BACK_CAMERA, preview)
    }

    AndroidView(
        factory = { previewView },
        modifier = Modifier.fillMaxSize()
    )
}
</code></pre>

<p><strong>迁移后（Compose 原生方法）：</strong></p>

<pre><code class="kotlin">@Composable
fun NewCameraPreview() {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current
    val selector = CameraSelector.DEFAULT_BACK_CAMERA

    val surfaceRequests = remember { MutableStateFlow&lt;SurfaceRequest?&gt;(null) }
    val surfaceRequest by surfaceRequests.collectAsState(initial = null)

    LaunchedEffect(Unit) {
        val provider = ProcessCameraProvider.awaitInstance(context)
        val preview = Preview.Builder().build().apply {
            setSurfaceProvider { req -&gt; surfaceRequests.value = req }
        }
        provider.unbindAll()
        provider.bindToLifecycle(lifecycleOwner, selector, preview)
    }

    surfaceRequest?.let {
        CameraXViewfinder(
            surfaceRequest = it,
            modifier = Modifier.fillMaxSize()
        )
    }
}
</code></pre>

<p>关键的思维转变：不再将 View 的“SurfaceProvider”赋予 CameraX，而是将“SurfaceRequest”对象发布到 Compose 状态，并使用“CameraXViewfinder”进行渲染。</p>

<h2>所需依赖项</h2>

<p>添加到你的 <code>build.gradle.kts</code> 中：</p>

<pre><code class="kotlin">val cameraxVersion = "1.5.1"dependencies {
    implementation("androidx.camera:camera-core:$cameraxVersion")
    implementation("androidx.camera:camera-camera2:$cameraxVersion")
    implementation("androidx.camera:camera-lifecycle:$cameraxVersion")
    implementation("androidx.camera:camera-video:$cameraxVersion")

    // The new Compose-native viewfinder
    implementation("androidx.camera:camera-compose:$cameraxVersion")
}
</code></pre>

<p>清单权限：</p>

<pre><code class="xml">&lt;uses-permission android:name="android.permission.CAMERA" /&gt;
&lt;uses-permission android:name="android.permission.RECORD_AUDIO" /&gt;
</code></pre>

<h2><strong>实现模式（性能 vs. 合成）</strong></h2>

<p><code>CameraXViewfinder</code> 可以通过两种方式渲染预览：</p>

<h3><strong>EXTERNAL（SurfaceView 支持）</strong></h3>

<p>相机帧在其<strong>自己的 Surface</strong> 上渲染，由系统在 Compose 绘制通道<strong>之外</strong>合成。可以想象成“UI 背后的实时视频层”。通常启用硬件叠加 → 最佳性能/延迟。非常适合在标准 UI 后方显示全屏矩形预览。由于它是一个单独的层，因此对<em>相机像素</em>的逐像素效果（复杂的裁剪/模糊）不适用。</p>

<ul>
<li>优点：延迟更低，GPU 负载更少，非常适合全屏预览/录制。</li>
<li>缺点：不受逐像素界面特效（圆角蒙版/模糊）的影响，不会显示在 Compose 屏幕截图中。</li>
</ul>


<h3><strong>嵌入式（TextureView 支持）</strong></h3>

<p>相机帧作为<strong>GPU 纹理</strong>绘制在 Compose 渲染通道<strong>内部</strong>——类似于<strong>可重绘面板</strong>，其行为与其他可组合项类似。你可以获得深度裁剪/蒙版/动画/模糊/Z 轴排序，但代价是 GPU 工作量增加，延迟略高。</p>

<ul>
<li>优点：行为类似于普通界面；裁剪、Alpha 通道、模糊、特殊形状和复杂 Z 轴排序均正常。</li>
<li>缺点：GPU 工作量增加 → 在繁重的界面或中端设备上，延迟/卡顿风险略高。</li>
</ul>


<h3><strong>经验法则</strong></h3>

<ul>
<li>全屏/高性能 → <strong>外部</strong></li>
<li>特殊构图/特效 → <strong>嵌入式</strong>。</li>
</ul>


<p>如果你未指定模式，库将选择一个合理的默认模式。强制使用以下方式：</p>

<pre><code class="kotlin">import androidx.camera.viewfinder.core.ImplementationMode

CameraXViewfinder(
    surfaceRequest = request,
    implementationMode = ImplementationMode.EXTERNAL // or ImplementationMode.EMBEDDED
)
</code></pre>

<h2>实际操作中的陷阱</h2>

<p><strong>坐标变换并非可选</strong>
不要将原始 Compose 偏移量传递给测量工厂。务必使用坐标变换器。数学运算看起来很简单，直到你在横屏、可折叠设备或非标准宽高比设备上进行测试。</p>

<p><strong>前置摄像头是镜像的</strong>
如果你正在绘制叠加层或处理拍摄的图像，请记住前置摄像头预览默认是镜像的，但拍摄的图像不是。在你的界面/处理逻辑中考虑到这一点。</p>

<p><strong>在真实设备上测试</strong>
不同 OEM 的相机行为有所不同。在 Pixel 上完美运行的功能在三星或小米上可能存在问题。在代表性硬件上测试你的关键流程。</p>

<p><strong>权限用户体验</strong>
在入口点请求 <code>CAMERA</code>；仅在开始录制时请求 <code>RECORD_AUDIO</code>（这是一种良好做法）。上面的内联 <code>PermissionGate</code> 模式将该逻辑保留在你的 Compose 树中。</p>

<h2>高级功能：可折叠和自适应 UI</h2>

<p>由于 <code>CameraXViewfinder</code> 只是另一个可组合项，因此可折叠支持非常简单。简单的双窗格布局或全屏布局通常就足够了；如果需要，可以使用 <code>AnimatedContent</code> 来在状态之间添加动画。</p>

<pre><code class="kotlin">@Composable
fun AdaptiveCameraScreen(surfaceRequest: SurfaceRequest?) {
    val expanded = remember { mutableStateOf(false) } // pretend this reflects window size/hinge state

    AnimatedContent(targetState = expanded.value, label = "layout") { isExpanded -&gt;
        if (isExpanded) {
            Row(Modifier.fillMaxSize()) {
                surfaceRequest?.let {
                    CameraXViewfinder(
                        surfaceRequest = it,
                        modifier = Modifier
                            .weight(1f)
                            .aspectRatio(9f / 16f)
                    )
                }
                Box(Modifier.weight(1f)) { /* CameraControls(Modifier.align(Alignment.Center)) */ }
            }
        } else {
            Box(Modifier.fillMaxSize()) {
                surfaceRequest?.let {
                    CameraXViewfinder(
                        surfaceRequest = it,
                        modifier = Modifier.fillMaxSize()
                    )
                }
                /* CameraControls(Modifier.align(Alignment.BottomCenter)) */
            }
        }
    }
}
</code></pre>

<h2>测试清单（实用）</h2>

<ul>
<li>验证纵向/横向以及 <code>ContentScale.Crop/Fit</code> 模式下的点击对焦精度。</li>
<li>测试缩放限制；确保捏合和程序化缩放过渡流畅。</li>
<li>切换摄像头（前/后）并重新验证变换 + 镜像行为。</li>
<li>导航离开/后退、旋转和处理配置更改；预览应能够恢复且不闪烁。</li>
<li>在对焦/缩放时录制视频；确保没有表面掉落。</li>
</ul>


<h2>全局展望</h2>

<p>此版本的重要性不仅在于它带来的功能，还在于它所传递的信息。</p>

<p>多年来，Android 中的相机开发一直感觉像是二等公民。除了相机页面之外，你可以在任何地方使用 Compose 构建现代 UI，而相机页面则需要你勉强才能与 View 进行互操作。虽然 Compose 确实有效，但编写代码时总感觉像是被束缚了一只手。</p>

<p><code>camera-compose</code> 不仅仅是一个新产物。CameraX 团队曾说过：“Compose 现在是一流的相机开发平台。”</p>

<p>这意味着：</p>

<ul>
<li>未来的相机功能将在设计时充分考虑 Compose，而不是对其进行改造。</li>
<li>社区将构建以 Compose 为先的相机库和组件。</li>
<li>最佳实践将围绕可组合相机 UI 不断发展。</li>
<li>文档和示例将反映现代 Android 开发。</li>
</ul>


<p>我们在整个 Android 生态系统中都看到了这种模式——最初以 View 为中心的 API 正在逐渐获得 Compose 原生的对应版本。<code>camera-compose</code> 就是迄今为止最具影响力的例子之一。</p>

<h2>你现在应该做什么</h2>

<p><strong>如果你正在开发一个新的相机功能：</strong>
从一开始就使用 <code>CameraXViewfinder</code>。甚至不需要考虑 <code>PreviewView</code>。它的代码更简洁，思维模型更简单，你以后会感谢自己的。</p>

<p><strong>如果你已经有相机代码：</strong>
将 <code>camera-compose</code> 添加到你的依赖项中，并一次迁移一个页面。从最简单的相机 UI（可能是基本的纯预览页面）开始，熟悉新的 API。然后再处理复杂的部分。</p>

<p><strong>如果你正在构建一个库：</strong>
现在是时候将 Compose 原生相机组件添加到你的 SDK 中了。开发者正在寻找可组合的相机解决方案，而生态系统已经为他们做好了准备。</p>

<h2>延伸阅读</h2>

<ul>
<li><a href="https://developer.android.com/jetpack/androidx/releases/camera">CameraX 发行说明</a> — 官方更新日志和工件</li>
<li><a href="https://developer.android.com/jetpack/androidx/releases/camera-viewfinder">Camera Viewfinder 文档</a> — 实现模式、缩放和对齐</li>
<li><a href="https://github.com/androidx/androidx/tree/androidx-main/camera">CameraX GitHub 示例</a> — 真实代码示例</li>
</ul>


<h2>国王已死 / 国王万岁</h2>

<p>“AndroidView”相机预览的时代已经结束。如果你要在 2025 年及以后构建相机功能，那么你将使用 Compose 来构建它们。现在终于有了可以正确支持这些功能的工具。</p>

<p>现在，甩掉那个“AndroidView”包装器，编写一些漂亮的相机 UI 吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解retain{}的内部机制：Jetpack Compose中基于作用域的状态保存]]></title>
    <link href="https://alexhilton.github.io/blog/2025/10/22/understanding-retrain-internals/"/>
    <updated>2025-10-22T22:29:55+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/10/22/understanding-retrain-internals</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Understanding retain{} internals: A Scope-based State Preservation in Jetpack Compose」，原文链接<a href="https://proandroiddev.com/understanding-retain-internals-a-new-way-to-preserve-state-in-jetpack-compose-54471a32fd05">https://proandroiddev.com/understanding-retain-internals-a-new-way-to-preserve-state-in-jetpack-compose-54471a32fd05</a>，由Jaewoong Eum发布于2025年10月15日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/1*yQo3amM25om4TWkUzgxjvQ.jpeg" title="auto auto" ></a></p>

<!-- more -->


<p>Jetpack Compose 是一种现代 Android UI 开发方式，拥有声明式方法和强大的状态管理原语。虽然 <code>remember{}</code> 能够很好地在重组过程中保存状态，但它有一个根本性的局限性：它无法在配置更改或导航转换后继续生效。引入 <code>retain{}</code>，这是一种在瞬时销毁场景下保存状态的新方法，同时保持可组合性。</p>

<p>在本文中，你将深入了解 <code>retain{}</code>、<code>RetainScope</code>、<code>RetainObserver</code> 和 <code>RetainedEffect</code> 的内部机制，探索它们的底层工作原理，以及使 Retention 既内存安全又性能卓越的优化方法。</p>

<p>如果你尚未阅读以下之前的文章，理解以下部分将对你有所帮助：</p>

<ul>
<li><a href="https://medium.com/proandroiddev/exploring-retain-api-a-new-way-to-persist-state-in-jetpack-compose-bfb2fe2eae43">预览 retain{} API：Jetpack Compose 中持久化状态的新方法</a></li>
<li><a href="https://medium.com/proandroiddev/previewing-retainedeffect-a-new-side-effect-to-bridge-between-composition-and-retention-lifecycles-685b9e543de7">预览 RetainedEffect：桥接 Composition 和 Retention 生命周期的新 Side Effect</a></li>
</ul>


<h2>导入 Compose 运行时 retain 库</h2>

<p>你可以使用以下依赖项导入 Compose 运行时 retain 库：</p>

<pre><code class="kotlin">implementation("androidx.compose.runtime:runtime-retain:1.10.0-alpha05")
</code></pre>

<p>请注意，此库目前处于实验阶段，未来将不断完善和稳定发布。</p>

<h2>理解核心问题：为什么 remember{} 还不够</h2>

<p>从本质上讲，<code>remember{}</code> 可以在单个组合生命周期内跨重组保留状态。但是，当你的 Activity 因配置更改而重新创建时会发生什么？或者当导航目标从返回堆栈中移除时？状态会丢失，你的可组合项会重新开始。</p>

<p>传统的 Android 解决方案涉及 <code>ViewModel</code> 和 <code>SavedStateHandle</code>，但它们本身也具有复杂性：序列化要求、手动状态恢复以及在可组合项层次结构之外管理状态的认知开销。如果我们可以拥有一个像 <code>remember{}</code> 一样工作，但又能在这些瞬时销毁后继续存在的东西，那会怎样？</p>

<pre><code class="kotlin">// With remember: state lost on configuration change
@Composable
fun VideoPlayer() {
    val player = remember { MediaPlayer() } // Lost on rotation!
}

// With retain: state preserved across configuration changes
@Composable
fun VideoPlayer() {
    val player = retain { MediaPlayer() } // Survives rotation!
}
</code></pre>

<p><code>retain{}</code> 背后的关键洞察是，状态销毁并不总是永久性的。通常，它是暂时的；内容会被重新创建，恢复之前的状态会对我们有利。这就是“RetainScope”发挥作用的地方。</p>

<h2>retain{} API 及其生命周期</h2>

<p>如果你检查 retain 函数签名，会发现它与 <code>remember</code> API 类似，但存在以下区别：</p>

<pre><code class="kotlin">@Composable
public inline fun &lt;reified T&gt; retain(noinline calculation: () -&gt; T): T

@Composable
public inline fun &lt;reified T&gt; retain(vararg keys: Any?, noinline calculation: () -&gt; T): T
</code></pre>

<p>带有 <code>reified</code> 类型参数的 inline 修饰符无需显式类参数即可实现类型安全的保留。但真正的魔力在于其实现：</p>

<pre><code class="kotlin">@Composable
private fun &lt;T&gt; retainImpl(key: RetainKeys, calculation: () -&gt; T): T {
    val retainScope = LocalRetainScope.current
    val holder = remember(key) {
        val retainedValue = retainScope.getExitedValueOrDefault(key, RetainScopeMissingValue)
        if (retainedValue !== RetainScopeMissingValue) {
            RetainedValueHolder(
                key = key,
                value = @Suppress("UNCHECKED_CAST") (retainedValue as T),
                owner = retainScope,
                isNewlyRetained = false,
            )
        } else {
            RetainedValueHolder(
                key = key,
                value = calculation(),
                owner = retainScope,
                isNewlyRetained = true,
            )
        }
    }

    if (holder.owner !== retainScope) {
        SideEffect { holder.readoptUnder(retainScope) }
    }
    return holder.value
}
</code></pre>

<p>此实现揭示了保留的两个阶段特性：</p>

<p><strong>阶段 1：记忆阶段</strong>。<code>retain{}</code> 首先使用 <code>remember{}</code> 创建一个 <code>RetainedValueHolder</code>。该持有者包装实际值并跟踪其生命周期。</p>

<p><strong>阶段 2：保留阶段</strong>。当持有者离开组合时，<code>RetainScope</code> 不会立即将其丢弃，而是决定是否将其保留以备将来恢复。</p>

<h2>RetainedValueHolder 和 RetainScope</h2>

<p>首先，如果你仔细研究 <code>RetainedValueHolder</code> 的内部代码，你会发现它是生命周期管理发生的地方。它实现了 <code>RememberObserver</code> 接口，以便与 Compose 的生命周期挂钩：</p>

<pre><code class="kotlin">internal class RetainedValueHolder&lt;out T&gt; internal constructor(
    val key: Any,
    val value: T,
    owner: RetainScope,
    private var isNewlyRetained: Boolean,
) : RememberObserver {

    override fun onRemembered() {
        if (value is RetainObserver) {
            if (isNewlyRetained) {
                isNewlyRetained = false
                value.onRetained()
            }
            value.onEnteredComposition()
        }
    }

    override fun onForgotten() {
        if (owner.isKeepingExitedValues) {
            owner.saveExitingValue(key, value)
        }

        if (value is RetainObserver) {
            value.onExitedComposition()
            if (!owner.isKeepingExitedValues) value.onRetired()
        }
    }

    override fun onAbandoned() {
        if (owner.isKeepingExitedValues) {
            if (value is RetainObserver) value.onRetained()
            owner.saveExitingValue(key, value)
        } else if (value is RetainObserver) {
            value.onUnused()
        }
    }
}
</code></pre>

<p>重要的一点是，该持有者会拦截组合生命周期事件并将其转换为保留事件。当 <code>onForgotten()</code> 被调用时（值离开组合），它会检查 <code>RetainScope</code> 是否保留了已退出的值。如果是，它会保存该值以供将来恢复，而不是丢弃它。</p>

<p><code>RetainScope</code> 是保留系统的核心概念。它管理何时保留值、如何存储它们以及何时恢复或退出它们。让我们来看看它的细节：</p>

<pre><code class="kotlin">public abstract class RetainScope : RetainStateProvider {
    protected var keepExitedValuesRequests: Int = 0
        private set

    final override val isKeepingExitedValues: Boolean
        get() = keepExitedValuesRequests &gt; 0

    public abstract fun getExitedValueOrDefault(key: Any, defaultIfAbsent: Any?): Any?
    protected abstract fun saveExitingValue(key: Any, value: Any?)
    protected abstract fun onStartKeepingExitedValues()
    protected abstract fun onStopKeepingExitedValues()
}
</code></pre>

<p>作用域有两种运行模式：</p>

<ol>
<li><strong>普通模式</strong> (<code>isKeepingExitedValues = false</code>)：值离开组合时会被丢弃，就像 <code>remember{}</code> 一样。</li>
<li><strong>保留模式</strong> (<code>isKeepingExitedValues = true</code>)：值退出时会被保留，以便将来恢复。</li>
</ol>


<p>那么，保留生命周期是如何运作的呢？通过原始源代码中嵌入的图表可以最好地理解保留生命周期：</p>

<pre><code class="bash">┌──────────────────────┐
│                      │
│ retain(keys) { ... } │
│        ┌────────────┐│
└────────┤  value: T  ├┘
         └──┬─────────┘
            │   ▲
        Exit│   │Enter
 composition│   │composition
   or change│   │
        keys│   │                         ┌──────────────────────────┐
            │   ├───No retained value─────┤   calculation: () -&gt; T   │
            │   │   or different keys     └──────────────────────────┘
            │   │                         ┌──────────────────────────┐
            │   └───Re-enter composition──┤    Local RetainScope     │
            │       with the same keys    └─────────────────┬────────┘
            │                                           ▲   │
            │                      ┌─Yes────────────────┘   │ value not
            │                      │                        │ restored and
            │   .──────────────────┴──────────────────.     │ scope stops
            └─▶(   RetainScope.isKeepingExitedValues   )    │ keeping exited
                `──────────────────┬──────────────────'     │ values
                                   │                        ▼
                                   │      ┌──────────────────────────┐
                                   └─No──▶│     value is retired     │
                                          └──────────────────────────┘
</code></pre>

<p>此流程揭示了几个关键的见解：</p>

<ol>
<li><strong>保留是有条件的</strong>：只有当 <code>isKeepingExitedValues</code> 为 <code>true</code> 时，值才会被保留。</li>
<li><strong>键很重要</strong>：即使在保留期间，更改的键也会导致立即退出。</li>
<li><strong>恢复是自动的</strong>：当内容使用相同的键重新输入时，保留的值将被恢复。</li>
<li><strong>退出是最终的</strong>：保留停止时未恢复的值将被退出。</li>
</ol>


<h2>ControlledRetainScope：可变实现</h2>

<p>虽然 <code>RetainScope</code> 提供了抽象，但 <code>ControlledRetainScope</code> 才是主要的实现：</p>

<pre><code class="kotlin">public class ControlledRetainScope : RetainScope() {
    private val keptExitedValues = SafeMultiValueMap&lt;Any, Any?&gt;()

    override fun saveExitingValue(key: Any, value: Any?) {
        keptExitedValues.add(key, value)
    }

    @Suppress("UNCHECKED_CAST")
    override fun getExitedValueOrDefault(key: Any, defaultIfAbsent: Any?): Any? {
        return keptExitedValues.removeLast(key, defaultIfAbsent)
    }

    override fun onStopKeepingExitedValues() {
        keptExitedValues.forEachValue { value -&gt;
            if (value is RetainObserver) value.onRetired()
        }
        keptExitedValues.clear()
    }
}
</code></pre>

<p>该实现使用 <code>SafeMultiValueMap</code> 进行存储是一个重要的设计选择。为什么？因为多个 retain 调用可以具有相同的键：</p>

<pre><code class="kotlin">@Composable
fun Example() {
    // Both have the same positional key!
    val value1 = retain { "First" }
    val value2 = retain { "Second" }
}
</code></pre>

<p>该映射按 LIFO（后进先出）顺序存储每个键的值。恢复时，<code>removeLast()</code> 确保值按其存储的相反顺序恢复，从而保持 retain 调用与其值之间的正确配对。</p>

<p>此外，<code>ControlledRetainScope</code> 支持嵌套在父级 <code>RetainStateProvider</code> 下：</p>

<pre><code class="kotlin">public fun setParentRetainStateProvider(parent: RetainStateProvider) {
    val oldParent = parentScope
    parentScope = parent

    parent.addRetainStateObserver(parentObserver)
    oldParent.removeRetainStateObserver(parentObserver)

    if (parent.isKeepingExitedValues) startKeepingExitedValues()
    if (oldParent.isKeepingExitedValues) stopKeepingExitedValues()
}
</code></pre>

<p>这支持有序的层次结构，其中子作用域从父级继承保留状态。你可以利用此功能使所有 <code>RetainScopes</code> 在配置更改期间保留，根作用域会检测到配置更改，并沿层次结构向下级联保留。</p>

<h2>RetainObserver：保留对象的生命周期回调</h2>

<p>需要了解其保留生命周期的对象需要实现 <code>RetainObserver</code>：</p>

<pre><code class="kotlin">@Suppress("CallbackName")
public interface RetainObserver {
    public fun onRetained()

    // Successfully retained
    public fun onEnteredComposition() // Entered composition
    public fun onExitedComposition()  // Exited composition
    public fun onRetired()

    // No longer retained
    public fun onUnused()

    // Created but never used
}
</code></pre>

<p>这些回调实现了 <code>remember{}</code> 无法实现的资源管理模式。设想一个媒体播放器，当屏幕未显示时应该暂停，但如果可能再次显示，则不应释放资源：</p>

<pre><code class="kotlin">class RetainableMediaPlayer : RetainObserver {
    private var player: MediaPlayer? = null

    override fun onRetained() {
        player = MediaPlayer()
    }

    override fun onEnteredComposition() {
        player?.play()
    }

    override fun onExitedComposition() {
        player?.pause() // Just pause, don't release
    }

    override fun onRetired() {
        player?.release() // Now we can release
        player = null
    }

    override fun onUnused() {
        // Never entered composition, clean up
        player?.release()
        player = null
    }
}
</code></pre>

<p>还应记住，回调遵循严格的顺序保证。当多个 <code>RetainObserver</code> 同时进入组合状态时，它们的 <code>onEnteredComposition</code> 回调将按顺序触发。退出时，<code>onExitedComposition</code> 将按相反顺序触发<strong>，</strong>以确保正确清理嵌套资源。</p>

<h2>RememberObserver 限制</h2>

<p>你可以在 <code>RetainedValueHolder</code> 中找到一个有趣的安全检查：</p>

<pre><code class="kotlin">init {
    if (value is RememberObserver &amp;&amp; value !is RetainObserver) {
        throw IllegalArgumentException(
            "Retained a value that implements RememberObserver but not RetainObserver. " +
            "To receive the correct callbacks, the retained value '$value' must also " +
            "implement RetainObserver."
        )
    }
}
</code></pre>

<p>为什么有这个限制？<code>RememberObserver</code> 回调（<code>onRemembered</code>、<code>onForgotten</code>、<code>onAbandoned</code>）与保留语义不一致。暂时脱离组合的保留值不会被“遗忘”，而是处于不确定状态，可能会再次返回。使用 <code>RememberObserver</code> 会导致错误的生命周期回调，因此库强制使用 <code>RetainObserver</code>。</p>

<h2>RetainedEffect：保留后仍存在的副作用</h2>

<p><code>RetainedEffect</code> 将保留的概念扩展到副作用：</p>

<pre><code class="kotlin">@Composable
public fun RetainedEffect(key1: Any?, effect: RetainedEffectScope.() -&gt; RetainedEffectResult) {
    retain(key1) { RetainedEffectImpl(effect) }
}

private class RetainedEffectImpl(
    private val effect: RetainedEffectScope.() -&gt; RetainedEffectResult
) : RetainObserver {
    private var onRetire: RetainedEffectResult? = null

    override fun onRetained() {
        onRetire = InternalRetainedEffectScope.effect()
    }

    override fun onRetired() {
        onRetire?.retire()
        onRetire = null
    }

    // Other callbacks are no-ops
}
</code></pre>

<p>实现非常简单：它将 effect 包装在一个 <code>RetainObserver</code> 中，该 <code>RetainObserver</code> 在保留时执行 effect，并在退出时进行清理。与 DisposableEffect 不同，DisposableEffect 在离开组合时运行其处置，而 RetainedEffect 仅在真正退出时处置：</p>

<pre><code class="kotlin">@Composable
fun VideoPlayer(mediaUri: String) {
    val player = retain(mediaUri) { MediaPlayer(mediaUri) }

    // DisposableEffect would dispose on every hide/show
    // RetainedEffect only disposes when truly done
    RetainedEffect(player) {
        player.initialize()
        onRetire {
            player.close() // Only called when player is retired
        }
    }
}
</code></pre>

<p>这是一个很好的例子，说明在短暂的 UI 变化期间不应重新创建昂贵的资源。</p>

<h2>RetainedContentHost 和 RetainScopeHolder</h2>

<p><code>compose-runtime-retain</code> 库提供了基于这些原语构建的更高级别的抽象。<code>RetainedContentHost</code> 管理显示/隐藏场景：</p>

<pre><code class="kotlin">@Composable
public fun RetainedContentHost(active: Boolean, content: @Composable () -&gt; Unit) {
    val retainScope = retainControlledRetainScope()
    if (active) {
        CompositionLocalProvider(LocalRetainScope provides retainScope, content)

        val composer = currentComposer
        DisposableEffect(retainScope) {
            val cancellationHandle =
                if (retainScope.keepExitedValuesRequestsFromSelf &gt; 0) {
                    composer.scheduleFrameEndCallback {
                        retainScope.stopKeepingExitedValues()
                    }
                } else {
                    null
                }

            onDispose {
                cancellationHandle?.cancel()
                retainScope.startKeepingExitedValues()
            }
        }
    }
}
</code></pre>

<p>该实现揭示了一些时间控制：</p>

<p><strong>变为活动状态</strong>：安排在帧结束时停止保留，确保所有内容都首先恢复其值。</p>

<p><strong>变为非活动状态</strong>：在内容被移除之前立即开始保留。</p>

<p>这确保了值在需要时被准确保留，不会太早（这会阻止恢复），也不会太晚（这会丢失值）。</p>

<p>对于列表等动态内容，<code>RetainScopeHolder</code> 负责管理每个项目的保留：</p>

<pre><code class="kotlin">public class RetainScopeHolder() {
    private val childScopes = MutableScatterMap&lt;Any?, ControlledRetainScope&gt;()

    public fun getOrCreateRetainScopeForChild(key: Any?): RetainScope {
        return childScopes.getOrPut(key) {
            ControlledRetainScope().apply {
                if (isParentKeepingExitedValues) startKeepingExitedValues()
            }
        }
    }

    @Composable
    public fun RetainScopeProvider(key: Any?, content: @Composable () -&gt; Unit) {
        CompositionLocalProvider(
            LocalRetainScope provides getOrCreateRetainScopeForChild(key)
        ) {
            content()
            PresenceIndicator(key)
        }
    }

    @Composable
    private fun PresenceIndicator(key: Any?) {
        val composer = currentComposer
        DisposableEffect(key) {
            val endRetainHandle =
                if (keepExitedValuesRequestsFor(key) &gt; 0) {
                    composer.scheduleFrameEndCallback {
                        stopKeepingExitedValues(key)
                    }
                } else {
                    null
                }
            onDispose {
                endRetainHandle?.cancel()
                startKeepingExitedValues(key)
            }
        }
    }
}
</code></pre>

<p><code>PresenceIndicator</code> 可组合项是一种巧妙的模式。它按组合顺序放置在内容<strong>之后</strong>，以确保正确的生命周期管理。移除时，它会触发保留。添加时，它会安排在帧完成后停止保留。</p>

<h2>内存和性能考量</h2>

<p>该实现中进行了值得理解的权衡：</p>

<p><strong>内存优先于 CPU</strong>：保留值在内存中保留的时间比 <code>remember{}</code> 更长。这用内存换取了重新创建时的 CPU 开销。对于开销较大的对象（例如位图、媒体播放器），这通常是值得的。</p>

<p><strong>O(n) 范围操作</strong>：查找要恢复或退出的值需要迭代存储的值。对于包含数十个保留值的典型用例，这可以忽略不计。</p>

<p><strong>惰性分配</strong>：仅在需要时分配缓冲区和存储空间。未使用的 <code>RetainScope</code> 开销极小。</p>

<p><strong>通过具体化实现类型安全</strong>：内联/具体化模式消除了运行时类型检查的需要，同时保持了类型安全。</p>

<p><strong>默认为组合范围</strong>：与 ViewModel（应用范围）或 rememberSaveable（Activity范围）不同，retain 是组合范围的，可以对保留边界进行细粒度的控制。</p>

<p>另外，需要注意的是，不要将长期存活的对象保留在其预期作用域之外，以免造成内存泄漏，正如 Compose 库中的以下注释所示。</p>

<pre><code class="kotlin">/**
 * 重要提示：保留值的保存时间比其所关联的可组合项的生命周期长。
 * 如果保留对象的保存时间超过其预期的
 * 生命周期，则可能导致内存泄漏。请谨慎选择保留的数据类型。切勿保留 Android 上下文或
 * 直接或间接引用上下文（包括视图）的对象。
 */
</code></pre>

<h2>测试保留机制</h2>

<p>一个有趣的<a href="https://github.com/androidx/androidx/blob/942319dfe9d751390febcef640d43290886f1a0b/compose/runtime/runtime-retain/src/commonTest/kotlin/androidx/compose/runtime/retain/RetainTests.kt#L866">内部单元测试用例</a> 表明，该库可以处理边缘情况并保证：</p>

<pre><code class="kotlin">@Test
fun retain_duplicateRetainKeys() = compositionTest {
    val scope = ControlledRetainScope().apply { startKeepingExitedValues() }
    var showContent = true

    compose {
        CompositionLocalProvider(value = LocalRetainScope provides scope) {
            if (showContent) {
                // All have same key!
                retain { CountingRetainObject() }
                retain { CountingRetainObject() }
                retain { CountingRetainObject() }
            }
        }
    }

    // Hide and show content
    showContent = false
    recomposeScope.invalidate()
    advance()

    showContent = true
    recomposeScope.invalidate()
    advance()

    // All values correctly restored despite duplicate keys
}
</code></pre>

<p>测试验证了即使存在重复的键（在循环或生成的内容中很常见），值也能通过后进先出 (LIFO) 顺序与其保留调用正确配对。</p>

<h2>结论</h2>

<p>在本文中，我们探索了 <code>retain{}</code>、<code>RetainScope</code>、<code>RetainObserver</code> 和 <code>RetainedEffect</code> API 的工作原理及其内部机制。了解这些内部机制有助于我们更好地决定何时使用 <code>retain{}</code>、<code>remember{}</code> 和 <code>rememberSaveable{}</code>，如何构建保留资源，以及预期的性能特征。</p>

<p>无论是构建可旋转的视频播放器、保留滚动位置的导航系统，还是在配置更改后保持状态的复杂表单，<code>retain{}</code> 都能在 Jetpack Compose 中提供基于作用域的状态保存功能。</p>

<p>如果你想了解最新的技能、新闻、技术文章、面试问题和实用代码技巧，请查看 <a href="https://github.com/doveletter/">Dove Letter</a>。如果你想深入了解面试准备，千万不要错过终极 Android 面试指南：<a href="https://www.android.skydoves.me/">Manifest Android Interview</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compose Unstyled：Compose UI中失传​​的设计系统层]]></title>
    <link href="https://alexhilton.github.io/blog/2025/09/11/compose-unstyled/"/>
    <updated>2025-09-11T00:17:33+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/09/11/compose-unstyled</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Compose Unstyled: The missing Design System layer for Compose UI」，原文链接<a href="https://composables.com/blog/introducing-compose-unstyled">https://composables.com/blog/introducing-compose-unstyled</a>，由Alex Styl发布于2025年8月7日。</p></blockquote>

<p><a href=""><img src="https://composables.com/og_unstyled.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>使用 Compose UI 构建应用的最大问题是 Material Compose 的灵活性不足。Material Compose 的可定制性不足以让你在其上构建自己的设计系统，因此你最终只能对其组件进行修改。另一方面，Compose Foundation 又过于“原始”——它有行和列，但没有按钮或底部表单。而且，由于主题设置与 Material 绑定，如果不完全遵循 Material 的设计决策，你甚至无法为你的应用设置主题。</p>

<p>你可以从头开始构建所有内容，但谁有时间这样做呢？考虑到不同的状态、可访问性和边缘情况，像底部表单这样的单个组件可能需要 3-4 周才能完成。这个问题在 Compose Multiplatform 中变得更加严重——Material 在 iOS 上看起来笨拙，在桌面上显得不成比例。</p>

<p>我需要一个灵活的解决方案，可以在任何平台上使用，而不受 Material 的限制。于是我撸起袖子，自己动手构建了一个：</p>

<p><strong><a href="https://composables.com/docs/com.composables/core">Compose Unstyled</a> 是基于 Compose Foundation 的 API，可轻松构建任何设计系统</strong> （链接：<a href="https://composables.com/docs/com.composables/core%EF%BC%89%E3%80%82%E5%AE%83%E6%8F%90%E4%BE%9B%E6%97%A0%E6%A0%B7%E5%BC%8F%E3%80%81%E5%8F%AF%E8%AE%BF%E9%97%AE%E7%9A%84%E7%BB%84%E4%BB%B6%EF%BC%8C%E5%B9%B6%E9%85%8D%E6%9C%89%E7%81%B5%E6%B4%BB%E7%9A%84%E4%B8%BB%E9%A2%98">https://composables.com/docs/com.composables/core%EF%BC%89%E3%80%82%E5%AE%83%E6%8F%90%E4%BE%9B%E6%97%A0%E6%A0%B7%E5%BC%8F%E3%80%81%E5%8F%AF%E8%AE%BF%E9%97%AE%E7%9A%84%E7%BB%84%E4%BB%B6%EF%BC%8C%E5%B9%B6%E9%85%8D%E6%9C%89%E7%81%B5%E6%B4%BB%E7%9A%84%E4%B8%BB%E9%A2%98</a> API——所有关于用户体验和可访问性的繁琐工作都已为你处理。</p>

<p>Unstyled 中的组件完全无需渲染，默认情况下不会在屏幕上显示任何内容。你可以将它们视为“组件模式”，它们将“底部表单”或“进度条”的概念引入你的应用，而无需你担心用户体验、键盘导航或可访问性实现。只需添加样式即可。</p>

<h2>简洁的 API，提供你所需的样式</h2>

<p>Compose Unstyled 不提供任何特殊的样式 API。所有操作都通过 <code>Modifier</code> 完成。如果你知道如何设置 <code>Box()</code> 的样式，那么你就知道如何设置 Compose Unstyled 中每个组件的样式。</p>

<p>下面是一个使用 Compose Unstyled 构建模态底部表单的简单示例，其中包含自定义定位点（表单在屏幕上“停留”的位置）以及你选择的样式：</p>

<pre><code class="kotlin">val Peek = SheetDetent("peek") { containerHeight, sheetHeight -&gt;
    containerHeight * 0.6f
}
BoxWithConstraints(modifier = Modifier.fillMaxSize().background(Brush.linearGradient(listOf(Color(0xFF800080), Color(0xFFDA70D6))))) {
    val modalSheetState = rememberModalBottomSheetState(
        initialDetent = Hidden,
        detents = listOf(Hidden, Peek, FullyExpanded)
    )
    LaunchedEffect(Unit) {
        delay(50)
        modalSheetState.targetDetent = Peek
    }
    Button(onClick = { modalSheetState.targetDetent = Peek }, modifier = Modifier.align(Alignment.Center).padding(WindowInsets.navigationBars.only(WindowInsetsSides.Horizontal).asPaddingValues()), shape = RoundedCornerShape(6.dp), contentPadding = PaddingValues(horizontal = 14.dp, vertical = 10.dp), backgroundColor = Color.White) {
        Text("Show Sheet", fontWeight = FontWeight(500))
    }
    val isCompact = maxWidth &lt; 600.dp
    ModalBottomSheet(state = modalSheetState) {
        Scrim(
            scrimColor = Color.Black.copy(0.3f),
            enter = fadeIn(),
            exit = fadeOut()
        )
        Box(Modifier.fillMaxSize().padding(top = 12.dp).let { if (isCompact) it else it.padding(horizontal = 56.dp) }.displayCutoutPadding().statusBarsPadding().padding(WindowInsets.navigationBars.only(WindowInsetsSides.Horizontal).asPaddingValues())) {
            Sheet(
                modifier = Modifier
                    .shadow(4.dp, RoundedCornerShape(topStart = 28.dp, topEnd = 28.dp))
                    .widthIn(max = 640.dp)
                    .fillMaxWidth(),
                shape = RoundedCornerShape(topStart = 28.dp, topEnd = 28.dp),
                backgroundColor = Color.White,
                contentColor = Color.Black
            ) {
                Box(Modifier.fillMaxWidth().height(600.dp), contentAlignment = Alignment.TopCenter) {
                    DragIndication(
                        modifier = Modifier.padding(top = 22.dp)
                            .background(Color.Black.copy(0.4f), RoundedCornerShape(100)).width(32.dp).height(4.dp)
                    )
                }
            }
        }
    }
}
</code></pre>

<p>现在，我知道你可能会想。“Alex！这 API 真奇怪。为什么我需要一个 <code>ModalBottomSheet</code> 和一个 <code>Sheet</code>？为什么不直接用 Slots 呢？”</p>

<p>这个设计选择是经过深思熟虑的：</p>

<h2>设计理念</h2>

<p>Compose Unstyled 不会替你做出任何设计决策，而是让你完全掌控布局。事实上，如果你被迫使用无法根据需求更改的样式，则会被视为错误（请提交 GitHub 问题，以便我进行调查）。</p>

<p>例如，你可能希望将底部表单放置在屏幕的左侧或右侧。当你想要求开发者提供一个在布局上具有严格位置的组件时，基于插槽的 API 非常实用。</p>

<p>在这种情况下，你可以将 <code>ModalBottomSheet</code> 组件视为表单可以移动的区域。<code>Sheet</code> 是用户可以与之交互的实际表单。通过提供这样的组件，它为开发者提供了清晰的 API，并清楚地说明了组件的功能。例如，<code>Scrim()</code> 组件具有 <em>enter</em> 和 <em>exit</em> 过渡参数。 Compose Unstyled 会在恰当的时机为纱幕添加和隐藏动画，以实现最佳用户体验。你只需指定“如何”实现即可。</p>

<p>由于 Compose Unstyled 在外观方面非常开放，因此与原始的 Compose Foundation 组件相比，它没有任何平台限制。Foundation 中的“对话框”具有固定的最大尺寸，这使得它们在诸如全屏对话框等情况下难以工作。</p>

<p>Compose Unstyled 中的所有组件在所有平台上的工作方式完全相同。这是有意为之，因为此类决策应该属于设计系统层的一部分。尽管这会给开发者带来更多负担，但由于没有“陷阱”，它大大缩短了开发时间。组件的样式与你描述的完全一致。</p>

<p>这不会使 Compose Unstyled 与底层平台脱节。在使用对话框和模态底部菜单等模态窗口时，设置系统窗口的样式是 Android 样式设置的重要组成部分。在这种情况下，Compose Unstyled 提供了一个 <code>LocalModalWindow</code> 组合本地接口，允许你访问渲染模态窗口的 <code>Window</code>。请注意，此类 API 仅适用于 Android 目标平台，不属于通用目标平台 API。</p>

<p>最后，每个组件的代码都包含在其自己的文件中，即使你不是 Compose 专家，也能轻松理解。你无需担心任何限制。如果你现在需要更改某些内容，并且迫不及待地想要提交错误并在库级别修复它，你只需将组件的单个文件复制粘贴到你的代码库中即可。这为你节省了通常需要你自己完成的 4 周工作时间。</p>

<h2>滑块</h2>

<p>以下是如何构建一个具有你所选样式的滑块。</p>

<p>它与 Compose 的“InteractionState”集成，以便你可以按照自己想要的方式完善组件。键盘交互功能开箱即用，用户可以通过按下键盘上的“向上”或“向下”键来增加或减少值：</p>

<p><img src="file:///Users/alexhilton/Downloads/compose-style-1.png" alt="" /></p>

<pre><code class="kotlin">Box(modifier = Modifier.fillMaxSize().background(Brush.linearGradient(listOf(Color(0xFFED213A), Color(0xFF93291E)))),   contentAlignment = Alignment.Center) {
    val interactionSource = remember { MutableInteractionSource() }
    val isFocused by interactionSource.collectIsFocusedAsState()
    val isPressed by interactionSource.collectIsPressedAsState()
    val state = rememberSliderState(initialValue = 0.7f)
    Row(verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(12.dp), modifier = Modifier.padding(horizontal = 16.dp).widthIn(max = 480.dp).fillMaxWidth()) {
        Button(onClick = { state.value -= 0.1f }, modifier = Modifier.shadow(4.dp, CircleShape), shape = CircleShape, backgroundColor = Color.White, contentPadding = PaddingValues(8.dp),) {
            Icon(VolumeDown, "Decrease")
        }
        Slider(
            interactionSource = interactionSource,
            state = state,
            modifier = Modifier.weight(1f),
            track = {
                Box(Modifier.fillMaxWidth().height(8.dp).padding(horizontal = 16.dp).clip(RoundedCornerShape(100.dp))) {
                    // the 'not yet completed' part of the track
                    Box(Modifier.fillMaxHeight().fillMaxWidth().background(Color(0xFF93291E)))
                    // the 'completed' part of the track
                    Box(Modifier.fillMaxHeight().fillMaxWidth(state.value).background(Color.White))
                }
            },
            thumb = {
                val thumbSize by animateDpAsState(targetValue = if (isPressed) 22.dp else 18.dp)
                val thumbInteractionSource = remember { MutableInteractionSource() }
                val isHovered by thumbInteractionSource.collectIsHoveredAsState()
                val glowColor by animateColorAsState(
                    if (isFocused || isHovered) Color.White.copy(0.33f) else Color.Transparent
                )
                // keep the size fixed to ensure that the resizing animation is always centered
                Box(
                    modifier = Modifier.size(36.dp).clip(CircleShape).background(glowColor),
                    contentAlignment = Alignment.Center
                ) {
                    Thumb(
                        color = Color.White,
                        modifier = Modifier.size(thumbSize).shadow(4.dp, CircleShape).hoverable(thumbInteractionSource),
                        shape = CircleShape,
                    )
                }
            }
        )
        Button(onClick = { state.value += 0.1f }, modifier = Modifier.shadow(4.dp, CircleShape), shape = CircleShape, backgroundColor = Color.White, contentPadding = PaddingValues(8.dp),) {
            Icon(VolumeUp, "Increase")
        }
    }
}
</code></pre>

<h2>下拉菜单</h2>

<p>下拉菜单的正确实现非常复杂，尤其是在键盘导航和焦点管理方面。</p>

<p>要充分体验此组件，请在桌面上试用：点击“Options”按钮以聚焦演示，然后使用键盘的上下箭头键进行导航：</p>

<p><img src="file:///Users/alexhilton/Downloads/compose-style-2.png" alt="" /></p>

<pre><code class="kotlin">class DropdownOption(val text: String, val icon: ImageVector, val enabled: Boolean = true, val dangerous: Boolean = false)
val options = listOf(
    DropdownOption("Select All", Maximize),
    DropdownOption("Copy", Copy),
    DropdownOption("Cut", Scissors, enabled = false),
    DropdownOption("Paste", Clipboard),
    DropdownOption("Delete", Trash2, dangerous = true),
)
var expanded by remember { mutableStateOf(true) }
DropdownMenu(onExpandRequest = { expanded = true }) {
    Button(shape = RoundedCornerShape(6.dp), backgroundColor = Color.White, onClick = { expanded = true }, contentPadding = PaddingValues(horizontal = 14.dp, vertical = 10.dp),) {
        Text("Options", fontWeight = FontWeight(500))
        Spacer(Modifier.width(8.dp))
        Icon(ChevronDown, null)
    }
    DropdownMenuPanel(
        expanded = expanded,
        onDismissRequest = { expanded = false },
        backgroundColor = Color.White,
        shape = RoundedCornerShape(8.dp),
        modifier = Modifier
            .padding(vertical = 4.dp)
            .width(240.dp)
            .shadow(4.dp, RoundedCornerShape(8.dp)),
        enter = scaleIn(
            animationSpec = tween(durationMillis = 120, easing = LinearOutSlowInEasing),
            initialScale = 0.8f,
            transformOrigin = TransformOrigin(0f, 0f)
        ) + fadeIn(tween(durationMillis = 30)),
        exit = scaleOut(animationSpec = tween(durationMillis = 1, delayMillis = 75), targetScale = 1f) + fadeOut(tween(durationMillis = 75))
    ) {
        options.forEachIndexed { index, option -&gt;
            if (index == 1 || index == options.lastIndex) {
                Separator(color = Color(0xFFBDBDBD))
            }
            Button(onClick = { expanded = false }, enabled = option.enabled, modifier = Modifier.padding(4.dp), contentPadding = PaddingValues(horizontal = 8.dp, vertical = 2.dp), contentColor = (if (option.dangerous) Color(0xFFC62828) else LocalContentColor.current).copy(alpha = if (option.enabled) 1f else 0.5f), shape = RoundedCornerShape(8.dp),) {
                Icon(option.icon, null)
                Spacer(Modifier.width(4.dp))
                Text(text = option.text, modifier = Modifier.fillMaxWidth().padding(vertical = 8.dp, horizontal = 4.dp))
            }
        }
    }
}
</code></pre>

<p>以及更多未样式化的组件，例如：</p>

<ul>
<li><a href="https://composables.com/docs/com.composables/core/textfield">TextField</a>，全面支持屏幕阅读器的无障碍功能</li>
<li><a href="https://composables.com/docs/com.composables/core/button">Button</a></li>
<li><a href="https://composables.com/docs/com.composables/core/dialog">Dialog</a></li>
<li><a href="https://composables.com/docs/com.composables/core/radiogroup">Radio Group</a></li>
<li><a href="https://composables.com/docs/com.composables/core/tabgroup">TabGroup</a>，用于构建标签式导航，例如底部应用栏或顶部标签桌面</li>
<li><a href="https://composables.com/docs/com.composables/core/checkbox">复选框</a></li>
<li><a href="https://composables.com/docs/com.composables/core/tristatecheckbox">三态复选框</a></li>
<li><a href="https://composables.com/docs/com.composables/core/toggleswitch">切换开关</a></li>
<li><a href="https://composables.com/docs/com.composables/core/scrollarea">滚动条</a>（没错，就是滚动条。）</li>
</ul>


<p>每个组件在构建时都充分考虑了可访问性，包括合理的语义和完整的键盘导航支持。</p>

<p>你可以<a href="https://composables.com/docs/com.composables/core">在文档中找到完整的组件列表 -></a>（链接：<a href="https://composables.com/docs/com.composables/core%EF%BC%89%E3%80%82">https://composables.com/docs/com.composables/core%EF%BC%89%E3%80%82</a></p>

<h2>使用你的设计令牌自定义 Compose 主题</h2>

<p>Compose Unstyled 包含一个灵活的主题系统，可与任何设计系统令牌兼容。</p>

<p>以下是如何使用你选择的设计令牌创建完全自定义的主题：</p>

<p>以下是创建 Compose Theme 函数的示例：</p>

<pre><code class="kotlin">// define your theme properties
private val colors = ThemeProperty&lt;Color&gt;("colors")
private val typography = ThemeProperty&lt;TextStyle&gt;("typography")
private val shapes = ThemeProperty&lt;Shape&gt;("shapes")
private val elevation = ThemeProperty&lt;Dp&gt;("elevation")
// define your theme tokens.
// those are the potential values of your theme properties
private val background = ThemeToken&lt;Color&gt;("background")
private val card = ThemeToken&lt;Color&gt;("surface")
private val onCard = ThemeToken&lt;Color&gt;("onCard")
private val outline = ThemeToken&lt;Color&gt;("outline")
private val accent = ThemeToken&lt;Color&gt;("accent")
private val primary = ThemeToken&lt;Color&gt;("primary")
private val onPrimary = ThemeToken&lt;Color&gt;("onPrimary")
private val onSecondary = ThemeToken&lt;Color&gt;("onSecondary")
private val secondary = ThemeToken&lt;Color&gt;("secondary")
private val subtle = ThemeToken&lt;Dp&gt;("subtle")
private val titleMedium = ThemeToken&lt;TextStyle&gt;("titleMedium")
private val bodyMedium = ThemeToken&lt;TextStyle&gt;("bodyMedium")
private val cardShape = ThemeToken&lt;Shape&gt;("cardShape")
private val albumCoverShape = ThemeToken&lt;Shape&gt;("albumCoverShape")
private val buttonShape = ThemeToken&lt;Shape&gt;("buttonShape")
// create your Compose Theme and assign values to each token
private val LightTheme = buildTheme {
    name = "LightTheme"
    properties[colors] = mapOf(
        accent to Color(0xFF3B82F6),
        card to Color.White,
        onCard to Color(0xFF1E293B),
        outline to Color(0xFFE2E8F0),
        primary to Color(0xFF2563EB),
        onPrimary to Color.White,
        secondary to Color(0xFFE2E8F0),
        onSecondary to Color(0xFF64748B),
        background to Color(0xFFF8F9FA),
    )
    properties[typography] = mapOf(
        titleMedium to TextStyle(
            fontSize = 18.sp,
            fontWeight = FontWeight.SemiBold,
            fontFamily = loadInterFont(),
        ),
        bodyMedium to TextStyle(
            fontSize = 14.sp,
            fontWeight = FontWeight.Normal,
            fontFamily = loadInterFont(),
        )
    )
    properties[shapes] = mapOf(
        cardShape to RoundedCornerShape(16.dp),
        albumCoverShape to RoundedCornerShape(12.dp),
        buttonShape to CircleShape
    )
    properties[elevation] = mapOf(
        subtle to 8.dp
    )
}
</code></pre>

<p>然后，你可以使用新的主题函数包装你的应用：</p>

<pre><code class="kotlin">@Composable
fun MusicPlayerApp() {
    LightTheme {
        MusicPlayerCard()
    }
}
</code></pre>

<p>然后，它会使用 <code>Theme</code> 对象授予其子组件对主题的访问权限：</p>

<pre><code class="kotlin">@Composable
fun MusicPlayerCard(modifier: Modifier = Modifier) {
    val sliderState = rememberSliderState(initialValue = 0.3f)
    Box(
        modifier = modifier
            .outline(1.dp, Theme[colors][outline], Theme[shapes][cardShape])
            .shadow(Theme[elevation][subtle], Theme[shapes][cardShape])
            .background(Theme[colors][card], Theme[shapes][cardShape])
            .padding(24.dp)
    ) {
        ProvideContentColor(Theme[colors][onCard]) {
            Column(verticalArrangement = Arrangement.spacedBy(20.dp)) {
                Row(verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(16.dp)) {
                    Image(
                        painter = painterResource(Res.drawable.just_hoist_it_cover),
                        modifier = Modifier
                            .clip(Theme[shapes][albumCoverShape])
                            .background(Theme[colors][primary])
                            .size(80.dp),
                        contentDescription = "Album Cover",
                        contentScale = ContentScale.Crop
                    )
                    Column(modifier = Modifier.weight(1f)) {
                        Text("Just hoist it!", style = Theme[typography][titleMedium])
                        Spacer(Modifier.height(4.dp))
                        Text(
                            "The Deprecated",
                            style = Theme[typography][bodyMedium],
                            color = Theme[colors][onSecondary]
                        )
                    }
                }
                Slider(
                    state = sliderState,
                    modifier = Modifier.fillMaxWidth(),
                    track = {
                        Box(Modifier.fillMaxWidth().height(4.dp).clip(RoundedCornerShape(2.dp))) {
                            // the empty part of the track
                            Box(Modifier.fillMaxSize().background(Theme[colors][secondary]))
                            // the filled part of the track
                            Box(
                                Modifier.fillMaxWidth(sliderState.value).fillMaxSize().background(Theme[colors][accent])
                            )
                        }
                    },
                    thumb = {
                        Thumb(
                            color = Theme[colors][accent],
                            modifier = Modifier.size(16.dp),
                            shape = Theme[shapes][buttonShape]
                        )
                    }
                )
                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceEvenly, verticalAlignment = Alignment.CenterVertically) {
                    Button(onClick = { }, contentPadding = PaddingValues(12.dp), shape = Theme[shapes][buttonShape]) {
                        Icon(imageVector = Lucide.SkipBack, contentDescription = "Previous", modifier = Modifier.size(20.dp))
                    }
                    Button(onClick = { }, backgroundColor = Theme[colors][primary], contentColor = Theme[colors][onPrimary], contentPadding = PaddingValues(16.dp), shape = Theme[shapes][buttonShape]) {
                        Icon(imageVector = Lucide.Pause, contentDescription = "Pause", modifier = Modifier.size(24.dp))
                    }
                    Button(onClick = { }, contentPadding = PaddingValues(12.dp), shape = Theme[shapes][buttonShape]) {
                        Icon(imageVector = Lucide.SkipForward, contentDescription = "Next", modifier = Modifier.size(20.dp))
                    }
                }
            }
        }
    }
}
</code></pre>

<h2>轮廓修饰符</h2>

<p>最后但同样重要的是，Compose Unstyled 引入了一些 Compose Foundation 中缺少的样式 <code>Modifier</code>，但这些修饰符对于构建视觉丰富的界面必不可少：</p>

<h3>轮廓</h3>

<p>与 Compose Foundation 的 <code>border()</code> 修饰符不同，此修饰符不会影响布局。它还会在组件周围而不是内部进行绘制。当你需要一个与阴影完美融合的半透明轮廓时，这个功能非常方便：</p>

<p><img src="file:///Users/alexhilton/Downloads/compose-style-3.png" alt="" /></p>

<pre><code class="kotlin">SimpleButton(
  shape = RectangleShape,
  modifier = Modifier.outline(2.dp, Color(0xFF3B82F6), shape = RectangleShape)
)
SimpleButton(
  shape = RoundedCornerShape(8.dp),
  modifier = Modifier.outline(2.dp, Color(0xFF3B82F6), shape = RoundedCornerShape(8.dp))
)
SimpleButton(
  shape = CircleShape,
  modifier = Modifier.outline(2.dp, Color(0xFF3B82F6), shape = CircleShape)
)
</code></pre>

<h3>焦点环</h3>

<p>焦点环在处理键盘导航和焦点时非常重要。它们只有在获得焦点时才会渲染轮廓。</p>

<pre><code class="kotlin">val interactionSource = remember { MutableInteractionSource() }
SimpleButton(
    modifier = Modifier.focusRing(
        interactionSource = interactionSource,
        width = 2.dp,
        color = Color(0xFF3B82F6),
        shape = RoundedCornerShape(8.dp),
        offset = 2.dp
    ),
    interactionSource = interactionSource
)
</code></pre>

<h2>然后呢？</h2>

<p>即将推出的组件包括：</p>

<ul>
<li>侧边栏</li>
<li>工具提示</li>
<li>上下文菜单</li>
</ul>


<p>以及更多。</p>

<p>如果你愿意为该项目提供资金支持，我们还提供<a href="https://composables.com/ui-kit">正在制作中的 UI Kit</a>（链接：<a href="https://composables.com/ui-kit%EF%BC%89%E3%80%82%E8%AF%A5">https://composables.com/ui-kit%EF%BC%89%E3%80%82%E8%AF%A5</a> UI Kit 是一套完整的设计系统，适用于触控和指针应用。</p>

<p>为了使这些 API 完美无缺，我们投入了大量的工作和专业知识。通过资金支持该项目，你将在未来几年获得更多资源，而我则可以继续从事开源工作，同时支付房租。</p>

<p>想要随时了解最新动态？请务必<a href="https://github.com/composablehorizo%E2%80%8B%E2%80%8Bns/compose-unstyled/">在 Github 上关注 Unstyled</a>（链接:<a href="https://github.com/composablehorizo%E2%80%8B%E2%80%8Bns/compose-unstyled/%EF%BC%89%E3%80%82">https://github.com/composablehorizo%E2%80%8B%E2%80%8Bns/compose-unstyled/%EF%BC%89%E3%80%82</a></p>

<p>想要评论这篇文章吗？<a href="https://github.com/composablehorizo%E2%80%8B%E2%80%8Bns/compose-unstyled/discussions/106">在 GitHub 上讨论 →</a>（链接：<a href="https://github.com/composablehorizo%E2%80%8B%E2%80%8Bns/compose-unstyled/discussions/106%EF%BC%89">https://github.com/composablehorizo%E2%80%8B%E2%80%8Bns/compose-unstyled/discussions/106%EF%BC%89</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[运行时着色器实战：实现元球（Metaballs）动效]]></title>
    <link href="https://alexhilton.github.io/blog/2025/09/06/metaballs-with-runtimeshaders/"/>
    <updated>2025-09-06T23:19:16+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/09/06/metaballs-with-runtimeshaders</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Metaballs with Runtimeshaders」，原文链接<a href="https://medium.com/@off.mind.by/metaballs-with-runtimeshaders-bb7e5f6b27c2">https://medium.com/@off.mind.by/metaballs-with-runtimeshaders-bb7e5f6b27c2</a>，由Alex Volkov发布于2025810。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:2000/1*fQOua40zD_PlbsejLeHBeg.png" title="auto auto" ></a></p>

<!-- more -->


<p>大家好！今天我想向大家介绍一种最简单却又出人意料地令人印象深刻的效果：元球。</p>

<p>元球是一种看起来像有机体的形状，其特点是它们能够在近距离内融合在一起，形成单个连续的物体。</p>

<p>使用 GLSL 着色器创建这种效果非常简单，只需几行代码即可。当然，你也可以在网上找到关于如何将其移植到 AGSL 并在 Compose 中使用的教程。然而，主要的问题是这种效果需要两个（或更多）物体。我找到的所有教程都只是在单个着色器中模拟两个组件。这种方法在视觉上很有效，但在实际项目中使用时会带来很多限制。因此，我开始以一种每个元素只扭曲自身的方式来构建这种效果——尽可能地让一切看起来公平、干净。</p>

<p>好了，既然我们已经明白了为什么这不仅仅是一个metaball教程，而是一个全新的教程——那就开始吧！和往常一样，我把所有内容分解成几个部分：</p>

<ul>
<li>首先，我会快速解释一下这种效果在经典实现中的工作原理，然后我们会进行哪些不同的调整。</li>
<li>然后，我会介绍一下Compose的简单设置，让它运行起来。</li>
<li>最后，我们会更详细地介绍着色器本身。</li>
</ul>


<p>最终，我们应该得到如下所示的效果：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1192/1*2oZU3pJdUVUq1eR56tVTNw.gif" alt="这只是其中一个选项；这种效果是高度可定制的。" /></p>

<blockquote><p>开始之前，先简单说明一下——我不会为我制作的每个效果都制作教程，但你可以在我的 <a href="https://github.com/AleksiejVolkov/runtimeshaders">GitHub</a> （链接：<a href="https://github.com/AleksiejVolkov/runtimeshaders%EF%BC%89%E4%B8%8A%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%99%E7%A8%8B%E3%80%82%E4%BD%A0%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%88%91%E7%9A%84">https://github.com/AleksiejVolkov/runtimeshaders%EF%BC%89%E4%B8%8A%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%99%E7%A8%8B%E3%80%82%E4%BD%A0%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%88%91%E7%9A%84</a> <a href="https://t.me/droidshaderworks">Telegram 频道</a> 上找到视频、新效果公告以及问题的解答。期待在那里见到你！</p></blockquote>

<p>要创建元球效果，我们先来回顾一下基础知识。如何在着色器中绘制一个简单的圆圈？最简单的方法是定义一个中心和一个半径，然后使用 step 函数。如果像素比半径更靠近中心，则返回 1；如果像素比半径更远离中心，则返回 0。实际代码如下：</p>

<pre><code class="glsl">float ball( vec2 p, vec2 center, float radius ) {
    return step(length(p-center), radius);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Normalized pixel coordinates (from -0.5 to 0.5)
    vec2 uv = fragCoord/iResolution.xy - 0.5;
    uv.x *= iResolution.x / iResolution.y;

    float b1 = ball(uv, vec2(0.), 0.2);

    vec3 color = b1*vec3(1.);

    fragColor = vec4(color,1.0);
}
</code></pre>

<blockquote><p>这段代码是用 GLSL 编写的，而不是 AGSL，你可以直接复制粘贴到 shadertoy.com 中。在本节中，所有代码都将采用相同的方法，让你无需运行 Android Studio 即可更轻松地测试和查看结果。</p></blockquote>

<p><em>结果是一个最简单的圆圈。如果你对着色器稍有了解，这部分应该很容易理解。</em></p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*PTHu_h9ayCxqi-EgVN2nVQ.png" alt="最简单的圆圈" /></p>

<p>现在，让我们添加第二个圆圈，并将它们水平放置，使它们略微分开，而不是同时位于中心。这次，我们不再使用步长函数来定义边缘，而是使用反距离。我们仍然会得到两个圆圈，但边缘不再是锐利的，而是平滑的渐变，使圆圈看起来更像发光的点。</p>

<pre><code class="glsl">float ball(vec2 p, vec2 center, float radius) {
    float dist = length(p - center);
    return radius / dist;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
   // Normalized pixel coordinates (from -0.5 to 0.5)
    vec2 uv = fragCoord/iResolution.xy - 0.5;
    uv.x *= iResolution.x / iResolution.y;

    float b1 = ball(uv, vec2(-0.4,0.), 0.1);
    float b2 = ball(uv, vec2(0.4,0.), 0.1);

    float circles = b1 + b2;

    vec3 color = circles*vec3(1.);

    fragColor = vec4(color,1.0);
}
</code></pre>

<p>最终效果如下：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*rXfBtvZOlpnK98XEy7HyUA.png" alt="" /></p>

<p>如你所见，在最终图像中，我们将两个圆的值相加。即使现在，如果你将它们移近，你也会看到它们开始合并。基本上，效果已经存在——剩下的就是对最终值应用一些函数，或者再次使用 step 函数截断低于特定阈值的所有内容，保留其内部内容。就这样——元球效果完成了！</p>

<pre><code class="glsl">float ball(vec2 p, vec2 center, float radius) {
    float dist = length(p - center);
    return radius / dist;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Normalized pixel coordinates (from -0.5 to 0.5)   
    vec2 uv = fragCoord/iResolution.xy - 0.5;
    uv.x *= iResolution.x / iResolution.y;

    // make circles moving slightly along horizontal direction
    float horiz = (0.5*sin(iTime)+0.5)*0.2;
    float b1 = ball(uv, vec2(-0.3+horiz,0.), 0.1);
    float b2 = ball(uv, vec2(0.3-horiz,0.), 0.1);

    float circles = b1 + b2;

    float threshold = 1.0;
    float alpha = step(threshold, circles);

    vec3 color = alpha*vec3(1.);

    fragColor = vec4(color,1.0);
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*rIVQla9lc5qbYGaCMVmI4g.gif" alt="最简单的元球效果" /></p>

<p>当然，除了阶跃函数，你还可以使用 SmoothStep，添加距离的平方反比，或者尝试不同的公式，调整系数等等。所有这些都是可能的，并且都会改变最终的外观，但核心思想保持不变：我们用平滑衰减公式定义圆，将结果相加，并在某个阈值处进行截断。这样，当形状接近时，它们的场之和会超过阈值，从而合并成一个形状——而当它们相距较远时，则不会合并。</p>

<p>现在我们已经了解了如何创建元球效果，看起来我们只需打开 Android Studio 就可以开始构建了！然而，我们很快就会遇到两个问题：</p>

<ul>
<li>目前，所有按钮都像圆形一样工作——这是意料之中的。但如果我们希望合并按钮具有其他形状，则需要使用例如 SDF 方法。即便如此，形状仍然在着色器内部定义，这意味着我们不能简单地在 Compose 视图中应用 RoundedCornerShape 并期望它能够正常工作。</li>
<li>两个按钮必须在同一个着色器中定义。如果有三个按钮，则三个按钮都必须位于同一个着色器中。最重要的是——我们如何处理这些按钮的点击？</li>
</ul>


<p>如果你查找有关此效果的文章，你会发现这两个问题通常被忽略。然而，对我来说，它们至关重要——这正是我决定撰写本教程的原因。我建议采用一种不同的方法来解决这两个问题。</p>

<p>首先，我们不会在着色器内部定义形状。相反，我们将变形坐标系本身，从而解决不同形状的问题。</p>

<p>其次，效果中的每个元素都会获得自己的着色器实例，但我们也会将相邻元素的坐标传递给它。这解决了点击处理问题，因为现在每个元素都是一个独立的可组合元素，拥有自己的属性和 lambda 表达式。下图所示：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*7yVd3iok98-pQNLWIhP1mQ.png" alt="绿色表示可组合元素。粉色表示着色器" /></p>

<p>因此，我们的任务可以分为两个主要的子任务。一旦解决了这两个子任务，我们就能得到最终的效果。首先，我们需要学习如何变形画布以获得与元球相同的视觉效果。然后，我们将收集容器中每个子元素的位置数据，并将其传递给其他着色器。让我们先从第一部分开始。</p>

<p>让我们从使用着色器所需的最简单的设置开始。下面是可组合部分——你可以直接复制粘贴到你的项目中，它应该可以立即运行。</p>

<pre><code class="kotlin">@Composable
fun MetaballShaderScreen(paddingValues: PaddingValues) {
    val shader = remember { RuntimeShader(metaballShader) }

    Box(modifier = Modifier
            .padding(paddingValues)
            .fillMaxSize()
            .background(Color(0xFF171717)),
        contentAlignment = Alignment.Center
    ) {
        ShadedButton(shader)
    }
}

@Composable
fun ShadedButton(

shader: RuntimeShader,) {
    var boxSize by remember { mutableStateOf(IntSize.Zero) }
    Box(
        contentAlignment = Alignment.Center,
        modifier = Modifier.size(50.dp)
    ) {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .onSizeChanged { boxSize = it }
                .graphicsLayer {
                    shader.setFloatUniform(
                        "resolution",
                        boxSize.width.toFloat(),
                        boxSize.width.toFloat())
                    this.renderEffect = RenderEffect
                        .createRuntimeShaderEffect(shader, "image")
                        .asComposeRenderEffect()
                }
        ) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .clip(RoundedCornerShape(10.dp))
                    .background(color = Color(0xFFF6F6F6))
            )
        }
        Icon(
            imageVector = Icons.Default.MoreVert,
            contentDescription = "Expand Menu",
            tint = Color.Black
        )
    }
}
</code></pre>

<p>以下是着色器代码：</p>

<pre><code class="kotlin">@Language("AGSL")
private val metaballShader = """
    uniform vec2 resolution;
    uniform shader image;

    vec2 NormalizeCoordinates(vec2 o, vec2 r) {

        float2 uv = o / r - 0.5;

        if (r.x &gt;= r.y) {
            uv.x *= r.x / r.y;
        } else {
            uv.y *= r.y / r.x;
        }

        return uv;
    }

    vec4 GetImageTexture(vec2 p, vec2 pivot, vec2 r) {

        if (r.x &gt; r.y) {
            p.x /= r.x / r.y;
        } else {
            p.y /= r.y / r.x;
        }

        p += pivot;    
        p *= r;

        return image.eval(p);
    }

    vec4 main(float2 fragCoord) {
        float2 uv = NormalizeCoordinates(fragCoord, resolution);
        vec4 final = GetImageTexture(uv, vec2(0.5), resolution);
        return vec4(final);
    }""".trimIndent()
</code></pre>

<blockquote><p>在着色器中，我已经包含了两个必要的方法：一个用于规范化，一个用于从输入纹理中获取颜色。我在之前的课程中介绍过这些方法，因此你可以简单地将它们视为必需的样板代码——它们不会影响效果的核心逻辑——或者查看我之前的教程，我在那里详细解释了它们。本课程已经相当丰富，甚至可能信息量过大，所以我在这里就不赘述了。</p></blockquote>

<p>太好了！如果一切设置正确，我们将得到一个尚未添加任何内容的着色器——它只是绘制所有内容，就像着色器根本不存在一样。结果应该只是一个普通的按钮，没什么特别的：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*V_yEnqGelKeDKYaPwUklTg.png" alt="没什么特别的，只是一个按钮 :)" /></p>

<p>在最终的代码中，变形将基于其他元素，但由于我们目前还没有这些元素，我只需添加一个虚拟点并将其绘制在画布上即可。这只是测试代码，我们稍后会将其移除。我还会将时间传递给着色器，并使该点水平移动。这将是我们的虚拟点，我们将使用它作为画布变形的参考：</p>

<pre><code class="kotlin">//...
 var time by remember { mutableStateOf(0f) }
//...
  .graphicsLayer {
       //...
        shader.setFloatUniform("time", time)
//...
</code></pre>

<p>在着色器代码中，我们必须添加时间统一函数：</p>

<pre><code class="glsl">    uniform float time;
</code></pre>

<p>并添加虚拟圆：</p>

<pre><code class="glsl"> float getCircle(vec2 p, vec2 pivot) {
        return step(length(pivot - p), 0.1);
 }
</code></pre>

<p>同时将虚拟圆添加到最终输出中：</p>

<pre><code class="glsl"> vec4 main(float2 fragCoord) {
        //...

        float circleHorizontalPosition = sin(0.5*time)*2.;
        float helperCicrle = getCircle(uv, vec2(circleHorizontalPosition, 0.));

        final = mix(final, helperCicrle*vec4(1.,0.,0.,1.), helperCicrle);
        return vec4(final);
}
</code></pre>

<p>这样，我们应该看到一个红色的参考点，我们将以此为基础来扭曲按钮。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*rikNEHT918EmDeWLzQsWbA.gif" alt="" /></p>

<p>现在，让我们尝试计算控制点对按钮的影响，使用与计算元球完全相同的方法：</p>

<pre><code class="glsl"> float getInfluence(vec2 uv, vec2 controlPoint) {
        float dist = length(controlPoint-uv);
        return 1./dist;
 }

 vec4 main(float2 fragCoord) {
        float2 uv = NormalizeCoordinates(fragCoord, resolution);

        float circleHorizontalPosition = sin(0.2*time)*2.;
        vec2 controlPointPos = vec2(circleHorizontalPosition, 0.);
        float helperCicrle = getCircle(uv, controlPointPos);

        float influence = getInfluence(uv, controlPointPos);

        uv *= 1.-influence; // why here is 1 - influence was explained in Deform the Canvas tutorial
        vec4 final = GetImageTexture(uv, vec2(0.5), resolution);

        final = mix(final,helperCicrle*vec4(1.,0.,0.,1.),helperCicrle);
        return vec4(final);
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*ivjxpAXa4_O6hDtt.gif" alt="够搞笑的，但这不是我们想要的" /></p>

<p>结果很搞笑，但不是我们的预期。内部的瑕疵（“洞”效果）可以通过将影响值限制在 0 到 1 之间轻松修复。然而，这仍然不是我们想要的结果——我们得到的是控制点周围的区域膨胀了，而我们需要的效果几乎是相反的。那么，我们该如何实现呢？</p>

<p>答案很简单，也有点意思——虽然我花了一些时间才明白。这个想法是将坐标中心到控制点的距离与两个距离之和进行比较：从中心到当前点 (uv) 的距离，以及从当前点到控制点的距离。下图是按钮内部一个随机点的示意图。这个距离总是大于直接到中心的距离，而这个技巧就是让我们实现元球效果的关键！</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*n7kIFbwMCFNmhinMLfBP6g.png" alt="如果我们将绿色到红色的距离加上到中心的距离，那么绿色到红色的距离总是大于中心到红色的距离。" /></p>

<p>所以，为了将我们现在的效果变成几乎完整的效果（除了强度设置和其他一些小的调整），我们实际上只需要将中心添加到距离计算中——就这样！</p>

<pre><code class="glsl">  float getInfluence(vec2 uv, vec2 controlPoint) {
        // float dist = length(controlPoint-uv); - was like that
        float dist = length(controlPoint-uv) + length(uv); //added length(uv);
        return 1./dist;
  }
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*ArDCdZxeCKBBmsfQ.gif" alt="我们已经得到了想要的结果" /></p>

<blockquote><p><em>现在可以添加“mass”或除以距离的平方来加快淡出速度。但这些都是完善的细节，并非核心效果逻辑的一部分。我强烈建议你自己尝试一下 getInfluence 方法。</em></p></blockquote>

<p>最后一步是传递另一个组件的坐标，而不是使用着色器内的控制点。听起来很简单，但这里有一些需要讨论的地方。对我来说，最难的部分是获取与着色器本身位于同一“系统”中的坐标。虽然控制点位于着色器内部，但我们使用 uv 创建了它，而 uv 已经根据视图的大小进行了归一化。但是，现在我们要获取相对于父容器的位置。那么，我们如何将所有这些结合起来呢？</p>

<p>首先，让我们在容器中添加第二个按钮，并将所有必要的参数传递给着色器。之后，我们将深入着色器逻辑的核心——在我看来，这是最有趣的部分。</p>

<pre><code class="kotlin">@Composable
fun TestShaderScreen(paddingValues: PaddingValues) {
    val shader = remember { RuntimeShader(metaballShader) }
    val parentBoxSize = remember { mutableStateOf(IntSize.Zero) }
    val firstButtonPosition = remember { mutableStateOf(Offset.Zero) }
    val secondButtonPosition = remember { mutableStateOf(Offset.Zero) }

    Box(
        modifier = Modifier
            .padding(paddingValues)
            .fillMaxSize()
            .background(Color(0xFF171717))
            .onSizeChanged {
                parentBoxSize.value = it
            },
        contentAlignment = Alignment.Center
    ) {
        ShadedButton(
            modifier = Modifier
                .padding(start = 70.dp)
                .size(50.dp)
                .onGloballyPositioned {
                    firstButtonPosition.value = it.positionInParent() +
                            Offset(
                                x = it.size.width * 0.5f,
                                y = it.size.height * 0.5f
                            )
                },
            icon = Icons.Filled.Favorite,
            shader = shader,
            parentBoxSize = parentBoxSize.value,
            otherViewPosition = secondButtonPosition.value,
            myPosition = firstButtonPosition.value,
        )
        ShadedButton(
            modifier = Modifier
                .padding(end = 70.dp)
                .size(50.dp)
                .onGloballyPositioned {
                    secondButtonPosition.value = it.positionInParent() +
                            Offset(
                                x = it.size.width * 0.5f,
                                y = it.size.height * 0.5f
                            )
                },
            icon = Icons.Filled.Star,
            shader = shader,
            parentBoxSize = parentBoxSize.value,
            otherViewPosition = firstButtonPosition.value,
            myPosition = secondButtonPosition.value,
        )
    }
}

@Composable
fun ShadedButton(

modifier: Modifier = Modifier,

icon: ImageVector,

shader: RuntimeShader,

parentBoxSize: IntSize,

myPosition: Offset,

otherViewPosition: Offset,) {
    var boxSize by remember { mutableStateOf(IntSize.Zero) }
    Box(
        contentAlignment = Alignment.Center,
        modifier = modifier
    ) {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .onSizeChanged {
                    boxSize = it
                }
                .graphicsLayer {
                    shader.setFloatUniform(
                        "resolution",
                        boxSize.width.toFloat(),
                        boxSize.width.toFloat()
                    )
                    shader.setFloatUniform(
                        "parentBoxSize",
                        parentBoxSize.width.toFloat(),
                        parentBoxSize.height.toFloat()
                    )
                    shader.setFloatUniform(
                        "otherViewPosition",
                        otherViewPosition.x,
                        otherViewPosition.y
                    )
                    shader.setFloatUniform(
                        "positionInParent",
                        myPosition.x,
                        myPosition.y
                    )
                    this.renderEffect = RenderEffect
                        .createRuntimeShaderEffect(shader, "image")
                        .asComposeRenderEffect()
                }
        ) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .clip(RoundedCornerShape(10.dp))
                    .background(color = Color(0xFFF6F6F6))
            )
        }
        Icon(
            imageVector = icon,
            contentDescription = "Expand Menu",
            tint = Color.Black
        )
    }
}
</code></pre>

<p>基本上，我们添加的只是传递父容器的大小和相邻视图的中心坐标。请记住，由于 Compose 回调返回的位置是左上角，因此我们需要在传递之前对其进行一些调整。另外，请记住，第一个组件应该在 otherViewPosition 参数中接收第二个组件，第二个组件也应该接收第一个组件。最重要的是不要混淆它们 :)</p>

<p>让我们继续讨论着色器。我们将从添加必要的 uniform 开始。</p>

<pre><code class="glsl"> uniform float2 otherViewPosition;
 uniform float2 parentBoxSize;
 uniform float2 positionInParent;
</code></pre>

<p>现在到了有趣的部分：之前的控制点现在需要根据两个参数来计算——父级的大小以及第二个视图相对于父级的坐标。</p>

<p>首先，我们来获取容器大小与按钮大小的比率。</p>

<pre><code class="glsl">  float parentRatio = parentBoxSize.x / resolution.x;
</code></pre>

<p>现在我们只需要稍微修改一下 getInfluence 方法，就能将所有内容整合到一个坐标系中：</p>

<pre><code class="glsl">float getInfluence(vec2 uv, float ratio) {
        float2 posInParentNormalized = (positionInParent/parentBoxSize) - 0.5;
        float2 controlPoint = otherViewPosition / parentBoxSize - 0.5;
        controlPoint.x = (controlPoint.x-posInParentNormalized.x) * ratio;

        float dist = max(1., length(controlPoint-uv) + length(uv));
        float influence = smoothstep(0.,1., 1./pow(dist,2.));
        return influence;
    }
</code></pre>

<p>听起来很简单，但实际上，过程中出现了一些不太明显的计算。而且这些计算并非一眼就能轻易掌握。所以我尽量把它解释得清晰易懂。所以，从整体上看，我们得到的是这样的：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*ttaLU6zCxuP0vuHWmtkgGA.png" alt="左边是我们的“活动”视图。想象一下，我们始终处于视图着色器的“内部”。" /></p>

<p>好的，我们有父容器、它的大小、我们视图相对于父容器的位置，以及相邻视图（我们之前示例中的控制点）的位置。我们的任务是将这个控制点放到我们的UV坐标系中。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*S6fLIECuZWm-UYymAuwPbg.png" alt="从上到下的整个过程" /></p>

<p>我尝试自上而下地解释了整个过程。现在让我们再看一下代码，并逐步讲解一下。</p>

<pre><code class="glsl">  float2 posInParentNormalized = (positionInParent/parentBoxSize) - 0.5;
  float2 controlPoint = otherViewPosition / parentBoxSize - 0.5;
  float parentRatio = parentBoxSize.x / resolution.x;
  controlPoint.x = (controlPoint.x-posInParentNormalized.x) * parentRatio;
</code></pre>

<p>假设父容器的宽度为 500。我们在其中的位置为 100，相邻视图的位置为 400。首先，我们获取两个视图相对于父容器的标准化坐标（偏移 -0.5）。在本例中，我们的位置为 -0.3，相邻视图的位置为 0.2。因此，它们之间的距离为 0.5——即父容器宽度的一半。但请记住，我们位于附加到自身视图的着色器内部，因此必须将这个值乘以父容器大小与我们视图大小的比值。这是关键的一步：我们现在得到的不是 0.5，而是另一个值，但它位于我们视图的坐标系中。由此，我们可以计算距离，并执行之前对虚拟控制点执行的所有操作！</p>

<blockquote><p>_这里我将所有内容简化为水平坐标，但同样的逻辑也适用于垂直坐标。我只是不想让本来就很复杂的解释更加难以理解。</p></blockquote>

<p>最终，我们得到了：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*OWQ-vSnQ3yAiPloRXBRXQw.png" alt="静态看起来有点奇怪，但很明显两个视图是相互影响的。" /></p>

<p>最后一步是用数组替换这两个视图，这样我们就可以添加第三个、第四个甚至第五个按钮。</p>

<p>在着色器中，不能使用动态数组，所以我们需要设置一个上限——我选择了 10 个元素。我们还需要一个单独的计数器来记录实际有多少个元素。由于数组不能留空，在 Compose 中，我们会自动用零位置填充未使用的槽位，但计数器会确保这不会影响最终结果。</p>

<p>因此，在着色器中，uniform 变量看起来如下：</p>

<pre><code class="glsl"> uniform int count;
 uniform float2 positions[10];
 uniform float2 parentResolution;
 uniform float2 positionInParent;
</code></pre>

<p>如果多个相邻元素同时影响视图，getInfluence 方法将循环遍历所有元素并累积影响。</p>

<pre><code class="glsl">float getInfluence(float2 uv, float ratio) {
    float influence = 0.0;
    for (int i = 0; i &lt; 10; i++) {
        float posInParentNormalized = (positionInParent/parentBoxSize) - 0.5;
        float2 controlPoint = positions[i] / parentBoxSize - 0.5;
        controlPoint.x = (controlPoint.x-posInParentNormalized) * r;
        float dist = max(1.,length(controlPoint-uv) + length(uv));
        float rawScale = 1./pow(dist,2.);
        influence += smoothstep(0., 1., rawScale);

        if(i==count-1) break;
    }
    return clamp(influence,0.,1.);
}
</code></pre>

<p>在 Compose 中，我们需要添加一个列表并仔细传递所有值。你也可以添加动画和其他效果，但这会使 Compose 代码过载，在本课中更难理解。本教程已经相当丰富，所以我只演示如何将值传递到数组中——其余的实验留给你自己 :) 记住，你可以随时查看我的代码库以获取完整版本。</p>

<p>下面是我编写的一个扩展方法，用于方便地向着色器添加列表。</p>

<pre><code class="kotlin">fun RuntimeShader.setVec2ArrayUniform(

name: String,

values: List&lt;Pair&lt;Float, Float&gt;&gt;,

maxSize: Int = 10) {
    require(values.size &lt;= maxSize) {
        "Too many elements for uniform '$name'. Maximum allowed is $maxSize, but got ${values.size}"
    }

    val padded = values + List(maxSize - values.size) { 0f to 0f }
    val floatArray = padded.flatMap { listOf(it.first, it.second) }.toFloatArray()

    this.setFloatUniform(name, floatArray)
}
</code></pre>

<p>用法：</p>

<pre><code class="kotlin">  shader.setVec2ArrayUniform(name, values)
</code></pre>

<p>现在你可以添加不同的元素，并观察它们在动画过程中平滑地合并或分离：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*s01C-TPOXIfOwZDg.gif" alt="以下是三个不同形状的视图" /></p>

<p>感谢你的阅读！如果你觉得我的实验有趣且我的解释对你有帮助，欢迎加入我的<a href="https://t.me/droidshaderworks">Telegram频道</a>或在<a href="https://x.com/KrowaNaMostku">Twitter (X)</a>上关注我。这个项目只是我的一个爱好，说实话，我的动力很大程度上取决于收到的反馈——所以我非常高兴在频道里见到你。如果你愿意，请在你的社交媒体上分享这篇文章，我将不胜感激。祝你撸码愉快！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转Shader之学会如何变形画布]]></title>
    <link href="https://alexhilton.github.io/blog/2025/09/05/deform-the-canvas/"/>
    <updated>2025-09-05T22:24:46+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/09/05/deform-the-canvas</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Deform the canvas」，原文链接<a href="https://medium.com/@off.mind.by/deform-the-canvas-57dc59bec42a">https://medium.com/@off.mind.by/deform-the-canvas-57dc59bec42a</a>，由Alex Volkov发布于2025年8月2日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:2000/1*DTU5ja0MLebUmXQMg9qi9w.png" title="auto auto" ></a></p>

<!-- more -->


<p>大家好！使用着色器时，我总是着迷于如何轻松创建看起来精致而昂贵的效果。今天的文章就是另一个很好的例子。最近，我的 Telegram 频道的一位订阅者问我，如何在用手指拖动视图时创建拉伸效果。自然而然地，我立刻想到了用着色器来实现。现在结果已经出来了，我很高兴分享我的构建过程。和往常一样，这篇文章分为几个部分：第一部分展示了 Compose 的简单设置，第二部分逐步讲解着色器，最后，我们将在 Compose 中添加一些小细节，这些细节实际上构成了 90% 的视觉效果——尽管这可能感觉有点不公平。</p>

<p>最终效果如下：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1196/1*M42RvZvThTrI7UMjelqb5w.gif" alt="最终结果" /></p>

<blockquote><p>在深入探讨之前，我想提醒你，我并没有为所有效果创建教程。不过，所有效果都可以在我的 <a href="https://github.com/AleksiejVolkov/runtimeshaders">GitHub</a> (链接：<a href="https://github.com/AleksiejVolkov/runtimeshaders">https://github.com/AleksiejVolkov/runtimeshaders</a>)上找到。你还可以在我的 <a href="https://t.me/droidshaderworks">Telegram 频道</a> 中找到视频、新效果的公告以及问题的解答。期待在那里见到你！</p></blockquote>

<p>让我们从最基本的 Compose 设置开始。在本教程中，我不会包含任何背景图片或额外的样式。我们会尽可能地保持简洁。我们只需要一个应用着色器的容器、一些着色器本身的参数，以及一个放置在着色器盒内的菜单或列表的基本模拟。以下是我们开始所需的基本设置：</p>

<pre><code class="kotlin">val shader = remember { RuntimeShader(runtimeShader) }
var targetPercentage by remember { mutableFloatStateOf(0f) }
val percentage = animateFloatAsState(
    targetValue = targetPercentage, 
    animationSpec = tween(
          durationMillis = 1000, 
          easing = ElasticOutEasing)
    )
val pressed = remember { mutableStateOf(false) }
var fingerPosition by remember { mutableStateOf(Offset.Zero) }
var fingerStartPosition by remember { mutableStateOf(Offset.Zero) }Box(
  modifier = Modifier
            .onSizeChanged { size -&gt;
                shader.setFloatUniform(
                    "resolution", size.width.toFloat(), size.height.toFloat()
                )
            }
            .pointerInput(Unit) {
                awaitPointerEventScope {
                    while (true) {
                        val event = awaitPointerEvent()
                        val change = event.changes.firstOrNull() ?: continue
                        pressed.value = change.pressed

                        if (change.pressed) {
                            if (change.previousPressed.not()) {
                               fingerStartPosition = change.position
                            }
                            targetPercentage = 1f
                            fingerPosition = change.position - fingerStartPosition
                        } else {
                            targetPercentage = 0f
                        }

                        event.changes.forEach { it.consume() }
                    }
                }
            }
            .graphicsLayer {
                if (pressed.value) {
                    shader.setFloatUniform("percentage", 1f)
                } else {
                    shader.setFloatUniform("percentage", percentage.value)
                }
                shader.setFloatUniform("touch", fingerPosition.x, fingerPosition.y)

                this.renderEffect = RenderEffect
                    .createRuntimeShaderEffect(shader, "image")
                    .asComposeRenderEffect()
            }
            .clickable {
                targetPercentage = if (targetPercentage == 0f) 1f else 0f
            }
    ) {
      //... 这里是下拉列表本身或任何其他可以通过拖动拉伸的可组合项
    }    
</code></pre>

<p><strong>shader -</strong> 这是着色器本身，我们将在第二部分中编写它。</p>

<p><strong>targetPercentage</strong>、<strong>percentage</strong> 和 <strong>pressed -</strong> 这些控制传递给着色器的效果强度。我们需要它们来为用户抬起手指后的“反弹”效果添加动画效果。思路很简单：当有活动触摸时，强度为 1（最大值），当用户抬起手指时，我们将其动画化为 0。我们将使用自定义的 <strong><em>ElasticOutEasing</em></strong> 来代替常规的线性动画，我将在最后一节中对其进行描述。</p>

<p><strong>fingerPosition</strong> 和 <strong>fingerStartPosition -</strong> 我们只将增量向量传递给着色器，这意味着我们关心方向和强度（向量长度）。拉伸始终从中心开始（我发现这比从精确的触摸点开始更美观）。因此，我们存储两个值，并将它们的差值传递给着色器。</p>

<p>接下来，在 <strong>onSizeChanged</strong> 中，我们将视图大小传递给着色器。在 pointerInput 中，我们跟踪拖动并计算增量向量。最后，在 <strong>graphicsLayer</strong> 中，我们将增量和效果强度传递给着色器。</p>

<p>接下来是包含将要拉伸的视图示例的代码块。它实际上只是一段基本的占位符代码，所以我认为不值得详细分析。我将其包含在这里只是为了方便——这样你就可以复制它，而不必担心自己编写它：</p>

<pre><code class="kotlin">val actions = listOf("Cut", "Copy", "Paste", "Edit")
Column(
    modifier = Modifier
        .width(250.dp)
        .background(Color(0x8843484C), RoundedCornerShape(8.dp))
        .border(1.dp, Color.Gray, RoundedCornerShape(8.dp))
        .padding(8.dp)
) {
    actions.forEach { action -&gt;
        Text(
            text = action,
            color = Color.White.copy(alpha = 0.8f),
            modifier = Modifier
                .fillMaxWidth()
                .padding(vertical = 8.dp, horizontal = 16.dp)
        )
        if(action != "Edit") {
            HorizontalDivider()
        }
    }
}
</code></pre>

<p>Compose 的设置就到这里！让我们开始编写着色器吧！</p>

<p>我们从最简单的着色器开始。下面是输出输入的极简代码，无需进行任何重大更改。我唯一添加的是一个辅助方法，方便以后修改。它叫做 <strong>GetImageTexture</strong>。从技术上讲，你可以使用 <strong>image.eval(fragCoord)</strong> 返回所有未更改的图像，但是一旦在重新映射图像之前开始修改坐标，就需要处理宽高比和图像平移——这基本上就是使用以画布中心为中心的坐标系。这个方法可以处理这些问题。你只需向它传递标准化的 UV 坐标、自定义中心点和分辨率，它就会返回正确的结果。如果你现在使用这些设置运行着色器，你应该会看到与不使用着色器时完全相同的图像。这是一个好兆头！</p>

<pre><code class="kotlin">private val runtimeShader = """
    uniform shader image;
    uniform float2 resolution;
    uniform float percentage;
    uniform float2 touch;

    vec4 GetImageTexture(vec2 p, vec2 pivot, vec2 r) {

    p.x /= r.x / r.y;

    p += pivot;

    p *= r;

    return image.eval(p);

    }

    half4 main(float2 fragCoord) {

    float ratio = resolution.x / resolution.y;

    float2 uv = fragCoord / resolution - 0.5;

    uv.x *= ratio;

    vec4 img = GetImageTexture(uv, vec2(0.5), resolution);

    return half4(img.rgb, img.a);

    }""".trimIndent()
</code></pre>

<p>你在这里看到的应该非常熟悉——几乎所有我的着色器都是这样启动的，说实话，大多数其他着色器也是如此。我再重复一遍：我们获取 fragCoord，它是每个像素相对于视图画布的位置。在此基础上，我们创建一个标准化的 UV 坐标系，根据宽高比进行调整，并偏移 0.5——这将原点置于视图的正中央。并非每个人都这样做，但我觉得这样更方便。它可以“免费”地实现很多效果，比如镜像行为，因为我们只围绕中心计算一次所有内容，而不是分别处理每条边。下面是我们画布的示意图。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*1aPwjWpXJgxlQ8-mCJ2JBA.png" alt="方形画布的简单 UV 图示" /></p>

<p>好了，现在该了解一下我们想要实现的效果了。我们需要从中心（在当前实现中）沿着特定向量拉伸画布，同时保持其余部分不变。那么，如何拉伸画布呢？其实，最简单的方法就是乘以一个数字！让我们测试一下——添加一个比例变量并尝试一下。最后，我们将 UV 乘以这个比例向量。</p>

<pre><code class="glsl">vec2 scale = vec2(0.8, 1.2);
uv *= vec2(scale.x, scale.y);vec4 img = GetImageTexture(uv, vec2(0.5), resolution);
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*_C7fYI8VQn5WKMOFUSnbdA.png" alt="左边是原始图像，右边是我们应用了缩放效果的图像。" /></p>

<p>尝试使用不同的<strong>scale</strong>值来更好地感受效果。正如你所注意到的——使用1不会改变任何值，因为乘以1后值保持不变。小于1的值会拉伸图像，而大于1的值会压缩图像。记住这一点——我们稍后会计算缩放强度并将其从1中减去，这样当缩放为零时，效果也为零，这意味着我们乘以了一个单位向量。</p>

<p>太好了，现在让我们将触摸位置添加到计算中。简单回顾一下——我们从触摸中接收了一个位移向量。因此，当手指触摸屏幕时，向量为 (0, 0)。如果我们将手指向右移动 20 像素，则得到 (20, 0)。我们首先需要对这个向量进行归一化，并将其乘以宽高比。</p>

<pre><code class="glsl">vec2 nMouse = touch / resolution;
nMouse.x *= ratio;
</code></pre>

<p>如果我们将手指向左移动 20 像素，则会得到一个 (-20, 0) 的向量。因此，我们不会直接使用这个向量作为比例，而是取其长度。它看起来会像这样：</p>

<pre><code class="glsl">vec2 scale = vec2(length(nMouse.x), length(nMouse.y));
</code></pre>

<p>记住，没有效果意味着乘以 1，而不是乘以 0？这就是为什么在使用比例向量时，我们在应用之前先将其从 1 中减去：</p>

<pre><code class="glsl">uv *= vec2(1.0) - scale;
</code></pre>

<p>如果一切设置正确，我们现在应该能够控制沿两个轴的拉伸。大致如下所示：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:800/1*ix2Fe4IcYGkQ_iHmSHJ3jA.gif" alt="" /></p>

<p>一切看起来都很好——现在我们只需要在一个方向上应用拉伸。为此，我们可以使用向量的点积。原理很简单：如果向量指向同一方向，则此运算返回正值；如果向量指向相反方向，则返回负值。我强烈建议你在专用资源上阅读更多关于此运算（以及其他向量运算）的内容，因为线性代数是着色器中一切的基础。在这里，我将向你展示它在实践中的工作原理！</p>

<pre><code class="glsl">float influence = dot(normalize(nMouse), uv);
scale *= influence;
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*aKRAalWcQzf2Jugs18aEoQ.png" alt="应用点积后" /></p>

<p>如你所见，效果已经近乎完美！但我不太喜欢另一侧在另一个方向上变形（即被压缩）。这是点积的副作用——当它返回负值时，缩放比例也会变为负值，画布的这一部分会被挤压。我希望保持视图的这一部分不变，所以我添加了一个从零到定义最大值的线性插值。</p>

<pre><code class="glsl">influence = smoothstep(0., 1.5, influence);
</code></pre>

<p>最后一步是乘以“效果强度”，我们通过百分比参数传递该强度（也许这不是最好的命名，但我习惯这样称呼它）。这不会改变拖动过程中的行为，但它可以让我们在拖动结束后平滑地将视图恢复到原始状态。</p>

<pre><code class="glsl">scale *= percentage;
</code></pre>

<p>就是这样！着色器已准备就绪。以下是完整代码——尽管最终的视觉效果看起来丰富而复杂，但它简洁明了。在最终版本中，我还限制了 x 轴和 y 轴上的最大缩放值。你可以根据需要随意调整这些值。</p>

<pre><code class="glsl">uniform shader image;
uniform float2 resolution;
uniform float percentage;
uniform float2 touch;

vec4 GetImageTexture(vec2 p, vec2 pivot, vec2 r) {
    p.x /= r.x / r.y;
    p += pivot;
    p *= r;
    return image.eval(p);
} half4 main(float2 fragCoord) {
    float ratio = resolution.x / resolution.y;
    float2 uv = fragCoord / resolution - 0.5;
    uv.x *= ratio;
    vec2 nMouse = touch / resolution;
    nMouse.x *= ratio;

    vec2 scale = vec2(min(length(nMouse.x), 0.3), min(length(nMouse.y), 0.4));
    float influence = dot(normalize(nMouse), uv);

    influence = smoothstep(0., 1.5, influence);
    scale *= influence;
    scale *= percentage;

    uv *= vec2(1.0) - scale;

    vec4 img = GetImageTexture(uv, vec2(0.5), resolution);

    return half4(img);
}
</code></pre>

<p>现在来看看我从 Compose 中留下的部分——ElasticOutEasing。在 Compose 中创建动画时，你可以使用内置的缓动函数，也可以定义自己的缓动函数。我使用了一个简单的弹性缓动函数示例，如下所示：</p>

<pre><code class="kotlin">val ElasticOutEasing = Easing { t -&gt;
    val p = 0.3f
    if (t == 0f || t == 1f) t
    else {
        val s = p / 4
        2f.pow(-10f * t) * sin((t - s) * (2f * PI.toFloat()) / p) + 1f
    }
}
</code></pre>

<p>此缓动函数在动画结束时创建类似弹跳的效果。它一开始很快，然后略微超过目标并稳定下来，模仿弹簧的行为。其核心思想是将指数衰减 (2^-10t) 与正弦波相结合，以模拟弹性运动。它在起始 (0) 和结束 (1) 处返回精确值，但在两者之间添加了一个抖动。</p>

<p>你也可以使用常规的线性缓动，但结果看起来会更加平淡。这正是我在开头提到的——这个小细节为整体效果的流畅度和令人满意的体验贡献了 90%！</p>

<p>感谢你的阅读！如果你觉得我的实验有趣且我的解释对你有帮助，欢迎加入我的 <a href="https://t.me/droidshaderworks">Telegram 频道</a> 或在 <a href="https://x.com/KrowaNaMostku">Twitter (X)</a> 上关注我。这个项目只是我的一个爱好，说实话，我的动力很大程度上取决于收到的反馈——所以我非常高兴在频道里见到你。如果你愿意的话，请将这篇文章分享到你的社交媒体上，我将不胜感激。祝你撸码愉快！</p>
]]></content>
  </entry>
  
</feed>
