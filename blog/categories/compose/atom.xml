<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Compose | ç¨€æœ‰çŒ¿è¯‰]]></title>
  <link href="https://alexhilton.github.io/blog/categories/compose/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2025-12-11T14:11:05+00:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[å€ŸåŠ©RemoteComposeå¼€å‘åŠ¨æ€åŒ–é¡µé¢]]></title>
    <link href="https://alexhilton.github.io/blog/2025/12/11/intro-to-remotecompose/"/>
    <updated>2025-12-11T00:00:00+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/12/11/intro-to-remotecompose</id>
    <content type="html"><![CDATA[<blockquote><p>æœ¬æ–‡è¯‘è‡ªã€ŒRemoteCompose: Another Paradigm for Server-Driven UI in Jetpack Composeã€ï¼ŒåŸæ–‡é“¾æ¥<a href="https://proandroiddev.com/remotecompose-another-paradigm-for-server-driven-ui-in-jetpack-compose-92186619ba8f">https://proandroiddev.com/remotecompose-another-paradigm-for-server-driven-ui-in-jetpack-compose-92186619ba8f</a>ï¼Œç”±Jaewoong Eumå‘å¸ƒäº2025å¹´11æœˆ29æ—¥ã€‚</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:2000/0*o9-kxXHKgJcB-Bvh" title="auto auto" ></a></p>

<!-- more -->


<p>æ„å»ºåŠ¨æ€ç”¨æˆ·ç•Œé¢ä¸€ç›´æ˜¯ Android å¼€å‘ä¸­çš„ä¸€é¡¹æ ¹æœ¬æ€§æŒ‘æˆ˜ã€‚ä¼ ç»Ÿæ–¹æ³•è¦æ±‚æ¯æ¬¡ UI éœ€è¦æ›´æ”¹æ—¶éƒ½å¿…é¡»é‡æ–°ç¼–è¯‘å’Œé‡æ–°éƒ¨ç½²æ•´ä¸ªåº”ç”¨ç¨‹åºï¼Œè¿™ç»™ A/B æµ‹è¯•ã€åŠŸèƒ½å¼€å…³å’Œå®æ—¶å†…å®¹æ›´æ–°å¸¦æ¥äº†æå¤§çš„ä¸ä¾¿ã€‚</p>

<p>è¯•æƒ³ä¸€ä¸‹ï¼Œä½ çš„è¥é”€å›¢é˜Ÿæƒ³è¦æµ‹è¯•ä¸€ä¸ªæ–°çš„ç»“è´¦æŒ‰é’®è®¾è®¡ï¼šåœ¨ä¼ ç»Ÿæ¨¡å¼ä¸‹ï¼Œè¿™ç§ç®€å•çš„æ›´æ”¹éœ€è¦å¼€å‘äººå‘˜èŠ±è´¹æ—¶é—´ã€è¿›è¡Œä»£ç å®¡æŸ¥ã€QA æµ‹è¯•ã€æäº¤åˆ°åº”ç”¨å•†åº—ï¼Œä»¥åŠç­‰å¾…æ•°å‘¨æ‰èƒ½è·å¾—ç”¨æˆ·é‡‡çº³ã€‚RemoteCompose çš„å‡ºç°ä¸ºè§£å†³è¿™ä¸€é—®é¢˜æä¾›äº†ä¸€ä¸ªå¼ºå¤§çš„æ–¹æ¡ˆï¼Œå®ƒä½¿å¼€å‘äººå‘˜èƒ½å¤Ÿåœ¨è¿è¡Œæ—¶åˆ›å»ºã€ä¼ è¾“å’Œæ¸²æŸ“ Jetpack Compose UI å¸ƒå±€ï¼Œè€Œæ— éœ€é‡æ–°ç¼–è¯‘ã€‚</p>

<p>æœ¬æ–‡å°†æ¢è®¨ RemoteCompose çš„æ¦‚å¿µï¼Œç†è§£å…¶æ ¸å¿ƒæ¶æ„ï¼Œå¹¶æ¢ç´¢å®ƒå¦‚ä½•ä¸º Jetpack Compose çš„åŠ¨æ€é¡µé¢è®¾è®¡å¸¦æ¥è¯¸å¤šä¼˜åŠ¿ã€‚æœ¬æ–‡å¹¶éåº“çš„ä½¿ç”¨æ•™ç¨‹ï¼Œè€Œæ˜¯ç€é‡æ¢è®¨å®ƒæ‰€ä»£è¡¨çš„ Android UI å¼€å‘èŒƒå¼è½¬å˜ã€‚</p>

<h3><strong>é›†æˆä¸ä¾èµ–</strong></h3>

<p>åœ¨æ·±å…¥æ¢è®¨æ¦‚å¿µä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæ¥äº†è§£å¦‚ä½•å°† RemoteCompose æ·»åŠ åˆ°ä½ çš„é¡¹ç›®ä¸­ã€‚å¯¹äºè¿è¡Œåœ¨ JVM ä¸Šä¸”ä¸ä¾èµ– Android çš„æœåŠ¡å™¨å’Œåç«¯ï¼š</p>

<pre><code class="groovy">// settings.gradle
repositories {
  maven {
    url = uri("https://androidx.dev/snapshots/builds/14511716/artifacts/repository")
  }
}

// JVM server - no Android dependencies
dependencies {
    implementation("androidx.compose.remote:remote-core:1.0.0-SNAPSHOT")
    implementation("androidx.compose.remote:remote-creation-compose:1.0.0-SNAPSHOT")
}

// Compose-based app
dependencies {
    implementation("androidx.compose.remote:remote-player-compose:1.0.0-SNAPSHOT")
    implementation("androidx.compose.remote:remote-tooling-preview:1.0.0-SNAPSHOT")
}

// View-based app
dependencies {
    implementation("androidx.compose.remote:remote-player-view:1.0.0-SNAPSHOT")
}
</code></pre>

<p>è¯·æ³¨æ„ï¼ŒRemoteCompose ä»åœ¨ç”± AndroidX å›¢é˜Ÿå¼€å‘ä¸­ï¼Œå°šæœªæ­£å¼å‘å¸ƒï¼›å®ƒä»…å¯é€šè¿‡ AndroidX å¿«ç…§ Maven ä»“åº“è·å–ã€‚</p>

<h3>ç†è§£æ ¸å¿ƒæŠ½è±¡</h3>

<p>RemoteCompose çš„æ ¸å¿ƒæ˜¯ä¸€ä¸ªæ¡†æ¶ï¼Œå®ƒæ”¯æŒ Compose UI ç»„ä»¶çš„è¿œç¨‹æ¸²æŸ“ã€‚å®ƒä¸ä¼ ç»Ÿ UI æ–¹æ³•çš„åŒºåˆ«åœ¨äºå®ƒéµå¾ªä¸¤ä¸ªåŸºæœ¬åŸåˆ™ï¼šå£°æ˜å¼æ–‡æ¡£åºåˆ—åŒ–å’Œå¹³å°æ— å…³æ¸²æŸ“ã€‚è¿™äº›ä¸ä»…ä»…æ˜¯æŠ€æœ¯ç‰¹æ€§ï¼›è¿™äº›æ¶æ„å†³ç­–ä»æ ¹æœ¬ä¸Šæ”¹å˜äº†ä½ å¯¹ UI éƒ¨ç½²çš„æ€è€ƒæ–¹å¼ã€‚</p>

<p><strong>å£°æ˜å¼æ–‡æ¡£åºåˆ—åŒ–</strong></p>

<p>å£°æ˜å¼æ–‡æ¡£åºåˆ—åŒ–æ„å‘³ç€ä½ å¯ä»¥å°†ä»»ä½• Jetpack Compose å¸ƒå±€æ•è·ä¸ºç´§å‡‘çš„åºåˆ—åŒ–æ ¼å¼ã€‚ä½ å¯ä»¥æŠŠå®ƒæƒ³è±¡æˆå¯¹ UI è¿›è¡Œâ€œæˆªå›¾â€ï¼Œåªä¸è¿‡ä½ æ•è·çš„ä¸æ˜¯åƒç´ ï¼Œè€Œæ˜¯å®é™…çš„ç»˜å›¾æŒ‡ä»¤ã€‚è¿™ä¸ªæ•è·çš„æ–‡æ¡£åŒ…å«äº†é‡å»º UI æ‰€éœ€çš„ä¸€åˆ‡ï¼šå½¢çŠ¶ã€é¢œè‰²ã€æ–‡æœ¬ã€å›¾åƒã€åŠ¨ç”»ï¼Œç”šè‡³è¿˜æœ‰äº¤äº’å¼è§¦æ‘¸åŒºåŸŸã€‚</p>

<pre><code class="kotlin">// On the server or creation side
val document = captureRemoteDocument(
    context = context,
    creationDisplayInfo = displayInfo,
    profile = profile
) {
    RemoteColumn(modifier = RemoteModifier.fillMaxSize()) {
        RemoteText("Dynamic Content")
        RemoteButton(onClick = { /* action */ }) {
            RemoteText("Click Me")
        }
    }
}
</code></pre>

<p>ç»“æœå¦‚ä½•ï¼Ÿä¸€ä¸ªå¯ä»¥é€šè¿‡ç½‘ç»œå‘é€çš„å­—èŠ‚æ•°ç»„ã€‚è¿™ç§æ–¹æ³•çš„å…³é”®åœ¨äºï¼Œåˆ›å»ºç«¯ç¼–å†™çš„æ˜¯æ ‡å‡†çš„ Compose ä»£ç ã€‚æ— éœ€å­¦ä¹ æ–°çš„ DSLï¼Œæ— éœ€ç»´æŠ¤ JSON æ¨¡å¼ï¼Œä¹Ÿæ— éœ€æŒæ¡æ¨¡æ¿è¯­è¨€ã€‚åªè¦å¯ä»¥ç”¨ Compose ç¼–å†™ï¼Œå°±å¯ä»¥ç”¨ RemoteCompose æ•è·ã€‚</p>

<p>ä½ å¯ä»¥æ•è·ä¸€ä¸ªæ™®é€šçš„ Compose ä»£ç ï¼Œå®ƒä¼šæ•è·ç»˜åˆ¶è°ƒç”¨ï¼ˆè¿™äº›è°ƒç”¨éå¸¸é™æ€ï¼‰ã€‚æ›´å¸¸è§çš„æƒ…å†µæ˜¯ï¼Œä½ åº”è¯¥æ‹¥æœ‰é•œåƒ Compose çš„ Remote* ä¸“ç”¨ APIï¼Œè¿™äº› API ä¸“ä¸ºåºåˆ—åŒ–å’Œè¿œç¨‹æ’­æ”¾è€Œè®¾è®¡ï¼Œä¾‹å¦‚ <code>RemoteColumn</code>ã€<code>RemoteButton</code>ã€<code>RemoteText</code> ç­‰ã€‚</p>

<p><strong>å¹³å°æ— å…³æ¸²æŸ“</strong></p>

<p>å¹³å°æ— å…³æ¸²æŸ“æ„å‘³ç€æ•è·çš„æ–‡æ¡£å¯ä»¥é€šè¿‡ç½‘ç»œä¼ è¾“ï¼Œå¹¶åœ¨ä»»ä½• Android è®¾å¤‡ä¸Šæ¸²æŸ“ï¼Œè€Œæ— éœ€åŸå§‹çš„ Compose ä»£ç ã€‚å®¢æˆ·ç«¯è®¾å¤‡ä¸éœ€è¦ä½ çš„å¯ç»„åˆå‡½æ•°ã€è§†å›¾æ¨¡å‹æˆ–ä¸šåŠ¡é€»è¾‘â€”â€”å®ƒåªéœ€è¦æ–‡æ¡£å­—èŠ‚å’Œä¸€ä¸ªæ’­æ”¾å™¨ã€‚</p>

<pre><code class="kotlin">// On the client or player side
RemoteDocumentPlayer(
    document = remoteDocument.document,
    documentWidth = windowInfo.containerSize.width,
    documentHeight = windowInfo.containerSize.height,
    onAction = { actionId, value -&gt;
        // Handle user interactions
    }
)
</code></pre>

<p>è¿™äº›ç‰¹æ€§å¹¶éä»…ä»…æ˜¯ä¸ºäº†æ–¹ä¾¿ï¼›å®ƒä»¬æ˜¯æ¶æ„çº¦æŸï¼Œèƒ½å¤ŸçœŸæ­£å®ç° UI å®šä¹‰ä¸éƒ¨ç½²çš„è§£è€¦ã€‚æ–‡æ¡£æ ¼å¼ä¸ä»…åŒ…å«é™æ€å¸ƒå±€ï¼Œè¿˜åŒ…å«çŠ¶æ€ã€åŠ¨ç”»å’Œäº¤äº’ï¼Œä»è€Œå®Œæ•´åœ°å‘ˆç°äº† UI ä½“éªŒã€‚</p>

<p><strong>â€‹â€‹æ–¹æ³•æ¯”è¾ƒï¼šä¸ºä»€ä¹ˆä¸é€‰æ‹© JSON æˆ– WebViewï¼Ÿ</strong></p>

<p>åœ¨æ·±å…¥æ¢è®¨ä¹‹å‰ï¼Œæˆ‘ä»¬æœ‰å¿…è¦äº†è§£ RemoteCompose ä¸ºä»€ä¹ˆé€‰æ‹©è¿™ç§æ–¹æ³•è€Œä¸æ˜¯å…¶ä»–æ–¹æ¡ˆã€‚</p>

<p>åŸºäº JSON çš„æœåŠ¡å™¨ç«¯ UIï¼Œä¾‹å¦‚ Airbnb çš„ Epoxy æˆ– Shopify çš„æ–¹æ³•ï¼Œéœ€è¦å®šä¹‰ä¸€ä¸ªæ˜ å°„åˆ°åŸç”Ÿç»„ä»¶çš„æ¨¡å¼ã€‚è¿™ç§æ–¹æ³•é€‚ç”¨äºç»“æ„åŒ–å†…å®¹ï¼Œä½†éš¾ä»¥å¤„ç†å¤æ‚çš„åŠ¨ç”»å’Œè¿‡æ¸¡æ•ˆæœã€è‡ªå®šä¹‰ç»˜å›¾å’Œå›¾å½¢ã€å¸¦æœ‰å†…è”æ ·å¼çš„å¯Œæ–‡æœ¬ä»¥åŠæ¸å˜å’Œé˜´å½±ç­‰è§†è§‰æ•ˆæœã€‚</p>

<p>WebView æä¾›äº†å…¨é¢çš„çµæ´»æ€§ï¼Œä½†ç”±äºå…¶ç‹¬ç«‹çš„æ¸²æŸ“è¿‡ç¨‹ï¼Œä¼šå¸¦æ¥æ€§èƒ½å¼€é”€ï¼›æ­¤å¤–ï¼ŒWeb æ ·å¼ä¸åŸç”Ÿè®¾è®¡åœ¨å¤–è§‚å’Œä½“éªŒä¸Šå­˜åœ¨ä¸ä¸€è‡´ï¼›æ¯ä¸ª WebView éƒ½ä¼šå ç”¨å¤§é‡èµ„æºï¼Œé€ æˆå†…å­˜å‹åŠ›ï¼›è§¦æ‘¸å¤„ç†ä¹Ÿè¾ƒä¸ºå¤æ‚ï¼Œå®¹æ˜“å‡ºç°æ‰‹åŠ¿å†²çªã€‚</p>

<p>RemoteCompose å¦è¾Ÿè¹Šå¾„ï¼šæ•è· Compose å®é™…æ‰§è¡Œçš„ç»˜åˆ¶æ“ä½œã€‚è¿™æ„å‘³ç€ï¼Œä½ å¯ä»¥ä½¿ç”¨ Compose æ„å»ºçš„ä»»ä½• UIï¼ŒåŒ…æ‹¬è‡ªå®šä¹‰ Canvas ç»˜åˆ¶ã€å¤æ‚åŠ¨ç”»å’Œ Material Design ç»„ä»¶ï¼Œéƒ½å¯ä»¥è¢«æ•è·å¹¶ä»¥åŸç”Ÿæ€§èƒ½è¿œç¨‹é‡æ”¾ã€‚</p>

<h3><strong>åŸºäºæ–‡æ¡£çš„æ¶æ„ï¼šåˆ›å»ºä¸å›æ”¾</strong></h3>

<p>RemoteCompose çš„æ¶æ„å›´ç»•ç€ä¸¤ä¸ªé˜¶æ®µçš„æ¸…æ™°åˆ†ç¦»è€Œæ„å»ºï¼šæ–‡æ¡£åˆ›å»ºå’Œæ–‡æ¡£å›æ”¾ã€‚ç†è§£è¿™ç§åˆ†ç¦»æ˜¯ç†è§£æ¡†æ¶å¼ºå¤§åŠŸèƒ½çš„å…³é”®ã€‚</p>

<p><strong>æ–‡æ¡£åˆ›å»ºï¼šå°† UI ä½œä¸ºæ•°æ®æ•è·</strong></p>

<p>åˆ›å»ºé˜¶æ®µå°† Compose UI ä»£ç è½¬æ¢ä¸ºåºåˆ—åŒ–æ–‡æ¡£ã€‚è¿™æ˜¯é€šè¿‡æ•è·æœºåˆ¶å®ç°çš„ï¼Œè¯¥æœºåˆ¶ä¼šåœ¨ Canvas å±‚ï¼ˆAndroid æ¸²æŸ“ç®¡çº¿çš„æœ€åº•å±‚ï¼‰æ‹¦æˆªç»˜åˆ¶æ“ä½œã€‚</p>

<pre><code class="kotlin">@Composable Content
        â†“
RemoteComposeCreationState (Tracks state and modifiers)
        â†“
CaptureComposeView (Virtual Display - no actual screen needed)
        â†“
RecordingCanvas (Intercepts every draw call)
        â†“
Operations (93+ operation types covering all drawing primitives)
        â†“
RemoteComposeBuffer (Efficient binary serialization)
        â†“
ByteArray (Network-ready, typically 10-100KB for complex UIs)
</code></pre>

<p>åˆ›å»ºç«¯æä¾›äº†ä¸€ä¸ªå®Œæ•´çš„ Compose é›†æˆå±‚ã€‚ä½ åªéœ€ç¼–å†™æ ‡å‡†çš„ <code>@Composable</code> å‡½æ•°ï¼Œæ¡†æ¶å³å¯æ•è·æ‰€æœ‰å†…å®¹ï¼šå¸ƒå±€å±‚çº§ã€ä¿®é¥°ç¬¦ã€æ–‡æœ¬æ ·å¼ã€å›¾åƒã€åŠ¨ç”»ï¼Œç”šè‡³è§¦æ‘¸å¤„ç†ç¨‹åºã€‚</p>

<p>å…¶ç‹¬ç‰¹ä¹‹å¤„åœ¨äºï¼Œæ•è·çš„æ–‡æ¡£æ˜¯è‡ªåŒ…å«çš„ã€‚å®ƒåŒ…å«å½¢çŠ¶ã€é¢œè‰²ã€æ¸å˜å’Œé˜´å½±ç­‰è§†è§‰å…ƒç´ ï¼Œä»¥åŠå¸¦æœ‰å­—ç¬¦ä¸²ã€å­—ä½“ã€å¤§å°å’Œæ ·å¼çš„æ–‡æœ¬ã€‚å›¾åƒå¯ä»¥åµŒå…¥ä¸ºä½å›¾æˆ– URL ä»¥å®ç°å»¶è¿ŸåŠ è½½ã€‚å¸ƒå±€ä¿¡æ¯æ¶µç›–å¤§å°ã€ä½ç½®ã€å†…è¾¹è·å’Œå¯¹é½æ–¹å¼ã€‚äº¤äº’å®šä¹‰äº†è§¦æ‘¸åŒºåŸŸã€ç‚¹å‡»å¤„ç†ç¨‹åºå’Œå‘½åæ“ä½œã€‚çŠ¶æ€å˜é‡å¯ä»¥åœ¨è¿è¡Œæ—¶æ›´æ–°ï¼ŒåŠ¨ç”»åˆ™é€šè¿‡åŸºäºæ—¶é—´çš„è¿åŠ¨è¡¨è¾¾å¼æ¥è¡¨è¾¾ã€‚</p>

<p>æ¥æ”¶æ–¹æ— éœ€è®¿é—®ä½ çš„ä»£ç åº“ï¼Œåªéœ€è®¿é—®æ–‡æ¡£å­—èŠ‚å³å¯ã€‚è¿™ä¸å…¶ä»–æœåŠ¡å™¨é©±åŠ¨çš„ UI æ–¹æ³•æœ‰ç€æœ¬è´¨åŒºåˆ«ï¼Œåœ¨å…¶ä»–æ–¹æ³•ä¸­ï¼Œå®¢æˆ·ç«¯éœ€è¦ç†è§£æ¶æ„æˆ–æ‹¥æœ‰é¢„æ„å»ºçš„ç»„ä»¶ã€‚</p>

<p><strong>æ–‡æ¡£æ’­æ”¾ï¼šæ— éœ€ç¼–è¯‘å³å¯æ¸²æŸ“</strong></p>

<p>æ’­æ”¾é˜¶æ®µæ¥æ”¶åºåˆ—åŒ–çš„æ–‡æ¡£å¹¶å°†å…¶æ¸²æŸ“åˆ°å±å¹•ä¸Šã€‚æ’­æ”¾å™¨ä¼šéå†ä¸€ç³»åˆ—æ“ä½œï¼Œå¯¹ Canvas æ‰§è¡Œæ¯ä¸ªæ“ä½œã€‚å…¶æ¦‚å¿µç±»ä¼¼äºè§†é¢‘æ’­æ”¾å™¨è§£ç å¸§çš„æ–¹å¼ï¼Œåªä¸è¿‡æˆ‘ä»¬è§£ç çš„æ˜¯ç»˜å›¾æŒ‡ä»¤è€Œä¸æ˜¯åƒç´ ã€‚</p>

<p>RemoteCompose æä¾›ä¸¤ç§æ¸²æŸ“åç«¯ä»¥æ»¡è¶³ä¸åŒçš„æ¶æ„éœ€æ±‚ã€‚åŸºäº Compose çš„æ’­æ”¾å™¨æ¨èç”¨äºç°ä»£åº”ç”¨ç¨‹åºï¼š</p>

<pre><code class="kotlin">@Composable
fun DynamicScreen(document: CoreDocument) {
    RemoteDocumentPlayer(
        document = document,
        documentWidth = screenWidth,
        documentHeight = screenHeight,
        modifier = Modifier.fillMaxSize(),
        onNamedAction = { name, value, stateUpdater -&gt;
            // Handle named actions from the document
            when (name) {
                "addToCart" -&gt; cartManager.addItem(value)
                "navigate" -&gt; navController.navigate(value)
                "trackEvent" -&gt; analytics.logEvent(value)
            }
        },
        bitmapLoader = rememberBitmapLoader()  // For lazy image loading
    )
}
</code></pre>

<p>åŸºäº Compose çš„æ’­æ”¾å™¨å¯ä»¥è‡ªç„¶åœ°ä¸ä½ ç°æœ‰çš„ Compose UI é›†æˆã€‚å®ƒæ˜¯ä¸€ä¸ªå¯ç»„åˆçš„å‡½æ•°ï¼Œä½ å¯ä»¥å°†å…¶æ”¾ç½®åœ¨ç»„åˆå±‚çº§ç»“æ„ä¸­çš„ä»»ä½•ä½ç½®ï¼Œå¹¶åƒå…¶ä»–å¯ç»„åˆå‡½æ•°ä¸€æ ·å¯¹å…¶åº”ç”¨ä¿®é¥°ç¬¦å’ŒåŠ¨ç”»ã€‚</p>

<p>ä¸ºäº†ä¸ç°æœ‰çš„ View å±‚çº§ç»“æ„å…¼å®¹ï¼Œæˆ‘ä»¬è¿˜æä¾›äº†ä¸€ä¸ªåŸºäº View çš„æ’­æ”¾å™¨ï¼š</p>

<pre><code class="kotlin">class LegacyActivity : AppCompatActivity() {
    private lateinit var player: RemoteComposePlayer

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        player = RemoteComposePlayer(this)
        setContentView(player)

        // Load document from network
        lifecycleScope.launch {
            val bytes = api.fetchDocument("home-screen")
            player.setDocument(bytes)
        }

        player.onNamedAction { name, value, stateUpdater -&gt;
            // Handle actions
        }
    }
}
</code></pre>

<p>ä¸¤ç§æ’­æ”¾å™¨æä¾›ç›¸åŒçš„æ¸²æŸ“ä¿çœŸåº¦ï¼›é€‰æ‹©å“ªç§å–å†³äºä½ çš„åº”ç”¨ç¨‹åºæ¶æ„ã€‚å¦‚æœä½ å®Œå…¨ä½¿ç”¨ Composeï¼Œè¯·ä½¿ç”¨å¯ç»„åˆæ’­æ”¾å™¨ã€‚å¦‚æœä½ æ˜¯ä» Views è¿ç§»è¿‡æ¥çš„ï¼Œæˆ–è€…å°†å…¶åµŒå…¥åˆ° View å±‚çº§ç»“æ„ä¸­ï¼Œè¯·ä½¿ç”¨åŸºäº View çš„æ’­æ”¾å™¨ã€‚</p>

<h3><strong>æ“ä½œæ¨¡å‹ï¼šä¸€å¥—å…¨é¢çš„ç»˜å›¾è¯æ±‡è¡¨</strong></h3>

<p>RemoteCompose çš„ä¼˜åŠ¿åœ¨äºå…¶å…¨é¢çš„æ“ä½œæ¨¡å‹ã€‚è¯¥æ¡†æ¶å®šä¹‰äº† 93 ç§ä»¥ä¸Šçš„ä¸åŒæ“ä½œï¼Œæ¶µç›–äº† UI æ¸²æŸ“çš„æ–¹æ–¹é¢é¢ã€‚è¿™å¹¶ééšæ„è®¾å®šçš„æ•°å­—ï¼Œè€Œæ˜¯è¡¨è¾¾ä»»ä½• Canvas ç»˜å›¾æ“ä½œæ‰€éœ€çš„å®Œæ•´è¯æ±‡è¡¨ã€‚</p>

<p><strong>æ“ä½œçš„é‡è¦æ€§</strong></p>

<p>ä¼ ç»Ÿçš„æœåŠ¡å™¨é©±åŠ¨å‹ UI å‘é€çš„æ˜¯é«˜çº§ç»„ä»¶æè¿°ï¼šâ€œæ¸²æŸ“ä¸€ä¸ªå¸¦æœ‰æ–‡æœ¬â€˜æäº¤â€™çš„æŒ‰é’®â€ã€‚å®¢æˆ·ç«¯å¿…é¡»è§£æè¿™äº›æè¿°å¹¶å°†å…¶æ˜ å°„åˆ°åŸç”Ÿç»„ä»¶ã€‚è¿™å¯¼è‡´æœåŠ¡å™¨å’Œå®¢æˆ·ç«¯ä¹‹é—´ç´§å¯†è€¦åˆï¼›åŒæ–¹å¿…é¡»å°±â€œæŒ‰é’®â€çš„å®šä¹‰åŠå…¶è¡Œä¸ºè¾¾æˆä¸€è‡´ã€‚</p>

<p>RemoteCompose åˆ™åœ¨æ›´åº•å±‚è¿è¡Œï¼šå®ƒä¸å‘é€â€œæ¸²æŸ“ä¸€ä¸ªæŒ‰é’®â€è¿™æ ·çš„æè¿°ï¼Œè€Œæ˜¯å‘é€å®é™…çš„ç»˜å›¾æŒ‡ä»¤ï¼šâ€œåœ¨è¿™äº›åæ ‡å¤„ç»˜åˆ¶ä¸€ä¸ªå¸¦æœ‰è¿™ç§é¢œè‰²çš„åœ†è§’çŸ©å½¢ï¼Œç„¶ååœ¨è¿™ä¸ªä½ç½®ç»˜åˆ¶å¸¦æœ‰è¿™ç§å­—ä½“çš„æ–‡æœ¬â€˜æäº¤â€™â€ã€‚å®¢æˆ·ç«¯æ— éœ€äº†è§£â€œæŒ‰é’®â€çš„å®šä¹‰ï¼›å®ƒåªéœ€æ‰§è¡Œç»˜å›¾æ“ä½œå³å¯ã€‚</p>

<p>è¿™ç§åº•å±‚æ–¹æ³•æ„ä¹‰æ·±è¿œã€‚ç”±äºæœåŠ¡å™¨å’Œå®¢æˆ·ç«¯æ— éœ€å°±ç»„ä»¶å®šä¹‰è¾¾æˆä¸€è‡´ï¼Œå› æ­¤æ— éœ€è¿›è¡Œæ¨¡å¼åŒæ­¥ã€‚ç”±äº Compose ä¸­æ‰€æœ‰å¯èƒ½çš„è§†è§‰æ•ˆæœå‡å¯æ•è·ï¼Œå› æ­¤èƒ½å¤Ÿå®Œæ•´ä¿ç•™è§†è§‰ä¿çœŸåº¦ã€‚ç”±äºæ–°çš„è§†è§‰è®¾è®¡å¯åœ¨æ—§å®¢æˆ·ç«¯ä¸Šè¿è¡Œï¼ˆå®ƒä»¬åªæ˜¯ä¸åŒçš„ç»˜åˆ¶æ“ä½œï¼‰ï¼Œå› æ­¤å†…ç½®äº†å‘å‰å…¼å®¹æ€§ã€‚è‡ªå®šä¹‰ç»„ä»¶æ— éœ€æ³¨å†Œå³å¯è‡ªåŠ¨è¿è¡Œã€‚</p>

<p><strong>ç»˜åˆ¶æ“ä½œ</strong></p>

<p>ç»˜åˆ¶æ“ä½œæ•è· Canvas ç»˜åˆ¶è°ƒç”¨ï¼Œè¿™æ˜¯ 2D å›¾å½¢çš„åŸºæœ¬å›¾å…ƒã€‚è¿™äº›å›¾å…ƒåŒ…æ‹¬ï¼šç”¨äºæŒ‰é’®ã€å¡ç‰‡å’ŒèƒŒæ™¯çš„çŸ©å½¢çš„ <code>DRAW_RECT</code>ï¼›ç”¨äºå¸¦æœ‰åœ†è§’çš„ Material æ›²é¢çš„ <code>DRAW_ROUND_RECT</code>ï¼›ç”¨äºå¤´åƒå’ŒæŒ‡ç¤ºå™¨çš„ <code>DRAW_CIRCLE</code>ï¼›ç”¨äºæ¸²æŸ“å¸¦æœ‰å®Œæ•´æ ·å¼çš„æ–‡æœ¬çš„ <code>DRAW_TEXT</code>ï¼›ç”¨äºæ²¿æ›²çº¿ç»˜åˆ¶æ–‡æœ¬çš„ <code>DRAW_TEXT_ON_PATH</code>ï¼›ä»¥åŠç”¨äºå›¾åƒçš„ <code>DRAW_BITMAP</code>ã€‚ <code>DRAW_TWEEN_PATH</code> ç”¨äºåŠ¨ç”»è·¯å¾„å˜å½¢ï¼Œç­‰ç­‰ã€‚</p>

<p>æ¯ä¸ªæ“ä½œéƒ½åŒ…å«æ‰§è¡Œå®ƒæ‰€éœ€çš„æ‰€æœ‰ä¿¡æ¯ï¼šåæ ‡ã€é¢œè‰²ã€ç»˜åˆ¶æ ·å¼ä»¥åŠå¯¹æ–‡æ¡£ä¸­å…¶ä»–ä½ç½®å­˜å‚¨çš„æ•°æ®ï¼ˆä¾‹å¦‚æ–‡æœ¬å­—ç¬¦ä¸²æˆ–ä½å›¾ï¼‰çš„å¼•ç”¨ã€‚</p>

<p><strong>å¸ƒå±€æ“ä½œ</strong></p>

<p>å¸ƒå±€æ“ä½œå®šä¹‰ç»„ä»¶å±‚æ¬¡ç»“æ„å’Œç©ºé—´å…³ç³»ã€‚<code>Component</code> æ“ä½œå£°æ˜ä¸€ä¸ªå¸ƒå±€ç»„ä»¶ï¼Œè€Œ <code>Container</code> æ“ä½œåˆ›å»ºä¸€ä¸ªç±»ä¼¼äº <code>Column</code> æˆ– <code>Row</code> çš„å®¹å™¨ï¼Œ<code>ContainerEnd</code> æ“ä½œåˆ™å…³é—­å®ƒã€‚<code>LoopOperation</code> æ“ä½œç”¨äºå¾ªç¯åˆ—è¡¨å†…å®¹ã€‚<code>Modifier</code> åŒ…æ‹¬ç”¨äºèƒŒæ™¯é¢œè‰²å’Œå¯ç»˜åˆ¶å¯¹è±¡çš„ <code>BackgroundModifier</code>ã€ç”¨äºè¾¹æ¡†æ ·å¼çš„ <code>BorderModifier</code>ã€ç”¨äºå†…éƒ¨é—´è·çš„ <code>PaddingModifier</code> ä»¥åŠç”¨äºè§¦æ‘¸å¤„ç†çš„ <code>ClickModifier</code>ã€‚</p>

<p>å®¹å™¨æ¨¡å‹é‡‡ç”¨æ¨é€/å¼¹å‡ºæœºåˆ¶ã€‚å½“æ’­æ”¾å™¨é‡åˆ° <code>Container</code> æ“ä½œæ—¶ï¼Œå®ƒä¼šåˆ›å»ºä¸€ä¸ªæ–°çš„å¸ƒå±€ä¸Šä¸‹æ–‡ã€‚æ‰€æœ‰åç»­æ“ä½œéƒ½å°†åœ¨è¯¥ä¸Šä¸‹æ–‡ä¸­æ‰§è¡Œï¼Œç›´åˆ° <code>ContainerEnd</code> æ“ä½œå°†å…¶å¼¹å‡ºã€‚è¿™ä¸ Compose çš„å¸ƒå±€ç³»ç»Ÿçš„å·¥ä½œæ–¹å¼ç±»ä¼¼ã€‚</p>

<p><strong>çŠ¶æ€å’Œè¡¨è¾¾å¼æ“ä½œ</strong></p>

<p>çŠ¶æ€æ“ä½œæ”¯æŒè¿è¡Œæ—¶å¯æ›´æ”¹çš„åŠ¨æ€å€¼ã€‚<code>NamedVariable</code> å£°æ˜ä¸€ä¸ªå‘½åçš„çŠ¶æ€å˜é‡ã€‚<code>ColorAttribute</code> æä¾›å¯è‡ªå®šä¹‰ä¸»é¢˜çš„é¢œè‰²ã€‚<code>TimeAttribute</code> å¼•ç”¨åŠ¨ç”»æ—¶é—´ã€‚<code>FloatExpression</code> å’Œ <code>IntegerExpression</code> æ¯å¸§è®¡ç®—æ•°å­¦è¡¨è¾¾å¼ã€‚<code>ConditionalOp</code> æ”¯æŒåŸºäºçŠ¶æ€çš„æ¡ä»¶æ¸²æŸ“ã€‚</p>

<p>è¡¨è¾¾å¼ç³»ç»ŸåŠŸèƒ½å¼ºå¤§ã€‚ä½ å¯ä»¥åµŒå…¥å…¬å¼ï¼Œè€Œä¸æ˜¯é™æ€å€¼ï¼š</p>

<pre><code class="kotlin">// These expressions are evaluated every frame
val opacity = FloatExpression("sin(time * 2) * 0.5 + 0.5")  // Pulsing effect
val rotation = FloatExpression("time * 90 % 360")

// Continuous rotation
val position = FloatExpression("lerp(0, 100, time / 2)")

// Linear interpolation
</code></pre>

<p>è¿™ä½¿å¾—å®Œå…¨åœ¨æ–‡æ¡£ä¸­å®šä¹‰ä¸°å¯Œçš„åŠ¨ç”»æˆä¸ºå¯èƒ½â€”â€”æ— éœ€å®¢æˆ·ç«¯åŠ¨ç”»ä»£ç ã€‚
â€‹â€‹
<strong>äº¤äº’æ“ä½œ</strong></p>

<p>äº¤äº’æ“ä½œå¤„ç†ç”¨æˆ·è¾“å…¥ã€‚<code>TouchOperation</code> å®šä¹‰è§¦æ‘¸åŒºåŸŸï¼Œè€Œ <code>CLICK_AREA</code> å¤„ç†ç®€å•çš„ç‚¹å‡»æ“ä½œã€‚<code>ParticlesCreate</code> åˆå§‹åŒ–ç²’å­ç³»ç»Ÿï¼Œ<code>ParticlesLoop</code> é©±åŠ¨ç²’å­åŠ¨ç”»ã€‚</p>

<p>è§¦æ‘¸æ“ä½œæ³¨å†Œå¸¦æœ‰å‘½åæ“ä½œçš„çŸ©å½¢åŒºåŸŸã€‚å½“ç”¨æˆ·ç‚¹å‡»æŸä¸ªåŒºåŸŸæ—¶ï¼Œæ’­æ”¾å™¨ä¼šè§¦å‘ç›¸åº”çš„æ“ä½œï¼Œå®¿ä¸»åº”ç”¨ç¨‹åºä¼šé€šè¿‡å›è°ƒå‡½æ•°æ¥å¤„ç†è¿™äº›æ“ä½œã€‚è¿™ç§è®¾è®¡æ—¢ä¿æŒäº†æ–‡æ¡£æ ¼å¼çš„ç®€æ´æ€§ï¼Œåˆå®ç°äº†ä¸°å¯Œçš„äº¤äº’åŠŸèƒ½ã€‚</p>

<h3>åŠ¨æ€å±å¹•è®¾è®¡çš„ä¼˜åŠ¿</h3>

<p>ç°åœ¨ï¼Œè®©æˆ‘ä»¬é€šè¿‡å¸¸è§åº”ç”¨åœºæ™¯ä¸­çš„çœŸå®æ¡ˆä¾‹ï¼Œæ¥æ¢è®¨ RemoteCompose ä¸ºåŠ¨æ€å±å¹•è®¾è®¡å¸¦æ¥çš„åˆ‡å®ä¼˜åŠ¿ã€‚</p>

<p><strong>æœåŠ¡å™¨é©±åŠ¨ UIï¼Œæ€§èƒ½æ¯«ä¸å¦¥å</strong></p>

<p>ä¼ ç»Ÿçš„æœåŠ¡å™¨é©±åŠ¨ UI æ–¹æ³•éœ€è¦æƒè¡¡å–èˆã€‚åŸºäº JSON çš„å¸ƒå±€è¡¨è¾¾èƒ½åŠ›æœ‰é™ï¼Œæ— æ³•å®ç°å¤æ‚çš„åŠ¨ç”»æˆ–è‡ªå®šä¹‰ç»˜åˆ¶ã€‚WebView ä¼šå¸¦æ¥æ€§èƒ½å¼€é”€ã€å¤–è§‚ä¸ä¸€è‡´ä»¥åŠæ›´é«˜çš„å†…å­˜å ç”¨ã€‚è‡ªå®šä¹‰ DSL åˆ™ä¼šå¢åŠ ç»´æŠ¤è´Ÿæ‹…ã€å­¦ä¹ æ›²çº¿ï¼Œå¹¶ä¸”å¯¹é¢„å®šä¹‰ç»„ä»¶æœ‰æ‰€é™åˆ¶ã€‚</p>

<p>RemoteCompose æä¾›äº†ç¬¬ä¸‰æ¡è·¯å¾„ï¼šä»æœåŠ¡å™¨å®šä¹‰çš„å¸ƒå±€è¿›è¡ŒåŸç”Ÿ Compose æ¸²æŸ“ã€‚ä½ æ—¢èƒ½å……åˆ†åˆ©ç”¨ Compose æ¸²æŸ“å¼•æ“çš„å¼ºå¤§åŠŸèƒ½ï¼Œåˆèƒ½äº«å—æœåŠ¡å™¨é©±åŠ¨å†…å®¹çš„çµæ´»æ€§ã€‚</p>

<p>ä¾‹å¦‚ï¼Œä¸€ä¸ªç”µå•†åº”ç”¨éœ€è¦é¢‘ç¹æ›´æ–°äº§å“å¡ç‰‡ã€æ·»åŠ æ–°çš„å¾½ç« æ ·å¼ã€ä¿ƒé”€å åŠ å±‚æˆ–å­£èŠ‚æ€§ä¸»é¢˜ã€‚å€ŸåŠ© RemoteComposeï¼ŒæœåŠ¡å™¨ç«¯å…è®¸è¥é”€å›¢é˜Ÿæ— éœ€å‘å¸ƒåº”ç”¨å³å¯æ›´æ–°å¡ç‰‡è®¾è®¡ï¼š</p>

<pre><code class="kotlin">// Server-side: We can update card designs without app release
@Composable
fun ProductCard(product: Product) {
    Card(
        modifier = RemoteModifier
            .fillMaxWidth()
            .clickable { namedAction("viewProduct", product.id) }
    ) {
        Box {
            // Product image with gradient overlay
            AsyncImage(
                url = product.imageUrl,
                modifier = RemoteModifier.fillMaxWidth().aspectRatio(1.5f)
            )

            // Promotional badge - can be A/B tested server-side
            if (product.hasPromotion) {
                PromotionalBadge(
                    text = product.promotionText,
                    modifier = RemoteModifier.align(Alignment.TopEnd)
                )
            }

            // Price with sale styling
            PriceTag(
                originalPrice = product.originalPrice,
                salePrice = product.salePrice,
                modifier = RemoteModifier.align(Alignment.BottomStart)
            )
        }
    }
}
</code></pre>

<p>å®¢æˆ·ç«¯åªéœ€æ¸²æŸ“æœåŠ¡å™¨å‘é€çš„å†…å®¹ï¼š</p>

<pre><code class="kotlin">// Client-side: Just renders whatever the server sends
@Composable
fun ProductGrid(viewModel: ProductViewModel) {
    val documents by viewModel.productDocuments.collectAsState()

    LazyVerticalGrid(columns = GridCells.Fixed(2)) {
        items(documents) { document -&gt;
            RemoteDocumentPlayer(
                document = document,
                onNamedAction = { name, value, _ -&gt;
                    if (name == "viewProduct") {
                        navController.navigate("product/$value")
                    }
                }
            )
        }
    }
}
</code></pre>

<p>ç°åœ¨ï¼Œä½ çš„å›¢é˜Ÿæ— éœ€å‘å¸ƒä»»ä½•åº”ç”¨å³å¯æ›´æ–°äº§å“å¡ç‰‡è®¾è®¡ï¼Œæ›´æ”¹å¾½ç« é¢œè‰²ã€æ·»åŠ åŠ¨ç”»å’Œé‡æ–°æ’åˆ—å…ƒç´ ã€‚ç”±äºå®ƒæ˜¯åŸç”Ÿåº”ç”¨ï¼Œé€šè¿‡ Compose çš„å®é™…ç»˜åˆ¶ç®¡é“æ¸²æŸ“ï¼Œå› æ­¤ UI çš„å¤–è§‚å’Œä½“éªŒä¸åŸç”Ÿåº”ç”¨æ— å¼‚ã€‚</p>

<h3>å¤§è§„æ¨¡ A/B æµ‹è¯•</h3>

<p>ä¼ ç»Ÿçš„ A/B æµ‹è¯• UI å˜ä½“éœ€è¦åœ¨åº”ç”¨äºŒè¿›åˆ¶æ–‡ä»¶ä¸­å®ç°æ‰€æœ‰å˜ä½“ï¼Œä¸ºæ¯ä¸ªå˜ä½“åˆ›å»ºåŠŸèƒ½æ ‡å¿—ï¼Œå‘å¸ƒåŒ…å«æ‰€æœ‰å˜ä½“çš„åº”ç”¨ï¼Œç„¶åç­‰å¾…ç”¨æˆ·é‡‡ç”¨åå†è¡¡é‡ç»“æœã€‚ä»æ„æ€åˆ°è·å¾—æ•°æ®ï¼Œè¿™ä¸ªè¿‡ç¨‹é€šå¸¸éœ€è¦ 2-4 å‘¨ã€‚</p>

<p>å€ŸåŠ© RemoteComposeï¼Œä½ æ— éœ€éƒ¨ç½²ä»»ä½•å®¢æˆ·ç«¯å³å¯æµ‹è¯• UI å˜ä½“ã€‚å‡è®¾ä¸€ä¸ªç”µå•†å›¢é˜Ÿæƒ³è¦æµ‹è¯•å•é¡µç»“è´¦æµç¨‹æ˜¯å¦æ¯”å¤šæ­¥éª¤å‘å¯¼è½¬åŒ–ç‡æ›´é«˜ï¼š</p>

<pre><code class="kotlin">// Server-side: Two completely different checkout experiences
object CheckoutExperiments {

    fun getCheckoutDocument(user: User, cart: Cart): ByteArray {
        val variant = experimentService.getVariant(user.id, "checkout-flow")

        return when (variant) {
            "single-page" -&gt; captureSinglePageCheckout(cart)
            "multi-step" -&gt; captureMultiStepCheckout(cart)
            "express" -&gt; captureExpressCheckout(cart)  // New variant added without app update
            else -&gt; captureSinglePageCheckout(cart)
        }
    }

    private fun captureSinglePageCheckout(cart: Cart): ByteArray {
        return captureRemoteDocument(context, displayInfo, profile) {
            SinglePageCheckout(
                cart = cart,
                onPlaceOrder = { namedAction("placeOrder", cart.id) },
                onUpdateQuantity = { itemId, qty -&gt;
                    namedAction("updateQuantity", "$itemId:$qty")
                }
            )
        }
    }

    private fun captureMultiStepCheckout(cart: Cart): ByteArray {
        return captureRemoteDocument(context, displayInfo, profile) {
            MultiStepCheckout(
                cart = cart,
                steps = listOf("Shipping", "Payment", "Review"),
                onComplete = { namedAction("placeOrder", cart.id) }
            )
        }
    }
}
</code></pre>

<p>å®¢æˆ·ç«¯å®Œå…¨ä¸çŸ¥é“æ˜¾ç¤ºçš„æ˜¯å“ªä¸ªç‰ˆæœ¬ï¼š</p>

<pre><code class="kotlin">// Client-side: Completely agnostic to which variant is shown
@Composable
fun CheckoutScreen(viewModel: CheckoutViewModel) {
    val document by viewModel.checkoutDocument.collectAsState()

    document?.let { doc -&gt;
        RemoteDocumentPlayer(
            document = doc,
            onNamedAction = { name, value, stateUpdater -&gt;
                when (name) {
                    "placeOrder" -&gt; viewModel.placeOrder(value)
                    "updateQuantity" -&gt; {
                        val (itemId, qty) = value.split(":")
                        viewModel.updateQuantity(itemId, qty.toInt())
                    }
                }
            }
        )
    }
}
</code></pre>

<p>ç»“æœå³æ—¶ä¸”å®æ—¶ï¼Œè¿™æ„å‘³ç€æ— éœ€ç­‰å¾…åº”ç”¨å•†åº—å®¡æ ¸æˆ–ç”¨æˆ·åé¦ˆã€‚ä½ ç”šè‡³å¯ä»¥æ·»åŠ å…¨æ–°çš„ç‰ˆæœ¬ï¼Œä¾‹å¦‚â€œå¿«é€Ÿç»“è´¦â€ï¼Œè€Œæ— éœ€å¯¹å®¢æˆ·ç«¯è¿›è¡Œä»»ä½•æ›´æ”¹ã€‚å®éªŒä¼šæŒç»­è¿è¡Œï¼Œç›´åˆ°è·å¾—ç»Ÿè®¡å­¦æ„ä¹‰ä¸Šçš„æ˜¾è‘—æ€§ï¼Œç„¶åå°†è·èƒœç‰ˆæœ¬æ¨å¹¿åˆ°æ‰€æœ‰ç”¨æˆ·ï¼ŒåŒæ ·æ— éœ€å‘å¸ƒæ–°åº”ç”¨ã€‚</p>

<h3>å®æ—¶å†…å®¹æ›´æ–°</h3>

<p>å†…å®¹å¯†é›†å‹åº”ç”¨å¸¸å¸¸éœ€è¦åœ¨åŸç”Ÿæ€§èƒ½å’Œå†…å®¹æ–°é²œåº¦ä¹‹é—´å¯»æ±‚å¹³è¡¡ã€‚ä»¥æ–°é—»åº”ç”¨ä¸ºä¾‹ï¼šæ–‡ç« éœ€è¦ä¸°å¯Œçš„æ ¼å¼ã€åµŒå…¥å¼åª’ä½“å’Œäº¤äº’å…ƒç´ ï¼Œä½†åŒæ—¶ä¹Ÿéœ€è¦éšç€æ–°é—»äº‹ä»¶çš„è¿›å±•å®æ—¶æ›´æ–°ã€‚</p>

<p>ä¸€å®¶æŠ¥é“é‡å¤§äº‹ä»¶çš„æ–°é—»æœºæ„éœ€è¦å®æ—¶æ›´æ–°æ–‡ç« å¸ƒå±€ã€‚ç¼–è¾‘å›¢é˜Ÿå¯ä»¥æ ¹æ®æ–°é—»äº‹ä»¶çš„è¿›å±•è°ƒæ•´å¸ƒå±€ï¼š</p>

<pre><code class="kotlin">// Server-side: Editorial team can update layout as story develops
class ArticleLayoutService {

    fun getArticleDocument(article: Article): ByteArray {
        return captureRemoteDocument(context, displayInfo, profile) {
            ArticleLayout(article)
        }
    }

    @Composable
    private fun ArticleLayout(article: Article) {
        Column(modifier = RemoteModifier.fillMaxSize().padding(16.dp)) {
            // Breaking news banner - can be added/removed instantly
            if (article.isBreaking) {
                BreakingNewsBanner(
                    modifier = RemoteModifier.fillMaxWidth()
                )
            }

            // Headline with dynamic styling
            Text(
                text = article.headline,
                style = if (article.isBreaking) {
                    HeadlineStyle.Breaking
                } else {
                    HeadlineStyle.Standard
                }
            )

            // Live updates indicator
            if (article.hasLiveUpdates) {
                LiveUpdatesIndicator(
                    lastUpdate = article.lastUpdate,
                    modifier = RemoteModifier.clickable {
                        namedAction("refreshArticle", article.id)
                    }
                )
            }

            // Rich content blocks - can include any Compose UI
            article.contentBlocks.forEach { block -&gt;
                when (block) {
                    is TextBlock -&gt; ArticleText(block)
                    is ImageBlock -&gt; ArticleImage(block)
                    is VideoBlock -&gt; VideoEmbed(block)
                    is LiveBlogBlock -&gt; LiveBlogTimeline(block)
                    is InteractiveChartBlock -&gt; DataVisualization(block)
                    is PullQuoteBlock -&gt; PullQuote(block)
                }
            }

            // Related articles - layout can be A/B tested
            RelatedArticles(
                articles = article.relatedArticles,
                onArticleClick = { namedAction("openArticle", it.id) }
            )
        }
    }
}
</code></pre>

<p>å®¢æˆ·ç«¯åªéœ€æ¸²æŸ“æœåŠ¡å™¨æä¾›çš„ä»»ä½•å¸ƒå±€ï¼š</p>

<pre><code class="kotlin">// Client-side: Renders whatever layout the server sends
@Composable
fun ArticleScreen(articleId: String, viewModel: ArticleViewModel) {
    val document by viewModel.articleDocument.collectAsState()
    val refreshing by viewModel.isRefreshing.collectAsState()

    SwipeRefresh(
        state = rememberSwipeRefreshState(refreshing),
        onRefresh = { viewModel.refresh() }
    ) {
        document?.let { doc -&gt;
            RemoteDocumentPlayer(
                document = doc,
                onNamedAction = { name, value, _ -&gt;
                    when (name) {
                        "openArticle" -&gt; navController.navigate("article/$value")
                        "refreshArticle" -&gt; viewModel.refresh()
                        "playVideo" -&gt; videoPlayer.play(value)
                    }
                }
            )
        }
    }
}
</code></pre>

<p>ä½ çš„å›¢é˜Ÿæ— éœ€ä¿®æ”¹åº”ç”¨å³å¯æ›´æ–°æ–‡ç« å¸ƒå±€ï¼Œæ·»åŠ å®æ—¶åšå®¢æ—¶é—´çº¿ã€åµŒå…¥äº¤äº’å¼å›¾è¡¨å’Œæ›´æ”¹å­—ä½“ã€‚å½“æ–°é—»äº‹ä»¶æœ‰è¿›å±•æ—¶ï¼Œä»–ä»¬å¯ä»¥ç«‹å³åœ¨æ‰€æœ‰ç›¸å…³æ–‡ç« ä¸Šæ·»åŠ â€œçªå‘æ–°é—»â€æ¨ªå¹…ã€‚</p>

<h3>é¿å…ä»£ç è†¨èƒ€çš„åŠŸèƒ½æ ‡å¿—</h3>

<p>ä¼ ç»Ÿçš„åŠŸèƒ½æ ‡å¿—éœ€è¦å°†æ‰€æœ‰å˜ä½“éƒ½åŒ…å«åœ¨äºŒè¿›åˆ¶æ–‡ä»¶ä¸­ï¼š</p>

<pre><code class="kotlin">// Traditional approach - all code ships, even unused variations
@Composable
fun HomeScreen() {
    when {
        featureFlags.newHomeV3 -&gt; NewHomeLayoutV3()  // Ships always
        featureFlags.newHomeV2 -&gt; NewHomeLayoutV2()  // Ships always
        else -&gt; OldHomeLayout()

        // Ships always
    }
}
</code></pre>

<p>è¿™ä¼šå¸¦æ¥å‡ ä¸ªé—®é¢˜ã€‚äºŒè¿›åˆ¶æ–‡ä»¶ä¼šå› ä¸ºåŒ…å«æ‰€æœ‰å˜ä½“è€Œå¢åŠ åº”ç”¨ç¨‹åºçš„å¤§å°ã€‚å³ä½¿æœªä½¿ç”¨ï¼Œä¹Ÿä¼šåŒ…å«æ— ç”¨ä»£ç ã€‚å½“åŠŸèƒ½æ ‡å¿—é…ç½®é”™è¯¯æ—¶ï¼Œå¯èƒ½ä¼šæš´éœ²æœªå‘å¸ƒçš„åŠŸèƒ½ï¼Œä»è€Œå¸¦æ¥å®‰å…¨é£é™©ã€‚éšç€æ—¶é—´çš„æ¨ç§»ï¼Œæ—§çš„å˜ä½“ä¸æ–­ç´¯ç§¯ï¼Œå¯¼è‡´æŠ€æœ¯å€ºåŠ¡ä¸æ–­å¢åŠ ã€‚</p>

<p>ä½¿ç”¨ RemoteComposeï¼Œåªä¼šä¼ è¾“å½“å‰æ¿€æ´»çš„å˜ä½“ï¼š</p>

<pre><code class="kotlin">// Server-side: Only the active variation exists on the server
class HomeScreenService {
    fun getHomeDocument(user: User): ByteArray {
        return when (featureFlags.getHomeVariant(user)) {
            "v3" -&gt; captureHomeV3(user)
            "v2" -&gt; captureHomeV2(user)
            else -&gt; captureHomeDefault(user)
        }
    }
}

// Client-side: No conditional code, no dead code
@Composable
fun HomeScreen(document: CoreDocument) {
    RemoteDocumentPlayer(document = document)
    // That's it. No feature flags, no conditionals.
}
</code></pre>

<p>è¿™æ¶ˆé™¤äº†äºŒè¿›åˆ¶æ–‡ä»¶è†¨èƒ€ï¼Œå› ä¸ºä¸ä¼šä¼ è¾“æ—§çš„å˜ä½“ï¼›ç”±äºåªå­˜åœ¨æœåŠ¡å™¨ç«¯ä»£ç ï¼Œå› æ­¤æ¶ˆé™¤äº†æ— ç”¨ä»£ç ï¼›å¹¶ä¸”ç”±äºé…ç½®é”™è¯¯åªä¼šæ˜¾ç¤ºä¸åŒçš„ UI è€Œä¸æ˜¯æœªå‘å¸ƒçš„ä»£ç ï¼Œå› æ­¤é™ä½äº†å®‰å…¨é£é™©ã€‚</p>

<p>è®¾æƒ³ä¸€ä¸ªç¤¾äº¤åª’ä½“åº”ç”¨æ­£åœ¨é€æ­¥é‡æ–°è®¾è®¡å…¶ä¿¡æ¯æµï¼š</p>

<pre><code class="kotlin">// Server-side: Complete control over who sees what
class FeedLayoutService {

    fun getFeedDocument(user: User, posts: List&lt;Post&gt;): ByteArray {
        val variant = rolloutService.getFeedVariant(user)

        return captureRemoteDocument(context, displayInfo, profile) {
            when (variant) {
                FeedVariant.NEW_DESIGN -&gt; NewFeedLayout(posts)
                FeedVariant.NEW_DESIGN_COMPACT -&gt; NewFeedCompactLayout(posts)
                FeedVariant.CLASSIC -&gt; ClassicFeedLayout(posts)
            }
        }
    }
}

// Rollout service controls the percentage
class RolloutService {
    fun getFeedVariant(user: User): FeedVariant {
        // 5% get new design, 5% get compact variant, 90% get classic
        return when {
            user.id.hashCode() % 100 &lt; 5 -&gt; FeedVariant.NEW_DESIGN
            user.id.hashCode() % 100 &lt; 10 -&gt; FeedVariant.NEW_DESIGN_COMPACT
            else -&gt; FeedVariant.CLASSIC
        }
    }

    // Instant rollback if issues are detected
    fun emergencyRollback() {
        // All users immediately get classic layout
        // No app update needed
    }
}
</code></pre>

<p>å¦‚æœæ–°è®¾è®¡å¯¼è‡´é—®é¢˜ï¼ˆä¾‹å¦‚å´©æºƒã€ç”¨æˆ·äº’åŠ¨åº¦ä¸‹é™æˆ–ç”¨æˆ·æŠ•è¯‰ï¼‰ï¼Œå¯ä»¥ç«‹å³å›æ»šã€‚åªéœ€æ›´æ”¹æœåŠ¡å™¨é…ç½®å³å¯ã€‚æ— éœ€ç´§æ€¥å‘å¸ƒåº”ç”¨ã€‚</p>

<h3>è·¨å¹³å°ä¸€è‡´æ€§</h3>

<p>RemoteCompose çš„æ–‡æ¡£æ ¼å¼ä¸å¹³å°æ— å…³ã€‚åŒä¸€æ–‡æ¡£å¯ä»¥åœ¨æ‰‹æœºã€å¹³æ¿ç”µè„‘ã€æŠ˜å å±è®¾å¤‡å’Œ Wear OS è®¾å¤‡ä¸Šæ¸²æŸ“ï¼Œå¹¶ç”±ç›¸åº”çš„å¹³å°æ’­æ”¾å™¨è´Ÿè´£æ¸²æŸ“ã€‚</p>

<pre><code class="bash">Creation (Server/Backend)  
    â†“  
RemoteComposeBuffer (Platform-independent binary format)  
    â†“  
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  
â”‚

â”‚
â†“

â†“

â†“

â†“
Android Phone

Android Tablet

Foldable Device

Wear OS
(Compose Player) (Compose Player)  (Compose Player)   (Wear Player)
</code></pre>

<p>å‡è®¾ä¸€æ¬¾å¥èº«åº”ç”¨åœ¨æ‰‹æœºå’Œæ‰‹è¡¨åº”ç”¨ä¸Šéƒ½æ˜¾ç¤ºé”»ç‚¼æ€»ç»“ã€‚ç›¸åŒçš„æ•°æ®ä¼šé’ˆå¯¹ä¸åŒçš„è®¾å¤‡å°ºå¯¸è¿›è¡Œä¼˜åŒ–ï¼Œå‘ˆç°ä¸åŒçš„å†…å®¹ï¼š</p>

<pre><code class="kotlin">// Server-side: Same data, different presentations
class WorkoutSummaryService {

    fun getPhoneDocument(workout: Workout): ByteArray {
        return captureRemoteDocument(context, phoneDisplayInfo, profile) {
            PhoneWorkoutSummary(workout)  // Full detailed view
        }
    }

    fun getWatchDocument(workout: Workout): ByteArray {
        return captureRemoteDocument(context, watchDisplayInfo, profile) {
            WatchWorkoutSummary(workout)  // Glanceable summary
        }
    }

    @Composable
    private fun PhoneWorkoutSummary(workout: Workout) {
        Column {
            WorkoutHeader(workout)
            HeartRateChart(workout.heartRateData)
            PaceChart(workout.paceData)
            SplitsTable(workout.splits)
            MapView(workout.route)
            ShareButton { namedAction("share", workout.id) }
        }
    }

    @Composable
    private fun WatchWorkoutSummary(workout: Workout) {
        // Optimized for small screen
        Column(modifier = RemoteModifier.fillMaxSize()) {
            Text(workout.type, style = WatchTypography.Title)
            Row {
                StatBox("Duration", workout.duration)
                StatBox("Distance", workout.distance)
            }
            MiniHeartRateIndicator(workout.avgHeartRate)
        }
    }
}
</code></pre>

<p>ä¸¤æ¬¾è®¾å¤‡éƒ½æ˜¾ç¤ºé”»ç‚¼æ•°æ®ï¼Œä½†å¸ƒå±€é’ˆå¯¹å„è‡ªçš„è®¾å¤‡å°ºå¯¸è¿›è¡Œäº†ä¼˜åŒ–ã€‚ä»»ä¸€å¸ƒå±€çš„æ›´æ–°éƒ½ä¼šç«‹å³ç”Ÿæ•ˆï¼Œæ— éœ€åœ¨ä»»ä¸€å¹³å°ä¸Šæ›´æ–°åº”ç”¨ã€‚</p>

<h3>ç¼©çŸ­å‘å¸ƒå‘¨æœŸ</h3>

<p>æœ€æ˜¾è‘—çš„ä¼˜åŠ¿åœ¨äºè¿è¥å±‚é¢ï¼šUI æ›´æ”¹ä¸å†éœ€è¦å‘å¸ƒåº”ç”¨ã€‚è€ƒè™‘ä¸€ä¸‹ç®€å• UI è°ƒæ•´çš„å¼€å‘å‘¨æœŸã€‚</p>

<p>ä¼ ç»Ÿæ–¹æ³•å¤§çº¦éœ€è¦ä¸¤åˆ°å››å‘¨ã€‚ç¬¬ä¸€å¤©å’Œç¬¬äºŒå¤©æ˜¯å¼€å‘äººå‘˜å®ç°ã€‚ç¬¬ä¸‰å¤©å’Œç¬¬å››å¤©ç”¨äºä»£ç å®¡æŸ¥å’Œä¿®æ”¹ã€‚ç¬¬äº”å¤©åˆ°ç¬¬ä¸ƒå¤©ç”¨äºè´¨é‡ä¿è¯æµ‹è¯•ã€‚ç¬¬å…«å¤©å’Œç¬¬ä¹å¤©å¤„ç†å‘å¸ƒå‡†å¤‡å’Œåº”ç”¨å•†åº—æäº¤ã€‚ç¬¬åå¤©åˆ°ç¬¬åå››å¤©ï¼šç­‰å¾…åº”ç”¨å•†åº—å®¡æ ¸ã€‚ç¬¬åäº”å¤©åˆ°ç¬¬ä¸‰åå¤©ç”¨æˆ·é€æ­¥é‡‡ç”¨ï¼Œé€šå¸¸ä¸¤å‘¨å†…ä¼šæœ‰ 50% åˆ° 70% çš„ç”¨æˆ·æ›´æ–°ã€‚å¤§å¤šæ•°ç”¨æˆ·åœ¨ä¸¤åˆ°å››å‘¨å†…ä¸ä¼šçœ‹åˆ°å˜åŒ–ã€‚</p>

<p>RemoteCompose æ–¹æ³•åªéœ€ä¸€åˆ°ä¸¤å¤©å³å¯å®Œæˆã€‚ç¬¬ä¸€å¤©å’Œç¬¬äºŒå¤©æ˜¯å¼€å‘äººå‘˜åœ¨æœåŠ¡å™¨ç«¯å®ç°ã€‚éƒ¨ç½²åªéœ€å‡ åˆ†é’Ÿã€‚æ‰€æœ‰ç”¨æˆ·éƒ½èƒ½ç«‹å³çœ‹åˆ°å˜åŒ–ã€‚</p>

<p>è¿™ç§é€Ÿåº¦ä¼˜åŠ¿å¯¹äºèŠ‚å‡æ—¥ä¿ƒé”€æ´»åŠ¨è‡³å…³é‡è¦ï¼Œä½ å¯ä»¥æ ¹æ®éœ€è¦åœ¨å½“å¤©éƒ¨ç½²å­£èŠ‚æ€§ä¸»é¢˜ï¼›å¯¹äºæœåŠ¡ä¸­æ–­çš„ç´§æ€¥æ¶ˆæ¯ï¼Œä½ å¯ä»¥å³æ—¶æ›´æ–° UIï¼›å¯¹äºå¿«é€Ÿè¿­ä»£ï¼Œä½ å¯ä»¥å¿«é€Ÿæµ‹è¯•æƒ³æ³•å¹¶å¿«é€Ÿå¤±è´¥ï¼›å¯¹äºç«äº‰å“åº”ï¼Œä½ å¯ä»¥ä»¥å°æ—¶è€Œä¸æ˜¯å‡ å‘¨çš„æ—¶é—´å¯¹å¸‚åœºå˜åŒ–åšå‡ºååº”ã€‚</p>

<p>ä»¥ä¸€ä¸ªå‡†å¤‡è¿æ¥é»‘è‰²æ˜ŸæœŸäº”çš„ç”µå•†åº”ç”¨ä¸ºä¾‹ï¼š</p>

<pre><code class="kotlin">// Traditional approach: Ship all variations weeks in advance
// Problem: All promotional code ships weeks early
// Risk: Date logic bugs could show promotions early
@Composable
fun HomeScreen() {
    val today = LocalDate.now()
    when {
        today == BlackFriday -&gt; BlackFridayHome()

        // Must ship by Oct 15
        today in BlackFridayWeek -&gt; BlackFridayWeekHome()   // Must ship by Oct 15
        today == CyberMonday -&gt; CyberMondayHome()

        // Must ship by Oct 15
        else -&gt; RegularHome()
    }
}

// Remote approach: Deploy each promotion on the exact day
// Benefit: Each promotion deploys on the exact minute needed
// Flexibility: Can react to competitor moves in real-time
class HomeScreenService {
    fun getHomeDocument(user: User): ByteArray {
        val promotion = promotionService.getCurrentPromotion()

        return captureRemoteDocument(context, displayInfo, profile) {
            when (promotion) {
                is BlackFridayPromotion -&gt; BlackFridayHome(promotion)
                is CyberMondayPromotion -&gt; CyberMondayHome(promotion)
                is FlashSale -&gt; FlashSaleHome(promotion)  // Can add new types anytime
                else -&gt; RegularHome()
            }
        }
    }
}
</code></pre>

<h3>çŠ¶æ€ç®¡ç†ï¼šè¶…è¶Šé™æ€å¸ƒå±€</h3>

<p>RemoteCompose ä¸ä»…é™äºé™æ€å¸ƒå±€ã€‚è¯¥æ¡†æ¶åŒ…å«ä¸€ä¸ªçŠ¶æ€ç®¡ç†ç³»ç»Ÿï¼Œå¯ä»¥å®ç°äº¤äº’å¼ã€åŠ¨æ€çš„ UIã€‚</p>

<p><strong>è¿œç¨‹çŠ¶æ€å˜é‡</strong></p>

<p>çŠ¶æ€å¯ä»¥åµŒå…¥æ–‡æ¡£ä¸­ï¼Œå¹¶ç”±å®¢æˆ·ç«¯æ›´æ–°ã€‚è¿™ä½¿å¾—è¡¨å•ã€è®¡æ•°å™¨ã€åˆ‡æ¢å¼€å…³å’Œå…¶ä»–äº¤äº’å…ƒç´ æˆä¸ºå¯èƒ½ï¼š</p>

<pre><code class="kotlin">// Creation side: Define interactive widget
@Composable
fun QuantitySelector(initialQuantity: Int) {
    var quantity by rememberRemoteState("quantity", initialQuantity)

    Row(
        modifier = RemoteModifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceBetween
    ) {
        IconButton(
            onClick = {
                if (quantity &gt; 1) {
                    quantity--
                    namedAction("quantityChanged", quantity.toString())
                }
            }
        ) {
            Icon(Icons.Minus)
        }

        Text(
            text = quantity.toString(),
            style = MaterialTheme.typography.headlineMedium
        )

        IconButton(
            onClick = {
                quantity++
                namedAction("quantityChanged", quantity.toString())
            }
        ) {
            Icon(Icons.Plus)
        }
    }
}
</code></pre>

<p>æ’­æ”¾å™¨ç«¯é€šè¿‡æ“ä½œå›è°ƒå¤„ç†çŠ¶æ€æ›´æ–°ï¼š</p>

<pre><code class="kotlin">// Player side: Handle state updates
RemoteDocumentPlayer(
    document = document,
    onNamedAction = { name, value, stateUpdater -&gt;
        when (name) {
            "quantityChanged" -&gt; {
                // Update cart
                cartManager.setQuantity(itemId, value.toInt())

                // Optionally update remote state directly
                stateUpdater.updateState { state -&gt;
                    state["quantity"] = RcInt(value.toInt())
                }
            }
        }
    }
)
</code></pre>

<p><strong>åŠ¨ç”»æ—¶é—´è·Ÿè¸ª</strong></p>

<p>æ’­æ”¾å™¨è·Ÿè¸ªåŠ¨ç”»æ—¶é—´å¹¶å°†å…¶ä¼ é€’ç»™æ–‡æ¡£ï¼Œä»è€Œæ— éœ€ä»»ä½•å®¢æˆ·ç«¯åŠ¨ç”»ä»£ç å³å¯å®ç°åŸºäºæ—¶é—´çš„åŠ¨ç”»ï¼š</p>

<pre><code class="kotlin">// Server side: Define animated elements
@Composable
fun PulsingNotificationBadge(count: Int) {
    // Scale pulses between 0.9 and 1.1 over 1 second
    val scale = FloatExpression("0.9 + 0.2 * sin(time * 6.28)")

    // Opacity pulses between 0.7 and 1.0
    val opacity = FloatExpression("0.7 + 0.3 * sin(time * 6.28)")

    Box(
        modifier = RemoteModifier
            .scale(scale)
            .alpha(opacity)
            .background(Color.Red, CircleShape)
            .size(24.dp)
    ) {
        Text(
            text = count.toString(),
            color = Color.White,
            modifier = RemoteModifier.align(Alignment.Center)
        )
    }
}

// The player automatically:
// 1. Tracks elapsed time since document load
// 2. Evaluates expressions each frame
// 3. Updates visual properties
// No client animation code needed
</code></pre>

<p>è¿™ä½¿å¾—å®Œå…¨åœ¨æ–‡æ¡£æ ¼å¼ä¸­å®šä¹‰çš„æµç•…ã€é«˜æ€§èƒ½åŠ¨ç”»æˆä¸ºå¯èƒ½ã€‚è¡¨è¾¾å¼æ”¯æŒè¯¸å¦‚ <code>sin</code>ã€<code>cos</code>ã€<code>lerp</code> å’Œ <code>clamp</code> ä¹‹ç±»çš„æ•°å­¦å‡½æ•°ï¼Œä»¥åŠç®—æœ¯è¿ç®—ç¬¦å’Œå˜é‡å¼•ç”¨ã€‚</p>

<p><strong>åŒå‘é€šä¿¡</strong></p>

<p>æ“ä½œç³»ç»Ÿæ”¯æŒæ–‡æ¡£ä¸å®¿ä¸»åº”ç”¨ä¹‹é—´çš„åŒå‘é€šä¿¡ï¼š</p>

<pre><code class="kotlin">// Document triggers actions for various purposes
@Composable
fun ProductDetailPage(product: Product) {
    Column {
        // Analytics tracking
        LaunchedEffect(Unit) {
            namedAction("analytics", "product_viewed:${product.id}")
        }

        ProductImage(product.imageUrl)

        // Navigation action
        TextButton(onClick = { namedAction("navigate", "/reviews/${product.id}") }) {
            Text("See all reviews")
        }

        // Cart action with data
        Button(onClick = { namedAction("addToCart", product.id) }) {
            Text("Add to Cart")
        }

        // State update action
        var isFavorite by rememberRemoteState("favorite", product.isFavorite)
        IconButton(
            onClick = {
                isFavorite = !isFavorite
                namedAction("toggleFavorite", "${product.id}:$isFavorite")
            }
        ) {
            Icon(if (isFavorite) Icons.Filled.Favorite else Icons.Outlined.Favorite)
        }
    }
}
</code></pre>

<p>å®¿ä¸»åº”ç”¨ç»Ÿä¸€å¤„ç†æ‰€æœ‰æ“ä½œï¼š</p>

<pre><code class="kotlin">// Host app handles all actions uniformly
RemoteDocumentPlayer(
    document = document,
    onNamedAction = { name, value, stateUpdater -&gt;
        when (name) {
            "analytics" -&gt; {
                val (event, id) = value.split(":")
                analytics.logEvent(event, mapOf("productId" to id))
            }
            "navigate" -&gt; navController.navigate(value)
            "addToCart" -&gt; {
                cartManager.add(value)
                // Update UI to show confirmation
                stateUpdater.updateState { state -&gt;
                    state["cartCount"] = RcInt((state["cartCount"] as? RcInt)?.value?.plus(1) ?: 1)
                }
            }
            "toggleFavorite" -&gt; {
                val (id, isFavorite) = value.split(":")
                favoritesManager.setFavorite(id, isFavorite.toBoolean())
            }
        }
    }
)
</code></pre>

<p>è¿™ç§åŒå‘é€šä¿¡æ„å‘³ç€è¿œç¨‹æ–‡æ¡£å¯ä»¥å®Œå…¨é›†æˆåˆ°ä½ åº”ç”¨çš„å¯¼èˆªã€åˆ†æã€çŠ¶æ€ç®¡ç†å’Œä¸šåŠ¡é€»è¾‘ä¸­ï¼Œè€Œæ–‡æ¡£æœ¬èº«æ— éœ€äº†è§£ä½ çš„å…·ä½“å®ç°ã€‚</p>

<h3><strong>å®é™…åº”ç”¨æ¶æ„æ¨¡å¼</strong></h3>

<p>è®©æˆ‘ä»¬æ¥æ¢è®¨ä¸€ä¸‹ RemoteCompose å¦‚ä½•èå…¥å®é™…åº”ç”¨æ¶æ„ã€‚</p>

<p><strong>æ¨¡å¼ 1ï¼šæ··åˆæ¶æ„ï¼ˆæ¨èï¼‰</strong></p>

<p>å¤§å¤šæ•°åº”ç”¨éƒ½èƒ½ä»æ··åˆæ¶æ„ä¸­è·ç›Šï¼šå…³é”®é¡µé¢ä½¿ç”¨æœ¬åœ° Compose ä»£ç æ„å»ºï¼Œè€ŒåŠ¨æ€å†…å®¹åŒºåŸŸåˆ™ä½¿ç”¨ RemoteComposeã€‚</p>

<pre><code class="kotlin">// Navigation: Local Compose (fast, reliable)
@Composable
fun AppNavigation() {
    NavHost(navController, startDestination = "home") {
        composable("home") { HomeScreen() }
        composable("product/{id}") { ProductScreen(it.arguments?.getString("id")) }
        composable("cart") { CartScreen() }
        composable("checkout") { CheckoutScreen() }
    }
}

// Home screen: Remote (marketing can update freely)
@Composable
fun HomeScreen(viewModel: HomeViewModel = hiltViewModel()) {
    val document by viewModel.homeDocument.collectAsState()

    when (val state = document) {
        is Loading -&gt; LoadingIndicator()
        is Success -&gt; RemoteDocumentPlayer(
            document = state.document,
            onNamedAction = { name, value, _ -&gt; handleAction(name, value) }
        )
        is Error -&gt; LocalFallbackHome()  // Graceful degradation
    }
}

// Product screen: Hybrid (shell is local, content is remote)
@Composable
fun ProductScreen(productId: String, viewModel: ProductViewModel = hiltViewModel()) {
    val product by viewModel.product.collectAsState()
    val contentDocument by viewModel.contentDocument.collectAsState()

    Scaffold(
        topBar = { ProductTopBar(product) },  // Local: consistent navigation
        bottomBar = { AddToCartBar(product) } // Local: critical purchase flow
    ) { padding -&gt;
        // Remote: Rich product content, can be A/B tested
        contentDocument?.let { doc -&gt;
            RemoteDocumentPlayer(
                document = doc,
                modifier = Modifier.padding(padding)
            )
        }
    }
}
</code></pre>

<p><strong>æ¨¡å¼ 2ï¼šæ–‡æ¡£ç¼“å­˜ä»¥å®ç°ç¦»çº¿æ”¯æŒ</strong></p>

<p>è¿œç¨‹æ–‡æ¡£å¯ä»¥ç¼“å­˜ä»¥ä¾›ç¦»çº¿è®¿é—®ï¼š</p>

<pre><code class="kotlin">class DocumentRepository @Inject constructor(
    private val api: DocumentApi,
    private val cache: DocumentCache,
    private val connectivity: ConnectivityManager
) {
    suspend fun getDocument(key: String): CoreDocument {
        // Try cache first
        cache.get(key)?.let { cached -&gt;
            // Return cached immediately, refresh in background
            refreshInBackground(key)
            return cached
        }

        // No cache, must fetch
        return if (connectivity.isConnected) {
            fetchAndCache(key)
        } else {
            throw OfflineException("No cached document and no connectivity")
        }
    }

    private suspend fun fetchAndCache(key: String): CoreDocument {
        val bytes = api.fetchDocument(key)
        val document = RemoteComposeBuffer.deserialize(bytes)
        cache.store(key, document, ttl = 1.hours)
        return document
    }

    private fun refreshInBackground(key: String) {
        scope.launch {
            try {
                fetchAndCache(key)
            } catch (e: Exception) {
                // Silent failure, cached version is still valid
                Log.w(TAG, "Background refresh failed", e)
            }
        }
    }
}
</code></pre>

<p><strong>æ¨¡å¼ 3ï¼šæ–‡æ¡£é¢„åŠ è½½ä»¥å®ç°æµç•…å¯¼èˆª</strong></p>

<p>é¢„åŠ è½½ç”¨æˆ·å¯èƒ½è®¿é—®çš„é¡µé¢çš„æ–‡æ¡£ï¼š</p>

<pre><code class="kotlin">class DocumentPreloader @Inject constructor(
    private val repository: DocumentRepository
) {
    // Preload when user enters a screen
    fun preloadForScreen(screen: Screen) {
        val keysToPreload = when (screen) {
            is HomeScreen -&gt; listOf("featured", "categories", "promotions")
            is CategoryScreen -&gt; screen.subcategories.map { "category_${it.id}" }
            is ProductScreen -&gt; listOf("reviews_${screen.productId}", "related_${screen.productId}")
            else -&gt; emptyList()
        }

        keysToPreload.forEach { key -&gt;
            scope.launch {
                try {
                    repository.getDocument(key)  // Caches for later
                } catch (e: Exception) {
                    // Preload failure is not critical
                }
            }
        }
    }
}

// Usage in navigation
navController.addOnDestinationChangedListener { _, destination, arguments -&gt;
    preloader.preloadForScreen(destination.toScreen(arguments))
}
</code></pre>

<h3><strong>ç»“è®º</strong></h3>

<p>RemoteCompose ä»£è¡¨äº†æˆ‘ä»¬å¯¹ Android UI å¼€å‘æ€ç»´æ–¹å¼çš„ä¸€æ¬¡èŒƒå¼è½¬å˜ã€‚é€šè¿‡å°† Compose å¸ƒå±€è½¬æ¢ä¸ºå¯ç§»æ¤æ–‡æ¡£æ ¼å¼ï¼ŒRemoteCompose å®ç°äº†æœåŠ¡å™¨é©±åŠ¨çš„ UIã€å³æ—¶ A/B æµ‹è¯•ã€å®æ—¶å†…å®¹æ›´æ–°å’Œè·¨å¹³å°ä¸€è‡´æ€§ï¼ŒåŒæ—¶ä¿æŒäº†åŸç”Ÿæ¸²æŸ“æ€§èƒ½ã€‚</p>

<p>è¯¥æ¡†æ¶æ‹¥æœ‰åŒ…å« 93 ç§ä»¥ä¸Šæ“ä½œçš„å…¨é¢æ“ä½œæ¨¡å‹ï¼Œå……åˆ†å±•ç°äº† Compose çš„è¡¨è¾¾èƒ½åŠ›ï¼ŒåŒ…æ‹¬åŠ¨ç”»ã€çŠ¶æ€å’Œäº¤äº’ã€‚åˆ›å»ºå’Œæ’­æ”¾çš„åˆ†ç¦»ä½¿å¾—éƒ¨ç½²æ¶æ„æ›´åŠ çµæ´»ï¼šåœ¨åç«¯ç”Ÿæˆå…·æœ‰å®Œæ•´ Compose è¡¨è¾¾èƒ½åŠ›çš„æ–‡æ¡£ï¼Œé€šè¿‡ç°æœ‰åŸºç¡€æ¶æ„åˆ†å‘ï¼Œå¹¶åœ¨ä»»ä½• Android è®¾å¤‡ä¸Šè¿›è¡ŒåŸç”Ÿæ¸²æŸ“ã€‚</p>

<p>å…³é”®åœ¨äºæ‰¾åˆ°åˆé€‚çš„å¹³è¡¡ç‚¹ï¼šå¯¹äºåŠ¨æ€ã€é¢‘ç¹å˜åŒ–çš„å†…å®¹åŒºåŸŸï¼Œä½¿ç”¨ RemoteComposeï¼›åŒæ—¶å°†å…³é”®æµç¨‹ä¿ç•™åœ¨æœ¬åœ° Compose ä»£ç ä¸­ã€‚è¿™ç§æ··åˆæ–¹æ³•åœ¨éœ€è¦çµæ´»æ€§çš„åœ°æ–¹æä¾›æœåŠ¡å™¨é©±åŠ¨ UI çš„ä¼˜åŠ¿ï¼Œåœ¨éœ€è¦å¯é æ€§çš„åœ°æ–¹æä¾›ç¼–è¯‘ä»£ç çš„ä¼˜åŠ¿ã€‚</p>

<p>æ— è®ºä½ æ˜¯æ„å»ºéœ€è¦é¢‘ç¹æ›´æ–°å¸ƒå±€çš„å†…å®¹å¯†é›†å‹åº”ç”¨ã€éœ€è¦å¿«é€Ÿ A/B æµ‹è¯•çš„ç”µå­å•†åŠ¡å¹³å°ï¼Œè¿˜æ˜¯éœ€è¦å¿«é€Ÿè¿­ä»£çš„ä¼ä¸šçº§å·¥å…·ï¼ŒRemoteCompose éƒ½èƒ½ä¸ºçœŸæ­£åŠ¨æ€çš„ UI æä¾›æ¶æ„åŸºç¡€ã€‚è¯¥æ¡†æ¶å¤„ç†äº†åºåˆ—åŒ–ã€ä¼ è¾“å’Œæ¸²æŸ“çš„å¤æ‚æ€§ï¼Œå› æ­¤ä½ å¯ä»¥ä¸“æ³¨äºè®¾è®¡å“è¶Šçš„ç”¨æˆ·ä½“éªŒã€‚</p>

<p>ä½ å¯ä»¥è§‚çœ‹ä»–ä»¬æœ€è¿‘å…³äº<a href="https://speakerdeck.com/camaelon/introducing-remotecompose-break-your-ui-out-of-the-app-sandbox">RemoteCompose ç®€ä»‹ï¼šå°†ä½ çš„ UI ä»åº”ç”¨ç¨‹åºæ²™ç›’ä¸­è§£æ”¾å‡ºæ¥</a>çš„æ¼”è®²ã€‚</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jetpack Composeä¸­çš„é˜´å½±è‰ºæœ¯]]></title>
    <link href="https://alexhilton.github.io/blog/2025/11/24/the-art-of-shadows-in-jetpack-compose/"/>
    <updated>2025-11-24T00:00:00+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/11/24/the-art-of-shadows-in-jetpack-compose</id>
    <content type="html"><![CDATA[<blockquote><p>æœ¬æ–‡è¯‘è‡ªã€ŒThe Art of Shadows in Jetpack Composeã€ï¼ŒåŸæ–‡é“¾æ¥<a href="https://medium.com/proandroiddev/the-art-of-shadows-in-jetpack-compose-63a75070882f">https://medium.com/proandroiddev/the-art-of-shadows-in-jetpack-compose-63a75070882f</a>ï¼Œç”±Stefano Nataliå‘å¸ƒäº2025å¹´10æœˆ4æ—¥ã€‚</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/1*UjyqMyVg002OIDJ1Hdee8Q.png" title="auto auto" ></a></p>

<!-- more -->


<p>UI ä¸­çš„é˜´å½±å‘æŒ¥ç€è‡³å…³é‡è¦çš„ä½œç”¨ï¼šå®ƒä»¬åœ¨è§†è§‰ä¸Š<strong>æå‡</strong>å…ƒç´ ï¼ŒæŒ‡ç¤ºç€<strong>äº¤äº’æ€§</strong>ï¼Œå¹¶æä¾›ç”¨æˆ·æ“ä½œçš„å³æ—¶<strong>åé¦ˆ</strong>ã€‚å¤šå¹´æ¥ï¼Œæˆ‘ä»¬ä¸€ç›´ä¾èµ–äº<strong>é«˜åº¦</strong>å±æ€§ï¼Œä½† Jetpack Compose ç°åœ¨æä¾›äº†ä¸€å¥—å¼ºå¤§çš„å·¥å…·ï¼Œå¯ä»¥å¯¹<strong>é˜´å½±æ¸²æŸ“</strong>è¿›è¡Œç²¾ç»†æ§åˆ¶ã€‚</p>

<p>Google æœ€è¿‘æ–°å¢äº†ä¸€ä¸ª<a href="https://developer.android.com/develop/ui/compose/graphics/draw/shadows">æ–‡æ¡£é¡µé¢</a>ï¼Œå…¶ä¸­åŒ…å«ä¸€ç³»åˆ—æœ‰è¶£çš„ç”¨ä¾‹ã€‚æœ¬æ–‡å°†æ¢ç´¢ Compose ä¸­çš„ä¸»è¦é˜´å½±ä¿®æ”¹å™¨ï¼Œå¹¶æ·±å…¥è®²è§£åˆ›å»ºæ¸å˜å’Œç‚«é…·ç‰¹æ•ˆç­‰é«˜çº§æŠ€å·§ï¼Œä»è€Œæå‡åº”ç”¨çš„é£æ ¼ã€‚</p>

<p>æœ¬æ–‡è®¨è®ºçš„æ‰€æœ‰æŠ€å·§çš„å®Œæ•´ä»£ç ç¤ºä¾‹éƒ½å¯ä»¥åœ¨æˆ‘çš„ GitHub ä»“åº“ <a href="https://github.com/stefanoq21/ComposePlayground"><strong>Compose Playground</strong></a> ä¸­æ‰¾åˆ°ã€‚</p>

<h2>é˜´å½±ä¿®æ”¹å™¨ï¼ˆShadow Modifiersï¼‰</h2>

<p>æ·»åŠ é˜´å½±æœ€ç®€å•ä½†è‡ªå®šä¹‰ç¨‹åº¦æœ€ä½çš„æ–¹æ³•æ˜¯ä½¿ç”¨ <strong>Modifier.shadow()</strong>ã€‚ä¸ä»¥å¾€ä¸€æ ·ï¼Œå®ƒçš„è¡Œä¸ºä¾èµ–äº<strong>åŸºäºé«˜åº¦çš„é˜´å½±</strong>ï¼Œæ¨¡æ‹Ÿæ¥è‡ªä¸Šæ–¹çš„å…‰æºï¼Œé˜´å½±æ·±åº¦ç›´æ¥å–å†³äºä½ æä¾›çš„é«˜åº¦å€¼ã€‚å…¶ä¸»è¦é™åˆ¶åœ¨äºé˜´å½±å§‹ç»ˆè¢«è£å‰ªåˆ°å¯åˆæˆå¯¹è±¡çš„å½¢çŠ¶å†…ï¼Œå¹¶ä¸”ä½ æ— æ³•è‡ªå®šä¹‰æ‰©å±•ã€é¢œè‰²è‰²è°ƒæˆ–åç§»ç­‰å±æ€§ã€‚</p>

<pre><code class="kotlin">Box(
    Modifier
        .size(100.dp)
        .shadow(
            elevation = 10.dp, 
            shape = RectangleShape
        )
        .background(Color.White)
)
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:704/1*7Nkm6z8Ls4FyvDqCcKToDw.png" alt="" /></p>

<p>è®©æˆ‘ä»¬ä»ä¸€äº›æ–°åŠŸèƒ½å¼€å§‹ï¼Œè¿™äº›åŠŸèƒ½èµ‹äºˆæˆ‘ä»¬æ›´å¼ºå¤§çš„åŠ›é‡ã€‚ä½¿ç”¨ <strong>dropShadow()</strong>ï¼Œæˆ‘ä»¬å¯ä»¥åœ¨å†…å®¹åé¢åˆ›å»ºè‡ªå®šä¹‰é˜´å½±ã€‚è¿™ä¸ªä¿®é¥°ç¬¦æ˜¯åˆ›å»ºå¤æ‚é˜´å½±çš„å…³é”®ï¼Œå®ƒå…è®¸å¯¹å†…å®¹åé¢çš„é˜´å½±è¿›è¡Œç²¾ç»†æ§åˆ¶ï¼Œä½¿å…ƒç´ çœ‹èµ·æ¥åƒæ˜¯è¢«æŠ¬å‡äº†ä¸€æ ·ã€‚</p>

<pre><code class="kotlin"> .dropShadow(
    shape = RoundedCornerShape(20.dp), shadow = Shadow(
            radius = 6.dp,
            spread = 2.dp,
            color = Color.Black.copy(alpha = 0.3f),
            offset = DpOffset(2.dp, 2.dp)
              )
            )
 .background(
    color = Color.White, shape = RoundedCornerShape(20.dp)
            )
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:990/1*kENF6x3L985dO65DSY0Zng.png" alt="" /></p>

<p>å®ƒä½¿ç”¨ <strong>Shadow</strong> å‚æ•°ï¼Œå¯ä»¥ç²¾ç¡®æ§åˆ¶è§†è§‰æ•ˆæœã€‚è¿™ä¸ªå‚æ•°å…è®¸ä½ ä½¿ç”¨å‡ ä¸ªå…³é”®å±æ€§æ¥å¡‘é€ é˜´å½±ã€‚ <strong>åŠå¾„</strong> å†³å®šäº†è¾¹ç¼˜çš„æŸ”å’Œåº¦å’Œæ‰©æ•£ï¼ˆæ¨¡ç³Šï¼‰ç¨‹åº¦ã€‚<strong>æ‰©æ•£</strong> å€¼æ§åˆ¶é˜´å½±å‡ ä½•å½¢çŠ¶ç›¸å¯¹äºå¯ç»„åˆå…ƒç´ å¤§å°çš„æ‰©å±•æˆ–æ”¶ç¼©ã€‚æœ€åï¼Œ<strong>åç§»</strong> æ²¿ <strong>X è½´å’Œ Y è½´</strong>å®šä½é˜´å½±ï¼Œä»è€Œç¡®å®šå…‰æºçš„è§†è§‰æ–¹å‘ã€‚ç»“åˆé˜´å½±çš„<strong>é¢œè‰²</strong>ï¼Œè¿™äº›å±æ€§å¯ä»¥å®ç°å®Œå…¨è‡ªå®šä¹‰ã€‚</p>

<p>ğŸ’¡ <strong>é¡ºåºå¾ˆé‡è¦ï¼š</strong>åœ¨ä¿®æ”¹å™¨é“¾ä¸­ï¼Œ<strong>dropShadow()</strong> ä¿®æ”¹å™¨å¿…é¡»å‡ºç°åœ¨ <strong>background()</strong> ä¿®æ”¹å™¨<strong>ä¹‹å‰</strong>ï¼Œå› ä¸ºé˜´å½±å…ˆç»˜åˆ¶ï¼ŒèƒŒæ™¯ç»˜åˆ¶åœ¨å…¶ä¸Šæ–¹ã€‚</p>

<p><strong>innerShadow()</strong> ä¿®æ”¹å™¨æ˜¯ <strong>dropShadow()</strong> çš„é€†æ“ä½œï¼Œå®ƒåœ¨å¯ç»„åˆå…ƒç´ è¾¹ç•Œçš„<strong>å†…éƒ¨</strong>åˆ›å»ºé˜´å½±ï¼Œä»è€Œå®ç°å…ƒç´ å‡¹é™·æˆ–å‹å…¥è¡¨é¢çš„è§†è§‰æ•ˆæœã€‚ä¸å®ƒçš„å¯¹åº”é¡¹ä¸€æ ·ï¼Œå®ƒä¹Ÿä½¿ç”¨å¯è‡ªå®šä¹‰çš„<strong>Shadow</strong>å¯¹è±¡ï¼Œå…è®¸ä½ ä½¿ç”¨<strong>åŠå¾„</strong>ã€<strong>é¢œè‰²</strong>ã€<strong>åç§»</strong>å’Œ<strong>æ‰©æ•£</strong>æ¥å¾®è°ƒæ•ˆæœã€‚</p>

<pre><code class="kotlin">.background(
    Color.White, shape = RoundedCornerShape(20.dp)
)
.innerShadow(
    shape = RoundedCornerShape(20.dp), shadow = Shadow(
        radius = 6.dp,
        spread = 2.dp,
        color = Color.Black.copy(alpha = 0.3f),
        offset = DpOffset(2.dp, 2.dp)
    )
)
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1108/1*a7KFFaTXCk4KC-sm9AYUoQ.png" alt="" /></p>

<p>ğŸ’¡<strong>å†æ¬¡å¼ºè°ƒï¼Œé¡ºåºå¾ˆé‡è¦ï¼š</strong><strong>innerShadow()</strong>ä¿®æ”¹å™¨<strong>å¿…é¡»</strong>æ”¾åœ¨<strong>background()</strong>ä¿®æ”¹å™¨<strong>ä¹‹å</strong>ã€‚å¦‚æœå°†å…¶æ”¾åœ¨èƒŒæ™¯ä¹‹å‰ï¼Œå†…å®¹å°†ç»˜åˆ¶åœ¨é˜´å½±ä¹‹ä¸Šï¼Œå®Œå…¨é®ç›–é˜´å½±ã€‚</p>

<p>è¿™äº›ä¿®æ”¹å™¨çš„çœŸæ­£å¼ºå¤§ä¹‹å¤„åœ¨äºå®ƒä»¬çš„è‡ªå®šä¹‰å’Œç»„åˆã€‚é€šè¿‡å åŠ <strong>innerShadow()</strong>å’Œ<strong>dropShadow()</strong>ï¼Œä½ å¯ä»¥åˆ›å»ºå¤æ‚è€Œé€¼çœŸçš„è§†è§‰æ•ˆæœã€‚æˆ‘ä»¬æ¥çœ‹ä¸€äº›é«˜çº§ç”¨ä¾‹ã€‚</p>

<h2>é«˜çº§æŠ€å·§ï¼šç»„åˆå’Œè‡ªå®šä¹‰é˜´å½±</h2>

<h3>è‡ªå®šä¹‰é˜´å½±</h3>

<p>å½“ä½ åœ¨ <strong>dropShadow()</strong> å‡½æ•°ä¸­å°† <strong>Brush</strong> å¯¹è±¡è€Œéçº¯è‰²ä¼ é€’ç»™ <strong>Shadow</strong> å¯¹è±¡æ—¶ï¼Œè‡ªå®šä¹‰çš„å¼ºå¤§åŠŸèƒ½ä¾¿æ˜¾è€Œæ˜“è§ã€‚æ­¤åŠŸèƒ½å…è®¸ä½ ä½¿ç”¨ <strong>Brush.sweepGradient</strong> åˆ›å»ºæ¸å˜æ•ˆæœã€‚æ­¤å¤–ï¼Œæ— è®ºä½ ä½¿ç”¨æ ‡å‡†å½¢çŠ¶è¿˜æ˜¯å®Œå…¨è‡ªå®šä¹‰çš„å‡ ä½•ä½“ï¼Œé˜´å½±å§‹ç»ˆä¼šè´´åˆå¯ç»„åˆå¯¹è±¡çš„å½¢çŠ¶ã€‚</p>

<pre><code class="kotlin">.dropShadow(
    shape = MaterialShapes.Cookie12Sided.toShape(), shadow = Shadow(
        radius = 10.dp,
        spread = 6.dp,
        brush = Brush.sweepGradient(
            listOf(Color.Green, Color.Blue, Color.Yellow, Color.Green)
        ),
        offset = DpOffset(2.dp, 2.dp)
    )
)
.background(
    color = Color.White,
    shape = MaterialShapes.Cookie12Sided.toShape(),
)
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1122/1*a8xMvXOb3hS6icdGU0p1gg.png" alt="" /></p>

<h3>æ–°ç²—çŠ·ä¸»ä¹‰é˜´å½±</h3>

<p>è¿™ç§é£æ ¼å®Œç¾åœ°å±•ç°äº† <strong>dropShadow()</strong> ä¿®æ”¹å™¨åœ¨å®ç°æè‡´é«˜å¯¹æ¯”åº¦æ•ˆæœæ–¹é¢çš„å¼ºå¤§åŠŸèƒ½ã€‚è¦å®ç°æ–°ç²—çŠ·ä¸»ä¹‰ï¼ˆNeobrutalismï¼‰é‚£ç§ç²—çŠ·ã€æ£±è§’åˆ†æ˜çš„è§†è§‰æ•ˆæœï¼Œä½ å¿…é¡»ä½¿ç”¨ <code>dropShadow()</code> å‡½æ•°ï¼Œå¹¶è®¾ç½®æ¨¡ç³Šåº¦ä¸ºé›¶ï¼Œåç§»é‡è¦æ˜æ˜¾ï¼Œé€šå¸¸è¿˜è¦é…åˆç²—è¾¹æ¡†ã€‚å…·ä½“æ¥è¯´ï¼Œä½ éœ€è¦åŒæ—¶è®¾ç½® <code>radius = 0.dp</code> å’Œ <code>spread = 0.dp</code> æ¥æ¶ˆé™¤æ‰©æ•£ï¼Œç„¶ååº”ç”¨é²œè‰³çš„è‰²å½©ï¼Œå¹¶è®¾ç½®ä¸€ä¸ªæ˜æ˜¾çš„åç§»é‡ï¼Œä»è€Œåˆ›å»ºå‡ºæ ‡å¿—æ€§çš„é”åˆ©è½®å»“ã€‚</p>

<pre><code class="kotlin"> .dropShadow(
     shape = RoundedCornerShape(0.dp),
     shadow = Shadow(
        radius = 0.dp,
        spread = 0.dp,
        color = dropShadowColor,
        offset = DpOffset(x = 8.dp, 8.dp)
                    )
        )
 .border(
    8.dp, borderColor
        )
 .background(
    color = Color.White,
    shape = RoundedCornerShape(0.dp)
        )
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*bdPpm0XYPfTXMuoNrVQuZw.png" alt="" /></p>

<h3>å…·æœ‰åŠ¨æ•ˆçš„é˜´å½±</h3>

<p>é˜´å½±å¹¶éåªæ˜¯é™æ€çš„ï¼›å®ƒä»¬å¯ä»¥åˆ¶ä½œæˆåŠ¨ç”»ï¼Œä»è€Œæä¾›å³æ—¶çš„ç”¨æˆ·åé¦ˆã€‚æˆ‘ä»¬å°†è¦æ¢ç´¢çš„æœ€åä¸€ä¸ªé«˜çº§æŠ€å·§æ˜¯åˆ›å»ºäº¤äº’å¼é˜´å½±ï¼Œä½¿å…¶åœ¨ç‰¹å®šæ“ä½œï¼ˆä¾‹å¦‚ç‚¹å‡»æˆ–æŒ‰ä¸‹ï¼‰æ—¶å¹³æ»‘è¿‡æ¸¡ã€‚è¿™é¡¹æŠ€æœ¯å¯¹äºæ¨¡æ‹Ÿç‰©ç†äº¤äº’è‡³å…³é‡è¦ï¼Œå®ƒèƒ½ç›´è§‚åœ°ç¡®è®¤å…ƒç´ çš„æŠ¬å‡æˆ–çŠ¶æ€å‘ç”Ÿäº†å˜åŒ–ã€‚</p>

<pre><code class="kotlin"> Box(Modifier.fillMaxSize()) {
        val interactionSource = remember { MutableInteractionSource() }
        val isPressed by interactionSource.collectIsPressedAsState()

        // Create transition with pressed state
        val transition = updateTransition(
            targetState = isPressed, label = "button_press_transition"
        )

        fun &lt;T&gt; buttonPressAnimation() = tween&lt;T&gt;(
            durationMillis = 400, easing = Ease
        )

        // Animate all properties using the transition
        val shadowAlpha by transition.animateFloat(
            label = "shadow_alpha", transitionSpec = { buttonPressAnimation() }) { pressed -&gt;
            if (pressed) 0f else 1f
        }

        //to animate the color
        val colorDropShadow by transition.animateColor(
            label = "shadow_color", transitionSpec = { buttonPressAnimation() }) { pressed -&gt;
            if (pressed) Color.Transparent else Color.Green.copy(alpha = (0.5f))
        }
        val innerShadowAlpha by transition.animateFloat(
            label = "inner_shadow_alpha", transitionSpec = { buttonPressAnimation() }) { pressed -&gt;
            if (!pressed) 0f else 1f
        }

        Box(
            Modifier
                .clickable(
                    interactionSource, indication = null
                ) {
                    //...
                }
                .width(300.dp)
                .height(200.dp)
                .align(Alignment.Center)
                .dropShadow(
                    shape = RoundedCornerShape(70.dp), shadow = Shadow(
                        radius = 10.dp,
                        spread = 0.dp,
                        color = Color.Green.copy(alpha = (0.5f)),
                        offset = DpOffset(x = 0.dp, 0.dp),
                        alpha = shadowAlpha
                    )
                )
                // note that the background needs to be defined before defining the inner shadow
                .background(
                    color = Color(0xFFFFFFFF), shape = RoundedCornerShape(70.dp)
                )
                .innerShadow(
                    shape = RoundedCornerShape(70.dp), shadow = Shadow(
                        radius = 8.dp,
                        spread = 4.dp,
                        color = Color.Green.copy(alpha = (0.5f)),
                        alpha = innerShadowAlpha,
                        offset = DpOffset(x = 0.dp, 0.dp)
                    )
                )
        ) {
            //...
        }
    }
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*idzAQ4lII7JweFZdCyfNqg.gif" alt="" /></p>

<p>å¥½çš„ï¼Œæˆ‘ä»¬å·²ç»äº†è§£äº†å¦‚ä½•ä½¿ç”¨ <strong>updateTransition</strong> API æ¥åˆ›å»ºæµç•…çš„äº¤äº’åé¦ˆã€‚å®ƒé¦–å…ˆä½¿ç”¨ <strong>MutableInteractionSource</strong> è·Ÿè¸ªæŒ‰ä¸‹çŠ¶æ€ã€‚è¯¥çŠ¶æ€ä¼šé©±åŠ¨ä¸€ä¸ª <strong>400 æ¯«ç§’çš„è¿‡æ¸¡åŠ¨ç”»</strong>ï¼ŒåŒæ—¶ä¸ºä¸¤ä¸ªæ–¹å‘ç›¸åçš„é˜´å½±æ·»åŠ åŠ¨ç”»æ•ˆæœã€‚å¤–éƒ¨çš„ <strong>dropShadow</strong> åœ¨æŒ‰ä¸‹æ—¶ä¼šæ·¡å‡ºï¼Œè€Œå†…éƒ¨çš„ <strong>innerShadow</strong> åˆ™ä¼šæ·¡å…¥ã€‚è¿™ç§åŒé˜´å½±åŠ¨ç”»ä½¿ç»„ä»¶ä» <strong>æŠ¬å‡</strong> çŠ¶æ€å¹³æ»‘è¿‡æ¸¡åˆ° <strong>å‡¹é™·</strong> çŠ¶æ€ï¼Œä»è€Œåœ¨ç”¨æˆ·äº¤äº’æ—¶æä¾›æ¸…æ™°ä¸”åŠ¨æ€çš„åé¦ˆã€‚</p>

<h2>ç»“è®º</h2>

<p>Compose å…¨æ–°çš„é˜´å½± API æ ‡å¿—ç€å¯¹ä¼ ç»Ÿ <strong>elevation</strong> å±æ€§å±€é™æ€§çš„é‡å¤§çªç ´ã€‚å®ƒå°†æ ¸å¿ƒæ¦‚å¿µæ‹†åˆ†ä¸º <strong>dropShadow()</strong> å’Œ <strong>innerShadow()</strong>ï¼Œå¹¶èµ‹äºˆæˆ‘ä»¬å¯¹ <strong>Shadow</strong> å¯¹è±¡å±æ€§çš„å®Œå…¨æ§åˆ¶æƒã€‚</p>

<p>æ— è®ºä½ æ˜¯æ‰“é€ ç®€å•çš„æ¸å˜æ•ˆæœã€æ¨¡æ‹Ÿç‰©ç†æ·±åº¦ï¼Œè¿˜æ˜¯å®ç°æ–°ç²—é‡ä¸»ä¹‰çš„é«˜å¯¹æ¯”åº¦è§†è§‰å†²å‡»ï¼Œè¿™ç§å…¨æ–°çš„è‡ªå®šä¹‰ç¨‹åº¦éƒ½æ„å‘³ç€ä½ çš„ <strong>UI ç»ˆäºå¯ä»¥å……åˆ†å±•ç°ä½ è®¾è®¡çš„è‰ºæœ¯æ„¿æ™¯</strong>ã€‚</p>

<p>ä¸å¦¨å°è¯•è¿™äº›ä¿®é¥°ç¬¦ï¼Œä¸ºä½ çš„ Jetpack Compose åº”ç”¨æ³¨å…¥å…¨æ–°çš„åˆ›æ„ç»´åº¦ï¼</p>

<p>å¦‚æœä½ è§‰å¾—è¿™ç¯‡æ–‡ç« æœ‰è¶£ï¼Œæ¬¢è¿å…³æ³¨æˆ‘ï¼Œè·å–æ›´å¤šå…³äº Android å¼€å‘å’Œ Jetpack Compose çš„ç²¾å½©å†…å®¹ã€‚æˆ‘ä¼šå®šæœŸå‘å¸ƒç›¸å…³ä¸»é¢˜çš„æ–‡ç« ã€‚æ¬¢è¿éšæ—¶åˆ†äº«ä½ çš„è¯„è®ºï¼Œæˆ–é€šè¿‡ <a href="https://bsky.app/profile/stefanoq21.bsky.social"><strong>Bluesky</strong></a> æˆ– <a href="http://www.linkedin.com/in/stefano-natali-q21"><strong>LinkedIn</strong></a> ä¸æˆ‘è”ç³»ï¼Œè¿›è¡Œæ›´æ·±å…¥çš„è®¨è®ºã€‚</p>

<p>ç¥ä½ å¼€å¿ƒï¼Œç¼–ç¨‹å¿«ä¹ï¼</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[åœ¨Jetpack Composeä¸­åˆ›å»ºCRTå±å¹•æ•ˆæœ]]></title>
    <link href="https://alexhilton.github.io/blog/2025/11/12/crt-effects/"/>
    <updated>2025-11-12T13:42:48+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/11/12/crt-effects</id>
    <content type="html"><![CDATA[<blockquote><p>æœ¬æ–‡è¯‘è‡ªã€ŒCreating a CRT Screen Effect in Jetpack Composeã€ï¼ŒåŸæ–‡é“¾æ¥<a href="https://www.sinasamaki.com/creating-a-crt-screen-effect-in-jetpack-compose/">https://www.sinasamaki.com/creating-a-crt-screen-effect-in-jetpack-compose/</a>ï¼Œç”±sinasamakiå‘å¸ƒäº2025å¹´11æœˆ7æ—¥ã€‚</p></blockquote>

<p><a href=""><img src="https://www.sinasamaki.com/content/images/size/w2000/2025/11/CRT.png" title="auto auto" ></a></p>

<!-- more -->


<p>CRT æ˜¾ç¤ºå™¨å…·æœ‰ç‹¬ç‰¹è€Œæ€€æ—§çš„å¤–è§‚ï¼šæ¨¡ç³Šçš„è¾¹ç¼˜ã€æ‰«æçº¿å’Œè½»å¾®çš„è‰²å½©æº¢å‡ºã€‚è®©æˆ‘ä»¬å°è¯•ä½¿ç”¨ <code>GraphicsLayer</code> å’Œä¸€äº›å·§å¦™çš„å›¾å±‚æŠ€å·§åœ¨ Jetpack Compose ä¸­é‡ç°è¿™ç§æ•ˆæœã€‚</p>

<h2>GraphicsLayer</h2>

<p>ä¸ä¸Šä¸€ç¯‡æ–‡ç« ä¸€æ ·ï¼Œæ­¤æ•ˆæœçš„åŸºç¡€æ˜¯ <code>GraphicsLayer</code>ã€‚å®ƒå…è®¸æˆ‘ä»¬å°†å†…å®¹ç»˜åˆ¶ä¸€æ¬¡åˆ°å±å¹•å¤–ç¼“å†²åŒºã€‚ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥ä»¥æä½çš„æ€§èƒ½å¼€é”€å¤šæ¬¡ä½¿ç”¨ä¸åŒçš„æ•ˆæœé‡æ–°ç»˜åˆ¶å®ƒã€‚</p>

<pre><code class="kotlin">val graphicsLayer = rememberGraphicsLayer()

Box(Modifier.drawWithContent {
    graphicsLayer.record { 
        this@drawWithContent.drawContent() 
    }
}) {
    content()
}
</code></pre>

<p>ä¸€æ—¦æˆ‘ä»¬å°†å†…å®¹è®°å½•åˆ° <code>graphicsLayer</code> ä¸­ï¼Œå°±å¯ä»¥ä½¿ç”¨ <code>drawLayer(graphicsLayer)</code> æ ¹æ®éœ€è¦å¤šæ¬¡ç»˜åˆ¶å®ƒã€‚</p>

<p>æˆ‘å–œæ¬¢åœ¨é»‘è‰²èƒŒæ™¯ä¸Šç»˜åˆ¶è‰²å½©é²œè‰³ã€é¥±å’Œåº¦é«˜çš„å†…å®¹ï¼Œå¹¶è¿ç”¨è¿™ç§æ•ˆæœã€‚ä»¥ä¸‹æ˜¯æˆ‘ä»¬å°†åº”ç”¨æ­¤æ•ˆæœçš„åŸºç¡€å¯ç»„åˆå¯¹è±¡ã€‚</p>

<p><img src="https://www.sinasamaki.com/content/images/2025/11/Screenshot-2025-11-07-at-09.39.28.png" alt="" /></p>

<h2>æ·»åŠ æ‰«æçº¿</h2>

<p>ä¸ºäº†æ¨¡æ‹Ÿ CRT æ˜¾ç¤ºå™¨ä¸Šçš„æ°´å¹³æ‰«æçº¿ï¼Œæˆ‘ä»¬å°†ä½¿ç”¨é‡å¤æ¸å˜ã€‚è®©æˆ‘ä»¬å°†å…¶æ”¾å…¥ä¸€ä¸ªæ‰©å±•å‡½æ•°ä¸­ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š</p>

<pre><code class="kotlin">private fun DrawScope.drawScanLines(alpha: Float, blendMode: BlendMode) {
    val color = Colors.Black.copy(alpha = alpha)
    drawRect(
        brush = Brush.verticalGradient(
            0f to color,
            0.4f to color,
            0.4f to Colors.Transparent,
            1f to Colors.Transparent,
            tileMode = TileMode.Repeated,
            startY = 0f,
            endY = 10f,
        ),
        blendMode = blendMode
    )
    drawRect(
        brush = Brush.horizontalGradient(
            0f to color,
            0.1f to color,
            0.1f to Colors.Transparent,
            1f to Colors.Transparent,
            tileMode = TileMode.Repeated,
            startX = 0f,
            endX = 10f,
        ),
        blendMode = blendMode
    )
}
</code></pre>

<p>æˆ‘ä»¬æ‰‹åŠ¨å®šä¹‰é¢œè‰²åœæ­¢ç‚¹ï¼Œä»¥ä¾¿åœ¨é¢œè‰²ä¹‹é—´å½¢æˆæ¸…æ™°çš„è¾¹ç¼˜ï¼Œç„¶åå°† <code>tileMode</code> è®¾ç½®ä¸º <code>Repeated</code>ã€‚è¿™æ ·ï¼Œå†åŠ ä¸Šè¾ƒçŸ­çš„èµ·ç‚¹å’Œç»ˆç‚¹ï¼Œå°±èƒ½å¾—åˆ°è®¸å¤šé‡å¤çš„å¹³è¡Œçº¿ã€‚</p>

<p>æ‰©å±•å‡½æ•°è¿˜ä¼šæ¥æ”¶æˆ‘ä»¬æ‰€éœ€çš„é€æ˜åº¦å’Œ <code>BlendMode</code> å‚æ•°ã€‚</p>

<p>ç„¶åï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æ­¤å‡½æ•°åœ¨ <code>graphicsLayer</code> ä¸Šç»˜åˆ¶æ‰«æçº¿ã€‚</p>

<pre><code class="kotlin">.drawBehind {
    layer {
        drawLayer(graphicsLayer)
        drawScanLines(alpha = 1f, blendMode = BlendMode.DstOut)
    }
}
</code></pre>

<p>å°†æ··åˆæ¨¡å¼è®¾ç½®ä¸º <code>DstOut</code> ä¼šä»ç»˜åˆ¶çš„å†…å®¹ä¸­â€œå‡å»â€æˆ‘ä»¬çš„æ¸å˜ï¼Œä»è€Œäº§ç”Ÿè¿™ç§æ•ˆæœã€‚</p>

<p><img src="https://www.sinasamaki.com/content/images/2025/11/Screenshot-2025-11-07-at-09.39.55.png" alt="" /></p>

<h2>æ„å»ºæ¨¡ç³Šå›¾å±‚</h2>

<p>ä¸ºäº†å®ç° CRT å±å¹•å¸¸è§çš„å‘å…‰æ•ˆæœï¼Œæˆ‘ä»¬å°†å¤šæ¬¡ç»˜åˆ¶ <code>graphicsLayer</code> å›¾å±‚ï¼Œæ¯æ¬¡ç»˜åˆ¶æ—¶åˆ†åˆ«è®¾ç½®ä¸åŒçš„æ¨¡ç³ŠåŠå¾„ã€é€æ˜åº¦å’Œç¼©æ”¾æ¯”ä¾‹ã€‚</p>

<pre><code class="kotlin">val blurLayers = remember {
    listOf(
        Triple(1.dp, 0.2f, 1.02f to 1.03f),
        Triple(0.dp, .2f, 1f to 1f),
        Triple(1.dp, 0.9f, 1f to 1f),
        Triple(10.dp, 1f, 1f to 1f),
        Triple(40.dp, 1f, 1f to 1f),
    )
}
</code></pre>

<p>æˆ‘ä»¬å°†ä½¿ç”¨ä¸€ä¸ª <code>Triple</code> åˆ—è¡¨æ¥å­˜å‚¨æ¯ä¸ªå›¾å±‚çš„æ•°æ®ã€‚è¯¥åˆ—è¡¨çš„é¡ºåºä¹Ÿå®šä¹‰äº†å®ƒä»¬çš„ç»˜åˆ¶é¡ºåºã€‚æˆ‘å»ºè®®ä½ å°è¯•è°ƒæ•´è¿™äº›å€¼å’Œé¡ºåºï¼Œä»¥è·å¾—æ‰€éœ€çš„æ•ˆæœã€‚ä½†è¿™æ˜¯æˆ‘ç›®å‰ä½¿ç”¨çš„æ–¹æ³•ã€‚</p>

<pre><code class="kotlin">blurLayers.forEach { (blur, alpha, scale) -&gt;  
    Box(  
        Modifier  
            .matchParentSize()  
            .blur(blur, BlurredEdgeTreatment.Unbounded)  
            .graphicsLayer {  
                scaleX = scale.first  
                scaleY = scale.second  
                this.alpha = alpha  
            }  
            .drawBehind {  
                layer {  
                    drawLayer(graphicsLayer)  
                    drawScanLines(alpha = 1f, blendMode = BlendMode.DstOut)  
                }  
            }    
    )  
}
</code></pre>

<p>ç„¶åï¼Œæˆ‘ä»¬ä½¿ç”¨åˆ—è¡¨ä¸­çš„å€¼ç»˜åˆ¶æ¯ä¸ªå›¾å±‚ã€‚åœ¨ <code>drawBehind</code> ä¿®æ”¹å™¨ä¸Šæ–¹ï¼Œæˆ‘ä»¬å°†å›¾å±‚å¤§å°è®¾ç½®ä¸ºä¸çˆ¶å›¾å±‚åŒ¹é…ï¼Œå¹¶åº”ç”¨æ¨¡ç³Šã€ç¼©æ”¾å’Œé€æ˜åº¦ã€‚è¯·è®°ä½å°†æ¨¡ç³Šè®¾ç½®ä¸º <code>Unbounded</code>ï¼Œä½¿å…¶è¶…å‡ºåŒ…å«å®ƒçš„å¯ç»„åˆå¯¹è±¡çš„è¾¹ç•Œã€‚</p>

<p><img src="https://www.sinasamaki.com/content/images/2025/11/Screenshot-2025-11-07-at-08.33.20.png" alt="" /></p>

<h2>å±å¹•æŠ–åŠ¨</h2>

<p>æœ€åï¼Œæˆ‘ä»¬æ¥æ·»åŠ å±å¹•æŠ–åŠ¨æ•ˆæœï¼Œä»¥æ¨¡æ‹Ÿ CRT æ˜¾ç¤ºå™¨ç‰¹æœ‰çš„æŠ–åŠ¨ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡åˆ›å»ºä¸€ä¸ª <code>Offset</code> å¯¹è±¡ï¼Œå¹¶ç”¨ -1 åˆ° 1 ä¹‹é—´çš„éšæœºæµ®ç‚¹å€¼æ¥æ›´æ–°å®ƒã€‚</p>

<pre><code class="kotlin">var shake by remember { mutableStateOf(Offset.Zero) }

LaunchedEffect(Unit) {
    while (true) {
        shake = Offset(
            Random.nextInt(-1, 1) * Random.nextFloat(),
            Random.nextInt(-1, 1) * Random.nextFloat(),
        )
        delay(32)
    }
}
</code></pre>

<p>è¿™é‡Œåªéœ€åœ¨ä¸€ä¸ª while å¾ªç¯ä¸­å³å¯å®Œæˆã€‚å¯ä»¥è°ƒæ•´å»¶è¿Ÿæ—¶é—´æ¥æ§åˆ¶é—ªçƒçš„é—´éš”é¢‘ç‡ã€‚</p>

<pre><code class="kotlin">modifier = modifier  
    .graphicsLayer {  
        translationX = shake.x  
        translationY = shake.y  
    }
</code></pre>

<p>ç„¶åå¯ä»¥ä½¿ç”¨ä¿®é¥°ç¬¦æ¥åº”ç”¨æ­¤åç§»é‡ã€‚</p>

<p><img src="file:///Users/alexhilton/Downloads/crt_opt.gif" alt="" /></p>

<h2>æ•´åˆæ‰€æœ‰åŠŸèƒ½</h2>

<p>è®©æˆ‘ä»¬å°†æ‰€æœ‰è¿™äº›åŠŸèƒ½ç»„åˆæˆä¸€ä¸ªå¯è½»æ¾ä½¿ç”¨çš„ç»„åˆã€‚å®ƒä¼šæ¥æ”¶ <code>content</code> å‚æ•°ä»¥åŠ <code>flickerDelay</code> å‚æ•°ï¼Œåè€…ç”¨äºæ§åˆ¶é—ªçƒé¢‘ç‡ã€‚</p>

<pre><code class="kotlin">@Composable  
fun CRTBox(  
    modifier: Modifier = Modifier,  
    flickerDelay: Int = 32,  
    content: @Composable () -&gt; Unit,  
) {  
    var shake by remember { mutableStateOf(Offset.Zero) }  

    LaunchedEffect(Unit) {  
        while (flickerDelay &gt; 0) {  
            shake = Offset(  
                Random.nextInt(-1, 1) * Random.nextFloat(),  
                Random.nextInt(-1, 1) * Random.nextFloat(),  
            )  
            delay(flickerDelay.toLong())  
        }  
    }  

    val graphicsLayer = rememberGraphicsLayer()  

    Box(  
        modifier = modifier  
            .graphicsLayer {  
                translationX = shake.x  
                translationY = shake.y  
            }  
    ) {  
        Box(Modifier.drawWithContent {  
            graphicsLayer.record { this@drawWithContent.drawContent() }  
        }) {  
            content()  
        }  

        val blurLayers = remember {  
            listOf(  
                Triple(5.dp, .3f, 1.02f to 1.03f),  
                Triple(0.dp, .8f, 1f to 1f),  
                Triple(1.dp, .9f, 1f to 1f),  
                Triple(10.dp, .6f, 1.001f to 1f),  
                Triple(40.dp, .7f, 1f to 1f),  
            )  
        }  

        blurLayers.forEach { (blur, alpha, scale) -&gt;  
            Box(  
                Modifier  
                    .matchParentSize()  
                    .blur(blur, BlurredEdgeTreatment.Unbounded)  
                    .graphicsLayer {  
                        scaleX = scale.first  
                        scaleY = scale.second  
                        this.alpha = alpha  
                    }  
                    .drawBehind {  
                        layer {  
                            drawLayer(graphicsLayer)  
                            drawScanLines(alpha = 1f, blendMode = BlendMode.DstOut)  
                        }  
                    }            
            )  
        }  
    }}  

private fun DrawScope.layer(  
    bounds: Rect = size.toRect(),  
    block: DrawScope.() -&gt; Unit  
) =  
    drawIntoCanvas { canvas -&gt;  
        canvas.withSaveLayer(  
            bounds = bounds,  
            paint = Paint(),  
        ) { block() }  
    }  

private fun DrawScope.drawScanLines(alpha: Float, blendMode: BlendMode) {  
    val color = Colors.Black.copy(alpha = alpha)  
    drawRect(  
        brush = Brush.verticalGradient(  
            0f to color,  
            0.4f to color,  
            0.4f to Colors.Transparent,  
            1f to Colors.Transparent,  
            tileMode = TileMode.Repeated,  
            startY = 0f,  
            endY = 10f,  
        ),  
        blendMode = blendMode  
    )  
    drawRect(  
        brush = Brush.horizontalGradient(  
            0f to color,  
            0.1f to color,  
            0.1f to Colors.Transparent,  
            1f to Colors.Transparent,  
            tileMode = TileMode.Repeated,  
            startX = 0f,  
            endX = 10f,  
        ),  
        blendMode = blendMode  
    )  
}
</code></pre>

<p>ç„¶åï¼Œä½ å¯ä»¥åƒä½¿ç”¨å…¶ä»–å¯ç»„åˆç»„ä»¶ä¸€æ ·ä½¿ç”¨å®ƒï¼š</p>

<pre><code class="kotlin">CRTBox {
    Text("GAME OVER")
}
</code></pre>

<h2>Sweeper æ›´æ–°</h2>

<p>å¦‚æœä½ æƒ³æŸ¥çœ‹å®é™…æ•ˆæœï¼Œè¯·æŸ¥çœ‹æœ€æ–°çš„ Sweeper æ›´æ–°ï¼Œè¯¥æ›´æ–°ä½¿ç”¨ CRT æ•ˆæœåˆ›å»ºäº†ä¸€ä¸ªä»¤äººæ¯›éª¨æ‚šç„¶çš„ä¸‡åœ£èŠ‚ä¸»é¢˜ã€‚</p>

<p><img src="https://www.sinasamaki.com/content/images/2025/11/IMG_9612-Edited-copy.jpeg" alt="" /></p>

<p><a href="https://play.google.com/store/apps/details?id=com.sinasamaki.chroma.sweeper&amp;ref=sinasamaki.com">https://play.google.com/store/apps/details?id=com.sinasamaki.chroma.sweeper</a></p>

<p><a href="https://apps.apple.com/us/app/sweeper-by-sinasamaki/id6752220495?ref=sinasamaki.com">https://apps.apple.com/us/app/sweeper-by-sinasamaki/id6752220495</a></p>

<p>æ„Ÿè°¢é˜…è¯»ï¼Œç¥ä½ å¥½è¿ï¼</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compose CameraXç°å·²ç¨³å®šï¼šç»™Composerçš„ç«¯åˆ°ç«¯æŒ‡å—]]></title>
    <link href="https://alexhilton.github.io/blog/2025/11/02/compose-camerax-is-stable/"/>
    <updated>2025-11-02T14:10:34+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/11/02/compose-camerax-is-stable</id>
    <content type="html"><![CDATA[<blockquote><p>æœ¬æ–‡è¯‘è‡ªã€ŒCompose-Native CameraX Is Now Stable: End-to-End Guide for Jetpack Composeã€ï¼ŒåŸæ–‡é“¾æ¥<a href="https://proandroiddev.com/goodbye-androidview-camerax-goes-full-compose-4d21ca234c4e">https://proandroiddev.com/goodbye-androidview-camerax-goes-full-compose-4d21ca234c4e</a>ï¼Œç”±Ioannis Anifantakiså‘å¸ƒäº20251026ã€‚</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/1*sizZteIZmrzNr4X1BeXcJg.png" title="auto auto" ></a></p>

<!-- more -->


<h2>ç®€ä»‹</h2>

<p>è¿˜è®°å¾—ä½ åœ¨ Jetpack Compose ä¸­çš„ç¬¬ä¸€ä¸ªç›¸æœºé¡µé¢å—ï¼Ÿçº¯ç²¹çš„å£°æ˜å¼ä¹è¶£â€¦â€¦ç›´åˆ°é¢„è§ˆã€‚ç„¶åæ˜¯ç†Ÿæ‚‰çš„ <code>AndroidView(PreviewView)</code> ç»•é“ã€‚å®ƒç¡®å®æœ‰æ•ˆï¼Œä½†æ€»æ„Ÿè§‰ä¸å¯¹ï¼šcomposablesä¸­é—´æœ‰ä¸€ä¸ª View å½¢çŠ¶çš„ç©ºæ´ï¼ˆç±»ä¼¼äº <code>_iFrame_</code>_ â€¦â€¦ï¼‰ï¼Œè€Œä¸”ç‚¹å‡»å¯¹ç„¦çš„æ•°å­¦è®¡ç®—æ€»æ˜¯è®©äººæ„Ÿè§‰ä¸å¤ªå¯é ã€‚</p>

<p>åœ¨ I/O 25 ä¹‹åï¼Œè¿™ç§å¦¥åå·²ç»ç»“æŸã€‚</p>

<ul>
<li><strong>ä¸å†</strong> ä½¿ç”¨ <code>**AndroidView(PreviewView)**</code> è¿›è¡Œç›¸æœºé¢„è§ˆã€‚</li>
<li><strong>æ–°å¢</strong> <code>**CameraXViewfinder**</code> å¯ç»„åˆé¡¹ï¼Œå¯åœ¨ Compose ä¸­ç›´æ¥æ¸²æŸ“ CameraX <code>SurfaceRequest</code>ã€‚</li>
<li><strong>ä¿®æ­£äº†å†…ç½®åæ ‡å˜æ¢</strong>ï¼ˆç‚¹å‡»å¯¹ç„¦ã€å åŠ å±‚ï¼‰ï¼Œå¹¶å»ºç«‹äº†æ›´ç®€æ´ã€æ›´å…·å£°æ˜æ€§çš„å¿ƒæ™ºæ¨¡å‹ã€‚</li>
</ul>


<blockquote><p><strong><em>æ³¨æ„ï¼š</em></strong></p>

<p><em>â€œ</em>åœ¨ I/O 25 å¤§ä¼šä¸Šï¼ŒCompose æ”¯æŒå·²å‘å¸ƒ <strong>alpha/beta</strong> ç‰ˆæœ¬ï¼Œç¨³å®šç‰ˆå·²äº 9 æœˆå‘å¸ƒâ€”â€”ç°åœ¨æ˜¯æ—¶å€™äº†è§£ä¸€ä¸‹äº†ã€‚â€_</p></blockquote>

<h2>é…å¥—é¡¹ç›®</h2>

<p>ä½ å¯ä»¥åœ¨ <a href="https://github.com/ioannisa/CameraX-Composable-Demo/"><strong>GitHub ä¸Šçš„é…å¥—é¡¹ç›®</strong></a> æ‰¾åˆ°æœ¬æ–‡çš„é…å¥—é¡¹ç›®ï¼Œè¯¥é¡¹ç›®æ¼”ç¤ºäº† CameraX ä¸­ Jetpack Compose çš„æ–°åŠŸèƒ½ã€‚</p>

<h3>æƒé™ç”¨æˆ·ä½“éªŒï¼ˆç®€è¦è¯´æ˜ï¼‰</h3>

<p>æœ¬æ–‡å°†é‡ç‚¹ä»‹ç» Compose + CameraX çš„åŠŸèƒ½ã€‚<strong>é…å¥—é¡¹ç›®</strong> å®ç°äº†å®Œæ•´çš„è¿è¡Œæ—¶æµç¨‹ï¼š</p>

<ul>
<li>åœ¨é¢„è§ˆå…¥å£ç‚¹è¯·æ±‚ <code>**CAMERA**</code>ã€‚</li>
<li>ä»…åœ¨ç”¨æˆ·å¼€å§‹å½•åˆ¶æ—¶ï¼ˆæŒ‰éœ€éº¦å…‹é£ï¼‰è¯·æ±‚ <code>**RECORD_AUDIO**</code>ã€‚</li>
<li>ä¸€ä¸ªå°å‹çš„ <code>PermissionGate</code> å¯ç»„åˆå‡½æ•°è´Ÿè´£å¤„ç† Compose æ ‘ä¸­çš„æˆæƒ/æ‹’ç»/é‡æ–°è¯·æ±‚ã€‚</li>
<li>ä¸ºäº†æ»¡è¶³ Lint å¯¹ <code>@RequiresPermission</code> çš„è¦æ±‚ï¼Œè°ƒç”¨ç‚¹è¿˜ä¼šåœ¨è°ƒç”¨ä¸éº¦å…‹é£ç›¸å…³çš„ API ä¹‹å‰æ‰§è¡Œæ˜¾å¼ <code>checkSelfPermission(...)</code>ã€‚</li>
</ul>


<p>è¯·å‚é˜…ä»£ç åº“ï¼Œäº†è§£å…·ä½“çš„ <code>PermissionGate</code> ä»¥åŠæˆ‘ä»¬å¦‚ä½•å°†å…¶è¿æ¥åˆ° Capture é¡µé¢ã€‚</p>

<h2>å®é™…å˜åŒ–æ˜¯ä»€ä¹ˆï¼Ÿ</h2>

<p>CameraX å›¢é˜Ÿæ”¾å¼ƒäº† <code>androidx.camera:camera-compose</code>ï¼Œå–è€Œä»£ä¹‹çš„æ˜¯çœ‹ä¼¼ç®€å•çš„ APIï¼š<code>**CameraXViewfinder**</code>ã€‚ä½†è¿™ä¸ä»…ä»…æ˜¯â€œå°† <code>PreviewView</code> å°è£…åœ¨å¯ç»„åˆé¡¹ä¸­â€ã€‚è¿™æ˜¯å¯¹ Compose çš„å½»åº•é‡å†™ï¼Œä¹Ÿæ˜¯å¯¹ç›¸æœº Surface ä¸ Compose é›†æˆæ–¹å¼çš„æ ¹æœ¬æ€§é‡æ–°æ€è€ƒã€‚</p>

<p>ä»¥ä¸‹æ˜¯æ¶æ„å±‚é¢çš„å˜åŒ–ï¼š</p>

<p><strong>Compose ç›®æ ‡ä¼˜å…ˆ</strong>
å–æ™¯å™¨æ¸²æŸ“ç®¡é“ç°åœ¨å°† Compose è§†ä¸ºä¸»è¦å¹³å°ã€‚Surface ç”Ÿå‘½å‘¨æœŸã€æ—‹è½¬å¤„ç†å’Œç¼©æ”¾éƒ½ä»¥ Compose æƒ¯ç”¨çš„æ–¹å¼è¿›è¡Œã€‚</p>

<p><strong>å¼€ç®±å³ç”¨çš„æ­£ç¡®åæ ‡å˜æ¢</strong>
è¿˜è®°å¾—è®¡ç®—é¢„è§ˆä¸­çš„ç‚¹å‡»å®é™…æ˜ å°„åˆ°ç›¸æœºä¼ æ„Ÿå™¨çš„ä½ç½®ï¼Œå¹¶è€ƒè™‘æ—‹è½¬ã€å®½é«˜æ¯”è£å‰ªå’Œç¼©æ”¾æ¨¡å¼å—ï¼Ÿ<code>MutableCoordinateTransformer</code> å¯ä»¥å¤„ç†è¿™äº›ã€‚ç‚¹å‡»å¯¹ç„¦ç°åœ¨â€¦â€¦å¯ä»¥æ­£å¸¸å·¥ä½œäº†ã€‚</p>

<p><strong>çœŸæ­£çš„å¯ç»„åˆè¯­ä¹‰</strong>
æƒ³è¦å°†é¢„è§ˆ <code>clip()</code> è½¬æ¢ä¸ºè‡ªå®šä¹‰å½¢çŠ¶ï¼Ÿåº”ç”¨ <code>graphicsLayer</code> å˜æ¢ï¼Ÿä½¿ç”¨ <code>AnimatedContent</code> ä¸ºå…¶æ·»åŠ åŠ¨ç”»æ•ˆæœï¼Ÿç°åœ¨ï¼Œä½ å¯ä»¥è½»æ¾å®Œæˆæ‰€æœ‰è¿™äº›æ“ä½œï¼Œè€Œæ— éœ€ä¸æ¸²æŸ“å™¨å†²çªã€‚å®ƒä¸å…¶ä»–å¯ç»„åˆç»„ä»¶ä¸€æ ·ã€‚</p>

<p><strong>CameraX 1.5.x æˆç†Ÿåº¦</strong>
æ•´ä¸ªæŠ€æœ¯æ ˆéƒ½å¾—åˆ°äº†å®Œå–„ï¼šé€‚ç”¨äº Kotlin åç¨‹çš„ <code>ProcessCameraProvider.awaitInstance()</code>ã€å…¨é¢ç¨³å®šçš„æ„ä»¶ä»¥åŠæ›´å®Œå–„çš„æ–‡æ¡£ã€‚è¿™å¹¶é Beta æµ‹è¯•â€¦â€¦å®ƒå·²å‡†å¤‡å¥½æŠ•å…¥ç”Ÿäº§ã€‚</p>

<h2>ä¸ºä»€ä¹ˆè¿™çœŸçš„å¾ˆé‡è¦</h2>

<p>å¦‚æœä½ ä¸€ç›´åœ¨æ„å»ºç›¸æœºåŠŸèƒ½ï¼Œ<strong>ä½ å°±ä¼šçŸ¥é“å…¶ä¸­çš„ç—›ç‚¹</strong>ï¼š</p>

<ul>
<li><strong>å¿ƒæ™ºæ¨¡å‹åˆ†è£‚</strong>ï¼šâ€œç”¨ Compose æ€è€ƒ UIï¼Œç”¨ View æ€è€ƒç›¸æœºï¼Œå¹¶åœ¨ä¸¤è€…ä¹‹é—´ä¸æ–­è½¬æ¢ã€‚â€</li>
<li><strong>æ‰‹åŠ¿åè°ƒçš„å™©æ¢¦</strong>ï¼šåœ¨ Compose ä¸­å¤„ç†è§¦æ‘¸äº‹ä»¶ï¼Œåœ¨ View åæ ‡ç³»ä¸­æµ‹å…‰å¯¹ç„¦ï¼Œç¥ˆç¥·ä½ çš„è®¡ç®—å‡†ç¡®æ— è¯¯ã€‚</li>
<li><strong>Z è½´é¡ºåºéš¾é¢˜</strong>ï¼šâ€œPreviewViewâ€ ç»å¸¸ä½¿ç”¨åœ¨å•ç‹¬å›¾å±‚ä¸­æ¸²æŸ“çš„â€œSurfaceViewâ€ã€‚Compose å åŠ å±‚æ— æ³•å¯é åœ°ä½äºé¡¶éƒ¨ï¼Œå› æ­¤åå­—çº¿ã€å‚è€ƒçº¿å’ŒæŒ‰é’®å¯èƒ½ä¼šæ¶ˆå¤±åœ¨é¢„è§ˆå±‚åé¢ã€‚</li>
<li><strong>ç”Ÿå‘½å‘¨æœŸä¹‹èˆ</strong>ï¼šä½¿ç”¨ CameraX ç”¨ä¾‹ç»‘å®šå°† Compose é‡ç»„ä¸ View ç”Ÿå‘½å‘¨æœŸåŒæ­¥</li>
</ul>


<p>æ‰€æœ‰è¿™äº›æ‘©æ“¦ï¼Ÿéƒ½æ¶ˆå¤±äº†ã€‚</p>

<blockquote><p><strong>â€œç°åœ¨ï¼Œä½ å¯ä»¥åƒç¼–å†™å…¶ä»–ç°ä»£ Android åº”ç”¨ä¸€æ ·ç¼–å†™ç›¸æœº UIã€‚ä¸€ä¸ªèŒƒä¾‹ã€‚ä¸€ä¸ªå¿ƒæ™ºæ¨¡å‹ã€‚çº¯ç²¹çš„ Composeã€‚â€</strong></p></blockquote>

<h2>ä»£ç æ¼”ç¤º</h2>

<p>è®©æˆ‘ä»¬ä»æœ€åŸºæœ¬çš„å¼€å§‹â€”â€”ä¸€ä¸ªå¯ä»¥å·¥ä½œçš„ç›¸æœºé¢„è§ˆï¼ˆå›ºå®šçŠ¶æ€æ¨¡å¼ï¼šå°†<strong>å†™å…¥å™¨</strong> <code>MutableStateFlow</code> ä¸<strong>è¯»å–å™¨</strong> <code>collectAsState</code> åˆ†ç¦»ï¼‰ã€‚</p>

<pre><code class="kotlin">@Composable
fun CameraPreview(modifier: Modifier = Modifier) {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current

    // Writer: MutableStateFlow we can update from CameraX callbacks
    val surfaceRequests = remember { MutableStateFlow&lt;SurfaceRequest?&gt;(null) }

    // Reader: Compose state derived from the flow
    val surfaceRequest by surfaceRequests.collectAsState(initial = null)

    // Bind CameraX use cases once
    LaunchedEffect(Unit) {
        val provider = ProcessCameraProvider.awaitInstance(context)

        val preview = Preview.Builder().build().apply {
            // When CameraX needs a surface, publish it to Compose
            setSurfaceProvider { request -&gt;
                surfaceRequests.value = request
            }
        }

        provider.unbindAll()
        provider.bindToLifecycle(
            lifecycleOwner,
            CameraSelector.DEFAULT_BACK_CAMERA,
            preview
        )
    }

    // The actual Compose viewfinder
    surfaceRequest?.let { request -&gt;
        CameraXViewfinder(
            surfaceRequest = request,
            modifier = modifier.fillMaxSize()
        )
    }
}
</code></pre>

<p>å°±æ˜¯è¿™æ ·ã€‚æ²¡æœ‰ <code>AndroidView</code>ã€‚æ²¡æœ‰ <code>PreviewView</code>ã€‚åªæœ‰ä¸€ä¸ªå¯ç»„åˆç»„ä»¶ï¼Œå®ƒæ¥æ”¶ <code>SurfaceRequest</code> å¹¶è¿›è¡Œæ¸²æŸ“ã€‚</p>

<blockquote><p><strong><em>æ¨¡å¼å¾ˆç®€æ´ï¼šâ€œ</em></strong>CameraX å‘å¸ƒ Surface è¯·æ±‚ï¼ŒCompose å¤„ç†å®ƒä»¬ã€‚å•å‘ã€‚æ²¡æœ‰å›è°ƒåœ¨å„ä¸ªä¸–ç•Œä¹‹é—´æ¥å›åˆ‡æ¢ã€‚â€</p></blockquote>

<h3>å¯é€‰ï¼šä½¿ç”¨é•œå¤´åˆ‡æ¢æŒ‰é’®ï¼ˆFABï¼‰è¿›è¡Œé¢„è§ˆï¼ˆå‰/åï¼‰</h3>

<pre><code class="kotlin">@Composable
fun PreviewWithLensSwitch(modifier: Modifier = Modifier) {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current

    val surfaceRequests = remember { MutableStateFlow&lt;SurfaceRequest?&gt;(null) }
    val surfaceRequest by surfaceRequests.collectAsState(initial = null)

    // remember current lens
    var useFront by rememberSaveable { mutableStateOf(false) }
    val selector = if (useFront) CameraSelector.DEFAULT_FRONT_CAMERA else CameraSelector.DEFAULT_BACK_CAMERA

    // bind when camera selector changes (front/back camera)
    LaunchedEffect(selector) {
        val provider = ProcessCameraProvider.awaitInstance(context)
        val preview = Preview.Builder().build().apply {
            setSurfaceProvider { req -&gt; surfaceRequests.value = req }
        }
        provider.unbindAll()
        provider.bindToLifecycle(lifecycleOwner, selector, preview)
    }

    Box(Modifier.fillMaxSize()) {
        surfaceRequest?.let { req -&gt;
            CameraXViewfinder(surfaceRequest = req, modifier = Modifier.fillMaxSize())
        }
        FloatingActionButton(
            onClick = { useFront = !useFront },
            modifier = Modifier.align(Alignment.BottomEnd).padding(16.dp)
        ) { Icon(Icons.Rounded.Cameraswitch, contentDescription = "Switch camera") }
    }
}
</code></pre>

<h2>çœŸæ­£çš„è€ƒéªŒï¼šäº¤äº’å¼ç›¸æœºæ§ä»¶</h2>

<p>æ—§æ–¹æ³•çš„å¤±è´¥ä¹‹å¤„å°±åœ¨è¿™é‡Œã€‚è®©æˆ‘ä»¬å®ç°ç‚¹å‡»å¯¹ç„¦å’Œæåˆç¼©æ”¾â€¦â€¦è¿™äº›åŠŸèƒ½è¿‡å»éœ€è¦å¯¹è§†å›¾åæ ‡ç³»è¿›è¡Œä¸€äº› hackï¼ˆåŒæ ·ä½¿ç”¨å›ºå®šçš„å†™å…¥/è¯»å–æ¨¡å¼ï¼‰ï¼š</p>

<pre><code class="kotlin">@Composable
fun InteractiveCameraPreview(

modifier: Modifier = Modifier,

onFocusTap: (success: Boolean) -&gt; Unit = {}) {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current

    var camera by remember { mutableStateOf&lt;Camera?&gt;(null) }

    val surfaceRequests = remember { MutableStateFlow&lt;SurfaceRequest?&gt;(null) }
    val surfaceRequest by surfaceRequests.collectAsState(initial = null)

    // Bind camera once
    LaunchedEffect(Unit) {
        val provider = ProcessCameraProvider.awaitInstance(context)
        val preview = Preview.Builder().build().apply {
            setSurfaceProvider { req -&gt; surfaceRequests.value = req }
        }

        camera = provider.bindToLifecycle(
            lifecycleOwner,
            CameraSelector.DEFAULT_BACK_CAMERA,
            preview
        )
    }

    // Coordinate transformer: Compose UI â†’ Camera surface
    val coordinateTransformer = remember { MutableCoordinateTransformer() }

    surfaceRequest?.let { request -&gt;
        CameraXViewfinder(
            surfaceRequest = request,
            coordinateTransformer = coordinateTransformer,
            modifier = modifier
                .fillMaxSize()
                .pointerInput(camera) {
                    // Tap-to-focus
                    detectTapGestures { offset -&gt;
                        val cam = camera ?: return@detectTapGestures

                        // Transform Compose coordinates to camera surface
                        val surfacePoint = with(coordinateTransformer) {
                            offset.transform()
                        }

                        val meteringFactory = SurfaceOrientedMeteringPointFactory(
                            request.resolution.width.toFloat(),
                            request.resolution.height.toFloat()
                        )

                        val focusPoint = meteringFactory.createPoint(
                            surfacePoint.x,
                            surfacePoint.y
                        )

                        val action = FocusMeteringAction.Builder(
                            focusPoint,
                            FocusMeteringAction.FLAG_AF or FocusMeteringAction.FLAG_AE
                        ).setAutoCancelDuration(3, TimeUnit.SECONDS).build()

                        cam.cameraControl
                            .startFocusAndMetering(action)
                            .addListener(
                                { onFocusTap(true) },
                                ContextCompat.getMainExecutor(context)
                            )
                    }
                }
                .pointerInput(camera) {
                    // Pinch-to-zoom
                    detectTransformGestures { _, _, zoom, _ -&gt;
                        val cam = camera ?: return@detectTransformGestures
                        val zoomState = cam.cameraInfo.zoomState.value ?: return@detectTransformGestures

                        val newRatio = (zoomState.zoomRatio * zoom).coerceIn(
                            zoomState.minZoomRatio,
                            zoomState.maxZoomRatio
                        )

                        cam.cameraControl.setZoomRatio(newRatio)
                    }
                }
        )
    }
}
</code></pre>

<p>çœ‹çœ‹è¿™ä¸ªç‚¹å‡»å¯¹ç„¦çš„å®ç°ã€‚æ³¨æ„ä½ <strong>æ²¡æœ‰</strong>åšçš„äº‹æƒ…ï¼š</p>

<ul>
<li>æ— éœ€æ‰‹åŠ¨æ—‹è½¬è¡¥å¿</li>
<li>æ— éœ€è¿›è¡Œåæ ‡æ˜ å°„çš„å®½é«˜æ¯”è®¡ç®—</li>
<li>æ— éœ€è¿›è¡Œè§†å›¾ â†’ è¡¨é¢ â†’ ä¼ æ„Ÿå™¨åæ ‡é“¾è®¡ç®—</li>
<li>æ— éœ€è¿›è¡Œâ€œç¥ˆç¥·å®ƒåœ¨æ¨ªå‘æ¨¡å¼ä¸‹èƒ½æ­£å¸¸å·¥ä½œâ€çš„æ¼«é•¿æµ‹è¯•</li>
</ul>


<p><code>MutableCoordinateTransformer</code> å¯ä»¥å¤„ç†æ‰€æœ‰è¿™äº›ã€‚ä½ ç‚¹å‡» Compose åæ ‡ç³»ï¼Œå®ƒä¼šè½¬æ¢ä¸ºç›¸æœºåæ ‡ç³»ï¼Œå°±å®Œæˆäº†ã€‚</p>

<p>è¿™å°±æ˜¯â€œæŠ€æœ¯ä¸Šå¯è¡Œâ€å’Œâ€œå®é™…æ˜“äºå®ç°â€ä¹‹é—´çš„åŒºåˆ«ã€‚</p>

<h2>æ‹æ‘„ç…§ç‰‡å’Œè§†é¢‘</h2>

<p>æ·»åŠ æ‹æ‘„åŠŸèƒ½éµå¾ªç›¸åŒçš„ç®€æ´æ¨¡å¼â€”â€”ç»‘å®šå…¶ä»–ç”¨ä¾‹ï¼Œå¹¶ä» Compose ç•Œé¢è§¦å‘å®ƒä»¬ã€‚</p>

<p>æˆ‘ä»¬è¿˜å°†ä»…åœ¨å°è¯•å½•åˆ¶æ—¶è¯·æ±‚<strong>éº¦å…‹é£</strong>ï¼Œå¹¶ä½¿ç”¨ç®€å•çš„â€œPermissionGateâ€æ¨¡å¼ï¼ˆä¸æˆ‘ä»¬é¡¹ç›®åœ¨éœ€è¦æ—¶ä»…è¯·æ±‚éŸ³é¢‘çš„æ–¹æ³•ä¸€è‡´ï¼‰ã€‚</p>

<pre><code class="kotlin">@Composable
fun CameraScreen() {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current

    var camera by remember { mutableStateOf&lt;Camera?&gt;(null) }
    var imageCapture by remember { mutableStateOf&lt;ImageCapture?&gt;(null) }
    var videoCapture by remember { mutableStateOf&lt;VideoCapture&lt;Recorder&gt;?&gt;(null) }
    var activeRecording by remember { mutableStateOf&lt;Recording?&gt;(null) }

    val surfaceRequests = remember { MutableStateFlow&lt;SurfaceRequest?&gt;(null) }
    val surfaceRequest by surfaceRequests.collectAsState(initial = null)

    // Bind all use cases
    LaunchedEffect(Unit) {
        val provider = ProcessCameraProvider.awaitInstance(context)

        val preview = Preview.Builder().build().apply {
            setSurfaceProvider { req -&gt; surfaceRequests.value = req }
        }

        imageCapture = ImageCapture.Builder()
            .setCaptureMode(ImageCapture.CAPTURE_MODE_MINIMIZE_LATENCY)
            .build()

            val recorder = Recorder.Builder()
            .setQualitySelector(QualitySelector.from(Quality.FHD))
            .build()
        videoCapture = VideoCapture.withOutput(recorder)

        camera = provider.bindToLifecycle(
            lifecycleOwner,
            CameraSelector.DEFAULT_BACK_CAMERA,
            preview,
            imageCapture!!,
            videoCapture!!
        )
    }

    Box(modifier = Modifier.fillMaxSize()) {
        // Camera preview
        surfaceRequest?.let { request -&gt;
            CameraXViewfinder(
                surfaceRequest = request,
                modifier = Modifier.fillMaxSize()
            )
        }

        // Compose UI controls
        Row(
            modifier = Modifier
                .align(Alignment.BottomCenter)
                .padding(bottom = 32.dp)
        ) {
            // Capture photo button
            IconButton(
                onClick = { capturePhoto(context, imageCapture) }
            ) {
                Icon(Icons.Default.PhotoCamera, "Take Photo")
            }

            Spacer(modifier = Modifier.width(32.dp))

            // Video record toggle (mic requested only when needed)
            PermissionGate(
                permission = Permission.RECORD_AUDIO,
                // Optional: custom UI if permission is not yet granted
                contentNonGranted = { missing, humanReadable, requestPermissions -&gt;
                    // Minimal, inline UX: re-request directly
                    Button(onClick = { requestPermissions(missing) }) {
                        Text("Grant $humanReadable")
                    }
                }
            ) {
                IconButton(
                    onClick = {
                        activeRecording = toggleRecording(
                            context,
                            videoCapture,
                            activeRecording
                        )
                    }
                ) {
                    Icon(
                        if (activeRecording == null) Icons.Default.RadioButtonUnchecked
                        else Icons.Default.Stop,
                        "Record Video"
                    )
                }
            }
        }
    }
}

private fun capturePhoto(context: Context, imageCapture: ImageCapture?) {
    val capture = imageCapture ?: return

    val name = "IMG_${System.currentTimeMillis()}.jpg"
    val contentValues = ContentValues().apply {
        put(MediaStore.Images.Media.DISPLAY_NAME, name)
        put(MediaStore.Images.Media.MIME_TYPE, "image/jpeg")
        // On Android 10+ you could also set RELATIVE_PATH = "DCIM/CameraX"
    }

    val outputOptions = ImageCapture.OutputFileOptions.Builder(
        context.contentResolver,
        MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
        contentValues
    ).build()

    capture.takePicture(
        outputOptions,
        ContextCompat.getMainExecutor(context),
        object : ImageCapture.OnImageSavedCallback {
            override fun onImageSaved(output: ImageCapture.OutputFileResults) {
                // Success: output.savedUri
            }
            override fun onError(exception: ImageCaptureException) {
                // Handle error
            }
        }
    )
}

private fun toggleRecording(
    context: Context,
    videoCapture: VideoCapture&lt;Recorder&gt;?,
    currentRecording: Recording?
): Recording? {
    val capture = videoCapture ?: return null

    // Stop if already recording
    if (currentRecording != null) {
        currentRecording.stop()
        return null
    }

    // Start new recording
    val name = "VID_${System.currentTimeMillis()}.mp4"
    val contentValues = ContentValues().apply {
        put(MediaStore.Video.Media.DISPLAY_NAME, name)
        // On Android 10+ you could also set RELATIVE_PATH = "DCIM/CameraX"
    }

    val outputOptions = MediaStoreOutputOptions.Builder(
        context.contentResolver,
        MediaStore.Video.Media.EXTERNAL_CONTENT_URI
    ).setContentValues(contentValues).build()

    return capture.output
        .prepareRecording(context, outputOptions)
        .withAudioEnabled() // mic permission is ensured by PermissionGate above
        .start(ContextCompat.getMainExecutor(context)) { event -&gt;
            // Handle recording events (e.g., finalize, error)
        }
}
</code></pre>

<p>è¿™æ˜¯çº¯ç²¹çš„ Compose UI æ„å»ºã€‚ä½ çš„ç›¸æœºæŒ‰é’®ä¸é¢„è§ˆä½äºåŒä¸€ä¸ªå¯ç»„åˆæ ‘ä¸­ã€‚æ²¡æœ‰æ¡¥æ¥é€»è¾‘ã€‚æ— éœ€ç®¡ç†å•ç‹¬çš„ View å±‚æ¬¡ç»“æ„ã€‚</p>

<h2>è¿ç§»ç­–ç•¥ï¼šPreviewView â†’ CameraXViewfinder</h2>

<p>å¦‚æœä½ ç°æœ‰çš„ç›¸æœºä»£ç ä½¿ç”¨â€œPreviewViewâ€ï¼Œåˆ™è¿ç§»è·¯å¾„å¦‚ä¸‹ï¼š</p>

<p><strong>è¿ç§»å‰ï¼ˆæ—§æ–¹æ³•ï¼‰ï¼š</strong></p>

<pre><code class="kotlin">@Composable
fun OldCameraPreview() {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current
    val previewView = remember { PreviewView(context) }

    LaunchedEffect(previewView) {
        val provider = ProcessCameraProvider.getInstance(context).get()
        val preview = Preview.Builder().build()
        preview.setSurfaceProvider(previewView.surfaceProvider)
        provider.bindToLifecycle(lifecycleOwner, CameraSelector.DEFAULT_BACK_CAMERA, preview)
    }

    AndroidView(
        factory = { previewView },
        modifier = Modifier.fillMaxSize()
    )
}
</code></pre>

<p><strong>è¿ç§»åï¼ˆCompose åŸç”Ÿæ–¹æ³•ï¼‰ï¼š</strong></p>

<pre><code class="kotlin">@Composable
fun NewCameraPreview() {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current
    val selector = CameraSelector.DEFAULT_BACK_CAMERA

    val surfaceRequests = remember { MutableStateFlow&lt;SurfaceRequest?&gt;(null) }
    val surfaceRequest by surfaceRequests.collectAsState(initial = null)

    LaunchedEffect(Unit) {
        val provider = ProcessCameraProvider.awaitInstance(context)
        val preview = Preview.Builder().build().apply {
            setSurfaceProvider { req -&gt; surfaceRequests.value = req }
        }
        provider.unbindAll()
        provider.bindToLifecycle(lifecycleOwner, selector, preview)
    }

    surfaceRequest?.let {
        CameraXViewfinder(
            surfaceRequest = it,
            modifier = Modifier.fillMaxSize()
        )
    }
}
</code></pre>

<p>å…³é”®çš„æ€ç»´è½¬å˜ï¼šä¸å†å°† View çš„â€œSurfaceProviderâ€èµ‹äºˆ CameraXï¼Œè€Œæ˜¯å°†â€œSurfaceRequestâ€å¯¹è±¡å‘å¸ƒåˆ° Compose çŠ¶æ€ï¼Œå¹¶ä½¿ç”¨â€œCameraXViewfinderâ€è¿›è¡Œæ¸²æŸ“ã€‚</p>

<h2>æ‰€éœ€ä¾èµ–é¡¹</h2>

<p>æ·»åŠ åˆ°ä½ çš„ <code>build.gradle.kts</code> ä¸­ï¼š</p>

<pre><code class="kotlin">val cameraxVersion = "1.5.1"dependencies {
    implementation("androidx.camera:camera-core:$cameraxVersion")
    implementation("androidx.camera:camera-camera2:$cameraxVersion")
    implementation("androidx.camera:camera-lifecycle:$cameraxVersion")
    implementation("androidx.camera:camera-video:$cameraxVersion")

    // The new Compose-native viewfinder
    implementation("androidx.camera:camera-compose:$cameraxVersion")
}
</code></pre>

<p>æ¸…å•æƒé™ï¼š</p>

<pre><code class="xml">&lt;uses-permission android:name="android.permission.CAMERA" /&gt;
&lt;uses-permission android:name="android.permission.RECORD_AUDIO" /&gt;
</code></pre>

<h2><strong>å®ç°æ¨¡å¼ï¼ˆæ€§èƒ½ vs. åˆæˆï¼‰</strong></h2>

<p><code>CameraXViewfinder</code> å¯ä»¥é€šè¿‡ä¸¤ç§æ–¹å¼æ¸²æŸ“é¢„è§ˆï¼š</p>

<h3><strong>EXTERNALï¼ˆSurfaceView æ”¯æŒï¼‰</strong></h3>

<p>ç›¸æœºå¸§åœ¨å…¶<strong>è‡ªå·±çš„ Surface</strong> ä¸Šæ¸²æŸ“ï¼Œç”±ç³»ç»Ÿåœ¨ Compose ç»˜åˆ¶é€šé“<strong>ä¹‹å¤–</strong>åˆæˆã€‚å¯ä»¥æƒ³è±¡æˆâ€œUI èƒŒåçš„å®æ—¶è§†é¢‘å±‚â€ã€‚é€šå¸¸å¯ç”¨ç¡¬ä»¶å åŠ  â†’ æœ€ä½³æ€§èƒ½/å»¶è¿Ÿã€‚éå¸¸é€‚åˆåœ¨æ ‡å‡† UI åæ–¹æ˜¾ç¤ºå…¨å±çŸ©å½¢é¢„è§ˆã€‚ç”±äºå®ƒæ˜¯ä¸€ä¸ªå•ç‹¬çš„å±‚ï¼Œå› æ­¤å¯¹<em>ç›¸æœºåƒç´ </em>çš„é€åƒç´ æ•ˆæœï¼ˆå¤æ‚çš„è£å‰ª/æ¨¡ç³Šï¼‰ä¸é€‚ç”¨ã€‚</p>

<ul>
<li>ä¼˜ç‚¹ï¼šå»¶è¿Ÿæ›´ä½ï¼ŒGPU è´Ÿè½½æ›´å°‘ï¼Œéå¸¸é€‚åˆå…¨å±é¢„è§ˆ/å½•åˆ¶ã€‚</li>
<li>ç¼ºç‚¹ï¼šä¸å—é€åƒç´ ç•Œé¢ç‰¹æ•ˆï¼ˆåœ†è§’è’™ç‰ˆ/æ¨¡ç³Šï¼‰çš„å½±å“ï¼Œä¸ä¼šæ˜¾ç¤ºåœ¨ Compose å±å¹•æˆªå›¾ä¸­ã€‚</li>
</ul>


<h3><strong>åµŒå…¥å¼ï¼ˆTextureView æ”¯æŒï¼‰</strong></h3>

<p>ç›¸æœºå¸§ä½œä¸º<strong>GPU çº¹ç†</strong>ç»˜åˆ¶åœ¨ Compose æ¸²æŸ“é€šé“<strong>å†…éƒ¨</strong>â€”â€”ç±»ä¼¼äº<strong>å¯é‡ç»˜é¢æ¿</strong>ï¼Œå…¶è¡Œä¸ºä¸å…¶ä»–å¯ç»„åˆé¡¹ç±»ä¼¼ã€‚ä½ å¯ä»¥è·å¾—æ·±åº¦è£å‰ª/è’™ç‰ˆ/åŠ¨ç”»/æ¨¡ç³Š/Z è½´æ’åºï¼Œä½†ä»£ä»·æ˜¯ GPU å·¥ä½œé‡å¢åŠ ï¼Œå»¶è¿Ÿç•¥é«˜ã€‚</p>

<ul>
<li>ä¼˜ç‚¹ï¼šè¡Œä¸ºç±»ä¼¼äºæ™®é€šç•Œé¢ï¼›è£å‰ªã€Alpha é€šé“ã€æ¨¡ç³Šã€ç‰¹æ®Šå½¢çŠ¶å’Œå¤æ‚ Z è½´æ’åºå‡æ­£å¸¸ã€‚</li>
<li>ç¼ºç‚¹ï¼šGPU å·¥ä½œé‡å¢åŠ  â†’ åœ¨ç¹é‡çš„ç•Œé¢æˆ–ä¸­ç«¯è®¾å¤‡ä¸Šï¼Œå»¶è¿Ÿ/å¡é¡¿é£é™©ç•¥é«˜ã€‚</li>
</ul>


<h3><strong>ç»éªŒæ³•åˆ™</strong></h3>

<ul>
<li>å…¨å±/é«˜æ€§èƒ½ â†’ <strong>å¤–éƒ¨</strong></li>
<li>ç‰¹æ®Šæ„å›¾/ç‰¹æ•ˆ â†’ <strong>åµŒå…¥å¼</strong>ã€‚</li>
</ul>


<p>å¦‚æœä½ æœªæŒ‡å®šæ¨¡å¼ï¼Œåº“å°†é€‰æ‹©ä¸€ä¸ªåˆç†çš„é»˜è®¤æ¨¡å¼ã€‚å¼ºåˆ¶ä½¿ç”¨ä»¥ä¸‹æ–¹å¼ï¼š</p>

<pre><code class="kotlin">import androidx.camera.viewfinder.core.ImplementationMode

CameraXViewfinder(
    surfaceRequest = request,
    implementationMode = ImplementationMode.EXTERNAL // or ImplementationMode.EMBEDDED
)
</code></pre>

<h2>å®é™…æ“ä½œä¸­çš„é™·é˜±</h2>

<p><strong>åæ ‡å˜æ¢å¹¶éå¯é€‰</strong>
ä¸è¦å°†åŸå§‹ Compose åç§»é‡ä¼ é€’ç»™æµ‹é‡å·¥å‚ã€‚åŠ¡å¿…ä½¿ç”¨åæ ‡å˜æ¢å™¨ã€‚æ•°å­¦è¿ç®—çœ‹èµ·æ¥å¾ˆç®€å•ï¼Œç›´åˆ°ä½ åœ¨æ¨ªå±ã€å¯æŠ˜å è®¾å¤‡æˆ–éæ ‡å‡†å®½é«˜æ¯”è®¾å¤‡ä¸Šè¿›è¡Œæµ‹è¯•ã€‚</p>

<p><strong>å‰ç½®æ‘„åƒå¤´æ˜¯é•œåƒçš„</strong>
å¦‚æœä½ æ­£åœ¨ç»˜åˆ¶å åŠ å±‚æˆ–å¤„ç†æ‹æ‘„çš„å›¾åƒï¼Œè¯·è®°ä½å‰ç½®æ‘„åƒå¤´é¢„è§ˆé»˜è®¤æ˜¯é•œåƒçš„ï¼Œä½†æ‹æ‘„çš„å›¾åƒä¸æ˜¯ã€‚åœ¨ä½ çš„ç•Œé¢/å¤„ç†é€»è¾‘ä¸­è€ƒè™‘åˆ°è¿™ä¸€ç‚¹ã€‚</p>

<p><strong>åœ¨çœŸå®è®¾å¤‡ä¸Šæµ‹è¯•</strong>
ä¸åŒ OEM çš„ç›¸æœºè¡Œä¸ºæœ‰æ‰€ä¸åŒã€‚åœ¨ Pixel ä¸Šå®Œç¾è¿è¡Œçš„åŠŸèƒ½åœ¨ä¸‰æ˜Ÿæˆ–å°ç±³ä¸Šå¯èƒ½å­˜åœ¨é—®é¢˜ã€‚åœ¨ä»£è¡¨æ€§ç¡¬ä»¶ä¸Šæµ‹è¯•ä½ çš„å…³é”®æµç¨‹ã€‚</p>

<p><strong>æƒé™ç”¨æˆ·ä½“éªŒ</strong>
åœ¨å…¥å£ç‚¹è¯·æ±‚ <code>CAMERA</code>ï¼›ä»…åœ¨å¼€å§‹å½•åˆ¶æ—¶è¯·æ±‚ <code>RECORD_AUDIO</code>ï¼ˆè¿™æ˜¯ä¸€ç§è‰¯å¥½åšæ³•ï¼‰ã€‚ä¸Šé¢çš„å†…è” <code>PermissionGate</code> æ¨¡å¼å°†è¯¥é€»è¾‘ä¿ç•™åœ¨ä½ çš„ Compose æ ‘ä¸­ã€‚</p>

<h2>é«˜çº§åŠŸèƒ½ï¼šå¯æŠ˜å å’Œè‡ªé€‚åº” UI</h2>

<p>ç”±äº <code>CameraXViewfinder</code> åªæ˜¯å¦ä¸€ä¸ªå¯ç»„åˆé¡¹ï¼Œå› æ­¤å¯æŠ˜å æ”¯æŒéå¸¸ç®€å•ã€‚ç®€å•çš„åŒçª—æ ¼å¸ƒå±€æˆ–å…¨å±å¸ƒå±€é€šå¸¸å°±è¶³å¤Ÿäº†ï¼›å¦‚æœéœ€è¦ï¼Œå¯ä»¥ä½¿ç”¨ <code>AnimatedContent</code> æ¥åœ¨çŠ¶æ€ä¹‹é—´æ·»åŠ åŠ¨ç”»ã€‚</p>

<pre><code class="kotlin">@Composable
fun AdaptiveCameraScreen(surfaceRequest: SurfaceRequest?) {
    val expanded = remember { mutableStateOf(false) } // pretend this reflects window size/hinge state

    AnimatedContent(targetState = expanded.value, label = "layout") { isExpanded -&gt;
        if (isExpanded) {
            Row(Modifier.fillMaxSize()) {
                surfaceRequest?.let {
                    CameraXViewfinder(
                        surfaceRequest = it,
                        modifier = Modifier
                            .weight(1f)
                            .aspectRatio(9f / 16f)
                    )
                }
                Box(Modifier.weight(1f)) { /* CameraControls(Modifier.align(Alignment.Center)) */ }
            }
        } else {
            Box(Modifier.fillMaxSize()) {
                surfaceRequest?.let {
                    CameraXViewfinder(
                        surfaceRequest = it,
                        modifier = Modifier.fillMaxSize()
                    )
                }
                /* CameraControls(Modifier.align(Alignment.BottomCenter)) */
            }
        }
    }
}
</code></pre>

<h2>æµ‹è¯•æ¸…å•ï¼ˆå®ç”¨ï¼‰</h2>

<ul>
<li>éªŒè¯çºµå‘/æ¨ªå‘ä»¥åŠ <code>ContentScale.Crop/Fit</code> æ¨¡å¼ä¸‹çš„ç‚¹å‡»å¯¹ç„¦ç²¾åº¦ã€‚</li>
<li>æµ‹è¯•ç¼©æ”¾é™åˆ¶ï¼›ç¡®ä¿æåˆå’Œç¨‹åºåŒ–ç¼©æ”¾è¿‡æ¸¡æµç•…ã€‚</li>
<li>åˆ‡æ¢æ‘„åƒå¤´ï¼ˆå‰/åï¼‰å¹¶é‡æ–°éªŒè¯å˜æ¢ + é•œåƒè¡Œä¸ºã€‚</li>
<li>å¯¼èˆªç¦»å¼€/åé€€ã€æ—‹è½¬å’Œå¤„ç†é…ç½®æ›´æ”¹ï¼›é¢„è§ˆåº”èƒ½å¤Ÿæ¢å¤ä¸”ä¸é—ªçƒã€‚</li>
<li>åœ¨å¯¹ç„¦/ç¼©æ”¾æ—¶å½•åˆ¶è§†é¢‘ï¼›ç¡®ä¿æ²¡æœ‰è¡¨é¢æ‰è½ã€‚</li>
</ul>


<h2>å…¨å±€å±•æœ›</h2>

<p>æ­¤ç‰ˆæœ¬çš„é‡è¦æ€§ä¸ä»…åœ¨äºå®ƒå¸¦æ¥çš„åŠŸèƒ½ï¼Œè¿˜åœ¨äºå®ƒæ‰€ä¼ é€’çš„ä¿¡æ¯ã€‚</p>

<p>å¤šå¹´æ¥ï¼ŒAndroid ä¸­çš„ç›¸æœºå¼€å‘ä¸€ç›´æ„Ÿè§‰åƒæ˜¯äºŒç­‰å…¬æ°‘ã€‚é™¤äº†ç›¸æœºé¡µé¢ä¹‹å¤–ï¼Œä½ å¯ä»¥åœ¨ä»»ä½•åœ°æ–¹ä½¿ç”¨ Compose æ„å»ºç°ä»£ UIï¼Œè€Œç›¸æœºé¡µé¢åˆ™éœ€è¦ä½ å‹‰å¼ºæ‰èƒ½ä¸ View è¿›è¡Œäº’æ“ä½œã€‚è™½ç„¶ Compose ç¡®å®æœ‰æ•ˆï¼Œä½†ç¼–å†™ä»£ç æ—¶æ€»æ„Ÿè§‰åƒæ˜¯è¢«æŸç¼šäº†ä¸€åªæ‰‹ã€‚</p>

<p><code>camera-compose</code> ä¸ä»…ä»…æ˜¯ä¸€ä¸ªæ–°äº§ç‰©ã€‚CameraX å›¢é˜Ÿæ›¾è¯´è¿‡ï¼šâ€œCompose ç°åœ¨æ˜¯ä¸€æµçš„ç›¸æœºå¼€å‘å¹³å°ã€‚â€</p>

<p>è¿™æ„å‘³ç€ï¼š</p>

<ul>
<li>æœªæ¥çš„ç›¸æœºåŠŸèƒ½å°†åœ¨è®¾è®¡æ—¶å……åˆ†è€ƒè™‘ Composeï¼Œè€Œä¸æ˜¯å¯¹å…¶è¿›è¡Œæ”¹é€ ã€‚</li>
<li>ç¤¾åŒºå°†æ„å»ºä»¥ Compose ä¸ºå…ˆçš„ç›¸æœºåº“å’Œç»„ä»¶ã€‚</li>
<li>æœ€ä½³å®è·µå°†å›´ç»•å¯ç»„åˆç›¸æœº UI ä¸æ–­å‘å±•ã€‚</li>
<li>æ–‡æ¡£å’Œç¤ºä¾‹å°†åæ˜ ç°ä»£ Android å¼€å‘ã€‚</li>
</ul>


<p>æˆ‘ä»¬åœ¨æ•´ä¸ª Android ç”Ÿæ€ç³»ç»Ÿä¸­éƒ½çœ‹åˆ°äº†è¿™ç§æ¨¡å¼â€”â€”æœ€åˆä»¥ View ä¸ºä¸­å¿ƒçš„ API æ­£åœ¨é€æ¸è·å¾— Compose åŸç”Ÿçš„å¯¹åº”ç‰ˆæœ¬ã€‚<code>camera-compose</code> å°±æ˜¯è¿„ä»Šä¸ºæ­¢æœ€å…·å½±å“åŠ›çš„ä¾‹å­ä¹‹ä¸€ã€‚</p>

<h2>ä½ ç°åœ¨åº”è¯¥åšä»€ä¹ˆ</h2>

<p><strong>å¦‚æœä½ æ­£åœ¨å¼€å‘ä¸€ä¸ªæ–°çš„ç›¸æœºåŠŸèƒ½ï¼š</strong>
ä»ä¸€å¼€å§‹å°±ä½¿ç”¨ <code>CameraXViewfinder</code>ã€‚ç”šè‡³ä¸éœ€è¦è€ƒè™‘ <code>PreviewView</code>ã€‚å®ƒçš„ä»£ç æ›´ç®€æ´ï¼Œæ€ç»´æ¨¡å‹æ›´ç®€å•ï¼Œä½ ä»¥åä¼šæ„Ÿè°¢è‡ªå·±çš„ã€‚</p>

<p><strong>å¦‚æœä½ å·²ç»æœ‰ç›¸æœºä»£ç ï¼š</strong>
å°† <code>camera-compose</code> æ·»åŠ åˆ°ä½ çš„ä¾èµ–é¡¹ä¸­ï¼Œå¹¶ä¸€æ¬¡è¿ç§»ä¸€ä¸ªé¡µé¢ã€‚ä»æœ€ç®€å•çš„ç›¸æœº UIï¼ˆå¯èƒ½æ˜¯åŸºæœ¬çš„çº¯é¢„è§ˆé¡µé¢ï¼‰å¼€å§‹ï¼Œç†Ÿæ‚‰æ–°çš„ APIã€‚ç„¶åå†å¤„ç†å¤æ‚çš„éƒ¨åˆ†ã€‚</p>

<p><strong>å¦‚æœä½ æ­£åœ¨æ„å»ºä¸€ä¸ªåº“ï¼š</strong>
ç°åœ¨æ˜¯æ—¶å€™å°† Compose åŸç”Ÿç›¸æœºç»„ä»¶æ·»åŠ åˆ°ä½ çš„ SDK ä¸­äº†ã€‚å¼€å‘è€…æ­£åœ¨å¯»æ‰¾å¯ç»„åˆçš„ç›¸æœºè§£å†³æ–¹æ¡ˆï¼Œè€Œç”Ÿæ€ç³»ç»Ÿå·²ç»ä¸ºä»–ä»¬åšå¥½äº†å‡†å¤‡ã€‚</p>

<h2>å»¶ä¼¸é˜…è¯»</h2>

<ul>
<li><a href="https://developer.android.com/jetpack/androidx/releases/camera">CameraX å‘è¡Œè¯´æ˜</a> â€” å®˜æ–¹æ›´æ–°æ—¥å¿—å’Œå·¥ä»¶</li>
<li><a href="https://developer.android.com/jetpack/androidx/releases/camera-viewfinder">Camera Viewfinder æ–‡æ¡£</a> â€” å®ç°æ¨¡å¼ã€ç¼©æ”¾å’Œå¯¹é½</li>
<li><a href="https://github.com/androidx/androidx/tree/androidx-main/camera">CameraX GitHub ç¤ºä¾‹</a> â€” çœŸå®ä»£ç ç¤ºä¾‹</li>
</ul>


<h2>å›½ç‹å·²æ­» / å›½ç‹ä¸‡å²</h2>

<p>â€œAndroidViewâ€ç›¸æœºé¢„è§ˆçš„æ—¶ä»£å·²ç»ç»“æŸã€‚å¦‚æœä½ è¦åœ¨ 2025 å¹´åŠä»¥åæ„å»ºç›¸æœºåŠŸèƒ½ï¼Œé‚£ä¹ˆä½ å°†ä½¿ç”¨ Compose æ¥æ„å»ºå®ƒä»¬ã€‚ç°åœ¨ç»ˆäºæœ‰äº†å¯ä»¥æ­£ç¡®æ”¯æŒè¿™äº›åŠŸèƒ½çš„å·¥å…·ã€‚</p>

<p>ç°åœ¨ï¼Œç”©æ‰é‚£ä¸ªâ€œAndroidViewâ€åŒ…è£…å™¨ï¼Œç¼–å†™ä¸€äº›æ¼‚äº®çš„ç›¸æœº UI å§ã€‚</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ç†è§£retain{}çš„å†…éƒ¨æœºåˆ¶ï¼šJetpack Composeä¸­åŸºäºä½œç”¨åŸŸçš„çŠ¶æ€ä¿å­˜]]></title>
    <link href="https://alexhilton.github.io/blog/2025/10/22/understanding-retrain-internals/"/>
    <updated>2025-10-22T14:29:55+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/10/22/understanding-retrain-internals</id>
    <content type="html"><![CDATA[<blockquote><p>æœ¬æ–‡è¯‘è‡ªã€ŒUnderstanding retain{} internals: A Scope-based State Preservation in Jetpack Composeã€ï¼ŒåŸæ–‡é“¾æ¥<a href="https://proandroiddev.com/understanding-retain-internals-a-new-way-to-preserve-state-in-jetpack-compose-54471a32fd05">https://proandroiddev.com/understanding-retain-internals-a-new-way-to-preserve-state-in-jetpack-compose-54471a32fd05</a>ï¼Œç”±Jaewoong Eumå‘å¸ƒäº2025å¹´10æœˆ15æ—¥ã€‚</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/1*yQo3amM25om4TWkUzgxjvQ.jpeg" title="auto auto" ></a></p>

<!-- more -->


<p>Jetpack Compose æ˜¯ä¸€ç§ç°ä»£ Android UI å¼€å‘æ–¹å¼ï¼Œæ‹¥æœ‰å£°æ˜å¼æ–¹æ³•å’Œå¼ºå¤§çš„çŠ¶æ€ç®¡ç†åŸè¯­ã€‚è™½ç„¶ <code>remember{}</code> èƒ½å¤Ÿå¾ˆå¥½åœ°åœ¨é‡ç»„è¿‡ç¨‹ä¸­ä¿å­˜çŠ¶æ€ï¼Œä½†å®ƒæœ‰ä¸€ä¸ªæ ¹æœ¬æ€§çš„å±€é™æ€§ï¼šå®ƒæ— æ³•åœ¨é…ç½®æ›´æ”¹æˆ–å¯¼èˆªè½¬æ¢åç»§ç»­ç”Ÿæ•ˆã€‚å¼•å…¥ <code>retain{}</code>ï¼Œè¿™æ˜¯ä¸€ç§åœ¨ç¬æ—¶é”€æ¯åœºæ™¯ä¸‹ä¿å­˜çŠ¶æ€çš„æ–°æ–¹æ³•ï¼ŒåŒæ—¶ä¿æŒå¯ç»„åˆæ€§ã€‚</p>

<p>åœ¨æœ¬æ–‡ä¸­ï¼Œä½ å°†æ·±å…¥äº†è§£ <code>retain{}</code>ã€<code>RetainScope</code>ã€<code>RetainObserver</code> å’Œ <code>RetainedEffect</code> çš„å†…éƒ¨æœºåˆ¶ï¼Œæ¢ç´¢å®ƒä»¬çš„åº•å±‚å·¥ä½œåŸç†ï¼Œä»¥åŠä½¿ Retention æ—¢å†…å­˜å®‰å…¨åˆæ€§èƒ½å“è¶Šçš„ä¼˜åŒ–æ–¹æ³•ã€‚</p>

<p>å¦‚æœä½ å°šæœªé˜…è¯»ä»¥ä¸‹ä¹‹å‰çš„æ–‡ç« ï¼Œç†è§£ä»¥ä¸‹éƒ¨åˆ†å°†å¯¹ä½ æœ‰æ‰€å¸®åŠ©ï¼š</p>

<ul>
<li><a href="https://medium.com/proandroiddev/exploring-retain-api-a-new-way-to-persist-state-in-jetpack-compose-bfb2fe2eae43">é¢„è§ˆ retain{} APIï¼šJetpack Compose ä¸­æŒä¹…åŒ–çŠ¶æ€çš„æ–°æ–¹æ³•</a></li>
<li><a href="https://medium.com/proandroiddev/previewing-retainedeffect-a-new-side-effect-to-bridge-between-composition-and-retention-lifecycles-685b9e543de7">é¢„è§ˆ RetainedEffectï¼šæ¡¥æ¥ Composition å’Œ Retention ç”Ÿå‘½å‘¨æœŸçš„æ–° Side Effect</a></li>
</ul>


<h2>å¯¼å…¥ Compose è¿è¡Œæ—¶ retain åº“</h2>

<p>ä½ å¯ä»¥ä½¿ç”¨ä»¥ä¸‹ä¾èµ–é¡¹å¯¼å…¥ Compose è¿è¡Œæ—¶ retain åº“ï¼š</p>

<pre><code class="kotlin">implementation("androidx.compose.runtime:runtime-retain:1.10.0-alpha05")
</code></pre>

<p>è¯·æ³¨æ„ï¼Œæ­¤åº“ç›®å‰å¤„äºå®éªŒé˜¶æ®µï¼Œæœªæ¥å°†ä¸æ–­å®Œå–„å’Œç¨³å®šå‘å¸ƒã€‚</p>

<h2>ç†è§£æ ¸å¿ƒé—®é¢˜ï¼šä¸ºä»€ä¹ˆ remember{} è¿˜ä¸å¤Ÿ</h2>

<p>ä»æœ¬è´¨ä¸Šè®²ï¼Œ<code>remember{}</code> å¯ä»¥åœ¨å•ä¸ªç»„åˆç”Ÿå‘½å‘¨æœŸå†…è·¨é‡ç»„ä¿ç•™çŠ¶æ€ã€‚ä½†æ˜¯ï¼Œå½“ä½ çš„ Activity å› é…ç½®æ›´æ”¹è€Œé‡æ–°åˆ›å»ºæ—¶ä¼šå‘ç”Ÿä»€ä¹ˆï¼Ÿæˆ–è€…å½“å¯¼èˆªç›®æ ‡ä»è¿”å›å †æ ˆä¸­ç§»é™¤æ—¶ï¼ŸçŠ¶æ€ä¼šä¸¢å¤±ï¼Œä½ çš„å¯ç»„åˆé¡¹ä¼šé‡æ–°å¼€å§‹ã€‚</p>

<p>ä¼ ç»Ÿçš„ Android è§£å†³æ–¹æ¡ˆæ¶‰åŠ <code>ViewModel</code> å’Œ <code>SavedStateHandle</code>ï¼Œä½†å®ƒä»¬æœ¬èº«ä¹Ÿå…·æœ‰å¤æ‚æ€§ï¼šåºåˆ—åŒ–è¦æ±‚ã€æ‰‹åŠ¨çŠ¶æ€æ¢å¤ä»¥åŠåœ¨å¯ç»„åˆé¡¹å±‚æ¬¡ç»“æ„ä¹‹å¤–ç®¡ç†çŠ¶æ€çš„è®¤çŸ¥å¼€é”€ã€‚å¦‚æœæˆ‘ä»¬å¯ä»¥æ‹¥æœ‰ä¸€ä¸ªåƒ <code>remember{}</code> ä¸€æ ·å·¥ä½œï¼Œä½†åˆèƒ½åœ¨è¿™äº›ç¬æ—¶é”€æ¯åç»§ç»­å­˜åœ¨çš„ä¸œè¥¿ï¼Œé‚£ä¼šæ€æ ·ï¼Ÿ</p>

<pre><code class="kotlin">// With remember: state lost on configuration change
@Composable
fun VideoPlayer() {
    val player = remember { MediaPlayer() } // Lost on rotation!
}

// With retain: state preserved across configuration changes
@Composable
fun VideoPlayer() {
    val player = retain { MediaPlayer() } // Survives rotation!
}
</code></pre>

<p><code>retain{}</code> èƒŒåçš„å…³é”®æ´å¯Ÿæ˜¯ï¼ŒçŠ¶æ€é”€æ¯å¹¶ä¸æ€»æ˜¯æ°¸ä¹…æ€§çš„ã€‚é€šå¸¸ï¼Œå®ƒæ˜¯æš‚æ—¶çš„ï¼›å†…å®¹ä¼šè¢«é‡æ–°åˆ›å»ºï¼Œæ¢å¤ä¹‹å‰çš„çŠ¶æ€ä¼šå¯¹æˆ‘ä»¬æœ‰åˆ©ã€‚è¿™å°±æ˜¯â€œRetainScopeâ€å‘æŒ¥ä½œç”¨çš„åœ°æ–¹ã€‚</p>

<h2>retain{} API åŠå…¶ç”Ÿå‘½å‘¨æœŸ</h2>

<p>å¦‚æœä½ æ£€æŸ¥ retain å‡½æ•°ç­¾åï¼Œä¼šå‘ç°å®ƒä¸ <code>remember</code> API ç±»ä¼¼ï¼Œä½†å­˜åœ¨ä»¥ä¸‹åŒºåˆ«ï¼š</p>

<pre><code class="kotlin">@Composable
public inline fun &lt;reified T&gt; retain(noinline calculation: () -&gt; T): T

@Composable
public inline fun &lt;reified T&gt; retain(vararg keys: Any?, noinline calculation: () -&gt; T): T
</code></pre>

<p>å¸¦æœ‰ <code>reified</code> ç±»å‹å‚æ•°çš„ inline ä¿®é¥°ç¬¦æ— éœ€æ˜¾å¼ç±»å‚æ•°å³å¯å®ç°ç±»å‹å®‰å…¨çš„ä¿ç•™ã€‚ä½†çœŸæ­£çš„é­”åŠ›åœ¨äºå…¶å®ç°ï¼š</p>

<pre><code class="kotlin">@Composable
private fun &lt;T&gt; retainImpl(key: RetainKeys, calculation: () -&gt; T): T {
    val retainScope = LocalRetainScope.current
    val holder = remember(key) {
        val retainedValue = retainScope.getExitedValueOrDefault(key, RetainScopeMissingValue)
        if (retainedValue !== RetainScopeMissingValue) {
            RetainedValueHolder(
                key = key,
                value = @Suppress("UNCHECKED_CAST") (retainedValue as T),
                owner = retainScope,
                isNewlyRetained = false,
            )
        } else {
            RetainedValueHolder(
                key = key,
                value = calculation(),
                owner = retainScope,
                isNewlyRetained = true,
            )
        }
    }

    if (holder.owner !== retainScope) {
        SideEffect { holder.readoptUnder(retainScope) }
    }
    return holder.value
}
</code></pre>

<p>æ­¤å®ç°æ­ç¤ºäº†ä¿ç•™çš„ä¸¤ä¸ªé˜¶æ®µç‰¹æ€§ï¼š</p>

<p><strong>é˜¶æ®µ 1ï¼šè®°å¿†é˜¶æ®µ</strong>ã€‚<code>retain{}</code> é¦–å…ˆä½¿ç”¨ <code>remember{}</code> åˆ›å»ºä¸€ä¸ª <code>RetainedValueHolder</code>ã€‚è¯¥æŒæœ‰è€…åŒ…è£…å®é™…å€¼å¹¶è·Ÿè¸ªå…¶ç”Ÿå‘½å‘¨æœŸã€‚</p>

<p><strong>é˜¶æ®µ 2ï¼šä¿ç•™é˜¶æ®µ</strong>ã€‚å½“æŒæœ‰è€…ç¦»å¼€ç»„åˆæ—¶ï¼Œ<code>RetainScope</code> ä¸ä¼šç«‹å³å°†å…¶ä¸¢å¼ƒï¼Œè€Œæ˜¯å†³å®šæ˜¯å¦å°†å…¶ä¿ç•™ä»¥å¤‡å°†æ¥æ¢å¤ã€‚</p>

<h2>RetainedValueHolder å’Œ RetainScope</h2>

<p>é¦–å…ˆï¼Œå¦‚æœä½ ä»”ç»†ç ”ç©¶ <code>RetainedValueHolder</code> çš„å†…éƒ¨ä»£ç ï¼Œä½ ä¼šå‘ç°å®ƒæ˜¯ç”Ÿå‘½å‘¨æœŸç®¡ç†å‘ç”Ÿçš„åœ°æ–¹ã€‚å®ƒå®ç°äº† <code>RememberObserver</code> æ¥å£ï¼Œä»¥ä¾¿ä¸ Compose çš„ç”Ÿå‘½å‘¨æœŸæŒ‚é’©ï¼š</p>

<pre><code class="kotlin">internal class RetainedValueHolder&lt;out T&gt; internal constructor(
    val key: Any,
    val value: T,
    owner: RetainScope,
    private var isNewlyRetained: Boolean,
) : RememberObserver {

    override fun onRemembered() {
        if (value is RetainObserver) {
            if (isNewlyRetained) {
                isNewlyRetained = false
                value.onRetained()
            }
            value.onEnteredComposition()
        }
    }

    override fun onForgotten() {
        if (owner.isKeepingExitedValues) {
            owner.saveExitingValue(key, value)
        }

        if (value is RetainObserver) {
            value.onExitedComposition()
            if (!owner.isKeepingExitedValues) value.onRetired()
        }
    }

    override fun onAbandoned() {
        if (owner.isKeepingExitedValues) {
            if (value is RetainObserver) value.onRetained()
            owner.saveExitingValue(key, value)
        } else if (value is RetainObserver) {
            value.onUnused()
        }
    }
}
</code></pre>

<p>é‡è¦çš„ä¸€ç‚¹æ˜¯ï¼Œè¯¥æŒæœ‰è€…ä¼šæ‹¦æˆªç»„åˆç”Ÿå‘½å‘¨æœŸäº‹ä»¶å¹¶å°†å…¶è½¬æ¢ä¸ºä¿ç•™äº‹ä»¶ã€‚å½“ <code>onForgotten()</code> è¢«è°ƒç”¨æ—¶ï¼ˆå€¼ç¦»å¼€ç»„åˆï¼‰ï¼Œå®ƒä¼šæ£€æŸ¥ <code>RetainScope</code> æ˜¯å¦ä¿ç•™äº†å·²é€€å‡ºçš„å€¼ã€‚å¦‚æœæ˜¯ï¼Œå®ƒä¼šä¿å­˜è¯¥å€¼ä»¥ä¾›å°†æ¥æ¢å¤ï¼Œè€Œä¸æ˜¯ä¸¢å¼ƒå®ƒã€‚</p>

<p><code>RetainScope</code> æ˜¯ä¿ç•™ç³»ç»Ÿçš„æ ¸å¿ƒæ¦‚å¿µã€‚å®ƒç®¡ç†ä½•æ—¶ä¿ç•™å€¼ã€å¦‚ä½•å­˜å‚¨å®ƒä»¬ä»¥åŠä½•æ—¶æ¢å¤æˆ–é€€å‡ºå®ƒä»¬ã€‚è®©æˆ‘ä»¬æ¥çœ‹çœ‹å®ƒçš„ç»†èŠ‚ï¼š</p>

<pre><code class="kotlin">public abstract class RetainScope : RetainStateProvider {
    protected var keepExitedValuesRequests: Int = 0
        private set

    final override val isKeepingExitedValues: Boolean
        get() = keepExitedValuesRequests &gt; 0

    public abstract fun getExitedValueOrDefault(key: Any, defaultIfAbsent: Any?): Any?
    protected abstract fun saveExitingValue(key: Any, value: Any?)
    protected abstract fun onStartKeepingExitedValues()
    protected abstract fun onStopKeepingExitedValues()
}
</code></pre>

<p>ä½œç”¨åŸŸæœ‰ä¸¤ç§è¿è¡Œæ¨¡å¼ï¼š</p>

<ol>
<li><strong>æ™®é€šæ¨¡å¼</strong> (<code>isKeepingExitedValues = false</code>)ï¼šå€¼ç¦»å¼€ç»„åˆæ—¶ä¼šè¢«ä¸¢å¼ƒï¼Œå°±åƒ <code>remember{}</code> ä¸€æ ·ã€‚</li>
<li><strong>ä¿ç•™æ¨¡å¼</strong> (<code>isKeepingExitedValues = true</code>)ï¼šå€¼é€€å‡ºæ—¶ä¼šè¢«ä¿ç•™ï¼Œä»¥ä¾¿å°†æ¥æ¢å¤ã€‚</li>
</ol>


<p>é‚£ä¹ˆï¼Œä¿ç•™ç”Ÿå‘½å‘¨æœŸæ˜¯å¦‚ä½•è¿ä½œçš„å‘¢ï¼Ÿé€šè¿‡åŸå§‹æºä»£ç ä¸­åµŒå…¥çš„å›¾è¡¨å¯ä»¥æœ€å¥½åœ°ç†è§£ä¿ç•™ç”Ÿå‘½å‘¨æœŸï¼š</p>

<pre><code class="bash">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      â”‚
â”‚ retain(keys) { ... } â”‚
â”‚        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¤  value: T  â”œâ”˜
         â””â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚   â–²
        Exitâ”‚   â”‚Enter
 compositionâ”‚   â”‚composition
   or changeâ”‚   â”‚
        keysâ”‚   â”‚                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚   â”œâ”€â”€â”€No retained valueâ”€â”€â”€â”€â”€â”¤   calculation: () -&gt; T   â”‚
            â”‚   â”‚   or different keys     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚   â”‚                         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
            â”‚   â””â”€â”€â”€Re-enter compositionâ”€â”€â”¤    Local RetainScope     â”‚
            â”‚       with the same keys    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â”‚                                           â–²   â”‚
            â”‚                      â”Œâ”€Yesâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ value not
            â”‚                      â”‚                        â”‚ restored and
            â”‚   .â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€.     â”‚ scope stops
            â””â”€â–¶(   RetainScope.isKeepingExitedValues   )    â”‚ keeping exited
                `â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€'     â”‚ values
                                   â”‚                        â–¼
                                   â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                   â””â”€Noâ”€â”€â–¶â”‚     value is retired     â”‚
                                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>

<p>æ­¤æµç¨‹æ­ç¤ºäº†å‡ ä¸ªå…³é”®çš„è§è§£ï¼š</p>

<ol>
<li><strong>ä¿ç•™æ˜¯æœ‰æ¡ä»¶çš„</strong>ï¼šåªæœ‰å½“ <code>isKeepingExitedValues</code> ä¸º <code>true</code> æ—¶ï¼Œå€¼æ‰ä¼šè¢«ä¿ç•™ã€‚</li>
<li><strong>é”®å¾ˆé‡è¦</strong>ï¼šå³ä½¿åœ¨ä¿ç•™æœŸé—´ï¼Œæ›´æ”¹çš„é”®ä¹Ÿä¼šå¯¼è‡´ç«‹å³é€€å‡ºã€‚</li>
<li><strong>æ¢å¤æ˜¯è‡ªåŠ¨çš„</strong>ï¼šå½“å†…å®¹ä½¿ç”¨ç›¸åŒçš„é”®é‡æ–°è¾“å…¥æ—¶ï¼Œä¿ç•™çš„å€¼å°†è¢«æ¢å¤ã€‚</li>
<li><strong>é€€å‡ºæ˜¯æœ€ç»ˆçš„</strong>ï¼šä¿ç•™åœæ­¢æ—¶æœªæ¢å¤çš„å€¼å°†è¢«é€€å‡ºã€‚</li>
</ol>


<h2>ControlledRetainScopeï¼šå¯å˜å®ç°</h2>

<p>è™½ç„¶ <code>RetainScope</code> æä¾›äº†æŠ½è±¡ï¼Œä½† <code>ControlledRetainScope</code> æ‰æ˜¯ä¸»è¦çš„å®ç°ï¼š</p>

<pre><code class="kotlin">public class ControlledRetainScope : RetainScope() {
    private val keptExitedValues = SafeMultiValueMap&lt;Any, Any?&gt;()

    override fun saveExitingValue(key: Any, value: Any?) {
        keptExitedValues.add(key, value)
    }

    @Suppress("UNCHECKED_CAST")
    override fun getExitedValueOrDefault(key: Any, defaultIfAbsent: Any?): Any? {
        return keptExitedValues.removeLast(key, defaultIfAbsent)
    }

    override fun onStopKeepingExitedValues() {
        keptExitedValues.forEachValue { value -&gt;
            if (value is RetainObserver) value.onRetired()
        }
        keptExitedValues.clear()
    }
}
</code></pre>

<p>è¯¥å®ç°ä½¿ç”¨ <code>SafeMultiValueMap</code> è¿›è¡Œå­˜å‚¨æ˜¯ä¸€ä¸ªé‡è¦çš„è®¾è®¡é€‰æ‹©ã€‚ä¸ºä»€ä¹ˆï¼Ÿå› ä¸ºå¤šä¸ª retain è°ƒç”¨å¯ä»¥å…·æœ‰ç›¸åŒçš„é”®ï¼š</p>

<pre><code class="kotlin">@Composable
fun Example() {
    // Both have the same positional key!
    val value1 = retain { "First" }
    val value2 = retain { "Second" }
}
</code></pre>

<p>è¯¥æ˜ å°„æŒ‰ LIFOï¼ˆåè¿›å…ˆå‡ºï¼‰é¡ºåºå­˜å‚¨æ¯ä¸ªé”®çš„å€¼ã€‚æ¢å¤æ—¶ï¼Œ<code>removeLast()</code> ç¡®ä¿å€¼æŒ‰å…¶å­˜å‚¨çš„ç›¸åé¡ºåºæ¢å¤ï¼Œä»è€Œä¿æŒ retain è°ƒç”¨ä¸å…¶å€¼ä¹‹é—´çš„æ­£ç¡®é…å¯¹ã€‚</p>

<p>æ­¤å¤–ï¼Œ<code>ControlledRetainScope</code> æ”¯æŒåµŒå¥—åœ¨çˆ¶çº§ <code>RetainStateProvider</code> ä¸‹ï¼š</p>

<pre><code class="kotlin">public fun setParentRetainStateProvider(parent: RetainStateProvider) {
    val oldParent = parentScope
    parentScope = parent

    parent.addRetainStateObserver(parentObserver)
    oldParent.removeRetainStateObserver(parentObserver)

    if (parent.isKeepingExitedValues) startKeepingExitedValues()
    if (oldParent.isKeepingExitedValues) stopKeepingExitedValues()
}
</code></pre>

<p>è¿™æ”¯æŒæœ‰åºçš„å±‚æ¬¡ç»“æ„ï¼Œå…¶ä¸­å­ä½œç”¨åŸŸä»çˆ¶çº§ç»§æ‰¿ä¿ç•™çŠ¶æ€ã€‚ä½ å¯ä»¥åˆ©ç”¨æ­¤åŠŸèƒ½ä½¿æ‰€æœ‰ <code>RetainScopes</code> åœ¨é…ç½®æ›´æ”¹æœŸé—´ä¿ç•™ï¼Œæ ¹ä½œç”¨åŸŸä¼šæ£€æµ‹åˆ°é…ç½®æ›´æ”¹ï¼Œå¹¶æ²¿å±‚æ¬¡ç»“æ„å‘ä¸‹çº§è”ä¿ç•™ã€‚</p>

<h2>RetainObserverï¼šä¿ç•™å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸå›è°ƒ</h2>

<p>éœ€è¦äº†è§£å…¶ä¿ç•™ç”Ÿå‘½å‘¨æœŸçš„å¯¹è±¡éœ€è¦å®ç° <code>RetainObserver</code>ï¼š</p>

<pre><code class="kotlin">@Suppress("CallbackName")
public interface RetainObserver {
    public fun onRetained()

    // Successfully retained
    public fun onEnteredComposition() // Entered composition
    public fun onExitedComposition()  // Exited composition
    public fun onRetired()

    // No longer retained
    public fun onUnused()

    // Created but never used
}
</code></pre>

<p>è¿™äº›å›è°ƒå®ç°äº† <code>remember{}</code> æ— æ³•å®ç°çš„èµ„æºç®¡ç†æ¨¡å¼ã€‚è®¾æƒ³ä¸€ä¸ªåª’ä½“æ’­æ”¾å™¨ï¼Œå½“å±å¹•æœªæ˜¾ç¤ºæ—¶åº”è¯¥æš‚åœï¼Œä½†å¦‚æœå¯èƒ½å†æ¬¡æ˜¾ç¤ºï¼Œåˆ™ä¸åº”é‡Šæ”¾èµ„æºï¼š</p>

<pre><code class="kotlin">class RetainableMediaPlayer : RetainObserver {
    private var player: MediaPlayer? = null

    override fun onRetained() {
        player = MediaPlayer()
    }

    override fun onEnteredComposition() {
        player?.play()
    }

    override fun onExitedComposition() {
        player?.pause() // Just pause, don't release
    }

    override fun onRetired() {
        player?.release() // Now we can release
        player = null
    }

    override fun onUnused() {
        // Never entered composition, clean up
        player?.release()
        player = null
    }
}
</code></pre>

<p>è¿˜åº”è®°ä½ï¼Œå›è°ƒéµå¾ªä¸¥æ ¼çš„é¡ºåºä¿è¯ã€‚å½“å¤šä¸ª <code>RetainObserver</code> åŒæ—¶è¿›å…¥ç»„åˆçŠ¶æ€æ—¶ï¼Œå®ƒä»¬çš„ <code>onEnteredComposition</code> å›è°ƒå°†æŒ‰é¡ºåºè§¦å‘ã€‚é€€å‡ºæ—¶ï¼Œ<code>onExitedComposition</code> å°†æŒ‰ç›¸åé¡ºåºè§¦å‘<strong>ï¼Œ</strong>ä»¥ç¡®ä¿æ­£ç¡®æ¸…ç†åµŒå¥—èµ„æºã€‚</p>

<h2>RememberObserver é™åˆ¶</h2>

<p>ä½ å¯ä»¥åœ¨ <code>RetainedValueHolder</code> ä¸­æ‰¾åˆ°ä¸€ä¸ªæœ‰è¶£çš„å®‰å…¨æ£€æŸ¥ï¼š</p>

<pre><code class="kotlin">init {
    if (value is RememberObserver &amp;&amp; value !is RetainObserver) {
        throw IllegalArgumentException(
            "Retained a value that implements RememberObserver but not RetainObserver. " +
            "To receive the correct callbacks, the retained value '$value' must also " +
            "implement RetainObserver."
        )
    }
}
</code></pre>

<p>ä¸ºä»€ä¹ˆæœ‰è¿™ä¸ªé™åˆ¶ï¼Ÿ<code>RememberObserver</code> å›è°ƒï¼ˆ<code>onRemembered</code>ã€<code>onForgotten</code>ã€<code>onAbandoned</code>ï¼‰ä¸ä¿ç•™è¯­ä¹‰ä¸ä¸€è‡´ã€‚æš‚æ—¶è„±ç¦»ç»„åˆçš„ä¿ç•™å€¼ä¸ä¼šè¢«â€œé—å¿˜â€ï¼Œè€Œæ˜¯å¤„äºä¸ç¡®å®šçŠ¶æ€ï¼Œå¯èƒ½ä¼šå†æ¬¡è¿”å›ã€‚ä½¿ç”¨ <code>RememberObserver</code> ä¼šå¯¼è‡´é”™è¯¯çš„ç”Ÿå‘½å‘¨æœŸå›è°ƒï¼Œå› æ­¤åº“å¼ºåˆ¶ä½¿ç”¨ <code>RetainObserver</code>ã€‚</p>

<h2>RetainedEffectï¼šä¿ç•™åä»å­˜åœ¨çš„å‰¯ä½œç”¨</h2>

<p><code>RetainedEffect</code> å°†ä¿ç•™çš„æ¦‚å¿µæ‰©å±•åˆ°å‰¯ä½œç”¨ï¼š</p>

<pre><code class="kotlin">@Composable
public fun RetainedEffect(key1: Any?, effect: RetainedEffectScope.() -&gt; RetainedEffectResult) {
    retain(key1) { RetainedEffectImpl(effect) }
}

private class RetainedEffectImpl(
    private val effect: RetainedEffectScope.() -&gt; RetainedEffectResult
) : RetainObserver {
    private var onRetire: RetainedEffectResult? = null

    override fun onRetained() {
        onRetire = InternalRetainedEffectScope.effect()
    }

    override fun onRetired() {
        onRetire?.retire()
        onRetire = null
    }

    // Other callbacks are no-ops
}
</code></pre>

<p>å®ç°éå¸¸ç®€å•ï¼šå®ƒå°† effect åŒ…è£…åœ¨ä¸€ä¸ª <code>RetainObserver</code> ä¸­ï¼Œè¯¥ <code>RetainObserver</code> åœ¨ä¿ç•™æ—¶æ‰§è¡Œ effectï¼Œå¹¶åœ¨é€€å‡ºæ—¶è¿›è¡Œæ¸…ç†ã€‚ä¸ DisposableEffect ä¸åŒï¼ŒDisposableEffect åœ¨ç¦»å¼€ç»„åˆæ—¶è¿è¡Œå…¶å¤„ç½®ï¼Œè€Œ RetainedEffect ä»…åœ¨çœŸæ­£é€€å‡ºæ—¶å¤„ç½®ï¼š</p>

<pre><code class="kotlin">@Composable
fun VideoPlayer(mediaUri: String) {
    val player = retain(mediaUri) { MediaPlayer(mediaUri) }

    // DisposableEffect would dispose on every hide/show
    // RetainedEffect only disposes when truly done
    RetainedEffect(player) {
        player.initialize()
        onRetire {
            player.close() // Only called when player is retired
        }
    }
}
</code></pre>

<p>è¿™æ˜¯ä¸€ä¸ªå¾ˆå¥½çš„ä¾‹å­ï¼Œè¯´æ˜åœ¨çŸ­æš‚çš„ UI å˜åŒ–æœŸé—´ä¸åº”é‡æ–°åˆ›å»ºæ˜‚è´µçš„èµ„æºã€‚</p>

<h2>RetainedContentHost å’Œ RetainScopeHolder</h2>

<p><code>compose-runtime-retain</code> åº“æä¾›äº†åŸºäºè¿™äº›åŸè¯­æ„å»ºçš„æ›´é«˜çº§åˆ«çš„æŠ½è±¡ã€‚<code>RetainedContentHost</code> ç®¡ç†æ˜¾ç¤º/éšè—åœºæ™¯ï¼š</p>

<pre><code class="kotlin">@Composable
public fun RetainedContentHost(active: Boolean, content: @Composable () -&gt; Unit) {
    val retainScope = retainControlledRetainScope()
    if (active) {
        CompositionLocalProvider(LocalRetainScope provides retainScope, content)

        val composer = currentComposer
        DisposableEffect(retainScope) {
            val cancellationHandle =
                if (retainScope.keepExitedValuesRequestsFromSelf &gt; 0) {
                    composer.scheduleFrameEndCallback {
                        retainScope.stopKeepingExitedValues()
                    }
                } else {
                    null
                }

            onDispose {
                cancellationHandle?.cancel()
                retainScope.startKeepingExitedValues()
            }
        }
    }
}
</code></pre>

<p>è¯¥å®ç°æ­ç¤ºäº†ä¸€äº›æ—¶é—´æ§åˆ¶ï¼š</p>

<p><strong>å˜ä¸ºæ´»åŠ¨çŠ¶æ€</strong>ï¼šå®‰æ’åœ¨å¸§ç»“æŸæ—¶åœæ­¢ä¿ç•™ï¼Œç¡®ä¿æ‰€æœ‰å†…å®¹éƒ½é¦–å…ˆæ¢å¤å…¶å€¼ã€‚</p>

<p><strong>å˜ä¸ºéæ´»åŠ¨çŠ¶æ€</strong>ï¼šåœ¨å†…å®¹è¢«ç§»é™¤ä¹‹å‰ç«‹å³å¼€å§‹ä¿ç•™ã€‚</p>

<p>è¿™ç¡®ä¿äº†å€¼åœ¨éœ€è¦æ—¶è¢«å‡†ç¡®ä¿ç•™ï¼Œä¸ä¼šå¤ªæ—©ï¼ˆè¿™ä¼šé˜»æ­¢æ¢å¤ï¼‰ï¼Œä¹Ÿä¸ä¼šå¤ªæ™šï¼ˆè¿™ä¼šä¸¢å¤±å€¼ï¼‰ã€‚</p>

<p>å¯¹äºåˆ—è¡¨ç­‰åŠ¨æ€å†…å®¹ï¼Œ<code>RetainScopeHolder</code> è´Ÿè´£ç®¡ç†æ¯ä¸ªé¡¹ç›®çš„ä¿ç•™ï¼š</p>

<pre><code class="kotlin">public class RetainScopeHolder() {
    private val childScopes = MutableScatterMap&lt;Any?, ControlledRetainScope&gt;()

    public fun getOrCreateRetainScopeForChild(key: Any?): RetainScope {
        return childScopes.getOrPut(key) {
            ControlledRetainScope().apply {
                if (isParentKeepingExitedValues) startKeepingExitedValues()
            }
        }
    }

    @Composable
    public fun RetainScopeProvider(key: Any?, content: @Composable () -&gt; Unit) {
        CompositionLocalProvider(
            LocalRetainScope provides getOrCreateRetainScopeForChild(key)
        ) {
            content()
            PresenceIndicator(key)
        }
    }

    @Composable
    private fun PresenceIndicator(key: Any?) {
        val composer = currentComposer
        DisposableEffect(key) {
            val endRetainHandle =
                if (keepExitedValuesRequestsFor(key) &gt; 0) {
                    composer.scheduleFrameEndCallback {
                        stopKeepingExitedValues(key)
                    }
                } else {
                    null
                }
            onDispose {
                endRetainHandle?.cancel()
                startKeepingExitedValues(key)
            }
        }
    }
}
</code></pre>

<p><code>PresenceIndicator</code> å¯ç»„åˆé¡¹æ˜¯ä¸€ç§å·§å¦™çš„æ¨¡å¼ã€‚å®ƒæŒ‰ç»„åˆé¡ºåºæ”¾ç½®åœ¨å†…å®¹<strong>ä¹‹å</strong>ï¼Œä»¥ç¡®ä¿æ­£ç¡®çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€‚ç§»é™¤æ—¶ï¼Œå®ƒä¼šè§¦å‘ä¿ç•™ã€‚æ·»åŠ æ—¶ï¼Œå®ƒä¼šå®‰æ’åœ¨å¸§å®Œæˆååœæ­¢ä¿ç•™ã€‚</p>

<h2>å†…å­˜å’Œæ€§èƒ½è€ƒé‡</h2>

<p>è¯¥å®ç°ä¸­è¿›è¡Œäº†å€¼å¾—ç†è§£çš„æƒè¡¡ï¼š</p>

<p><strong>å†…å­˜ä¼˜å…ˆäº CPU</strong>ï¼šä¿ç•™å€¼åœ¨å†…å­˜ä¸­ä¿ç•™çš„æ—¶é—´æ¯” <code>remember{}</code> æ›´é•¿ã€‚è¿™ç”¨å†…å­˜æ¢å–äº†é‡æ–°åˆ›å»ºæ—¶çš„ CPU å¼€é”€ã€‚å¯¹äºå¼€é”€è¾ƒå¤§çš„å¯¹è±¡ï¼ˆä¾‹å¦‚ä½å›¾ã€åª’ä½“æ’­æ”¾å™¨ï¼‰ï¼Œè¿™é€šå¸¸æ˜¯å€¼å¾—çš„ã€‚</p>

<p><strong>O(n) èŒƒå›´æ“ä½œ</strong>ï¼šæŸ¥æ‰¾è¦æ¢å¤æˆ–é€€å‡ºçš„å€¼éœ€è¦è¿­ä»£å­˜å‚¨çš„å€¼ã€‚å¯¹äºåŒ…å«æ•°åä¸ªä¿ç•™å€¼çš„å…¸å‹ç”¨ä¾‹ï¼Œè¿™å¯ä»¥å¿½ç•¥ä¸è®¡ã€‚</p>

<p><strong>æƒ°æ€§åˆ†é…</strong>ï¼šä»…åœ¨éœ€è¦æ—¶åˆ†é…ç¼“å†²åŒºå’Œå­˜å‚¨ç©ºé—´ã€‚æœªä½¿ç”¨çš„ <code>RetainScope</code> å¼€é”€æå°ã€‚</p>

<p><strong>é€šè¿‡å…·ä½“åŒ–å®ç°ç±»å‹å®‰å…¨</strong>ï¼šå†…è”/å…·ä½“åŒ–æ¨¡å¼æ¶ˆé™¤äº†è¿è¡Œæ—¶ç±»å‹æ£€æŸ¥çš„éœ€è¦ï¼ŒåŒæ—¶ä¿æŒäº†ç±»å‹å®‰å…¨ã€‚</p>

<p><strong>é»˜è®¤ä¸ºç»„åˆèŒƒå›´</strong>ï¼šä¸ ViewModelï¼ˆåº”ç”¨èŒƒå›´ï¼‰æˆ– rememberSaveableï¼ˆActivityèŒƒå›´ï¼‰ä¸åŒï¼Œretain æ˜¯ç»„åˆèŒƒå›´çš„ï¼Œå¯ä»¥å¯¹ä¿ç•™è¾¹ç•Œè¿›è¡Œç»†ç²’åº¦çš„æ§åˆ¶ã€‚</p>

<p>å¦å¤–ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¸è¦å°†é•¿æœŸå­˜æ´»çš„å¯¹è±¡ä¿ç•™åœ¨å…¶é¢„æœŸä½œç”¨åŸŸä¹‹å¤–ï¼Œä»¥å…é€ æˆå†…å­˜æ³„æ¼ï¼Œæ­£å¦‚ Compose åº“ä¸­çš„ä»¥ä¸‹æ³¨é‡Šæ‰€ç¤ºã€‚</p>

<pre><code class="kotlin">/**
 * é‡è¦æç¤ºï¼šä¿ç•™å€¼çš„ä¿å­˜æ—¶é—´æ¯”å…¶æ‰€å…³è”çš„å¯ç»„åˆé¡¹çš„ç”Ÿå‘½å‘¨æœŸé•¿ã€‚
 * å¦‚æœä¿ç•™å¯¹è±¡çš„ä¿å­˜æ—¶é—´è¶…è¿‡å…¶é¢„æœŸçš„
 * ç”Ÿå‘½å‘¨æœŸï¼Œåˆ™å¯èƒ½å¯¼è‡´å†…å­˜æ³„æ¼ã€‚è¯·è°¨æ…é€‰æ‹©ä¿ç•™çš„æ•°æ®ç±»å‹ã€‚åˆ‡å‹¿ä¿ç•™ Android ä¸Šä¸‹æ–‡æˆ–
 * ç›´æ¥æˆ–é—´æ¥å¼•ç”¨ä¸Šä¸‹æ–‡ï¼ˆåŒ…æ‹¬è§†å›¾ï¼‰çš„å¯¹è±¡ã€‚
 */
</code></pre>

<h2>æµ‹è¯•ä¿ç•™æœºåˆ¶</h2>

<p>ä¸€ä¸ªæœ‰è¶£çš„<a href="https://github.com/androidx/androidx/blob/942319dfe9d751390febcef640d43290886f1a0b/compose/runtime/runtime-retain/src/commonTest/kotlin/androidx/compose/runtime/retain/RetainTests.kt#L866">å†…éƒ¨å•å…ƒæµ‹è¯•ç”¨ä¾‹</a> è¡¨æ˜ï¼Œè¯¥åº“å¯ä»¥å¤„ç†è¾¹ç¼˜æƒ…å†µå¹¶ä¿è¯ï¼š</p>

<pre><code class="kotlin">@Test
fun retain_duplicateRetainKeys() = compositionTest {
    val scope = ControlledRetainScope().apply { startKeepingExitedValues() }
    var showContent = true

    compose {
        CompositionLocalProvider(value = LocalRetainScope provides scope) {
            if (showContent) {
                // All have same key!
                retain { CountingRetainObject() }
                retain { CountingRetainObject() }
                retain { CountingRetainObject() }
            }
        }
    }

    // Hide and show content
    showContent = false
    recomposeScope.invalidate()
    advance()

    showContent = true
    recomposeScope.invalidate()
    advance()

    // All values correctly restored despite duplicate keys
}
</code></pre>

<p>æµ‹è¯•éªŒè¯äº†å³ä½¿å­˜åœ¨é‡å¤çš„é”®ï¼ˆåœ¨å¾ªç¯æˆ–ç”Ÿæˆçš„å†…å®¹ä¸­å¾ˆå¸¸è§ï¼‰ï¼Œå€¼ä¹Ÿèƒ½é€šè¿‡åè¿›å…ˆå‡º (LIFO) é¡ºåºä¸å…¶ä¿ç•™è°ƒç”¨æ­£ç¡®é…å¯¹ã€‚</p>

<h2>ç»“è®º</h2>

<p>åœ¨æœ¬æ–‡ä¸­ï¼Œæˆ‘ä»¬æ¢ç´¢äº† <code>retain{}</code>ã€<code>RetainScope</code>ã€<code>RetainObserver</code> å’Œ <code>RetainedEffect</code> API çš„å·¥ä½œåŸç†åŠå…¶å†…éƒ¨æœºåˆ¶ã€‚äº†è§£è¿™äº›å†…éƒ¨æœºåˆ¶æœ‰åŠ©äºæˆ‘ä»¬æ›´å¥½åœ°å†³å®šä½•æ—¶ä½¿ç”¨ <code>retain{}</code>ã€<code>remember{}</code> å’Œ <code>rememberSaveable{}</code>ï¼Œå¦‚ä½•æ„å»ºä¿ç•™èµ„æºï¼Œä»¥åŠé¢„æœŸçš„æ€§èƒ½ç‰¹å¾ã€‚</p>

<p>æ— è®ºæ˜¯æ„å»ºå¯æ—‹è½¬çš„è§†é¢‘æ’­æ”¾å™¨ã€ä¿ç•™æ»šåŠ¨ä½ç½®çš„å¯¼èˆªç³»ç»Ÿï¼Œè¿˜æ˜¯åœ¨é…ç½®æ›´æ”¹åä¿æŒçŠ¶æ€çš„å¤æ‚è¡¨å•ï¼Œ<code>retain{}</code> éƒ½èƒ½åœ¨ Jetpack Compose ä¸­æä¾›åŸºäºä½œç”¨åŸŸçš„çŠ¶æ€ä¿å­˜åŠŸèƒ½ã€‚</p>

<p>å¦‚æœä½ æƒ³äº†è§£æœ€æ–°çš„æŠ€èƒ½ã€æ–°é—»ã€æŠ€æœ¯æ–‡ç« ã€é¢è¯•é—®é¢˜å’Œå®ç”¨ä»£ç æŠ€å·§ï¼Œè¯·æŸ¥çœ‹ <a href="https://github.com/doveletter/">Dove Letter</a>ã€‚å¦‚æœä½ æƒ³æ·±å…¥äº†è§£é¢è¯•å‡†å¤‡ï¼Œåƒä¸‡ä¸è¦é”™è¿‡ç»ˆæ Android é¢è¯•æŒ‡å—ï¼š<a href="https://www.android.skydoves.me/">Manifest Android Interview</a>ã€‚</p>
]]></content>
  </entry>
  
</feed>
