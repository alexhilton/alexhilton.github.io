<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Compose | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/compose/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2025-08-18T22:25:11+08:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深入浅出着色器：极坐标系与炫酷环形进度条]]></title>
    <link href="https://alexhilton.github.io/blog/2025/08/18/circle-bar-with-shader/"/>
    <updated>2025-08-18T22:20:10+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/08/18/circle-bar-with-shader</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Circle bars with AGSL」，原文链接<a href="https://medium.com/@off.mind.by/circle-bars-with-agsl-37d0612c34a2">https://medium.com/@off.mind.by/circle-bars-with-agsl-37d0612c34a2</a>，由Alex Volkov发布于2025年1月6日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:2000/1*eA4A8yhl-BSTW4EoFMDRJw.jpeg" title="auto auto" ></a></p>

<!-- more -->


<p>大家好！今天，我将向大家讲解如何使用极坐标系。这是一个重要但又相当简单的主题，因此我选择了一个直截了当的效果，以避免过多地深入讲解其他细节。与往常一样，本教程分为几个部分。首先，我将概述设置着色器所需的最简 Compose 代码。在第二部分中，我将详细解释着色器本身以及使用极坐标的原理。最后，我们将进行一些收尾工作，使效果更加惊艳。</p>

<p>最终，我们将实现如下效果：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1000/1*RA4vKEMtnGVL78RVxe9Avg.gif" alt="" /></p>

<blockquote><p>在深入探讨之前，我想提醒你，我并没有为每个效果创建教程。不过，所有效果都可以在我的 <a href="https://github.com/AleksiejVolkov/runtimeshaders">GitHub</a> （链接：<a href="https://github.com/AleksiejVolkov/runtimeshaders%EF%BC%89%E4%B8%8A%E6%89%BE%E5%88%B0%E3%80%82%E4%BD%A0%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%88%91%E7%9A%84">https://github.com/AleksiejVolkov/runtimeshaders%EF%BC%89%E4%B8%8A%E6%89%BE%E5%88%B0%E3%80%82%E4%BD%A0%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%88%91%E7%9A%84</a> <a href="https://t.me/droidshaderworks">Telegram 频道</a> 中找到视频、新效果的公告以及问题的解答。期待在那里见到你！</p></blockquote>

<p>和往常一样，让我们从布局开始。我将基础 Compose 组件命名为“TimerShaderScreen”。在组件内部，我们将从一个“Column”容器开始，该容器顶部包含一个输入字段，后面跟着一个“Box”。这个“Box”在同一层级上包含一个将应用着色器的“Box”和一个显示当前计时器值的“Text”元素（这一点很重要）。从技术上讲，我们可以只使用一个“Box”，但这会使着色器稍微复杂一些。为了简化本教程，我选择了稍微复杂的构图，以使着色器保持简洁。在这个“Box”之后，有一个用于启动计时器的按钮。我提供了一个布局图，以便更清晰地展示，但总的来说，布局本身已经非常简单了。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*oIa0bosA1IbHuMZVKw9tFw.png" alt="" /></p>

<p>接下来，让我们添加必要的变量并定义整个布局。由于我们尚未准备好着色器，因此你可以暂时跳过“RuntimeShader”变量，只需运行项目并确保一切正常即可。我想强调一个重要的细节：如果你将着色器应用于一个不包含任何内容的“Box”，则需要为其设置背景颜色。这确保它参与合成，从而使我们的效果可见。但是，务必在应用“graphicsLayer”之后设置背景颜色。否则，只会渲染颜色，着色器将不可见。目前，布局应该如下所示：</p>

<pre><code class="kotlin">@Composable
fun TimerShaderScreen(paddingValues: PaddingValues) {
    var startValue by remember { mutableStateOf(20) }
    var percentage by remember { mutableFloatStateOf(0.0f) }
    var isRunning by remember { mutableStateOf(false) }
    val seconds = remember { mutableStateOf(startValue) }

    // circularTimeShader是一个包含着色器代码的字符串对象，我们将在下面的部分中编写
    val shader = remember { RuntimeShader(circularTimerShader) }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(paddingValues),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        OutlinedTextField(
            value = if (startValue != 0) startValue.toString() else "",
            onValueChange = {
                startValue = it.toIntOrNull() ?: 0
            },
            label = { Text("Start value") },
            modifier = Modifier.width(200.dp)
        )
        Box(
            modifier = Modifier.size(250.dp),
            contentAlignment = Alignment.Center
        ) {
            Box(
                modifier = Modifier
                    .size(250.dp)
                    .onSizeChanged {
                        shader.setFloatUniform("resolution", it.width.toFloat(), it.height.toFloat())
                    }
                    .graphicsLayer {
                        shader.setFloatUniform("percentage", percentage)
                        renderEffect = RenderEffect.createRuntimeShaderEffect(shader, "image").asComposeRenderEffect()
                    }
                    .background(color = Color.Black), // &lt;-- 我们必须添加一些颜色，否则空框就会从构图中移除，就看不出效果了
            )

            Text(
                modifier = Modifier
                    .fillMaxWidth(),
                textAlign = TextAlign.Center,
                text = seconds.toString(),
                fontSize = 50.sp,
                fontWeight = FontWeight.Thin,
                color = Color.White
            )
        }

        OutlinedButton(
            onClick = { isRunning = !isRunning },
            modifier = Modifier.padding(top = 16.dp)
        ) {
            Text(if (isRunning) "Stop" else "Start")
        }
    }
}
</code></pre>

<p>这是它在手机上的实际显示效果：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:924/1*HPGAGRtgTmxrihj91xiRXw.png" alt="" /></p>

<p>剩下的就是添加计时器本身的逻辑，然后我们就可以开始进入正文了。首先，让我们创建一个 <code>LaunchedEffect</code> 来在计时器运行时更新其值。同时，我们将在此代码块中计算着色器的 <code>percentage</code>。由于我们的着色器会从计时器的起始值向下过渡到零，因此我们需要对 <code>percentage</code> 变量进行归一化，使其相应地从 0 变为 1。代码如下：</p>

<pre><code class="kotlin">LaunchedEffect(isRunning) {
    val startTime = System.currentTimeMillis()
    while (isRunning) {
        if (seconds.value &lt; 0) { isRunning = false } // 时间到时停止倒计时

        val elapsedTime = System.currentTimeMillis() - startTime // 已用时间（单位是毫秒）
        percentage = (elapsedTime / 1000f) / startValue // 将经过的时间归一化为[0,1]

        // 将百分比限制在 [0, 1] 之间以避免过冲
        percentage = percentage.coerceIn(0f, 1f)

        // 计算剩余秒数
        seconds.value = ((startValue - (elapsedTime / 1000f))).toInt()

        delay(10) // 延迟以控制更新频率
    }
}
</code></pre>

<p>Compose 部分就到此为止；让我们继续编写着色器吧！</p>

<p>首先，让我们定义来自 UI 的变量，以及着色器的最低设置。现在，我们将返回像素与归一化坐标中心的距离，作为颜色：<code>length(uv)</code>。如果这部分内容不太清楚，强烈建议你查看我的<a href="https://juejin.cn/post/7535292253813981247">教程</a>，了解如何在 Android 中使用着色器。</p>

<pre><code class="kotlin">private val circularTimerShader = """
    uniform float time;
    uniform float percentage;
    uniform vec2 resolution;
    uniform shader image;

    vec4 main(float2 fragCoord) {
        float2 uv = fragCoord / resolution - 0.5; // 归一化坐标
        uv.x *= resolution.x / resolution.y;
        return vec4(length(uv));
    }
""".trimIndent()
</code></pre>

<p>因此，目前我们得到的大致如下：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1000/1*e2GHAO-1N7K0KBjN4wAYww.png" alt="" /></p>

<p>现在，让我们尝试在标准笛卡尔平面上绘制一个“栅栏”，即一系列垂直的条形。如何实现这个效果？首先，我们将 y 轴上的所有值限制在零以下。着色器现在如下所示：</p>

<pre><code class="glsl">vec4 main(float2 fragCoord) {
    float2 uv = fragCoord / resolution - 0.5; // 归一化坐标
    uv.x *= resolution.x / resolution.y;

    vec3 color = vec3(1.) * step(uv.y, 0.0);

    return vec4(color, 1.0);
}
</code></pre>

<p>接下来，我们还将沿 x 轴裁剪掉一半的区域。记住，我们的 <code>uv</code> 坐标偏移了 0.5，使零点位于中心。这样，我们也可以沿 x 轴在零点处裁剪，只留下右上象限。</p>

<pre><code class="glsl">float fence = step(0.0, uv.x);
vec3 color = vec3(1.) * step(uv.y, 0.0) * fence;
</code></pre>

<p>现在，如果我们将 x 轴上的坐标乘以 10，并只取小数部分，我们将得到如下所示的 x 轴值：<code>[0...1, 0...1, 0...1, ...]</code>。再将它们平移 0.5，我们就得到了“栅栏”。下面，我演示了构建垂直条的三个步骤。</p>

<pre><code class="glsl">vec4 main(float2 fragCoord) {
    float2 uv = fragCoord / resolution - 0.5; // 归一化坐标
    uv.x *= resolution.x / resolution.y;

    float fence = step(0.0, fract(uv.x * 10.) - 0.5);
    vec3 color = vec3(1.0) * step(uv.y, 0.0) * fence;

    return vec4(color, 1.0);
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*l7X_24sRzAI7iYZLqeWKFQ.png" alt="" /></p>

<p>现在到了最激动人心的部分：如何从笛卡尔坐标系过渡到极坐标系？换句话说，如何创建相同的“栅栏”，但使其看起来像圆形？让我们来弄清楚。</p>

<p>我们习惯用两个值来描述函数：<code>x</code> 和 <code>y</code>。这使我们能够确定像素在平面上的精确位置并为其分配颜色。在我们的例子中，坐标系是 <code>uv</code>。为了垂直裁剪，我们使用 <code>y</code>；为了水平裁剪“栅栏”的各个部分，我们使用 <code>x</code>。</p>

<p>极坐标系与此非常相似，但我们使用的不是水平轴和垂直轴，而是半径（与原点的距离）和角度。</p>

<p>换句话说，由于这两个坐标系都包含两个分量，理解它们的含义使我们能够相对轻松地将笛卡尔坐标系中使用的公式和技术应用于极坐标系。然而，最终的图像看起来会“弯曲”成一个圆形。让我们尝试将“栅栏”转换为极坐标：</p>

<pre><code class="glsl">vec2 cartesianToPolar(vec2 uv) {
    float r = length(uv);
    float theta = atan(uv.y, uv.x);
    return vec2(r, theta);
}vec4 main(float2 fragCoord) {
    float2 uv = fragCoord / resolution - 0.5; // 归一化坐标
    uv.x *= resolution.x / resolution.y;

    // 转换为极坐标
    vec2 polar = cartesianToPolar(uv);

    float r = polar.x; // 半径

    float theta = polar.y; // 角度

    float fence = step( 0.5, fract(theta * 10.0));
    vec3 color = vec3(1.) * step(0.5, r) * fence;

    return vec4(color, 1.0);
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1000/1*UR389J0im6ziWvc_d9ERzA.png" alt="极坐标系中的“栅栏”" /></p>

<p>但是，你可能会注意到，光线的宽度随着远离中心而增加。我们可以添加补偿来消除这种影响。</p>

<pre><code class="glsl">// 宽度已调整的进度条
float width = 0.02; // Bar width
float adjustedWidth = width / max(r, 0.001); // 补偿径向缩放
float fence = step( 0.5 - adjustedWidth, fract(theta * 10.0));
</code></pre>

<p>接下来，我们不仅需要限制内半径，还需要限制外半径，以创建一个环，而不是无限延伸的光线。</p>

<pre><code class="glsl">// 将波浪蒙版均匀地涂抹在进度条上
float barRadius = 0.3;
float barMask = smoothstep(barRadius+0.01, barRadius, r);
</code></pre>

<p>总的来说，此时它看起来应该像这样：</p>

<pre><code class="glsl">vec4 main(float2 fragCoord) {
    float2 uv = fragCoord / resolution - 0.5; // 归一化坐标
    uv.x *= resolution.x / resolution.y;

    float width = 0.02; // 进度条宽度

    // 转化为极坐标
    vec2 polar = cartesianToPolar(uv);
    float r = polar.x;

    // 半径
    float theta = polar.y;

    // 角度
    float innerMask = step(0.3, r);

    // 宽度已调整的进度条
    float adjustedWidth = width / max(r, 0.001); // 补偿径向缩放
    float fence = step( 0.5 - adjustedWidth, fract(theta * 10.0));

    // 将波浪蒙版均匀地涂抹在进度条上
    float barRadius = 0.3;
    float barMask = smoothstep(barRadius+0.01, barRadius, r);

    // 结合进度条和内层蒙版
    float combinedMask = barMask * fence * innerMask;

    vec3 col = vec3(1.0) * combinedMask;

    return vec4(col, 1.0);
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1288/1*B_VJQme_vnEdXq0pEmfLZg.png" alt="" /></p>

<p>最后一步是根据 <code>percentage</code> 的值增加列的大小。这里需要注意的是，角度 <code>theta</code> 的当前范围是从 <code>-Pi</code> 到 <code>Pi</code>，因此需要对其进行归一化，即将其转换为从 <code>0</code> 到 <code>1</code> 的范围。这样可以更容易地将其与 <code>percentage</code> 的值对齐，因为 <code>percentage</code> 的值也是从 <code>0</code> 到 <code>1</code> 变化的。</p>

<pre><code class="glsl">// 还将其移动，使零位于顶部而不是左侧
float normalizedAngle = mod((theta + 1.57079632679) / 6.28318530718, 1.0); 
</code></pre>

<p>现在我们可以为“wave”应用另一个蒙版，它将取决于 <code>percentage</code> 变量的当前值。</p>

<pre><code class="glsl">// 计算条形中心的波浪蒙版
float wave = smoothstep(fixPercentage, fixPercentage - 0.1, centerNormalizedAngle);
float waveMask = smoothstep(0.32 + 0.1 * wave, 0.31 + 0.1 * wave, r);
</code></pre>

<p>我们还需要将这个波浪的值添加到 <code>barRadius</code> 中，并在最后将整体遮罩乘以 <code>waveMask</code>。此外，我将最终 Alpha 值的常量值替换为组合遮罩的值。这样，我们现在得到了一个几乎完整的效果。</p>

<pre><code class="glsl">// 其余代码 ...

float barRadius = 0.3 + 0.1 * wave; // 使用波形蒙版设置条形半径

// ...

float combinedMask = barMask * fence * innerMask * waveMask;
vec3 col = vec3(1.0) * combinedMask;

return vec4(col, combinedMask);
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1000/1*ZduMs_yVlmd5r7CxADMpRQ.gif" alt="" /></p>

<p>我想在本节中添加的最后一点是稍微优化一下蒙版。你可能已经注意到，每个列的左右边缘半径不同，但我希望它们的高度一致。这样可以使效果看起来更简洁一些。以下是实现方法：</p>

<pre><code class="glsl">// 在每个条形的中心采样波形蒙版
float barIndex = floor(theta * 10.0); // 确定条的索引
float centerTheta = (barIndex + 0.5) / 10.0; // 条的中心角
float centerNormalizedAngle = mod((centerTheta + 1.57079632679) / 6.28318530718, 1.0);

// 计算条形中心的波浪蒙版
float wave = smoothstep(fixPercentage, fixPercentage - 0.1, centerNormalizedAngle);
float waveMask = smoothstep(0.32 + 0.1 * wave, 0.31 + 0.1 * wave, r);
</code></pre>

<p>总的来说，核心效果现在已经完成。然而，在着色器中，通常情况下，99% 复杂而有趣的工作构成了效果的基础，但单独来看，效果可能看起来简单平淡。正是这最后的 1% 的润色，才能彻底改变一切！</p>

<p>让我们为着色器添加一个渐变。我使用了最简单的一个，它在 <a href="http://shadertoy.com/">ShaderToy</a> （链接：<a href="http://shadertoy.com/%EF%BC%89%E4%B8%AD%E5%90%AF%E5%8A%A8%E6%96%B0%E9%A1%B9%E7%9B%AE%E6%97%B6%E9%BB%98%E8%AE%A4%E5%88%9B%E5%BB%BA%EF%BC%88%E4%BD%A0%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%E5%B9%B6%E7%82%B9%E5%87%BB%E5%8F%B3%E4%B8%8A%E8%A7%92%E7%9A%84%E2%80%9C%E6%96%B0%E5%BB%BA%E2%80%9D%E6%8C%89%E9%92%AE%E6%9F%A5%E7%9C%8B%EF%BC%89%E3%80%82%E6%88%91%E6%8A%8A%E5%AE%83%E7%A7%BB%E5%88%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E5%8D%95%E7%8B%AC%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%AD%EF%BC%8C%E5%B9%B6%E5%B0%86%E5%85%B6%E5%91%BD%E5%90%8D%E4%B8%BA">http://shadertoy.com/%EF%BC%89%E4%B8%AD%E5%90%AF%E5%8A%A8%E6%96%B0%E9%A1%B9%E7%9B%AE%E6%97%B6%E9%BB%98%E8%AE%A4%E5%88%9B%E5%BB%BA%EF%BC%88%E4%BD%A0%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%E5%B9%B6%E7%82%B9%E5%87%BB%E5%8F%B3%E4%B8%8A%E8%A7%92%E7%9A%84%E2%80%9C%E6%96%B0%E5%BB%BA%E2%80%9D%E6%8C%89%E9%92%AE%E6%9F%A5%E7%9C%8B%EF%BC%89%E3%80%82%E6%88%91%E6%8A%8A%E5%AE%83%E7%A7%BB%E5%88%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E5%8D%95%E7%8B%AC%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%AD%EF%BC%8C%E5%B9%B6%E5%B0%86%E5%85%B6%E5%91%BD%E5%90%8D%E4%B8%BA</a> <code>gradient</code>：</p>

<pre><code class="glsl"> vec3 gradient(vec2 uv, float t) {
        return 0.5 + 0.5 * cos(t + uv.xyx + vec3(0, 2, 4));
 }
</code></pre>

<p>现在，我不再将最终颜色乘以 <code>vec3(1.)</code>（即白色），而是将其乘以我们刚刚创建的渐变。此外，我还对其余区域应用了相同的渐变，但 Alpha 值非常低，这为整个屏幕增添了微妙的辉光。</p>

<blockquote><p>请注意，要看到这个效果，我们还必须从 Compose 代码中传递 <code>time</code>。</p></blockquote>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*DXGRdfXQ67eQG7UMnMy8lw.png" alt="" /></p>

<p>现在，让我们转到项目的可组合部分，并在文本变化时添加动画和模糊效果。我不会详细介绍这一点，因为这超出了本课的范围。但是，如果本教程完全不包含代码，感觉不太对劲。所以，以下是可组合部分（包含时间更新和文本动画）的最终版本：</p>

<pre><code class="kotlin">@Composable
fun TimerShaderScreen(paddingValues: PaddingValues) {
    var startValue by remember { mutableStateOf(20) }
    var percentage by remember { mutableFloatStateOf(0.0f) }
    var isRunning by remember { mutableStateOf(false) }

    val shader = remember { RuntimeShader(circularTimerShader) }

    var time by remember { mutableStateOf(0f) }

    LaunchedEffect(null) {
        while (true) {
            time += 0.01f
            delay(10)
        }
    }

    val seconds = remember { mutableStateOf(startValue) }

    LaunchedEffect(isRunning) {
        val startTime = System.currentTimeMillis()
        while (isRunning) {
            if (seconds.value &lt; 0) { isRunning = false } // 时间到时停止倒计时

            val elapsedTime = System.currentTimeMillis() - startTime // 已用时间（单位是毫秒）
            percentage = (elapsedTime / 1000f) / startValue // 将经过的时间归一化为[0,1]

            // 将百分比限制在 [0, 1] 之间以避免过冲
            percentage = percentage.coerceIn(0f, 1f)

            // 计算剩余秒数
            seconds.value = ((startValue - (elapsedTime / 1000f))).toInt()

            delay(10) // 延迟以控制更新频率
        }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(paddingValues),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        OutlinedTextField(
            value = if (startValue != 0) startValue.toString() else "",
            onValueChange = {
                startValue = it.toIntOrNull() ?: 0
            },
            label = { Text("Start value") },
            modifier = Modifier.width(200.dp)
        )
        Box(
            modifier = Modifier.size(250.dp),
            contentAlignment = Alignment.Center
        ) {
            Box(
                modifier = Modifier
                    .size(250.dp)
                    .onSizeChanged {
                        shader.setFloatUniform("resolution", it.width.toFloat(), it.height.toFloat())
                    }
                    .graphicsLayer {
                        shader.setFloatUniform("percentage", percentage)
                        shader.setFloatUniform("time", time)
                        renderEffect = RenderEffect.createRuntimeShaderEffect(shader, "image").asComposeRenderEffect()
                    }
                    .background(color = Color.Black),
            )
            var previousSeconds by remember { mutableStateOf(seconds.value.coerceAtLeast(0)) }

            AnimatedContent(
                targetState = seconds.value.coerceAtLeast(0),
                transitionSpec = {
                    (slideInVertically(animationSpec = tween(500)) { height -&gt; -height } + fadeIn(
                        animationSpec = tween(
                            500
                        )
                    ))
                        .togetherWith(slideOutVertically(animationSpec = tween(500)) { height -&gt; height } + fadeOut(
                            tween(500)
                        ))
                },
                label = "CountdownAnimation"
            ) { targetSeconds -&gt;
                // 检测是否正在转换
                val isTransitioning = targetSeconds != previousSeconds

                // 过渡期间模糊动画
                val blurRadius by animateFloatAsState(
                    targetValue = if (isTransitioning) 30f else 0f, // 过渡时模糊
                    animationSpec = tween(durationMillis = 500) // 匹配过渡持续时间
                )

                // 转换完成后更新 previousSeconds
                LaunchedEffect(targetSeconds) {
                    previousSeconds = targetSeconds
                }

                Text(
                    modifier = Modifier
                        .fillMaxWidth()
                        .graphicsLayer {
                            // 应用动画模糊效果
                            renderEffect = RenderEffect.createBlurEffect(
                                blurRadius, blurRadius, android.graphics.Shader.TileMode.CLAMP
                            ).asComposeRenderEffect()
                        },
                    textAlign = androidx.compose.ui.text.style.TextAlign.Center,
                    text = targetSeconds.toString(),
                    fontSize = 50.sp,
                    fontWeight = androidx.compose.ui.text.font.FontWeight.Thin,
                    color = Color.White
                )
            }
        }

        OutlinedButton(
            onClick = { isRunning = !isRunning },
            modifier = Modifier.padding(top = 16.dp)
        ) {
            Text(if (isRunning) "Stop" else "Start")
        }
    }
}
</code></pre>

<p>以及最终的着色器代码：</p>

<pre><code class="glsl">uniform float time;
uniform float percentage;
uniform vec2 resolution;
uniform shader image;vec2 cartesianToPolar(vec2 uv) {
    float r = length(uv);
    float theta = atan(uv.y, uv.x);
    return vec2(r, theta);
}vec3 gradient(vec2 uv, float t) {
    return 0.5 + 0.5 * cos(t + uv.xyx + vec3(0, 2, 4));
}vec4 main(float2 fragCoord) {
    float2 uv = fragCoord / resolution - 0.5; // 归一化坐标
    uv.x *= resolution.x / resolution.y;

    float width = 0.02; // 条形宽度

    // 转换为极坐标
    vec2 polar = cartesianToPolar(uv);
    float r = polar.x; // 半径

    float theta = polar.y;    // 角度

    float innerMask = step(0.3, r);

    // 将顶部设为零，使角度标准化
    float normalizedAngle = mod((theta + 1.57079632679) / 6.28318530718, 1.0);

    // 固定百分比补偿
    float fixPercentage = percentage + percentage * 0.1;

    // 在每个条形的中心采样波形蒙板
    float barIndex = floor(theta * 10.0); // 确定条的索引
    float centerTheta = (barIndex + 0.5) / 10.0; // 条的中心角
    float centerNormalizedAngle = mod((centerTheta + 1.57079632679) / 6.28318530718, 1.0);

    // 计算条形中心的波浪蒙板
    float wave = smoothstep(fixPercentage, fixPercentage - 0.1, centerNormalizedAngle);
    float waveMask = smoothstep(0.32 + 0.1 * wave, 0.31 + 0.1 * wave, r);

    // 宽度已调整的条形图案
    float adjustedWidth = width / max(r, 0.001); // 补偿径向缩放
    float fence = step( 0.5 - adjustedWidth, fract(theta * 10.0));

    // 将波浪蒙版均匀地涂抹在吧台上
    float barRadius = 0.3 + 0.1 * wave; // 使用波形蒙版设置条形半径
    float barMask = smoothstep(barRadius+0.01, barRadius, r);

    // 结合条形和内层蒙版
    float combinedMask = barMask * fence * innerMask * waveMask;

    vec3 grad = gradient(uv, time);
    vec3 col = grad * combinedMask;

    return vec4(col + grad * 0.1, combinedMask + length(uv));
}
</code></pre>

<p>感谢阅读！如果你觉得我的实验有趣且讲解有帮助，欢迎加入我的<a href="https://t.me/droidshaderworks">Telegram频道</a>或在<a href="https://x.com/KrowaNaMostku">Twitter (X)</a>上关注我。你的支持意义重大，并激励着我。祝你撸码愉快！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用Compose中的Shader实现一个雪花飘飘弹窗效果]]></title>
    <link href="https://alexhilton.github.io/blog/2025/08/17/snow-dialog-shader/"/>
    <updated>2025-08-17T22:02:24+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/08/17/snow-dialog-shader</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Snow Dialog Shader Tutorial」，原文链接<a href="https://medium.com/@off.mind.by/snow-dialog-shader-tutorial-dde1b4a61e20">https://medium.com/@off.mind.by/snow-dialog-shader-tutorial-dde1b4a61e20</a>，由Alex Volkov发布于2024年12月27日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:2000/1*oNN6ZtalbQEvYCpTx8gLWg.png" title="auto auto" ></a></p>

<!-- more -->


<p>大家好！在本教程中，我将向大家展示如何创建雪花覆盖的对话框效果。总的来说，该效果可以分为三个部分。</p>

<ol>
<li><strong>设置 Compose 代码</strong>：这确保了基础效果的实现。</li>
<li><strong>创建对话框底部积雪的着色器</strong>：这是我在今天教程中重点讲解的核心效果。</li>
<li><strong>添加飘落的雪花</strong>：为此，我在 ShaderToy 上找到了一个现成的着色器，并对其进行了一些优化，使其不会对手机性能造成太大负担。第三部分将包含原始着色器的链接以及一些优化说明。</li>
</ol>


<p>本教程主要讲解如何为对话框创建不断增长的雪盖效果。</p>

<p>最终效果如下：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:804/1*SRa57BglcDzpLzAAw1UAPw.gif" alt="最终效果" /></p>

<blockquote><p>在深入探讨之前，我想提醒你，我并没有为所有效果创建教程。不过，所有效果都可以在我的 <a href="https://github.com/AleksiejVolkov/runtimeshaders">GitHub</a> （链接：<a href="https://github.com/AleksiejVolkov/runtimeshaders%EF%BC%89%E4%B8%8A%E6%89%BE%E5%88%B0%E3%80%82%E4%BD%A0%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%88%91%E7%9A%84">https://github.com/AleksiejVolkov/runtimeshaders%EF%BC%89%E4%B8%8A%E6%89%BE%E5%88%B0%E3%80%82%E4%BD%A0%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%88%91%E7%9A%84</a> <a href="https://t.me/droidshaderworks">Telegram 频道</a> （链接：<a href="https://t.me/droidshaderworks%EF%BC%89%E4%B8%AD%E6%89%BE%E5%88%B0%E8%A7%86%E9%A2%91%E3%80%81%E6%96%B0%E6%95%88%E6%9E%9C%E5%85%AC%E5%91%8A%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E7%AD%94%E3%80%82%E6%9C%9F%E5%BE%85%E5%9C%A8%E9%82%A3%E9%87%8C%E8%A7%81%E5%88%B0%E4%BD%A0%EF%BC%81">https://t.me/droidshaderworks%EF%BC%89%E4%B8%AD%E6%89%BE%E5%88%B0%E8%A7%86%E9%A2%91%E3%80%81%E6%96%B0%E6%95%88%E6%9E%9C%E5%85%AC%E5%91%8A%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E7%AD%94%E3%80%82%E6%9C%9F%E5%BE%85%E5%9C%A8%E9%82%A3%E9%87%8C%E8%A7%81%E5%88%B0%E4%BD%A0%EF%BC%81</a></p></blockquote>

<p>让我们从 Compose 中为效果设置一个最小页面开始。它包含一张背景图片和一个位于中心的按钮，用于触发对话框。</p>

<p>需要注意的是，对话框不应来自 Material 库，而应使用 Compose 中最基本的“AlertDialog”。</p>

<p>以下是最低配置：</p>

<pre><code class="Kotlin">@Composable
fun SnowDialogScreen() {
    var showDialog by remember { mutableStateOf(false) }  

    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Image(
            painter = painterResource(id = R.drawable.christmas_night),
            contentDescription = "Sample Image",
            contentScale = ContentScale.Crop,
            modifier = Modifier.fillMaxSize()
        )        if (!showDialog) {
            Button(onClick = { showDialog = true }) {
                Text("Ho-ho-ho!")
            }
        } else {
            SnowedDialog { showDialog = false }
        }
    }
}

@Composable
private fun SnowedDialog(onDismiss: () -&gt; Unit) {
    BasicAlertDialog(
        onDismissRequest = { onDismiss() },
        properties = DialogProperties(usePlatformDefaultWidth = false)
    ) {
        Column(
            Modifier
                .padding(horizontal = 16.dp)
                .background(shape = MaterialTheme.shapes.large, 
                            color = MaterialTheme.colorScheme.surface)
                .padding(16.dp),
        ) {
            Text("Merry Christmas!", style = MaterialTheme.typography.titleLarge)
            Spacer(modifier = Modifier.height(10.dp))
            Text("Happy New Year!")
            Spacer(modifier = Modifier.height(26.dp))
            Row(
                modifier = Modifier
                    .fillMaxWidth(),
                horizontalArrangement = Arrangement.End
            ) {
                Text(
                    modifier = Modifier
                        .clickable { onDismiss() }
                        .padding(5.dp),
                    text = "Close",
                    style = MaterialTheme.typography.bodyMedium.copy(color = MaterialTheme.colorScheme.primary)
                )
            }
        }
    }
}
</code></pre>

<p>最终，你应该得到类似这样的效果：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*fnlF56ZxRxMwa7vHkCOudA.png" alt="颜色可能会有所不同，此外观已针对暗黑模式进行了调整" /></p>

<p>现在我们可以开始编写着色器了！我将简要介绍如何设置着色器并将其附加到对话框中。有关运行时着色器的更详细介绍和初学者指南，你可以查看我的另一个<a href="https://juejin.cn/post/7535292253813981247">教程</a>。</p>

<p>开始使用着色器所需的最低要求如下所示。在对话框中，我们添加一个 <code>runtimeShader</code>，并使用 <code>graphicsLayer</code> 将其分配给 <code>Column</code>：</p>

<pre><code class="kotlin">@Composable
private fun SnowedDialog(onDismiss: () -&gt; Unit) {
    // 从字符串编译我们的着色器
    val snowCapShader = remember { RuntimeShader(snowCapShader) }  

    BasicAlertDialog(
        onDismissRequest = { onDismiss() },
        properties = DialogProperties(usePlatformDefaultWidth = false)
    ) {
        Column(
            Modifier
                .padding(horizontal = 16.dp)
                .background(shape = MaterialTheme.shapes.large, color = MaterialTheme.colorScheme.surface)
                .onSizeChanged { size -&gt;
                    // pass resolution
                    snowCapShader.setFloatUniform(
                        "resolution",
                        size.width.toFloat(),
                        size.height.toFloat()
                    )
                }
                .graphicsLayer {
                    // apply shader 
                    this.renderEffect = RenderEffect
                        .createRuntimeShaderEffect(snowCapShader, "image")
                        .asComposeRenderEffect()
                }
                .padding(16.dp),
        ) {
          // 其余代码保持不变

//...

@Language("agsl")
private val snowCapShader = """
    uniform shader image;
    uniform vec2 resolution;    
    vec4 main(float2 fragCoord) {
         float2 uv = fragCoord / resolution - 0.5;
         if(abs(uv.x)&gt;0.5 || abs(uv.y)&gt;0.5) {
             return vec4(0.0);
         }          
         float ratio = resolution.x / resolution.y;    
         uv.x *= ratio;        
         vec4 imageColor = image.eval(fragCoord);        
         return vec4(vec3(1.0), imageColor.a);
    }
""".trimIndent()
</code></pre>

<p>目前，它将显示为一个空白矩形，就像我们的对话框一样：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*C5O1IMHS7MvK0lFnIqHFYA.png" alt="" /></p>

<p>在继续之前，让我先尽可能简单地解释一下实现此效果背后的逻辑。我将算法分为四个概念步骤：</p>

<ol>
<li><strong>找到一个函数</strong>来定义雪边缘的轮廓。</li>
<li><strong>在 y 轴上</strong>绘制此函数上方的所有内容**，并将其垂直移向底部边缘。</li>
<li><strong>定义一个遮罩区域</strong>，这意味着在此区域之外，函数将被完全忽略，我们只需绘制着色器从系统接收的内容即可。</li>
<li><strong>修改侧面和顶部的遮罩</strong>，使雪的形状更自然，而底部边缘的轮廓则由我们的函数处理。</li>
</ol>


<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*Vbq5YEL42g1tQsLjWKAokQ.png" alt="" /></p>

<p>现在，让我们在着色器中按顺序实现这些步骤。为简单起见，我选择了一个基本的正弦波作为雪边缘的函数。我添加了一些系数来压缩它并降低其振幅：</p>

<pre><code class="glsl">float snowEdge = (sin(10.*uv.x)*0.5+0.5)*0.2;
</code></pre>

<p>接下来，我们需要用白色填充此线上方的所有内容，同时忽略其下方的所有内容。</p>

<pre><code class="glsl">vec4 snow = step(uv.y, snowEdge)*vec4(1.0);
</code></pre>

<blockquote><p>通过向 <code>uv.y</code> 添加一个常量，我们可以垂直移动整个函数。</p></blockquote>

<p>最后，我们需要将该方法移近对话框的底部边缘并添加一个遮罩。现在，我们使用一个简单的矩形区域作为遮罩。我们可以通过分别指定每个边缘来定义它。这种方法可能看起来有点冗长，但它使代码更容易理解：</p>

<pre><code class="glsl"> vec4 main(float2 fragCoord) {
         float2 uv = fragCoord / resolution - 0.5;        
         float ratio = resolution.x / resolution.y;    
         uv.x *= ratio;         

         float snowEdge = (sin(10.*uv.x)*0.5+0.5)*0.2;
         snowEdge = step(uv.y-0.4, snowEdge);       

         float topBound = 0.3;
         float leftBound = -.5*ratio;
         float rightBound = .5*ratio;        

         float snowMask = 0.;       
         if(uv.x &gt; leftBound &amp;&amp; uv.x &lt; rightBound &amp;&amp; uv.y &gt; topBound) {
            snowMask = 1.0;
         }
         snowMask *= snowEdge;        
         vec4 imageColor = image.eval(fragCoord);
         vec3 snowColor = vec3(1.0);       
         vec3 finalColor = mix(imageColor.rgb, snowColor, snowMask);      

         return vec4(finalColor, snowMask+imageColor.a);
    }
</code></pre>

<p>调整后，我们应该得到类似这样的结果。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*GM2d-tsCUOAHnloMiDYAAA.png" alt="" /></p>

<p>现在可能不是提及这一点的最佳时机，也许应该早点提及，但在这里强调这一点至关重要。请记住，我们对坐标进行了归一化，并对其进行了平移，使零点恰好位于画布（即对话框）的中心。具体操作如下：<code>_float2 uv = fragCoord/resolution — 0.5;_</code></p>

<p>理解这一点很重要，因为现在我想减小中心正弦波的振幅，并随着我们向左右两侧远离中心而增大振幅。理解坐标系的设置方式后，我们可以通过将函数乘以沿 x 轴距离中心的距离来实现这一点。这样，函数将在中心处恰好返回零点，并随着向外移动而增大。最终，我们将实现以下效果：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*oW8OP3R2VFo0SkJmDhgVSw.png" alt="" /></p>

<p>现在，让我们使用函数而不是常量来定义遮罩的顶部边界。现在，让我们使用另一个正弦波，但间隔等于对话框的宽度。</p>

<pre><code class="glsl">float topBound = (sin(ratio*uv.x*0.8+2.)*0.5+0.5)*.2+0.3;
</code></pre>

<p>我们将为左右边界添加类似的代码：我希望它们也使用正弦波，但这次是垂直运行的。</p>

<pre><code class="glsl">float leftBound = -.5*ratio+(sin(10.*uv.y)*0.5+0.5)*0.5*length(uv.y-topBound);
float rightBound = .5*ratio-(sin(10.*uv.y)*0.5+0.5)*0.4*length(uv.y-topBound);
</code></pre>

<p>最后，我们需要为底部边缘添加一个常量：这是一个时间变量，我们会将它从 Compose 传递给着色器。在着色器中，我们只需添加相应的 <code>uniform</code> 变量，并将底部边缘函数乘以它即可：</p>

<pre><code class="glsl">uniform shader image;
    uniform vec2 resolution;
    uniform float time;        vec4 main(float2 fragCoord) {
         float2 uv = fragCoord / resolution - 0.5;        

         float ratio = resolution.x / resolution.y;    
         uv.x *= ratio;         

         float adjustedTime = clamp(time * 0.3,0.0,1.0);
         float snowEdge = (sin(10.*uv.x)*0.5+0.5)*0.2 * length(uv.x)*adjustedTime;
         snowEdge = step(uv.y-0.5, snowEdge);       

         float topBound = (sin(ratio*uv.x*0.8+2.)*0.5+0.5)*.2+0.3;
         float leftBound = -.5*ratio+(sin(10.*uv.y)*0.5+0.5)*0.5*length(uv.y-topBound);
         float rightBound = .5*ratio-(sin(10.*uv.y)*0.5+0.5)*0.4*length(uv.y-topBound);                   

         float snowMask = 0.;         
         if(uv.x &gt; leftBound &amp;&amp; uv.x &lt; rightBound &amp;&amp; uv.y &gt; topBound) {
            snowMask = 1.0;
         }

         snowMask *= snowEdge;         

         vec4 imageColor = image.eval(fragCoord);
         vec3 snowColor = vec3(1.0);        
         vec3 finalColor = mix(imageColor.rgb, snowColor, snowMask);       

         return vec4(finalColor, snowMask+imageColor.a);
    }
</code></pre>

<p>别忘了从composable中提供时间：</p>

<pre><code class="Kotlin">@Composable
private fun SnowedDialog(onDismiss: () -&gt; Unit) {
    val snowCapShader = remember { RuntimeShader(snowCapShader) }
    var time by remember { mutableStateOf(0f) }

    LaunchedEffect(null)  {
        while (true) {
            delay(10)
            time += 0.01f
        }
    }

    BasicAlertDialog(
        onDismissRequest = { onDismiss() },
        properties = DialogProperties(usePlatformDefaultWidth = false)
    ) {
        Column(
            Modifier
                .padding(horizontal = 16.dp)
                .background(shape = MaterialTheme.shapes.large, color = MaterialTheme.colorScheme.surface)
                .onSizeChanged { size -&gt;
                    snowCapShader.setFloatUniform(
                        "resolution",
                        size.width.toFloat(),
                        size.height.toFloat()
                    )
                }
                .graphicsLayer {
                    // 这里提供时间：
                    snowCapShader.setFloatUniform("time", time)
                    this.renderEffect = RenderEffect
                        .createRuntimeShaderEffect(snowCapShader, "image")
                        .asComposeRenderEffect()
                }
                .padding(16.dp),
        ) {
// 其余代码保持不变
</code></pre>

<p>我们得到如下效果：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*5YYiM3lZYp42O8Fa9iS-4A.gif" alt="" /></p>

<p>关于这个效果，我想分享的差不多就是这些了！这是核心思想，从这里开始，你可以尝试不同的设置。例如，我用一个基于 Perlin 噪声的更混乱的版本替换了基本的正弦波。</p>

<p>但这些只是细节，在实现上可以有无限的变化。创建着色器的关键在于掌握其背后的核心思想。</p>

<p>你可以在我的代码库中找到我的实现，其中还包含各种用于不同增强功能的辅助方法。例如，这里有一系列过渡效果（线性、三次、指数等）。</p>

<p>添加雪花是最后一步，但创建雪、雨、星星等效果的方法值得另开一个教程。下次我一定会讲解。今天，我只想提一下，为了实现这个特定的效果，我使用了 <strong>Andrew Baldwin</strong> 于 2013 年在 ShaderToy 上创建的着色器。链接如下：<a href="https://www.shadertoy.com/view/ldsGDn">https://www.shadertoy.com/view/ldsGDn</a></p>

<p>由于原始着色器对于手机来说过于庞大，我做了一些简化。此外，它还需要一些适配 AGSL 的功能。这是我的版本：</p>

<pre><code class="glsl">  uniform shader image;
   uniform vec2 resolution;
   uniform float time;

   uniform int uLayers;
   uniform float uDepth;
   uniform float uSpeed;

   const int MAX_LAYERS = 50;
   const float WIDTH = 0.4;

   vec2 NormalizeCoordinates(vec2 o, vec2 r) {
        float2 uv = o / r - 0.5;
        if (r.x &gt; r.y) {
            uv.x *= r.x / r.y;
        } else {
            uv.y *= r.y / r.x;
        } 
        return uv;
    }

    vec4 GetImageTexture(vec2 p, vec2 pivot, vec2 r) {
        if (r.x &gt; r.y) {
            p.x /= r.x / r.y;
        } else {
            p.y /= r.y / r.x;
        }
        p += pivot;
        p *= r;
        return image.eval(p);
    }

    vec4 main(float2 fragCoord) {
       float2 uv = NormalizeCoordinates(fragCoord, resolution);  
       vec4 image = GetImageTexture(uv, vec2(0.5, 0.5), resolution);
       const mat3 p = mat3(13.323122, 23.5112, 21.71123, 21.1212, 28.7312, 11.9312, 21.8112, 14.7212, 61.3934);

       float ratio = resolution.y / resolution.x;
       vec3 acc = vec3(0.0);
       float alpha = 0.0; // 初始化 alpha
       float dof = 5.0 * sin(time * 0.1);
       for (int i = 0; i &lt; MAX_LAYERS; i++) {
           if (i &gt;= uLayers) break; // 如果 i 超出 uLayers，则跳出循环

           float fi = float(i);
           vec2 q = uv * (1.0 + fi * uDepth);

           // 通过调制和时间调整雪花位置
           q -= vec2(q.y * (WIDTH * mod(fi * 7.238917, 1.0) - WIDTH * 0.5), uSpeed * time / (1.0 + fi * uDepth * 0.03));                      vec3 n = vec3(floor(q), 31.189 + fi);
           vec3 m = floor(n) * 0.00001 + fract(n);
           vec3 mp = (31415.9 + m) / fract(p * m);
           vec3 r = fract(mp);

           // 使用圆形mask的圆形雪花形状
           float2 center = mod(q, 1.0) - 0.5 + 0.5 * r.xy;
           float distanceToCenter = length(center); // 圆周距离
           float flakeRadius = 0.015 + 0.01 * r.z; // 每个薄片的半径略有不同

           // 通过扩展的平滑步进实现更平滑的边缘
           float intensity = smoothstep(flakeRadius + 0.015, flakeRadius, distanceToCenter) * 
                               smoothstep(flakeRadius, flakeRadius - 0.015, distanceToCenter);

           // Ensure flakes are white or transparent (prevent black color)
           vec3 flakeColor = vec3(1.0); // 雪花要是白色
           acc += flakeColor * intensity;

           // 通过平滑过渡积累 alpha
           alpha += intensity;
       }

       // 归一化 alpha 以确保其不超过 1.0
       alpha = clamp(alpha, 0.0, 1.0);
       vec3 finalColor = mix(image.rgb, acc, alpha);

      if(uv.y &lt; -0.5*ratio || uv.y &gt; .5*ratio) {
           finalColor = vec3(0.0);
           alpha = 0.0;
       }
       return vec4(finalColor, alpha+image.a);
   }
</code></pre>

<p>当然，为了让一些雪花出现在屏幕前方，而另一些雪花飘到屏幕后方，我必须在这个着色器中使用两层。这是对话框可组合函数的最终效果：</p>

<pre><code class="Kotlin">@Composable
private fun SnowedDialog(onDismiss: () -&gt; Unit) {
    val snowCapShader = remember { RuntimeShader(snowCapShader) }
    val flakesShaderForeground = remember { RuntimeShader(snowShader) }
    val flakesShaderBackground = remember { RuntimeShader(snowShader) }

    var time by remember { mutableStateOf(0f) }

    LaunchedEffect(null)  {
        while (true) {
            delay(10)
            time += 0.01f
        }
    }

    flakesShaderForeground.setIntUniform("uLayers", 5)
    flakesShaderForeground.setFloatUniform("uDepth", 0.15f)
    flakesShaderForeground.setFloatUniform("uSpeed", 1.0f)

    flakesShaderBackground.setIntUniform("uLayers", 10)
    flakesShaderBackground.setFloatUniform("uDepth", 1.5f)
    flakesShaderBackground.setFloatUniform("uSpeed", 0.8f)

    BasicAlertDialog(
        onDismissRequest = { onDismiss() },
        properties = DialogProperties(usePlatformDefaultWidth = false)
    ) {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .onSizeChanged { size -&gt;
                    flakesShaderForeground.setFloatUniform(
                        "resolution",
                        size.width.toFloat(),
                        size.height.toFloat()
                    )
                }
                .graphicsLayer {
                    flakesShaderForeground.setFloatUniform("time", time)
                    this.renderEffect = RenderEffect
                        .createRuntimeShaderEffect(flakesShaderForeground, "image")
                        .asComposeRenderEffect()
                }
                .padding(16.dp),
            contentAlignment = Alignment.Center
        ) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .onSizeChanged { size -&gt;
                        flakesShaderBackground.setFloatUniform(
                            "resolution",
                            size.width.toFloat(),
                            size.height.toFloat()
                        )
                    }
                    .graphicsLayer {
                        flakesShaderBackground.setFloatUniform("time", time)
                        this.renderEffect = RenderEffect
                            .createRuntimeShaderEffect(flakesShaderBackground, "image")
                            .asComposeRenderEffect()
                    }
            ) {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .background(color = Color.Black.copy(0.1f))
                )
            }
            Column(
                Modifier
                    .padding(horizontal = 16.dp)
                    .background(shape = MaterialTheme.shapes.large, color = MaterialTheme.colorScheme.surface)
                    .onSizeChanged { size -&gt;
                        snowCapShader.setFloatUniform(
                            "resolution",
                            size.width.toFloat(),
                            size.height.toFloat()
                        )
                    }
                    .graphicsLayer {
                        snowCapShader.setFloatUniform("time", time)
                        this.renderEffect = RenderEffect
                            .createRuntimeShaderEffect(snowCapShader, "image")
                            .asComposeRenderEffect()
                    }
                    .padding(16.dp),
            ) {
                Text("Merry Christmas!", style = MaterialTheme.typography.titleLarge)
                Spacer(modifier = Modifier.height(10.dp))
                Text("Happy New Year!")
                Spacer(modifier = Modifier.height(26.dp))
                Row(
                    modifier = Modifier
                        .fillMaxWidth(),
                    horizontalArrangement = Arrangement.End
                ) {
                    Text(
                        modifier = Modifier
                            .clickable { onDismiss() }
                            .padding(5.dp),
                        text = "Close",
                        style = MaterialTheme.typography.bodyMedium.copy(color = MaterialTheme.colorScheme.primary)
                    )
                }
            }
        }
    }
}
</code></pre>

<p>最终结果：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1000/1*UG3e4b_9AqY1J1kKCNFqAw.png" alt="" /></p>

<p>感谢你的阅读！如果你觉得我的实验有趣且我的解释对你有帮助，欢迎加入我的<a href="https://t.me/droidshaderworks">Telegram频道</a>或在<a href="https://x.com/KrowaNaMostku">Twitter (X)</a>上关注我。你的支持意义重大，并激励着我。祝你撸码愉快！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初探Compose中的着色器RuntimeShader]]></title>
    <link href="https://alexhilton.github.io/blog/2025/08/15/first-look-at-runtimeshader/"/>
    <updated>2025-08-15T22:21:24+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/08/15/first-look-at-runtimeshader</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「First look at RuntimeShaders in Compose」，原文链接<a href="https://medium.com/@off.mind.by/first-look-at-runtimeshaders-in-compose-b0b431083644">https://medium.com/@off.mind.by/first-look-at-runtimeshaders-in-compose-b0b431083644</a>，由Alex Volkov发布于2024年4月12日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1302/1*QXaDvaYryDIZ1GItjM1uqQ.png" title="auto auto" ></a></p>

<!-- more -->


<p>自从我们有机会在 Compose 中使用 RuntimeShaders 自定义Shader（着色器）以来，已经过去了一年多的时间。说实话，我原本以为会有大量关于这个主题的文章。我以为现在 Android 上应该已经充斥着无数令人惊叹的示例、意想不到的效果，以及听到“着色器”这个词时脑海中浮现的其他令人着迷的东西。但事实并非如此。在 RuntimeShaders 可用之后，几乎立刻就出现了几篇文章，之后就再也没有了。一片寂静。</p>

<p>我想答案很简单：Android 开发者并不熟悉着色器，而着色器程序员通常不会直接为 Android 编写代码；他们通常会使用某种游戏引擎。事实上，如果我的假设正确，我希望用这篇文章来弥合这两个世界之间的差距。我真心希望着色器编写能够渗透到 Android 开发领域。因此，在本文的剩余部分，我将介绍一些必要的基础知识，以便你可以坐下来编写着色器并享受其成果。</p>

<p>因此，我假设你已经对 Compose 有了一定的了解。本文不会过多讨论着色器。我的主要重点是连接这两个世界。我们将在未来讨论具体的技术。假设我们有两个项目：一个带有背景图像，顶部有一个框，我们暂时将其设置为黑色。以下是代码的简化版本：</p>

<pre><code class="Kotlin">VerySimpleShaderTheme {
    Box(Modifier.fillMaxSize(), 
        contentAlignment = Alignment.Center) {
        Image(
            modifier = Modifier.fillMaxSize(),
            contentScale = androidx.compose.ui.layout.ContentScale.Crop,
            painter = painterResource(id = R.drawable.background_pattern),
            contentDescription = null
        )
        Box(modifier = Modifier
            .size(200.dp)
            .clipToBounds()
          ){
        }
    }
}
</code></pre>

<p>现在，要将着色器添加到框中，你需要获取着色器文本本身，该文本以常规字符串形式传递。使用此文本创建一个 <code>RuntimeShader</code> 对象。然后，将其传递给 <code>graphicsLayer</code> 方法。这是一个简单的例子：</p>

<pre><code class="Kotlin">val runtimeShader = """
uniform shader image;

half4 main(float2 fragCoord) {
   return half4(0., 0.0, 0.0, .5);
}
""".trimIndent()

val shader = remember { RuntimeShader(runtimeShader) } 
Box(modifier = Modifier.size(200.dp)
                        .clipToBounds()
                        .graphicsLayer {
                            this.renderEffect = RenderEffect
                                .createRuntimeShaderEffect(
                                    shader, "image"
                                )
                                .asComposeRenderEffect()
                        }
                        .background(Color.White)
                       ) 
</code></pre>

<p>这是一个非常基础的着色器示例，它输出黑色，透明度为 50%。它看起来像下面的屏幕截图所示（背景只是来自资源库的图片）。它可能还不够令人印象深刻，但我想在这里强调两个重要的细节。首先，我们如何将着色器应用到盒子上。在我们的着色器代码中，我们需要一个着色器对象，以便在创建 renderEffect 时传递它。第二个重要的细节是，我们需要为盒子添加一个背景，并且背景不能完全透明；只有这样，我们的着色器才能应用到盒子上，否则它将不可见。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*DWbBFHchSRHzeVv_9FuxvQ.png" alt="" /></p>

<p>在使用着色器时，通常需要对坐标进行归一化，使其从 0 变为 1。理想情况下，从 -0.5 到 0.5，这样坐标中心就位于画布的正中央。这有助于使用各种数学公式。然而，要做到这一点，不仅需要知道当前像素坐标，还需要知道画布的总尺寸。为了演示如何做到这一点，我将向你展示下一个重点：将参数从代码传递给着色器。我们将传递盒子的尺寸并修改着色器，使其绘制一个圆圈：</p>

<pre><code class="Kotlin">val runtimeShader = """
uniform shader image;
uniform float2 resolution;

half4 main(float2 fragCoord) {
    vec2 uv = fragCoord/resolution.xy - .5;
    uv.x *= resolution.x/resolution.y;    
    return half4(step(length(uv),0.5));
}
""".trimIndent()

Box(modifier = Modifier
                        .size(200.dp)
                        .clipToBounds()
                        .onSizeChanged { size -&gt;
                            shader.setFloatUniform(
                                "resolution", size.width.toFloat(), size.height.toFloat()
                            )
                        }
                        .graphicsLayer {
                            this.renderEffect = RenderEffect
                                .createRuntimeShaderEffect(
                                    shader, "image"
                                )
                                .asComposeRenderEffect()
                        }
                        .background(Color.White)
                       ) {
                    }
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*nBzr_W24ekFtGgf3xdz8QA.png" alt="" /></p>

<p>现在我们已经学习了如何创建自己的着色器并为其传递参数，重要的是要理解你可以传递任何你需要的参数，无论是时间、颜色还是着色器所需的其他参数。为了巩固这些知识，我将向你展示一个我为 Android 制作的第一个着色器的示例——一个用于加载的发光圆圈。我们将传递当前时间来为其添加动画效果；下面是一个此类效果的简单示例：</p>

<pre><code class="Kotlin">val runtimeShader = """
uniform shader image;
uniform float2 resolution;
uniform float radius;
uniform float time;

half4 main(float2 fragCoord) {
    vec2 uv = fragCoord/resolution.xy - .5;
    uv.x *= resolution.x/resolution.y;    
    float radiusWithTime = (1+sin(time))*0.1 + radius;
    float glowingCircle = smoothstep(radiusWithTime, radiusWithTime-radiusWithTime*0.3, length(uv));    
    return half4(glowingCircle-step(length(uv),radius*0.7));
}
""".trimIndent()

val shader = remember { RuntimeShader(runtimeShader) }
var time by remember { mutableStateOf(0f) }
shader.setFloatUniform("radius", 0.6f)
LaunchedEffect(null) {
    while (true) {
        delay(10)
        time+=0.01f
    }
}

shader.setFloatUniform("time", time)
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*Lr85zuDhk8o0-TUgw993_A.png" alt="它实际上有一个光晕动画" /></p>

<p>我已经演示了最基础的部分。我的目标是提供一个切入点，并展示它是多么的简单。关于着色器，我还有很多想讨论的，但我们留到下次再说。</p>

<p>感谢你的关注，祝你使用 Android、Compose 和Shader（着色器）顺利进入非凡的 UI 世界。期待与你相见！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[学会用最优雅的姿式在Compose中显示富文本]]></title>
    <link href="https://alexhilton.github.io/blog/2025/07/30/styledstring-in-jetpack-compose/"/>
    <updated>2025-07-30T22:50:40+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/07/30/styledstring-in-jetpack-compose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「StyledString: A Better Pattern for Rich Text in Jetpack Compose」，原文链接<a href="https://proandroiddev.com/styledstring-a-better-pattern-for-rich-text-in-jetpack-compose-5930bde981b1">https://proandroiddev.com/styledstring-a-better-pattern-for-rich-text-in-jetpack-compose-5930bde981b1</a>，由Eury Pérez Beltré发布于2025年7月14日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NS_T-i72tS5eOs5F0f_Tnw.png" title="auto auto" ></a></p>

<!-- more -->


<p>在 Jetpack Compose 中设置文本样式看似简单……但其实不然。在本文中，我们将探讨 AnnotatedString 的局限性，以及 StyledString 如何让富文本更易于管理。让我们来详细分析一下。👇</p>

<h2>📚 目录</h2>

<ol>
<li>引言：一个粗体字、一个链接，以及一大堆麻烦</li>
<li>AnnotatedString：样式过多，简洁性不足</li>
<li>StyledString 简介：一个 API 即可设置所有样式</li>
<li>StyledString 底层原理：API 背后的引擎</li>
<li>结语</li>
</ol>


<h2>引言：一个加粗的单词、一个链接，以及一大堆麻烦</h2>

<p>一开始，你拥有了 AnnotatedString 和一个 SpanStyle ，一切看起来都很顺畅。你想加粗一个单词？很简单✅。给某个东西加下划线？没问题。这甚至感觉有点有趣，尤其是在你像<a href="https://developer.android.com/develop/ui/compose/text/style-text#multiple-styles">官方文档</a>中那样手动构建整个字符串的时候。</p>

<p>但问题是：🧠</p>

<p>当你完全控制字符串时，这种方法非常有效。但当你处理实际内容：动态副本、本地化文本、从其他地方传入的段落，而你只需要设置其中一部分的样式时？</p>

<p>事情很快就变得很糟糕。</p>

<p>突然间，你需要跟踪子字符串、计算索引、应用样式，并连接点击监听器。只需对文本进行一次更改，你的逻辑就会像纸牌屋一样崩溃。🃏</p>

<p>你原本想要的只是加粗一个单词并让链接可点击。现在你深陷于样板代码中，祈祷一切都不会改变。</p>

<p>在这篇文章中，我将解释为什么 AnnotatedString 在实际 UI 中无法很好地扩展，并介绍一个我为了解决这个问题而构建的微型抽象。它叫做 StyledString，它的功能非常强大：💡 它确实做到了：</p>

<p><strong>让Compose 中的文本样式再次变得简单。</strong></p>

<h2>AnnotatedString：样式太多，简洁性不足</h2>

<p>首先，让我们称赞一下 AnnotatedString。它是一款强大的工具💪.</p>

<p>你可以使用一个 Text 可组合项来创建带样式、可点击、可交互的文本。想要让一个单词加粗，另一个单词像链接一样显示？完全可以。该 API 灵活、底层，并且由 Compose 本身的富文本引擎支持。</p>

<p>问题是，它只有<strong>在手动</strong>构建整个字符串时才能发挥最佳效果。</p>

<p>文档中的大多数示例如下所示：</p>

<pre><code class="Kotlin">buildAnnotatedString {
    append("Hello ")
    withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {
        append("world")
    }
}
</code></pre>

<p>看起来不错，对吧？但棘手的地方就在这里。👀</p>

<p>如果你有一整段动态文本，比如一段本地化的字符串或一个从其他地方拉取的句子，而你只想为其中的部分内容添加样式，该怎么办？</p>

<p>现在你需要处理：</p>

<ul>
<li>查找要添加样式的子字符串</li>
<li>计算起始和结束索引</li>
<li>手动添加样式或注释</li>
<li>希望文本永远不变，否则一切都会崩溃。</li>
</ul>


<p>如果你需要多种样式，比如粗体单词、可点击的电子邮件和带下划线的 URL，动态地，事情很快就会变得混乱。🔥
这时，buildAnnotatedString 就会变成一堆脆弱的索引数学运算、重复的逻辑和样板代码，难以阅读，更难以维护。</p>

<p>当然，AnnotatedString 功能强大。但当你的文本是动态的，而你只想为其中的部分内容添加样式时？它很快就会变得索然无味。</p>

<h2>StyledString 隆重出场：一个 API 即可实现所有样式</h2>

<p>在与 AnnotatedString 纠结了无数次之后，我决定构建一个更好的东西。它并非一个庞大的库，也不是一个完整的样式框架。而是一个简单、兼容 Compose 的抽象，用于解决一个非常具体的问题。</p>

<p><strong>StyledString 来啦！👋</strong></p>

<p>它的目标很简单：让你定义字符串的哪些部分应该被设置样式或可点击，而无需担心 indexOf 、 addStyle 或 AnnotatedString.Builder 。你只需编写文本，告诉它需要设置哪些单词的样式，以及点击后该执行的操作。</p>

<p>它的实际效果如下：</p>

<pre><code class="Kotlin">// This list can be built in the ViewModel
val styledStrings = persistentListOf(
    StyledString.ClickableEmail(
        highlightedText = "support@example.com",
        email = "support@example.com",
        style = SpanStyle(
            color = Color.Blue,
            textDecoration = TextDecoration.Underline
        )
    ),
    StyledString.ClickableUrl(
        highlightedText = "website",
        url = "https://euryperez.dev",
        style = SpanStyle(
            color = Color.Blue,
            textDecoration = TextDecoration.Underline
        )
    )
)

// In your Compose Screen
StyledText(
    fullText = "Contact us at support@example.com or visit our website",
    styledStrings = styledStrings,
    style = MaterialTheme.typography.label,
    onClick = { styled -&gt;
        when (styled) {
            is ClickableEmail -&gt; openEmailClient(styled.email)
            is ClickableUrl -&gt; openUrl(styled.url)
        }
    }
)
</code></pre>

<p>就是这样。无需手动构建文本，无需索引计算，无需样板代码。只需简洁、易读、声明式的样式，即可与真实文本兼容。</p>

<p>由于 StyledString 支持 Simple 、 ClickableEmail 和 ClickableUrl 等类型，因此它易于在你的应用中扩展和复用。你可以获得可点击的、带样式的文本，而无需牺牲其合理性和可维护性。🙏</p>

<h2>StyledString 的底层：API 背后的引擎</h2>

<p>让我们揭开它的面纱，逐步了解 StyledString 的工作原理。🪄</p>

<p>当你在 UI 中使用 StyledText 时，🧠它可能感觉像魔法一样神奇，但在幕后，它只是一个简洁、易于组合的架构，旨在减少样式设计的痛苦，而不会增加不必要的复杂性。</p>

<p>本节涵盖了 StyledString 系统的每个部分，从样式的描述方式，到样式的查找、应用和在屏幕上渲染。</p>

<h3>🧱 1. 数据模型：StyledString 和 ClickableStyleString</h3>

<p>整个实用程序的核心是一个名为 StyledString 的密封接口。我们通过它来对需要以某种方式设置样式的文本片段进行建模。</p>

<pre><code class="Kotlin">@Immutable
sealed interface StyledString {
    val highlightedText: String
    val style: SpanStyle

    // Add `Simple` type

    // Add `ClickableEmail` type

    // Add `ClickableUrl` type
}
</code></pre>

<p>每个 StyledString 都需要两条信息：</p>

<ul>
<li>highlightedText：需要设置样式的文本的确切部分</li>
<li>style：定义其外观的 SpanStyle（颜色、下划线、字体粗细等）。</li>
</ul>


<p>然后，我们定义一些实现此接口的特定类型：</p>

<pre><code class="Kotlin">@Immutable
data class Simple(
    override val highlightedText: String,
    override val style: SpanStyle,
) : StyledString
</code></pre>

<p>这个是纯视觉效果的，它会改变文本的外观，但不响应点击。</p>

<p>然后我们介绍交互类型：</p>

<pre><code class="Kotlin">@Immutable
data class ClickableEmail(
    override val highlightedText: String,
    val email: String,
    override val style: SpanStyle,
) : StyledString, ClickableStyleString

@Immutable
data class ClickableUrl(
    override val highlightedText: String,
    val url: String,
    override val style: SpanStyle
) : StyledString, ClickableStyleString
</code></pre>

<p>它们执行相同的样式设置工作，但还携带额外的数据（例如点击时应打开的 URL 或电子邮件）。更重要的是，它们实现了第二个接口：ClickableStyleString。</p>

<pre><code class="Kotlin">sealed interface ClickableStyleString
</code></pre>

<p>这个小接口意义重大，它让我们能够区分纯视觉样式和应该响应点击的样式。这使得我们的点击处理逻辑简洁且类型安全。💡</p>

<p>你可以轻松添加更多变体，例如 @mentions、#hashtags 或电话号码，只需创建另一个数据类并选择性地实现ClickableStyleString 即可。</p>

<h3>🎯 2. 样式和链接：applyStyle</h3>

<p>一旦我们知道了哪些文本需要样式，我们就需要一种将这些样式应用于实际的 AnnotatedString 的方法。这就是 applyStyle() 的作用，它是一个简单的扩展函数，它根据 StyledString 的类型应用样式（和点击监听器）。</p>

<pre><code class="Kotlin">private fun AnnotatedString.Builder.applyStyle(
    styledString: StyledString,
    startIndex: Int,
    endIndex: Int,
    onClick: (ClickableStyleString) -&gt; Unit
) {
    when (styledString) {
        is StyledString.ClickableUrl -&gt; TODO()

        is StyledString.ClickableEmail -&gt; TODO()

        is StyledString.Simple -&gt; TODO()
    }
}
</code></pre>

<p>每次匹配每个 StyledString 时，都会调用一次此函数。现在让我们看看它做了什么：</p>

<pre><code class="Kotlin">is StyledString.ClickableUrl -&gt; {
    val linkAnnotation = LinkAnnotation.Url(
        url = styledString.url,
        styles = TextLinkStyles(style = styledString.style),
        linkInteractionListener = { onClick(styledString) }
    )
    addLink(linkAnnotation, startIndex, endIndex)
}
</code></pre>

<p>如果是 URL，我们会创建一个 LinkAnnotation.Url 对象，附加样式，并为其添加一个点击监听器。addLink 负责将其附加到正确的文本范围。</p>

<p>我们执行的操作类似，但针对电子邮件使用的是 LinkAnnotation.Clickable ：</p>

<pre><code class="Kotlin">is StyledString.ClickableEmail -&gt; {
    val linkAnnotation = LinkAnnotation.Clickable(
        tag = styledString.highlightedText,
        styles = TextLinkStyles(style = styledString.style),
        linkInteractionListener = { onClick(styledString) }
    )
    addLink(linkAnnotation, startIndex, endIndex)
}
</code></pre>

<p>如果样式只是视觉上的（不可点击），我们会应用常规跨度：</p>

<pre><code class="Kotlin">is StyledString.Simple -&gt; {
    addStyle(
        style = styledString.style, 
        start = startIndex, 
        end = endIndex
    )
}
</code></pre>

<p>这种分离将所有样式应用逻辑集中在一处。如果你想要支持新的链接类型或行为，只需更新此函数即可。</p>

<h3>🔍 3. 匹配文本：findAllOccurrences</h3>

<p>在应用样式之前，我们需要找到文本中所有出现指定highlightedText 的位置。这就是此函数的用途。</p>

<pre><code class="Kotlin">/**
 * Find all occurrences of a substring in a string, optionally ignoring case.
 *
 * @param substring The substring to search for.
 * @param ignoreCase Whether to perform a case-insensitive search.
 * @return A list of indices where the substring was found.
 */
private fun String.findAllOccurrences(
    substring: String,
    ignoreCase: Boolean = false
): List&lt;Int&gt;
</code></pre>

<p>这将获取全文，并返回给定子字符串的每个匹配项的起始索引列表。</p>

<p>工作原理如下：</p>

<pre><code class="Kotlin">if (substring.isEmpty()) return emptyList()
</code></pre>

<p>对于空子字符串，快速提前退出。避免奇怪的边缘情况。然后，我们准备进行不区分大小写的搜索（如果需要）：</p>

<pre><code class="Kotlin">val indices = mutableListOf&lt;Int&gt;()
val searchString = if (ignoreCase) this.lowercase() else this
val searchSubstring = if (ignoreCase) substring.lowercase() else substring
</code></pre>

<p>现在我们遍历字符串，找到所有匹配项：</p>

<pre><code class="Kotlin">var startIndex = 0
val maxStartIndex = length - substring.length

while (startIndex &lt;= maxStartIndex) {
    val index = searchString.indexOf(searchSubstring, startIndex)
    if (index == -1) break
    indices.add(index)
    startIndex = index + 1
}
</code></pre>

<p>我们最终返回结果：</p>

<pre><code class="Kotlin">return indices.toList()
</code></pre>

<p>这使得我们的样式逻辑保持灵活性和弹性，无论我们设计的单词出现一次还是十几次。</p>

<h3>🧠 4. 构建 AnnotatedString：rememberStyledAnnotationString</h3>

<p>以下函数将所有内容整合在一起。它接收完整文本和你的StyledString 列表，并返回一个应用了所有样式的 AnnotatedString。</p>

<pre><code class="Kotlin">@Composable
fun rememberStyledAnnotationString(
    fullText: String,
    styledStrings: ImmutableList&lt;StyledString&gt;,
    ignoreCase: Boolean = false,
    onClick: (ClickableStyleString) -&gt; Unit
): AnnotatedString
</code></pre>

<p>我们确保使用 rememberUpdatedState() 来保持点击监听器的最新状态：</p>

<pre><code class="Kotlin">val currentOnClick by rememberUpdatedState(onClick)
</code></pre>

<p>然后我们使用记住来缓存工作，除非输入发生变化：</p>

<pre><code class="Kotlin">return remember(fullText, styledStrings, ignoreCase) {
  // TODO: build annotated string
}
</code></pre>

<p>我们首先附加完整的未样式化的文本。然后，对于每个 StyledString ，我们找到所有匹配的位置并应用样式：</p>

<pre><code class="Kotlin">buildAnnotatedString {
    append(fullText)

    styledStrings.fastForEach { styledStringInfo -&gt;
        val indices =
            fullText.findAllOccurrences(styledStringInfo.highlightedText, ignoreCase)

        indices.fastForEach { startIndex -&gt;
            val endIndex = startIndex + styledStringInfo.highlightedText.length
            applyStyle(styledStringInfo, startIndex, endIndex, currentOnClick)
        }
    }
}
</code></pre>

<p>这个循环使得样式设置能够动态且多目标化。你可以将任何本地化或运行时生成的字符串作为 fullText 传递，它仍然能够正确应用样式。</p>

<h3>🧩 5. 可组合项：StyledText</h3>

<p>最后，StyledText 可组合项将所有内容连接在一起。</p>

<pre><code class="Kotlin">@Composable
fun StyledText(
    fullText: String,
    styledStrings: ImmutableList&lt;StyledString&gt;,
    style: TextStyle,
    modifier: Modifier = Modifier,
    onClick: (ClickableStyleString) -&gt; Unit = {},
    ignoreCase: Boolean = false,
) {
    // TODO: Implementation
}
</code></pre>

<p>你传入全文、样式以及可选的点击处理程序。它的内部功能如下：</p>

<pre><code class="Kotlin">val annotatedString = rememberStyledAnnotationString(
    fullText = fullText,
    styledStrings = styledStrings,
    ignoreCase = ignoreCase,
    onClick = onClick
)
</code></pre>

<p>这调用了我们刚刚讲过的逻辑。它返回一个带样式的 AnnotatedString 。然后我们渲染它：</p>

<pre><code class="Kotlin">Text(
    modifier = modifier,
    text = annotatedString,
    style = style
)
</code></pre>

<p>它只是一个普通的 Compose Text 。但所有样式逻辑都已预先烘焙。现在，你的 UI 代码保持简洁且声明式。🌚</p>

<h3>⚡️ 6. StyledText 实践</h3>

<p>现在，让我们来看看 StyledText 的实践，为此，我整理了一个预览，你可以自己测试一下：</p>

<pre><code class="Kotlin">@PreviewLightDark
@Composable
private fun StyledTextPreview() {
    MyTheme {
        Box(
            modifier = Modifier
                .background(color = MaterialTheme.colors.background)
                .padding(16.dp)
        ) {
            // This list can be built in the ViewModel
            val styledStrings = persistentListOf(
                StyledString.ClickableEmail(
                    highlightedText = "support@example.com",
                    email = "support@example.com",
                    style = SpanStyle(
                        color = Color.Gray,
                        textDecoration = TextDecoration.Underline
                    )
                ),
                StyledString.ClickableUrl(
                    highlightedText = "website",
                    url = "https://euryperez.dev",
                    style = SpanStyle(
                        color = Color.Gray,
                        textDecoration = TextDecoration.Underline
                    )
                )
            )

            // In your Compose Screen
            StyledText(
                fullText = "Contact us at support@example.com or visit our website",
                styledStrings = styledStrings,
                style = MaterialTheme.typography.body2,
                color = MaterialTheme.colors.onBackground,
                onClick = { styled -&gt;
                    when (styled) {
                        is StyledString.ClickableEmail -&gt; TODO()
                        is StyledString.ClickableUrl -&gt; TODO()
                    }
                }
            )
        }
    }
}
</code></pre>

<p>你将在预览中看到以下内容：
<img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Tc22BNoUfij54fBGQ7YCg.png" alt="StyledTextPreview" /></p>

<h3>✅ 总结：一个输出简洁的简单引擎</h3>

<p>总而言之，我们构建了一个完全可复用的 Compose 实用程序，它：</p>

<ul>
<li>使用 StyledString 以声明式方式描述样式</li>
<li>安全地区分可视样式和可点击样式</li>
<li>使用 applyStyle 应用 span 和 link</li>
<li>使用 findAllOccurrences 查找多个匹配项</li>
<li>以 Compose 稳定的方式组装所有内容</li>
<li>封装在一个简洁的 API 中：StyledText</li>
</ul>


<p>无需 indexOf ，无需复杂的范围逻辑，也无需复制粘贴 buildAnnotatedString样板代码。</p>

<p><a href="https://gist.github.com/euri16/614a460fe6a690ce57cd23cc41164b5a">点击此处</a>（链接：<a href="https://gist.github.com/euri16/614a460fe6a690ce57cd23cc41164b5a%EF%BC%89%E8%8E%B7%E5%8F%96%E5%AE%8C%E6%95%B4%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%82">https://gist.github.com/euri16/614a460fe6a690ce57cd23cc41164b5a%EF%BC%89%E8%8E%B7%E5%8F%96%E5%AE%8C%E6%95%B4%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%82</a></p>

<h2>结语🎯</h2>

<p>Jetpack Compose 赋予我们强大的功能，但并非总是最符合人体工程学的开箱即用工具。AnnotatedString 对于一次性需求来说非常棒，但一旦你的 UI 需要多种样式、复用模式或动态点击处理，它就会很快变得冗长。</p>

<p>这就是 StyledString 的用武之地。</p>

<p>它并非取代 AnnotatedString，而是对其进行包装，为你提供一种更安全、更清晰的方式来描述意图：</p>

<ul>
<li>→ “将此单词加粗”</li>
<li>→ “将此短语设为链接”</li>
<li>→ “为该字符串的每个实例设置样式”</li>
</ul>


<p>你无需再考虑文本偏移量和跨度范围，而是开始思考含义。结果：代码更简洁、样板更少，开发者体验更佳💆</p>

<h3>🧩 易于采用</h3>

<p>你无需重构整个应用即可使用 StyledString 。</p>

<p>只需将一两个 Text() 元素替换为 StyledText() 即可。将内联的 buildAnnotatedString { &hellip; } 块替换为 StyledString.Simple 或 ClickableUrl 的简单列表即可。</p>

<p>就这样，你就成功了。✨</p>

<h3>🛠️ 易于扩展</h3>

<p>还有其他用例吗？</p>

<ul>
<li>为 #hashtags 设置样式？</li>
<li>处理 @mentions？</li>
<li>自动检测电话号码？</li>
<li>添加图标或背景高亮？</li>
</ul>


<p>只需创建一个实现 StyledString 的新数据类，并在 applyStyle() 中处理它即可。系统的其余部分保持不变。</p>

<p>这种分离使你的文本逻辑模块化、可测试，并能够适应未来的设计或业务需求。</p>

<p>如果你有什么有趣的想法，别忘了在评论区分享。😉</p>

<h3>🫱 轮到你了</h3>

<p>现在你已经了解了它的工作原理（以及它实际需要的代码量有多小），那就在下一个 Compose 屏幕中尝试一下吧。不再需要繁琐的 AnnotatedString.Builder 代码。不再需要重复的 span 逻辑。只需描述你想要的内容，剩下的交给 StyledText 处理。</p>

<p><strong>让 Compose 中的文本样式再次变得简单。😎</strong></p>

<h3>🤝 感谢阅读</h3>

<p>如果你最终在项目中使用了 StyledString，请告诉我！看到这些微型模式在现实世界中落地总是很酷。👀</p>

<p>感谢阅读！如果你觉得这篇文章有用，请考虑分享给其他开发者，点赞或留言。这很有帮助。✌️</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[揭密Jetpack Compose中的PausableComposition]]></title>
    <link href="https://alexhilton.github.io/blog/2025/07/24/exploring-pausablecomposition/"/>
    <updated>2025-07-24T19:55:51+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/07/24/exploring-pausablecomposition</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Exploring PausableComposition internals in Jetpack Compose」，原文链接<a href="https://blog.shreyaspatil.dev/exploring-pausablecomposition-internals-in-jetpack-compose">https://blog.shreyaspatil.dev/exploring-pausablecomposition-internals-in-jetpack-compose</a>，由Shreyas Patil发布于2025年7月14日。</p></blockquote>

<p><a href=""><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1751791091096/4e5b36e3-485c-4079-88be-987082e7d67e.png?w=1600&amp;h=840&amp;fit=crop&amp;crop=entropy&amp;auto=compress,format&amp;format=webp" title="auto auto" ></a></p>

<!-- more -->


<p>嗨，Composers 们👋，在最近的 Compose 1.9.X 版本中，Compose-runtime 引入了一个名为 PausableComposition 的新内部 API，据称它可以解决性能问题。它听起来像魔法，但在底层，这一切都归功于一些非常巧妙的工程设计。在深入研究 Compose 运行时以更好地理解这一点时，我偶然发现了一个强大的内部工具，它使这一切成为可能。</p>

<p>这篇文章将深入分析这一机制：PausableComposition。这是 Compose 的内部 API，开发者无需了解它。但了解它的底层工作原理总是有益的。对于想要深入了解 Compose 如何实现其惊人性能的 Jetpack Compose 开发者来说，这篇探索文章将为你提供更清晰的视角。我们将深入运行时源代码，了解它的工作原理、它对性能如此重要的原因，以及如何协调所有组件以使我们的 UI 感觉如此流畅。让我们开始吧！</p>

<h2>缘起</h2>

<p>为了实现流畅的 60 帧/秒 (fps)，我们的应用需要在 16.7 毫秒内绘制每一帧。当用户滚动浏览 LazyColumn 时，必须在这个微小的窗口内创建、测量和绘制新的项目。</p>

<p>如果一个项目很复杂，包含嵌套布局、图片和大量逻辑，那么组合它所需的工作很容易超过 16 毫秒。当这种情况发生时，主线程会被阻塞，帧会丢失，用户会在滚动过程中看到“卡顿”或卡顿。😩</p>

<p>这正是 PausableComposition 的初衷。</p>

<h2>“做什么”：更智能的 Compose 方式</h2>

<p>想象一下，你是一位厨师，正在为一场活动准备一顿大餐。👨‍🍳 与其在第一位客人到来时慌乱地从头开始烹饪所有食材，不如提前几个小时做好准备工作。切菜、调酱、烤甜点。等到上桌时，最后的烹饪和组装速度会快得令人难以置信。</p>

<p>PausableComposition 将这种“准备工作”的理念带到了 Compose 中。它允许运行时：</p>

<ol>
<li>增量式 Compose：将大型 UI 元素的合成分解成更小、更易于管理的部分。</li>
<li>异步准备：在 UI 真正需要显示在屏幕上之前进行合成工作，通常利用帧间的空闲时间。</li>
</ol>


<p>这种可组合项的预热意味着，当某个项目最终滚动到视图中时，大部分繁重的工作已经完成，使其几乎可以立即显示。</p>

<p>为了直观地理解这一概念，请观看以下动画：</p>

<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1751997214840/f9f7308a-7b83-4a3d-9d38-e3ce6aa8d9a9.gif?auto=format,compress&amp;gif-q=60&amp;format=webm" alt="滚动帧时间线" /></p>

<p>滚动发生时，假设项目 A、B、C、D 和 E 已在屏幕上可见，下一个项目是 F。如果项目 F 的布局或结构复杂，需要更多时间进行布局计算或其他预处理才能在 UI 上渲染，则此预处理将在帧时间轴内分块进行（例如 16 毫秒）。因此，如果它需要 2 帧，则 F 所需的预处理会在 2 帧的空闲时间内完成，不会造成任何帧卡顿。最后，当需要显示时，它会被绘制到 UI 上。项目 G 和 H 也采用相同的流程。</p>

<h2>工作原理：核心组件</h2>

<p>通过查看运行时源代码，我们可以看到它是如何通过一些关键接口和类来处理的。虽然你不会直接使用这些 API，但理解它们可以揭示 LazyColumn 的性能提升。🕵️‍♂️</p>

<h3>生命周期：PausableComposition 及其控制器</h3>

<p>旅程从 PausableComposition 接口开始，该接口扩展了 ReusableComposition 并添加了暂停功能。</p>

<blockquote><p>关于 ReusableComposition 的简要说明：</p>

<p>在讨论暂停之前，我们先来了解一下什么是 ReusableComposition？它是一种特殊的组合，专为需要高效回收 UI 内容的高性能场景而设计。想象一下 LazyColumn 中的项目。ReusableComposition 不会销毁滚动到屏幕外的项目的整个组合，而是允许运行时停用它。这会保留底层 UI 节点，但会清除已记住的状态。然后，这个停用的组合可以快速地用新内容“重新填充”，从而节省了从头创建节点的成本。PausableComposition 直接构建于这个强大的回收基础之上。</p></blockquote>

<p>PausableComposition 的外观如下：</p>

<pre><code class="Kotlin">// https://cs.android.com/androidx/platform/frameworks/support/+/8d08d42d60f7cc7ec0034d0b7ff6fd953516d96a:compose/runtime/runtime/src/commonMain/kotlin/androidx/compose/runtime/PausableComposition.kt;l=66
sealed interface PausableComposition : ReusableComposition {
    fun setPausableContent(content: @Composable () -&gt; Unit): PausedComposition
    fun setPausableContentWithReuse(content: @Composable () -&gt; Unit): PausedComposition
}
</code></pre>

<p>（注意：该接口是密封的，因为它仅在 Compose 运行时内部具有一组封闭且有限的实现。这为编译器提供了更多信息来进行优化。）</p>

<p>调用 setPausableContent 不会立即组合界面。相反，它会返回一个 PausedComposition 对象，该对象充当逐步过程的控制器。</p>

<pre><code class="Kotlin">// https://cs.android.com/androidx/platform/frameworks/support/+/8d08d42d60f7cc7ec0034d0b7ff6fd953516d96a:compose/runtime/runtime/src/commonMain/kotlin/androidx/compose/runtime/PausableComposition.kt;l=112
sealed interface PausedComposition {
    val isComplete: Boolean
    fun resume(shouldPause: ShouldPauseCallback): Boolean
    fun apply()
    fun cancel()
}
</code></pre>

<p>这个生命周期最好以状态机的形式来表示：</p>

<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1751864148018/27512893-f186-47e7-9bdc-26036460aed7.png?auto=compress,format&amp;format=webp" alt="PausableComposition生命周期流程图" /></p>

<ul>
<li>resume(shouldPause: ShouldPauseCallback)：这是引擎。预取系统（此处指 LazyColumn 上下文）会反复调用 resume() 来执行大量的组合工作。神奇之处在于 shouldPause 回调。Compose 运行时会在组合过程中频繁调用此 lambda。如果它返回 true（例如，由于帧截止时间已近），则组合过程将停止，并将主线程交还给更重要的工作，例如绘制当前帧。</li>
<li>apply()：一旦 resume() 返回 true，即表示操作完成，就会调用 apply()。这会获取所有计算出的界面更改，并将其提交到实际的界面树中。</li>
<li>cancel()：如果用户滚动离开，并且不再需要预先组合的项目，则会调用 cancellation() 来丢弃工作并释放资源。</li>
</ul>


<h3>内部结构概览：PausedCompositionImpl</h3>

<p>上述状态机由内部的 PausedCompositionImpl 类管理。该类保存状态并连接所有部分。</p>

<pre><code class="Kotlin">// https://cs.android.com/androidx/platform/frameworks/support/+/8d08d42d60f7cc7ec0034d0b7ff6fd953516d96a:compose/runtime/runtime/src/commonMain/kotlin/androidx/compose/runtime/PausableComposition.kt;l=202
internal class PausedCompositionImpl(...) : PausedComposition {
    private var state = PausedCompositionState.InitialPending
    internal val pausableApplier = RecordingApplier(applier.current)
    // ...

    override fun resume(shouldPause: ShouldPauseCallback): Boolean {
        when (state) {
            PausedCompositionState.InitialPending -&gt; {
                // This is the first time resume() is called.
                // It starts the initial composition of the content.
                invalidScopes =
                    context.composeInitialPaused(composition, shouldPause, content)
                state = PausedCompositionState.RecomposePending
                if (invalidScopes.isEmpty()) markComplete()
            }
            PausedCompositionState.RecomposePending -&gt; {
                // This is for subsequent calls to resume().
                state = PausedCompositionState.Recomposing
                // It tells the Composer to continue where it left off,
                // processing any pending invalidations.
                invalidScopes =
                    context.recomposePaused(composition, shouldPause, invalidScopes)
                state = PausedCompositionState.RecomposePending
                if (invalidScopes.isEmpty()) markComplete()
            }
            // ... other states like Recomposing, Applied, Cancelled are handled here ...
        }
        return isComplete
    }

    override fun apply() {
        // ... other state checks ...
        if (state == PausedCompositionState.ApplyPending) {
            applyChanges() // The call site
            state = PausedCompositionState.Applied
        }
        // ...
    }

    private fun applyChanges() {
        // ...
        pausableApplier.playTo(applier, rememberManager)
        rememberManager.dispatchRememberObservers()
        rememberManager.dispatchSideEffects()
        // ...
    }
}
</code></pre>

<p>调用 resume() 时，它会检查其内部状态并采取相应的措施：</p>

<ul>
<li>InitialPending：首次调用时，它会通过调用 context.composeInitialPaused 启动合成过程。这会告知核心 ComposerImpl 开始执行 @Composable 内容，并执行 shouldPause 回调。</li>
<li>RecomposePending：后续调用时，它会通过调用 context.recomposePaused 继续工作。此方法用于处理合成中任何因状态变化而失效的部分，或继续之前暂停的工作。</li>
<li>Applier：在此过程中，ComposerImpl 将所有 UI 更改操作转发给 pausableApplier（即 RecordingApplier），该操作会进行缓冲，而不是立即应用。</li>
<li>此过程持续进行，直到工作完成或 shouldPause 回调返回 true。</li>
</ul>


<h3>RecordingApplier：推迟最后的润色</h3>

<p>一个关键的性能技巧是 RecordingApplier。调用 resume() 时，Composer 不会直接更改实时 UI 树。如果分小步执行，可能会很慢，并导致 UI 更新不完整，显得怪异。</p>

<p>PausableComposition 使用的是 RecordingApplier。这个特殊的 Applier 会将其应该执行的所有 UI 操作（例如“创建 Text 节点”、“设置其文本属性”或“添加子图像”）记录到一个内部列表中。</p>

<p>只有调用 PausedComposition.apply() 时，RecordingApplier 才会将其记录的操作列表“回放”到实际的 Applier 上，从而高效地单步更新 UI 树。PausedComposition 的公共 apply() 方法是一个简单的状态机守卫。真正的工作发生在内部的 applyChanges() 方法中（如上面的代码片段所示）。</p>

<p>当调用 applyChanges 时，它会按顺序执行三项关键操作：</p>

<ul>
<li>它会告诉 RecordingApplier 将其所有缓冲的命令播放到实际的 applier 上。这才是 UI 真正出现在屏幕上的关键。</li>
<li>它会为所有已创建的 RememberObservers（例如 DisposableEffect）调度所有 onRemembered 生命周期回调。</li>
<li>最后，它会运行在合成过程中排队的所有 SideEffect。</li>
</ul>


<p>这种有序的批处理过程确保 UI 高效更新，并且所有生命周期事件都在正确的时间发生。</p>

<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1751794209046/49f5c1c7-b424-4c7d-a017-8ba65bb7b2d3.png?auto=compress,format&amp;format=webp" alt="PausableComposition时序图" /></p>

<h2>使用了 PausableComposition 的 LazyList</h2>

<p>LazyList 已经开始使用 PausableComposition API了。在 LazyList 中，PausableComposition 并非独立工作，而是协同工作的系统的一部分。</p>

<ul>
<li>指挥器 (Recomposer)：主 Recomposer 负责控制节奏，驱动可见 UI 的逐帧更新。</li>
<li>规划器 (LazyLayoutPrefetchState)：当用户滚动时，此组件会预测哪些项目即将显示。</li>
<li>舞台管理器 (SubcomposeLayout)：这个强大的 SubcomposeLayout 是 LazyList 的基础。它的 SubcomposeLayoutState 可以在需要时为各个项目创建和管理合成。最重要的是，它提供了 createPausedPrecomposition() API。</li>
<li>舞台调度器 (PrefetchScheduler)：此调度器会在帧之间寻找空闲时间来执行规划器请求的预合成工作。</li>
</ul>


<p>了解此功能的开发过程也很有趣。在 LazyLayoutPrefetchState 文件中，你可以找到控制它的功能标志：</p>

<pre><code class="Kotlin">// A simplified look inside LazyLayoutPrefetchState.kt: https://cs.android.com/androidx/platform/frameworks/support/+/8d08d42d60f7cc7ec0034d0b7ff6fd953516d96a:compose/foundation/foundation/src/commonMain/kotlin/androidx/compose/foundation/lazy/layout/LazyLayoutPrefetchState.kt;l=647
if (ComposeFoundationFlags.isPausableCompositionInPrefetchEnabled) {
    // This is the future, modern path.
    performPausableComposition(key, contentType, average)
} else {
    // This is the older, non-pausable fallback.
    performFullComposition(key, contentType)
}
</code></pre>

<p>isPausableCompositionInPrefetchEnabled 这个标志充当了终止开关的作用。虽然它在源代码中的默认值为 false。如果你想在惰性布局（LazyColumn、LazyRow 等）中启用可暂停组合行为，我们可以简单地按如下方式启用它：</p>

<pre><code class="Kotlin">class MyApplication : Application() {
    fun onCreate() {
        ComposeFoundationFlags.isPausableCompositionInPrefetchEnabled = true
        super.onCreate()
    }
}
</code></pre>

<h3>规划器：LazyLayoutPrefetchState 详解</h3>

<p>LazyLayoutPrefetchState 是预取操作的核心。它的作用是获取来自 LazyLayout 的预测（例如，“第 25 项即将上线”），并将其转换为实际的预组合任务。</p>

<p>它通过 PrefetchHandleProvider 实现此操作，该提供者会创建一个 PrefetchRequest。此请求是 PrefetchScheduler 可以执行的工作单元。在这个请求中，我们找到了暂停逻辑的核心。</p>

<p>当 PrefetchScheduler 执行请求时，它会进入一个循环，在 PausableComposition 上调用 resume()。传递给 resume 的 lambda 表达式决定是否暂停。</p>

<p>因此，如果启用了上述功能标记，它将通过 Pausable Composition API 执行请求，如下所示：</p>

<pre><code class="Kotlin">// https://cs.android.com/androidx/platform/frameworks/support/+/8d08d42d60f7cc7ec0034d0b7ff6fd953516d96a:compose/foundation/foundation/src/commonMain/kotlin/androidx/compose/foundation/lazy/layout/LazyLayoutPrefetchState.kt;l=754
// Simplified from HandleAndRequestImpl inside LazyLayoutPrefetchState
private fun PrefetchRequestScope.performPausableComposition(...) {
    val composition = // get the composition for the item of the LazyLayout 
    pauseRequested = false

    while (!composition.isComplete &amp;&amp; !pauseRequested) {
        composition.resume {
            if (!pauseRequested) {
                // 1. Update how much time is left in this frame's idle window.
                updateElapsedAndAvailableTime()

                // 2. Save how long this work chunk took, to improve future estimates.
                averages.saveResumeTimeNanos(elapsedTimeNanos)

                // 3. The Core Decision: Is there enough time left to do another
                //    chunk of work without risking a frame drop?
                pauseRequested = !shouldExecute(
                    availableTimeNanos,
                    averages.resumeTimeNanos + averages.pauseTimeNanos,
                )
            }
            // 4. Return the decision to the composition engine.
            pauseRequested
        }
    }

    updateElapsedAndAvailableTime()
    if (pauseRequested) {
        // If we decided to pause, record how long the final pause check took.
        averages.savePauseTimeNanos(elapsedTimeNanos)
    } else {
        // If we finished without pausing, record the time for the final resume chunk.
        averages.saveResumeTimeNanos(elapsedTimeNanos)
    }
}
</code></pre>

<p>让我们分解一下这个逻辑：</p>

<ol>
<li>updateElapsedAndAvailableTime()：在恢复 lambda 函数内部，系统会不断检查距离下一帧需要绘制还剩多少时间。</li>
<li>averages.saveResumeTimeNanos(&hellip;)：它会记录每个小块合成工作所需的时间。这有助于它构建一个平均值 (averages) 来预测未来工作的成本。</li>
<li>!shouldExecute(&hellip;)：这是核心决策。它会将 availableTimeNanos 与预算进行比较。这个预算是一个智能估算：完成另一块工作所需的平均时间加上暂停所需的平均时间。如果时间不足，pauseRequested 会变为 true。</li>
<li>最终计时：在本次循环退出后（因为工作完成或请求暂停），会调用最后一次 updateElapsedAndAvailableTime()。这会捕获最后一个操作的时间。</li>
<li>保存平均值：然后系统会保存这个最终计时。如果请求了暂停，则它会影响 pauseTimeNanos。如果循环自然完成，则它会影响 resumeTimeNanos。这确保了用于未来预测的历史数据始终准确。</li>
</ol>


<p>这种自我调节的反馈循环允许预取器在系统空闲时保持积极主动，但在需要渲染 UI 时又能保持礼貌，尊重主线程。</p>

<h3>最后一步：应用预组合 UI</h3>

<p>那么，当屏幕上真正需要预组合的项目时会发生什么呢？这时 SubcomposeLayout 就占据了中心位置。在正常的测量过程中，它会为现在可见的项目调用其 subcompose 函数。在内部，这会触发最后一步。</p>

<pre><code class="Kotlin">// https://cs.android.com/androidx/platform/frameworks/support/+/8d08d42d60f7cc7ec0034d0b7ff6fd953516d96a:compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/layout/SubcomposeLayout.kt;l=1186
// Simplified from LayoutNodeSubcompositionsState inside SubcomposeLayout.kt
private fun NodeState.applyPausedPrecomposition(shouldComplete: Boolean) {
    val pausedComposition = this.pausedComposition
    if (pausedComposition != null) {
        // 1. If the work must be completed now...
        if (shouldComplete) {
            // ...force the composition to finish by looping `resume`
            // and always passing `false` to the `shouldPause` callback.
            while (!pausedComposition.isComplete) {
                pausedComposition.resume { false }
            }
        }
        // 2. Apply the changes to the real UI tree.
        pausedComposition.apply()
        this.pausedComposition = null // Clear the handle.
    }
}
</code></pre>

<p>当某个项目可见时，其组合不再是低优先级的后台任务，而是高优先级的同步任务。shouldComplete = true 参数确保所有剩余的组合工作立即完成，无需暂停。然后，apply() 被调用，完整的 UI 会立即显示在屏幕上。</p>

<p>它们如何协同工作：</p>

<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1751799217100/82837ef0-e97e-49c7-bee6-cd68ab1804ba.png?auto=compress,format&amp;format=webp" alt="LazyList滚动时序图" /></p>

<h2>结论</h2>

<p>深入研究 Compose 运行时后，PausableComposition 的设计堪称性能工程的杰作。</p>

<ul>
<li>它并非魔法，而是延迟：其核心理念是在紧急任务之前完成。通过在空闲时间合成项目，快速滚动时主线程所需的工作量会大大减少。</li>
<li>协作式和非阻塞式：shouldPause 回调是处理多任务的绝佳方式。它可以让长时间运行的合成任务优雅地让位于更紧急的当前帧渲染任务，从而直接防止卡顿。</li>
<li>通过批处理提高效率：RecordingApplier 通过将 UI 树中的许多小的独立更改分组为单个高效的更新，避免了这些更改带来的开销。</li>
</ul>


<p>虽然 PausableComposition 是一个你可能永远不会直接使用的内部功能，但了解它的存在和运作方式，可以让你真正体会到 Jetpack Compose 如此高性能的明智决策。下次你轻松流畅地滚动浏览复杂的 LazyColumn 时，你就会体会到这巧妙且精心编排的“舞蹈”是如何在表面之下进行的。✅ 这种架构不仅解决了当前的性能挑战，还为 Compose 未来更先进的渲染策略铺平了道路。</p>

<p>希望你已经了解了这个新 API 在 Jetpack Compose 中的工作原理。</p>

<p>太棒了！希望你从中获得了一些宝贵的见解。如果你喜欢这篇文章，请分享 😉，因为……</p>

<p>“分享即关爱”</p>

<p>谢谢！😄</p>

<p>让我们一起回顾 X （链接：<a href="https://twitter.com/imShreyasPatil%EF%BC%89%E7%9A%84%E6%9C%80%E6%96%B0%E5%8A%A8%E6%80%81%EF%BC%8C%E6%88%96%E8%80%85%E8%AE%BF%E9%97%AE%E6%88%91%E7%9A%84%E7%BD%91%E7%AB%99%EF%BC%88%E9%93%BE%E6%8E%A5%EF%BC%9Ahttps://shreyaspatil.dev/%EF%BC%89%E4%BA%86%E8%A7%A3%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84%E4%BF%A1%E6%81%AF">https://twitter.com/imShreyasPatil%EF%BC%89%E7%9A%84%E6%9C%80%E6%96%B0%E5%8A%A8%E6%80%81%EF%BC%8C%E6%88%96%E8%80%85%E8%AE%BF%E9%97%AE%E6%88%91%E7%9A%84%E7%BD%91%E7%AB%99%EF%BC%88%E9%93%BE%E6%8E%A5%EF%BC%9Ahttps://shreyaspatil.dev/%EF%BC%89%E4%BA%86%E8%A7%A3%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84%E4%BF%A1%E6%81%AF</a> 😎。</p>
]]></content>
  </entry>
  
</feed>
