<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Compose | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/compose/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2025-10-16T20:12:27+08:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Compose Unstyled：Compose UI中失传​​的设计系统层]]></title>
    <link href="https://alexhilton.github.io/blog/2025/09/11/compose-unstyled/"/>
    <updated>2025-09-11T00:17:33+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/09/11/compose-unstyled</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Compose Unstyled: The missing Design System layer for Compose UI」，原文链接<a href="https://composables.com/blog/introducing-compose-unstyled">https://composables.com/blog/introducing-compose-unstyled</a>，由Alex Styl发布于2025年8月7日。</p></blockquote>

<p><a href=""><img src="https://composables.com/og_unstyled.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>使用 Compose UI 构建应用的最大问题是 Material Compose 的灵活性不足。Material Compose 的可定制性不足以让你在其上构建自己的设计系统，因此你最终只能对其组件进行修改。另一方面，Compose Foundation 又过于“原始”——它有行和列，但没有按钮或底部表单。而且，由于主题设置与 Material 绑定，如果不完全遵循 Material 的设计决策，你甚至无法为你的应用设置主题。</p>

<p>你可以从头开始构建所有内容，但谁有时间这样做呢？考虑到不同的状态、可访问性和边缘情况，像底部表单这样的单个组件可能需要 3-4 周才能完成。这个问题在 Compose Multiplatform 中变得更加严重——Material 在 iOS 上看起来笨拙，在桌面上显得不成比例。</p>

<p>我需要一个灵活的解决方案，可以在任何平台上使用，而不受 Material 的限制。于是我撸起袖子，自己动手构建了一个：</p>

<p><strong><a href="https://composables.com/docs/com.composables/core">Compose Unstyled</a> 是基于 Compose Foundation 的 API，可轻松构建任何设计系统</strong> （链接：<a href="https://composables.com/docs/com.composables/core%EF%BC%89%E3%80%82%E5%AE%83%E6%8F%90%E4%BE%9B%E6%97%A0%E6%A0%B7%E5%BC%8F%E3%80%81%E5%8F%AF%E8%AE%BF%E9%97%AE%E7%9A%84%E7%BB%84%E4%BB%B6%EF%BC%8C%E5%B9%B6%E9%85%8D%E6%9C%89%E7%81%B5%E6%B4%BB%E7%9A%84%E4%B8%BB%E9%A2%98">https://composables.com/docs/com.composables/core%EF%BC%89%E3%80%82%E5%AE%83%E6%8F%90%E4%BE%9B%E6%97%A0%E6%A0%B7%E5%BC%8F%E3%80%81%E5%8F%AF%E8%AE%BF%E9%97%AE%E7%9A%84%E7%BB%84%E4%BB%B6%EF%BC%8C%E5%B9%B6%E9%85%8D%E6%9C%89%E7%81%B5%E6%B4%BB%E7%9A%84%E4%B8%BB%E9%A2%98</a> API——所有关于用户体验和可访问性的繁琐工作都已为你处理。</p>

<p>Unstyled 中的组件完全无需渲染，默认情况下不会在屏幕上显示任何内容。你可以将它们视为“组件模式”，它们将“底部表单”或“进度条”的概念引入你的应用，而无需你担心用户体验、键盘导航或可访问性实现。只需添加样式即可。</p>

<h2>简洁的 API，提供你所需的样式</h2>

<p>Compose Unstyled 不提供任何特殊的样式 API。所有操作都通过 <code>Modifier</code> 完成。如果你知道如何设置 <code>Box()</code> 的样式，那么你就知道如何设置 Compose Unstyled 中每个组件的样式。</p>

<p>下面是一个使用 Compose Unstyled 构建模态底部表单的简单示例，其中包含自定义定位点（表单在屏幕上“停留”的位置）以及你选择的样式：</p>

<pre><code class="kotlin">val Peek = SheetDetent("peek") { containerHeight, sheetHeight -&gt;
    containerHeight * 0.6f
}
BoxWithConstraints(modifier = Modifier.fillMaxSize().background(Brush.linearGradient(listOf(Color(0xFF800080), Color(0xFFDA70D6))))) {
    val modalSheetState = rememberModalBottomSheetState(
        initialDetent = Hidden,
        detents = listOf(Hidden, Peek, FullyExpanded)
    )
    LaunchedEffect(Unit) {
        delay(50)
        modalSheetState.targetDetent = Peek
    }
    Button(onClick = { modalSheetState.targetDetent = Peek }, modifier = Modifier.align(Alignment.Center).padding(WindowInsets.navigationBars.only(WindowInsetsSides.Horizontal).asPaddingValues()), shape = RoundedCornerShape(6.dp), contentPadding = PaddingValues(horizontal = 14.dp, vertical = 10.dp), backgroundColor = Color.White) {
        Text("Show Sheet", fontWeight = FontWeight(500))
    }
    val isCompact = maxWidth &lt; 600.dp
    ModalBottomSheet(state = modalSheetState) {
        Scrim(
            scrimColor = Color.Black.copy(0.3f),
            enter = fadeIn(),
            exit = fadeOut()
        )
        Box(Modifier.fillMaxSize().padding(top = 12.dp).let { if (isCompact) it else it.padding(horizontal = 56.dp) }.displayCutoutPadding().statusBarsPadding().padding(WindowInsets.navigationBars.only(WindowInsetsSides.Horizontal).asPaddingValues())) {
            Sheet(
                modifier = Modifier
                    .shadow(4.dp, RoundedCornerShape(topStart = 28.dp, topEnd = 28.dp))
                    .widthIn(max = 640.dp)
                    .fillMaxWidth(),
                shape = RoundedCornerShape(topStart = 28.dp, topEnd = 28.dp),
                backgroundColor = Color.White,
                contentColor = Color.Black
            ) {
                Box(Modifier.fillMaxWidth().height(600.dp), contentAlignment = Alignment.TopCenter) {
                    DragIndication(
                        modifier = Modifier.padding(top = 22.dp)
                            .background(Color.Black.copy(0.4f), RoundedCornerShape(100)).width(32.dp).height(4.dp)
                    )
                }
            }
        }
    }
}
</code></pre>

<p>现在，我知道你可能会想。“Alex！这 API 真奇怪。为什么我需要一个 <code>ModalBottomSheet</code> 和一个 <code>Sheet</code>？为什么不直接用 Slots 呢？”</p>

<p>这个设计选择是经过深思熟虑的：</p>

<h2>设计理念</h2>

<p>Compose Unstyled 不会替你做出任何设计决策，而是让你完全掌控布局。事实上，如果你被迫使用无法根据需求更改的样式，则会被视为错误（请提交 GitHub 问题，以便我进行调查）。</p>

<p>例如，你可能希望将底部表单放置在屏幕的左侧或右侧。当你想要求开发者提供一个在布局上具有严格位置的组件时，基于插槽的 API 非常实用。</p>

<p>在这种情况下，你可以将 <code>ModalBottomSheet</code> 组件视为表单可以移动的区域。<code>Sheet</code> 是用户可以与之交互的实际表单。通过提供这样的组件，它为开发者提供了清晰的 API，并清楚地说明了组件的功能。例如，<code>Scrim()</code> 组件具有 <em>enter</em> 和 <em>exit</em> 过渡参数。 Compose Unstyled 会在恰当的时机为纱幕添加和隐藏动画，以实现最佳用户体验。你只需指定“如何”实现即可。</p>

<p>由于 Compose Unstyled 在外观方面非常开放，因此与原始的 Compose Foundation 组件相比，它没有任何平台限制。Foundation 中的“对话框”具有固定的最大尺寸，这使得它们在诸如全屏对话框等情况下难以工作。</p>

<p>Compose Unstyled 中的所有组件在所有平台上的工作方式完全相同。这是有意为之，因为此类决策应该属于设计系统层的一部分。尽管这会给开发者带来更多负担，但由于没有“陷阱”，它大大缩短了开发时间。组件的样式与你描述的完全一致。</p>

<p>这不会使 Compose Unstyled 与底层平台脱节。在使用对话框和模态底部菜单等模态窗口时，设置系统窗口的样式是 Android 样式设置的重要组成部分。在这种情况下，Compose Unstyled 提供了一个 <code>LocalModalWindow</code> 组合本地接口，允许你访问渲染模态窗口的 <code>Window</code>。请注意，此类 API 仅适用于 Android 目标平台，不属于通用目标平台 API。</p>

<p>最后，每个组件的代码都包含在其自己的文件中，即使你不是 Compose 专家，也能轻松理解。你无需担心任何限制。如果你现在需要更改某些内容，并且迫不及待地想要提交错误并在库级别修复它，你只需将组件的单个文件复制粘贴到你的代码库中即可。这为你节省了通常需要你自己完成的 4 周工作时间。</p>

<h2>滑块</h2>

<p>以下是如何构建一个具有你所选样式的滑块。</p>

<p>它与 Compose 的“InteractionState”集成，以便你可以按照自己想要的方式完善组件。键盘交互功能开箱即用，用户可以通过按下键盘上的“向上”或“向下”键来增加或减少值：</p>

<p><img src="file:///Users/alexhilton/Downloads/compose-style-1.png" alt="" /></p>

<pre><code class="kotlin">Box(modifier = Modifier.fillMaxSize().background(Brush.linearGradient(listOf(Color(0xFFED213A), Color(0xFF93291E)))),   contentAlignment = Alignment.Center) {
    val interactionSource = remember { MutableInteractionSource() }
    val isFocused by interactionSource.collectIsFocusedAsState()
    val isPressed by interactionSource.collectIsPressedAsState()
    val state = rememberSliderState(initialValue = 0.7f)
    Row(verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(12.dp), modifier = Modifier.padding(horizontal = 16.dp).widthIn(max = 480.dp).fillMaxWidth()) {
        Button(onClick = { state.value -= 0.1f }, modifier = Modifier.shadow(4.dp, CircleShape), shape = CircleShape, backgroundColor = Color.White, contentPadding = PaddingValues(8.dp),) {
            Icon(VolumeDown, "Decrease")
        }
        Slider(
            interactionSource = interactionSource,
            state = state,
            modifier = Modifier.weight(1f),
            track = {
                Box(Modifier.fillMaxWidth().height(8.dp).padding(horizontal = 16.dp).clip(RoundedCornerShape(100.dp))) {
                    // the 'not yet completed' part of the track
                    Box(Modifier.fillMaxHeight().fillMaxWidth().background(Color(0xFF93291E)))
                    // the 'completed' part of the track
                    Box(Modifier.fillMaxHeight().fillMaxWidth(state.value).background(Color.White))
                }
            },
            thumb = {
                val thumbSize by animateDpAsState(targetValue = if (isPressed) 22.dp else 18.dp)
                val thumbInteractionSource = remember { MutableInteractionSource() }
                val isHovered by thumbInteractionSource.collectIsHoveredAsState()
                val glowColor by animateColorAsState(
                    if (isFocused || isHovered) Color.White.copy(0.33f) else Color.Transparent
                )
                // keep the size fixed to ensure that the resizing animation is always centered
                Box(
                    modifier = Modifier.size(36.dp).clip(CircleShape).background(glowColor),
                    contentAlignment = Alignment.Center
                ) {
                    Thumb(
                        color = Color.White,
                        modifier = Modifier.size(thumbSize).shadow(4.dp, CircleShape).hoverable(thumbInteractionSource),
                        shape = CircleShape,
                    )
                }
            }
        )
        Button(onClick = { state.value += 0.1f }, modifier = Modifier.shadow(4.dp, CircleShape), shape = CircleShape, backgroundColor = Color.White, contentPadding = PaddingValues(8.dp),) {
            Icon(VolumeUp, "Increase")
        }
    }
}
</code></pre>

<h2>下拉菜单</h2>

<p>下拉菜单的正确实现非常复杂，尤其是在键盘导航和焦点管理方面。</p>

<p>要充分体验此组件，请在桌面上试用：点击“Options”按钮以聚焦演示，然后使用键盘的上下箭头键进行导航：</p>

<p><img src="file:///Users/alexhilton/Downloads/compose-style-2.png" alt="" /></p>

<pre><code class="kotlin">class DropdownOption(val text: String, val icon: ImageVector, val enabled: Boolean = true, val dangerous: Boolean = false)
val options = listOf(
    DropdownOption("Select All", Maximize),
    DropdownOption("Copy", Copy),
    DropdownOption("Cut", Scissors, enabled = false),
    DropdownOption("Paste", Clipboard),
    DropdownOption("Delete", Trash2, dangerous = true),
)
var expanded by remember { mutableStateOf(true) }
DropdownMenu(onExpandRequest = { expanded = true }) {
    Button(shape = RoundedCornerShape(6.dp), backgroundColor = Color.White, onClick = { expanded = true }, contentPadding = PaddingValues(horizontal = 14.dp, vertical = 10.dp),) {
        Text("Options", fontWeight = FontWeight(500))
        Spacer(Modifier.width(8.dp))
        Icon(ChevronDown, null)
    }
    DropdownMenuPanel(
        expanded = expanded,
        onDismissRequest = { expanded = false },
        backgroundColor = Color.White,
        shape = RoundedCornerShape(8.dp),
        modifier = Modifier
            .padding(vertical = 4.dp)
            .width(240.dp)
            .shadow(4.dp, RoundedCornerShape(8.dp)),
        enter = scaleIn(
            animationSpec = tween(durationMillis = 120, easing = LinearOutSlowInEasing),
            initialScale = 0.8f,
            transformOrigin = TransformOrigin(0f, 0f)
        ) + fadeIn(tween(durationMillis = 30)),
        exit = scaleOut(animationSpec = tween(durationMillis = 1, delayMillis = 75), targetScale = 1f) + fadeOut(tween(durationMillis = 75))
    ) {
        options.forEachIndexed { index, option -&gt;
            if (index == 1 || index == options.lastIndex) {
                Separator(color = Color(0xFFBDBDBD))
            }
            Button(onClick = { expanded = false }, enabled = option.enabled, modifier = Modifier.padding(4.dp), contentPadding = PaddingValues(horizontal = 8.dp, vertical = 2.dp), contentColor = (if (option.dangerous) Color(0xFFC62828) else LocalContentColor.current).copy(alpha = if (option.enabled) 1f else 0.5f), shape = RoundedCornerShape(8.dp),) {
                Icon(option.icon, null)
                Spacer(Modifier.width(4.dp))
                Text(text = option.text, modifier = Modifier.fillMaxWidth().padding(vertical = 8.dp, horizontal = 4.dp))
            }
        }
    }
}
</code></pre>

<p>以及更多未样式化的组件，例如：</p>

<ul>
<li><a href="https://composables.com/docs/com.composables/core/textfield">TextField</a>，全面支持屏幕阅读器的无障碍功能</li>
<li><a href="https://composables.com/docs/com.composables/core/button">Button</a></li>
<li><a href="https://composables.com/docs/com.composables/core/dialog">Dialog</a></li>
<li><a href="https://composables.com/docs/com.composables/core/radiogroup">Radio Group</a></li>
<li><a href="https://composables.com/docs/com.composables/core/tabgroup">TabGroup</a>，用于构建标签式导航，例如底部应用栏或顶部标签桌面</li>
<li><a href="https://composables.com/docs/com.composables/core/checkbox">复选框</a></li>
<li><a href="https://composables.com/docs/com.composables/core/tristatecheckbox">三态复选框</a></li>
<li><a href="https://composables.com/docs/com.composables/core/toggleswitch">切换开关</a></li>
<li><a href="https://composables.com/docs/com.composables/core/scrollarea">滚动条</a>（没错，就是滚动条。）</li>
</ul>


<p>每个组件在构建时都充分考虑了可访问性，包括合理的语义和完整的键盘导航支持。</p>

<p>你可以<a href="https://composables.com/docs/com.composables/core">在文档中找到完整的组件列表 -></a>（链接：<a href="https://composables.com/docs/com.composables/core%EF%BC%89%E3%80%82">https://composables.com/docs/com.composables/core%EF%BC%89%E3%80%82</a></p>

<h2>使用你的设计令牌自定义 Compose 主题</h2>

<p>Compose Unstyled 包含一个灵活的主题系统，可与任何设计系统令牌兼容。</p>

<p>以下是如何使用你选择的设计令牌创建完全自定义的主题：</p>

<p>以下是创建 Compose Theme 函数的示例：</p>

<pre><code class="kotlin">// define your theme properties
private val colors = ThemeProperty&lt;Color&gt;("colors")
private val typography = ThemeProperty&lt;TextStyle&gt;("typography")
private val shapes = ThemeProperty&lt;Shape&gt;("shapes")
private val elevation = ThemeProperty&lt;Dp&gt;("elevation")
// define your theme tokens.
// those are the potential values of your theme properties
private val background = ThemeToken&lt;Color&gt;("background")
private val card = ThemeToken&lt;Color&gt;("surface")
private val onCard = ThemeToken&lt;Color&gt;("onCard")
private val outline = ThemeToken&lt;Color&gt;("outline")
private val accent = ThemeToken&lt;Color&gt;("accent")
private val primary = ThemeToken&lt;Color&gt;("primary")
private val onPrimary = ThemeToken&lt;Color&gt;("onPrimary")
private val onSecondary = ThemeToken&lt;Color&gt;("onSecondary")
private val secondary = ThemeToken&lt;Color&gt;("secondary")
private val subtle = ThemeToken&lt;Dp&gt;("subtle")
private val titleMedium = ThemeToken&lt;TextStyle&gt;("titleMedium")
private val bodyMedium = ThemeToken&lt;TextStyle&gt;("bodyMedium")
private val cardShape = ThemeToken&lt;Shape&gt;("cardShape")
private val albumCoverShape = ThemeToken&lt;Shape&gt;("albumCoverShape")
private val buttonShape = ThemeToken&lt;Shape&gt;("buttonShape")
// create your Compose Theme and assign values to each token
private val LightTheme = buildTheme {
    name = "LightTheme"
    properties[colors] = mapOf(
        accent to Color(0xFF3B82F6),
        card to Color.White,
        onCard to Color(0xFF1E293B),
        outline to Color(0xFFE2E8F0),
        primary to Color(0xFF2563EB),
        onPrimary to Color.White,
        secondary to Color(0xFFE2E8F0),
        onSecondary to Color(0xFF64748B),
        background to Color(0xFFF8F9FA),
    )
    properties[typography] = mapOf(
        titleMedium to TextStyle(
            fontSize = 18.sp,
            fontWeight = FontWeight.SemiBold,
            fontFamily = loadInterFont(),
        ),
        bodyMedium to TextStyle(
            fontSize = 14.sp,
            fontWeight = FontWeight.Normal,
            fontFamily = loadInterFont(),
        )
    )
    properties[shapes] = mapOf(
        cardShape to RoundedCornerShape(16.dp),
        albumCoverShape to RoundedCornerShape(12.dp),
        buttonShape to CircleShape
    )
    properties[elevation] = mapOf(
        subtle to 8.dp
    )
}
</code></pre>

<p>然后，你可以使用新的主题函数包装你的应用：</p>

<pre><code class="kotlin">@Composable
fun MusicPlayerApp() {
    LightTheme {
        MusicPlayerCard()
    }
}
</code></pre>

<p>然后，它会使用 <code>Theme</code> 对象授予其子组件对主题的访问权限：</p>

<pre><code class="kotlin">@Composable
fun MusicPlayerCard(modifier: Modifier = Modifier) {
    val sliderState = rememberSliderState(initialValue = 0.3f)
    Box(
        modifier = modifier
            .outline(1.dp, Theme[colors][outline], Theme[shapes][cardShape])
            .shadow(Theme[elevation][subtle], Theme[shapes][cardShape])
            .background(Theme[colors][card], Theme[shapes][cardShape])
            .padding(24.dp)
    ) {
        ProvideContentColor(Theme[colors][onCard]) {
            Column(verticalArrangement = Arrangement.spacedBy(20.dp)) {
                Row(verticalAlignment = Alignment.CenterVertically, horizontalArrangement = Arrangement.spacedBy(16.dp)) {
                    Image(
                        painter = painterResource(Res.drawable.just_hoist_it_cover),
                        modifier = Modifier
                            .clip(Theme[shapes][albumCoverShape])
                            .background(Theme[colors][primary])
                            .size(80.dp),
                        contentDescription = "Album Cover",
                        contentScale = ContentScale.Crop
                    )
                    Column(modifier = Modifier.weight(1f)) {
                        Text("Just hoist it!", style = Theme[typography][titleMedium])
                        Spacer(Modifier.height(4.dp))
                        Text(
                            "The Deprecated",
                            style = Theme[typography][bodyMedium],
                            color = Theme[colors][onSecondary]
                        )
                    }
                }
                Slider(
                    state = sliderState,
                    modifier = Modifier.fillMaxWidth(),
                    track = {
                        Box(Modifier.fillMaxWidth().height(4.dp).clip(RoundedCornerShape(2.dp))) {
                            // the empty part of the track
                            Box(Modifier.fillMaxSize().background(Theme[colors][secondary]))
                            // the filled part of the track
                            Box(
                                Modifier.fillMaxWidth(sliderState.value).fillMaxSize().background(Theme[colors][accent])
                            )
                        }
                    },
                    thumb = {
                        Thumb(
                            color = Theme[colors][accent],
                            modifier = Modifier.size(16.dp),
                            shape = Theme[shapes][buttonShape]
                        )
                    }
                )
                Row(modifier = Modifier.fillMaxWidth(), horizontalArrangement = Arrangement.SpaceEvenly, verticalAlignment = Alignment.CenterVertically) {
                    Button(onClick = { }, contentPadding = PaddingValues(12.dp), shape = Theme[shapes][buttonShape]) {
                        Icon(imageVector = Lucide.SkipBack, contentDescription = "Previous", modifier = Modifier.size(20.dp))
                    }
                    Button(onClick = { }, backgroundColor = Theme[colors][primary], contentColor = Theme[colors][onPrimary], contentPadding = PaddingValues(16.dp), shape = Theme[shapes][buttonShape]) {
                        Icon(imageVector = Lucide.Pause, contentDescription = "Pause", modifier = Modifier.size(24.dp))
                    }
                    Button(onClick = { }, contentPadding = PaddingValues(12.dp), shape = Theme[shapes][buttonShape]) {
                        Icon(imageVector = Lucide.SkipForward, contentDescription = "Next", modifier = Modifier.size(20.dp))
                    }
                }
            }
        }
    }
}
</code></pre>

<h2>轮廓修饰符</h2>

<p>最后但同样重要的是，Compose Unstyled 引入了一些 Compose Foundation 中缺少的样式 <code>Modifier</code>，但这些修饰符对于构建视觉丰富的界面必不可少：</p>

<h3>轮廓</h3>

<p>与 Compose Foundation 的 <code>border()</code> 修饰符不同，此修饰符不会影响布局。它还会在组件周围而不是内部进行绘制。当你需要一个与阴影完美融合的半透明轮廓时，这个功能非常方便：</p>

<p><img src="file:///Users/alexhilton/Downloads/compose-style-3.png" alt="" /></p>

<pre><code class="kotlin">SimpleButton(
  shape = RectangleShape,
  modifier = Modifier.outline(2.dp, Color(0xFF3B82F6), shape = RectangleShape)
)
SimpleButton(
  shape = RoundedCornerShape(8.dp),
  modifier = Modifier.outline(2.dp, Color(0xFF3B82F6), shape = RoundedCornerShape(8.dp))
)
SimpleButton(
  shape = CircleShape,
  modifier = Modifier.outline(2.dp, Color(0xFF3B82F6), shape = CircleShape)
)
</code></pre>

<h3>焦点环</h3>

<p>焦点环在处理键盘导航和焦点时非常重要。它们只有在获得焦点时才会渲染轮廓。</p>

<pre><code class="kotlin">val interactionSource = remember { MutableInteractionSource() }
SimpleButton(
    modifier = Modifier.focusRing(
        interactionSource = interactionSource,
        width = 2.dp,
        color = Color(0xFF3B82F6),
        shape = RoundedCornerShape(8.dp),
        offset = 2.dp
    ),
    interactionSource = interactionSource
)
</code></pre>

<h2>然后呢？</h2>

<p>即将推出的组件包括：</p>

<ul>
<li>侧边栏</li>
<li>工具提示</li>
<li>上下文菜单</li>
</ul>


<p>以及更多。</p>

<p>如果你愿意为该项目提供资金支持，我们还提供<a href="https://composables.com/ui-kit">正在制作中的 UI Kit</a>（链接：<a href="https://composables.com/ui-kit%EF%BC%89%E3%80%82%E8%AF%A5">https://composables.com/ui-kit%EF%BC%89%E3%80%82%E8%AF%A5</a> UI Kit 是一套完整的设计系统，适用于触控和指针应用。</p>

<p>为了使这些 API 完美无缺，我们投入了大量的工作和专业知识。通过资金支持该项目，你将在未来几年获得更多资源，而我则可以继续从事开源工作，同时支付房租。</p>

<p>想要随时了解最新动态？请务必<a href="https://github.com/composablehorizo%E2%80%8B%E2%80%8Bns/compose-unstyled/">在 Github 上关注 Unstyled</a>（链接:<a href="https://github.com/composablehorizo%E2%80%8B%E2%80%8Bns/compose-unstyled/%EF%BC%89%E3%80%82">https://github.com/composablehorizo%E2%80%8B%E2%80%8Bns/compose-unstyled/%EF%BC%89%E3%80%82</a></p>

<p>想要评论这篇文章吗？<a href="https://github.com/composablehorizo%E2%80%8B%E2%80%8Bns/compose-unstyled/discussions/106">在 GitHub 上讨论 →</a>（链接：<a href="https://github.com/composablehorizo%E2%80%8B%E2%80%8Bns/compose-unstyled/discussions/106%EF%BC%89">https://github.com/composablehorizo%E2%80%8B%E2%80%8Bns/compose-unstyled/discussions/106%EF%BC%89</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[运行时着色器实战：实现元球（Metaballs）动效]]></title>
    <link href="https://alexhilton.github.io/blog/2025/09/06/metaballs-with-runtimeshaders/"/>
    <updated>2025-09-06T23:19:16+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/09/06/metaballs-with-runtimeshaders</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Metaballs with Runtimeshaders」，原文链接<a href="https://medium.com/@off.mind.by/metaballs-with-runtimeshaders-bb7e5f6b27c2">https://medium.com/@off.mind.by/metaballs-with-runtimeshaders-bb7e5f6b27c2</a>，由Alex Volkov发布于2025810。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:2000/1*fQOua40zD_PlbsejLeHBeg.png" title="auto auto" ></a></p>

<!-- more -->


<p>大家好！今天我想向大家介绍一种最简单却又出人意料地令人印象深刻的效果：元球。</p>

<p>元球是一种看起来像有机体的形状，其特点是它们能够在近距离内融合在一起，形成单个连续的物体。</p>

<p>使用 GLSL 着色器创建这种效果非常简单，只需几行代码即可。当然，你也可以在网上找到关于如何将其移植到 AGSL 并在 Compose 中使用的教程。然而，主要的问题是这种效果需要两个（或更多）物体。我找到的所有教程都只是在单个着色器中模拟两个组件。这种方法在视觉上很有效，但在实际项目中使用时会带来很多限制。因此，我开始以一种每个元素只扭曲自身的方式来构建这种效果——尽可能地让一切看起来公平、干净。</p>

<p>好了，既然我们已经明白了为什么这不仅仅是一个metaball教程，而是一个全新的教程——那就开始吧！和往常一样，我把所有内容分解成几个部分：</p>

<ul>
<li>首先，我会快速解释一下这种效果在经典实现中的工作原理，然后我们会进行哪些不同的调整。</li>
<li>然后，我会介绍一下Compose的简单设置，让它运行起来。</li>
<li>最后，我们会更详细地介绍着色器本身。</li>
</ul>


<p>最终，我们应该得到如下所示的效果：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1192/1*2oZU3pJdUVUq1eR56tVTNw.gif" alt="这只是其中一个选项；这种效果是高度可定制的。" /></p>

<blockquote><p>开始之前，先简单说明一下——我不会为我制作的每个效果都制作教程，但你可以在我的 <a href="https://github.com/AleksiejVolkov/runtimeshaders">GitHub</a> （链接：<a href="https://github.com/AleksiejVolkov/runtimeshaders%EF%BC%89%E4%B8%8A%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%99%E7%A8%8B%E3%80%82%E4%BD%A0%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%88%91%E7%9A%84">https://github.com/AleksiejVolkov/runtimeshaders%EF%BC%89%E4%B8%8A%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%99%E7%A8%8B%E3%80%82%E4%BD%A0%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%88%91%E7%9A%84</a> <a href="https://t.me/droidshaderworks">Telegram 频道</a> 上找到视频、新效果公告以及问题的解答。期待在那里见到你！</p></blockquote>

<p>要创建元球效果，我们先来回顾一下基础知识。如何在着色器中绘制一个简单的圆圈？最简单的方法是定义一个中心和一个半径，然后使用 step 函数。如果像素比半径更靠近中心，则返回 1；如果像素比半径更远离中心，则返回 0。实际代码如下：</p>

<pre><code class="glsl">float ball( vec2 p, vec2 center, float radius ) {
    return step(length(p-center), radius);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Normalized pixel coordinates (from -0.5 to 0.5)
    vec2 uv = fragCoord/iResolution.xy - 0.5;
    uv.x *= iResolution.x / iResolution.y;

    float b1 = ball(uv, vec2(0.), 0.2);

    vec3 color = b1*vec3(1.);

    fragColor = vec4(color,1.0);
}
</code></pre>

<blockquote><p>这段代码是用 GLSL 编写的，而不是 AGSL，你可以直接复制粘贴到 shadertoy.com 中。在本节中，所有代码都将采用相同的方法，让你无需运行 Android Studio 即可更轻松地测试和查看结果。</p></blockquote>

<p><em>结果是一个最简单的圆圈。如果你对着色器稍有了解，这部分应该很容易理解。</em></p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*PTHu_h9ayCxqi-EgVN2nVQ.png" alt="最简单的圆圈" /></p>

<p>现在，让我们添加第二个圆圈，并将它们水平放置，使它们略微分开，而不是同时位于中心。这次，我们不再使用步长函数来定义边缘，而是使用反距离。我们仍然会得到两个圆圈，但边缘不再是锐利的，而是平滑的渐变，使圆圈看起来更像发光的点。</p>

<pre><code class="glsl">float ball(vec2 p, vec2 center, float radius) {
    float dist = length(p - center);
    return radius / dist;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
   // Normalized pixel coordinates (from -0.5 to 0.5)
    vec2 uv = fragCoord/iResolution.xy - 0.5;
    uv.x *= iResolution.x / iResolution.y;

    float b1 = ball(uv, vec2(-0.4,0.), 0.1);
    float b2 = ball(uv, vec2(0.4,0.), 0.1);

    float circles = b1 + b2;

    vec3 color = circles*vec3(1.);

    fragColor = vec4(color,1.0);
}
</code></pre>

<p>最终效果如下：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*rXfBtvZOlpnK98XEy7HyUA.png" alt="" /></p>

<p>如你所见，在最终图像中，我们将两个圆的值相加。即使现在，如果你将它们移近，你也会看到它们开始合并。基本上，效果已经存在——剩下的就是对最终值应用一些函数，或者再次使用 step 函数截断低于特定阈值的所有内容，保留其内部内容。就这样——元球效果完成了！</p>

<pre><code class="glsl">float ball(vec2 p, vec2 center, float radius) {
    float dist = length(p - center);
    return radius / dist;
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    // Normalized pixel coordinates (from -0.5 to 0.5)   
    vec2 uv = fragCoord/iResolution.xy - 0.5;
    uv.x *= iResolution.x / iResolution.y;

    // make circles moving slightly along horizontal direction
    float horiz = (0.5*sin(iTime)+0.5)*0.2;
    float b1 = ball(uv, vec2(-0.3+horiz,0.), 0.1);
    float b2 = ball(uv, vec2(0.3-horiz,0.), 0.1);

    float circles = b1 + b2;

    float threshold = 1.0;
    float alpha = step(threshold, circles);

    vec3 color = alpha*vec3(1.);

    fragColor = vec4(color,1.0);
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*rIVQla9lc5qbYGaCMVmI4g.gif" alt="最简单的元球效果" /></p>

<p>当然，除了阶跃函数，你还可以使用 SmoothStep，添加距离的平方反比，或者尝试不同的公式，调整系数等等。所有这些都是可能的，并且都会改变最终的外观，但核心思想保持不变：我们用平滑衰减公式定义圆，将结果相加，并在某个阈值处进行截断。这样，当形状接近时，它们的场之和会超过阈值，从而合并成一个形状——而当它们相距较远时，则不会合并。</p>

<p>现在我们已经了解了如何创建元球效果，看起来我们只需打开 Android Studio 就可以开始构建了！然而，我们很快就会遇到两个问题：</p>

<ul>
<li>目前，所有按钮都像圆形一样工作——这是意料之中的。但如果我们希望合并按钮具有其他形状，则需要使用例如 SDF 方法。即便如此，形状仍然在着色器内部定义，这意味着我们不能简单地在 Compose 视图中应用 RoundedCornerShape 并期望它能够正常工作。</li>
<li>两个按钮必须在同一个着色器中定义。如果有三个按钮，则三个按钮都必须位于同一个着色器中。最重要的是——我们如何处理这些按钮的点击？</li>
</ul>


<p>如果你查找有关此效果的文章，你会发现这两个问题通常被忽略。然而，对我来说，它们至关重要——这正是我决定撰写本教程的原因。我建议采用一种不同的方法来解决这两个问题。</p>

<p>首先，我们不会在着色器内部定义形状。相反，我们将变形坐标系本身，从而解决不同形状的问题。</p>

<p>其次，效果中的每个元素都会获得自己的着色器实例，但我们也会将相邻元素的坐标传递给它。这解决了点击处理问题，因为现在每个元素都是一个独立的可组合元素，拥有自己的属性和 lambda 表达式。下图所示：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*7yVd3iok98-pQNLWIhP1mQ.png" alt="绿色表示可组合元素。粉色表示着色器" /></p>

<p>因此，我们的任务可以分为两个主要的子任务。一旦解决了这两个子任务，我们就能得到最终的效果。首先，我们需要学习如何变形画布以获得与元球相同的视觉效果。然后，我们将收集容器中每个子元素的位置数据，并将其传递给其他着色器。让我们先从第一部分开始。</p>

<p>让我们从使用着色器所需的最简单的设置开始。下面是可组合部分——你可以直接复制粘贴到你的项目中，它应该可以立即运行。</p>

<pre><code class="kotlin">@Composable
fun MetaballShaderScreen(paddingValues: PaddingValues) {
    val shader = remember { RuntimeShader(metaballShader) }

    Box(modifier = Modifier
            .padding(paddingValues)
            .fillMaxSize()
            .background(Color(0xFF171717)),
        contentAlignment = Alignment.Center
    ) {
        ShadedButton(shader)
    }
}

@Composable
fun ShadedButton(

shader: RuntimeShader,) {
    var boxSize by remember { mutableStateOf(IntSize.Zero) }
    Box(
        contentAlignment = Alignment.Center,
        modifier = Modifier.size(50.dp)
    ) {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .onSizeChanged { boxSize = it }
                .graphicsLayer {
                    shader.setFloatUniform(
                        "resolution",
                        boxSize.width.toFloat(),
                        boxSize.width.toFloat())
                    this.renderEffect = RenderEffect
                        .createRuntimeShaderEffect(shader, "image")
                        .asComposeRenderEffect()
                }
        ) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .clip(RoundedCornerShape(10.dp))
                    .background(color = Color(0xFFF6F6F6))
            )
        }
        Icon(
            imageVector = Icons.Default.MoreVert,
            contentDescription = "Expand Menu",
            tint = Color.Black
        )
    }
}
</code></pre>

<p>以下是着色器代码：</p>

<pre><code class="kotlin">@Language("AGSL")
private val metaballShader = """
    uniform vec2 resolution;
    uniform shader image;

    vec2 NormalizeCoordinates(vec2 o, vec2 r) {

        float2 uv = o / r - 0.5;

        if (r.x &gt;= r.y) {
            uv.x *= r.x / r.y;
        } else {
            uv.y *= r.y / r.x;
        }

        return uv;
    }

    vec4 GetImageTexture(vec2 p, vec2 pivot, vec2 r) {

        if (r.x &gt; r.y) {
            p.x /= r.x / r.y;
        } else {
            p.y /= r.y / r.x;
        }

        p += pivot;    
        p *= r;

        return image.eval(p);
    }

    vec4 main(float2 fragCoord) {
        float2 uv = NormalizeCoordinates(fragCoord, resolution);
        vec4 final = GetImageTexture(uv, vec2(0.5), resolution);
        return vec4(final);
    }""".trimIndent()
</code></pre>

<blockquote><p>在着色器中，我已经包含了两个必要的方法：一个用于规范化，一个用于从输入纹理中获取颜色。我在之前的课程中介绍过这些方法，因此你可以简单地将它们视为必需的样板代码——它们不会影响效果的核心逻辑——或者查看我之前的教程，我在那里详细解释了它们。本课程已经相当丰富，甚至可能信息量过大，所以我在这里就不赘述了。</p></blockquote>

<p>太好了！如果一切设置正确，我们将得到一个尚未添加任何内容的着色器——它只是绘制所有内容，就像着色器根本不存在一样。结果应该只是一个普通的按钮，没什么特别的：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*V_yEnqGelKeDKYaPwUklTg.png" alt="没什么特别的，只是一个按钮 :)" /></p>

<p>在最终的代码中，变形将基于其他元素，但由于我们目前还没有这些元素，我只需添加一个虚拟点并将其绘制在画布上即可。这只是测试代码，我们稍后会将其移除。我还会将时间传递给着色器，并使该点水平移动。这将是我们的虚拟点，我们将使用它作为画布变形的参考：</p>

<pre><code class="kotlin">//...
 var time by remember { mutableStateOf(0f) }
//...
  .graphicsLayer {
       //...
        shader.setFloatUniform("time", time)
//...
</code></pre>

<p>在着色器代码中，我们必须添加时间统一函数：</p>

<pre><code class="glsl">    uniform float time;
</code></pre>

<p>并添加虚拟圆：</p>

<pre><code class="glsl"> float getCircle(vec2 p, vec2 pivot) {
        return step(length(pivot - p), 0.1);
 }
</code></pre>

<p>同时将虚拟圆添加到最终输出中：</p>

<pre><code class="glsl"> vec4 main(float2 fragCoord) {
        //...

        float circleHorizontalPosition = sin(0.5*time)*2.;
        float helperCicrle = getCircle(uv, vec2(circleHorizontalPosition, 0.));

        final = mix(final, helperCicrle*vec4(1.,0.,0.,1.), helperCicrle);
        return vec4(final);
}
</code></pre>

<p>这样，我们应该看到一个红色的参考点，我们将以此为基础来扭曲按钮。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*rikNEHT918EmDeWLzQsWbA.gif" alt="" /></p>

<p>现在，让我们尝试计算控制点对按钮的影响，使用与计算元球完全相同的方法：</p>

<pre><code class="glsl"> float getInfluence(vec2 uv, vec2 controlPoint) {
        float dist = length(controlPoint-uv);
        return 1./dist;
 }

 vec4 main(float2 fragCoord) {
        float2 uv = NormalizeCoordinates(fragCoord, resolution);

        float circleHorizontalPosition = sin(0.2*time)*2.;
        vec2 controlPointPos = vec2(circleHorizontalPosition, 0.);
        float helperCicrle = getCircle(uv, controlPointPos);

        float influence = getInfluence(uv, controlPointPos);

        uv *= 1.-influence; // why here is 1 - influence was explained in Deform the Canvas tutorial
        vec4 final = GetImageTexture(uv, vec2(0.5), resolution);

        final = mix(final,helperCicrle*vec4(1.,0.,0.,1.),helperCicrle);
        return vec4(final);
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*ivjxpAXa4_O6hDtt.gif" alt="够搞笑的，但这不是我们想要的" /></p>

<p>结果很搞笑，但不是我们的预期。内部的瑕疵（“洞”效果）可以通过将影响值限制在 0 到 1 之间轻松修复。然而，这仍然不是我们想要的结果——我们得到的是控制点周围的区域膨胀了，而我们需要的效果几乎是相反的。那么，我们该如何实现呢？</p>

<p>答案很简单，也有点意思——虽然我花了一些时间才明白。这个想法是将坐标中心到控制点的距离与两个距离之和进行比较：从中心到当前点 (uv) 的距离，以及从当前点到控制点的距离。下图是按钮内部一个随机点的示意图。这个距离总是大于直接到中心的距离，而这个技巧就是让我们实现元球效果的关键！</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*n7kIFbwMCFNmhinMLfBP6g.png" alt="如果我们将绿色到红色的距离加上到中心的距离，那么绿色到红色的距离总是大于中心到红色的距离。" /></p>

<p>所以，为了将我们现在的效果变成几乎完整的效果（除了强度设置和其他一些小的调整），我们实际上只需要将中心添加到距离计算中——就这样！</p>

<pre><code class="glsl">  float getInfluence(vec2 uv, vec2 controlPoint) {
        // float dist = length(controlPoint-uv); - was like that
        float dist = length(controlPoint-uv) + length(uv); //added length(uv);
        return 1./dist;
  }
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*ArDCdZxeCKBBmsfQ.gif" alt="我们已经得到了想要的结果" /></p>

<blockquote><p><em>现在可以添加“mass”或除以距离的平方来加快淡出速度。但这些都是完善的细节，并非核心效果逻辑的一部分。我强烈建议你自己尝试一下 getInfluence 方法。</em></p></blockquote>

<p>最后一步是传递另一个组件的坐标，而不是使用着色器内的控制点。听起来很简单，但这里有一些需要讨论的地方。对我来说，最难的部分是获取与着色器本身位于同一“系统”中的坐标。虽然控制点位于着色器内部，但我们使用 uv 创建了它，而 uv 已经根据视图的大小进行了归一化。但是，现在我们要获取相对于父容器的位置。那么，我们如何将所有这些结合起来呢？</p>

<p>首先，让我们在容器中添加第二个按钮，并将所有必要的参数传递给着色器。之后，我们将深入着色器逻辑的核心——在我看来，这是最有趣的部分。</p>

<pre><code class="kotlin">@Composable
fun TestShaderScreen(paddingValues: PaddingValues) {
    val shader = remember { RuntimeShader(metaballShader) }
    val parentBoxSize = remember { mutableStateOf(IntSize.Zero) }
    val firstButtonPosition = remember { mutableStateOf(Offset.Zero) }
    val secondButtonPosition = remember { mutableStateOf(Offset.Zero) }

    Box(
        modifier = Modifier
            .padding(paddingValues)
            .fillMaxSize()
            .background(Color(0xFF171717))
            .onSizeChanged {
                parentBoxSize.value = it
            },
        contentAlignment = Alignment.Center
    ) {
        ShadedButton(
            modifier = Modifier
                .padding(start = 70.dp)
                .size(50.dp)
                .onGloballyPositioned {
                    firstButtonPosition.value = it.positionInParent() +
                            Offset(
                                x = it.size.width * 0.5f,
                                y = it.size.height * 0.5f
                            )
                },
            icon = Icons.Filled.Favorite,
            shader = shader,
            parentBoxSize = parentBoxSize.value,
            otherViewPosition = secondButtonPosition.value,
            myPosition = firstButtonPosition.value,
        )
        ShadedButton(
            modifier = Modifier
                .padding(end = 70.dp)
                .size(50.dp)
                .onGloballyPositioned {
                    secondButtonPosition.value = it.positionInParent() +
                            Offset(
                                x = it.size.width * 0.5f,
                                y = it.size.height * 0.5f
                            )
                },
            icon = Icons.Filled.Star,
            shader = shader,
            parentBoxSize = parentBoxSize.value,
            otherViewPosition = firstButtonPosition.value,
            myPosition = secondButtonPosition.value,
        )
    }
}

@Composable
fun ShadedButton(

modifier: Modifier = Modifier,

icon: ImageVector,

shader: RuntimeShader,

parentBoxSize: IntSize,

myPosition: Offset,

otherViewPosition: Offset,) {
    var boxSize by remember { mutableStateOf(IntSize.Zero) }
    Box(
        contentAlignment = Alignment.Center,
        modifier = modifier
    ) {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .onSizeChanged {
                    boxSize = it
                }
                .graphicsLayer {
                    shader.setFloatUniform(
                        "resolution",
                        boxSize.width.toFloat(),
                        boxSize.width.toFloat()
                    )
                    shader.setFloatUniform(
                        "parentBoxSize",
                        parentBoxSize.width.toFloat(),
                        parentBoxSize.height.toFloat()
                    )
                    shader.setFloatUniform(
                        "otherViewPosition",
                        otherViewPosition.x,
                        otherViewPosition.y
                    )
                    shader.setFloatUniform(
                        "positionInParent",
                        myPosition.x,
                        myPosition.y
                    )
                    this.renderEffect = RenderEffect
                        .createRuntimeShaderEffect(shader, "image")
                        .asComposeRenderEffect()
                }
        ) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .clip(RoundedCornerShape(10.dp))
                    .background(color = Color(0xFFF6F6F6))
            )
        }
        Icon(
            imageVector = icon,
            contentDescription = "Expand Menu",
            tint = Color.Black
        )
    }
}
</code></pre>

<p>基本上，我们添加的只是传递父容器的大小和相邻视图的中心坐标。请记住，由于 Compose 回调返回的位置是左上角，因此我们需要在传递之前对其进行一些调整。另外，请记住，第一个组件应该在 otherViewPosition 参数中接收第二个组件，第二个组件也应该接收第一个组件。最重要的是不要混淆它们 :)</p>

<p>让我们继续讨论着色器。我们将从添加必要的 uniform 开始。</p>

<pre><code class="glsl"> uniform float2 otherViewPosition;
 uniform float2 parentBoxSize;
 uniform float2 positionInParent;
</code></pre>

<p>现在到了有趣的部分：之前的控制点现在需要根据两个参数来计算——父级的大小以及第二个视图相对于父级的坐标。</p>

<p>首先，我们来获取容器大小与按钮大小的比率。</p>

<pre><code class="glsl">  float parentRatio = parentBoxSize.x / resolution.x;
</code></pre>

<p>现在我们只需要稍微修改一下 getInfluence 方法，就能将所有内容整合到一个坐标系中：</p>

<pre><code class="glsl">float getInfluence(vec2 uv, float ratio) {
        float2 posInParentNormalized = (positionInParent/parentBoxSize) - 0.5;
        float2 controlPoint = otherViewPosition / parentBoxSize - 0.5;
        controlPoint.x = (controlPoint.x-posInParentNormalized.x) * ratio;

        float dist = max(1., length(controlPoint-uv) + length(uv));
        float influence = smoothstep(0.,1., 1./pow(dist,2.));
        return influence;
    }
</code></pre>

<p>听起来很简单，但实际上，过程中出现了一些不太明显的计算。而且这些计算并非一眼就能轻易掌握。所以我尽量把它解释得清晰易懂。所以，从整体上看，我们得到的是这样的：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*ttaLU6zCxuP0vuHWmtkgGA.png" alt="左边是我们的“活动”视图。想象一下，我们始终处于视图着色器的“内部”。" /></p>

<p>好的，我们有父容器、它的大小、我们视图相对于父容器的位置，以及相邻视图（我们之前示例中的控制点）的位置。我们的任务是将这个控制点放到我们的UV坐标系中。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*S6fLIECuZWm-UYymAuwPbg.png" alt="从上到下的整个过程" /></p>

<p>我尝试自上而下地解释了整个过程。现在让我们再看一下代码，并逐步讲解一下。</p>

<pre><code class="glsl">  float2 posInParentNormalized = (positionInParent/parentBoxSize) - 0.5;
  float2 controlPoint = otherViewPosition / parentBoxSize - 0.5;
  float parentRatio = parentBoxSize.x / resolution.x;
  controlPoint.x = (controlPoint.x-posInParentNormalized.x) * parentRatio;
</code></pre>

<p>假设父容器的宽度为 500。我们在其中的位置为 100，相邻视图的位置为 400。首先，我们获取两个视图相对于父容器的标准化坐标（偏移 -0.5）。在本例中，我们的位置为 -0.3，相邻视图的位置为 0.2。因此，它们之间的距离为 0.5——即父容器宽度的一半。但请记住，我们位于附加到自身视图的着色器内部，因此必须将这个值乘以父容器大小与我们视图大小的比值。这是关键的一步：我们现在得到的不是 0.5，而是另一个值，但它位于我们视图的坐标系中。由此，我们可以计算距离，并执行之前对虚拟控制点执行的所有操作！</p>

<blockquote><p>_这里我将所有内容简化为水平坐标，但同样的逻辑也适用于垂直坐标。我只是不想让本来就很复杂的解释更加难以理解。</p></blockquote>

<p>最终，我们得到了：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*OWQ-vSnQ3yAiPloRXBRXQw.png" alt="静态看起来有点奇怪，但很明显两个视图是相互影响的。" /></p>

<p>最后一步是用数组替换这两个视图，这样我们就可以添加第三个、第四个甚至第五个按钮。</p>

<p>在着色器中，不能使用动态数组，所以我们需要设置一个上限——我选择了 10 个元素。我们还需要一个单独的计数器来记录实际有多少个元素。由于数组不能留空，在 Compose 中，我们会自动用零位置填充未使用的槽位，但计数器会确保这不会影响最终结果。</p>

<p>因此，在着色器中，uniform 变量看起来如下：</p>

<pre><code class="glsl"> uniform int count;
 uniform float2 positions[10];
 uniform float2 parentResolution;
 uniform float2 positionInParent;
</code></pre>

<p>如果多个相邻元素同时影响视图，getInfluence 方法将循环遍历所有元素并累积影响。</p>

<pre><code class="glsl">float getInfluence(float2 uv, float ratio) {
    float influence = 0.0;
    for (int i = 0; i &lt; 10; i++) {
        float posInParentNormalized = (positionInParent/parentBoxSize) - 0.5;
        float2 controlPoint = positions[i] / parentBoxSize - 0.5;
        controlPoint.x = (controlPoint.x-posInParentNormalized) * r;
        float dist = max(1.,length(controlPoint-uv) + length(uv));
        float rawScale = 1./pow(dist,2.);
        influence += smoothstep(0., 1., rawScale);

        if(i==count-1) break;
    }
    return clamp(influence,0.,1.);
}
</code></pre>

<p>在 Compose 中，我们需要添加一个列表并仔细传递所有值。你也可以添加动画和其他效果，但这会使 Compose 代码过载，在本课中更难理解。本教程已经相当丰富，所以我只演示如何将值传递到数组中——其余的实验留给你自己 :) 记住，你可以随时查看我的代码库以获取完整版本。</p>

<p>下面是我编写的一个扩展方法，用于方便地向着色器添加列表。</p>

<pre><code class="kotlin">fun RuntimeShader.setVec2ArrayUniform(

name: String,

values: List&lt;Pair&lt;Float, Float&gt;&gt;,

maxSize: Int = 10) {
    require(values.size &lt;= maxSize) {
        "Too many elements for uniform '$name'. Maximum allowed is $maxSize, but got ${values.size}"
    }

    val padded = values + List(maxSize - values.size) { 0f to 0f }
    val floatArray = padded.flatMap { listOf(it.first, it.second) }.toFloatArray()

    this.setFloatUniform(name, floatArray)
}
</code></pre>

<p>用法：</p>

<pre><code class="kotlin">  shader.setVec2ArrayUniform(name, values)
</code></pre>

<p>现在你可以添加不同的元素，并观察它们在动画过程中平滑地合并或分离：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*s01C-TPOXIfOwZDg.gif" alt="以下是三个不同形状的视图" /></p>

<p>感谢你的阅读！如果你觉得我的实验有趣且我的解释对你有帮助，欢迎加入我的<a href="https://t.me/droidshaderworks">Telegram频道</a>或在<a href="https://x.com/KrowaNaMostku">Twitter (X)</a>上关注我。这个项目只是我的一个爱好，说实话，我的动力很大程度上取决于收到的反馈——所以我非常高兴在频道里见到你。如果你愿意，请在你的社交媒体上分享这篇文章，我将不胜感激。祝你撸码愉快！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转Shader之学会如何变形画布]]></title>
    <link href="https://alexhilton.github.io/blog/2025/09/05/deform-the-canvas/"/>
    <updated>2025-09-05T22:24:46+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/09/05/deform-the-canvas</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Deform the canvas」，原文链接<a href="https://medium.com/@off.mind.by/deform-the-canvas-57dc59bec42a">https://medium.com/@off.mind.by/deform-the-canvas-57dc59bec42a</a>，由Alex Volkov发布于2025年8月2日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:2000/1*DTU5ja0MLebUmXQMg9qi9w.png" title="auto auto" ></a></p>

<!-- more -->


<p>大家好！使用着色器时，我总是着迷于如何轻松创建看起来精致而昂贵的效果。今天的文章就是另一个很好的例子。最近，我的 Telegram 频道的一位订阅者问我，如何在用手指拖动视图时创建拉伸效果。自然而然地，我立刻想到了用着色器来实现。现在结果已经出来了，我很高兴分享我的构建过程。和往常一样，这篇文章分为几个部分：第一部分展示了 Compose 的简单设置，第二部分逐步讲解着色器，最后，我们将在 Compose 中添加一些小细节，这些细节实际上构成了 90% 的视觉效果——尽管这可能感觉有点不公平。</p>

<p>最终效果如下：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1196/1*M42RvZvThTrI7UMjelqb5w.gif" alt="最终结果" /></p>

<blockquote><p>在深入探讨之前，我想提醒你，我并没有为所有效果创建教程。不过，所有效果都可以在我的 <a href="https://github.com/AleksiejVolkov/runtimeshaders">GitHub</a> (链接：<a href="https://github.com/AleksiejVolkov/runtimeshaders">https://github.com/AleksiejVolkov/runtimeshaders</a>)上找到。你还可以在我的 <a href="https://t.me/droidshaderworks">Telegram 频道</a> 中找到视频、新效果的公告以及问题的解答。期待在那里见到你！</p></blockquote>

<p>让我们从最基本的 Compose 设置开始。在本教程中，我不会包含任何背景图片或额外的样式。我们会尽可能地保持简洁。我们只需要一个应用着色器的容器、一些着色器本身的参数，以及一个放置在着色器盒内的菜单或列表的基本模拟。以下是我们开始所需的基本设置：</p>

<pre><code class="kotlin">val shader = remember { RuntimeShader(runtimeShader) }
var targetPercentage by remember { mutableFloatStateOf(0f) }
val percentage = animateFloatAsState(
    targetValue = targetPercentage, 
    animationSpec = tween(
          durationMillis = 1000, 
          easing = ElasticOutEasing)
    )
val pressed = remember { mutableStateOf(false) }
var fingerPosition by remember { mutableStateOf(Offset.Zero) }
var fingerStartPosition by remember { mutableStateOf(Offset.Zero) }Box(
  modifier = Modifier
            .onSizeChanged { size -&gt;
                shader.setFloatUniform(
                    "resolution", size.width.toFloat(), size.height.toFloat()
                )
            }
            .pointerInput(Unit) {
                awaitPointerEventScope {
                    while (true) {
                        val event = awaitPointerEvent()
                        val change = event.changes.firstOrNull() ?: continue
                        pressed.value = change.pressed

                        if (change.pressed) {
                            if (change.previousPressed.not()) {
                               fingerStartPosition = change.position
                            }
                            targetPercentage = 1f
                            fingerPosition = change.position - fingerStartPosition
                        } else {
                            targetPercentage = 0f
                        }

                        event.changes.forEach { it.consume() }
                    }
                }
            }
            .graphicsLayer {
                if (pressed.value) {
                    shader.setFloatUniform("percentage", 1f)
                } else {
                    shader.setFloatUniform("percentage", percentage.value)
                }
                shader.setFloatUniform("touch", fingerPosition.x, fingerPosition.y)

                this.renderEffect = RenderEffect
                    .createRuntimeShaderEffect(shader, "image")
                    .asComposeRenderEffect()
            }
            .clickable {
                targetPercentage = if (targetPercentage == 0f) 1f else 0f
            }
    ) {
      //... 这里是下拉列表本身或任何其他可以通过拖动拉伸的可组合项
    }    
</code></pre>

<p><strong>shader -</strong> 这是着色器本身，我们将在第二部分中编写它。</p>

<p><strong>targetPercentage</strong>、<strong>percentage</strong> 和 <strong>pressed -</strong> 这些控制传递给着色器的效果强度。我们需要它们来为用户抬起手指后的“反弹”效果添加动画效果。思路很简单：当有活动触摸时，强度为 1（最大值），当用户抬起手指时，我们将其动画化为 0。我们将使用自定义的 <strong><em>ElasticOutEasing</em></strong> 来代替常规的线性动画，我将在最后一节中对其进行描述。</p>

<p><strong>fingerPosition</strong> 和 <strong>fingerStartPosition -</strong> 我们只将增量向量传递给着色器，这意味着我们关心方向和强度（向量长度）。拉伸始终从中心开始（我发现这比从精确的触摸点开始更美观）。因此，我们存储两个值，并将它们的差值传递给着色器。</p>

<p>接下来，在 <strong>onSizeChanged</strong> 中，我们将视图大小传递给着色器。在 pointerInput 中，我们跟踪拖动并计算增量向量。最后，在 <strong>graphicsLayer</strong> 中，我们将增量和效果强度传递给着色器。</p>

<p>接下来是包含将要拉伸的视图示例的代码块。它实际上只是一段基本的占位符代码，所以我认为不值得详细分析。我将其包含在这里只是为了方便——这样你就可以复制它，而不必担心自己编写它：</p>

<pre><code class="kotlin">val actions = listOf("Cut", "Copy", "Paste", "Edit")
Column(
    modifier = Modifier
        .width(250.dp)
        .background(Color(0x8843484C), RoundedCornerShape(8.dp))
        .border(1.dp, Color.Gray, RoundedCornerShape(8.dp))
        .padding(8.dp)
) {
    actions.forEach { action -&gt;
        Text(
            text = action,
            color = Color.White.copy(alpha = 0.8f),
            modifier = Modifier
                .fillMaxWidth()
                .padding(vertical = 8.dp, horizontal = 16.dp)
        )
        if(action != "Edit") {
            HorizontalDivider()
        }
    }
}
</code></pre>

<p>Compose 的设置就到这里！让我们开始编写着色器吧！</p>

<p>我们从最简单的着色器开始。下面是输出输入的极简代码，无需进行任何重大更改。我唯一添加的是一个辅助方法，方便以后修改。它叫做 <strong>GetImageTexture</strong>。从技术上讲，你可以使用 <strong>image.eval(fragCoord)</strong> 返回所有未更改的图像，但是一旦在重新映射图像之前开始修改坐标，就需要处理宽高比和图像平移——这基本上就是使用以画布中心为中心的坐标系。这个方法可以处理这些问题。你只需向它传递标准化的 UV 坐标、自定义中心点和分辨率，它就会返回正确的结果。如果你现在使用这些设置运行着色器，你应该会看到与不使用着色器时完全相同的图像。这是一个好兆头！</p>

<pre><code class="kotlin">private val runtimeShader = """
    uniform shader image;
    uniform float2 resolution;
    uniform float percentage;
    uniform float2 touch;

    vec4 GetImageTexture(vec2 p, vec2 pivot, vec2 r) {

    p.x /= r.x / r.y;

    p += pivot;

    p *= r;

    return image.eval(p);

    }

    half4 main(float2 fragCoord) {

    float ratio = resolution.x / resolution.y;

    float2 uv = fragCoord / resolution - 0.5;

    uv.x *= ratio;

    vec4 img = GetImageTexture(uv, vec2(0.5), resolution);

    return half4(img.rgb, img.a);

    }""".trimIndent()
</code></pre>

<p>你在这里看到的应该非常熟悉——几乎所有我的着色器都是这样启动的，说实话，大多数其他着色器也是如此。我再重复一遍：我们获取 fragCoord，它是每个像素相对于视图画布的位置。在此基础上，我们创建一个标准化的 UV 坐标系，根据宽高比进行调整，并偏移 0.5——这将原点置于视图的正中央。并非每个人都这样做，但我觉得这样更方便。它可以“免费”地实现很多效果，比如镜像行为，因为我们只围绕中心计算一次所有内容，而不是分别处理每条边。下面是我们画布的示意图。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*1aPwjWpXJgxlQ8-mCJ2JBA.png" alt="方形画布的简单 UV 图示" /></p>

<p>好了，现在该了解一下我们想要实现的效果了。我们需要从中心（在当前实现中）沿着特定向量拉伸画布，同时保持其余部分不变。那么，如何拉伸画布呢？其实，最简单的方法就是乘以一个数字！让我们测试一下——添加一个比例变量并尝试一下。最后，我们将 UV 乘以这个比例向量。</p>

<pre><code class="glsl">vec2 scale = vec2(0.8, 1.2);
uv *= vec2(scale.x, scale.y);vec4 img = GetImageTexture(uv, vec2(0.5), resolution);
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*_C7fYI8VQn5WKMOFUSnbdA.png" alt="左边是原始图像，右边是我们应用了缩放效果的图像。" /></p>

<p>尝试使用不同的<strong>scale</strong>值来更好地感受效果。正如你所注意到的——使用1不会改变任何值，因为乘以1后值保持不变。小于1的值会拉伸图像，而大于1的值会压缩图像。记住这一点——我们稍后会计算缩放强度并将其从1中减去，这样当缩放为零时，效果也为零，这意味着我们乘以了一个单位向量。</p>

<p>太好了，现在让我们将触摸位置添加到计算中。简单回顾一下——我们从触摸中接收了一个位移向量。因此，当手指触摸屏幕时，向量为 (0, 0)。如果我们将手指向右移动 20 像素，则得到 (20, 0)。我们首先需要对这个向量进行归一化，并将其乘以宽高比。</p>

<pre><code class="glsl">vec2 nMouse = touch / resolution;
nMouse.x *= ratio;
</code></pre>

<p>如果我们将手指向左移动 20 像素，则会得到一个 (-20, 0) 的向量。因此，我们不会直接使用这个向量作为比例，而是取其长度。它看起来会像这样：</p>

<pre><code class="glsl">vec2 scale = vec2(length(nMouse.x), length(nMouse.y));
</code></pre>

<p>记住，没有效果意味着乘以 1，而不是乘以 0？这就是为什么在使用比例向量时，我们在应用之前先将其从 1 中减去：</p>

<pre><code class="glsl">uv *= vec2(1.0) - scale;
</code></pre>

<p>如果一切设置正确，我们现在应该能够控制沿两个轴的拉伸。大致如下所示：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:800/1*ix2Fe4IcYGkQ_iHmSHJ3jA.gif" alt="" /></p>

<p>一切看起来都很好——现在我们只需要在一个方向上应用拉伸。为此，我们可以使用向量的点积。原理很简单：如果向量指向同一方向，则此运算返回正值；如果向量指向相反方向，则返回负值。我强烈建议你在专用资源上阅读更多关于此运算（以及其他向量运算）的内容，因为线性代数是着色器中一切的基础。在这里，我将向你展示它在实践中的工作原理！</p>

<pre><code class="glsl">float influence = dot(normalize(nMouse), uv);
scale *= influence;
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*aKRAalWcQzf2Jugs18aEoQ.png" alt="应用点积后" /></p>

<p>如你所见，效果已经近乎完美！但我不太喜欢另一侧在另一个方向上变形（即被压缩）。这是点积的副作用——当它返回负值时，缩放比例也会变为负值，画布的这一部分会被挤压。我希望保持视图的这一部分不变，所以我添加了一个从零到定义最大值的线性插值。</p>

<pre><code class="glsl">influence = smoothstep(0., 1.5, influence);
</code></pre>

<p>最后一步是乘以“效果强度”，我们通过百分比参数传递该强度（也许这不是最好的命名，但我习惯这样称呼它）。这不会改变拖动过程中的行为，但它可以让我们在拖动结束后平滑地将视图恢复到原始状态。</p>

<pre><code class="glsl">scale *= percentage;
</code></pre>

<p>就是这样！着色器已准备就绪。以下是完整代码——尽管最终的视觉效果看起来丰富而复杂，但它简洁明了。在最终版本中，我还限制了 x 轴和 y 轴上的最大缩放值。你可以根据需要随意调整这些值。</p>

<pre><code class="glsl">uniform shader image;
uniform float2 resolution;
uniform float percentage;
uniform float2 touch;

vec4 GetImageTexture(vec2 p, vec2 pivot, vec2 r) {
    p.x /= r.x / r.y;
    p += pivot;
    p *= r;
    return image.eval(p);
} half4 main(float2 fragCoord) {
    float ratio = resolution.x / resolution.y;
    float2 uv = fragCoord / resolution - 0.5;
    uv.x *= ratio;
    vec2 nMouse = touch / resolution;
    nMouse.x *= ratio;

    vec2 scale = vec2(min(length(nMouse.x), 0.3), min(length(nMouse.y), 0.4));
    float influence = dot(normalize(nMouse), uv);

    influence = smoothstep(0., 1.5, influence);
    scale *= influence;
    scale *= percentage;

    uv *= vec2(1.0) - scale;

    vec4 img = GetImageTexture(uv, vec2(0.5), resolution);

    return half4(img);
}
</code></pre>

<p>现在来看看我从 Compose 中留下的部分——ElasticOutEasing。在 Compose 中创建动画时，你可以使用内置的缓动函数，也可以定义自己的缓动函数。我使用了一个简单的弹性缓动函数示例，如下所示：</p>

<pre><code class="kotlin">val ElasticOutEasing = Easing { t -&gt;
    val p = 0.3f
    if (t == 0f || t == 1f) t
    else {
        val s = p / 4
        2f.pow(-10f * t) * sin((t - s) * (2f * PI.toFloat()) / p) + 1f
    }
}
</code></pre>

<p>此缓动函数在动画结束时创建类似弹跳的效果。它一开始很快，然后略微超过目标并稳定下来，模仿弹簧的行为。其核心思想是将指数衰减 (2^-10t) 与正弦波相结合，以模拟弹性运动。它在起始 (0) 和结束 (1) 处返回精确值，但在两者之间添加了一个抖动。</p>

<p>你也可以使用常规的线性缓动，但结果看起来会更加平淡。这正是我在开头提到的——这个小细节为整体效果的流畅度和令人满意的体验贡献了 90%！</p>

<p>感谢你的阅读！如果你觉得我的实验有趣且我的解释对你有帮助，欢迎加入我的 <a href="https://t.me/droidshaderworks">Telegram 频道</a> 或在 <a href="https://x.com/KrowaNaMostku">Twitter (X)</a> 上关注我。这个项目只是我的一个爱好，说实话，我的动力很大程度上取决于收到的反馈——所以我非常高兴在频道里见到你。如果你愿意的话，请将这篇文章分享到你的社交媒体上，我将不胜感激。祝你撸码愉快！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入浅出着色器：极坐标系与炫酷环形进度条]]></title>
    <link href="https://alexhilton.github.io/blog/2025/08/18/circle-bar-with-shader/"/>
    <updated>2025-08-18T22:20:10+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/08/18/circle-bar-with-shader</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Circle bars with AGSL」，原文链接<a href="https://medium.com/@off.mind.by/circle-bars-with-agsl-37d0612c34a2">https://medium.com/@off.mind.by/circle-bars-with-agsl-37d0612c34a2</a>，由Alex Volkov发布于2025年1月6日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:2000/1*eA4A8yhl-BSTW4EoFMDRJw.jpeg" title="auto auto" ></a></p>

<!-- more -->


<p>大家好！今天，我将向大家讲解如何使用极坐标系。这是一个重要但又相当简单的主题，因此我选择了一个直截了当的效果，以避免过多地深入讲解其他细节。与往常一样，本教程分为几个部分。首先，我将概述设置着色器所需的最简 Compose 代码。在第二部分中，我将详细解释着色器本身以及使用极坐标的原理。最后，我们将进行一些收尾工作，使效果更加惊艳。</p>

<p>最终，我们将实现如下效果：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1000/1*RA4vKEMtnGVL78RVxe9Avg.gif" alt="" /></p>

<blockquote><p>在深入探讨之前，我想提醒你，我并没有为每个效果创建教程。不过，所有效果都可以在我的 <a href="https://github.com/AleksiejVolkov/runtimeshaders">GitHub</a> （链接：<a href="https://github.com/AleksiejVolkov/runtimeshaders%EF%BC%89%E4%B8%8A%E6%89%BE%E5%88%B0%E3%80%82%E4%BD%A0%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%88%91%E7%9A%84">https://github.com/AleksiejVolkov/runtimeshaders%EF%BC%89%E4%B8%8A%E6%89%BE%E5%88%B0%E3%80%82%E4%BD%A0%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%88%91%E7%9A%84</a> <a href="https://t.me/droidshaderworks">Telegram 频道</a> 中找到视频、新效果的公告以及问题的解答。期待在那里见到你！</p></blockquote>

<p>和往常一样，让我们从布局开始。我将基础 Compose 组件命名为“TimerShaderScreen”。在组件内部，我们将从一个“Column”容器开始，该容器顶部包含一个输入字段，后面跟着一个“Box”。这个“Box”在同一层级上包含一个将应用着色器的“Box”和一个显示当前计时器值的“Text”元素（这一点很重要）。从技术上讲，我们可以只使用一个“Box”，但这会使着色器稍微复杂一些。为了简化本教程，我选择了稍微复杂的构图，以使着色器保持简洁。在这个“Box”之后，有一个用于启动计时器的按钮。我提供了一个布局图，以便更清晰地展示，但总的来说，布局本身已经非常简单了。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*oIa0bosA1IbHuMZVKw9tFw.png" alt="" /></p>

<p>接下来，让我们添加必要的变量并定义整个布局。由于我们尚未准备好着色器，因此你可以暂时跳过“RuntimeShader”变量，只需运行项目并确保一切正常即可。我想强调一个重要的细节：如果你将着色器应用于一个不包含任何内容的“Box”，则需要为其设置背景颜色。这确保它参与合成，从而使我们的效果可见。但是，务必在应用“graphicsLayer”之后设置背景颜色。否则，只会渲染颜色，着色器将不可见。目前，布局应该如下所示：</p>

<pre><code class="kotlin">@Composable
fun TimerShaderScreen(paddingValues: PaddingValues) {
    var startValue by remember { mutableStateOf(20) }
    var percentage by remember { mutableFloatStateOf(0.0f) }
    var isRunning by remember { mutableStateOf(false) }
    val seconds = remember { mutableStateOf(startValue) }

    // circularTimeShader是一个包含着色器代码的字符串对象，我们将在下面的部分中编写
    val shader = remember { RuntimeShader(circularTimerShader) }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(paddingValues),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        OutlinedTextField(
            value = if (startValue != 0) startValue.toString() else "",
            onValueChange = {
                startValue = it.toIntOrNull() ?: 0
            },
            label = { Text("Start value") },
            modifier = Modifier.width(200.dp)
        )
        Box(
            modifier = Modifier.size(250.dp),
            contentAlignment = Alignment.Center
        ) {
            Box(
                modifier = Modifier
                    .size(250.dp)
                    .onSizeChanged {
                        shader.setFloatUniform("resolution", it.width.toFloat(), it.height.toFloat())
                    }
                    .graphicsLayer {
                        shader.setFloatUniform("percentage", percentage)
                        renderEffect = RenderEffect.createRuntimeShaderEffect(shader, "image").asComposeRenderEffect()
                    }
                    .background(color = Color.Black), // &lt;-- 我们必须添加一些颜色，否则空框就会从构图中移除，就看不出效果了
            )

            Text(
                modifier = Modifier
                    .fillMaxWidth(),
                textAlign = TextAlign.Center,
                text = seconds.toString(),
                fontSize = 50.sp,
                fontWeight = FontWeight.Thin,
                color = Color.White
            )
        }

        OutlinedButton(
            onClick = { isRunning = !isRunning },
            modifier = Modifier.padding(top = 16.dp)
        ) {
            Text(if (isRunning) "Stop" else "Start")
        }
    }
}
</code></pre>

<p>这是它在手机上的实际显示效果：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:924/1*HPGAGRtgTmxrihj91xiRXw.png" alt="" /></p>

<p>剩下的就是添加计时器本身的逻辑，然后我们就可以开始进入正文了。首先，让我们创建一个 <code>LaunchedEffect</code> 来在计时器运行时更新其值。同时，我们将在此代码块中计算着色器的 <code>percentage</code>。由于我们的着色器会从计时器的起始值向下过渡到零，因此我们需要对 <code>percentage</code> 变量进行归一化，使其相应地从 0 变为 1。代码如下：</p>

<pre><code class="kotlin">LaunchedEffect(isRunning) {
    val startTime = System.currentTimeMillis()
    while (isRunning) {
        if (seconds.value &lt; 0) { isRunning = false } // 时间到时停止倒计时

        val elapsedTime = System.currentTimeMillis() - startTime // 已用时间（单位是毫秒）
        percentage = (elapsedTime / 1000f) / startValue // 将经过的时间归一化为[0,1]

        // 将百分比限制在 [0, 1] 之间以避免过冲
        percentage = percentage.coerceIn(0f, 1f)

        // 计算剩余秒数
        seconds.value = ((startValue - (elapsedTime / 1000f))).toInt()

        delay(10) // 延迟以控制更新频率
    }
}
</code></pre>

<p>Compose 部分就到此为止；让我们继续编写着色器吧！</p>

<p>首先，让我们定义来自 UI 的变量，以及着色器的最低设置。现在，我们将返回像素与归一化坐标中心的距离，作为颜色：<code>length(uv)</code>。如果这部分内容不太清楚，强烈建议你查看我的<a href="https://juejin.cn/post/7535292253813981247">教程</a>，了解如何在 Android 中使用着色器。</p>

<pre><code class="kotlin">private val circularTimerShader = """
    uniform float time;
    uniform float percentage;
    uniform vec2 resolution;
    uniform shader image;

    vec4 main(float2 fragCoord) {
        float2 uv = fragCoord / resolution - 0.5; // 归一化坐标
        uv.x *= resolution.x / resolution.y;
        return vec4(length(uv));
    }
""".trimIndent()
</code></pre>

<p>因此，目前我们得到的大致如下：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1000/1*e2GHAO-1N7K0KBjN4wAYww.png" alt="" /></p>

<p>现在，让我们尝试在标准笛卡尔平面上绘制一个“栅栏”，即一系列垂直的条形。如何实现这个效果？首先，我们将 y 轴上的所有值限制在零以下。着色器现在如下所示：</p>

<pre><code class="glsl">vec4 main(float2 fragCoord) {
    float2 uv = fragCoord / resolution - 0.5; // 归一化坐标
    uv.x *= resolution.x / resolution.y;

    vec3 color = vec3(1.) * step(uv.y, 0.0);

    return vec4(color, 1.0);
}
</code></pre>

<p>接下来，我们还将沿 x 轴裁剪掉一半的区域。记住，我们的 <code>uv</code> 坐标偏移了 0.5，使零点位于中心。这样，我们也可以沿 x 轴在零点处裁剪，只留下右上象限。</p>

<pre><code class="glsl">float fence = step(0.0, uv.x);
vec3 color = vec3(1.) * step(uv.y, 0.0) * fence;
</code></pre>

<p>现在，如果我们将 x 轴上的坐标乘以 10，并只取小数部分，我们将得到如下所示的 x 轴值：<code>[0...1, 0...1, 0...1, ...]</code>。再将它们平移 0.5，我们就得到了“栅栏”。下面，我演示了构建垂直条的三个步骤。</p>

<pre><code class="glsl">vec4 main(float2 fragCoord) {
    float2 uv = fragCoord / resolution - 0.5; // 归一化坐标
    uv.x *= resolution.x / resolution.y;

    float fence = step(0.0, fract(uv.x * 10.) - 0.5);
    vec3 color = vec3(1.0) * step(uv.y, 0.0) * fence;

    return vec4(color, 1.0);
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*l7X_24sRzAI7iYZLqeWKFQ.png" alt="" /></p>

<p>现在到了最激动人心的部分：如何从笛卡尔坐标系过渡到极坐标系？换句话说，如何创建相同的“栅栏”，但使其看起来像圆形？让我们来弄清楚。</p>

<p>我们习惯用两个值来描述函数：<code>x</code> 和 <code>y</code>。这使我们能够确定像素在平面上的精确位置并为其分配颜色。在我们的例子中，坐标系是 <code>uv</code>。为了垂直裁剪，我们使用 <code>y</code>；为了水平裁剪“栅栏”的各个部分，我们使用 <code>x</code>。</p>

<p>极坐标系与此非常相似，但我们使用的不是水平轴和垂直轴，而是半径（与原点的距离）和角度。</p>

<p>换句话说，由于这两个坐标系都包含两个分量，理解它们的含义使我们能够相对轻松地将笛卡尔坐标系中使用的公式和技术应用于极坐标系。然而，最终的图像看起来会“弯曲”成一个圆形。让我们尝试将“栅栏”转换为极坐标：</p>

<pre><code class="glsl">vec2 cartesianToPolar(vec2 uv) {
    float r = length(uv);
    float theta = atan(uv.y, uv.x);
    return vec2(r, theta);
}vec4 main(float2 fragCoord) {
    float2 uv = fragCoord / resolution - 0.5; // 归一化坐标
    uv.x *= resolution.x / resolution.y;

    // 转换为极坐标
    vec2 polar = cartesianToPolar(uv);

    float r = polar.x; // 半径

    float theta = polar.y; // 角度

    float fence = step( 0.5, fract(theta * 10.0));
    vec3 color = vec3(1.) * step(0.5, r) * fence;

    return vec4(color, 1.0);
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1000/1*UR389J0im6ziWvc_d9ERzA.png" alt="极坐标系中的“栅栏”" /></p>

<p>但是，你可能会注意到，光线的宽度随着远离中心而增加。我们可以添加补偿来消除这种影响。</p>

<pre><code class="glsl">// 宽度已调整的进度条
float width = 0.02; // Bar width
float adjustedWidth = width / max(r, 0.001); // 补偿径向缩放
float fence = step( 0.5 - adjustedWidth, fract(theta * 10.0));
</code></pre>

<p>接下来，我们不仅需要限制内半径，还需要限制外半径，以创建一个环，而不是无限延伸的光线。</p>

<pre><code class="glsl">// 将波浪蒙版均匀地涂抹在进度条上
float barRadius = 0.3;
float barMask = smoothstep(barRadius+0.01, barRadius, r);
</code></pre>

<p>总的来说，此时它看起来应该像这样：</p>

<pre><code class="glsl">vec4 main(float2 fragCoord) {
    float2 uv = fragCoord / resolution - 0.5; // 归一化坐标
    uv.x *= resolution.x / resolution.y;

    float width = 0.02; // 进度条宽度

    // 转化为极坐标
    vec2 polar = cartesianToPolar(uv);
    float r = polar.x;

    // 半径
    float theta = polar.y;

    // 角度
    float innerMask = step(0.3, r);

    // 宽度已调整的进度条
    float adjustedWidth = width / max(r, 0.001); // 补偿径向缩放
    float fence = step( 0.5 - adjustedWidth, fract(theta * 10.0));

    // 将波浪蒙版均匀地涂抹在进度条上
    float barRadius = 0.3;
    float barMask = smoothstep(barRadius+0.01, barRadius, r);

    // 结合进度条和内层蒙版
    float combinedMask = barMask * fence * innerMask;

    vec3 col = vec3(1.0) * combinedMask;

    return vec4(col, 1.0);
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1288/1*B_VJQme_vnEdXq0pEmfLZg.png" alt="" /></p>

<p>最后一步是根据 <code>percentage</code> 的值增加列的大小。这里需要注意的是，角度 <code>theta</code> 的当前范围是从 <code>-Pi</code> 到 <code>Pi</code>，因此需要对其进行归一化，即将其转换为从 <code>0</code> 到 <code>1</code> 的范围。这样可以更容易地将其与 <code>percentage</code> 的值对齐，因为 <code>percentage</code> 的值也是从 <code>0</code> 到 <code>1</code> 变化的。</p>

<pre><code class="glsl">// 还将其移动，使零位于顶部而不是左侧
float normalizedAngle = mod((theta + 1.57079632679) / 6.28318530718, 1.0); 
</code></pre>

<p>现在我们可以为“wave”应用另一个蒙版，它将取决于 <code>percentage</code> 变量的当前值。</p>

<pre><code class="glsl">// 计算条形中心的波浪蒙版
float wave = smoothstep(fixPercentage, fixPercentage - 0.1, centerNormalizedAngle);
float waveMask = smoothstep(0.32 + 0.1 * wave, 0.31 + 0.1 * wave, r);
</code></pre>

<p>我们还需要将这个波浪的值添加到 <code>barRadius</code> 中，并在最后将整体遮罩乘以 <code>waveMask</code>。此外，我将最终 Alpha 值的常量值替换为组合遮罩的值。这样，我们现在得到了一个几乎完整的效果。</p>

<pre><code class="glsl">// 其余代码 ...

float barRadius = 0.3 + 0.1 * wave; // 使用波形蒙版设置条形半径

// ...

float combinedMask = barMask * fence * innerMask * waveMask;
vec3 col = vec3(1.0) * combinedMask;

return vec4(col, combinedMask);
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1000/1*ZduMs_yVlmd5r7CxADMpRQ.gif" alt="" /></p>

<p>我想在本节中添加的最后一点是稍微优化一下蒙版。你可能已经注意到，每个列的左右边缘半径不同，但我希望它们的高度一致。这样可以使效果看起来更简洁一些。以下是实现方法：</p>

<pre><code class="glsl">// 在每个条形的中心采样波形蒙版
float barIndex = floor(theta * 10.0); // 确定条的索引
float centerTheta = (barIndex + 0.5) / 10.0; // 条的中心角
float centerNormalizedAngle = mod((centerTheta + 1.57079632679) / 6.28318530718, 1.0);

// 计算条形中心的波浪蒙版
float wave = smoothstep(fixPercentage, fixPercentage - 0.1, centerNormalizedAngle);
float waveMask = smoothstep(0.32 + 0.1 * wave, 0.31 + 0.1 * wave, r);
</code></pre>

<p>总的来说，核心效果现在已经完成。然而，在着色器中，通常情况下，99% 复杂而有趣的工作构成了效果的基础，但单独来看，效果可能看起来简单平淡。正是这最后的 1% 的润色，才能彻底改变一切！</p>

<p>让我们为着色器添加一个渐变。我使用了最简单的一个，它在 <a href="http://shadertoy.com/">ShaderToy</a> （链接：<a href="http://shadertoy.com/%EF%BC%89%E4%B8%AD%E5%90%AF%E5%8A%A8%E6%96%B0%E9%A1%B9%E7%9B%AE%E6%97%B6%E9%BB%98%E8%AE%A4%E5%88%9B%E5%BB%BA%EF%BC%88%E4%BD%A0%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%E5%B9%B6%E7%82%B9%E5%87%BB%E5%8F%B3%E4%B8%8A%E8%A7%92%E7%9A%84%E2%80%9C%E6%96%B0%E5%BB%BA%E2%80%9D%E6%8C%89%E9%92%AE%E6%9F%A5%E7%9C%8B%EF%BC%89%E3%80%82%E6%88%91%E6%8A%8A%E5%AE%83%E7%A7%BB%E5%88%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E5%8D%95%E7%8B%AC%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%AD%EF%BC%8C%E5%B9%B6%E5%B0%86%E5%85%B6%E5%91%BD%E5%90%8D%E4%B8%BA">http://shadertoy.com/%EF%BC%89%E4%B8%AD%E5%90%AF%E5%8A%A8%E6%96%B0%E9%A1%B9%E7%9B%AE%E6%97%B6%E9%BB%98%E8%AE%A4%E5%88%9B%E5%BB%BA%EF%BC%88%E4%BD%A0%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E7%BD%91%E7%AB%99%E5%B9%B6%E7%82%B9%E5%87%BB%E5%8F%B3%E4%B8%8A%E8%A7%92%E7%9A%84%E2%80%9C%E6%96%B0%E5%BB%BA%E2%80%9D%E6%8C%89%E9%92%AE%E6%9F%A5%E7%9C%8B%EF%BC%89%E3%80%82%E6%88%91%E6%8A%8A%E5%AE%83%E7%A7%BB%E5%88%B0%E4%BA%86%E4%B8%80%E4%B8%AA%E5%8D%95%E7%8B%AC%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%AD%EF%BC%8C%E5%B9%B6%E5%B0%86%E5%85%B6%E5%91%BD%E5%90%8D%E4%B8%BA</a> <code>gradient</code>：</p>

<pre><code class="glsl"> vec3 gradient(vec2 uv, float t) {
        return 0.5 + 0.5 * cos(t + uv.xyx + vec3(0, 2, 4));
 }
</code></pre>

<p>现在，我不再将最终颜色乘以 <code>vec3(1.)</code>（即白色），而是将其乘以我们刚刚创建的渐变。此外，我还对其余区域应用了相同的渐变，但 Alpha 值非常低，这为整个屏幕增添了微妙的辉光。</p>

<blockquote><p>请注意，要看到这个效果，我们还必须从 Compose 代码中传递 <code>time</code>。</p></blockquote>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*DXGRdfXQ67eQG7UMnMy8lw.png" alt="" /></p>

<p>现在，让我们转到项目的可组合部分，并在文本变化时添加动画和模糊效果。我不会详细介绍这一点，因为这超出了本课的范围。但是，如果本教程完全不包含代码，感觉不太对劲。所以，以下是可组合部分（包含时间更新和文本动画）的最终版本：</p>

<pre><code class="kotlin">@Composable
fun TimerShaderScreen(paddingValues: PaddingValues) {
    var startValue by remember { mutableStateOf(20) }
    var percentage by remember { mutableFloatStateOf(0.0f) }
    var isRunning by remember { mutableStateOf(false) }

    val shader = remember { RuntimeShader(circularTimerShader) }

    var time by remember { mutableStateOf(0f) }

    LaunchedEffect(null) {
        while (true) {
            time += 0.01f
            delay(10)
        }
    }

    val seconds = remember { mutableStateOf(startValue) }

    LaunchedEffect(isRunning) {
        val startTime = System.currentTimeMillis()
        while (isRunning) {
            if (seconds.value &lt; 0) { isRunning = false } // 时间到时停止倒计时

            val elapsedTime = System.currentTimeMillis() - startTime // 已用时间（单位是毫秒）
            percentage = (elapsedTime / 1000f) / startValue // 将经过的时间归一化为[0,1]

            // 将百分比限制在 [0, 1] 之间以避免过冲
            percentage = percentage.coerceIn(0f, 1f)

            // 计算剩余秒数
            seconds.value = ((startValue - (elapsedTime / 1000f))).toInt()

            delay(10) // 延迟以控制更新频率
        }
    }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(paddingValues),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        OutlinedTextField(
            value = if (startValue != 0) startValue.toString() else "",
            onValueChange = {
                startValue = it.toIntOrNull() ?: 0
            },
            label = { Text("Start value") },
            modifier = Modifier.width(200.dp)
        )
        Box(
            modifier = Modifier.size(250.dp),
            contentAlignment = Alignment.Center
        ) {
            Box(
                modifier = Modifier
                    .size(250.dp)
                    .onSizeChanged {
                        shader.setFloatUniform("resolution", it.width.toFloat(), it.height.toFloat())
                    }
                    .graphicsLayer {
                        shader.setFloatUniform("percentage", percentage)
                        shader.setFloatUniform("time", time)
                        renderEffect = RenderEffect.createRuntimeShaderEffect(shader, "image").asComposeRenderEffect()
                    }
                    .background(color = Color.Black),
            )
            var previousSeconds by remember { mutableStateOf(seconds.value.coerceAtLeast(0)) }

            AnimatedContent(
                targetState = seconds.value.coerceAtLeast(0),
                transitionSpec = {
                    (slideInVertically(animationSpec = tween(500)) { height -&gt; -height } + fadeIn(
                        animationSpec = tween(
                            500
                        )
                    ))
                        .togetherWith(slideOutVertically(animationSpec = tween(500)) { height -&gt; height } + fadeOut(
                            tween(500)
                        ))
                },
                label = "CountdownAnimation"
            ) { targetSeconds -&gt;
                // 检测是否正在转换
                val isTransitioning = targetSeconds != previousSeconds

                // 过渡期间模糊动画
                val blurRadius by animateFloatAsState(
                    targetValue = if (isTransitioning) 30f else 0f, // 过渡时模糊
                    animationSpec = tween(durationMillis = 500) // 匹配过渡持续时间
                )

                // 转换完成后更新 previousSeconds
                LaunchedEffect(targetSeconds) {
                    previousSeconds = targetSeconds
                }

                Text(
                    modifier = Modifier
                        .fillMaxWidth()
                        .graphicsLayer {
                            // 应用动画模糊效果
                            renderEffect = RenderEffect.createBlurEffect(
                                blurRadius, blurRadius, android.graphics.Shader.TileMode.CLAMP
                            ).asComposeRenderEffect()
                        },
                    textAlign = androidx.compose.ui.text.style.TextAlign.Center,
                    text = targetSeconds.toString(),
                    fontSize = 50.sp,
                    fontWeight = androidx.compose.ui.text.font.FontWeight.Thin,
                    color = Color.White
                )
            }
        }

        OutlinedButton(
            onClick = { isRunning = !isRunning },
            modifier = Modifier.padding(top = 16.dp)
        ) {
            Text(if (isRunning) "Stop" else "Start")
        }
    }
}
</code></pre>

<p>以及最终的着色器代码：</p>

<pre><code class="glsl">uniform float time;
uniform float percentage;
uniform vec2 resolution;
uniform shader image;vec2 cartesianToPolar(vec2 uv) {
    float r = length(uv);
    float theta = atan(uv.y, uv.x);
    return vec2(r, theta);
}vec3 gradient(vec2 uv, float t) {
    return 0.5 + 0.5 * cos(t + uv.xyx + vec3(0, 2, 4));
}vec4 main(float2 fragCoord) {
    float2 uv = fragCoord / resolution - 0.5; // 归一化坐标
    uv.x *= resolution.x / resolution.y;

    float width = 0.02; // 条形宽度

    // 转换为极坐标
    vec2 polar = cartesianToPolar(uv);
    float r = polar.x; // 半径

    float theta = polar.y;    // 角度

    float innerMask = step(0.3, r);

    // 将顶部设为零，使角度标准化
    float normalizedAngle = mod((theta + 1.57079632679) / 6.28318530718, 1.0);

    // 固定百分比补偿
    float fixPercentage = percentage + percentage * 0.1;

    // 在每个条形的中心采样波形蒙板
    float barIndex = floor(theta * 10.0); // 确定条的索引
    float centerTheta = (barIndex + 0.5) / 10.0; // 条的中心角
    float centerNormalizedAngle = mod((centerTheta + 1.57079632679) / 6.28318530718, 1.0);

    // 计算条形中心的波浪蒙板
    float wave = smoothstep(fixPercentage, fixPercentage - 0.1, centerNormalizedAngle);
    float waveMask = smoothstep(0.32 + 0.1 * wave, 0.31 + 0.1 * wave, r);

    // 宽度已调整的条形图案
    float adjustedWidth = width / max(r, 0.001); // 补偿径向缩放
    float fence = step( 0.5 - adjustedWidth, fract(theta * 10.0));

    // 将波浪蒙版均匀地涂抹在吧台上
    float barRadius = 0.3 + 0.1 * wave; // 使用波形蒙版设置条形半径
    float barMask = smoothstep(barRadius+0.01, barRadius, r);

    // 结合条形和内层蒙版
    float combinedMask = barMask * fence * innerMask * waveMask;

    vec3 grad = gradient(uv, time);
    vec3 col = grad * combinedMask;

    return vec4(col + grad * 0.1, combinedMask + length(uv));
}
</code></pre>

<p>感谢阅读！如果你觉得我的实验有趣且讲解有帮助，欢迎加入我的<a href="https://t.me/droidshaderworks">Telegram频道</a>或在<a href="https://x.com/KrowaNaMostku">Twitter (X)</a>上关注我。你的支持意义重大，并激励着我。祝你撸码愉快！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用Compose中的Shader实现一个雪花飘飘弹窗效果]]></title>
    <link href="https://alexhilton.github.io/blog/2025/08/17/snow-dialog-shader/"/>
    <updated>2025-08-17T22:02:24+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/08/17/snow-dialog-shader</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Snow Dialog Shader Tutorial」，原文链接<a href="https://medium.com/@off.mind.by/snow-dialog-shader-tutorial-dde1b4a61e20">https://medium.com/@off.mind.by/snow-dialog-shader-tutorial-dde1b4a61e20</a>，由Alex Volkov发布于2024年12月27日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:2000/1*oNN6ZtalbQEvYCpTx8gLWg.png" title="auto auto" ></a></p>

<!-- more -->


<p>大家好！在本教程中，我将向大家展示如何创建雪花覆盖的对话框效果。总的来说，该效果可以分为三个部分。</p>

<ol>
<li><strong>设置 Compose 代码</strong>：这确保了基础效果的实现。</li>
<li><strong>创建对话框底部积雪的着色器</strong>：这是我在今天教程中重点讲解的核心效果。</li>
<li><strong>添加飘落的雪花</strong>：为此，我在 ShaderToy 上找到了一个现成的着色器，并对其进行了一些优化，使其不会对手机性能造成太大负担。第三部分将包含原始着色器的链接以及一些优化说明。</li>
</ol>


<p>本教程主要讲解如何为对话框创建不断增长的雪盖效果。</p>

<p>最终效果如下：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:804/1*SRa57BglcDzpLzAAw1UAPw.gif" alt="最终效果" /></p>

<blockquote><p>在深入探讨之前，我想提醒你，我并没有为所有效果创建教程。不过，所有效果都可以在我的 <a href="https://github.com/AleksiejVolkov/runtimeshaders">GitHub</a> （链接：<a href="https://github.com/AleksiejVolkov/runtimeshaders%EF%BC%89%E4%B8%8A%E6%89%BE%E5%88%B0%E3%80%82%E4%BD%A0%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%88%91%E7%9A%84">https://github.com/AleksiejVolkov/runtimeshaders%EF%BC%89%E4%B8%8A%E6%89%BE%E5%88%B0%E3%80%82%E4%BD%A0%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%88%91%E7%9A%84</a> <a href="https://t.me/droidshaderworks">Telegram 频道</a> （链接：<a href="https://t.me/droidshaderworks%EF%BC%89%E4%B8%AD%E6%89%BE%E5%88%B0%E8%A7%86%E9%A2%91%E3%80%81%E6%96%B0%E6%95%88%E6%9E%9C%E5%85%AC%E5%91%8A%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E7%AD%94%E3%80%82%E6%9C%9F%E5%BE%85%E5%9C%A8%E9%82%A3%E9%87%8C%E8%A7%81%E5%88%B0%E4%BD%A0%EF%BC%81">https://t.me/droidshaderworks%EF%BC%89%E4%B8%AD%E6%89%BE%E5%88%B0%E8%A7%86%E9%A2%91%E3%80%81%E6%96%B0%E6%95%88%E6%9E%9C%E5%85%AC%E5%91%8A%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E7%AD%94%E3%80%82%E6%9C%9F%E5%BE%85%E5%9C%A8%E9%82%A3%E9%87%8C%E8%A7%81%E5%88%B0%E4%BD%A0%EF%BC%81</a></p></blockquote>

<p>让我们从 Compose 中为效果设置一个最小页面开始。它包含一张背景图片和一个位于中心的按钮，用于触发对话框。</p>

<p>需要注意的是，对话框不应来自 Material 库，而应使用 Compose 中最基本的“AlertDialog”。</p>

<p>以下是最低配置：</p>

<pre><code class="Kotlin">@Composable
fun SnowDialogScreen() {
    var showDialog by remember { mutableStateOf(false) }  

    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Image(
            painter = painterResource(id = R.drawable.christmas_night),
            contentDescription = "Sample Image",
            contentScale = ContentScale.Crop,
            modifier = Modifier.fillMaxSize()
        )        if (!showDialog) {
            Button(onClick = { showDialog = true }) {
                Text("Ho-ho-ho!")
            }
        } else {
            SnowedDialog { showDialog = false }
        }
    }
}

@Composable
private fun SnowedDialog(onDismiss: () -&gt; Unit) {
    BasicAlertDialog(
        onDismissRequest = { onDismiss() },
        properties = DialogProperties(usePlatformDefaultWidth = false)
    ) {
        Column(
            Modifier
                .padding(horizontal = 16.dp)
                .background(shape = MaterialTheme.shapes.large, 
                            color = MaterialTheme.colorScheme.surface)
                .padding(16.dp),
        ) {
            Text("Merry Christmas!", style = MaterialTheme.typography.titleLarge)
            Spacer(modifier = Modifier.height(10.dp))
            Text("Happy New Year!")
            Spacer(modifier = Modifier.height(26.dp))
            Row(
                modifier = Modifier
                    .fillMaxWidth(),
                horizontalArrangement = Arrangement.End
            ) {
                Text(
                    modifier = Modifier
                        .clickable { onDismiss() }
                        .padding(5.dp),
                    text = "Close",
                    style = MaterialTheme.typography.bodyMedium.copy(color = MaterialTheme.colorScheme.primary)
                )
            }
        }
    }
}
</code></pre>

<p>最终，你应该得到类似这样的效果：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*fnlF56ZxRxMwa7vHkCOudA.png" alt="颜色可能会有所不同，此外观已针对暗黑模式进行了调整" /></p>

<p>现在我们可以开始编写着色器了！我将简要介绍如何设置着色器并将其附加到对话框中。有关运行时着色器的更详细介绍和初学者指南，你可以查看我的另一个<a href="https://juejin.cn/post/7535292253813981247">教程</a>。</p>

<p>开始使用着色器所需的最低要求如下所示。在对话框中，我们添加一个 <code>runtimeShader</code>，并使用 <code>graphicsLayer</code> 将其分配给 <code>Column</code>：</p>

<pre><code class="kotlin">@Composable
private fun SnowedDialog(onDismiss: () -&gt; Unit) {
    // 从字符串编译我们的着色器
    val snowCapShader = remember { RuntimeShader(snowCapShader) }  

    BasicAlertDialog(
        onDismissRequest = { onDismiss() },
        properties = DialogProperties(usePlatformDefaultWidth = false)
    ) {
        Column(
            Modifier
                .padding(horizontal = 16.dp)
                .background(shape = MaterialTheme.shapes.large, color = MaterialTheme.colorScheme.surface)
                .onSizeChanged { size -&gt;
                    // pass resolution
                    snowCapShader.setFloatUniform(
                        "resolution",
                        size.width.toFloat(),
                        size.height.toFloat()
                    )
                }
                .graphicsLayer {
                    // apply shader 
                    this.renderEffect = RenderEffect
                        .createRuntimeShaderEffect(snowCapShader, "image")
                        .asComposeRenderEffect()
                }
                .padding(16.dp),
        ) {
          // 其余代码保持不变

//...

@Language("agsl")
private val snowCapShader = """
    uniform shader image;
    uniform vec2 resolution;    
    vec4 main(float2 fragCoord) {
         float2 uv = fragCoord / resolution - 0.5;
         if(abs(uv.x)&gt;0.5 || abs(uv.y)&gt;0.5) {
             return vec4(0.0);
         }          
         float ratio = resolution.x / resolution.y;    
         uv.x *= ratio;        
         vec4 imageColor = image.eval(fragCoord);        
         return vec4(vec3(1.0), imageColor.a);
    }
""".trimIndent()
</code></pre>

<p>目前，它将显示为一个空白矩形，就像我们的对话框一样：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*C5O1IMHS7MvK0lFnIqHFYA.png" alt="" /></p>

<p>在继续之前，让我先尽可能简单地解释一下实现此效果背后的逻辑。我将算法分为四个概念步骤：</p>

<ol>
<li><strong>找到一个函数</strong>来定义雪边缘的轮廓。</li>
<li><strong>在 y 轴上</strong>绘制此函数上方的所有内容**，并将其垂直移向底部边缘。</li>
<li><strong>定义一个遮罩区域</strong>，这意味着在此区域之外，函数将被完全忽略，我们只需绘制着色器从系统接收的内容即可。</li>
<li><strong>修改侧面和顶部的遮罩</strong>，使雪的形状更自然，而底部边缘的轮廓则由我们的函数处理。</li>
</ol>


<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*Vbq5YEL42g1tQsLjWKAokQ.png" alt="" /></p>

<p>现在，让我们在着色器中按顺序实现这些步骤。为简单起见，我选择了一个基本的正弦波作为雪边缘的函数。我添加了一些系数来压缩它并降低其振幅：</p>

<pre><code class="glsl">float snowEdge = (sin(10.*uv.x)*0.5+0.5)*0.2;
</code></pre>

<p>接下来，我们需要用白色填充此线上方的所有内容，同时忽略其下方的所有内容。</p>

<pre><code class="glsl">vec4 snow = step(uv.y, snowEdge)*vec4(1.0);
</code></pre>

<blockquote><p>通过向 <code>uv.y</code> 添加一个常量，我们可以垂直移动整个函数。</p></blockquote>

<p>最后，我们需要将该方法移近对话框的底部边缘并添加一个遮罩。现在，我们使用一个简单的矩形区域作为遮罩。我们可以通过分别指定每个边缘来定义它。这种方法可能看起来有点冗长，但它使代码更容易理解：</p>

<pre><code class="glsl"> vec4 main(float2 fragCoord) {
         float2 uv = fragCoord / resolution - 0.5;        
         float ratio = resolution.x / resolution.y;    
         uv.x *= ratio;         

         float snowEdge = (sin(10.*uv.x)*0.5+0.5)*0.2;
         snowEdge = step(uv.y-0.4, snowEdge);       

         float topBound = 0.3;
         float leftBound = -.5*ratio;
         float rightBound = .5*ratio;        

         float snowMask = 0.;       
         if(uv.x &gt; leftBound &amp;&amp; uv.x &lt; rightBound &amp;&amp; uv.y &gt; topBound) {
            snowMask = 1.0;
         }
         snowMask *= snowEdge;        
         vec4 imageColor = image.eval(fragCoord);
         vec3 snowColor = vec3(1.0);       
         vec3 finalColor = mix(imageColor.rgb, snowColor, snowMask);      

         return vec4(finalColor, snowMask+imageColor.a);
    }
</code></pre>

<p>调整后，我们应该得到类似这样的结果。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*GM2d-tsCUOAHnloMiDYAAA.png" alt="" /></p>

<p>现在可能不是提及这一点的最佳时机，也许应该早点提及，但在这里强调这一点至关重要。请记住，我们对坐标进行了归一化，并对其进行了平移，使零点恰好位于画布（即对话框）的中心。具体操作如下：<code>_float2 uv = fragCoord/resolution — 0.5;_</code></p>

<p>理解这一点很重要，因为现在我想减小中心正弦波的振幅，并随着我们向左右两侧远离中心而增大振幅。理解坐标系的设置方式后，我们可以通过将函数乘以沿 x 轴距离中心的距离来实现这一点。这样，函数将在中心处恰好返回零点，并随着向外移动而增大。最终，我们将实现以下效果：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*oW8OP3R2VFo0SkJmDhgVSw.png" alt="" /></p>

<p>现在，让我们使用函数而不是常量来定义遮罩的顶部边界。现在，让我们使用另一个正弦波，但间隔等于对话框的宽度。</p>

<pre><code class="glsl">float topBound = (sin(ratio*uv.x*0.8+2.)*0.5+0.5)*.2+0.3;
</code></pre>

<p>我们将为左右边界添加类似的代码：我希望它们也使用正弦波，但这次是垂直运行的。</p>

<pre><code class="glsl">float leftBound = -.5*ratio+(sin(10.*uv.y)*0.5+0.5)*0.5*length(uv.y-topBound);
float rightBound = .5*ratio-(sin(10.*uv.y)*0.5+0.5)*0.4*length(uv.y-topBound);
</code></pre>

<p>最后，我们需要为底部边缘添加一个常量：这是一个时间变量，我们会将它从 Compose 传递给着色器。在着色器中，我们只需添加相应的 <code>uniform</code> 变量，并将底部边缘函数乘以它即可：</p>

<pre><code class="glsl">uniform shader image;
    uniform vec2 resolution;
    uniform float time;        vec4 main(float2 fragCoord) {
         float2 uv = fragCoord / resolution - 0.5;        

         float ratio = resolution.x / resolution.y;    
         uv.x *= ratio;         

         float adjustedTime = clamp(time * 0.3,0.0,1.0);
         float snowEdge = (sin(10.*uv.x)*0.5+0.5)*0.2 * length(uv.x)*adjustedTime;
         snowEdge = step(uv.y-0.5, snowEdge);       

         float topBound = (sin(ratio*uv.x*0.8+2.)*0.5+0.5)*.2+0.3;
         float leftBound = -.5*ratio+(sin(10.*uv.y)*0.5+0.5)*0.5*length(uv.y-topBound);
         float rightBound = .5*ratio-(sin(10.*uv.y)*0.5+0.5)*0.4*length(uv.y-topBound);                   

         float snowMask = 0.;         
         if(uv.x &gt; leftBound &amp;&amp; uv.x &lt; rightBound &amp;&amp; uv.y &gt; topBound) {
            snowMask = 1.0;
         }

         snowMask *= snowEdge;         

         vec4 imageColor = image.eval(fragCoord);
         vec3 snowColor = vec3(1.0);        
         vec3 finalColor = mix(imageColor.rgb, snowColor, snowMask);       

         return vec4(finalColor, snowMask+imageColor.a);
    }
</code></pre>

<p>别忘了从composable中提供时间：</p>

<pre><code class="Kotlin">@Composable
private fun SnowedDialog(onDismiss: () -&gt; Unit) {
    val snowCapShader = remember { RuntimeShader(snowCapShader) }
    var time by remember { mutableStateOf(0f) }

    LaunchedEffect(null)  {
        while (true) {
            delay(10)
            time += 0.01f
        }
    }

    BasicAlertDialog(
        onDismissRequest = { onDismiss() },
        properties = DialogProperties(usePlatformDefaultWidth = false)
    ) {
        Column(
            Modifier
                .padding(horizontal = 16.dp)
                .background(shape = MaterialTheme.shapes.large, color = MaterialTheme.colorScheme.surface)
                .onSizeChanged { size -&gt;
                    snowCapShader.setFloatUniform(
                        "resolution",
                        size.width.toFloat(),
                        size.height.toFloat()
                    )
                }
                .graphicsLayer {
                    // 这里提供时间：
                    snowCapShader.setFloatUniform("time", time)
                    this.renderEffect = RenderEffect
                        .createRuntimeShaderEffect(snowCapShader, "image")
                        .asComposeRenderEffect()
                }
                .padding(16.dp),
        ) {
// 其余代码保持不变
</code></pre>

<p>我们得到如下效果：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*5YYiM3lZYp42O8Fa9iS-4A.gif" alt="" /></p>

<p>关于这个效果，我想分享的差不多就是这些了！这是核心思想，从这里开始，你可以尝试不同的设置。例如，我用一个基于 Perlin 噪声的更混乱的版本替换了基本的正弦波。</p>

<p>但这些只是细节，在实现上可以有无限的变化。创建着色器的关键在于掌握其背后的核心思想。</p>

<p>你可以在我的代码库中找到我的实现，其中还包含各种用于不同增强功能的辅助方法。例如，这里有一系列过渡效果（线性、三次、指数等）。</p>

<p>添加雪花是最后一步，但创建雪、雨、星星等效果的方法值得另开一个教程。下次我一定会讲解。今天，我只想提一下，为了实现这个特定的效果，我使用了 <strong>Andrew Baldwin</strong> 于 2013 年在 ShaderToy 上创建的着色器。链接如下：<a href="https://www.shadertoy.com/view/ldsGDn">https://www.shadertoy.com/view/ldsGDn</a></p>

<p>由于原始着色器对于手机来说过于庞大，我做了一些简化。此外，它还需要一些适配 AGSL 的功能。这是我的版本：</p>

<pre><code class="glsl">  uniform shader image;
   uniform vec2 resolution;
   uniform float time;

   uniform int uLayers;
   uniform float uDepth;
   uniform float uSpeed;

   const int MAX_LAYERS = 50;
   const float WIDTH = 0.4;

   vec2 NormalizeCoordinates(vec2 o, vec2 r) {
        float2 uv = o / r - 0.5;
        if (r.x &gt; r.y) {
            uv.x *= r.x / r.y;
        } else {
            uv.y *= r.y / r.x;
        } 
        return uv;
    }

    vec4 GetImageTexture(vec2 p, vec2 pivot, vec2 r) {
        if (r.x &gt; r.y) {
            p.x /= r.x / r.y;
        } else {
            p.y /= r.y / r.x;
        }
        p += pivot;
        p *= r;
        return image.eval(p);
    }

    vec4 main(float2 fragCoord) {
       float2 uv = NormalizeCoordinates(fragCoord, resolution);  
       vec4 image = GetImageTexture(uv, vec2(0.5, 0.5), resolution);
       const mat3 p = mat3(13.323122, 23.5112, 21.71123, 21.1212, 28.7312, 11.9312, 21.8112, 14.7212, 61.3934);

       float ratio = resolution.y / resolution.x;
       vec3 acc = vec3(0.0);
       float alpha = 0.0; // 初始化 alpha
       float dof = 5.0 * sin(time * 0.1);
       for (int i = 0; i &lt; MAX_LAYERS; i++) {
           if (i &gt;= uLayers) break; // 如果 i 超出 uLayers，则跳出循环

           float fi = float(i);
           vec2 q = uv * (1.0 + fi * uDepth);

           // 通过调制和时间调整雪花位置
           q -= vec2(q.y * (WIDTH * mod(fi * 7.238917, 1.0) - WIDTH * 0.5), uSpeed * time / (1.0 + fi * uDepth * 0.03));                      vec3 n = vec3(floor(q), 31.189 + fi);
           vec3 m = floor(n) * 0.00001 + fract(n);
           vec3 mp = (31415.9 + m) / fract(p * m);
           vec3 r = fract(mp);

           // 使用圆形mask的圆形雪花形状
           float2 center = mod(q, 1.0) - 0.5 + 0.5 * r.xy;
           float distanceToCenter = length(center); // 圆周距离
           float flakeRadius = 0.015 + 0.01 * r.z; // 每个薄片的半径略有不同

           // 通过扩展的平滑步进实现更平滑的边缘
           float intensity = smoothstep(flakeRadius + 0.015, flakeRadius, distanceToCenter) * 
                               smoothstep(flakeRadius, flakeRadius - 0.015, distanceToCenter);

           // Ensure flakes are white or transparent (prevent black color)
           vec3 flakeColor = vec3(1.0); // 雪花要是白色
           acc += flakeColor * intensity;

           // 通过平滑过渡积累 alpha
           alpha += intensity;
       }

       // 归一化 alpha 以确保其不超过 1.0
       alpha = clamp(alpha, 0.0, 1.0);
       vec3 finalColor = mix(image.rgb, acc, alpha);

      if(uv.y &lt; -0.5*ratio || uv.y &gt; .5*ratio) {
           finalColor = vec3(0.0);
           alpha = 0.0;
       }
       return vec4(finalColor, alpha+image.a);
   }
</code></pre>

<p>当然，为了让一些雪花出现在屏幕前方，而另一些雪花飘到屏幕后方，我必须在这个着色器中使用两层。这是对话框可组合函数的最终效果：</p>

<pre><code class="Kotlin">@Composable
private fun SnowedDialog(onDismiss: () -&gt; Unit) {
    val snowCapShader = remember { RuntimeShader(snowCapShader) }
    val flakesShaderForeground = remember { RuntimeShader(snowShader) }
    val flakesShaderBackground = remember { RuntimeShader(snowShader) }

    var time by remember { mutableStateOf(0f) }

    LaunchedEffect(null)  {
        while (true) {
            delay(10)
            time += 0.01f
        }
    }

    flakesShaderForeground.setIntUniform("uLayers", 5)
    flakesShaderForeground.setFloatUniform("uDepth", 0.15f)
    flakesShaderForeground.setFloatUniform("uSpeed", 1.0f)

    flakesShaderBackground.setIntUniform("uLayers", 10)
    flakesShaderBackground.setFloatUniform("uDepth", 1.5f)
    flakesShaderBackground.setFloatUniform("uSpeed", 0.8f)

    BasicAlertDialog(
        onDismissRequest = { onDismiss() },
        properties = DialogProperties(usePlatformDefaultWidth = false)
    ) {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .onSizeChanged { size -&gt;
                    flakesShaderForeground.setFloatUniform(
                        "resolution",
                        size.width.toFloat(),
                        size.height.toFloat()
                    )
                }
                .graphicsLayer {
                    flakesShaderForeground.setFloatUniform("time", time)
                    this.renderEffect = RenderEffect
                        .createRuntimeShaderEffect(flakesShaderForeground, "image")
                        .asComposeRenderEffect()
                }
                .padding(16.dp),
            contentAlignment = Alignment.Center
        ) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .onSizeChanged { size -&gt;
                        flakesShaderBackground.setFloatUniform(
                            "resolution",
                            size.width.toFloat(),
                            size.height.toFloat()
                        )
                    }
                    .graphicsLayer {
                        flakesShaderBackground.setFloatUniform("time", time)
                        this.renderEffect = RenderEffect
                            .createRuntimeShaderEffect(flakesShaderBackground, "image")
                            .asComposeRenderEffect()
                    }
            ) {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .background(color = Color.Black.copy(0.1f))
                )
            }
            Column(
                Modifier
                    .padding(horizontal = 16.dp)
                    .background(shape = MaterialTheme.shapes.large, color = MaterialTheme.colorScheme.surface)
                    .onSizeChanged { size -&gt;
                        snowCapShader.setFloatUniform(
                            "resolution",
                            size.width.toFloat(),
                            size.height.toFloat()
                        )
                    }
                    .graphicsLayer {
                        snowCapShader.setFloatUniform("time", time)
                        this.renderEffect = RenderEffect
                            .createRuntimeShaderEffect(snowCapShader, "image")
                            .asComposeRenderEffect()
                    }
                    .padding(16.dp),
            ) {
                Text("Merry Christmas!", style = MaterialTheme.typography.titleLarge)
                Spacer(modifier = Modifier.height(10.dp))
                Text("Happy New Year!")
                Spacer(modifier = Modifier.height(26.dp))
                Row(
                    modifier = Modifier
                        .fillMaxWidth(),
                    horizontalArrangement = Arrangement.End
                ) {
                    Text(
                        modifier = Modifier
                            .clickable { onDismiss() }
                            .padding(5.dp),
                        text = "Close",
                        style = MaterialTheme.typography.bodyMedium.copy(color = MaterialTheme.colorScheme.primary)
                    )
                }
            }
        }
    }
}
</code></pre>

<p>最终结果：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1000/1*UG3e4b_9AqY1J1kKCNFqAw.png" alt="" /></p>

<p>感谢你的阅读！如果你觉得我的实验有趣且我的解释对你有帮助，欢迎加入我的<a href="https://t.me/droidshaderworks">Telegram频道</a>或在<a href="https://x.com/KrowaNaMostku">Twitter (X)</a>上关注我。你的支持意义重大，并激励着我。祝你撸码愉快！</p>
]]></content>
  </entry>
  
</feed>
