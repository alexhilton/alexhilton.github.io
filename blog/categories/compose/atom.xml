<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Compose | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/compose/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2025-12-18T12:07:25+00:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Jetpack Compose 2025年12月版本新增功能]]></title>
    <link href="https://alexhilton.github.io/blog/2025/12/18/compose-december-2025/"/>
    <updated>2025-12-18T00:00:00+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/12/18/compose-december-2025</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「What&rsquo;s new in the Jetpack Compose December &lsquo;25 release」，原文链接<a href="https://android-developers.googleblog.com/2025/12/whats-new-in-jetpack-compose-december.html">https://android-developers.googleblog.com/2025/12/whats-new-in-jetpack-compose-december.html</a>，由Nick Butcher发布于2025年12月3日。</p></blockquote>

<p><a href=""><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjaOFQLkqCBaw0FA8C7XCI7gKe-Z79r2dYH9QUOnWyZq_Qevh-EoHqRs6zTENmzLjHwKk_ECQlN_2EePI8-JyjCVH3PL2rOsbRdfKNZ6T" title="auto auto" ></a></p>

<!-- more -->


<p>现在，<a href="https://developer.android.com/jetpack/androidx/releases/compose">Jetpack Compose 2025年12月版本</a> 正式发布。该版本包含 Compose 核心模块 1.10 版和 Material 3 1.4 版（参见完整的 <a href="https://developer.android.com/develop/ui/compose/bom/bom-mapping">BOM 映射</a>），新增了多项功能并显著提升了性能。</p>

<p>要使用最新的版本，请将 Compose BOM 版本升级到 2025.12.00：</p>

<pre><code class="kotlin">implementation(platform("androidx.compose:compose-bom:2025.12.00"))
</code></pre>

<h2>性能改进</h2>

<p>我们知道应用程序的运行时性能对你和你的用户至关重要，因此性能一直是 Compose 团队的首要任务。此版本带来了一系列改进——你只需升级到最新版本即可获得所有这些改进。我们的内部滚动性能基准测试表明，Compose 现在的性能与使用 Views 时的性能相当：</p>

<p><img src="https://blogger.googleusercontent.com/img/a/AVvXsEhmNWZbGEVpwg-kdd6kw9Ay8TyOjGS226GxU1oNQQCI0IBJ1aj_Pze-SQ0z9LGywbdbzIROkIv6hxKKMIXJ0sBs-q5U_cv-yslsXFRzdRihM0MxWI3q2j-LURfcILGe7i9KodgjuGgUkAoeeZspHUa11iDkAiJTs295rxSDtgSWK0VSEofLt2MWburL7II" alt="滚动性能基准测试比较了 Views 和 Jetpack Compose 在不同 Compose 版本下的性能" /></p>

<h3>延迟预取中的可暂停组合</h3>

<p>延迟预取中的可暂停组合预取功能现已默认启用。这是 Compose 运行时调度机制的一项根本性变革，旨在显著减少高 UI 负载下的卡顿现象。</p>

<p>此前，一旦合成开始，就必须运行至完成。如果合成较为复杂，则可能导致主线程阻塞超过一帧，从而造成 UI 卡顿。而现在，借助可暂停合成功能，运行时可以在时间不足时“暂停”其工作，并在下一帧恢复。当与延迟布局预取结合使用，提前准备帧时，此功能尤为有效。 Compose 1.9 中引入的 LazyLayout<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/lazy/package-summary#rememberLazyListState(androidx.compose.foundation.lazy.layout.LazyLayoutCacheWindow,kotlin.Int,kotlin.Int)">CacheWindow</a> API 可以很好地预取更多内容，并利用可暂停的合成功能来显著提升 UI 性能。</p>

<p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhaE5BKUo2mBxNKAmgD8nnrrbooEAbjCSxsGJbJx6DgTmMPx8BmTWsOg2I2_FXcOODSG8OAX31ueJfgipH2zdF1Y3v6CcIXGW3mWiWcHbemqnmVO-IYWKVJ-V6CiD9LDo_35nqyWrDgK3Y_HOdUDfL8StGnfgg34Ia6wda1bXoDT3xhMQb8w2hn_d2gLhQ/s16000/pausable.gif" alt="可暂停合成结合延迟预取有助于减少卡顿" /></p>

<p>我们还优化了其他方面的性能，例如改进了 Modifier.onPlaced。 Modifier.onVisibilityChanged 和其他修饰符实现。我们将继续投入资源来提升 Compose 的性能。</p>

<h2>新功能</h2>

<h3>Retain</h3>

<p>Compose 提供了一系列 API 来跨不同的生命周期保存和管理状态；例如，<code>remember</code> 可以在组合之间持久化状态，而 <code>rememberSavable</code>/<code>rememberSerializable</code> 可以在 Activity 或进程重建之间持久化状态。<code>retain</code> 是一个介于这些 API 之间的新 API，它允许你在配置更改时持久化值而无需序列化，但不会跨进程终止。由于 <code>retain</code> 不会序列化你的状态，因此你可以持久化诸如 lambda 表达式、流程以及位图等难以序列化的大型对象。例如，你可以使用 <code>retain</code> 来管理媒体播放器（例如 ExoPlayer），以确保媒体播放不会因配置更改而中断。</p>

<pre><code class="kotlin">@Composable
fun MediaPlayer() {
    val applicationContext = LocalContext.current.applicationContext
    val exoPlayer = retain { ExoPlayer.Builder(applicationContext).apply { ... }.build() }
    ...
}
</code></pre>

<p>我们要感谢 AndroidDev 社区（特别是 <a href="https://slackhq.github.io/circuit">Circuit</a> 团队），他们对该功能的设计产生了影响并做出了贡献。</p>

<h3>Material 1.4</h3>

<p>Material3 库的 1.4.0 版本新增了一些组件和增强功能：</p>

<ul>
<li><p>TextField 现在提供了一个基于 TextFieldState 的实验性版本，它提供了一种 <a href="https://developer.android.com/develop/ui/compose/text/user-input">更强大的</a> 方法来管理文本状态。此外，还新增了变体SecureTextField 和 OutlinedSecureTextField。Material Text 可组合元素现在支持自动调整大小功能（autoSize）。</p></li>
<li><p>轮播组件现在提供了一个新的 <a href="https://developer.android.com/reference/kotlin/androidx/compose/material3/carousel/package-summary#Horizo%E2%80%8B%E2%80%8BntalCenteredHeroCarousel(androidx.compose.material3.carousel.CarouselState,androidx.compose.ui.Modifier,androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp,androidx.compose.foundation.gestures.TargetedFlingBehavior,kotlin.Boolean,androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp,androidx.compose.foundation.layout.PaddingValues,kotlin.Function2)">Horizo​​ntalCenteredHeroCarousel</a><a href="https://m3.material.io/components/carousel/specs">variant</a>。</p></li>
<li><p><a href="https://developer.android.com/reference/kotlin/androidx/compose/material3/package-summary?_gl=1*1h4dj5y*_up*MQ..*_ga*NDE1MzI0NzAwLjE3NjQ2MTM1MzU.*_ga_6HH9YJMN9M*czE3NjQ2MTM1MzQkbzEkZzAkdDE3NjQ2MTM1MzQkajYwJGwwJGgxODIyOTM4OTMy#TimePicker(androidx.compose.material3.TimePickerState,androidx.compose.ui.Modifier,androidx.compose.material3.TimePickerColors,androidx.compose.material3.TimePickerLayoutType)">TimePicker</a> 现在支持在选择器模式和输入模式之间切换。</p></li>
<li><p>垂直拖拽手柄（<a href="https://developer.android.com/reference/kotlin/androidx/compose/material3/package-summary#VerticalDragHandle(androidx.compose.ui.Modifier,androidx.compose.material3.DragHandleSizes,androidx.compose.material3.DragHandleColors,androidx.compose.material3.DragHandleShapes,androidx.compose.foundation.interaction.MutableInteractionSource)">VerticalDragHandle</a>）帮助用户更改自适应空格的大小或者位置。</p></li>
</ul>


<p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhTrvNyW_IJgSIqBWYlzweN3mkoZ_Uc3IMNj2Pu0cC1VdVqnja4nHA6kSCO2nk44MBi2diWEPu_oe0ozm2Jxh5jjXyJ7uqHdrdkyTrDaCgIifMpHLK9q3stUhD79QuLc7q_V4EisrNR7t4I3SMAxSq57EVzk8PGqiouXPRc-wI9Pu03vbuDU3_rnrA4THc/s16000/centered-hero-carousel.gif" alt="Horizontal centered hero carousel" /></p>

<p>请注意，<a href="https://m3.material.io/blog/building-with-m3-expressive">Material 3 Expressive</a> API 仍在 Material 3 库的 alpha 版本中持续开发。要了解更多信息，请观看<a href="https://www.youtube.com/embed/t9rrsqfB2tM">最近的演讲</a>。</p>

<h2>新的动画功能</h2>

<p>我们持续扩展动画 API，包括对自定义共享元素动画的更新。</p>

<h3>动态共享元素</h3>

<p>默认情况下，<code>sharedElement()</code> 和 <code>sharedBounds()</code> 动画会在目标状态中找到匹配的键时尝试为布局更改添加动画效果。但是，你可能希望根据某些条件（例如导航方向或当前 UI 状态）动态禁用​​此动画。</p>

<p>要控制共享元素过渡是否发生，你现在可以自定义传递给 <code>rememberSharedContentState()</code> 的 <code>SharedContentConfig</code>。<code>isEnabled</code> 属性决定共享元素是否处于活动状态。</p>

<pre><code class="kotlin">SharedTransitionLayout {
    val transition = updateTransition(currentState)
    transition.AnimatedContent { targetState -&gt;
        // Create the configuration that depends on state changing.
        fun animationConfig() : SharedTransitionScope.SharedContentConfig {
            return object : SharedTransitionScope.SharedContentConfig {
                override val SharedTransitionScope.SharedContentState.isEnabled: Boolean
                        get() =
                            // determine whether to perform a shared element transition
                }
            }
}
</code></pre>

<p>更多信息，请参阅<a href="https://developer.android.com/develop/ui/compose/animation/shared-elements/customize#dynamic-enable-disable">文档</a>。</p>

<h3>Modifier.skipToLookaheadPosition()</h3>

<p>此版本新增了一个修饰符 <a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/SharedTransitionScope?hl=en#(androidx.compose.ui.Modifier).skipToLookaheadPosition(kotlin.Function0)">Modifier.skipToLookaheadPosition()</a>，用于在执行共享元素动画时保持可组合元素的最终位置。这使得可以执行类似“揭示”类型的过渡动画，例如 Androidify 示例中相机的渐进式揭示效果。更多信息，请参阅<a href="https://www.youtube.com/embed/0moEXBqNDZI">此处的视频提示</a>。</p>

<h3>共享元素过渡中的初始速度</h3>

<p>此版本新增了一个共享元素过渡 API：<code>prepareTransitionWithInitialVelocity</code>，允许你将初始速度（例如来自手势）传递给共享元素过渡：</p>

<pre><code class="kotlin">Modifier.fillMaxSize()
    .draggable2D(
            rememberDraggable2DState{offset+=it},
            onDragStopped = { velocity -&gt;
                // Set up the initial velocity for the upcoming shared element
                // transition.
              sharedContentStateForDraggableCat?.prepareTransitionWithInitialVelocity(velocity)
                showDetails = false
            },
)
</code></pre>

<p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi-XdYTEA7H5BokZRoo_npAvjuSLPP3cXifTSHtonoHiuQVtav1w9ZKhIqlxQJKeX9AxyQnR0HjSe3t1Sy02jdMYiWI_mg1VoJST55CAKgBtkvHpgRatXJobhPVoimLQCJ-F6dfLRDt75vJANi46D4MhobglqRG7rSFb3VqglLcE6rNLx3c02Vzqiqr6IY/w288-h640/fling-shared.gif" alt="一个以初始速度开始的共享元素过渡，该初始速度来自手势" /></p>

<h3>面纱过渡动画</h3>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/EnterTransition">EnterTransition</a> 和 <a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/ExitTransition?_gl=1*1m00og2*_up*MQ..*_ga*MjU3NDMyNzc5LjE3NjQ2MTE4NjM.*_ga_6HH9YJMN9M*czE3NjQ2MTE4NjMkbzEkZzAkdDE3NjQ2MTE4NjMkajYwJGwwJGgxMTk2NzM1MDk0">ExitTransition</a> 定义了动画的执行方式。 <a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#AnimatedVisibility">AnimatedVisibility</a>/ <a href="https://developer.android.com/refe%20rence/kotlin/androidx/compose/animation/package-summary#AnimatedContent">AnimatedContent</a> 可组合元素出现或消失。新增的实验性遮罩选项允许你指定颜色来遮盖或修饰内容；例如，在内容上方淡入/淡出半透明黑色图层：</p>

<p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhemyKNMNnK50HVISQJlCz4fXPkkckq-ZdOgB3f8dolMzDe6UgCGq3_nVQhdfNb8au6cL00LHR0EJIQqxOQnnCXNSs8284eIMGroEp1V_F48JHkIk_kzPiYAov-nI3LAIG0_XXNjVQUIXwDvgH_rdMgF9wn_u605WU8oOD-uW-MSVKUHzyekqYsnFrEqms/w304-h640/veil_2.gif" alt="带遮蔽的动画内容 – 注意在动画过程中覆盖在网格内容上的半透明遮蔽层（或幕布）动画" /></p>

<pre><code class="kotlin">AnimatedContent(
    targetState = page,
    modifier = Modifier.fillMaxSize().weight(1f),
    transitionSpec = {
         if (targetState &gt; initialState) {
            (slideInHorizontally { it } togetherWith
                    slideOutHorizontally { -it / 2 } + veilOut(targetColor = veilColor))
        } else {
            slideInHorizontally { -it / 2 } +
                        unveilIn(initialColor = veilColor) togetherWith slideOutHorizontally { it }
        }
    },
) { targetPage -&gt;
    ...
}
</code></pre>

<h2>即将发生的变更</h2>

<h3>弃用 Modifier.onFirstVisible</h3>

<p>Compose 1.9 引入了 <a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#%28androidx.compose.ui.Modifier%29.onVisibilityChanged%28kotlin.Long,kotlin.Float,androidx.compose.ui.layout.LayoutBoundsHolder,kotlin.Function1%29">Modifier.onVisibilityChanged</a> 和 <a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#%28androidx.compose.ui.Modifier%29.onFirstVisible%28kotlin.Long,kotlin.Float,androidx.compose.ui.layout.LayoutBoundsHolder,kotlin.Function0%29">Modifier.onFirstVisible</a>。在审阅了你的反馈后，我们发现 <code>Modifier.onFirstVisible</code> 的约定无法确定性地执行；具体来说，就是无法确定某个元素何时首次可见。例如，Lazy 布局可能会释放滚动出视口的元素，然后在它们滚动回视口时重新组合它们。在这种情况下，<code>onFirstVisible</code> 回调会再次触发，因为它是一个新组合的元素。当导航回之前访问过的包含 <code>onFirstVisible</code> 的屏幕时，也会出现类似的行为。因此，我们决定在下一个 Compose 版本（1.11）中弃用此修饰符，并建议迁移到 <code>onVisibilityChanged</code>。有关更多信息，请参阅<a href="https://developer.android.com/develop/ui/compose/layouts/visibility-modifiers">文档</a>。</p>

<h3>测试中的协程分发</h3>

<p>我们计划更改测试中的协程分发，以改善测试的稳定性并捕获更多问题。目前，测试使用的是 UnconfinedTestDispatcher，这与生产环境的行为有所不同；例如，<a href="https://developer.android.com/develop/ui/compose/side-effects">副作用</a>可能会立即运行，而不是被放入队列。在未来的版本中，我们计划引入一个新的 API，默认使用 StandardTestDispatcher，以匹配生产环境的行为。你现在可以在 1.10 版本中尝试新的行为：</p>

<pre><code class="kotlin">@get:Rule // also createAndroidComposeRule, createEmptyComposeRule
val rule = createComposeRule(effectContext = StandardTestDispatcher())
</code></pre>

<p>使用 StandardTestDispatcher 会将任务放入队列，因此你必须使用同步机制，例如 composeTestRule.waitForIdle() 或 composeTestRule.runOnIdle()。如果你的测试使用了 runTest，则必须确保 runTest 和你的 Compose 规则共享同一个 StandardTestDispatcher 实例以进行同步。</p>

<pre><code class="kotlin">// 1. Create a SINGLE dispatcher instance
valtestDispatcher = StandardTestDispatcher()

// 2. Pass it to your Compose rule
@get:Rule
valcomposeRule = createComposeRule(effectContext = testDispatcher)

@Test
// 3. Pass the *SAME INSTANCE* to runTest
funmyTest() = runTest(testDispatcher) {
    composeRule.setContent{/* ... */}
}
</code></pre>

<h2>工具</h2>

<p>优秀的 API 需要优秀的工具，<a href="http://d.android.com/studio">Android Studio</a> 为 Compose 开发者新增了多项功能：</p>

<ul>
<li><p><a href="https://developer.android.com/studio/preview/features#iterate-ui-agent">变换 UI</a>：右键单击 @Preview，选择“变换 UI”，然后用自然语言描述更改，即可迭代你的设计。</p></li>
<li><p><a href="https://developer.android.com/studio/preview/features#ui-tools-setup">生成 @Preview</a>：右键单击可组合元素，然后选择 Gemini > 生成 [可组合元素名称] 预览。</p></li>
<li><p><a href="https://developer.android.com/studio/preview/features#material-symbols-support">自定义 Material Symbols</a>：矢量资源向导新增了对图标变体的支持。</p></li>
<li><p><a href="https://developer.android.com/studio/preview/features#screen-to-code-agent">从屏幕截图生成代码</a> 或让 Gemini <a href="https://developer.android.com/studio/preview/features#match-ui-agent">将你现有的 UI 与目标图像匹配</a>。这可以与远程 <a href="https://developer.android.com/studio/preview/features#remote-mcp">MCP 支持</a> 结合使用，例如连接到 Figma 文件并从设计生成 Compose UI。</p></li>
<li><p><a href="https://developer.android.com/studio/preview/features#find-and-fix-ui-quality-issues">修复 UI 质量问题</a> 会审核你的 UI 是否存在常见问题，例如辅助功能问题，然后提出修复方案。</p></li>
</ul>


<p>要查看这些工具的实际应用，请观看此 <a href="https://www.youtube.com/embed/jTlW8JeCClA">最新演示</a>。</p>

<h2>尽情创作</h2>

<p>我们持续投入资源开发 Jetpack Compose，为你提供创建美观、丰富的用户界面所需的 API 和工具。我们重视你的反馈，请在我们的<a href="https://issuetracker.google.com/issues/new?component=612128">问题跟踪器</a>中分享你对这些更改的反馈，或你希望看到的后续功能。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[借助RemoteCompose开发动态化页面]]></title>
    <link href="https://alexhilton.github.io/blog/2025/12/11/intro-to-remotecompose/"/>
    <updated>2025-12-11T00:00:00+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/12/11/intro-to-remotecompose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「RemoteCompose: Another Paradigm for Server-Driven UI in Jetpack Compose」，原文链接<a href="https://proandroiddev.com/remotecompose-another-paradigm-for-server-driven-ui-in-jetpack-compose-92186619ba8f">https://proandroiddev.com/remotecompose-another-paradigm-for-server-driven-ui-in-jetpack-compose-92186619ba8f</a>，由Jaewoong Eum发布于2025年11月29日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:2000/0*o9-kxXHKgJcB-Bvh" title="auto auto" ></a></p>

<!-- more -->


<p>构建动态用户界面一直是 Android 开发中的一项根本性挑战。传统方法要求每次 UI 需要更改时都必须重新编译和重新部署整个应用程序，这给 A/B 测试、功能开关和实时内容更新带来了极大的不便。</p>

<p>试想一下，你的营销团队想要测试一个新的结账按钮设计：在传统模式下，这种简单的更改需要开发人员花费时间、进行代码审查、QA 测试、提交到应用商店，以及等待数周才能获得用户采纳。RemoteCompose 的出现为解决这一问题提供了一个强大的方案，它使开发人员能够在运行时创建、传输和渲染 Jetpack Compose UI 布局，而无需重新编译。</p>

<p>本文将探讨 RemoteCompose 的概念，理解其核心架构，并探索它如何为 Jetpack Compose 的动态页面设计带来诸多优势。本文并非库的使用教程，而是着重探讨它所代表的 Android UI 开发范式转变。</p>

<h3><strong>集成与依赖</strong></h3>

<p>在深入探讨概念之前，我们先来了解如何将 RemoteCompose 添加到你的项目中。对于运行在 JVM 上且不依赖 Android 的服务器和后端：</p>

<pre><code class="groovy">// settings.gradle
repositories {
  maven {
    url = uri("https://androidx.dev/snapshots/builds/14511716/artifacts/repository")
  }
}

// JVM server - no Android dependencies
dependencies {
    implementation("androidx.compose.remote:remote-core:1.0.0-SNAPSHOT")
    implementation("androidx.compose.remote:remote-creation-compose:1.0.0-SNAPSHOT")
}

// Compose-based app
dependencies {
    implementation("androidx.compose.remote:remote-player-compose:1.0.0-SNAPSHOT")
    implementation("androidx.compose.remote:remote-tooling-preview:1.0.0-SNAPSHOT")
}

// View-based app
dependencies {
    implementation("androidx.compose.remote:remote-player-view:1.0.0-SNAPSHOT")
}
</code></pre>

<p>请注意，RemoteCompose 仍在由 AndroidX 团队开发中，尚未正式发布；它仅可通过 AndroidX 快照 Maven 仓库获取。</p>

<h3>理解核心抽象</h3>

<p>RemoteCompose 的核心是一个框架，它支持 Compose UI 组件的远程渲染。它与传统 UI 方法的区别在于它遵循两个基本原则：声明式文档序列化和平台无关渲染。这些不仅仅是技术特性；这些架构决策从根本上改变了你对 UI 部署的思考方式。</p>

<p><strong>声明式文档序列化</strong></p>

<p>声明式文档序列化意味着你可以将任何 Jetpack Compose 布局捕获为紧凑的序列化格式。你可以把它想象成对 UI 进行“截图”，只不过你捕获的不是像素，而是实际的绘图指令。这个捕获的文档包含了重建 UI 所需的一切：形状、颜色、文本、图像、动画，甚至还有交互式触摸区域。</p>

<pre><code class="kotlin">// On the server or creation side
val document = captureRemoteDocument(
    context = context,
    creationDisplayInfo = displayInfo,
    profile = profile
) {
    RemoteColumn(modifier = RemoteModifier.fillMaxSize()) {
        RemoteText("Dynamic Content")
        RemoteButton(onClick = { /* action */ }) {
            RemoteText("Click Me")
        }
    }
}
</code></pre>

<p>结果如何？一个可以通过网络发送的字节数组。这种方法的关键在于，创建端编写的是标准的 Compose 代码。无需学习新的 DSL，无需维护 JSON 模式，也无需掌握模板语言。只要可以用 Compose 编写，就可以用 RemoteCompose 捕获。</p>

<p>你可以捕获一个普通的 Compose 代码，它会捕获绘制调用（这些调用非常静态）。更常见的情况是，你应该拥有镜像 Compose 的 Remote* 专用 API，这些 API 专为序列化和远程播放而设计，例如 <code>RemoteColumn</code>、<code>RemoteButton</code>、<code>RemoteText</code> 等。</p>

<p><strong>平台无关渲染</strong></p>

<p>平台无关渲染意味着捕获的文档可以通过网络传输，并在任何 Android 设备上渲染，而无需原始的 Compose 代码。客户端设备不需要你的可组合函数、视图模型或业务逻辑——它只需要文档字节和一个播放器。</p>

<pre><code class="kotlin">// On the client or player side
RemoteDocumentPlayer(
    document = remoteDocument.document,
    documentWidth = windowInfo.containerSize.width,
    documentHeight = windowInfo.containerSize.height,
    onAction = { actionId, value -&gt;
        // Handle user interactions
    }
)
</code></pre>

<p>这些特性并非仅仅是为了方便；它们是架构约束，能够真正实现 UI 定义与部署的解耦。文档格式不仅包含静态布局，还包含状态、动画和交互，从而完整地呈现了 UI 体验。</p>

<p><strong>​​方法比较：为什么不选择 JSON 或 WebView？</strong></p>

<p>在深入探讨之前，我们有必要了解 RemoteCompose 为什么选择这种方法而不是其他方案。</p>

<p>基于 JSON 的服务器端 UI，例如 Airbnb 的 Epoxy 或 Shopify 的方法，需要定义一个映射到原生组件的模式。这种方法适用于结构化内容，但难以处理复杂的动画和过渡效果、自定义绘图和图形、带有内联样式的富文本以及渐变和阴影等视觉效果。</p>

<p>WebView 提供了全面的灵活性，但由于其独立的渲染过程，会带来性能开销；此外，Web 样式与原生设计在外观和体验上存在不一致；每个 WebView 都会占用大量资源，造成内存压力；触摸处理也较为复杂，容易出现手势冲突。</p>

<p>RemoteCompose 另辟蹊径：捕获 Compose 实际执行的绘制操作。这意味着，你可以使用 Compose 构建的任何 UI，包括自定义 Canvas 绘制、复杂动画和 Material Design 组件，都可以被捕获并以原生性能远程重放。</p>

<h3><strong>基于文档的架构：创建与回放</strong></h3>

<p>RemoteCompose 的架构围绕着两个阶段的清晰分离而构建：文档创建和文档回放。理解这种分离是理解框架强大功能的关键。</p>

<p><strong>文档创建：将 UI 作为数据捕获</strong></p>

<p>创建阶段将 Compose UI 代码转换为序列化文档。这是通过捕获机制实现的，该机制会在 Canvas 层（Android 渲染管线的最底层）拦截绘制操作。</p>

<pre><code class="kotlin">@Composable Content
        ↓
RemoteComposeCreationState (Tracks state and modifiers)
        ↓
CaptureComposeView (Virtual Display - no actual screen needed)
        ↓
RecordingCanvas (Intercepts every draw call)
        ↓
Operations (93+ operation types covering all drawing primitives)
        ↓
RemoteComposeBuffer (Efficient binary serialization)
        ↓
ByteArray (Network-ready, typically 10-100KB for complex UIs)
</code></pre>

<p>创建端提供了一个完整的 Compose 集成层。你只需编写标准的 <code>@Composable</code> 函数，框架即可捕获所有内容：布局层级、修饰符、文本样式、图像、动画，甚至触摸处理程序。</p>

<p>其独特之处在于，捕获的文档是自包含的。它包含形状、颜色、渐变和阴影等视觉元素，以及带有字符串、字体、大小和样式的文本。图像可以嵌入为位图或 URL 以实现延迟加载。布局信息涵盖大小、位置、内边距和对齐方式。交互定义了触摸区域、点击处理程序和命名操作。状态变量可以在运行时更新，动画则通过基于时间的运动表达式来表达。</p>

<p>接收方无需访问你的代码库，只需访问文档字节即可。这与其他服务器驱动的 UI 方法有着本质区别，在其他方法中，客户端需要理解架构或拥有预构建的组件。</p>

<p><strong>文档播放：无需编译即可渲染</strong></p>

<p>播放阶段接收序列化的文档并将其渲染到屏幕上。播放器会遍历一系列操作，对 Canvas 执行每个操作。其概念类似于视频播放器解码帧的方式，只不过我们解码的是绘图指令而不是像素。</p>

<p>RemoteCompose 提供两种渲染后端以满足不同的架构需求。基于 Compose 的播放器推荐用于现代应用程序：</p>

<pre><code class="kotlin">@Composable
fun DynamicScreen(document: CoreDocument) {
    RemoteDocumentPlayer(
        document = document,
        documentWidth = screenWidth,
        documentHeight = screenHeight,
        modifier = Modifier.fillMaxSize(),
        onNamedAction = { name, value, stateUpdater -&gt;
            // Handle named actions from the document
            when (name) {
                "addToCart" -&gt; cartManager.addItem(value)
                "navigate" -&gt; navController.navigate(value)
                "trackEvent" -&gt; analytics.logEvent(value)
            }
        },
        bitmapLoader = rememberBitmapLoader()  // For lazy image loading
    )
}
</code></pre>

<p>基于 Compose 的播放器可以自然地与你现有的 Compose UI 集成。它是一个可组合的函数，你可以将其放置在组合层级结构中的任何位置，并像其他可组合函数一样对其应用修饰符和动画。</p>

<p>为了与现有的 View 层级结构兼容，我们还提供了一个基于 View 的播放器：</p>

<pre><code class="kotlin">class LegacyActivity : AppCompatActivity() {
    private lateinit var player: RemoteComposePlayer

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        player = RemoteComposePlayer(this)
        setContentView(player)

        // Load document from network
        lifecycleScope.launch {
            val bytes = api.fetchDocument("home-screen")
            player.setDocument(bytes)
        }

        player.onNamedAction { name, value, stateUpdater -&gt;
            // Handle actions
        }
    }
}
</code></pre>

<p>两种播放器提供相同的渲染保真度；选择哪种取决于你的应用程序架构。如果你完全使用 Compose，请使用可组合播放器。如果你是从 Views 迁移过来的，或者将其嵌入到 View 层级结构中，请使用基于 View 的播放器。</p>

<h3><strong>操作模型：一套全面的绘图词汇表</strong></h3>

<p>RemoteCompose 的优势在于其全面的操作模型。该框架定义了 93 种以上的不同操作，涵盖了 UI 渲染的方方面面。这并非随意设定的数字，而是表达任何 Canvas 绘图操作所需的完整词汇表。</p>

<p><strong>操作的重要性</strong></p>

<p>传统的服务器驱动型 UI 发送的是高级组件描述：“渲染一个带有文本‘提交’的按钮”。客户端必须解析这些描述并将其映射到原生组件。这导致服务器和客户端之间紧密耦合；双方必须就“按钮”的定义及其行为达成一致。</p>

<p>RemoteCompose 则在更底层运行：它不发送“渲染一个按钮”这样的描述，而是发送实际的绘图指令：“在这些坐标处绘制一个带有这种颜色的圆角矩形，然后在这个位置绘制带有这种字体的文本‘提交’”。客户端无需了解“按钮”的定义；它只需执行绘图操作即可。</p>

<p>这种底层方法意义深远。由于服务器和客户端无需就组件定义达成一致，因此无需进行模式同步。由于 Compose 中所有可能的视觉效果均可捕获，因此能够完整保留视觉保真度。由于新的视觉设计可在旧客户端上运行（它们只是不同的绘制操作），因此内置了向前兼容性。自定义组件无需注册即可自动运行。</p>

<p><strong>绘制操作</strong></p>

<p>绘制操作捕获 Canvas 绘制调用，这是 2D 图形的基本图元。这些图元包括：用于按钮、卡片和背景的矩形的 <code>DRAW_RECT</code>；用于带有圆角的 Material 曲面的 <code>DRAW_ROUND_RECT</code>；用于头像和指示器的 <code>DRAW_CIRCLE</code>；用于渲染带有完整样式的文本的 <code>DRAW_TEXT</code>；用于沿曲线绘制文本的 <code>DRAW_TEXT_ON_PATH</code>；以及用于图像的 <code>DRAW_BITMAP</code>。 <code>DRAW_TWEEN_PATH</code> 用于动画路径变形，等等。</p>

<p>每个操作都包含执行它所需的所有信息：坐标、颜色、绘制样式以及对文档中其他位置存储的数据（例如文本字符串或位图）的引用。</p>

<p><strong>布局操作</strong></p>

<p>布局操作定义组件层次结构和空间关系。<code>Component</code> 操作声明一个布局组件，而 <code>Container</code> 操作创建一个类似于 <code>Column</code> 或 <code>Row</code> 的容器，<code>ContainerEnd</code> 操作则关闭它。<code>LoopOperation</code> 操作用于循环列表内容。<code>Modifier</code> 包括用于背景颜色和可绘制对象的 <code>BackgroundModifier</code>、用于边框样式的 <code>BorderModifier</code>、用于内部间距的 <code>PaddingModifier</code> 以及用于触摸处理的 <code>ClickModifier</code>。</p>

<p>容器模型采用推送/弹出机制。当播放器遇到 <code>Container</code> 操作时，它会创建一个新的布局上下文。所有后续操作都将在该上下文中执行，直到 <code>ContainerEnd</code> 操作将其弹出。这与 Compose 的布局系统的工作方式类似。</p>

<p><strong>状态和表达式操作</strong></p>

<p>状态操作支持运行时可更改的动态值。<code>NamedVariable</code> 声明一个命名的状态变量。<code>ColorAttribute</code> 提供可自定义主题的颜色。<code>TimeAttribute</code> 引用动画时间。<code>FloatExpression</code> 和 <code>IntegerExpression</code> 每帧计算数学表达式。<code>ConditionalOp</code> 支持基于状态的条件渲染。</p>

<p>表达式系统功能强大。你可以嵌入公式，而不是静态值：</p>

<pre><code class="kotlin">// These expressions are evaluated every frame
val opacity = FloatExpression("sin(time * 2) * 0.5 + 0.5")  // Pulsing effect
val rotation = FloatExpression("time * 90 % 360")

// Continuous rotation
val position = FloatExpression("lerp(0, 100, time / 2)")

// Linear interpolation
</code></pre>

<p>这使得完全在文档中定义丰富的动画成为可能——无需客户端动画代码。
​​
<strong>交互操作</strong></p>

<p>交互操作处理用户输入。<code>TouchOperation</code> 定义触摸区域，而 <code>CLICK_AREA</code> 处理简单的点击操作。<code>ParticlesCreate</code> 初始化粒子系统，<code>ParticlesLoop</code> 驱动粒子动画。</p>

<p>触摸操作注册带有命名操作的矩形区域。当用户点击某个区域时，播放器会触发相应的操作，宿主应用程序会通过回调函数来处理这些操作。这种设计既保持了文档格式的简洁性，又实现了丰富的交互功能。</p>

<h3>动态屏幕设计的优势</h3>

<p>现在，让我们通过常见应用场景中的真实案例，来探讨 RemoteCompose 为动态屏幕设计带来的切实优势。</p>

<p><strong>服务器驱动 UI，性能毫不妥协</strong></p>

<p>传统的服务器驱动 UI 方法需要权衡取舍。基于 JSON 的布局表达能力有限，无法实现复杂的动画或自定义绘制。WebView 会带来性能开销、外观不一致以及更高的内存占用。自定义 DSL 则会增加维护负担、学习曲线，并且对预定义组件有所限制。</p>

<p>RemoteCompose 提供了第三条路径：从服务器定义的布局进行原生 Compose 渲染。你既能充分利用 Compose 渲染引擎的强大功能，又能享受服务器驱动内容的灵活性。</p>

<p>例如，一个电商应用需要频繁更新产品卡片、添加新的徽章样式、促销叠加层或季节性主题。借助 RemoteCompose，服务器端允许营销团队无需发布应用即可更新卡片设计：</p>

<pre><code class="kotlin">// Server-side: We can update card designs without app release
@Composable
fun ProductCard(product: Product) {
    Card(
        modifier = RemoteModifier
            .fillMaxWidth()
            .clickable { namedAction("viewProduct", product.id) }
    ) {
        Box {
            // Product image with gradient overlay
            AsyncImage(
                url = product.imageUrl,
                modifier = RemoteModifier.fillMaxWidth().aspectRatio(1.5f)
            )

            // Promotional badge - can be A/B tested server-side
            if (product.hasPromotion) {
                PromotionalBadge(
                    text = product.promotionText,
                    modifier = RemoteModifier.align(Alignment.TopEnd)
                )
            }

            // Price with sale styling
            PriceTag(
                originalPrice = product.originalPrice,
                salePrice = product.salePrice,
                modifier = RemoteModifier.align(Alignment.BottomStart)
            )
        }
    }
}
</code></pre>

<p>客户端只需渲染服务器发送的内容：</p>

<pre><code class="kotlin">// Client-side: Just renders whatever the server sends
@Composable
fun ProductGrid(viewModel: ProductViewModel) {
    val documents by viewModel.productDocuments.collectAsState()

    LazyVerticalGrid(columns = GridCells.Fixed(2)) {
        items(documents) { document -&gt;
            RemoteDocumentPlayer(
                document = document,
                onNamedAction = { name, value, _ -&gt;
                    if (name == "viewProduct") {
                        navController.navigate("product/$value")
                    }
                }
            )
        }
    }
}
</code></pre>

<p>现在，你的团队无需发布任何应用即可更新产品卡片设计，更改徽章颜色、添加动画和重新排列元素。由于它是原生应用，通过 Compose 的实际绘制管道渲染，因此 UI 的外观和体验与原生应用无异。</p>

<h3>大规模 A/B 测试</h3>

<p>传统的 A/B 测试 UI 变体需要在应用二进制文件中实现所有变体，为每个变体创建功能标志，发布包含所有变体的应用，然后等待用户采用后再衡量结果。从构思到获得数据，这个过程通常需要 2-4 周。</p>

<p>借助 RemoteCompose，你无需部署任何客户端即可测试 UI 变体。假设一个电商团队想要测试单页结账流程是否比多步骤向导转化率更高：</p>

<pre><code class="kotlin">// Server-side: Two completely different checkout experiences
object CheckoutExperiments {

    fun getCheckoutDocument(user: User, cart: Cart): ByteArray {
        val variant = experimentService.getVariant(user.id, "checkout-flow")

        return when (variant) {
            "single-page" -&gt; captureSinglePageCheckout(cart)
            "multi-step" -&gt; captureMultiStepCheckout(cart)
            "express" -&gt; captureExpressCheckout(cart)  // New variant added without app update
            else -&gt; captureSinglePageCheckout(cart)
        }
    }

    private fun captureSinglePageCheckout(cart: Cart): ByteArray {
        return captureRemoteDocument(context, displayInfo, profile) {
            SinglePageCheckout(
                cart = cart,
                onPlaceOrder = { namedAction("placeOrder", cart.id) },
                onUpdateQuantity = { itemId, qty -&gt;
                    namedAction("updateQuantity", "$itemId:$qty")
                }
            )
        }
    }

    private fun captureMultiStepCheckout(cart: Cart): ByteArray {
        return captureRemoteDocument(context, displayInfo, profile) {
            MultiStepCheckout(
                cart = cart,
                steps = listOf("Shipping", "Payment", "Review"),
                onComplete = { namedAction("placeOrder", cart.id) }
            )
        }
    }
}
</code></pre>

<p>客户端完全不知道显示的是哪个版本：</p>

<pre><code class="kotlin">// Client-side: Completely agnostic to which variant is shown
@Composable
fun CheckoutScreen(viewModel: CheckoutViewModel) {
    val document by viewModel.checkoutDocument.collectAsState()

    document?.let { doc -&gt;
        RemoteDocumentPlayer(
            document = doc,
            onNamedAction = { name, value, stateUpdater -&gt;
                when (name) {
                    "placeOrder" -&gt; viewModel.placeOrder(value)
                    "updateQuantity" -&gt; {
                        val (itemId, qty) = value.split(":")
                        viewModel.updateQuantity(itemId, qty.toInt())
                    }
                }
            }
        )
    }
}
</code></pre>

<p>结果即时且实时，这意味着无需等待应用商店审核或用户反馈。你甚至可以添加全新的版本，例如“快速结账”，而无需对客户端进行任何更改。实验会持续运行，直到获得统计学意义上的显著性，然后将获胜版本推广到所有用户，同样无需发布新应用。</p>

<h3>实时内容更新</h3>

<p>内容密集型应用常常需要在原生性能和内容新鲜度之间寻求平衡。以新闻应用为例：文章需要丰富的格式、嵌入式媒体和交互元素，但同时也需要随着新闻事件的进展实时更新。</p>

<p>一家报道重大事件的新闻机构需要实时更新文章布局。编辑团队可以根据新闻事件的进展调整布局：</p>

<pre><code class="kotlin">// Server-side: Editorial team can update layout as story develops
class ArticleLayoutService {

    fun getArticleDocument(article: Article): ByteArray {
        return captureRemoteDocument(context, displayInfo, profile) {
            ArticleLayout(article)
        }
    }

    @Composable
    private fun ArticleLayout(article: Article) {
        Column(modifier = RemoteModifier.fillMaxSize().padding(16.dp)) {
            // Breaking news banner - can be added/removed instantly
            if (article.isBreaking) {
                BreakingNewsBanner(
                    modifier = RemoteModifier.fillMaxWidth()
                )
            }

            // Headline with dynamic styling
            Text(
                text = article.headline,
                style = if (article.isBreaking) {
                    HeadlineStyle.Breaking
                } else {
                    HeadlineStyle.Standard
                }
            )

            // Live updates indicator
            if (article.hasLiveUpdates) {
                LiveUpdatesIndicator(
                    lastUpdate = article.lastUpdate,
                    modifier = RemoteModifier.clickable {
                        namedAction("refreshArticle", article.id)
                    }
                )
            }

            // Rich content blocks - can include any Compose UI
            article.contentBlocks.forEach { block -&gt;
                when (block) {
                    is TextBlock -&gt; ArticleText(block)
                    is ImageBlock -&gt; ArticleImage(block)
                    is VideoBlock -&gt; VideoEmbed(block)
                    is LiveBlogBlock -&gt; LiveBlogTimeline(block)
                    is InteractiveChartBlock -&gt; DataVisualization(block)
                    is PullQuoteBlock -&gt; PullQuote(block)
                }
            }

            // Related articles - layout can be A/B tested
            RelatedArticles(
                articles = article.relatedArticles,
                onArticleClick = { namedAction("openArticle", it.id) }
            )
        }
    }
}
</code></pre>

<p>客户端只需渲染服务器提供的任何布局：</p>

<pre><code class="kotlin">// Client-side: Renders whatever layout the server sends
@Composable
fun ArticleScreen(articleId: String, viewModel: ArticleViewModel) {
    val document by viewModel.articleDocument.collectAsState()
    val refreshing by viewModel.isRefreshing.collectAsState()

    SwipeRefresh(
        state = rememberSwipeRefreshState(refreshing),
        onRefresh = { viewModel.refresh() }
    ) {
        document?.let { doc -&gt;
            RemoteDocumentPlayer(
                document = doc,
                onNamedAction = { name, value, _ -&gt;
                    when (name) {
                        "openArticle" -&gt; navController.navigate("article/$value")
                        "refreshArticle" -&gt; viewModel.refresh()
                        "playVideo" -&gt; videoPlayer.play(value)
                    }
                }
            )
        }
    }
}
</code></pre>

<p>你的团队无需修改应用即可更新文章布局，添加实时博客时间线、嵌入交互式图表和更改字体。当新闻事件有进展时，他们可以立即在所有相关文章上添加“突发新闻”横幅。</p>

<h3>避免代码膨胀的功能标志</h3>

<p>传统的功能标志需要将所有变体都包含在二进制文件中：</p>

<pre><code class="kotlin">// Traditional approach - all code ships, even unused variations
@Composable
fun HomeScreen() {
    when {
        featureFlags.newHomeV3 -&gt; NewHomeLayoutV3()  // Ships always
        featureFlags.newHomeV2 -&gt; NewHomeLayoutV2()  // Ships always
        else -&gt; OldHomeLayout()

        // Ships always
    }
}
</code></pre>

<p>这会带来几个问题。二进制文件会因为包含所有变体而增加应用程序的大小。即使未使用，也会包含无用代码。当功能标志配置错误时，可能会暴露未发布的功能，从而带来安全风险。随着时间的推移，旧的变体不断累积，导致技术债务不断增加。</p>

<p>使用 RemoteCompose，只会传输当前激活的变体：</p>

<pre><code class="kotlin">// Server-side: Only the active variation exists on the server
class HomeScreenService {
    fun getHomeDocument(user: User): ByteArray {
        return when (featureFlags.getHomeVariant(user)) {
            "v3" -&gt; captureHomeV3(user)
            "v2" -&gt; captureHomeV2(user)
            else -&gt; captureHomeDefault(user)
        }
    }
}

// Client-side: No conditional code, no dead code
@Composable
fun HomeScreen(document: CoreDocument) {
    RemoteDocumentPlayer(document = document)
    // That's it. No feature flags, no conditionals.
}
</code></pre>

<p>这消除了二进制文件膨胀，因为不会传输旧的变体；由于只存在服务器端代码，因此消除了无用代码；并且由于配置错误只会显示不同的 UI 而不是未发布的代码，因此降低了安全风险。</p>

<p>设想一个社交媒体应用正在逐步重新设计其信息流：</p>

<pre><code class="kotlin">// Server-side: Complete control over who sees what
class FeedLayoutService {

    fun getFeedDocument(user: User, posts: List&lt;Post&gt;): ByteArray {
        val variant = rolloutService.getFeedVariant(user)

        return captureRemoteDocument(context, displayInfo, profile) {
            when (variant) {
                FeedVariant.NEW_DESIGN -&gt; NewFeedLayout(posts)
                FeedVariant.NEW_DESIGN_COMPACT -&gt; NewFeedCompactLayout(posts)
                FeedVariant.CLASSIC -&gt; ClassicFeedLayout(posts)
            }
        }
    }
}

// Rollout service controls the percentage
class RolloutService {
    fun getFeedVariant(user: User): FeedVariant {
        // 5% get new design, 5% get compact variant, 90% get classic
        return when {
            user.id.hashCode() % 100 &lt; 5 -&gt; FeedVariant.NEW_DESIGN
            user.id.hashCode() % 100 &lt; 10 -&gt; FeedVariant.NEW_DESIGN_COMPACT
            else -&gt; FeedVariant.CLASSIC
        }
    }

    // Instant rollback if issues are detected
    fun emergencyRollback() {
        // All users immediately get classic layout
        // No app update needed
    }
}
</code></pre>

<p>如果新设计导致问题（例如崩溃、用户互动度下降或用户投诉），可以立即回滚。只需更改服务器配置即可。无需紧急发布应用。</p>

<h3>跨平台一致性</h3>

<p>RemoteCompose 的文档格式与平台无关。同一文档可以在手机、平板电脑、折叠屏设备和 Wear OS 设备上渲染，并由相应的平台播放器负责渲染。</p>

<pre><code class="bash">Creation (Server/Backend)  
    ↓  
RemoteComposeBuffer (Platform-independent binary format)  
    ↓  
┌─────────────────────────────────────────────────────────┐  
│

│
↓

↓

↓

↓
Android Phone

Android Tablet

Foldable Device

Wear OS
(Compose Player) (Compose Player)  (Compose Player)   (Wear Player)
</code></pre>

<p>假设一款健身应用在手机和手表应用上都显示锻炼总结。相同的数据会针对不同的设备尺寸进行优化，呈现不同的内容：</p>

<pre><code class="kotlin">// Server-side: Same data, different presentations
class WorkoutSummaryService {

    fun getPhoneDocument(workout: Workout): ByteArray {
        return captureRemoteDocument(context, phoneDisplayInfo, profile) {
            PhoneWorkoutSummary(workout)  // Full detailed view
        }
    }

    fun getWatchDocument(workout: Workout): ByteArray {
        return captureRemoteDocument(context, watchDisplayInfo, profile) {
            WatchWorkoutSummary(workout)  // Glanceable summary
        }
    }

    @Composable
    private fun PhoneWorkoutSummary(workout: Workout) {
        Column {
            WorkoutHeader(workout)
            HeartRateChart(workout.heartRateData)
            PaceChart(workout.paceData)
            SplitsTable(workout.splits)
            MapView(workout.route)
            ShareButton { namedAction("share", workout.id) }
        }
    }

    @Composable
    private fun WatchWorkoutSummary(workout: Workout) {
        // Optimized for small screen
        Column(modifier = RemoteModifier.fillMaxSize()) {
            Text(workout.type, style = WatchTypography.Title)
            Row {
                StatBox("Duration", workout.duration)
                StatBox("Distance", workout.distance)
            }
            MiniHeartRateIndicator(workout.avgHeartRate)
        }
    }
}
</code></pre>

<p>两款设备都显示锻炼数据，但布局针对各自的设备尺寸进行了优化。任一布局的更新都会立即生效，无需在任一平台上更新应用。</p>

<h3>缩短发布周期</h3>

<p>最显著的优势在于运营层面：UI 更改不再需要发布应用。考虑一下简单 UI 调整的开发周期。</p>

<p>传统方法大约需要两到四周。第一天和第二天是开发人员实现。第三天和第四天用于代码审查和修改。第五天到第七天用于质量保证测试。第八天和第九天处理发布准备和应用商店提交。第十天到第十四天：等待应用商店审核。第十五天到第三十天用户逐步采用，通常两周内会有 50% 到 70% 的用户更新。大多数用户在两到四周内不会看到变化。</p>

<p>RemoteCompose 方法只需一到两天即可完成。第一天和第二天是开发人员在服务器端实现。部署只需几分钟。所有用户都能立即看到变化。</p>

<p>这种速度优势对于节假日促销活动至关重要，你可以根据需要在当天部署季节性主题；对于服务中断的紧急消息，你可以即时更新 UI；对于快速迭代，你可以快速测试想法并快速失败；对于竞争响应，你可以以小时而不是几周的时间对市场变化做出反应。</p>

<p>以一个准备迎接黑色星期五的电商应用为例：</p>

<pre><code class="kotlin">// Traditional approach: Ship all variations weeks in advance
// Problem: All promotional code ships weeks early
// Risk: Date logic bugs could show promotions early
@Composable
fun HomeScreen() {
    val today = LocalDate.now()
    when {
        today == BlackFriday -&gt; BlackFridayHome()

        // Must ship by Oct 15
        today in BlackFridayWeek -&gt; BlackFridayWeekHome()   // Must ship by Oct 15
        today == CyberMonday -&gt; CyberMondayHome()

        // Must ship by Oct 15
        else -&gt; RegularHome()
    }
}

// Remote approach: Deploy each promotion on the exact day
// Benefit: Each promotion deploys on the exact minute needed
// Flexibility: Can react to competitor moves in real-time
class HomeScreenService {
    fun getHomeDocument(user: User): ByteArray {
        val promotion = promotionService.getCurrentPromotion()

        return captureRemoteDocument(context, displayInfo, profile) {
            when (promotion) {
                is BlackFridayPromotion -&gt; BlackFridayHome(promotion)
                is CyberMondayPromotion -&gt; CyberMondayHome(promotion)
                is FlashSale -&gt; FlashSaleHome(promotion)  // Can add new types anytime
                else -&gt; RegularHome()
            }
        }
    }
}
</code></pre>

<h3>状态管理：超越静态布局</h3>

<p>RemoteCompose 不仅限于静态布局。该框架包含一个状态管理系统，可以实现交互式、动态的 UI。</p>

<p><strong>远程状态变量</strong></p>

<p>状态可以嵌入文档中，并由客户端更新。这使得表单、计数器、切换开关和其他交互元素成为可能：</p>

<pre><code class="kotlin">// Creation side: Define interactive widget
@Composable
fun QuantitySelector(initialQuantity: Int) {
    var quantity by rememberRemoteState("quantity", initialQuantity)

    Row(
        modifier = RemoteModifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceBetween
    ) {
        IconButton(
            onClick = {
                if (quantity &gt; 1) {
                    quantity--
                    namedAction("quantityChanged", quantity.toString())
                }
            }
        ) {
            Icon(Icons.Minus)
        }

        Text(
            text = quantity.toString(),
            style = MaterialTheme.typography.headlineMedium
        )

        IconButton(
            onClick = {
                quantity++
                namedAction("quantityChanged", quantity.toString())
            }
        ) {
            Icon(Icons.Plus)
        }
    }
}
</code></pre>

<p>播放器端通过操作回调处理状态更新：</p>

<pre><code class="kotlin">// Player side: Handle state updates
RemoteDocumentPlayer(
    document = document,
    onNamedAction = { name, value, stateUpdater -&gt;
        when (name) {
            "quantityChanged" -&gt; {
                // Update cart
                cartManager.setQuantity(itemId, value.toInt())

                // Optionally update remote state directly
                stateUpdater.updateState { state -&gt;
                    state["quantity"] = RcInt(value.toInt())
                }
            }
        }
    }
)
</code></pre>

<p><strong>动画时间跟踪</strong></p>

<p>播放器跟踪动画时间并将其传递给文档，从而无需任何客户端动画代码即可实现基于时间的动画：</p>

<pre><code class="kotlin">// Server side: Define animated elements
@Composable
fun PulsingNotificationBadge(count: Int) {
    // Scale pulses between 0.9 and 1.1 over 1 second
    val scale = FloatExpression("0.9 + 0.2 * sin(time * 6.28)")

    // Opacity pulses between 0.7 and 1.0
    val opacity = FloatExpression("0.7 + 0.3 * sin(time * 6.28)")

    Box(
        modifier = RemoteModifier
            .scale(scale)
            .alpha(opacity)
            .background(Color.Red, CircleShape)
            .size(24.dp)
    ) {
        Text(
            text = count.toString(),
            color = Color.White,
            modifier = RemoteModifier.align(Alignment.Center)
        )
    }
}

// The player automatically:
// 1. Tracks elapsed time since document load
// 2. Evaluates expressions each frame
// 3. Updates visual properties
// No client animation code needed
</code></pre>

<p>这使得完全在文档格式中定义的流畅、高性能动画成为可能。表达式支持诸如 <code>sin</code>、<code>cos</code>、<code>lerp</code> 和 <code>clamp</code> 之类的数学函数，以及算术运算符和变量引用。</p>

<p><strong>双向通信</strong></p>

<p>操作系统支持文档与宿主应用之间的双向通信：</p>

<pre><code class="kotlin">// Document triggers actions for various purposes
@Composable
fun ProductDetailPage(product: Product) {
    Column {
        // Analytics tracking
        LaunchedEffect(Unit) {
            namedAction("analytics", "product_viewed:${product.id}")
        }

        ProductImage(product.imageUrl)

        // Navigation action
        TextButton(onClick = { namedAction("navigate", "/reviews/${product.id}") }) {
            Text("See all reviews")
        }

        // Cart action with data
        Button(onClick = { namedAction("addToCart", product.id) }) {
            Text("Add to Cart")
        }

        // State update action
        var isFavorite by rememberRemoteState("favorite", product.isFavorite)
        IconButton(
            onClick = {
                isFavorite = !isFavorite
                namedAction("toggleFavorite", "${product.id}:$isFavorite")
            }
        ) {
            Icon(if (isFavorite) Icons.Filled.Favorite else Icons.Outlined.Favorite)
        }
    }
}
</code></pre>

<p>宿主应用统一处理所有操作：</p>

<pre><code class="kotlin">// Host app handles all actions uniformly
RemoteDocumentPlayer(
    document = document,
    onNamedAction = { name, value, stateUpdater -&gt;
        when (name) {
            "analytics" -&gt; {
                val (event, id) = value.split(":")
                analytics.logEvent(event, mapOf("productId" to id))
            }
            "navigate" -&gt; navController.navigate(value)
            "addToCart" -&gt; {
                cartManager.add(value)
                // Update UI to show confirmation
                stateUpdater.updateState { state -&gt;
                    state["cartCount"] = RcInt((state["cartCount"] as? RcInt)?.value?.plus(1) ?: 1)
                }
            }
            "toggleFavorite" -&gt; {
                val (id, isFavorite) = value.split(":")
                favoritesManager.setFavorite(id, isFavorite.toBoolean())
            }
        }
    }
)
</code></pre>

<p>这种双向通信意味着远程文档可以完全集成到你应用的导航、分析、状态管理和业务逻辑中，而文档本身无需了解你的具体实现。</p>

<h3><strong>实际应用架构模式</strong></h3>

<p>让我们来探讨一下 RemoteCompose 如何融入实际应用架构。</p>

<p><strong>模式 1：混合架构（推荐）</strong></p>

<p>大多数应用都能从混合架构中获益：关键页面使用本地 Compose 代码构建，而动态内容区域则使用 RemoteCompose。</p>

<pre><code class="kotlin">// Navigation: Local Compose (fast, reliable)
@Composable
fun AppNavigation() {
    NavHost(navController, startDestination = "home") {
        composable("home") { HomeScreen() }
        composable("product/{id}") { ProductScreen(it.arguments?.getString("id")) }
        composable("cart") { CartScreen() }
        composable("checkout") { CheckoutScreen() }
    }
}

// Home screen: Remote (marketing can update freely)
@Composable
fun HomeScreen(viewModel: HomeViewModel = hiltViewModel()) {
    val document by viewModel.homeDocument.collectAsState()

    when (val state = document) {
        is Loading -&gt; LoadingIndicator()
        is Success -&gt; RemoteDocumentPlayer(
            document = state.document,
            onNamedAction = { name, value, _ -&gt; handleAction(name, value) }
        )
        is Error -&gt; LocalFallbackHome()  // Graceful degradation
    }
}

// Product screen: Hybrid (shell is local, content is remote)
@Composable
fun ProductScreen(productId: String, viewModel: ProductViewModel = hiltViewModel()) {
    val product by viewModel.product.collectAsState()
    val contentDocument by viewModel.contentDocument.collectAsState()

    Scaffold(
        topBar = { ProductTopBar(product) },  // Local: consistent navigation
        bottomBar = { AddToCartBar(product) } // Local: critical purchase flow
    ) { padding -&gt;
        // Remote: Rich product content, can be A/B tested
        contentDocument?.let { doc -&gt;
            RemoteDocumentPlayer(
                document = doc,
                modifier = Modifier.padding(padding)
            )
        }
    }
}
</code></pre>

<p><strong>模式 2：文档缓存以实现离线支持</strong></p>

<p>远程文档可以缓存以供离线访问：</p>

<pre><code class="kotlin">class DocumentRepository @Inject constructor(
    private val api: DocumentApi,
    private val cache: DocumentCache,
    private val connectivity: ConnectivityManager
) {
    suspend fun getDocument(key: String): CoreDocument {
        // Try cache first
        cache.get(key)?.let { cached -&gt;
            // Return cached immediately, refresh in background
            refreshInBackground(key)
            return cached
        }

        // No cache, must fetch
        return if (connectivity.isConnected) {
            fetchAndCache(key)
        } else {
            throw OfflineException("No cached document and no connectivity")
        }
    }

    private suspend fun fetchAndCache(key: String): CoreDocument {
        val bytes = api.fetchDocument(key)
        val document = RemoteComposeBuffer.deserialize(bytes)
        cache.store(key, document, ttl = 1.hours)
        return document
    }

    private fun refreshInBackground(key: String) {
        scope.launch {
            try {
                fetchAndCache(key)
            } catch (e: Exception) {
                // Silent failure, cached version is still valid
                Log.w(TAG, "Background refresh failed", e)
            }
        }
    }
}
</code></pre>

<p><strong>模式 3：文档预加载以实现流畅导航</strong></p>

<p>预加载用户可能访问的页面的文档：</p>

<pre><code class="kotlin">class DocumentPreloader @Inject constructor(
    private val repository: DocumentRepository
) {
    // Preload when user enters a screen
    fun preloadForScreen(screen: Screen) {
        val keysToPreload = when (screen) {
            is HomeScreen -&gt; listOf("featured", "categories", "promotions")
            is CategoryScreen -&gt; screen.subcategories.map { "category_${it.id}" }
            is ProductScreen -&gt; listOf("reviews_${screen.productId}", "related_${screen.productId}")
            else -&gt; emptyList()
        }

        keysToPreload.forEach { key -&gt;
            scope.launch {
                try {
                    repository.getDocument(key)  // Caches for later
                } catch (e: Exception) {
                    // Preload failure is not critical
                }
            }
        }
    }
}

// Usage in navigation
navController.addOnDestinationChangedListener { _, destination, arguments -&gt;
    preloader.preloadForScreen(destination.toScreen(arguments))
}
</code></pre>

<h3><strong>结论</strong></h3>

<p>RemoteCompose 代表了我们对 Android UI 开发思维方式的一次范式转变。通过将 Compose 布局转换为可移植文档格式，RemoteCompose 实现了服务器驱动的 UI、即时 A/B 测试、实时内容更新和跨平台一致性，同时保持了原生渲染性能。</p>

<p>该框架拥有包含 93 种以上操作的全面操作模型，充分展现了 Compose 的表达能力，包括动画、状态和交互。创建和播放的分离使得部署架构更加灵活：在后端生成具有完整 Compose 表达能力的文档，通过现有基础架构分发，并在任何 Android 设备上进行原生渲染。</p>

<p>关键在于找到合适的平衡点：对于动态、频繁变化的内容区域，使用 RemoteCompose；同时将关键流程保留在本地 Compose 代码中。这种混合方法在需要灵活性的地方提供服务器驱动 UI 的优势，在需要可靠性的地方提供编译代码的优势。</p>

<p>无论你是构建需要频繁更新布局的内容密集型应用、需要快速 A/B 测试的电子商务平台，还是需要快速迭代的企业级工具，RemoteCompose 都能为真正动态的 UI 提供架构基础。该框架处理了序列化、传输和渲染的复杂性，因此你可以专注于设计卓越的用户体验。</p>

<p>你可以观看他们最近关于<a href="https://speakerdeck.com/camaelon/introducing-remotecompose-break-your-ui-out-of-the-app-sandbox">RemoteCompose 简介：将你的 UI 从应用程序沙盒中解放出来</a>的演讲。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jetpack Compose中的阴影艺术]]></title>
    <link href="https://alexhilton.github.io/blog/2025/11/24/the-art-of-shadows-in-jetpack-compose/"/>
    <updated>2025-11-24T00:00:00+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/11/24/the-art-of-shadows-in-jetpack-compose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「The Art of Shadows in Jetpack Compose」，原文链接<a href="https://medium.com/proandroiddev/the-art-of-shadows-in-jetpack-compose-63a75070882f">https://medium.com/proandroiddev/the-art-of-shadows-in-jetpack-compose-63a75070882f</a>，由Stefano Natali发布于2025年10月4日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/1*UjyqMyVg002OIDJ1Hdee8Q.png" title="auto auto" ></a></p>

<!-- more -->


<p>UI 中的阴影发挥着至关重要的作用：它们在视觉上<strong>提升</strong>元素，指示着<strong>交互性</strong>，并提供用户操作的即时<strong>反馈</strong>。多年来，我们一直依赖于<strong>高度</strong>属性，但 Jetpack Compose 现在提供了一套强大的工具，可以对<strong>阴影渲染</strong>进行精细控制。</p>

<p>Google 最近新增了一个<a href="https://developer.android.com/develop/ui/compose/graphics/draw/shadows">文档页面</a>，其中包含一系列有趣的用例。本文将探索 Compose 中的主要阴影修改器，并深入讲解创建渐变和炫酷特效等高级技巧，从而提升应用的风格。</p>

<p>本文讨论的所有技巧的完整代码示例都可以在我的 GitHub 仓库 <a href="https://github.com/stefanoq21/ComposePlayground"><strong>Compose Playground</strong></a> 中找到。</p>

<h2>阴影修改器（Shadow Modifiers）</h2>

<p>添加阴影最简单但自定义程度最低的方法是使用 <strong>Modifier.shadow()</strong>。与以往一样，它的行为依赖于<strong>基于高度的阴影</strong>，模拟来自上方的光源，阴影深度直接取决于你提供的高度值。其主要限制在于阴影始终被裁剪到可合成对象的形状内，并且你无法自定义扩展、颜色色调或偏移等属性。</p>

<pre><code class="kotlin">Box(
    Modifier
        .size(100.dp)
        .shadow(
            elevation = 10.dp, 
            shape = RectangleShape
        )
        .background(Color.White)
)
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:704/1*7Nkm6z8Ls4FyvDqCcKToDw.png" alt="" /></p>

<p>让我们从一些新功能开始，这些功能赋予我们更强大的力量。使用 <strong>dropShadow()</strong>，我们可以在内容后面创建自定义阴影。这个修饰符是创建复杂阴影的关键，它允许对内容后面的阴影进行精细控制，使元素看起来像是被抬升了一样。</p>

<pre><code class="kotlin"> .dropShadow(
    shape = RoundedCornerShape(20.dp), shadow = Shadow(
            radius = 6.dp,
            spread = 2.dp,
            color = Color.Black.copy(alpha = 0.3f),
            offset = DpOffset(2.dp, 2.dp)
              )
            )
 .background(
    color = Color.White, shape = RoundedCornerShape(20.dp)
            )
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:990/1*kENF6x3L985dO65DSY0Zng.png" alt="" /></p>

<p>它使用 <strong>Shadow</strong> 参数，可以精确控制视觉效果。这个参数允许你使用几个关键属性来塑造阴影。 <strong>半径</strong> 决定了边缘的柔和度和扩散（模糊）程度。<strong>扩散</strong> 值控制阴影几何形状相对于可组合元素大小的扩展或收缩。最后，<strong>偏移</strong> 沿 <strong>X 轴和 Y 轴</strong>定位阴影，从而确定光源的视觉方向。结合阴影的<strong>颜色</strong>，这些属性可以实现完全自定义。</p>

<p>💡 <strong>顺序很重要：</strong>在修改器链中，<strong>dropShadow()</strong> 修改器必须出现在 <strong>background()</strong> 修改器<strong>之前</strong>，因为阴影先绘制，背景绘制在其上方。</p>

<p><strong>innerShadow()</strong> 修改器是 <strong>dropShadow()</strong> 的逆操作，它在可组合元素边界的<strong>内部</strong>创建阴影，从而实现元素凹陷或压入表面的视觉效果。与它的对应项一样，它也使用可自定义的<strong>Shadow</strong>对象，允许你使用<strong>半径</strong>、<strong>颜色</strong>、<strong>偏移</strong>和<strong>扩散</strong>来微调效果。</p>

<pre><code class="kotlin">.background(
    Color.White, shape = RoundedCornerShape(20.dp)
)
.innerShadow(
    shape = RoundedCornerShape(20.dp), shadow = Shadow(
        radius = 6.dp,
        spread = 2.dp,
        color = Color.Black.copy(alpha = 0.3f),
        offset = DpOffset(2.dp, 2.dp)
    )
)
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1108/1*a7KFFaTXCk4KC-sm9AYUoQ.png" alt="" /></p>

<p>💡<strong>再次强调，顺序很重要：</strong><strong>innerShadow()</strong>修改器<strong>必须</strong>放在<strong>background()</strong>修改器<strong>之后</strong>。如果将其放在背景之前，内容将绘制在阴影之上，完全遮盖阴影。</p>

<p>这些修改器的真正强大之处在于它们的自定义和组合。通过叠加<strong>innerShadow()</strong>和<strong>dropShadow()</strong>，你可以创建复杂而逼真的视觉效果。我们来看一些高级用例。</p>

<h2>高级技巧：组合和自定义阴影</h2>

<h3>自定义阴影</h3>

<p>当你在 <strong>dropShadow()</strong> 函数中将 <strong>Brush</strong> 对象而非纯色传递给 <strong>Shadow</strong> 对象时，自定义的强大功能便显而易见。此功能允许你使用 <strong>Brush.sweepGradient</strong> 创建渐变效果。此外，无论你使用标准形状还是完全自定义的几何体，阴影始终会贴合可组合对象的形状。</p>

<pre><code class="kotlin">.dropShadow(
    shape = MaterialShapes.Cookie12Sided.toShape(), shadow = Shadow(
        radius = 10.dp,
        spread = 6.dp,
        brush = Brush.sweepGradient(
            listOf(Color.Green, Color.Blue, Color.Yellow, Color.Green)
        ),
        offset = DpOffset(2.dp, 2.dp)
    )
)
.background(
    color = Color.White,
    shape = MaterialShapes.Cookie12Sided.toShape(),
)
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1122/1*a8xMvXOb3hS6icdGU0p1gg.png" alt="" /></p>

<h3>新粗犷主义阴影</h3>

<p>这种风格完美地展现了 <strong>dropShadow()</strong> 修改器在实现极致高对比度效果方面的强大功能。要实现新粗犷主义（Neobrutalism）那种粗犷、棱角分明的视觉效果，你必须使用 <code>dropShadow()</code> 函数，并设置模糊度为零，偏移量要明显，通常还要配合粗边框。具体来说，你需要同时设置 <code>radius = 0.dp</code> 和 <code>spread = 0.dp</code> 来消除扩散，然后应用鲜艳的色彩，并设置一个明显的偏移量，从而创建出标志性的锐利轮廓。</p>

<pre><code class="kotlin"> .dropShadow(
     shape = RoundedCornerShape(0.dp),
     shadow = Shadow(
        radius = 0.dp,
        spread = 0.dp,
        color = dropShadowColor,
        offset = DpOffset(x = 8.dp, 8.dp)
                    )
        )
 .border(
    8.dp, borderColor
        )
 .background(
    color = Color.White,
    shape = RoundedCornerShape(0.dp)
        )
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*bdPpm0XYPfTXMuoNrVQuZw.png" alt="" /></p>

<h3>具有动效的阴影</h3>

<p>阴影并非只是静态的；它们可以制作成动画，从而提供即时的用户反馈。我们将要探索的最后一个高级技巧是创建交互式阴影，使其在特定操作（例如点击或按下）时平滑过渡。这项技术对于模拟物理交互至关重要，它能直观地确认元素的抬升或状态发生了变化。</p>

<pre><code class="kotlin"> Box(Modifier.fillMaxSize()) {
        val interactionSource = remember { MutableInteractionSource() }
        val isPressed by interactionSource.collectIsPressedAsState()

        // Create transition with pressed state
        val transition = updateTransition(
            targetState = isPressed, label = "button_press_transition"
        )

        fun &lt;T&gt; buttonPressAnimation() = tween&lt;T&gt;(
            durationMillis = 400, easing = Ease
        )

        // Animate all properties using the transition
        val shadowAlpha by transition.animateFloat(
            label = "shadow_alpha", transitionSpec = { buttonPressAnimation() }) { pressed -&gt;
            if (pressed) 0f else 1f
        }

        //to animate the color
        val colorDropShadow by transition.animateColor(
            label = "shadow_color", transitionSpec = { buttonPressAnimation() }) { pressed -&gt;
            if (pressed) Color.Transparent else Color.Green.copy(alpha = (0.5f))
        }
        val innerShadowAlpha by transition.animateFloat(
            label = "inner_shadow_alpha", transitionSpec = { buttonPressAnimation() }) { pressed -&gt;
            if (!pressed) 0f else 1f
        }

        Box(
            Modifier
                .clickable(
                    interactionSource, indication = null
                ) {
                    //...
                }
                .width(300.dp)
                .height(200.dp)
                .align(Alignment.Center)
                .dropShadow(
                    shape = RoundedCornerShape(70.dp), shadow = Shadow(
                        radius = 10.dp,
                        spread = 0.dp,
                        color = Color.Green.copy(alpha = (0.5f)),
                        offset = DpOffset(x = 0.dp, 0.dp),
                        alpha = shadowAlpha
                    )
                )
                // note that the background needs to be defined before defining the inner shadow
                .background(
                    color = Color(0xFFFFFFFF), shape = RoundedCornerShape(70.dp)
                )
                .innerShadow(
                    shape = RoundedCornerShape(70.dp), shadow = Shadow(
                        radius = 8.dp,
                        spread = 4.dp,
                        color = Color.Green.copy(alpha = (0.5f)),
                        alpha = innerShadowAlpha,
                        offset = DpOffset(x = 0.dp, 0.dp)
                    )
                )
        ) {
            //...
        }
    }
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*idzAQ4lII7JweFZdCyfNqg.gif" alt="" /></p>

<p>好的，我们已经了解了如何使用 <strong>updateTransition</strong> API 来创建流畅的交互反馈。它首先使用 <strong>MutableInteractionSource</strong> 跟踪按下状态。该状态会驱动一个 <strong>400 毫秒的过渡动画</strong>，同时为两个方向相反的阴影添加动画效果。外部的 <strong>dropShadow</strong> 在按下时会淡出，而内部的 <strong>innerShadow</strong> 则会淡入。这种双阴影动画使组件从 <strong>抬升</strong> 状态平滑过渡到 <strong>凹陷</strong> 状态，从而在用户交互时提供清晰且动态的反馈。</p>

<h2>结论</h2>

<p>Compose 全新的阴影 API 标志着对传统 <strong>elevation</strong> 属性局限性的重大突破。它将核心概念拆分为 <strong>dropShadow()</strong> 和 <strong>innerShadow()</strong>，并赋予我们对 <strong>Shadow</strong> 对象属性的完全控制权。</p>

<p>无论你是打造简单的渐变效果、模拟物理深度，还是实现新粗野主义的高对比度视觉冲击，这种全新的自定义程度都意味着你的 <strong>UI 终于可以充分展现你设计的艺术愿景</strong>。</p>

<p>不妨尝试这些修饰符，为你的 Jetpack Compose 应用注入全新的创意维度！</p>

<p>如果你觉得这篇文章有趣，欢迎关注我，获取更多关于 Android 开发和 Jetpack Compose 的精彩内容。我会定期发布相关主题的文章。欢迎随时分享你的评论，或通过 <a href="https://bsky.app/profile/stefanoq21.bsky.social"><strong>Bluesky</strong></a> 或 <a href="http://www.linkedin.com/in/stefano-natali-q21"><strong>LinkedIn</strong></a> 与我联系，进行更深入的讨论。</p>

<p>祝你开心，编程快乐！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Jetpack Compose中创建CRT屏幕效果]]></title>
    <link href="https://alexhilton.github.io/blog/2025/11/12/crt-effects/"/>
    <updated>2025-11-12T13:42:48+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/11/12/crt-effects</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Creating a CRT Screen Effect in Jetpack Compose」，原文链接<a href="https://www.sinasamaki.com/creating-a-crt-screen-effect-in-jetpack-compose/">https://www.sinasamaki.com/creating-a-crt-screen-effect-in-jetpack-compose/</a>，由sinasamaki发布于2025年11月7日。</p></blockquote>

<p><a href=""><img src="https://www.sinasamaki.com/content/images/size/w2000/2025/11/CRT.png" title="auto auto" ></a></p>

<!-- more -->


<p>CRT 显示器具有独特而怀旧的外观：模糊的边缘、扫描线和轻微的色彩溢出。让我们尝试使用 <code>GraphicsLayer</code> 和一些巧妙的图层技巧在 Jetpack Compose 中重现这种效果。</p>

<h2>GraphicsLayer</h2>

<p>与上一篇文章一样，此效果的基础是 <code>GraphicsLayer</code>。它允许我们将内容绘制一次到屏幕外缓冲区。然后，我们可以以极低的性能开销多次使用不同的效果重新绘制它。</p>

<pre><code class="kotlin">val graphicsLayer = rememberGraphicsLayer()

Box(Modifier.drawWithContent {
    graphicsLayer.record { 
        this@drawWithContent.drawContent() 
    }
}) {
    content()
}
</code></pre>

<p>一旦我们将内容记录到 <code>graphicsLayer</code> 中，就可以使用 <code>drawLayer(graphicsLayer)</code> 根据需要多次绘制它。</p>

<p>我喜欢在黑色背景上绘制色彩鲜艳、饱和度高的内容，并运用这种效果。以下是我们将应用此效果的基础可组合对象。</p>

<p><img src="https://www.sinasamaki.com/content/images/2025/11/Screenshot-2025-11-07-at-09.39.28.png" alt="" /></p>

<h2>添加扫描线</h2>

<p>为了模拟 CRT 显示器上的水平扫描线，我们将使用重复渐变。让我们将其放入一个扩展函数中，如下所示：</p>

<pre><code class="kotlin">private fun DrawScope.drawScanLines(alpha: Float, blendMode: BlendMode) {
    val color = Colors.Black.copy(alpha = alpha)
    drawRect(
        brush = Brush.verticalGradient(
            0f to color,
            0.4f to color,
            0.4f to Colors.Transparent,
            1f to Colors.Transparent,
            tileMode = TileMode.Repeated,
            startY = 0f,
            endY = 10f,
        ),
        blendMode = blendMode
    )
    drawRect(
        brush = Brush.horizontalGradient(
            0f to color,
            0.1f to color,
            0.1f to Colors.Transparent,
            1f to Colors.Transparent,
            tileMode = TileMode.Repeated,
            startX = 0f,
            endX = 10f,
        ),
        blendMode = blendMode
    )
}
</code></pre>

<p>我们手动定义颜色停止点，以便在颜色之间形成清晰的边缘，然后将 <code>tileMode</code> 设置为 <code>Repeated</code>。这样，再加上较短的起点和终点，就能得到许多重复的平行线。</p>

<p>扩展函数还会接收我们所需的透明度和 <code>BlendMode</code> 参数。</p>

<p>然后，我们可以使用此函数在 <code>graphicsLayer</code> 上绘制扫描线。</p>

<pre><code class="kotlin">.drawBehind {
    layer {
        drawLayer(graphicsLayer)
        drawScanLines(alpha = 1f, blendMode = BlendMode.DstOut)
    }
}
</code></pre>

<p>将混合模式设置为 <code>DstOut</code> 会从绘制的内容中“减去”我们的渐变，从而产生这种效果。</p>

<p><img src="https://www.sinasamaki.com/content/images/2025/11/Screenshot-2025-11-07-at-09.39.55.png" alt="" /></p>

<h2>构建模糊图层</h2>

<p>为了实现 CRT 屏幕常见的发光效果，我们将多次绘制 <code>graphicsLayer</code> 图层，每次绘制时分别设置不同的模糊半径、透明度和缩放比例。</p>

<pre><code class="kotlin">val blurLayers = remember {
    listOf(
        Triple(1.dp, 0.2f, 1.02f to 1.03f),
        Triple(0.dp, .2f, 1f to 1f),
        Triple(1.dp, 0.9f, 1f to 1f),
        Triple(10.dp, 1f, 1f to 1f),
        Triple(40.dp, 1f, 1f to 1f),
    )
}
</code></pre>

<p>我们将使用一个 <code>Triple</code> 列表来存储每个图层的数据。该列表的顺序也定义了它们的绘制顺序。我建议你尝试调整这些值和顺序，以获得所需的效果。但这是我目前使用的方法。</p>

<pre><code class="kotlin">blurLayers.forEach { (blur, alpha, scale) -&gt;  
    Box(  
        Modifier  
            .matchParentSize()  
            .blur(blur, BlurredEdgeTreatment.Unbounded)  
            .graphicsLayer {  
                scaleX = scale.first  
                scaleY = scale.second  
                this.alpha = alpha  
            }  
            .drawBehind {  
                layer {  
                    drawLayer(graphicsLayer)  
                    drawScanLines(alpha = 1f, blendMode = BlendMode.DstOut)  
                }  
            }    
    )  
}
</code></pre>

<p>然后，我们使用列表中的值绘制每个图层。在 <code>drawBehind</code> 修改器上方，我们将图层大小设置为与父图层匹配，并应用模糊、缩放和透明度。请记住将模糊设置为 <code>Unbounded</code>，使其超出包含它的可组合对象的边界。</p>

<p><img src="https://www.sinasamaki.com/content/images/2025/11/Screenshot-2025-11-07-at-08.33.20.png" alt="" /></p>

<h2>屏幕抖动</h2>

<p>最后，我们来添加屏幕抖动效果，以模拟 CRT 显示器特有的抖动。我们可以通过创建一个 <code>Offset</code> 对象，并用 -1 到 1 之间的随机浮点值来更新它。</p>

<pre><code class="kotlin">var shake by remember { mutableStateOf(Offset.Zero) }

LaunchedEffect(Unit) {
    while (true) {
        shake = Offset(
            Random.nextInt(-1, 1) * Random.nextFloat(),
            Random.nextInt(-1, 1) * Random.nextFloat(),
        )
        delay(32)
    }
}
</code></pre>

<p>这里只需在一个 while 循环中即可完成。可以调整延迟时间来控制闪烁的间隔频率。</p>

<pre><code class="kotlin">modifier = modifier  
    .graphicsLayer {  
        translationX = shake.x  
        translationY = shake.y  
    }
</code></pre>

<p>然后可以使用修饰符来应用此偏移量。</p>

<p><img src="file:///Users/alexhilton/Downloads/crt_opt.gif" alt="" /></p>

<h2>整合所有功能</h2>

<p>让我们将所有这些功能组合成一个可轻松使用的组合。它会接收 <code>content</code> 参数以及 <code>flickerDelay</code> 参数，后者用于控制闪烁频率。</p>

<pre><code class="kotlin">@Composable  
fun CRTBox(  
    modifier: Modifier = Modifier,  
    flickerDelay: Int = 32,  
    content: @Composable () -&gt; Unit,  
) {  
    var shake by remember { mutableStateOf(Offset.Zero) }  

    LaunchedEffect(Unit) {  
        while (flickerDelay &gt; 0) {  
            shake = Offset(  
                Random.nextInt(-1, 1) * Random.nextFloat(),  
                Random.nextInt(-1, 1) * Random.nextFloat(),  
            )  
            delay(flickerDelay.toLong())  
        }  
    }  

    val graphicsLayer = rememberGraphicsLayer()  

    Box(  
        modifier = modifier  
            .graphicsLayer {  
                translationX = shake.x  
                translationY = shake.y  
            }  
    ) {  
        Box(Modifier.drawWithContent {  
            graphicsLayer.record { this@drawWithContent.drawContent() }  
        }) {  
            content()  
        }  

        val blurLayers = remember {  
            listOf(  
                Triple(5.dp, .3f, 1.02f to 1.03f),  
                Triple(0.dp, .8f, 1f to 1f),  
                Triple(1.dp, .9f, 1f to 1f),  
                Triple(10.dp, .6f, 1.001f to 1f),  
                Triple(40.dp, .7f, 1f to 1f),  
            )  
        }  

        blurLayers.forEach { (blur, alpha, scale) -&gt;  
            Box(  
                Modifier  
                    .matchParentSize()  
                    .blur(blur, BlurredEdgeTreatment.Unbounded)  
                    .graphicsLayer {  
                        scaleX = scale.first  
                        scaleY = scale.second  
                        this.alpha = alpha  
                    }  
                    .drawBehind {  
                        layer {  
                            drawLayer(graphicsLayer)  
                            drawScanLines(alpha = 1f, blendMode = BlendMode.DstOut)  
                        }  
                    }            
            )  
        }  
    }}  

private fun DrawScope.layer(  
    bounds: Rect = size.toRect(),  
    block: DrawScope.() -&gt; Unit  
) =  
    drawIntoCanvas { canvas -&gt;  
        canvas.withSaveLayer(  
            bounds = bounds,  
            paint = Paint(),  
        ) { block() }  
    }  

private fun DrawScope.drawScanLines(alpha: Float, blendMode: BlendMode) {  
    val color = Colors.Black.copy(alpha = alpha)  
    drawRect(  
        brush = Brush.verticalGradient(  
            0f to color,  
            0.4f to color,  
            0.4f to Colors.Transparent,  
            1f to Colors.Transparent,  
            tileMode = TileMode.Repeated,  
            startY = 0f,  
            endY = 10f,  
        ),  
        blendMode = blendMode  
    )  
    drawRect(  
        brush = Brush.horizontalGradient(  
            0f to color,  
            0.1f to color,  
            0.1f to Colors.Transparent,  
            1f to Colors.Transparent,  
            tileMode = TileMode.Repeated,  
            startX = 0f,  
            endX = 10f,  
        ),  
        blendMode = blendMode  
    )  
}
</code></pre>

<p>然后，你可以像使用其他可组合组件一样使用它：</p>

<pre><code class="kotlin">CRTBox {
    Text("GAME OVER")
}
</code></pre>

<h2>Sweeper 更新</h2>

<p>如果你想查看实际效果，请查看最新的 Sweeper 更新，该更新使用 CRT 效果创建了一个令人毛骨悚然的万圣节主题。</p>

<p><img src="https://www.sinasamaki.com/content/images/2025/11/IMG_9612-Edited-copy.jpeg" alt="" /></p>

<p><a href="https://play.google.com/store/apps/details?id=com.sinasamaki.chroma.sweeper&amp;ref=sinasamaki.com">https://play.google.com/store/apps/details?id=com.sinasamaki.chroma.sweeper</a></p>

<p><a href="https://apps.apple.com/us/app/sweeper-by-sinasamaki/id6752220495?ref=sinasamaki.com">https://apps.apple.com/us/app/sweeper-by-sinasamaki/id6752220495</a></p>

<p>感谢阅读，祝你好运！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compose CameraX现已稳定：给Composer的端到端指南]]></title>
    <link href="https://alexhilton.github.io/blog/2025/11/02/compose-camerax-is-stable/"/>
    <updated>2025-11-02T14:10:34+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/11/02/compose-camerax-is-stable</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Compose-Native CameraX Is Now Stable: End-to-End Guide for Jetpack Compose」，原文链接<a href="https://proandroiddev.com/goodbye-androidview-camerax-goes-full-compose-4d21ca234c4e">https://proandroiddev.com/goodbye-androidview-camerax-goes-full-compose-4d21ca234c4e</a>，由Ioannis Anifantakis发布于20251026。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/1*sizZteIZmrzNr4X1BeXcJg.png" title="auto auto" ></a></p>

<!-- more -->


<h2>简介</h2>

<p>还记得你在 Jetpack Compose 中的第一个相机页面吗？纯粹的声明式乐趣……直到预览。然后是熟悉的 <code>AndroidView(PreviewView)</code> 绕道。它确实有效，但总感觉不对：composables中间有一个 View 形状的空洞（类似于 <code>_iFrame_</code>_ ……），而且点击对焦的数学计算总是让人感觉不太可靠。</p>

<p>在 I/O 25 之后，这种妥协已经结束。</p>

<ul>
<li><strong>不再</strong> 使用 <code>**AndroidView(PreviewView)**</code> 进行相机预览。</li>
<li><strong>新增</strong> <code>**CameraXViewfinder**</code> 可组合项，可在 Compose 中直接渲染 CameraX <code>SurfaceRequest</code>。</li>
<li><strong>修正了内置坐标变换</strong>（点击对焦、叠加层），并建立了更简洁、更具声明性的心智模型。</li>
</ul>


<blockquote><p><strong><em>注意：</em></strong></p>

<p><em>“</em>在 I/O 25 大会上，Compose 支持已发布 <strong>alpha/beta</strong> 版本，稳定版已于 9 月发布——现在是时候了解一下了。”_</p></blockquote>

<h2>配套项目</h2>

<p>你可以在 <a href="https://github.com/ioannisa/CameraX-Composable-Demo/"><strong>GitHub 上的配套项目</strong></a> 找到本文的配套项目，该项目演示了 CameraX 中 Jetpack Compose 的新功能。</p>

<h3>权限用户体验（简要说明）</h3>

<p>本文将重点介绍 Compose + CameraX 的功能。<strong>配套项目</strong> 实现了完整的运行时流程：</p>

<ul>
<li>在预览入口点请求 <code>**CAMERA**</code>。</li>
<li>仅在用户开始录制时（按需麦克风）请求 <code>**RECORD_AUDIO**</code>。</li>
<li>一个小型的 <code>PermissionGate</code> 可组合函数负责处理 Compose 树中的授权/拒绝/重新请求。</li>
<li>为了满足 Lint 对 <code>@RequiresPermission</code> 的要求，调用点还会在调用与麦克风相关的 API 之前执行显式 <code>checkSelfPermission(...)</code>。</li>
</ul>


<p>请参阅代码库，了解具体的 <code>PermissionGate</code> 以及我们如何将其连接到 Capture 页面。</p>

<h2>实际变化是什么？</h2>

<p>CameraX 团队放弃了 <code>androidx.camera:camera-compose</code>，取而代之的是看似简单的 API：<code>**CameraXViewfinder**</code>。但这不仅仅是“将 <code>PreviewView</code> 封装在可组合项中”。这是对 Compose 的彻底重写，也是对相机 Surface 与 Compose 集成方式的根本性重新思考。</p>

<p>以下是架构层面的变化：</p>

<p><strong>Compose 目标优先</strong>
取景器渲染管道现在将 Compose 视为主要平台。Surface 生命周期、旋转处理和缩放都以 Compose 惯用的方式进行。</p>

<p><strong>开箱即用的正确坐标变换</strong>
还记得计算预览中的点击实际映射到相机传感器的位置，并考虑旋转、宽高比裁剪和缩放模式吗？<code>MutableCoordinateTransformer</code> 可以处理这些。点击对焦现在……可以正常工作了。</p>

<p><strong>真正的可组合语义</strong>
想要将预览 <code>clip()</code> 转换为自定义形状？应用 <code>graphicsLayer</code> 变换？使用 <code>AnimatedContent</code> 为其添加动画效果？现在，你可以轻松完成所有这些操作，而无需与渲染器冲突。它与其他可组合组件一样。</p>

<p><strong>CameraX 1.5.x 成熟度</strong>
整个技术栈都得到了完善：适用于 Kotlin 协程的 <code>ProcessCameraProvider.awaitInstance()</code>、全面稳定的构件以及更完善的文档。这并非 Beta 测试……它已准备好投入生产。</p>

<h2>为什么这真的很重要</h2>

<p>如果你一直在构建相机功能，<strong>你就会知道其中的痛点</strong>：</p>

<ul>
<li><strong>心智模型分裂</strong>：“用 Compose 思考 UI，用 View 思考相机，并在两者之间不断转换。”</li>
<li><strong>手势协调的噩梦</strong>：在 Compose 中处理触摸事件，在 View 坐标系中测光对焦，祈祷你的计算准确无误。</li>
<li><strong>Z 轴顺序难题</strong>：“PreviewView” 经常使用在单独图层中渲染的“SurfaceView”。Compose 叠加层无法可靠地位于顶部，因此十字线、参考线和按钮可能会消失在预览层后面。</li>
<li><strong>生命周期之舞</strong>：使用 CameraX 用例绑定将 Compose 重组与 View 生命周期同步</li>
</ul>


<p>所有这些摩擦？都消失了。</p>

<blockquote><p><strong>“现在，你可以像编写其他现代 Android 应用一样编写相机 UI。一个范例。一个心智模型。纯粹的 Compose。”</strong></p></blockquote>

<h2>代码演示</h2>

<p>让我们从最基本的开始——一个可以工作的相机预览（固定状态模式：将<strong>写入器</strong> <code>MutableStateFlow</code> 与<strong>读取器</strong> <code>collectAsState</code> 分离）。</p>

<pre><code class="kotlin">@Composable
fun CameraPreview(modifier: Modifier = Modifier) {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current

    // Writer: MutableStateFlow we can update from CameraX callbacks
    val surfaceRequests = remember { MutableStateFlow&lt;SurfaceRequest?&gt;(null) }

    // Reader: Compose state derived from the flow
    val surfaceRequest by surfaceRequests.collectAsState(initial = null)

    // Bind CameraX use cases once
    LaunchedEffect(Unit) {
        val provider = ProcessCameraProvider.awaitInstance(context)

        val preview = Preview.Builder().build().apply {
            // When CameraX needs a surface, publish it to Compose
            setSurfaceProvider { request -&gt;
                surfaceRequests.value = request
            }
        }

        provider.unbindAll()
        provider.bindToLifecycle(
            lifecycleOwner,
            CameraSelector.DEFAULT_BACK_CAMERA,
            preview
        )
    }

    // The actual Compose viewfinder
    surfaceRequest?.let { request -&gt;
        CameraXViewfinder(
            surfaceRequest = request,
            modifier = modifier.fillMaxSize()
        )
    }
}
</code></pre>

<p>就是这样。没有 <code>AndroidView</code>。没有 <code>PreviewView</code>。只有一个可组合组件，它接收 <code>SurfaceRequest</code> 并进行渲染。</p>

<blockquote><p><strong><em>模式很简洁：“</em></strong>CameraX 发布 Surface 请求，Compose 处理它们。单向。没有回调在各个世界之间来回切换。”</p></blockquote>

<h3>可选：使用镜头切换按钮（FAB）进行预览（前/后）</h3>

<pre><code class="kotlin">@Composable
fun PreviewWithLensSwitch(modifier: Modifier = Modifier) {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current

    val surfaceRequests = remember { MutableStateFlow&lt;SurfaceRequest?&gt;(null) }
    val surfaceRequest by surfaceRequests.collectAsState(initial = null)

    // remember current lens
    var useFront by rememberSaveable { mutableStateOf(false) }
    val selector = if (useFront) CameraSelector.DEFAULT_FRONT_CAMERA else CameraSelector.DEFAULT_BACK_CAMERA

    // bind when camera selector changes (front/back camera)
    LaunchedEffect(selector) {
        val provider = ProcessCameraProvider.awaitInstance(context)
        val preview = Preview.Builder().build().apply {
            setSurfaceProvider { req -&gt; surfaceRequests.value = req }
        }
        provider.unbindAll()
        provider.bindToLifecycle(lifecycleOwner, selector, preview)
    }

    Box(Modifier.fillMaxSize()) {
        surfaceRequest?.let { req -&gt;
            CameraXViewfinder(surfaceRequest = req, modifier = Modifier.fillMaxSize())
        }
        FloatingActionButton(
            onClick = { useFront = !useFront },
            modifier = Modifier.align(Alignment.BottomEnd).padding(16.dp)
        ) { Icon(Icons.Rounded.Cameraswitch, contentDescription = "Switch camera") }
    }
}
</code></pre>

<h2>真正的考验：交互式相机控件</h2>

<p>旧方法的失败之处就在这里。让我们实现点击对焦和捏合缩放……这些功能过去需要对视图坐标系进行一些 hack（同样使用固定的写入/读取模式）：</p>

<pre><code class="kotlin">@Composable
fun InteractiveCameraPreview(

modifier: Modifier = Modifier,

onFocusTap: (success: Boolean) -&gt; Unit = {}) {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current

    var camera by remember { mutableStateOf&lt;Camera?&gt;(null) }

    val surfaceRequests = remember { MutableStateFlow&lt;SurfaceRequest?&gt;(null) }
    val surfaceRequest by surfaceRequests.collectAsState(initial = null)

    // Bind camera once
    LaunchedEffect(Unit) {
        val provider = ProcessCameraProvider.awaitInstance(context)
        val preview = Preview.Builder().build().apply {
            setSurfaceProvider { req -&gt; surfaceRequests.value = req }
        }

        camera = provider.bindToLifecycle(
            lifecycleOwner,
            CameraSelector.DEFAULT_BACK_CAMERA,
            preview
        )
    }

    // Coordinate transformer: Compose UI → Camera surface
    val coordinateTransformer = remember { MutableCoordinateTransformer() }

    surfaceRequest?.let { request -&gt;
        CameraXViewfinder(
            surfaceRequest = request,
            coordinateTransformer = coordinateTransformer,
            modifier = modifier
                .fillMaxSize()
                .pointerInput(camera) {
                    // Tap-to-focus
                    detectTapGestures { offset -&gt;
                        val cam = camera ?: return@detectTapGestures

                        // Transform Compose coordinates to camera surface
                        val surfacePoint = with(coordinateTransformer) {
                            offset.transform()
                        }

                        val meteringFactory = SurfaceOrientedMeteringPointFactory(
                            request.resolution.width.toFloat(),
                            request.resolution.height.toFloat()
                        )

                        val focusPoint = meteringFactory.createPoint(
                            surfacePoint.x,
                            surfacePoint.y
                        )

                        val action = FocusMeteringAction.Builder(
                            focusPoint,
                            FocusMeteringAction.FLAG_AF or FocusMeteringAction.FLAG_AE
                        ).setAutoCancelDuration(3, TimeUnit.SECONDS).build()

                        cam.cameraControl
                            .startFocusAndMetering(action)
                            .addListener(
                                { onFocusTap(true) },
                                ContextCompat.getMainExecutor(context)
                            )
                    }
                }
                .pointerInput(camera) {
                    // Pinch-to-zoom
                    detectTransformGestures { _, _, zoom, _ -&gt;
                        val cam = camera ?: return@detectTransformGestures
                        val zoomState = cam.cameraInfo.zoomState.value ?: return@detectTransformGestures

                        val newRatio = (zoomState.zoomRatio * zoom).coerceIn(
                            zoomState.minZoomRatio,
                            zoomState.maxZoomRatio
                        )

                        cam.cameraControl.setZoomRatio(newRatio)
                    }
                }
        )
    }
}
</code></pre>

<p>看看这个点击对焦的实现。注意你<strong>没有</strong>做的事情：</p>

<ul>
<li>无需手动旋转补偿</li>
<li>无需进行坐标映射的宽高比计算</li>
<li>无需进行视图 → 表面 → 传感器坐标链计算</li>
<li>无需进行“祈祷它在横向模式下能正常工作”的漫长测试</li>
</ul>


<p><code>MutableCoordinateTransformer</code> 可以处理所有这些。你点击 Compose 坐标系，它会转换为相机坐标系，就完成了。</p>

<p>这就是“技术上可行”和“实际易于实现”之间的区别。</p>

<h2>拍摄照片和视频</h2>

<p>添加拍摄功能遵循相同的简洁模式——绑定其他用例，并从 Compose 界面触发它们。</p>

<p>我们还将仅在尝试录制时请求<strong>麦克风</strong>，并使用简单的“PermissionGate”模式（与我们项目在需要时仅请求音频的方法一致）。</p>

<pre><code class="kotlin">@Composable
fun CameraScreen() {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current

    var camera by remember { mutableStateOf&lt;Camera?&gt;(null) }
    var imageCapture by remember { mutableStateOf&lt;ImageCapture?&gt;(null) }
    var videoCapture by remember { mutableStateOf&lt;VideoCapture&lt;Recorder&gt;?&gt;(null) }
    var activeRecording by remember { mutableStateOf&lt;Recording?&gt;(null) }

    val surfaceRequests = remember { MutableStateFlow&lt;SurfaceRequest?&gt;(null) }
    val surfaceRequest by surfaceRequests.collectAsState(initial = null)

    // Bind all use cases
    LaunchedEffect(Unit) {
        val provider = ProcessCameraProvider.awaitInstance(context)

        val preview = Preview.Builder().build().apply {
            setSurfaceProvider { req -&gt; surfaceRequests.value = req }
        }

        imageCapture = ImageCapture.Builder()
            .setCaptureMode(ImageCapture.CAPTURE_MODE_MINIMIZE_LATENCY)
            .build()

            val recorder = Recorder.Builder()
            .setQualitySelector(QualitySelector.from(Quality.FHD))
            .build()
        videoCapture = VideoCapture.withOutput(recorder)

        camera = provider.bindToLifecycle(
            lifecycleOwner,
            CameraSelector.DEFAULT_BACK_CAMERA,
            preview,
            imageCapture!!,
            videoCapture!!
        )
    }

    Box(modifier = Modifier.fillMaxSize()) {
        // Camera preview
        surfaceRequest?.let { request -&gt;
            CameraXViewfinder(
                surfaceRequest = request,
                modifier = Modifier.fillMaxSize()
            )
        }

        // Compose UI controls
        Row(
            modifier = Modifier
                .align(Alignment.BottomCenter)
                .padding(bottom = 32.dp)
        ) {
            // Capture photo button
            IconButton(
                onClick = { capturePhoto(context, imageCapture) }
            ) {
                Icon(Icons.Default.PhotoCamera, "Take Photo")
            }

            Spacer(modifier = Modifier.width(32.dp))

            // Video record toggle (mic requested only when needed)
            PermissionGate(
                permission = Permission.RECORD_AUDIO,
                // Optional: custom UI if permission is not yet granted
                contentNonGranted = { missing, humanReadable, requestPermissions -&gt;
                    // Minimal, inline UX: re-request directly
                    Button(onClick = { requestPermissions(missing) }) {
                        Text("Grant $humanReadable")
                    }
                }
            ) {
                IconButton(
                    onClick = {
                        activeRecording = toggleRecording(
                            context,
                            videoCapture,
                            activeRecording
                        )
                    }
                ) {
                    Icon(
                        if (activeRecording == null) Icons.Default.RadioButtonUnchecked
                        else Icons.Default.Stop,
                        "Record Video"
                    )
                }
            }
        }
    }
}

private fun capturePhoto(context: Context, imageCapture: ImageCapture?) {
    val capture = imageCapture ?: return

    val name = "IMG_${System.currentTimeMillis()}.jpg"
    val contentValues = ContentValues().apply {
        put(MediaStore.Images.Media.DISPLAY_NAME, name)
        put(MediaStore.Images.Media.MIME_TYPE, "image/jpeg")
        // On Android 10+ you could also set RELATIVE_PATH = "DCIM/CameraX"
    }

    val outputOptions = ImageCapture.OutputFileOptions.Builder(
        context.contentResolver,
        MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
        contentValues
    ).build()

    capture.takePicture(
        outputOptions,
        ContextCompat.getMainExecutor(context),
        object : ImageCapture.OnImageSavedCallback {
            override fun onImageSaved(output: ImageCapture.OutputFileResults) {
                // Success: output.savedUri
            }
            override fun onError(exception: ImageCaptureException) {
                // Handle error
            }
        }
    )
}

private fun toggleRecording(
    context: Context,
    videoCapture: VideoCapture&lt;Recorder&gt;?,
    currentRecording: Recording?
): Recording? {
    val capture = videoCapture ?: return null

    // Stop if already recording
    if (currentRecording != null) {
        currentRecording.stop()
        return null
    }

    // Start new recording
    val name = "VID_${System.currentTimeMillis()}.mp4"
    val contentValues = ContentValues().apply {
        put(MediaStore.Video.Media.DISPLAY_NAME, name)
        // On Android 10+ you could also set RELATIVE_PATH = "DCIM/CameraX"
    }

    val outputOptions = MediaStoreOutputOptions.Builder(
        context.contentResolver,
        MediaStore.Video.Media.EXTERNAL_CONTENT_URI
    ).setContentValues(contentValues).build()

    return capture.output
        .prepareRecording(context, outputOptions)
        .withAudioEnabled() // mic permission is ensured by PermissionGate above
        .start(ContextCompat.getMainExecutor(context)) { event -&gt;
            // Handle recording events (e.g., finalize, error)
        }
}
</code></pre>

<p>这是纯粹的 Compose UI 构建。你的相机按钮与预览位于同一个可组合树中。没有桥接逻辑。无需管理单独的 View 层次结构。</p>

<h2>迁移策略：PreviewView → CameraXViewfinder</h2>

<p>如果你现有的相机代码使用“PreviewView”，则迁移路径如下：</p>

<p><strong>迁移前（旧方法）：</strong></p>

<pre><code class="kotlin">@Composable
fun OldCameraPreview() {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current
    val previewView = remember { PreviewView(context) }

    LaunchedEffect(previewView) {
        val provider = ProcessCameraProvider.getInstance(context).get()
        val preview = Preview.Builder().build()
        preview.setSurfaceProvider(previewView.surfaceProvider)
        provider.bindToLifecycle(lifecycleOwner, CameraSelector.DEFAULT_BACK_CAMERA, preview)
    }

    AndroidView(
        factory = { previewView },
        modifier = Modifier.fillMaxSize()
    )
}
</code></pre>

<p><strong>迁移后（Compose 原生方法）：</strong></p>

<pre><code class="kotlin">@Composable
fun NewCameraPreview() {
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current
    val selector = CameraSelector.DEFAULT_BACK_CAMERA

    val surfaceRequests = remember { MutableStateFlow&lt;SurfaceRequest?&gt;(null) }
    val surfaceRequest by surfaceRequests.collectAsState(initial = null)

    LaunchedEffect(Unit) {
        val provider = ProcessCameraProvider.awaitInstance(context)
        val preview = Preview.Builder().build().apply {
            setSurfaceProvider { req -&gt; surfaceRequests.value = req }
        }
        provider.unbindAll()
        provider.bindToLifecycle(lifecycleOwner, selector, preview)
    }

    surfaceRequest?.let {
        CameraXViewfinder(
            surfaceRequest = it,
            modifier = Modifier.fillMaxSize()
        )
    }
}
</code></pre>

<p>关键的思维转变：不再将 View 的“SurfaceProvider”赋予 CameraX，而是将“SurfaceRequest”对象发布到 Compose 状态，并使用“CameraXViewfinder”进行渲染。</p>

<h2>所需依赖项</h2>

<p>添加到你的 <code>build.gradle.kts</code> 中：</p>

<pre><code class="kotlin">val cameraxVersion = "1.5.1"dependencies {
    implementation("androidx.camera:camera-core:$cameraxVersion")
    implementation("androidx.camera:camera-camera2:$cameraxVersion")
    implementation("androidx.camera:camera-lifecycle:$cameraxVersion")
    implementation("androidx.camera:camera-video:$cameraxVersion")

    // The new Compose-native viewfinder
    implementation("androidx.camera:camera-compose:$cameraxVersion")
}
</code></pre>

<p>清单权限：</p>

<pre><code class="xml">&lt;uses-permission android:name="android.permission.CAMERA" /&gt;
&lt;uses-permission android:name="android.permission.RECORD_AUDIO" /&gt;
</code></pre>

<h2><strong>实现模式（性能 vs. 合成）</strong></h2>

<p><code>CameraXViewfinder</code> 可以通过两种方式渲染预览：</p>

<h3><strong>EXTERNAL（SurfaceView 支持）</strong></h3>

<p>相机帧在其<strong>自己的 Surface</strong> 上渲染，由系统在 Compose 绘制通道<strong>之外</strong>合成。可以想象成“UI 背后的实时视频层”。通常启用硬件叠加 → 最佳性能/延迟。非常适合在标准 UI 后方显示全屏矩形预览。由于它是一个单独的层，因此对<em>相机像素</em>的逐像素效果（复杂的裁剪/模糊）不适用。</p>

<ul>
<li>优点：延迟更低，GPU 负载更少，非常适合全屏预览/录制。</li>
<li>缺点：不受逐像素界面特效（圆角蒙版/模糊）的影响，不会显示在 Compose 屏幕截图中。</li>
</ul>


<h3><strong>嵌入式（TextureView 支持）</strong></h3>

<p>相机帧作为<strong>GPU 纹理</strong>绘制在 Compose 渲染通道<strong>内部</strong>——类似于<strong>可重绘面板</strong>，其行为与其他可组合项类似。你可以获得深度裁剪/蒙版/动画/模糊/Z 轴排序，但代价是 GPU 工作量增加，延迟略高。</p>

<ul>
<li>优点：行为类似于普通界面；裁剪、Alpha 通道、模糊、特殊形状和复杂 Z 轴排序均正常。</li>
<li>缺点：GPU 工作量增加 → 在繁重的界面或中端设备上，延迟/卡顿风险略高。</li>
</ul>


<h3><strong>经验法则</strong></h3>

<ul>
<li>全屏/高性能 → <strong>外部</strong></li>
<li>特殊构图/特效 → <strong>嵌入式</strong>。</li>
</ul>


<p>如果你未指定模式，库将选择一个合理的默认模式。强制使用以下方式：</p>

<pre><code class="kotlin">import androidx.camera.viewfinder.core.ImplementationMode

CameraXViewfinder(
    surfaceRequest = request,
    implementationMode = ImplementationMode.EXTERNAL // or ImplementationMode.EMBEDDED
)
</code></pre>

<h2>实际操作中的陷阱</h2>

<p><strong>坐标变换并非可选</strong>
不要将原始 Compose 偏移量传递给测量工厂。务必使用坐标变换器。数学运算看起来很简单，直到你在横屏、可折叠设备或非标准宽高比设备上进行测试。</p>

<p><strong>前置摄像头是镜像的</strong>
如果你正在绘制叠加层或处理拍摄的图像，请记住前置摄像头预览默认是镜像的，但拍摄的图像不是。在你的界面/处理逻辑中考虑到这一点。</p>

<p><strong>在真实设备上测试</strong>
不同 OEM 的相机行为有所不同。在 Pixel 上完美运行的功能在三星或小米上可能存在问题。在代表性硬件上测试你的关键流程。</p>

<p><strong>权限用户体验</strong>
在入口点请求 <code>CAMERA</code>；仅在开始录制时请求 <code>RECORD_AUDIO</code>（这是一种良好做法）。上面的内联 <code>PermissionGate</code> 模式将该逻辑保留在你的 Compose 树中。</p>

<h2>高级功能：可折叠和自适应 UI</h2>

<p>由于 <code>CameraXViewfinder</code> 只是另一个可组合项，因此可折叠支持非常简单。简单的双窗格布局或全屏布局通常就足够了；如果需要，可以使用 <code>AnimatedContent</code> 来在状态之间添加动画。</p>

<pre><code class="kotlin">@Composable
fun AdaptiveCameraScreen(surfaceRequest: SurfaceRequest?) {
    val expanded = remember { mutableStateOf(false) } // pretend this reflects window size/hinge state

    AnimatedContent(targetState = expanded.value, label = "layout") { isExpanded -&gt;
        if (isExpanded) {
            Row(Modifier.fillMaxSize()) {
                surfaceRequest?.let {
                    CameraXViewfinder(
                        surfaceRequest = it,
                        modifier = Modifier
                            .weight(1f)
                            .aspectRatio(9f / 16f)
                    )
                }
                Box(Modifier.weight(1f)) { /* CameraControls(Modifier.align(Alignment.Center)) */ }
            }
        } else {
            Box(Modifier.fillMaxSize()) {
                surfaceRequest?.let {
                    CameraXViewfinder(
                        surfaceRequest = it,
                        modifier = Modifier.fillMaxSize()
                    )
                }
                /* CameraControls(Modifier.align(Alignment.BottomCenter)) */
            }
        }
    }
}
</code></pre>

<h2>测试清单（实用）</h2>

<ul>
<li>验证纵向/横向以及 <code>ContentScale.Crop/Fit</code> 模式下的点击对焦精度。</li>
<li>测试缩放限制；确保捏合和程序化缩放过渡流畅。</li>
<li>切换摄像头（前/后）并重新验证变换 + 镜像行为。</li>
<li>导航离开/后退、旋转和处理配置更改；预览应能够恢复且不闪烁。</li>
<li>在对焦/缩放时录制视频；确保没有表面掉落。</li>
</ul>


<h2>全局展望</h2>

<p>此版本的重要性不仅在于它带来的功能，还在于它所传递的信息。</p>

<p>多年来，Android 中的相机开发一直感觉像是二等公民。除了相机页面之外，你可以在任何地方使用 Compose 构建现代 UI，而相机页面则需要你勉强才能与 View 进行互操作。虽然 Compose 确实有效，但编写代码时总感觉像是被束缚了一只手。</p>

<p><code>camera-compose</code> 不仅仅是一个新产物。CameraX 团队曾说过：“Compose 现在是一流的相机开发平台。”</p>

<p>这意味着：</p>

<ul>
<li>未来的相机功能将在设计时充分考虑 Compose，而不是对其进行改造。</li>
<li>社区将构建以 Compose 为先的相机库和组件。</li>
<li>最佳实践将围绕可组合相机 UI 不断发展。</li>
<li>文档和示例将反映现代 Android 开发。</li>
</ul>


<p>我们在整个 Android 生态系统中都看到了这种模式——最初以 View 为中心的 API 正在逐渐获得 Compose 原生的对应版本。<code>camera-compose</code> 就是迄今为止最具影响力的例子之一。</p>

<h2>你现在应该做什么</h2>

<p><strong>如果你正在开发一个新的相机功能：</strong>
从一开始就使用 <code>CameraXViewfinder</code>。甚至不需要考虑 <code>PreviewView</code>。它的代码更简洁，思维模型更简单，你以后会感谢自己的。</p>

<p><strong>如果你已经有相机代码：</strong>
将 <code>camera-compose</code> 添加到你的依赖项中，并一次迁移一个页面。从最简单的相机 UI（可能是基本的纯预览页面）开始，熟悉新的 API。然后再处理复杂的部分。</p>

<p><strong>如果你正在构建一个库：</strong>
现在是时候将 Compose 原生相机组件添加到你的 SDK 中了。开发者正在寻找可组合的相机解决方案，而生态系统已经为他们做好了准备。</p>

<h2>延伸阅读</h2>

<ul>
<li><a href="https://developer.android.com/jetpack/androidx/releases/camera">CameraX 发行说明</a> — 官方更新日志和工件</li>
<li><a href="https://developer.android.com/jetpack/androidx/releases/camera-viewfinder">Camera Viewfinder 文档</a> — 实现模式、缩放和对齐</li>
<li><a href="https://github.com/androidx/androidx/tree/androidx-main/camera">CameraX GitHub 示例</a> — 真实代码示例</li>
</ul>


<h2>国王已死 / 国王万岁</h2>

<p>“AndroidView”相机预览的时代已经结束。如果你要在 2025 年及以后构建相机功能，那么你将使用 Compose 来构建它们。现在终于有了可以正确支持这些功能的工具。</p>

<p>现在，甩掉那个“AndroidView”包装器，编写一些漂亮的相机 UI 吧。</p>
]]></content>
  </entry>
  
</feed>
