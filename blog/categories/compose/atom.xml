<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Compose | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/compose/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2025-08-17T22:07:16+08:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[用Compose中的Shader实现一个雪花飘飘弹窗效果]]></title>
    <link href="https://alexhilton.github.io/blog/2025/08/17/snow-dialog-shader/"/>
    <updated>2025-08-17T22:02:24+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/08/17/snow-dialog-shader</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Snow Dialog Shader Tutorial」，原文链接<a href="https://medium.com/@off.mind.by/snow-dialog-shader-tutorial-dde1b4a61e20">https://medium.com/@off.mind.by/snow-dialog-shader-tutorial-dde1b4a61e20</a>，由Alex Volkov发布于2024年12月27日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:2000/1*oNN6ZtalbQEvYCpTx8gLWg.png" title="auto auto" ></a></p>

<!-- more -->


<p>大家好！在本教程中，我将向大家展示如何创建雪花覆盖的对话框效果。总的来说，该效果可以分为三个部分。</p>

<ol>
<li><strong>设置 Compose 代码</strong>：这确保了基础效果的实现。</li>
<li><strong>创建对话框底部积雪的着色器</strong>：这是我在今天教程中重点讲解的核心效果。</li>
<li><strong>添加飘落的雪花</strong>：为此，我在 ShaderToy 上找到了一个现成的着色器，并对其进行了一些优化，使其不会对手机性能造成太大负担。第三部分将包含原始着色器的链接以及一些优化说明。</li>
</ol>


<p>本教程主要讲解如何为对话框创建不断增长的雪盖效果。</p>

<p>最终效果如下：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:804/1*SRa57BglcDzpLzAAw1UAPw.gif" alt="最终效果" /></p>

<blockquote><p>在深入探讨之前，我想提醒你，我并没有为所有效果创建教程。不过，所有效果都可以在我的 <a href="https://github.com/AleksiejVolkov/runtimeshaders">GitHub</a> （链接：<a href="https://github.com/AleksiejVolkov/runtimeshaders%EF%BC%89%E4%B8%8A%E6%89%BE%E5%88%B0%E3%80%82%E4%BD%A0%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%88%91%E7%9A%84">https://github.com/AleksiejVolkov/runtimeshaders%EF%BC%89%E4%B8%8A%E6%89%BE%E5%88%B0%E3%80%82%E4%BD%A0%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%88%91%E7%9A%84</a> <a href="https://t.me/droidshaderworks">Telegram 频道</a> （链接：<a href="https://t.me/droidshaderworks%EF%BC%89%E4%B8%AD%E6%89%BE%E5%88%B0%E8%A7%86%E9%A2%91%E3%80%81%E6%96%B0%E6%95%88%E6%9E%9C%E5%85%AC%E5%91%8A%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E7%AD%94%E3%80%82%E6%9C%9F%E5%BE%85%E5%9C%A8%E9%82%A3%E9%87%8C%E8%A7%81%E5%88%B0%E4%BD%A0%EF%BC%81">https://t.me/droidshaderworks%EF%BC%89%E4%B8%AD%E6%89%BE%E5%88%B0%E8%A7%86%E9%A2%91%E3%80%81%E6%96%B0%E6%95%88%E6%9E%9C%E5%85%AC%E5%91%8A%E4%BB%A5%E5%8F%8A%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E7%AD%94%E3%80%82%E6%9C%9F%E5%BE%85%E5%9C%A8%E9%82%A3%E9%87%8C%E8%A7%81%E5%88%B0%E4%BD%A0%EF%BC%81</a></p></blockquote>

<p>让我们从 Compose 中为效果设置一个最小页面开始。它包含一张背景图片和一个位于中心的按钮，用于触发对话框。</p>

<p>需要注意的是，对话框不应来自 Material 库，而应使用 Compose 中最基本的“AlertDialog”。</p>

<p>以下是最低配置：</p>

<pre><code class="Kotlin">@Composable
fun SnowDialogScreen() {
    var showDialog by remember { mutableStateOf(false) }  

    Box(
        modifier = Modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Image(
            painter = painterResource(id = R.drawable.christmas_night),
            contentDescription = "Sample Image",
            contentScale = ContentScale.Crop,
            modifier = Modifier.fillMaxSize()
        )        if (!showDialog) {
            Button(onClick = { showDialog = true }) {
                Text("Ho-ho-ho!")
            }
        } else {
            SnowedDialog { showDialog = false }
        }
    }
}

@Composable
private fun SnowedDialog(onDismiss: () -&gt; Unit) {
    BasicAlertDialog(
        onDismissRequest = { onDismiss() },
        properties = DialogProperties(usePlatformDefaultWidth = false)
    ) {
        Column(
            Modifier
                .padding(horizontal = 16.dp)
                .background(shape = MaterialTheme.shapes.large, 
                            color = MaterialTheme.colorScheme.surface)
                .padding(16.dp),
        ) {
            Text("Merry Christmas!", style = MaterialTheme.typography.titleLarge)
            Spacer(modifier = Modifier.height(10.dp))
            Text("Happy New Year!")
            Spacer(modifier = Modifier.height(26.dp))
            Row(
                modifier = Modifier
                    .fillMaxWidth(),
                horizontalArrangement = Arrangement.End
            ) {
                Text(
                    modifier = Modifier
                        .clickable { onDismiss() }
                        .padding(5.dp),
                    text = "Close",
                    style = MaterialTheme.typography.bodyMedium.copy(color = MaterialTheme.colorScheme.primary)
                )
            }
        }
    }
}
</code></pre>

<p>最终，你应该得到类似这样的效果：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*fnlF56ZxRxMwa7vHkCOudA.png" alt="颜色可能会有所不同，此外观已针对暗黑模式进行了调整" /></p>

<p>现在我们可以开始编写着色器了！我将简要介绍如何设置着色器并将其附加到对话框中。有关运行时着色器的更详细介绍和初学者指南，你可以查看我的另一个<a href="https://juejin.cn/post/7535292253813981247">教程</a>。</p>

<p>开始使用着色器所需的最低要求如下所示。在对话框中，我们添加一个 <code>runtimeShader</code>，并使用 <code>graphicsLayer</code> 将其分配给 <code>Column</code>：</p>

<pre><code class="kotlin">@Composable
private fun SnowedDialog(onDismiss: () -&gt; Unit) {
    // 从字符串编译我们的着色器
    val snowCapShader = remember { RuntimeShader(snowCapShader) }  

    BasicAlertDialog(
        onDismissRequest = { onDismiss() },
        properties = DialogProperties(usePlatformDefaultWidth = false)
    ) {
        Column(
            Modifier
                .padding(horizontal = 16.dp)
                .background(shape = MaterialTheme.shapes.large, color = MaterialTheme.colorScheme.surface)
                .onSizeChanged { size -&gt;
                    // pass resolution
                    snowCapShader.setFloatUniform(
                        "resolution",
                        size.width.toFloat(),
                        size.height.toFloat()
                    )
                }
                .graphicsLayer {
                    // apply shader 
                    this.renderEffect = RenderEffect
                        .createRuntimeShaderEffect(snowCapShader, "image")
                        .asComposeRenderEffect()
                }
                .padding(16.dp),
        ) {
          // 其余代码保持不变

//...

@Language("agsl")
private val snowCapShader = """
    uniform shader image;
    uniform vec2 resolution;    
    vec4 main(float2 fragCoord) {
         float2 uv = fragCoord / resolution - 0.5;
         if(abs(uv.x)&gt;0.5 || abs(uv.y)&gt;0.5) {
             return vec4(0.0);
         }          
         float ratio = resolution.x / resolution.y;    
         uv.x *= ratio;        
         vec4 imageColor = image.eval(fragCoord);        
         return vec4(vec3(1.0), imageColor.a);
    }
""".trimIndent()
</code></pre>

<p>目前，它将显示为一个空白矩形，就像我们的对话框一样：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*C5O1IMHS7MvK0lFnIqHFYA.png" alt="" /></p>

<p>在继续之前，让我先尽可能简单地解释一下实现此效果背后的逻辑。我将算法分为四个概念步骤：</p>

<ol>
<li><strong>找到一个函数</strong>来定义雪边缘的轮廓。</li>
<li><strong>在 y 轴上</strong>绘制此函数上方的所有内容**，并将其垂直移向底部边缘。</li>
<li><strong>定义一个遮罩区域</strong>，这意味着在此区域之外，函数将被完全忽略，我们只需绘制着色器从系统接收的内容即可。</li>
<li><strong>修改侧面和顶部的遮罩</strong>，使雪的形状更自然，而底部边缘的轮廓则由我们的函数处理。</li>
</ol>


<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*Vbq5YEL42g1tQsLjWKAokQ.png" alt="" /></p>

<p>现在，让我们在着色器中按顺序实现这些步骤。为简单起见，我选择了一个基本的正弦波作为雪边缘的函数。我添加了一些系数来压缩它并降低其振幅：</p>

<pre><code class="glsl">float snowEdge = (sin(10.*uv.x)*0.5+0.5)*0.2;
</code></pre>

<p>接下来，我们需要用白色填充此线上方的所有内容，同时忽略其下方的所有内容。</p>

<pre><code class="glsl">vec4 snow = step(uv.y, snowEdge)*vec4(1.0);
</code></pre>

<blockquote><p>通过向 <code>uv.y</code> 添加一个常量，我们可以垂直移动整个函数。</p></blockquote>

<p>最后，我们需要将该方法移近对话框的底部边缘并添加一个遮罩。现在，我们使用一个简单的矩形区域作为遮罩。我们可以通过分别指定每个边缘来定义它。这种方法可能看起来有点冗长，但它使代码更容易理解：</p>

<pre><code class="glsl"> vec4 main(float2 fragCoord) {
         float2 uv = fragCoord / resolution - 0.5;        
         float ratio = resolution.x / resolution.y;    
         uv.x *= ratio;         

         float snowEdge = (sin(10.*uv.x)*0.5+0.5)*0.2;
         snowEdge = step(uv.y-0.4, snowEdge);       

         float topBound = 0.3;
         float leftBound = -.5*ratio;
         float rightBound = .5*ratio;        

         float snowMask = 0.;       
         if(uv.x &gt; leftBound &amp;&amp; uv.x &lt; rightBound &amp;&amp; uv.y &gt; topBound) {
            snowMask = 1.0;
         }
         snowMask *= snowEdge;        
         vec4 imageColor = image.eval(fragCoord);
         vec3 snowColor = vec3(1.0);       
         vec3 finalColor = mix(imageColor.rgb, snowColor, snowMask);      

         return vec4(finalColor, snowMask+imageColor.a);
    }
</code></pre>

<p>调整后，我们应该得到类似这样的结果。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*GM2d-tsCUOAHnloMiDYAAA.png" alt="" /></p>

<p>现在可能不是提及这一点的最佳时机，也许应该早点提及，但在这里强调这一点至关重要。请记住，我们对坐标进行了归一化，并对其进行了平移，使零点恰好位于画布（即对话框）的中心。具体操作如下：<code>_float2 uv = fragCoord/resolution — 0.5;_</code></p>

<p>理解这一点很重要，因为现在我想减小中心正弦波的振幅，并随着我们向左右两侧远离中心而增大振幅。理解坐标系的设置方式后，我们可以通过将函数乘以沿 x 轴距离中心的距离来实现这一点。这样，函数将在中心处恰好返回零点，并随着向外移动而增大。最终，我们将实现以下效果：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*oW8OP3R2VFo0SkJmDhgVSw.png" alt="" /></p>

<p>现在，让我们使用函数而不是常量来定义遮罩的顶部边界。现在，让我们使用另一个正弦波，但间隔等于对话框的宽度。</p>

<pre><code class="glsl">float topBound = (sin(ratio*uv.x*0.8+2.)*0.5+0.5)*.2+0.3;
</code></pre>

<p>我们将为左右边界添加类似的代码：我希望它们也使用正弦波，但这次是垂直运行的。</p>

<pre><code class="glsl">float leftBound = -.5*ratio+(sin(10.*uv.y)*0.5+0.5)*0.5*length(uv.y-topBound);
float rightBound = .5*ratio-(sin(10.*uv.y)*0.5+0.5)*0.4*length(uv.y-topBound);
</code></pre>

<p>最后，我们需要为底部边缘添加一个常量：这是一个时间变量，我们会将它从 Compose 传递给着色器。在着色器中，我们只需添加相应的 <code>uniform</code> 变量，并将底部边缘函数乘以它即可：</p>

<pre><code class="glsl">uniform shader image;
    uniform vec2 resolution;
    uniform float time;        vec4 main(float2 fragCoord) {
         float2 uv = fragCoord / resolution - 0.5;        

         float ratio = resolution.x / resolution.y;    
         uv.x *= ratio;         

         float adjustedTime = clamp(time * 0.3,0.0,1.0);
         float snowEdge = (sin(10.*uv.x)*0.5+0.5)*0.2 * length(uv.x)*adjustedTime;
         snowEdge = step(uv.y-0.5, snowEdge);       

         float topBound = (sin(ratio*uv.x*0.8+2.)*0.5+0.5)*.2+0.3;
         float leftBound = -.5*ratio+(sin(10.*uv.y)*0.5+0.5)*0.5*length(uv.y-topBound);
         float rightBound = .5*ratio-(sin(10.*uv.y)*0.5+0.5)*0.4*length(uv.y-topBound);                   

         float snowMask = 0.;         
         if(uv.x &gt; leftBound &amp;&amp; uv.x &lt; rightBound &amp;&amp; uv.y &gt; topBound) {
            snowMask = 1.0;
         }

         snowMask *= snowEdge;         

         vec4 imageColor = image.eval(fragCoord);
         vec3 snowColor = vec3(1.0);        
         vec3 finalColor = mix(imageColor.rgb, snowColor, snowMask);       

         return vec4(finalColor, snowMask+imageColor.a);
    }
</code></pre>

<p>别忘了从composable中提供时间：</p>

<pre><code class="Kotlin">@Composable
private fun SnowedDialog(onDismiss: () -&gt; Unit) {
    val snowCapShader = remember { RuntimeShader(snowCapShader) }
    var time by remember { mutableStateOf(0f) }

    LaunchedEffect(null)  {
        while (true) {
            delay(10)
            time += 0.01f
        }
    }

    BasicAlertDialog(
        onDismissRequest = { onDismiss() },
        properties = DialogProperties(usePlatformDefaultWidth = false)
    ) {
        Column(
            Modifier
                .padding(horizontal = 16.dp)
                .background(shape = MaterialTheme.shapes.large, color = MaterialTheme.colorScheme.surface)
                .onSizeChanged { size -&gt;
                    snowCapShader.setFloatUniform(
                        "resolution",
                        size.width.toFloat(),
                        size.height.toFloat()
                    )
                }
                .graphicsLayer {
                    // 这里提供时间：
                    snowCapShader.setFloatUniform("time", time)
                    this.renderEffect = RenderEffect
                        .createRuntimeShaderEffect(snowCapShader, "image")
                        .asComposeRenderEffect()
                }
                .padding(16.dp),
        ) {
// 其余代码保持不变
</code></pre>

<p>我们得到如下效果：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*5YYiM3lZYp42O8Fa9iS-4A.gif" alt="" /></p>

<p>关于这个效果，我想分享的差不多就是这些了！这是核心思想，从这里开始，你可以尝试不同的设置。例如，我用一个基于 Perlin 噪声的更混乱的版本替换了基本的正弦波。</p>

<p>但这些只是细节，在实现上可以有无限的变化。创建着色器的关键在于掌握其背后的核心思想。</p>

<p>你可以在我的代码库中找到我的实现，其中还包含各种用于不同增强功能的辅助方法。例如，这里有一系列过渡效果（线性、三次、指数等）。</p>

<p>添加雪花是最后一步，但创建雪、雨、星星等效果的方法值得另开一个教程。下次我一定会讲解。今天，我只想提一下，为了实现这个特定的效果，我使用了 <strong>Andrew Baldwin</strong> 于 2013 年在 ShaderToy 上创建的着色器。链接如下：<a href="https://www.shadertoy.com/view/ldsGDn">https://www.shadertoy.com/view/ldsGDn</a></p>

<p>由于原始着色器对于手机来说过于庞大，我做了一些简化。此外，它还需要一些适配 AGSL 的功能。这是我的版本：</p>

<pre><code class="glsl">  uniform shader image;
   uniform vec2 resolution;
   uniform float time;

   uniform int uLayers;
   uniform float uDepth;
   uniform float uSpeed;

   const int MAX_LAYERS = 50;
   const float WIDTH = 0.4;

   vec2 NormalizeCoordinates(vec2 o, vec2 r) {
        float2 uv = o / r - 0.5;
        if (r.x &gt; r.y) {
            uv.x *= r.x / r.y;
        } else {
            uv.y *= r.y / r.x;
        } 
        return uv;
    }

    vec4 GetImageTexture(vec2 p, vec2 pivot, vec2 r) {
        if (r.x &gt; r.y) {
            p.x /= r.x / r.y;
        } else {
            p.y /= r.y / r.x;
        }
        p += pivot;
        p *= r;
        return image.eval(p);
    }

    vec4 main(float2 fragCoord) {
       float2 uv = NormalizeCoordinates(fragCoord, resolution);  
       vec4 image = GetImageTexture(uv, vec2(0.5, 0.5), resolution);
       const mat3 p = mat3(13.323122, 23.5112, 21.71123, 21.1212, 28.7312, 11.9312, 21.8112, 14.7212, 61.3934);

       float ratio = resolution.y / resolution.x;
       vec3 acc = vec3(0.0);
       float alpha = 0.0; // 初始化 alpha
       float dof = 5.0 * sin(time * 0.1);
       for (int i = 0; i &lt; MAX_LAYERS; i++) {
           if (i &gt;= uLayers) break; // 如果 i 超出 uLayers，则跳出循环

           float fi = float(i);
           vec2 q = uv * (1.0 + fi * uDepth);

           // 通过调制和时间调整雪花位置
           q -= vec2(q.y * (WIDTH * mod(fi * 7.238917, 1.0) - WIDTH * 0.5), uSpeed * time / (1.0 + fi * uDepth * 0.03));                      vec3 n = vec3(floor(q), 31.189 + fi);
           vec3 m = floor(n) * 0.00001 + fract(n);
           vec3 mp = (31415.9 + m) / fract(p * m);
           vec3 r = fract(mp);

           // 使用圆形mask的圆形雪花形状
           float2 center = mod(q, 1.0) - 0.5 + 0.5 * r.xy;
           float distanceToCenter = length(center); // 圆周距离
           float flakeRadius = 0.015 + 0.01 * r.z; // 每个薄片的半径略有不同

           // 通过扩展的平滑步进实现更平滑的边缘
           float intensity = smoothstep(flakeRadius + 0.015, flakeRadius, distanceToCenter) * 
                               smoothstep(flakeRadius, flakeRadius - 0.015, distanceToCenter);

           // Ensure flakes are white or transparent (prevent black color)
           vec3 flakeColor = vec3(1.0); // 雪花要是白色
           acc += flakeColor * intensity;

           // 通过平滑过渡积累 alpha
           alpha += intensity;
       }

       // 归一化 alpha 以确保其不超过 1.0
       alpha = clamp(alpha, 0.0, 1.0);
       vec3 finalColor = mix(image.rgb, acc, alpha);

      if(uv.y &lt; -0.5*ratio || uv.y &gt; .5*ratio) {
           finalColor = vec3(0.0);
           alpha = 0.0;
       }
       return vec4(finalColor, alpha+image.a);
   }
</code></pre>

<p>当然，为了让一些雪花出现在屏幕前方，而另一些雪花飘到屏幕后方，我必须在这个着色器中使用两层。这是对话框可组合函数的最终效果：</p>

<pre><code class="Kotlin">@Composable
private fun SnowedDialog(onDismiss: () -&gt; Unit) {
    val snowCapShader = remember { RuntimeShader(snowCapShader) }
    val flakesShaderForeground = remember { RuntimeShader(snowShader) }
    val flakesShaderBackground = remember { RuntimeShader(snowShader) }

    var time by remember { mutableStateOf(0f) }

    LaunchedEffect(null)  {
        while (true) {
            delay(10)
            time += 0.01f
        }
    }

    flakesShaderForeground.setIntUniform("uLayers", 5)
    flakesShaderForeground.setFloatUniform("uDepth", 0.15f)
    flakesShaderForeground.setFloatUniform("uSpeed", 1.0f)

    flakesShaderBackground.setIntUniform("uLayers", 10)
    flakesShaderBackground.setFloatUniform("uDepth", 1.5f)
    flakesShaderBackground.setFloatUniform("uSpeed", 0.8f)

    BasicAlertDialog(
        onDismissRequest = { onDismiss() },
        properties = DialogProperties(usePlatformDefaultWidth = false)
    ) {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .onSizeChanged { size -&gt;
                    flakesShaderForeground.setFloatUniform(
                        "resolution",
                        size.width.toFloat(),
                        size.height.toFloat()
                    )
                }
                .graphicsLayer {
                    flakesShaderForeground.setFloatUniform("time", time)
                    this.renderEffect = RenderEffect
                        .createRuntimeShaderEffect(flakesShaderForeground, "image")
                        .asComposeRenderEffect()
                }
                .padding(16.dp),
            contentAlignment = Alignment.Center
        ) {
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .onSizeChanged { size -&gt;
                        flakesShaderBackground.setFloatUniform(
                            "resolution",
                            size.width.toFloat(),
                            size.height.toFloat()
                        )
                    }
                    .graphicsLayer {
                        flakesShaderBackground.setFloatUniform("time", time)
                        this.renderEffect = RenderEffect
                            .createRuntimeShaderEffect(flakesShaderBackground, "image")
                            .asComposeRenderEffect()
                    }
            ) {
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .background(color = Color.Black.copy(0.1f))
                )
            }
            Column(
                Modifier
                    .padding(horizontal = 16.dp)
                    .background(shape = MaterialTheme.shapes.large, color = MaterialTheme.colorScheme.surface)
                    .onSizeChanged { size -&gt;
                        snowCapShader.setFloatUniform(
                            "resolution",
                            size.width.toFloat(),
                            size.height.toFloat()
                        )
                    }
                    .graphicsLayer {
                        snowCapShader.setFloatUniform("time", time)
                        this.renderEffect = RenderEffect
                            .createRuntimeShaderEffect(snowCapShader, "image")
                            .asComposeRenderEffect()
                    }
                    .padding(16.dp),
            ) {
                Text("Merry Christmas!", style = MaterialTheme.typography.titleLarge)
                Spacer(modifier = Modifier.height(10.dp))
                Text("Happy New Year!")
                Spacer(modifier = Modifier.height(26.dp))
                Row(
                    modifier = Modifier
                        .fillMaxWidth(),
                    horizontalArrangement = Arrangement.End
                ) {
                    Text(
                        modifier = Modifier
                            .clickable { onDismiss() }
                            .padding(5.dp),
                        text = "Close",
                        style = MaterialTheme.typography.bodyMedium.copy(color = MaterialTheme.colorScheme.primary)
                    )
                }
            }
        }
    }
}
</code></pre>

<p>最终结果：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1000/1*UG3e4b_9AqY1J1kKCNFqAw.png" alt="" /></p>

<p>感谢你的阅读！如果你觉得我的实验有趣且我的解释对你有帮助，欢迎加入我的<a href="https://t.me/droidshaderworks">Telegram频道</a>或在<a href="https://x.com/KrowaNaMostku">Twitter (X)</a>上关注我。你的支持意义重大，并激励着我。祝你撸码愉快！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初探Compose中的着色器RuntimeShader]]></title>
    <link href="https://alexhilton.github.io/blog/2025/08/15/first-look-at-runtimeshader/"/>
    <updated>2025-08-15T22:21:24+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/08/15/first-look-at-runtimeshader</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「First look at RuntimeShaders in Compose」，原文链接<a href="https://medium.com/@off.mind.by/first-look-at-runtimeshaders-in-compose-b0b431083644">https://medium.com/@off.mind.by/first-look-at-runtimeshaders-in-compose-b0b431083644</a>，由Alex Volkov发布于2024年4月12日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1302/1*QXaDvaYryDIZ1GItjM1uqQ.png" title="auto auto" ></a></p>

<!-- more -->


<p>自从我们有机会在 Compose 中使用 RuntimeShaders 自定义Shader（着色器）以来，已经过去了一年多的时间。说实话，我原本以为会有大量关于这个主题的文章。我以为现在 Android 上应该已经充斥着无数令人惊叹的示例、意想不到的效果，以及听到“着色器”这个词时脑海中浮现的其他令人着迷的东西。但事实并非如此。在 RuntimeShaders 可用之后，几乎立刻就出现了几篇文章，之后就再也没有了。一片寂静。</p>

<p>我想答案很简单：Android 开发者并不熟悉着色器，而着色器程序员通常不会直接为 Android 编写代码；他们通常会使用某种游戏引擎。事实上，如果我的假设正确，我希望用这篇文章来弥合这两个世界之间的差距。我真心希望着色器编写能够渗透到 Android 开发领域。因此，在本文的剩余部分，我将介绍一些必要的基础知识，以便你可以坐下来编写着色器并享受其成果。</p>

<p>因此，我假设你已经对 Compose 有了一定的了解。本文不会过多讨论着色器。我的主要重点是连接这两个世界。我们将在未来讨论具体的技术。假设我们有两个项目：一个带有背景图像，顶部有一个框，我们暂时将其设置为黑色。以下是代码的简化版本：</p>

<pre><code class="Kotlin">VerySimpleShaderTheme {
    Box(Modifier.fillMaxSize(), 
        contentAlignment = Alignment.Center) {
        Image(
            modifier = Modifier.fillMaxSize(),
            contentScale = androidx.compose.ui.layout.ContentScale.Crop,
            painter = painterResource(id = R.drawable.background_pattern),
            contentDescription = null
        )
        Box(modifier = Modifier
            .size(200.dp)
            .clipToBounds()
          ){
        }
    }
}
</code></pre>

<p>现在，要将着色器添加到框中，你需要获取着色器文本本身，该文本以常规字符串形式传递。使用此文本创建一个 <code>RuntimeShader</code> 对象。然后，将其传递给 <code>graphicsLayer</code> 方法。这是一个简单的例子：</p>

<pre><code class="Kotlin">val runtimeShader = """
uniform shader image;

half4 main(float2 fragCoord) {
   return half4(0., 0.0, 0.0, .5);
}
""".trimIndent()

val shader = remember { RuntimeShader(runtimeShader) } 
Box(modifier = Modifier.size(200.dp)
                        .clipToBounds()
                        .graphicsLayer {
                            this.renderEffect = RenderEffect
                                .createRuntimeShaderEffect(
                                    shader, "image"
                                )
                                .asComposeRenderEffect()
                        }
                        .background(Color.White)
                       ) 
</code></pre>

<p>这是一个非常基础的着色器示例，它输出黑色，透明度为 50%。它看起来像下面的屏幕截图所示（背景只是来自资源库的图片）。它可能还不够令人印象深刻，但我想在这里强调两个重要的细节。首先，我们如何将着色器应用到盒子上。在我们的着色器代码中，我们需要一个着色器对象，以便在创建 renderEffect 时传递它。第二个重要的细节是，我们需要为盒子添加一个背景，并且背景不能完全透明；只有这样，我们的着色器才能应用到盒子上，否则它将不可见。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*DWbBFHchSRHzeVv_9FuxvQ.png" alt="" /></p>

<p>在使用着色器时，通常需要对坐标进行归一化，使其从 0 变为 1。理想情况下，从 -0.5 到 0.5，这样坐标中心就位于画布的正中央。这有助于使用各种数学公式。然而，要做到这一点，不仅需要知道当前像素坐标，还需要知道画布的总尺寸。为了演示如何做到这一点，我将向你展示下一个重点：将参数从代码传递给着色器。我们将传递盒子的尺寸并修改着色器，使其绘制一个圆圈：</p>

<pre><code class="Kotlin">val runtimeShader = """
uniform shader image;
uniform float2 resolution;

half4 main(float2 fragCoord) {
    vec2 uv = fragCoord/resolution.xy - .5;
    uv.x *= resolution.x/resolution.y;    
    return half4(step(length(uv),0.5));
}
""".trimIndent()

Box(modifier = Modifier
                        .size(200.dp)
                        .clipToBounds()
                        .onSizeChanged { size -&gt;
                            shader.setFloatUniform(
                                "resolution", size.width.toFloat(), size.height.toFloat()
                            )
                        }
                        .graphicsLayer {
                            this.renderEffect = RenderEffect
                                .createRuntimeShaderEffect(
                                    shader, "image"
                                )
                                .asComposeRenderEffect()
                        }
                        .background(Color.White)
                       ) {
                    }
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*nBzr_W24ekFtGgf3xdz8QA.png" alt="" /></p>

<p>现在我们已经学习了如何创建自己的着色器并为其传递参数，重要的是要理解你可以传递任何你需要的参数，无论是时间、颜色还是着色器所需的其他参数。为了巩固这些知识，我将向你展示一个我为 Android 制作的第一个着色器的示例——一个用于加载的发光圆圈。我们将传递当前时间来为其添加动画效果；下面是一个此类效果的简单示例：</p>

<pre><code class="Kotlin">val runtimeShader = """
uniform shader image;
uniform float2 resolution;
uniform float radius;
uniform float time;

half4 main(float2 fragCoord) {
    vec2 uv = fragCoord/resolution.xy - .5;
    uv.x *= resolution.x/resolution.y;    
    float radiusWithTime = (1+sin(time))*0.1 + radius;
    float glowingCircle = smoothstep(radiusWithTime, radiusWithTime-radiusWithTime*0.3, length(uv));    
    return half4(glowingCircle-step(length(uv),radius*0.7));
}
""".trimIndent()

val shader = remember { RuntimeShader(runtimeShader) }
var time by remember { mutableStateOf(0f) }
shader.setFloatUniform("radius", 0.6f)
LaunchedEffect(null) {
    while (true) {
        delay(10)
        time+=0.01f
    }
}

shader.setFloatUniform("time", time)
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*Lr85zuDhk8o0-TUgw993_A.png" alt="它实际上有一个光晕动画" /></p>

<p>我已经演示了最基础的部分。我的目标是提供一个切入点，并展示它是多么的简单。关于着色器，我还有很多想讨论的，但我们留到下次再说。</p>

<p>感谢你的关注，祝你使用 Android、Compose 和Shader（着色器）顺利进入非凡的 UI 世界。期待与你相见！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[学会用最优雅的姿式在Compose中显示富文本]]></title>
    <link href="https://alexhilton.github.io/blog/2025/07/30/styledstring-in-jetpack-compose/"/>
    <updated>2025-07-30T22:50:40+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/07/30/styledstring-in-jetpack-compose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「StyledString: A Better Pattern for Rich Text in Jetpack Compose」，原文链接<a href="https://proandroiddev.com/styledstring-a-better-pattern-for-rich-text-in-jetpack-compose-5930bde981b1">https://proandroiddev.com/styledstring-a-better-pattern-for-rich-text-in-jetpack-compose-5930bde981b1</a>，由Eury Pérez Beltré发布于2025年7月14日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NS_T-i72tS5eOs5F0f_Tnw.png" title="auto auto" ></a></p>

<!-- more -->


<p>在 Jetpack Compose 中设置文本样式看似简单……但其实不然。在本文中，我们将探讨 AnnotatedString 的局限性，以及 StyledString 如何让富文本更易于管理。让我们来详细分析一下。👇</p>

<h2>📚 目录</h2>

<ol>
<li>引言：一个粗体字、一个链接，以及一大堆麻烦</li>
<li>AnnotatedString：样式过多，简洁性不足</li>
<li>StyledString 简介：一个 API 即可设置所有样式</li>
<li>StyledString 底层原理：API 背后的引擎</li>
<li>结语</li>
</ol>


<h2>引言：一个加粗的单词、一个链接，以及一大堆麻烦</h2>

<p>一开始，你拥有了 AnnotatedString 和一个 SpanStyle ，一切看起来都很顺畅。你想加粗一个单词？很简单✅。给某个东西加下划线？没问题。这甚至感觉有点有趣，尤其是在你像<a href="https://developer.android.com/develop/ui/compose/text/style-text#multiple-styles">官方文档</a>中那样手动构建整个字符串的时候。</p>

<p>但问题是：🧠</p>

<p>当你完全控制字符串时，这种方法非常有效。但当你处理实际内容：动态副本、本地化文本、从其他地方传入的段落，而你只需要设置其中一部分的样式时？</p>

<p>事情很快就变得很糟糕。</p>

<p>突然间，你需要跟踪子字符串、计算索引、应用样式，并连接点击监听器。只需对文本进行一次更改，你的逻辑就会像纸牌屋一样崩溃。🃏</p>

<p>你原本想要的只是加粗一个单词并让链接可点击。现在你深陷于样板代码中，祈祷一切都不会改变。</p>

<p>在这篇文章中，我将解释为什么 AnnotatedString 在实际 UI 中无法很好地扩展，并介绍一个我为了解决这个问题而构建的微型抽象。它叫做 StyledString，它的功能非常强大：💡 它确实做到了：</p>

<p><strong>让Compose 中的文本样式再次变得简单。</strong></p>

<h2>AnnotatedString：样式太多，简洁性不足</h2>

<p>首先，让我们称赞一下 AnnotatedString。它是一款强大的工具💪.</p>

<p>你可以使用一个 Text 可组合项来创建带样式、可点击、可交互的文本。想要让一个单词加粗，另一个单词像链接一样显示？完全可以。该 API 灵活、底层，并且由 Compose 本身的富文本引擎支持。</p>

<p>问题是，它只有<strong>在手动</strong>构建整个字符串时才能发挥最佳效果。</p>

<p>文档中的大多数示例如下所示：</p>

<pre><code class="Kotlin">buildAnnotatedString {
    append("Hello ")
    withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {
        append("world")
    }
}
</code></pre>

<p>看起来不错，对吧？但棘手的地方就在这里。👀</p>

<p>如果你有一整段动态文本，比如一段本地化的字符串或一个从其他地方拉取的句子，而你只想为其中的部分内容添加样式，该怎么办？</p>

<p>现在你需要处理：</p>

<ul>
<li>查找要添加样式的子字符串</li>
<li>计算起始和结束索引</li>
<li>手动添加样式或注释</li>
<li>希望文本永远不变，否则一切都会崩溃。</li>
</ul>


<p>如果你需要多种样式，比如粗体单词、可点击的电子邮件和带下划线的 URL，动态地，事情很快就会变得混乱。🔥
这时，buildAnnotatedString 就会变成一堆脆弱的索引数学运算、重复的逻辑和样板代码，难以阅读，更难以维护。</p>

<p>当然，AnnotatedString 功能强大。但当你的文本是动态的，而你只想为其中的部分内容添加样式时？它很快就会变得索然无味。</p>

<h2>StyledString 隆重出场：一个 API 即可实现所有样式</h2>

<p>在与 AnnotatedString 纠结了无数次之后，我决定构建一个更好的东西。它并非一个庞大的库，也不是一个完整的样式框架。而是一个简单、兼容 Compose 的抽象，用于解决一个非常具体的问题。</p>

<p><strong>StyledString 来啦！👋</strong></p>

<p>它的目标很简单：让你定义字符串的哪些部分应该被设置样式或可点击，而无需担心 indexOf 、 addStyle 或 AnnotatedString.Builder 。你只需编写文本，告诉它需要设置哪些单词的样式，以及点击后该执行的操作。</p>

<p>它的实际效果如下：</p>

<pre><code class="Kotlin">// This list can be built in the ViewModel
val styledStrings = persistentListOf(
    StyledString.ClickableEmail(
        highlightedText = "support@example.com",
        email = "support@example.com",
        style = SpanStyle(
            color = Color.Blue,
            textDecoration = TextDecoration.Underline
        )
    ),
    StyledString.ClickableUrl(
        highlightedText = "website",
        url = "https://euryperez.dev",
        style = SpanStyle(
            color = Color.Blue,
            textDecoration = TextDecoration.Underline
        )
    )
)

// In your Compose Screen
StyledText(
    fullText = "Contact us at support@example.com or visit our website",
    styledStrings = styledStrings,
    style = MaterialTheme.typography.label,
    onClick = { styled -&gt;
        when (styled) {
            is ClickableEmail -&gt; openEmailClient(styled.email)
            is ClickableUrl -&gt; openUrl(styled.url)
        }
    }
)
</code></pre>

<p>就是这样。无需手动构建文本，无需索引计算，无需样板代码。只需简洁、易读、声明式的样式，即可与真实文本兼容。</p>

<p>由于 StyledString 支持 Simple 、 ClickableEmail 和 ClickableUrl 等类型，因此它易于在你的应用中扩展和复用。你可以获得可点击的、带样式的文本，而无需牺牲其合理性和可维护性。🙏</p>

<h2>StyledString 的底层：API 背后的引擎</h2>

<p>让我们揭开它的面纱，逐步了解 StyledString 的工作原理。🪄</p>

<p>当你在 UI 中使用 StyledText 时，🧠它可能感觉像魔法一样神奇，但在幕后，它只是一个简洁、易于组合的架构，旨在减少样式设计的痛苦，而不会增加不必要的复杂性。</p>

<p>本节涵盖了 StyledString 系统的每个部分，从样式的描述方式，到样式的查找、应用和在屏幕上渲染。</p>

<h3>🧱 1. 数据模型：StyledString 和 ClickableStyleString</h3>

<p>整个实用程序的核心是一个名为 StyledString 的密封接口。我们通过它来对需要以某种方式设置样式的文本片段进行建模。</p>

<pre><code class="Kotlin">@Immutable
sealed interface StyledString {
    val highlightedText: String
    val style: SpanStyle

    // Add `Simple` type

    // Add `ClickableEmail` type

    // Add `ClickableUrl` type
}
</code></pre>

<p>每个 StyledString 都需要两条信息：</p>

<ul>
<li>highlightedText：需要设置样式的文本的确切部分</li>
<li>style：定义其外观的 SpanStyle（颜色、下划线、字体粗细等）。</li>
</ul>


<p>然后，我们定义一些实现此接口的特定类型：</p>

<pre><code class="Kotlin">@Immutable
data class Simple(
    override val highlightedText: String,
    override val style: SpanStyle,
) : StyledString
</code></pre>

<p>这个是纯视觉效果的，它会改变文本的外观，但不响应点击。</p>

<p>然后我们介绍交互类型：</p>

<pre><code class="Kotlin">@Immutable
data class ClickableEmail(
    override val highlightedText: String,
    val email: String,
    override val style: SpanStyle,
) : StyledString, ClickableStyleString

@Immutable
data class ClickableUrl(
    override val highlightedText: String,
    val url: String,
    override val style: SpanStyle
) : StyledString, ClickableStyleString
</code></pre>

<p>它们执行相同的样式设置工作，但还携带额外的数据（例如点击时应打开的 URL 或电子邮件）。更重要的是，它们实现了第二个接口：ClickableStyleString。</p>

<pre><code class="Kotlin">sealed interface ClickableStyleString
</code></pre>

<p>这个小接口意义重大，它让我们能够区分纯视觉样式和应该响应点击的样式。这使得我们的点击处理逻辑简洁且类型安全。💡</p>

<p>你可以轻松添加更多变体，例如 @mentions、#hashtags 或电话号码，只需创建另一个数据类并选择性地实现ClickableStyleString 即可。</p>

<h3>🎯 2. 样式和链接：applyStyle</h3>

<p>一旦我们知道了哪些文本需要样式，我们就需要一种将这些样式应用于实际的 AnnotatedString 的方法。这就是 applyStyle() 的作用，它是一个简单的扩展函数，它根据 StyledString 的类型应用样式（和点击监听器）。</p>

<pre><code class="Kotlin">private fun AnnotatedString.Builder.applyStyle(
    styledString: StyledString,
    startIndex: Int,
    endIndex: Int,
    onClick: (ClickableStyleString) -&gt; Unit
) {
    when (styledString) {
        is StyledString.ClickableUrl -&gt; TODO()

        is StyledString.ClickableEmail -&gt; TODO()

        is StyledString.Simple -&gt; TODO()
    }
}
</code></pre>

<p>每次匹配每个 StyledString 时，都会调用一次此函数。现在让我们看看它做了什么：</p>

<pre><code class="Kotlin">is StyledString.ClickableUrl -&gt; {
    val linkAnnotation = LinkAnnotation.Url(
        url = styledString.url,
        styles = TextLinkStyles(style = styledString.style),
        linkInteractionListener = { onClick(styledString) }
    )
    addLink(linkAnnotation, startIndex, endIndex)
}
</code></pre>

<p>如果是 URL，我们会创建一个 LinkAnnotation.Url 对象，附加样式，并为其添加一个点击监听器。addLink 负责将其附加到正确的文本范围。</p>

<p>我们执行的操作类似，但针对电子邮件使用的是 LinkAnnotation.Clickable ：</p>

<pre><code class="Kotlin">is StyledString.ClickableEmail -&gt; {
    val linkAnnotation = LinkAnnotation.Clickable(
        tag = styledString.highlightedText,
        styles = TextLinkStyles(style = styledString.style),
        linkInteractionListener = { onClick(styledString) }
    )
    addLink(linkAnnotation, startIndex, endIndex)
}
</code></pre>

<p>如果样式只是视觉上的（不可点击），我们会应用常规跨度：</p>

<pre><code class="Kotlin">is StyledString.Simple -&gt; {
    addStyle(
        style = styledString.style, 
        start = startIndex, 
        end = endIndex
    )
}
</code></pre>

<p>这种分离将所有样式应用逻辑集中在一处。如果你想要支持新的链接类型或行为，只需更新此函数即可。</p>

<h3>🔍 3. 匹配文本：findAllOccurrences</h3>

<p>在应用样式之前，我们需要找到文本中所有出现指定highlightedText 的位置。这就是此函数的用途。</p>

<pre><code class="Kotlin">/**
 * Find all occurrences of a substring in a string, optionally ignoring case.
 *
 * @param substring The substring to search for.
 * @param ignoreCase Whether to perform a case-insensitive search.
 * @return A list of indices where the substring was found.
 */
private fun String.findAllOccurrences(
    substring: String,
    ignoreCase: Boolean = false
): List&lt;Int&gt;
</code></pre>

<p>这将获取全文，并返回给定子字符串的每个匹配项的起始索引列表。</p>

<p>工作原理如下：</p>

<pre><code class="Kotlin">if (substring.isEmpty()) return emptyList()
</code></pre>

<p>对于空子字符串，快速提前退出。避免奇怪的边缘情况。然后，我们准备进行不区分大小写的搜索（如果需要）：</p>

<pre><code class="Kotlin">val indices = mutableListOf&lt;Int&gt;()
val searchString = if (ignoreCase) this.lowercase() else this
val searchSubstring = if (ignoreCase) substring.lowercase() else substring
</code></pre>

<p>现在我们遍历字符串，找到所有匹配项：</p>

<pre><code class="Kotlin">var startIndex = 0
val maxStartIndex = length - substring.length

while (startIndex &lt;= maxStartIndex) {
    val index = searchString.indexOf(searchSubstring, startIndex)
    if (index == -1) break
    indices.add(index)
    startIndex = index + 1
}
</code></pre>

<p>我们最终返回结果：</p>

<pre><code class="Kotlin">return indices.toList()
</code></pre>

<p>这使得我们的样式逻辑保持灵活性和弹性，无论我们设计的单词出现一次还是十几次。</p>

<h3>🧠 4. 构建 AnnotatedString：rememberStyledAnnotationString</h3>

<p>以下函数将所有内容整合在一起。它接收完整文本和你的StyledString 列表，并返回一个应用了所有样式的 AnnotatedString。</p>

<pre><code class="Kotlin">@Composable
fun rememberStyledAnnotationString(
    fullText: String,
    styledStrings: ImmutableList&lt;StyledString&gt;,
    ignoreCase: Boolean = false,
    onClick: (ClickableStyleString) -&gt; Unit
): AnnotatedString
</code></pre>

<p>我们确保使用 rememberUpdatedState() 来保持点击监听器的最新状态：</p>

<pre><code class="Kotlin">val currentOnClick by rememberUpdatedState(onClick)
</code></pre>

<p>然后我们使用记住来缓存工作，除非输入发生变化：</p>

<pre><code class="Kotlin">return remember(fullText, styledStrings, ignoreCase) {
  // TODO: build annotated string
}
</code></pre>

<p>我们首先附加完整的未样式化的文本。然后，对于每个 StyledString ，我们找到所有匹配的位置并应用样式：</p>

<pre><code class="Kotlin">buildAnnotatedString {
    append(fullText)

    styledStrings.fastForEach { styledStringInfo -&gt;
        val indices =
            fullText.findAllOccurrences(styledStringInfo.highlightedText, ignoreCase)

        indices.fastForEach { startIndex -&gt;
            val endIndex = startIndex + styledStringInfo.highlightedText.length
            applyStyle(styledStringInfo, startIndex, endIndex, currentOnClick)
        }
    }
}
</code></pre>

<p>这个循环使得样式设置能够动态且多目标化。你可以将任何本地化或运行时生成的字符串作为 fullText 传递，它仍然能够正确应用样式。</p>

<h3>🧩 5. 可组合项：StyledText</h3>

<p>最后，StyledText 可组合项将所有内容连接在一起。</p>

<pre><code class="Kotlin">@Composable
fun StyledText(
    fullText: String,
    styledStrings: ImmutableList&lt;StyledString&gt;,
    style: TextStyle,
    modifier: Modifier = Modifier,
    onClick: (ClickableStyleString) -&gt; Unit = {},
    ignoreCase: Boolean = false,
) {
    // TODO: Implementation
}
</code></pre>

<p>你传入全文、样式以及可选的点击处理程序。它的内部功能如下：</p>

<pre><code class="Kotlin">val annotatedString = rememberStyledAnnotationString(
    fullText = fullText,
    styledStrings = styledStrings,
    ignoreCase = ignoreCase,
    onClick = onClick
)
</code></pre>

<p>这调用了我们刚刚讲过的逻辑。它返回一个带样式的 AnnotatedString 。然后我们渲染它：</p>

<pre><code class="Kotlin">Text(
    modifier = modifier,
    text = annotatedString,
    style = style
)
</code></pre>

<p>它只是一个普通的 Compose Text 。但所有样式逻辑都已预先烘焙。现在，你的 UI 代码保持简洁且声明式。🌚</p>

<h3>⚡️ 6. StyledText 实践</h3>

<p>现在，让我们来看看 StyledText 的实践，为此，我整理了一个预览，你可以自己测试一下：</p>

<pre><code class="Kotlin">@PreviewLightDark
@Composable
private fun StyledTextPreview() {
    MyTheme {
        Box(
            modifier = Modifier
                .background(color = MaterialTheme.colors.background)
                .padding(16.dp)
        ) {
            // This list can be built in the ViewModel
            val styledStrings = persistentListOf(
                StyledString.ClickableEmail(
                    highlightedText = "support@example.com",
                    email = "support@example.com",
                    style = SpanStyle(
                        color = Color.Gray,
                        textDecoration = TextDecoration.Underline
                    )
                ),
                StyledString.ClickableUrl(
                    highlightedText = "website",
                    url = "https://euryperez.dev",
                    style = SpanStyle(
                        color = Color.Gray,
                        textDecoration = TextDecoration.Underline
                    )
                )
            )

            // In your Compose Screen
            StyledText(
                fullText = "Contact us at support@example.com or visit our website",
                styledStrings = styledStrings,
                style = MaterialTheme.typography.body2,
                color = MaterialTheme.colors.onBackground,
                onClick = { styled -&gt;
                    when (styled) {
                        is StyledString.ClickableEmail -&gt; TODO()
                        is StyledString.ClickableUrl -&gt; TODO()
                    }
                }
            )
        }
    }
}
</code></pre>

<p>你将在预览中看到以下内容：
<img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Tc22BNoUfij54fBGQ7YCg.png" alt="StyledTextPreview" /></p>

<h3>✅ 总结：一个输出简洁的简单引擎</h3>

<p>总而言之，我们构建了一个完全可复用的 Compose 实用程序，它：</p>

<ul>
<li>使用 StyledString 以声明式方式描述样式</li>
<li>安全地区分可视样式和可点击样式</li>
<li>使用 applyStyle 应用 span 和 link</li>
<li>使用 findAllOccurrences 查找多个匹配项</li>
<li>以 Compose 稳定的方式组装所有内容</li>
<li>封装在一个简洁的 API 中：StyledText</li>
</ul>


<p>无需 indexOf ，无需复杂的范围逻辑，也无需复制粘贴 buildAnnotatedString样板代码。</p>

<p><a href="https://gist.github.com/euri16/614a460fe6a690ce57cd23cc41164b5a">点击此处</a>（链接：<a href="https://gist.github.com/euri16/614a460fe6a690ce57cd23cc41164b5a%EF%BC%89%E8%8E%B7%E5%8F%96%E5%AE%8C%E6%95%B4%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%82">https://gist.github.com/euri16/614a460fe6a690ce57cd23cc41164b5a%EF%BC%89%E8%8E%B7%E5%8F%96%E5%AE%8C%E6%95%B4%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%82</a></p>

<h2>结语🎯</h2>

<p>Jetpack Compose 赋予我们强大的功能，但并非总是最符合人体工程学的开箱即用工具。AnnotatedString 对于一次性需求来说非常棒，但一旦你的 UI 需要多种样式、复用模式或动态点击处理，它就会很快变得冗长。</p>

<p>这就是 StyledString 的用武之地。</p>

<p>它并非取代 AnnotatedString，而是对其进行包装，为你提供一种更安全、更清晰的方式来描述意图：</p>

<ul>
<li>→ “将此单词加粗”</li>
<li>→ “将此短语设为链接”</li>
<li>→ “为该字符串的每个实例设置样式”</li>
</ul>


<p>你无需再考虑文本偏移量和跨度范围，而是开始思考含义。结果：代码更简洁、样板更少，开发者体验更佳💆</p>

<h3>🧩 易于采用</h3>

<p>你无需重构整个应用即可使用 StyledString 。</p>

<p>只需将一两个 Text() 元素替换为 StyledText() 即可。将内联的 buildAnnotatedString { &hellip; } 块替换为 StyledString.Simple 或 ClickableUrl 的简单列表即可。</p>

<p>就这样，你就成功了。✨</p>

<h3>🛠️ 易于扩展</h3>

<p>还有其他用例吗？</p>

<ul>
<li>为 #hashtags 设置样式？</li>
<li>处理 @mentions？</li>
<li>自动检测电话号码？</li>
<li>添加图标或背景高亮？</li>
</ul>


<p>只需创建一个实现 StyledString 的新数据类，并在 applyStyle() 中处理它即可。系统的其余部分保持不变。</p>

<p>这种分离使你的文本逻辑模块化、可测试，并能够适应未来的设计或业务需求。</p>

<p>如果你有什么有趣的想法，别忘了在评论区分享。😉</p>

<h3>🫱 轮到你了</h3>

<p>现在你已经了解了它的工作原理（以及它实际需要的代码量有多小），那就在下一个 Compose 屏幕中尝试一下吧。不再需要繁琐的 AnnotatedString.Builder 代码。不再需要重复的 span 逻辑。只需描述你想要的内容，剩下的交给 StyledText 处理。</p>

<p><strong>让 Compose 中的文本样式再次变得简单。😎</strong></p>

<h3>🤝 感谢阅读</h3>

<p>如果你最终在项目中使用了 StyledString，请告诉我！看到这些微型模式在现实世界中落地总是很酷。👀</p>

<p>感谢阅读！如果你觉得这篇文章有用，请考虑分享给其他开发者，点赞或留言。这很有帮助。✌️</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[揭密Jetpack Compose中的PausableComposition]]></title>
    <link href="https://alexhilton.github.io/blog/2025/07/24/exploring-pausablecomposition/"/>
    <updated>2025-07-24T19:55:51+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/07/24/exploring-pausablecomposition</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Exploring PausableComposition internals in Jetpack Compose」，原文链接<a href="https://blog.shreyaspatil.dev/exploring-pausablecomposition-internals-in-jetpack-compose">https://blog.shreyaspatil.dev/exploring-pausablecomposition-internals-in-jetpack-compose</a>，由Shreyas Patil发布于2025年7月14日。</p></blockquote>

<p><a href=""><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1751791091096/4e5b36e3-485c-4079-88be-987082e7d67e.png?w=1600&amp;h=840&amp;fit=crop&amp;crop=entropy&amp;auto=compress,format&amp;format=webp" title="auto auto" ></a></p>

<!-- more -->


<p>嗨，Composers 们👋，在最近的 Compose 1.9.X 版本中，Compose-runtime 引入了一个名为 PausableComposition 的新内部 API，据称它可以解决性能问题。它听起来像魔法，但在底层，这一切都归功于一些非常巧妙的工程设计。在深入研究 Compose 运行时以更好地理解这一点时，我偶然发现了一个强大的内部工具，它使这一切成为可能。</p>

<p>这篇文章将深入分析这一机制：PausableComposition。这是 Compose 的内部 API，开发者无需了解它。但了解它的底层工作原理总是有益的。对于想要深入了解 Compose 如何实现其惊人性能的 Jetpack Compose 开发者来说，这篇探索文章将为你提供更清晰的视角。我们将深入运行时源代码，了解它的工作原理、它对性能如此重要的原因，以及如何协调所有组件以使我们的 UI 感觉如此流畅。让我们开始吧！</p>

<h2>缘起</h2>

<p>为了实现流畅的 60 帧/秒 (fps)，我们的应用需要在 16.7 毫秒内绘制每一帧。当用户滚动浏览 LazyColumn 时，必须在这个微小的窗口内创建、测量和绘制新的项目。</p>

<p>如果一个项目很复杂，包含嵌套布局、图片和大量逻辑，那么组合它所需的工作很容易超过 16 毫秒。当这种情况发生时，主线程会被阻塞，帧会丢失，用户会在滚动过程中看到“卡顿”或卡顿。😩</p>

<p>这正是 PausableComposition 的初衷。</p>

<h2>“做什么”：更智能的 Compose 方式</h2>

<p>想象一下，你是一位厨师，正在为一场活动准备一顿大餐。👨‍🍳 与其在第一位客人到来时慌乱地从头开始烹饪所有食材，不如提前几个小时做好准备工作。切菜、调酱、烤甜点。等到上桌时，最后的烹饪和组装速度会快得令人难以置信。</p>

<p>PausableComposition 将这种“准备工作”的理念带到了 Compose 中。它允许运行时：</p>

<ol>
<li>增量式 Compose：将大型 UI 元素的合成分解成更小、更易于管理的部分。</li>
<li>异步准备：在 UI 真正需要显示在屏幕上之前进行合成工作，通常利用帧间的空闲时间。</li>
</ol>


<p>这种可组合项的预热意味着，当某个项目最终滚动到视图中时，大部分繁重的工作已经完成，使其几乎可以立即显示。</p>

<p>为了直观地理解这一概念，请观看以下动画：</p>

<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1751997214840/f9f7308a-7b83-4a3d-9d38-e3ce6aa8d9a9.gif?auto=format,compress&amp;gif-q=60&amp;format=webm" alt="滚动帧时间线" /></p>

<p>滚动发生时，假设项目 A、B、C、D 和 E 已在屏幕上可见，下一个项目是 F。如果项目 F 的布局或结构复杂，需要更多时间进行布局计算或其他预处理才能在 UI 上渲染，则此预处理将在帧时间轴内分块进行（例如 16 毫秒）。因此，如果它需要 2 帧，则 F 所需的预处理会在 2 帧的空闲时间内完成，不会造成任何帧卡顿。最后，当需要显示时，它会被绘制到 UI 上。项目 G 和 H 也采用相同的流程。</p>

<h2>工作原理：核心组件</h2>

<p>通过查看运行时源代码，我们可以看到它是如何通过一些关键接口和类来处理的。虽然你不会直接使用这些 API，但理解它们可以揭示 LazyColumn 的性能提升。🕵️‍♂️</p>

<h3>生命周期：PausableComposition 及其控制器</h3>

<p>旅程从 PausableComposition 接口开始，该接口扩展了 ReusableComposition 并添加了暂停功能。</p>

<blockquote><p>关于 ReusableComposition 的简要说明：</p>

<p>在讨论暂停之前，我们先来了解一下什么是 ReusableComposition？它是一种特殊的组合，专为需要高效回收 UI 内容的高性能场景而设计。想象一下 LazyColumn 中的项目。ReusableComposition 不会销毁滚动到屏幕外的项目的整个组合，而是允许运行时停用它。这会保留底层 UI 节点，但会清除已记住的状态。然后，这个停用的组合可以快速地用新内容“重新填充”，从而节省了从头创建节点的成本。PausableComposition 直接构建于这个强大的回收基础之上。</p></blockquote>

<p>PausableComposition 的外观如下：</p>

<pre><code class="Kotlin">// https://cs.android.com/androidx/platform/frameworks/support/+/8d08d42d60f7cc7ec0034d0b7ff6fd953516d96a:compose/runtime/runtime/src/commonMain/kotlin/androidx/compose/runtime/PausableComposition.kt;l=66
sealed interface PausableComposition : ReusableComposition {
    fun setPausableContent(content: @Composable () -&gt; Unit): PausedComposition
    fun setPausableContentWithReuse(content: @Composable () -&gt; Unit): PausedComposition
}
</code></pre>

<p>（注意：该接口是密封的，因为它仅在 Compose 运行时内部具有一组封闭且有限的实现。这为编译器提供了更多信息来进行优化。）</p>

<p>调用 setPausableContent 不会立即组合界面。相反，它会返回一个 PausedComposition 对象，该对象充当逐步过程的控制器。</p>

<pre><code class="Kotlin">// https://cs.android.com/androidx/platform/frameworks/support/+/8d08d42d60f7cc7ec0034d0b7ff6fd953516d96a:compose/runtime/runtime/src/commonMain/kotlin/androidx/compose/runtime/PausableComposition.kt;l=112
sealed interface PausedComposition {
    val isComplete: Boolean
    fun resume(shouldPause: ShouldPauseCallback): Boolean
    fun apply()
    fun cancel()
}
</code></pre>

<p>这个生命周期最好以状态机的形式来表示：</p>

<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1751864148018/27512893-f186-47e7-9bdc-26036460aed7.png?auto=compress,format&amp;format=webp" alt="PausableComposition生命周期流程图" /></p>

<ul>
<li>resume(shouldPause: ShouldPauseCallback)：这是引擎。预取系统（此处指 LazyColumn 上下文）会反复调用 resume() 来执行大量的组合工作。神奇之处在于 shouldPause 回调。Compose 运行时会在组合过程中频繁调用此 lambda。如果它返回 true（例如，由于帧截止时间已近），则组合过程将停止，并将主线程交还给更重要的工作，例如绘制当前帧。</li>
<li>apply()：一旦 resume() 返回 true，即表示操作完成，就会调用 apply()。这会获取所有计算出的界面更改，并将其提交到实际的界面树中。</li>
<li>cancel()：如果用户滚动离开，并且不再需要预先组合的项目，则会调用 cancellation() 来丢弃工作并释放资源。</li>
</ul>


<h3>内部结构概览：PausedCompositionImpl</h3>

<p>上述状态机由内部的 PausedCompositionImpl 类管理。该类保存状态并连接所有部分。</p>

<pre><code class="Kotlin">// https://cs.android.com/androidx/platform/frameworks/support/+/8d08d42d60f7cc7ec0034d0b7ff6fd953516d96a:compose/runtime/runtime/src/commonMain/kotlin/androidx/compose/runtime/PausableComposition.kt;l=202
internal class PausedCompositionImpl(...) : PausedComposition {
    private var state = PausedCompositionState.InitialPending
    internal val pausableApplier = RecordingApplier(applier.current)
    // ...

    override fun resume(shouldPause: ShouldPauseCallback): Boolean {
        when (state) {
            PausedCompositionState.InitialPending -&gt; {
                // This is the first time resume() is called.
                // It starts the initial composition of the content.
                invalidScopes =
                    context.composeInitialPaused(composition, shouldPause, content)
                state = PausedCompositionState.RecomposePending
                if (invalidScopes.isEmpty()) markComplete()
            }
            PausedCompositionState.RecomposePending -&gt; {
                // This is for subsequent calls to resume().
                state = PausedCompositionState.Recomposing
                // It tells the Composer to continue where it left off,
                // processing any pending invalidations.
                invalidScopes =
                    context.recomposePaused(composition, shouldPause, invalidScopes)
                state = PausedCompositionState.RecomposePending
                if (invalidScopes.isEmpty()) markComplete()
            }
            // ... other states like Recomposing, Applied, Cancelled are handled here ...
        }
        return isComplete
    }

    override fun apply() {
        // ... other state checks ...
        if (state == PausedCompositionState.ApplyPending) {
            applyChanges() // The call site
            state = PausedCompositionState.Applied
        }
        // ...
    }

    private fun applyChanges() {
        // ...
        pausableApplier.playTo(applier, rememberManager)
        rememberManager.dispatchRememberObservers()
        rememberManager.dispatchSideEffects()
        // ...
    }
}
</code></pre>

<p>调用 resume() 时，它会检查其内部状态并采取相应的措施：</p>

<ul>
<li>InitialPending：首次调用时，它会通过调用 context.composeInitialPaused 启动合成过程。这会告知核心 ComposerImpl 开始执行 @Composable 内容，并执行 shouldPause 回调。</li>
<li>RecomposePending：后续调用时，它会通过调用 context.recomposePaused 继续工作。此方法用于处理合成中任何因状态变化而失效的部分，或继续之前暂停的工作。</li>
<li>Applier：在此过程中，ComposerImpl 将所有 UI 更改操作转发给 pausableApplier（即 RecordingApplier），该操作会进行缓冲，而不是立即应用。</li>
<li>此过程持续进行，直到工作完成或 shouldPause 回调返回 true。</li>
</ul>


<h3>RecordingApplier：推迟最后的润色</h3>

<p>一个关键的性能技巧是 RecordingApplier。调用 resume() 时，Composer 不会直接更改实时 UI 树。如果分小步执行，可能会很慢，并导致 UI 更新不完整，显得怪异。</p>

<p>PausableComposition 使用的是 RecordingApplier。这个特殊的 Applier 会将其应该执行的所有 UI 操作（例如“创建 Text 节点”、“设置其文本属性”或“添加子图像”）记录到一个内部列表中。</p>

<p>只有调用 PausedComposition.apply() 时，RecordingApplier 才会将其记录的操作列表“回放”到实际的 Applier 上，从而高效地单步更新 UI 树。PausedComposition 的公共 apply() 方法是一个简单的状态机守卫。真正的工作发生在内部的 applyChanges() 方法中（如上面的代码片段所示）。</p>

<p>当调用 applyChanges 时，它会按顺序执行三项关键操作：</p>

<ul>
<li>它会告诉 RecordingApplier 将其所有缓冲的命令播放到实际的 applier 上。这才是 UI 真正出现在屏幕上的关键。</li>
<li>它会为所有已创建的 RememberObservers（例如 DisposableEffect）调度所有 onRemembered 生命周期回调。</li>
<li>最后，它会运行在合成过程中排队的所有 SideEffect。</li>
</ul>


<p>这种有序的批处理过程确保 UI 高效更新，并且所有生命周期事件都在正确的时间发生。</p>

<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1751794209046/49f5c1c7-b424-4c7d-a017-8ba65bb7b2d3.png?auto=compress,format&amp;format=webp" alt="PausableComposition时序图" /></p>

<h2>使用了 PausableComposition 的 LazyList</h2>

<p>LazyList 已经开始使用 PausableComposition API了。在 LazyList 中，PausableComposition 并非独立工作，而是协同工作的系统的一部分。</p>

<ul>
<li>指挥器 (Recomposer)：主 Recomposer 负责控制节奏，驱动可见 UI 的逐帧更新。</li>
<li>规划器 (LazyLayoutPrefetchState)：当用户滚动时，此组件会预测哪些项目即将显示。</li>
<li>舞台管理器 (SubcomposeLayout)：这个强大的 SubcomposeLayout 是 LazyList 的基础。它的 SubcomposeLayoutState 可以在需要时为各个项目创建和管理合成。最重要的是，它提供了 createPausedPrecomposition() API。</li>
<li>舞台调度器 (PrefetchScheduler)：此调度器会在帧之间寻找空闲时间来执行规划器请求的预合成工作。</li>
</ul>


<p>了解此功能的开发过程也很有趣。在 LazyLayoutPrefetchState 文件中，你可以找到控制它的功能标志：</p>

<pre><code class="Kotlin">// A simplified look inside LazyLayoutPrefetchState.kt: https://cs.android.com/androidx/platform/frameworks/support/+/8d08d42d60f7cc7ec0034d0b7ff6fd953516d96a:compose/foundation/foundation/src/commonMain/kotlin/androidx/compose/foundation/lazy/layout/LazyLayoutPrefetchState.kt;l=647
if (ComposeFoundationFlags.isPausableCompositionInPrefetchEnabled) {
    // This is the future, modern path.
    performPausableComposition(key, contentType, average)
} else {
    // This is the older, non-pausable fallback.
    performFullComposition(key, contentType)
}
</code></pre>

<p>isPausableCompositionInPrefetchEnabled 这个标志充当了终止开关的作用。虽然它在源代码中的默认值为 false。如果你想在惰性布局（LazyColumn、LazyRow 等）中启用可暂停组合行为，我们可以简单地按如下方式启用它：</p>

<pre><code class="Kotlin">class MyApplication : Application() {
    fun onCreate() {
        ComposeFoundationFlags.isPausableCompositionInPrefetchEnabled = true
        super.onCreate()
    }
}
</code></pre>

<h3>规划器：LazyLayoutPrefetchState 详解</h3>

<p>LazyLayoutPrefetchState 是预取操作的核心。它的作用是获取来自 LazyLayout 的预测（例如，“第 25 项即将上线”），并将其转换为实际的预组合任务。</p>

<p>它通过 PrefetchHandleProvider 实现此操作，该提供者会创建一个 PrefetchRequest。此请求是 PrefetchScheduler 可以执行的工作单元。在这个请求中，我们找到了暂停逻辑的核心。</p>

<p>当 PrefetchScheduler 执行请求时，它会进入一个循环，在 PausableComposition 上调用 resume()。传递给 resume 的 lambda 表达式决定是否暂停。</p>

<p>因此，如果启用了上述功能标记，它将通过 Pausable Composition API 执行请求，如下所示：</p>

<pre><code class="Kotlin">// https://cs.android.com/androidx/platform/frameworks/support/+/8d08d42d60f7cc7ec0034d0b7ff6fd953516d96a:compose/foundation/foundation/src/commonMain/kotlin/androidx/compose/foundation/lazy/layout/LazyLayoutPrefetchState.kt;l=754
// Simplified from HandleAndRequestImpl inside LazyLayoutPrefetchState
private fun PrefetchRequestScope.performPausableComposition(...) {
    val composition = // get the composition for the item of the LazyLayout 
    pauseRequested = false

    while (!composition.isComplete &amp;&amp; !pauseRequested) {
        composition.resume {
            if (!pauseRequested) {
                // 1. Update how much time is left in this frame's idle window.
                updateElapsedAndAvailableTime()

                // 2. Save how long this work chunk took, to improve future estimates.
                averages.saveResumeTimeNanos(elapsedTimeNanos)

                // 3. The Core Decision: Is there enough time left to do another
                //    chunk of work without risking a frame drop?
                pauseRequested = !shouldExecute(
                    availableTimeNanos,
                    averages.resumeTimeNanos + averages.pauseTimeNanos,
                )
            }
            // 4. Return the decision to the composition engine.
            pauseRequested
        }
    }

    updateElapsedAndAvailableTime()
    if (pauseRequested) {
        // If we decided to pause, record how long the final pause check took.
        averages.savePauseTimeNanos(elapsedTimeNanos)
    } else {
        // If we finished without pausing, record the time for the final resume chunk.
        averages.saveResumeTimeNanos(elapsedTimeNanos)
    }
}
</code></pre>

<p>让我们分解一下这个逻辑：</p>

<ol>
<li>updateElapsedAndAvailableTime()：在恢复 lambda 函数内部，系统会不断检查距离下一帧需要绘制还剩多少时间。</li>
<li>averages.saveResumeTimeNanos(&hellip;)：它会记录每个小块合成工作所需的时间。这有助于它构建一个平均值 (averages) 来预测未来工作的成本。</li>
<li>!shouldExecute(&hellip;)：这是核心决策。它会将 availableTimeNanos 与预算进行比较。这个预算是一个智能估算：完成另一块工作所需的平均时间加上暂停所需的平均时间。如果时间不足，pauseRequested 会变为 true。</li>
<li>最终计时：在本次循环退出后（因为工作完成或请求暂停），会调用最后一次 updateElapsedAndAvailableTime()。这会捕获最后一个操作的时间。</li>
<li>保存平均值：然后系统会保存这个最终计时。如果请求了暂停，则它会影响 pauseTimeNanos。如果循环自然完成，则它会影响 resumeTimeNanos。这确保了用于未来预测的历史数据始终准确。</li>
</ol>


<p>这种自我调节的反馈循环允许预取器在系统空闲时保持积极主动，但在需要渲染 UI 时又能保持礼貌，尊重主线程。</p>

<h3>最后一步：应用预组合 UI</h3>

<p>那么，当屏幕上真正需要预组合的项目时会发生什么呢？这时 SubcomposeLayout 就占据了中心位置。在正常的测量过程中，它会为现在可见的项目调用其 subcompose 函数。在内部，这会触发最后一步。</p>

<pre><code class="Kotlin">// https://cs.android.com/androidx/platform/frameworks/support/+/8d08d42d60f7cc7ec0034d0b7ff6fd953516d96a:compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/layout/SubcomposeLayout.kt;l=1186
// Simplified from LayoutNodeSubcompositionsState inside SubcomposeLayout.kt
private fun NodeState.applyPausedPrecomposition(shouldComplete: Boolean) {
    val pausedComposition = this.pausedComposition
    if (pausedComposition != null) {
        // 1. If the work must be completed now...
        if (shouldComplete) {
            // ...force the composition to finish by looping `resume`
            // and always passing `false` to the `shouldPause` callback.
            while (!pausedComposition.isComplete) {
                pausedComposition.resume { false }
            }
        }
        // 2. Apply the changes to the real UI tree.
        pausedComposition.apply()
        this.pausedComposition = null // Clear the handle.
    }
}
</code></pre>

<p>当某个项目可见时，其组合不再是低优先级的后台任务，而是高优先级的同步任务。shouldComplete = true 参数确保所有剩余的组合工作立即完成，无需暂停。然后，apply() 被调用，完整的 UI 会立即显示在屏幕上。</p>

<p>它们如何协同工作：</p>

<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1751799217100/82837ef0-e97e-49c7-bee6-cd68ab1804ba.png?auto=compress,format&amp;format=webp" alt="LazyList滚动时序图" /></p>

<h2>结论</h2>

<p>深入研究 Compose 运行时后，PausableComposition 的设计堪称性能工程的杰作。</p>

<ul>
<li>它并非魔法，而是延迟：其核心理念是在紧急任务之前完成。通过在空闲时间合成项目，快速滚动时主线程所需的工作量会大大减少。</li>
<li>协作式和非阻塞式：shouldPause 回调是处理多任务的绝佳方式。它可以让长时间运行的合成任务优雅地让位于更紧急的当前帧渲染任务，从而直接防止卡顿。</li>
<li>通过批处理提高效率：RecordingApplier 通过将 UI 树中的许多小的独立更改分组为单个高效的更新，避免了这些更改带来的开销。</li>
</ul>


<p>虽然 PausableComposition 是一个你可能永远不会直接使用的内部功能，但了解它的存在和运作方式，可以让你真正体会到 Jetpack Compose 如此高性能的明智决策。下次你轻松流畅地滚动浏览复杂的 LazyColumn 时，你就会体会到这巧妙且精心编排的“舞蹈”是如何在表面之下进行的。✅ 这种架构不仅解决了当前的性能挑战，还为 Compose 未来更先进的渲染策略铺平了道路。</p>

<p>希望你已经了解了这个新 API 在 Jetpack Compose 中的工作原理。</p>

<p>太棒了！希望你从中获得了一些宝贵的见解。如果你喜欢这篇文章，请分享 😉，因为……</p>

<p>“分享即关爱”</p>

<p>谢谢！😄</p>

<p>让我们一起回顾 X （链接：<a href="https://twitter.com/imShreyasPatil%EF%BC%89%E7%9A%84%E6%9C%80%E6%96%B0%E5%8A%A8%E6%80%81%EF%BC%8C%E6%88%96%E8%80%85%E8%AE%BF%E9%97%AE%E6%88%91%E7%9A%84%E7%BD%91%E7%AB%99%EF%BC%88%E9%93%BE%E6%8E%A5%EF%BC%9Ahttps://shreyaspatil.dev/%EF%BC%89%E4%BA%86%E8%A7%A3%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84%E4%BF%A1%E6%81%AF">https://twitter.com/imShreyasPatil%EF%BC%89%E7%9A%84%E6%9C%80%E6%96%B0%E5%8A%A8%E6%80%81%EF%BC%8C%E6%88%96%E8%80%85%E8%AE%BF%E9%97%AE%E6%88%91%E7%9A%84%E7%BD%91%E7%AB%99%EF%BC%88%E9%93%BE%E6%8E%A5%EF%BC%9Ahttps://shreyaspatil.dev/%EF%BC%89%E4%BA%86%E8%A7%A3%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84%E4%BF%A1%E6%81%AF</a> 😎。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SnapshotFlow还是collectAsState？对于Jetpack Compose来说哪个更香？]]></title>
    <link href="https://alexhilton.github.io/blog/2025/07/16/snapshotflow-or-collectasstate/"/>
    <updated>2025-07-16T22:31:22+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/07/16/snapshotflow-or-collectasstate</id>
    <content type="html"><![CDATA[<p>本文译自「SnapshotFlow or collectAsState? How to pick the right tool for Jetpack Compose」，原文链接<a href="https://proandroiddev.com/snapshotflow-or-collectasstate-how-to-pick-the-right-tool-for-jetpack-compose-d6f1cc9d2123">https://proandroiddev.com/snapshotflow-or-collectasstate-how-to-pick-the-right-tool-for-jetpack-compose-d6f1cc9d2123</a>，由Dmitry Glazunov发布于2025年7月7日。</p>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*P0darOG2IeBIDWdY" title="auto auto" ></a></p>

<!-- more -->


<p>构建 UI 可能感觉很简单，直到需要订阅状态变化并有效处理副作用时之前。许多开发者过度使用 collectAsState，导致延迟和意外的重组（reComposition）。还有一些人听说过 snapshotFlow，但却不太明白既然 StateFlow 和 collectAsState 已经存在，为什么还需要它？</p>

<p>在这篇文章中，我将通过探索实际项目中简短且实用的示例，分享我对何时使用 snapshotFlow 以及何时更适合使用 collectAsState 的看法，帮助你避免项目中隐藏的 bug 和性能问题。</p>

<p>让我们来详细分析一下。</p>

<h2>collectAsState 的作用</h2>

<p>collectAsState 在 Compose 中订阅 Flow，并自动将其公开为State，以便在 UI 中轻松显示：</p>

<pre><code class="Kotlin">val uiState by viewModel.uiStateFlow.collectAsState()
Text(uiState.text)
</code></pre>

<p>要点：</p>

<ul>
<li>非常易于使用。</li>
<li>重组时自动取消并重新开始收集。</li>
<li>非常适合 ViewModel → UI 数据绑定。</li>
</ul>


<p>但是：</p>

<ul>
<li>每次发出新数据时都会触发重组，哪怕只是发生了微小的变化。</li>
<li>可组合项进入重组状态后立即开始收集。</li>
<li>不适用于观察 Compose 特有的状态，例如滚动或手势。</li>
</ul>


<h2>快照流 (snapshotFlow) 的作用</h2>

<p>快照流 (snapshotFlow) 将 Compose 状态（例如 LazyListState 、 derivedStateOf ）转换为冷流 (cold Flow)，让你无需进行不必要的重组即可对状态变化做出反应：</p>

<pre><code class="Kotlin">val listState = rememberLazyListState()

LaunchedEffect(Unit) {
    snapshotFlow { listState.firstVisibleItemIndex }
        .distinctUntilChanged()
        .collect { index -&gt;
            analytics.logScrollPosition(index)
        }
}
</code></pre>

<p>要点：</p>

<ul>
<li>非常适合 Compose 状态变化的副作用。</li>
<li>不会触发重组。</li>
<li>可在 LaunchedEffect 或协程中使用。</li>
</ul>


<p>但是：</p>

<ul>
<li>不会公开状态以进行直接 UI 渲染。</li>
<li>不会替代 CollectAsState 来实现 ViewModel → UI 更新。</li>
</ul>


<h2>何时使用 collectAsState</h2>

<ul>
<li>从 ViewModel 订阅 UI 的 Flow 或 StateFlow。</li>
<li>在 UI 中显示数据（文本、加载状态、获取的数据）。</li>
<li>用户需要看到的低频更新。</li>
</ul>


<p>避免使用：</p>

<ul>
<li>高频更新（滚动偏移、传感器数据）。</li>
<li>触发不需要 UI 更新的副作用。</li>
</ul>


<h2>何时使用 snaphotFlow</h2>

<ul>
<li>响应 Compose 状态（滚动、手势、动画）。</li>
<li>触发副作用但不会导致重组。</li>
<li>从 Compose 状态构建 Flow 管道（分析、延迟加载触发器）。</li>
</ul>


<p>避免使用：</p>

<ul>
<li>直接 UI 数据渲染。</li>
<li>用 viewModel → UI 流替换 collectAsState。</li>
</ul>


<h2>snapshotFlow 的实用示例</h2>

<p>错误体位：使用 snaphotFlow.collectAsState 进行动画进度</p>

<pre><code class="Kotlin">val progress by snapshotFlow { animationState.progress }
    .collectAsState(initial = 0f)

Text("Progress: ${(progress * 100).toInt()}%")
</code></pre>

<p>使用 snaphotFlow 和 collectAsState 来驱动动画进度的 UI 更新会导致每一帧都重新合成，从而导致卡顿，违背了 snaphotFlow 的初衷。</p>

<p>正确姿式：使用 snaphotFlow 在动画过程中进行分析</p>

<pre><code class="Kotlin">LaunchedEffect(Unit) {
    snapshotFlow { animationState.progress }
        .distinctUntilChanged { old, new -&gt;
            (old * 100).toInt() == (new * 100).toInt()
        }
        .collect { progress -&gt;
            analytics.logAnimationProgress(progress)
        }
}
</code></pre>

<p>这会跟踪动画进度，以便进行分析或记录，而不会触发 UI 重构。</p>

<h2>collectAsState 的实用示例</h2>

<p>错误体位：将 collectAsState 用于高频滚动数据</p>

<pre><code class="Kotlin">val scrollOffset by viewModel.scrollOffsetFlow.collectAsState()
Text("Offset: $scrollOffset")
</code></pre>

<p>这会在滚动的每个像素上触发重新合成，导致 CPU 过载。</p>

<p>正确姿式：使用 collectAsState 获取有意义的 UI 数据</p>

<pre><code class="Kotlin">val userName by viewModel.userNameFlow.collectAsState()
Text("Hello, $userName!")
</code></pre>

<p>这适用于显示用户需要查看且不经常更改的数据。</p>

<h2>结论</h2>

<p>collectAsState 和 snapshotFlow 相辅相成：</p>

<ul>
<li>使用 collectAsState 在 UI 中显示 ViewModel 数据。</li>
<li>使用 snapshotFlow 响应 Compose 状态变化的副作用，而无需触发重组。</li>
</ul>


<p>正确使用它们将帮助你避免不必要的重组，提升应用的响应速度，并保持 Compose 代码简洁、可扩展且可预测。</p>

<p>如果你觉得本文分析有用，请随时关注我以获取更多见解。</p>
]]></content>
  </entry>
  
</feed>
