<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Compose | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/compose/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2026-01-12T12:53:23+00:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Jetpack Compose内部的不同节点类型]]></title>
    <link href="https://alexhilton.github.io/blog/2026/01/12/node-types-in-jetpack-compose/"/>
    <updated>2026-01-12T00:00:00+00:00</updated>
    <id>https://alexhilton.github.io/blog/2026/01/12/node-types-in-jetpack-compose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「The Different Node Types in Jetpack Compose」，原文链接<a href="https://www.grokkingandroid.com/the-different-node-types-in-jetpack-compose/">https://www.grokkingandroid.com/the-different-node-types-in-jetpack-compose/</a>，由Wolfram Rittmeyer发布于2025年12月30日。</p></blockquote>

<p><a href=""><img src="https://www.grokkingandroid.com/wordpress/wp-content/uploads/2025/12/ComposeUiNode-700x389.png" title="auto auto" ></a></p>

<!-- more -->


<p>如果你仔细观察 Compose，你会发现它很奇怪。你会发现很多函数都没有返回值。然而，<a href="https://developer.android.com/develop/ui/compose/mental-model">Android 文档</a>却说：</p>

<blockquote><p>可组合函数会生成 UI 层级结构。</p></blockquote>

<p>这到底是什么意思呢？从函数式编程的角度来看，你那些看似无害的无状态可组合函数实际上会产生大量的<em>副作用[1]</em>。其中就包括创建节点。</p>

<p>有时你可能会创建一些可组合函数来自己创建节点。但更多时候，你会直接委托给其他可组合函数来<em>创建节点[2]</em>。</p>

<p>那么，让我们来看看有哪些节点，它们的创建位置以及它们的用途：</p>

<ul>
<li>ComposeUiNode</li>
<li>LayoutNode</li>
<li>Modifier.Node</li>
<li>SemanticsNode</li>
</ul>


<h2>ComposeUiNode</h2>

<p>当你深入研究<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/layout/package-summary#Layout(androidx.compose.ui.Modifier,androidx.compose.ui.layout.MeasurePolicy)"><code>Layout</code></a>可组合对象时，你会发现它调用了<code>ReusableComposeNode[3]</code>:</p>

<pre><code class="kotlin">@Composable
@UiComposable
inline fun Layout(modifier: Modifier = Modifier, measurePolicy: MeasurePolicy) {
    val compositeKeyHash = currentCompositeKeyHash
    val materialized = currentComposer.materialize(modifier)
    val localMap = currentComposer.currentCompositionLocalMap
    ReusableComposeNode&lt;ComposeUiNode, Applier&gt;(
        factory = ComposeUiNode.Constructor,
        update = {
            set(measurePolicy, SetMeasurePolicy)
            set(localMap, SetResolvedCompositionLocals)
            set(materialized, SetModifier)
            set(compositeKeyHash, SetCompositeKeyHash)
        },
    )
}
</code></pre>

<p><strong><code>ReusableComposeNode</code>本身并不是一个节点。</strong> 上面的代码中并没有构造函数调用，而是对另一个可组合对象的调用。第八行的工厂参数看似无关紧要，但实际上非常重要。因为最终会创建节点的就是这个函数。它会创建一个 <code>ComposeUiNode</code>。</p>

<p><code>ReusableComposeNode</code> Composable 与 Compose 运行时紧密相关。这段代码告诉 Composer 应该启动一个 <code>GroupKind.ReusableNode</code> 类型的新组，然后代码会创建一个新节点，或者在重新组合时重用现有节点。最后，当使用 update 函数参数时，它会设置节点的内容：</p>

<pre><code class="kotlin">@Composable
inline fun &lt;T : Any, reified E : Applier&gt; ReusableComposeNode(
    noinline factory: () -&gt; T,
    update: @DisallowComposableCalls Updater.() -&gt; Unit
) {
    if (currentComposer.applier !is E) invalidApplier()
    currentComposer.startReusableNode()
    if (currentComposer.inserting) {
        currentComposer.createNode(factory)
    } else {
        currentComposer.useNode()
    }
    Updater(currentComposer).update()
    currentComposer.endNode()
}
</code></pre>

<p>我们看到工厂被传递给了 <code>createNode()</code> 调用。此调用会安排在所有插入操作处理完毕后创建节点。Compose 运行时内部会延迟执行许多操作以实现优化。这里我们并不关心具体何时发生，只需知道它<em>将会</em>发生即可。当它发生时，工厂将被调用。</p>

<p>现在让我们更仔细地看一下工厂本身：<code>ComposeUiNode.Constructor</code> 看起来像是 <code>ComposeUiNode</code> 的构造函数。但事实并非如此。实际上，<code>ComposeUiNode</code> 是一个接口，它本身并不执行任何操作。它实际上是 <code>LayoutNode</code> 使用的基接口。至于这个接口和构造函数的用途，在接口声明上方的注释中已经给出：</p>

<pre><code class="kotlin">/** Interface extracted from LayoutNode to not mark the whole LayoutNode class as @PublishedApi. */
@PublishedApi
internal interface ComposeUiNode {
    // ...
    /** Object of pre-allocated lambdas used to make use with ComposeNode allocation-less. */
    companion object {
        val Constructor: () -&gt; ComposeUiNode = LayoutNode.Constructor
        val VirtualConstructor: () -&gt; ComposeUiNode = { LayoutNode(isVirtual = true) }
        // ...
    }
}
</code></pre>

<p><strong>所以 <code>ComposeUiNode</code> 只是 <code>LayoutNode</code> 的一个抽象。</strong></p>

<h2>布局节点（LayoutNode）</h2>

<p>在上一节中，我们已经了解了 <code>LayoutNode</code> 的实际创建时间。基本上，每当调用 <code>Layout</code> 可组合组件时，都会创建 <code>LayoutNode</code>。<code>LayoutNode</code> 是树状结构中的元素，代表屏幕上的内容。它需要被测量，可以在其边界内放置子元素，也可以绘制内容。</p>

<p>每个 <code>LayoutNode</code> 都知道它的子元素和父元素。因此，<code>LayoutNode</code> 构成了一个节点树，代表了已发出的内容。需要明确的是：Compose 创建的树状结构与其他 UI 框架一样——但 Google 更倾向于使用一些更高级的命名方式。<strong>因此，每当你听到/读到有关可组合组件发出内容时，请将其理解为一个 LayoutNode 被创建并插入到树中。</strong></p>

<p><code>LayoutNode</code> 类实际上非常有趣，因此值得单独撰写一篇博文，我将在其中更详细地介绍它的一些方面。</p>

<p>这里有两点值得一提：</p>

<ul>
<li><code>Applier</code> 是调用 <code>LayoutNode</code> 相应树状结构处理方法的实例。 - <code>LayoutNode</code> 持有对 <code>Owner</code> 的引用。</li>
</ul>


<p>由于 <code>Applier</code> 和 <code>Owner</code> 在 Compose 中都是非常重要的概念，我将在单独的博文中分别介绍它们。</p>

<h3>LayoutNode 的用途</h3>

<p><code>LayoutNode</code> 构成 UI 树，并跟踪其父节点和子节点。UI 树本身的管理由 <code>Applier</code> 完成，我将在另一篇文章中介绍它。</p>

<p>另外，需要记住的一点是，<code>LayoutNode</code> 存储在 <code>SlotTable[4]</code> 中。因此，在重新组合时，如果运行时认为树的这一部分不需要更改，则可以重用现有的 <code>LayoutNode</code>。</p>

<p><code>LayoutNode</code> 还会保存其修饰符（参见下一节），并委托这些修饰符来决定该 <code>LayoutNode</code> 需要多少空间（测量）、在屏幕上放置元素的位置（布局）以及最终在屏幕上显示什么内容（绘制）。</p>

<p>还有更多内容——但正如我提到的，那是另一篇文章的一部分。</p>

<h2>Modifier.Node</h2>

<p>修饰符在内部由 <a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier.Node"><code>Modifier.Node</code></a> 对象表示。<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier.Node">根据文档</a>，它是“为应用于 androidx.compose.ui.layout.Layout 的每个 Modifier.Element 创建的生命周期更长的对象”。</p>

<p>这个“生命周期更长”很有意思。基本上，只要 <code>Modifier.Node</code> 属于 <code>LayoutNode</code> 的修饰符链，它就会一直存在。 <code>LayoutNode</code> 持有一个 <code>NodeChain</code> 类型的对象，该对象内部维护着一个修饰符列表，并检查该列表是否发生更改，以及 <code>Modifier.Node</code> 的生命周期方法（例如 <code>onAttach()</code>）是否被调用。</p>

<p><code>Modifier.Node</code> 有许多现有的子类型，例如 <a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/node/LayoutModifierNode"><code>LayoutModifierNode</code></a>（见下文）或 <a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/node/DrawModifierNode?hl=en"><code>DrawModifierNode</code></a>。后者负责实际在屏幕上绘制内容，我计划在另一篇文章中详细介绍。</p>

<p>由于 <code>LayoutNode</code> 是 <code>SlotTable</code> 的一部分，因此附加到 <code>LayoutNode</code> 的 <code>NodeChain</code> 对象的 <code>Modifier.Node</code> 显然也是 <code>SlotTable</code> 的一部分。</p>

<h3>特殊子类型：<code>LayoutModifierNode</code></h3>

<p><code>LayoutModifierNode</code>（<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/node/LayoutModifierNode%EF%BC%89%E6%98%AF%E5%AE%9E%E9%99%85%E8%BF%9B%E8%A1%8C%E6%B5%8B%E9%87%8F%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%AE%83%E4%BB%AC%E4%BC%9A%E5%BD%B1%E5%93%8D%E5%B1%8F%E5%B9%95%E4%B8%8A%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%92%8C%E4%BD%8D%E7%BD%AE%E3%80%82%E6%AD%A3%E5%A6%82%E6%96%87%E6%A1%A3%E6%89%80%E8%BF%B0%EF%BC%9A%E2%80%9C">https://developer.android.com/reference/kotlin/androidx/compose/ui/node/LayoutModifierNode%EF%BC%89%E6%98%AF%E5%AE%9E%E9%99%85%E8%BF%9B%E8%A1%8C%E6%B5%8B%E9%87%8F%E7%9A%84%E8%8A%82%E7%82%B9%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%AE%83%E4%BB%AC%E4%BC%9A%E5%BD%B1%E5%93%8D%E5%B1%8F%E5%B9%95%E4%B8%8A%E5%85%83%E7%B4%A0%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%92%8C%E4%BD%8D%E7%BD%AE%E3%80%82%E6%AD%A3%E5%A6%82%E6%96%87%E6%A1%A3%E6%89%80%E8%BF%B0%EF%BC%9A%E2%80%9C</a><code>LayoutModifierNode</code> 会改变其包裹内容的测量和布局方式。”。因此，在测量和布局过程中，每当遍历 <code>ModifierNode</code> 链时，这些节点实际上都会开始进行测量。</p>

<p>因此，所有想要改变其子元素位置或对整个 Composable 元素大小产生任何影响的修饰符都需要实现 <code>LayoutModifierNode</code> 接口。例如，<code>SizeNode</code> 就是一个实现 <code>LayoutModifierNode</code> 接口的例子，它是 <code>height()</code>、<code>width()</code> 或 <code>size()</code> 等修饰符实际使用的节点。</p>

<h2>SemanticsNode</h2>

<p>当你想要向设备的<em>辅助功能服务[5]</em>传递一些信息时，你可以使用 Compose 中的 <a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier).semantics(kotlin.Boolean,kotlin.Function1)"><code>semantics</code></a> 修饰符来告知系统要向用户传达哪些语义属性。</p>

<p>但是辅助功能服务并不了解 Compose。在其他平台上，这一点显而易见，但考虑到 Compose 向后兼容（而且它并非 Android 框架的组成部分），在 Android 上也是如此。</p>

<p>对于辅助功能，前面提到的 <code>Owner</code> 再次发挥作用。它持有一个 <code>SemanticsOwner</code>，该 <code>SemanticsOwner</code> 充当了与相应平台语义框架之间的桥梁。</p>

<p>为此，<code>SemanticsOwner</code> 维护着一个 <code>SemanticNode</code> 对象树，用于向辅助功能服务的用户描述屏幕内容。这也是我未来会更详细介绍的内容之一。</p>

<p>敬请期待更多关于 Compose 内部运作机制的见解。祝你编码愉快！</p>

<h2>脚注</h2>

<ul>
<li>[1] 我在本段中使用“副作用”一词，是因为它在<a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)">计算机科学和函数式编程</a>中由来已久。我这里指的并非官方 Compose 文档中提到的<a href="https://developer.android.com/develop/ui/compose/side-effects">副作用</a>。Compose 文档至少在过去有时会提及副作用的这种用法——尽管实际上 Compose 函数并非纯函数。</li>
<li>[2] 如果在 Compose Compiler 插件完成工作后查看 Composable，你会发现它不仅创建了节点，而且你的函数还会进行大量调用，从而改变应用程序的全局状态。但这些调用并不会实际绘制任何内容。它们最多只会创建一些绘制操作，这些操作会被记录下来，并在系统认为需要绘制时，于未来的某个时间点被调用。我将在以后的两篇文章中分别介绍绘制过程以及编译器对代码所做的更改。</li>
<li>[3] 实际上，布局可组合对象共有三个。但它们最终都会调用 <code>ReusableComposeNode</code>。其他变体的示例也与之非常相似。</li>
<li>[4] 本系列文章中我可能不会介绍 SlotTable。我推荐 Richard Leland 的这篇关于 compose 的文章（<a href="https://medium.com/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd%EF%BC%89%EF%BC%8C%E4%BB%A5%E5%8F%8A">https://medium.com/androiddevelopers/under-the-hood-of-jetpack-compose-part-2-of-2-37b2c20c6cdd%EF%BC%89%EF%BC%8C%E4%BB%A5%E5%8F%8A</a> Mohit Sarveiya 的关于 slotTable 的视频（<a href="https://codingwithmohit.com/%EF%BC%89%EF%BC%8C%E8%BF%99%E4%BA%9B%E8%A7%86%E9%A2%91%E8%AE%B2%E8%A7%A3%E4%BA%86%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8">https://codingwithmohit.com/%EF%BC%89%EF%BC%8C%E8%BF%99%E4%BA%9B%E8%A7%86%E9%A2%91%E8%AE%B2%E8%A7%A3%E4%BA%86%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8</a> slotTable。</li>
<li>[5] 设备上的辅助功能服务在 Android 系统中是 AccessibilityService 的实现，但在 iOS、桌面或 Web 端则有所不同，因此我在本文中使用“辅助功能服务”这个通用术语。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[学会在Jetpack Compose中加载Lottie动画资源]]></title>
    <link href="https://alexhilton.github.io/blog/2025/12/25/compose-lottie-resources/"/>
    <updated>2025-12-25T00:00:00+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/12/25/compose-lottie-resources</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「From File to Fetch」，原文链接<a href="https://proandroiddev.com/from-file-to-fetch-ed6dca1122c8">https://proandroiddev.com/from-file-to-fetch-ed6dca1122c8</a>，由Katie Barnett发布于2025年11月23日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/1*qaaJ_zFlqmNT3CKeLpsvKw.gif" title="auto auto" ></a></p>

<!-- more -->


<p>_注意：我与 Airbnb 及其 Lottie 项目（Lottie 的 GitHub 仓库）没有任何关联。](<a href="https://github.com/airbnb/lottie-android">https://github.com/airbnb/lottie-android</a>)我最近刚在一个应用中实现了 Lottie，想分享一些示例来佐证<a href="https://lottie.airbnb.tech/#/android-compose">官方文档</a>。</p>

<h2>了解 Lottie</h2>

<p>之前，我写过关于动画的文章<a href="https://medium.com/bilue/expanding-dialog-in-jetpack-compose-a6be40deab86">https://medium.com/bilue/card-flip-animation-with-jetpack-compose-f60aaaad4ac9</a>，也<a href="https://www.youtube.com/watch?v=ol9zpXu3g1U">在</a>上讨论过这个主题，以及我是如何创建原生动画的。但有时，我们想要一些更具艺术性的效果，不需要移动屏幕上的可组合元素；这时，我们就需要一个预先构建好的动画。</p>

<p>Lottie 就派上用场了。</p>

<p>如果你之前没有使用过 Lottie，它是由 Airbnb 开发人员开发的一个库，可以解析 Adob​​e After Effects 动画并将其导出为 JSON 格式。其理念是，设计师可以创建复杂的动画，而无需手动渲染。有很多设计工具的插件可以帮助创建动画，例如 Figma。如果你具备一定的设计天赋（我没有！），上手也很容易。</p>

<p>Lottie 已经存在一段时间了，可以在多个平台上渲染，例如 iOS、Web、Windows，当然还有 Android。它可用于 <a href="https://lottie.airbnb.tech/#/android">XML 视图</a>，但我今天要重点介绍的是它与 Jetpack Compose 的集成。</p>

<p>官方文档在这里 <a href="https://lottie.airbnb.tech/#/android-compose">https://lottie.airbnb.tech/#/android-compose</a>，但它并没有详细介绍如何使用 <code>LottieCompositionSpec</code> 中的多种不同源类​​型，以最便捷的方式提供我们的 Lottie 文件。实际上，某些应用可能需要处理多种源类型，尤其是在后端调用中指定特定动画的情况下。</p>

<p>我们将逐步介绍每种类型，但首先，让我们使用字符串来保存 Lottie 动画数据，从而进行基本设置。</p>

<h2>字符串来源</h2>

<p>使用任何 SDK 的第一步都是添加依赖项：</p>

<pre><code class="kotlin">// build.gradle.kts
...

dependencies {
    ...
    implementation(libs.lottie.compose)
}

// libs.version.toml
[versions]
lottie = "6.6.6"

[libraries]
lottie-compose = { group = "com.airbnb.android", name = "lottie-compose", version.ref = "lottie" }
</code></pre>

<p>然后，在 Composable 中，我们需要创建 <code>LottieCompositionSpec</code>。对于 JSON 字符串，我们可以使用 <code>LottieCompositionSpec.JsonString(val jsonString: String)</code>，</p>

<p>并将字符串传递给它。接下来，使用 <code>rememberLottieComposition</code> 并传入 <code>spec</code> 来记住组合状态。最后，可以将此状态传递给 <code>LottieAnimation</code> 以显示动画。</p>

<pre><code class="kotlin">val lottieCompositionSpec = LottieCompositionSpec.JsonString(JSON_STRING)
val lottieComposition = rememberLottieComposition(
    spec = lottieCompositionSpec
)
LottieAnimation(composition = lottieComposition.value)

const val JSON_STRING = "{\"v\":\"4.10.1\",...\"bm\":0}]}"
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:280/format:webp/1*pILmCNmRVMiswfyiq3yviw.gif" alt="Lottie动画来自 https://github.com/airbnb/lottie-android" /></p>

<p>现在，将动画存储在字符串中并非最易读或可持续的方式，更好的选择是使用Lottie JSON文件。一种方法是将其存储在assets目录中……</p>

<h2>Asset文件</h2>

<p>我们可以将Lottie文件存储为<code>.json</code>或<code>.lottie</code>文件（它们是同一种文件，只是扩展名不同），并将其存储在<code>app/assets</code>目录中。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*RYfpCujExeKM_FC0XOedPA.png" alt="" /></p>

<p>这里唯一的区别是我们需要使用 <code>LottieCompositionSpec.Asset(val assetName: String)</code> 并传递 <code>assets</code> 目录下的路径（你可以根据需要进行组织）。</p>

<pre><code class="kotlin">val lottieCompositionSpecLottieFile = LottieCompositionSpec.Asset("animations/android_wave.lottie")
val lottieCompositionSpecJsonFile = LottieCompositionSpec.Asset("animations/android_wave.json")
</code></pre>

<p>类似地，我们可以使用 <code>LottieCompositionSpec.File(val fileName: String)</code> 从设备文件系统中的任何位置加载动画文件——只需确保应用程序已获得该文件的访问权限即可！</p>

<p>使用资源文件意味着我们无法获得编译时保护来确保文件存在，但我们可以使用 <code>res/raw</code> 目录。</p>

<h2>原始资源文件</h2>

<p>同样，这很简单，只需将文件添加到 <code>raw</code> 目录即可：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*I0jHURry7W04WUibyHvunA.png" alt="" /></p>

<p>现在，我们可以通过使用 <code>LottieCompositionSpec.RawRes</code> 和 <code>R.raw</code> 访问原始资源，从而获得编译时安全性。</p>

<pre><code class="kotlin">val lottieCompositionSpec = LottieCompositionSpec.RawRes(R.raw.android_wave)
</code></pre>

<p>最后，如果我们希望在需要时动态获取 Lottie 文件，而不是将其打包到应用程序中，我们可以从 URL 加载它。</p>

<h2>URL 来源</h2>

<p>与上述类似，我们可以使用 <code>LottieCompositionSpec.Url</code> 加载以 URL 形式存储的 Lottie 文件：</p>

<pre><code class="kotlin">val lottieCompositionSpec = LottieCompositionSpec.Url("https://url/AndroidWave.json")
</code></pre>

<p>如果一切顺利，用户网络连接良好，这当然很好，但我们需要确保能够处理任何错误。</p>

<h3>错误响应和添加加载状态</h3>

<p>动画加载也可能需要一些时间，尤其是在动画文件较大或用户网络连接不佳的情况下。为此，我们可以使用 <code>LottieCompositionResult</code> 来检测动画的状态。</p>

<p>当动画正在下载或解析时，<code>LottieCompositionResult.isLoading</code> 将为 true；当解析成功且合成已准备好显示时，<code>LottieCompositionResult.isSuccess</code> 将为 true。我们还有两个状态：<code>LottieCompositionResult.isComplete</code>，当 <code>isLoading</code> 为 false 时（无论组合是否成功），它将为 true；最后是 <code>LottieCompositionResult.isFailure</code>，当出现不可恢复的错误时（即下文讨论的 <code>onRetry</code> lambda 返回 <code>false</code> 时），它将为 true。</p>

<p>为了展示标准的加载、错误和成功行为，我们可以像这样使用 <code>isLoading</code> 和 <code>isSuccess</code>：</p>

<pre><code class="kotlin">if (lottieComposition.isLoading) {
    Box(
        contentAlignment = Alignment.Center,
        modifier = Modifier.height(100.dp)
    ) {
        CircularProgressIndicator()
    }
} else if (lottieComposition.isSuccess) {
    LottieAnimation(
        composition = lottieComposition.value,
        modifier = Modifier.height(100.dp)
    )
} else {
    Image(
        imageVector = Icons.Filled.Error,
        contentDescription = null,
        modifier = Modifier.height(100.dp)
    )
}
</code></pre>

<h3>重试动画加载错误</h3>

<p>Lottie 提供了一种简单易用的方法，可以使用 <code>rememberLottieComposition</code> 中的 <code>onRetry</code> 来重试动画加载。我们可以通过两种方式使用它：</p>

<p><strong>反复重试直到达到某个限制</strong></p>

<p>在构造 <code>rememberLottieComposition</code> 时，我们可以指定 <code>onRetry</code> lambda，并返回 <code>true</code> 以继续重试，返回 <code>false</code> 以停止重试。 <code>onRetry</code> 包含一个 <code>failCount</code> 参数。这允许应用重试次数限制或指数退避。例如：</p>

<pre><code class="kotlin">val lottieComposition = rememberLottieComposition(
    spec = lottieCompositionSpec,
    onRetry = { failCount, exception -&gt;
        Timber.d(exception, "Error loading animation: ${exception.message}")
        failCount &lt; 5
    }
)
</code></pre>

<p>这里我将动画设置为重试 5 次后停止。你可以在此 lambda 表达式中添加错误消息或其他任何有用的信息（但请使用上面描述的 <code>LottieCompositionResult.isLoading</code> 布尔值来显示加载行为，而不是在此处设置另一个变量）。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:280/format:webp/1*d9gomTwO-kr5K9mufbMinA.gif" alt="" /></p>

<p><strong>等待重试信号</strong></p>

<p>我们还可以允许动画等待重试，直到某个外部条件发生变化，例如按下按钮或恢复网络连接。</p>

<p>为此，我们使用 <code>rememberLottieRetrySignal</code>。</p>

<pre><code class="kotlin">val retrySignal = rememberLottieRetrySignal()
var url by remember { mutableStateOf("https://bad/url") }
val lottieCompositionSpec = LottieCompositionSpec.Url(url)
val lottieComposition = rememberLottieComposition(
    spec = lottieCompositionSpec,
    onRetry = { _, exception -&gt;
        Timber.d(exception, "Error loading animation: ${exception.message}")
        retrySignal.awaitRetry()
        false
    }
)
Column(...) {
    if (lottieComposition.isLoading) {
        ...
    } else if (lottieComposition.isSuccess) {
        LottieAnimation(
            composition = lottieComposition.value,
            modifier = Modifier.height(100.dp)
        )
    } else {
        ...
    }
    TextButton(onClick = {
        url = "https://url/AndroidWave.json"
        retrySignal.retry()
    }) {
        Text("Fix url &amp; retry")
    }
}
</code></pre>

<p>在这个简单的示例中，我将 URL 设置为无效 URL，然后在 <code>onRetry</code> 中，当发生错误时，我们可以使用记住的 <code>retrySignal</code> 来等待重试。 <code>retrySignal.awaitRetry()</code>。动画将保持加载状态，直到按钮点击时调用 <code>retrySignal.retry()</code>。如果你不希望保持加载状态，而是希望在重试之前显示错误信息，你可以完全省略 <code>retrySignal</code>，并更新已记住的 <code>url</code> 状态，这样 <code>LottieCompositionSpec</code> 将重新组合。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:280/format:webp/1*HZRs6-0_sZxmXImH999iVA.gif" alt="" /></p>

<h2>动画配置</h2>

<p>最后，动画加载正确后，我们可以使用一些其他配置项来优化动画效果。</p>

<p>虽然最好在 Lottie 文件本身（创建时完成）中控制这些动画行为，但你也可以通过以下方式调整动画的播放方式： <code>LottieAnimation</code> 本身是可组合的。要了解其功能，最好查看一些可用参数：</p>

<pre><code class="kotlin">// An excerpt from version 6.6.6 of the SDK
@Composable
fun LottieAnimation(
    clipSpec: LottieClipSpec? = null,
    speed: Float = 1f,
    iterations: Int = 1,
    reverseOnRepeat: Boolean = false,
    alignment: Alignment = Alignment.Center,
    contentScale: ContentScale = ContentScale.Fit,
    ... // + others for more advanced use, check out the SDK documentation
) {}
</code></pre>

<p>在这里，我们可以控制：</p>

<ul>
<li><p><code>clipSpec</code>：动画播放的帧</p></li>
<li><p><code>speed</code>：动画速度</p></li>
<li><p><code>iterations</code>：动画运行次数（使用 <code>LottieConstants.IterateForever</code> 可无限循环）</p></li>
<li><p><code>reverseOnRepeat</code>：循环播放后反向播放</p></li>
<li><p><code>alignment</code> 和 <code>contentScale</code>：就像图像一样，我们可以调整动画在指定范围内的布局。</p></li>
</ul>


<p>现在你可以了解 Lottie 的所有用法，请务必为你正在开发的应用程序选择最佳方案，并选择最便捷的方式从你的设计团队获取文件，而无需费力地在不同文件格式之间进行转换。</p>

<p>再见！现在！</p>

<p><img src="https://miro.medium.com/v2/resize:fit:600/1*AbjuxEFO34XUsPCAs-U-Kw.gif" alt="" /></p>

<p>你可以在我的 GitHub 仓库的 <a href="https://github.com/KatieBarnett/Experiments/tree/main/jc-lottie">jc-lottie</a> 模块中找到上述示例代码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jetpack Compose 2025年12月版本新增功能]]></title>
    <link href="https://alexhilton.github.io/blog/2025/12/18/compose-december-2025/"/>
    <updated>2025-12-18T00:00:00+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/12/18/compose-december-2025</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「What&rsquo;s new in the Jetpack Compose December &lsquo;25 release」，原文链接<a href="https://android-developers.googleblog.com/2025/12/whats-new-in-jetpack-compose-december.html">https://android-developers.googleblog.com/2025/12/whats-new-in-jetpack-compose-december.html</a>，由Nick Butcher发布于2025年12月3日。</p></blockquote>

<p><a href=""><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjaOFQLkqCBaw0FA8C7XCI7gKe-Z79r2dYH9QUOnWyZq_Qevh-EoHqRs6zTENmzLjHwKk_ECQlN_2EePI8-JyjCVH3PL2rOsbRdfKNZ6T" title="auto auto" ></a></p>

<!-- more -->


<p>现在，<a href="https://developer.android.com/jetpack/androidx/releases/compose">Jetpack Compose 2025年12月版本</a> 正式发布。该版本包含 Compose 核心模块 1.10 版和 Material 3 1.4 版（参见完整的 <a href="https://developer.android.com/develop/ui/compose/bom/bom-mapping">BOM 映射</a>），新增了多项功能并显著提升了性能。</p>

<p>要使用最新的版本，请将 Compose BOM 版本升级到 2025.12.00：</p>

<pre><code class="kotlin">implementation(platform("androidx.compose:compose-bom:2025.12.00"))
</code></pre>

<h2>性能改进</h2>

<p>我们知道应用程序的运行时性能对你和你的用户至关重要，因此性能一直是 Compose 团队的首要任务。此版本带来了一系列改进——你只需升级到最新版本即可获得所有这些改进。我们的内部滚动性能基准测试表明，Compose 现在的性能与使用 Views 时的性能相当：</p>

<p><img src="https://blogger.googleusercontent.com/img/a/AVvXsEhmNWZbGEVpwg-kdd6kw9Ay8TyOjGS226GxU1oNQQCI0IBJ1aj_Pze-SQ0z9LGywbdbzIROkIv6hxKKMIXJ0sBs-q5U_cv-yslsXFRzdRihM0MxWI3q2j-LURfcILGe7i9KodgjuGgUkAoeeZspHUa11iDkAiJTs295rxSDtgSWK0VSEofLt2MWburL7II" alt="滚动性能基准测试比较了 Views 和 Jetpack Compose 在不同 Compose 版本下的性能" /></p>

<h3>延迟预取中的可暂停组合</h3>

<p>延迟预取中的可暂停组合预取功能现已默认启用。这是 Compose 运行时调度机制的一项根本性变革，旨在显著减少高 UI 负载下的卡顿现象。</p>

<p>此前，一旦合成开始，就必须运行至完成。如果合成较为复杂，则可能导致主线程阻塞超过一帧，从而造成 UI 卡顿。而现在，借助可暂停合成功能，运行时可以在时间不足时“暂停”其工作，并在下一帧恢复。当与延迟布局预取结合使用，提前准备帧时，此功能尤为有效。 Compose 1.9 中引入的 LazyLayout<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/lazy/package-summary#rememberLazyListState(androidx.compose.foundation.lazy.layout.LazyLayoutCacheWindow,kotlin.Int,kotlin.Int)">CacheWindow</a> API 可以很好地预取更多内容，并利用可暂停的合成功能来显著提升 UI 性能。</p>

<p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhaE5BKUo2mBxNKAmgD8nnrrbooEAbjCSxsGJbJx6DgTmMPx8BmTWsOg2I2_FXcOODSG8OAX31ueJfgipH2zdF1Y3v6CcIXGW3mWiWcHbemqnmVO-IYWKVJ-V6CiD9LDo_35nqyWrDgK3Y_HOdUDfL8StGnfgg34Ia6wda1bXoDT3xhMQb8w2hn_d2gLhQ/s16000/pausable.gif" alt="可暂停合成结合延迟预取有助于减少卡顿" /></p>

<p>我们还优化了其他方面的性能，例如改进了 Modifier.onPlaced。 Modifier.onVisibilityChanged 和其他修饰符实现。我们将继续投入资源来提升 Compose 的性能。</p>

<h2>新功能</h2>

<h3>Retain</h3>

<p>Compose 提供了一系列 API 来跨不同的生命周期保存和管理状态；例如，<code>remember</code> 可以在组合之间持久化状态，而 <code>rememberSavable</code>/<code>rememberSerializable</code> 可以在 Activity 或进程重建之间持久化状态。<code>retain</code> 是一个介于这些 API 之间的新 API，它允许你在配置更改时持久化值而无需序列化，但不会跨进程终止。由于 <code>retain</code> 不会序列化你的状态，因此你可以持久化诸如 lambda 表达式、流程以及位图等难以序列化的大型对象。例如，你可以使用 <code>retain</code> 来管理媒体播放器（例如 ExoPlayer），以确保媒体播放不会因配置更改而中断。</p>

<pre><code class="kotlin">@Composable
fun MediaPlayer() {
    val applicationContext = LocalContext.current.applicationContext
    val exoPlayer = retain { ExoPlayer.Builder(applicationContext).apply { ... }.build() }
    ...
}
</code></pre>

<p>我们要感谢 AndroidDev 社区（特别是 <a href="https://slackhq.github.io/circuit">Circuit</a> 团队），他们对该功能的设计产生了影响并做出了贡献。</p>

<h3>Material 1.4</h3>

<p>Material3 库的 1.4.0 版本新增了一些组件和增强功能：</p>

<ul>
<li><p>TextField 现在提供了一个基于 TextFieldState 的实验性版本，它提供了一种 <a href="https://developer.android.com/develop/ui/compose/text/user-input">更强大的</a> 方法来管理文本状态。此外，还新增了变体SecureTextField 和 OutlinedSecureTextField。Material Text 可组合元素现在支持自动调整大小功能（autoSize）。</p></li>
<li><p>轮播组件现在提供了一个新的 <a href="https://developer.android.com/reference/kotlin/androidx/compose/material3/carousel/package-summary#Horizo%E2%80%8B%E2%80%8BntalCenteredHeroCarousel(androidx.compose.material3.carousel.CarouselState,androidx.compose.ui.Modifier,androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp,androidx.compose.foundation.gestures.TargetedFlingBehavior,kotlin.Boolean,androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp,androidx.compose.foundation.layout.PaddingValues,kotlin.Function2)">Horizo​​ntalCenteredHeroCarousel</a><a href="https://m3.material.io/components/carousel/specs">variant</a>。</p></li>
<li><p><a href="https://developer.android.com/reference/kotlin/androidx/compose/material3/package-summary?_gl=1*1h4dj5y*_up*MQ..*_ga*NDE1MzI0NzAwLjE3NjQ2MTM1MzU.*_ga_6HH9YJMN9M*czE3NjQ2MTM1MzQkbzEkZzAkdDE3NjQ2MTM1MzQkajYwJGwwJGgxODIyOTM4OTMy#TimePicker(androidx.compose.material3.TimePickerState,androidx.compose.ui.Modifier,androidx.compose.material3.TimePickerColors,androidx.compose.material3.TimePickerLayoutType)">TimePicker</a> 现在支持在选择器模式和输入模式之间切换。</p></li>
<li><p>垂直拖拽手柄（<a href="https://developer.android.com/reference/kotlin/androidx/compose/material3/package-summary#VerticalDragHandle(androidx.compose.ui.Modifier,androidx.compose.material3.DragHandleSizes,androidx.compose.material3.DragHandleColors,androidx.compose.material3.DragHandleShapes,androidx.compose.foundation.interaction.MutableInteractionSource)">VerticalDragHandle</a>）帮助用户更改自适应空格的大小或者位置。</p></li>
</ul>


<p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhTrvNyW_IJgSIqBWYlzweN3mkoZ_Uc3IMNj2Pu0cC1VdVqnja4nHA6kSCO2nk44MBi2diWEPu_oe0ozm2Jxh5jjXyJ7uqHdrdkyTrDaCgIifMpHLK9q3stUhD79QuLc7q_V4EisrNR7t4I3SMAxSq57EVzk8PGqiouXPRc-wI9Pu03vbuDU3_rnrA4THc/s16000/centered-hero-carousel.gif" alt="Horizontal centered hero carousel" /></p>

<p>请注意，<a href="https://m3.material.io/blog/building-with-m3-expressive">Material 3 Expressive</a> API 仍在 Material 3 库的 alpha 版本中持续开发。要了解更多信息，请观看<a href="https://www.youtube.com/embed/t9rrsqfB2tM">最近的演讲</a>。</p>

<h2>新的动画功能</h2>

<p>我们持续扩展动画 API，包括对自定义共享元素动画的更新。</p>

<h3>动态共享元素</h3>

<p>默认情况下，<code>sharedElement()</code> 和 <code>sharedBounds()</code> 动画会在目标状态中找到匹配的键时尝试为布局更改添加动画效果。但是，你可能希望根据某些条件（例如导航方向或当前 UI 状态）动态禁用​​此动画。</p>

<p>要控制共享元素过渡是否发生，你现在可以自定义传递给 <code>rememberSharedContentState()</code> 的 <code>SharedContentConfig</code>。<code>isEnabled</code> 属性决定共享元素是否处于活动状态。</p>

<pre><code class="kotlin">SharedTransitionLayout {
    val transition = updateTransition(currentState)
    transition.AnimatedContent { targetState -&gt;
        // Create the configuration that depends on state changing.
        fun animationConfig() : SharedTransitionScope.SharedContentConfig {
            return object : SharedTransitionScope.SharedContentConfig {
                override val SharedTransitionScope.SharedContentState.isEnabled: Boolean
                        get() =
                            // determine whether to perform a shared element transition
                }
            }
}
</code></pre>

<p>更多信息，请参阅<a href="https://developer.android.com/develop/ui/compose/animation/shared-elements/customize#dynamic-enable-disable">文档</a>。</p>

<h3>Modifier.skipToLookaheadPosition()</h3>

<p>此版本新增了一个修饰符 <a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/SharedTransitionScope?hl=en#(androidx.compose.ui.Modifier).skipToLookaheadPosition(kotlin.Function0)">Modifier.skipToLookaheadPosition()</a>，用于在执行共享元素动画时保持可组合元素的最终位置。这使得可以执行类似“揭示”类型的过渡动画，例如 Androidify 示例中相机的渐进式揭示效果。更多信息，请参阅<a href="https://www.youtube.com/embed/0moEXBqNDZI">此处的视频提示</a>。</p>

<h3>共享元素过渡中的初始速度</h3>

<p>此版本新增了一个共享元素过渡 API：<code>prepareTransitionWithInitialVelocity</code>，允许你将初始速度（例如来自手势）传递给共享元素过渡：</p>

<pre><code class="kotlin">Modifier.fillMaxSize()
    .draggable2D(
            rememberDraggable2DState{offset+=it},
            onDragStopped = { velocity -&gt;
                // Set up the initial velocity for the upcoming shared element
                // transition.
              sharedContentStateForDraggableCat?.prepareTransitionWithInitialVelocity(velocity)
                showDetails = false
            },
)
</code></pre>

<p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi-XdYTEA7H5BokZRoo_npAvjuSLPP3cXifTSHtonoHiuQVtav1w9ZKhIqlxQJKeX9AxyQnR0HjSe3t1Sy02jdMYiWI_mg1VoJST55CAKgBtkvHpgRatXJobhPVoimLQCJ-F6dfLRDt75vJANi46D4MhobglqRG7rSFb3VqglLcE6rNLx3c02Vzqiqr6IY/w288-h640/fling-shared.gif" alt="一个以初始速度开始的共享元素过渡，该初始速度来自手势" /></p>

<h3>面纱过渡动画</h3>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/EnterTransition">EnterTransition</a> 和 <a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/ExitTransition?_gl=1*1m00og2*_up*MQ..*_ga*MjU3NDMyNzc5LjE3NjQ2MTE4NjM.*_ga_6HH9YJMN9M*czE3NjQ2MTE4NjMkbzEkZzAkdDE3NjQ2MTE4NjMkajYwJGwwJGgxMTk2NzM1MDk0">ExitTransition</a> 定义了动画的执行方式。 <a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#AnimatedVisibility">AnimatedVisibility</a>/ <a href="https://developer.android.com/refe%20rence/kotlin/androidx/compose/animation/package-summary#AnimatedContent">AnimatedContent</a> 可组合元素出现或消失。新增的实验性遮罩选项允许你指定颜色来遮盖或修饰内容；例如，在内容上方淡入/淡出半透明黑色图层：</p>

<p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhemyKNMNnK50HVISQJlCz4fXPkkckq-ZdOgB3f8dolMzDe6UgCGq3_nVQhdfNb8au6cL00LHR0EJIQqxOQnnCXNSs8284eIMGroEp1V_F48JHkIk_kzPiYAov-nI3LAIG0_XXNjVQUIXwDvgH_rdMgF9wn_u605WU8oOD-uW-MSVKUHzyekqYsnFrEqms/w304-h640/veil_2.gif" alt="带遮蔽的动画内容 – 注意在动画过程中覆盖在网格内容上的半透明遮蔽层（或幕布）动画" /></p>

<pre><code class="kotlin">AnimatedContent(
    targetState = page,
    modifier = Modifier.fillMaxSize().weight(1f),
    transitionSpec = {
         if (targetState &gt; initialState) {
            (slideInHorizontally { it } togetherWith
                    slideOutHorizontally { -it / 2 } + veilOut(targetColor = veilColor))
        } else {
            slideInHorizontally { -it / 2 } +
                        unveilIn(initialColor = veilColor) togetherWith slideOutHorizontally { it }
        }
    },
) { targetPage -&gt;
    ...
}
</code></pre>

<h2>即将发生的变更</h2>

<h3>弃用 Modifier.onFirstVisible</h3>

<p>Compose 1.9 引入了 <a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#%28androidx.compose.ui.Modifier%29.onVisibilityChanged%28kotlin.Long,kotlin.Float,androidx.compose.ui.layout.LayoutBoundsHolder,kotlin.Function1%29">Modifier.onVisibilityChanged</a> 和 <a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#%28androidx.compose.ui.Modifier%29.onFirstVisible%28kotlin.Long,kotlin.Float,androidx.compose.ui.layout.LayoutBoundsHolder,kotlin.Function0%29">Modifier.onFirstVisible</a>。在审阅了你的反馈后，我们发现 <code>Modifier.onFirstVisible</code> 的约定无法确定性地执行；具体来说，就是无法确定某个元素何时首次可见。例如，Lazy 布局可能会释放滚动出视口的元素，然后在它们滚动回视口时重新组合它们。在这种情况下，<code>onFirstVisible</code> 回调会再次触发，因为它是一个新组合的元素。当导航回之前访问过的包含 <code>onFirstVisible</code> 的屏幕时，也会出现类似的行为。因此，我们决定在下一个 Compose 版本（1.11）中弃用此修饰符，并建议迁移到 <code>onVisibilityChanged</code>。有关更多信息，请参阅<a href="https://developer.android.com/develop/ui/compose/layouts/visibility-modifiers">文档</a>。</p>

<h3>测试中的协程分发</h3>

<p>我们计划更改测试中的协程分发，以改善测试的稳定性并捕获更多问题。目前，测试使用的是 UnconfinedTestDispatcher，这与生产环境的行为有所不同；例如，<a href="https://developer.android.com/develop/ui/compose/side-effects">副作用</a>可能会立即运行，而不是被放入队列。在未来的版本中，我们计划引入一个新的 API，默认使用 StandardTestDispatcher，以匹配生产环境的行为。你现在可以在 1.10 版本中尝试新的行为：</p>

<pre><code class="kotlin">@get:Rule // also createAndroidComposeRule, createEmptyComposeRule
val rule = createComposeRule(effectContext = StandardTestDispatcher())
</code></pre>

<p>使用 StandardTestDispatcher 会将任务放入队列，因此你必须使用同步机制，例如 composeTestRule.waitForIdle() 或 composeTestRule.runOnIdle()。如果你的测试使用了 runTest，则必须确保 runTest 和你的 Compose 规则共享同一个 StandardTestDispatcher 实例以进行同步。</p>

<pre><code class="kotlin">// 1. Create a SINGLE dispatcher instance
valtestDispatcher = StandardTestDispatcher()

// 2. Pass it to your Compose rule
@get:Rule
valcomposeRule = createComposeRule(effectContext = testDispatcher)

@Test
// 3. Pass the *SAME INSTANCE* to runTest
funmyTest() = runTest(testDispatcher) {
    composeRule.setContent{/* ... */}
}
</code></pre>

<h2>工具</h2>

<p>优秀的 API 需要优秀的工具，<a href="http://d.android.com/studio">Android Studio</a> 为 Compose 开发者新增了多项功能：</p>

<ul>
<li><p><a href="https://developer.android.com/studio/preview/features#iterate-ui-agent">变换 UI</a>：右键单击 @Preview，选择“变换 UI”，然后用自然语言描述更改，即可迭代你的设计。</p></li>
<li><p><a href="https://developer.android.com/studio/preview/features#ui-tools-setup">生成 @Preview</a>：右键单击可组合元素，然后选择 Gemini > 生成 [可组合元素名称] 预览。</p></li>
<li><p><a href="https://developer.android.com/studio/preview/features#material-symbols-support">自定义 Material Symbols</a>：矢量资源向导新增了对图标变体的支持。</p></li>
<li><p><a href="https://developer.android.com/studio/preview/features#screen-to-code-agent">从屏幕截图生成代码</a> 或让 Gemini <a href="https://developer.android.com/studio/preview/features#match-ui-agent">将你现有的 UI 与目标图像匹配</a>。这可以与远程 <a href="https://developer.android.com/studio/preview/features#remote-mcp">MCP 支持</a> 结合使用，例如连接到 Figma 文件并从设计生成 Compose UI。</p></li>
<li><p><a href="https://developer.android.com/studio/preview/features#find-and-fix-ui-quality-issues">修复 UI 质量问题</a> 会审核你的 UI 是否存在常见问题，例如辅助功能问题，然后提出修复方案。</p></li>
</ul>


<p>要查看这些工具的实际应用，请观看此 <a href="https://www.youtube.com/embed/jTlW8JeCClA">最新演示</a>。</p>

<h2>尽情创作</h2>

<p>我们持续投入资源开发 Jetpack Compose，为你提供创建美观、丰富的用户界面所需的 API 和工具。我们重视你的反馈，请在我们的<a href="https://issuetracker.google.com/issues/new?component=612128">问题跟踪器</a>中分享你对这些更改的反馈，或你希望看到的后续功能。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[借助RemoteCompose开发动态化页面]]></title>
    <link href="https://alexhilton.github.io/blog/2025/12/11/intro-to-remotecompose/"/>
    <updated>2025-12-11T00:00:00+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/12/11/intro-to-remotecompose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「RemoteCompose: Another Paradigm for Server-Driven UI in Jetpack Compose」，原文链接<a href="https://proandroiddev.com/remotecompose-another-paradigm-for-server-driven-ui-in-jetpack-compose-92186619ba8f">https://proandroiddev.com/remotecompose-another-paradigm-for-server-driven-ui-in-jetpack-compose-92186619ba8f</a>，由Jaewoong Eum发布于2025年11月29日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:2000/0*o9-kxXHKgJcB-Bvh" title="auto auto" ></a></p>

<!-- more -->


<p>构建动态用户界面一直是 Android 开发中的一项根本性挑战。传统方法要求每次 UI 需要更改时都必须重新编译和重新部署整个应用程序，这给 A/B 测试、功能开关和实时内容更新带来了极大的不便。</p>

<p>试想一下，你的营销团队想要测试一个新的结账按钮设计：在传统模式下，这种简单的更改需要开发人员花费时间、进行代码审查、QA 测试、提交到应用商店，以及等待数周才能获得用户采纳。RemoteCompose 的出现为解决这一问题提供了一个强大的方案，它使开发人员能够在运行时创建、传输和渲染 Jetpack Compose UI 布局，而无需重新编译。</p>

<p>本文将探讨 RemoteCompose 的概念，理解其核心架构，并探索它如何为 Jetpack Compose 的动态页面设计带来诸多优势。本文并非库的使用教程，而是着重探讨它所代表的 Android UI 开发范式转变。</p>

<h3><strong>集成与依赖</strong></h3>

<p>在深入探讨概念之前，我们先来了解如何将 RemoteCompose 添加到你的项目中。对于运行在 JVM 上且不依赖 Android 的服务器和后端：</p>

<pre><code class="groovy">// settings.gradle
repositories {
  maven {
    url = uri("https://androidx.dev/snapshots/builds/14511716/artifacts/repository")
  }
}

// JVM server - no Android dependencies
dependencies {
    implementation("androidx.compose.remote:remote-core:1.0.0-SNAPSHOT")
    implementation("androidx.compose.remote:remote-creation-compose:1.0.0-SNAPSHOT")
}

// Compose-based app
dependencies {
    implementation("androidx.compose.remote:remote-player-compose:1.0.0-SNAPSHOT")
    implementation("androidx.compose.remote:remote-tooling-preview:1.0.0-SNAPSHOT")
}

// View-based app
dependencies {
    implementation("androidx.compose.remote:remote-player-view:1.0.0-SNAPSHOT")
}
</code></pre>

<p>请注意，RemoteCompose 仍在由 AndroidX 团队开发中，尚未正式发布；它仅可通过 AndroidX 快照 Maven 仓库获取。</p>

<h3>理解核心抽象</h3>

<p>RemoteCompose 的核心是一个框架，它支持 Compose UI 组件的远程渲染。它与传统 UI 方法的区别在于它遵循两个基本原则：声明式文档序列化和平台无关渲染。这些不仅仅是技术特性；这些架构决策从根本上改变了你对 UI 部署的思考方式。</p>

<p><strong>声明式文档序列化</strong></p>

<p>声明式文档序列化意味着你可以将任何 Jetpack Compose 布局捕获为紧凑的序列化格式。你可以把它想象成对 UI 进行“截图”，只不过你捕获的不是像素，而是实际的绘图指令。这个捕获的文档包含了重建 UI 所需的一切：形状、颜色、文本、图像、动画，甚至还有交互式触摸区域。</p>

<pre><code class="kotlin">// On the server or creation side
val document = captureRemoteDocument(
    context = context,
    creationDisplayInfo = displayInfo,
    profile = profile
) {
    RemoteColumn(modifier = RemoteModifier.fillMaxSize()) {
        RemoteText("Dynamic Content")
        RemoteButton(onClick = { /* action */ }) {
            RemoteText("Click Me")
        }
    }
}
</code></pre>

<p>结果如何？一个可以通过网络发送的字节数组。这种方法的关键在于，创建端编写的是标准的 Compose 代码。无需学习新的 DSL，无需维护 JSON 模式，也无需掌握模板语言。只要可以用 Compose 编写，就可以用 RemoteCompose 捕获。</p>

<p>你可以捕获一个普通的 Compose 代码，它会捕获绘制调用（这些调用非常静态）。更常见的情况是，你应该拥有镜像 Compose 的 Remote* 专用 API，这些 API 专为序列化和远程播放而设计，例如 <code>RemoteColumn</code>、<code>RemoteButton</code>、<code>RemoteText</code> 等。</p>

<p><strong>平台无关渲染</strong></p>

<p>平台无关渲染意味着捕获的文档可以通过网络传输，并在任何 Android 设备上渲染，而无需原始的 Compose 代码。客户端设备不需要你的可组合函数、视图模型或业务逻辑——它只需要文档字节和一个播放器。</p>

<pre><code class="kotlin">// On the client or player side
RemoteDocumentPlayer(
    document = remoteDocument.document,
    documentWidth = windowInfo.containerSize.width,
    documentHeight = windowInfo.containerSize.height,
    onAction = { actionId, value -&gt;
        // Handle user interactions
    }
)
</code></pre>

<p>这些特性并非仅仅是为了方便；它们是架构约束，能够真正实现 UI 定义与部署的解耦。文档格式不仅包含静态布局，还包含状态、动画和交互，从而完整地呈现了 UI 体验。</p>

<p><strong>​​方法比较：为什么不选择 JSON 或 WebView？</strong></p>

<p>在深入探讨之前，我们有必要了解 RemoteCompose 为什么选择这种方法而不是其他方案。</p>

<p>基于 JSON 的服务器端 UI，例如 Airbnb 的 Epoxy 或 Shopify 的方法，需要定义一个映射到原生组件的模式。这种方法适用于结构化内容，但难以处理复杂的动画和过渡效果、自定义绘图和图形、带有内联样式的富文本以及渐变和阴影等视觉效果。</p>

<p>WebView 提供了全面的灵活性，但由于其独立的渲染过程，会带来性能开销；此外，Web 样式与原生设计在外观和体验上存在不一致；每个 WebView 都会占用大量资源，造成内存压力；触摸处理也较为复杂，容易出现手势冲突。</p>

<p>RemoteCompose 另辟蹊径：捕获 Compose 实际执行的绘制操作。这意味着，你可以使用 Compose 构建的任何 UI，包括自定义 Canvas 绘制、复杂动画和 Material Design 组件，都可以被捕获并以原生性能远程重放。</p>

<h3><strong>基于文档的架构：创建与回放</strong></h3>

<p>RemoteCompose 的架构围绕着两个阶段的清晰分离而构建：文档创建和文档回放。理解这种分离是理解框架强大功能的关键。</p>

<p><strong>文档创建：将 UI 作为数据捕获</strong></p>

<p>创建阶段将 Compose UI 代码转换为序列化文档。这是通过捕获机制实现的，该机制会在 Canvas 层（Android 渲染管线的最底层）拦截绘制操作。</p>

<pre><code class="kotlin">@Composable Content
        ↓
RemoteComposeCreationState (Tracks state and modifiers)
        ↓
CaptureComposeView (Virtual Display - no actual screen needed)
        ↓
RecordingCanvas (Intercepts every draw call)
        ↓
Operations (93+ operation types covering all drawing primitives)
        ↓
RemoteComposeBuffer (Efficient binary serialization)
        ↓
ByteArray (Network-ready, typically 10-100KB for complex UIs)
</code></pre>

<p>创建端提供了一个完整的 Compose 集成层。你只需编写标准的 <code>@Composable</code> 函数，框架即可捕获所有内容：布局层级、修饰符、文本样式、图像、动画，甚至触摸处理程序。</p>

<p>其独特之处在于，捕获的文档是自包含的。它包含形状、颜色、渐变和阴影等视觉元素，以及带有字符串、字体、大小和样式的文本。图像可以嵌入为位图或 URL 以实现延迟加载。布局信息涵盖大小、位置、内边距和对齐方式。交互定义了触摸区域、点击处理程序和命名操作。状态变量可以在运行时更新，动画则通过基于时间的运动表达式来表达。</p>

<p>接收方无需访问你的代码库，只需访问文档字节即可。这与其他服务器驱动的 UI 方法有着本质区别，在其他方法中，客户端需要理解架构或拥有预构建的组件。</p>

<p><strong>文档播放：无需编译即可渲染</strong></p>

<p>播放阶段接收序列化的文档并将其渲染到屏幕上。播放器会遍历一系列操作，对 Canvas 执行每个操作。其概念类似于视频播放器解码帧的方式，只不过我们解码的是绘图指令而不是像素。</p>

<p>RemoteCompose 提供两种渲染后端以满足不同的架构需求。基于 Compose 的播放器推荐用于现代应用程序：</p>

<pre><code class="kotlin">@Composable
fun DynamicScreen(document: CoreDocument) {
    RemoteDocumentPlayer(
        document = document,
        documentWidth = screenWidth,
        documentHeight = screenHeight,
        modifier = Modifier.fillMaxSize(),
        onNamedAction = { name, value, stateUpdater -&gt;
            // Handle named actions from the document
            when (name) {
                "addToCart" -&gt; cartManager.addItem(value)
                "navigate" -&gt; navController.navigate(value)
                "trackEvent" -&gt; analytics.logEvent(value)
            }
        },
        bitmapLoader = rememberBitmapLoader()  // For lazy image loading
    )
}
</code></pre>

<p>基于 Compose 的播放器可以自然地与你现有的 Compose UI 集成。它是一个可组合的函数，你可以将其放置在组合层级结构中的任何位置，并像其他可组合函数一样对其应用修饰符和动画。</p>

<p>为了与现有的 View 层级结构兼容，我们还提供了一个基于 View 的播放器：</p>

<pre><code class="kotlin">class LegacyActivity : AppCompatActivity() {
    private lateinit var player: RemoteComposePlayer

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        player = RemoteComposePlayer(this)
        setContentView(player)

        // Load document from network
        lifecycleScope.launch {
            val bytes = api.fetchDocument("home-screen")
            player.setDocument(bytes)
        }

        player.onNamedAction { name, value, stateUpdater -&gt;
            // Handle actions
        }
    }
}
</code></pre>

<p>两种播放器提供相同的渲染保真度；选择哪种取决于你的应用程序架构。如果你完全使用 Compose，请使用可组合播放器。如果你是从 Views 迁移过来的，或者将其嵌入到 View 层级结构中，请使用基于 View 的播放器。</p>

<h3><strong>操作模型：一套全面的绘图词汇表</strong></h3>

<p>RemoteCompose 的优势在于其全面的操作模型。该框架定义了 93 种以上的不同操作，涵盖了 UI 渲染的方方面面。这并非随意设定的数字，而是表达任何 Canvas 绘图操作所需的完整词汇表。</p>

<p><strong>操作的重要性</strong></p>

<p>传统的服务器驱动型 UI 发送的是高级组件描述：“渲染一个带有文本‘提交’的按钮”。客户端必须解析这些描述并将其映射到原生组件。这导致服务器和客户端之间紧密耦合；双方必须就“按钮”的定义及其行为达成一致。</p>

<p>RemoteCompose 则在更底层运行：它不发送“渲染一个按钮”这样的描述，而是发送实际的绘图指令：“在这些坐标处绘制一个带有这种颜色的圆角矩形，然后在这个位置绘制带有这种字体的文本‘提交’”。客户端无需了解“按钮”的定义；它只需执行绘图操作即可。</p>

<p>这种底层方法意义深远。由于服务器和客户端无需就组件定义达成一致，因此无需进行模式同步。由于 Compose 中所有可能的视觉效果均可捕获，因此能够完整保留视觉保真度。由于新的视觉设计可在旧客户端上运行（它们只是不同的绘制操作），因此内置了向前兼容性。自定义组件无需注册即可自动运行。</p>

<p><strong>绘制操作</strong></p>

<p>绘制操作捕获 Canvas 绘制调用，这是 2D 图形的基本图元。这些图元包括：用于按钮、卡片和背景的矩形的 <code>DRAW_RECT</code>；用于带有圆角的 Material 曲面的 <code>DRAW_ROUND_RECT</code>；用于头像和指示器的 <code>DRAW_CIRCLE</code>；用于渲染带有完整样式的文本的 <code>DRAW_TEXT</code>；用于沿曲线绘制文本的 <code>DRAW_TEXT_ON_PATH</code>；以及用于图像的 <code>DRAW_BITMAP</code>。 <code>DRAW_TWEEN_PATH</code> 用于动画路径变形，等等。</p>

<p>每个操作都包含执行它所需的所有信息：坐标、颜色、绘制样式以及对文档中其他位置存储的数据（例如文本字符串或位图）的引用。</p>

<p><strong>布局操作</strong></p>

<p>布局操作定义组件层次结构和空间关系。<code>Component</code> 操作声明一个布局组件，而 <code>Container</code> 操作创建一个类似于 <code>Column</code> 或 <code>Row</code> 的容器，<code>ContainerEnd</code> 操作则关闭它。<code>LoopOperation</code> 操作用于循环列表内容。<code>Modifier</code> 包括用于背景颜色和可绘制对象的 <code>BackgroundModifier</code>、用于边框样式的 <code>BorderModifier</code>、用于内部间距的 <code>PaddingModifier</code> 以及用于触摸处理的 <code>ClickModifier</code>。</p>

<p>容器模型采用推送/弹出机制。当播放器遇到 <code>Container</code> 操作时，它会创建一个新的布局上下文。所有后续操作都将在该上下文中执行，直到 <code>ContainerEnd</code> 操作将其弹出。这与 Compose 的布局系统的工作方式类似。</p>

<p><strong>状态和表达式操作</strong></p>

<p>状态操作支持运行时可更改的动态值。<code>NamedVariable</code> 声明一个命名的状态变量。<code>ColorAttribute</code> 提供可自定义主题的颜色。<code>TimeAttribute</code> 引用动画时间。<code>FloatExpression</code> 和 <code>IntegerExpression</code> 每帧计算数学表达式。<code>ConditionalOp</code> 支持基于状态的条件渲染。</p>

<p>表达式系统功能强大。你可以嵌入公式，而不是静态值：</p>

<pre><code class="kotlin">// These expressions are evaluated every frame
val opacity = FloatExpression("sin(time * 2) * 0.5 + 0.5")  // Pulsing effect
val rotation = FloatExpression("time * 90 % 360")

// Continuous rotation
val position = FloatExpression("lerp(0, 100, time / 2)")

// Linear interpolation
</code></pre>

<p>这使得完全在文档中定义丰富的动画成为可能——无需客户端动画代码。
​​
<strong>交互操作</strong></p>

<p>交互操作处理用户输入。<code>TouchOperation</code> 定义触摸区域，而 <code>CLICK_AREA</code> 处理简单的点击操作。<code>ParticlesCreate</code> 初始化粒子系统，<code>ParticlesLoop</code> 驱动粒子动画。</p>

<p>触摸操作注册带有命名操作的矩形区域。当用户点击某个区域时，播放器会触发相应的操作，宿主应用程序会通过回调函数来处理这些操作。这种设计既保持了文档格式的简洁性，又实现了丰富的交互功能。</p>

<h3>动态屏幕设计的优势</h3>

<p>现在，让我们通过常见应用场景中的真实案例，来探讨 RemoteCompose 为动态屏幕设计带来的切实优势。</p>

<p><strong>服务器驱动 UI，性能毫不妥协</strong></p>

<p>传统的服务器驱动 UI 方法需要权衡取舍。基于 JSON 的布局表达能力有限，无法实现复杂的动画或自定义绘制。WebView 会带来性能开销、外观不一致以及更高的内存占用。自定义 DSL 则会增加维护负担、学习曲线，并且对预定义组件有所限制。</p>

<p>RemoteCompose 提供了第三条路径：从服务器定义的布局进行原生 Compose 渲染。你既能充分利用 Compose 渲染引擎的强大功能，又能享受服务器驱动内容的灵活性。</p>

<p>例如，一个电商应用需要频繁更新产品卡片、添加新的徽章样式、促销叠加层或季节性主题。借助 RemoteCompose，服务器端允许营销团队无需发布应用即可更新卡片设计：</p>

<pre><code class="kotlin">// Server-side: We can update card designs without app release
@Composable
fun ProductCard(product: Product) {
    Card(
        modifier = RemoteModifier
            .fillMaxWidth()
            .clickable { namedAction("viewProduct", product.id) }
    ) {
        Box {
            // Product image with gradient overlay
            AsyncImage(
                url = product.imageUrl,
                modifier = RemoteModifier.fillMaxWidth().aspectRatio(1.5f)
            )

            // Promotional badge - can be A/B tested server-side
            if (product.hasPromotion) {
                PromotionalBadge(
                    text = product.promotionText,
                    modifier = RemoteModifier.align(Alignment.TopEnd)
                )
            }

            // Price with sale styling
            PriceTag(
                originalPrice = product.originalPrice,
                salePrice = product.salePrice,
                modifier = RemoteModifier.align(Alignment.BottomStart)
            )
        }
    }
}
</code></pre>

<p>客户端只需渲染服务器发送的内容：</p>

<pre><code class="kotlin">// Client-side: Just renders whatever the server sends
@Composable
fun ProductGrid(viewModel: ProductViewModel) {
    val documents by viewModel.productDocuments.collectAsState()

    LazyVerticalGrid(columns = GridCells.Fixed(2)) {
        items(documents) { document -&gt;
            RemoteDocumentPlayer(
                document = document,
                onNamedAction = { name, value, _ -&gt;
                    if (name == "viewProduct") {
                        navController.navigate("product/$value")
                    }
                }
            )
        }
    }
}
</code></pre>

<p>现在，你的团队无需发布任何应用即可更新产品卡片设计，更改徽章颜色、添加动画和重新排列元素。由于它是原生应用，通过 Compose 的实际绘制管道渲染，因此 UI 的外观和体验与原生应用无异。</p>

<h3>大规模 A/B 测试</h3>

<p>传统的 A/B 测试 UI 变体需要在应用二进制文件中实现所有变体，为每个变体创建功能标志，发布包含所有变体的应用，然后等待用户采用后再衡量结果。从构思到获得数据，这个过程通常需要 2-4 周。</p>

<p>借助 RemoteCompose，你无需部署任何客户端即可测试 UI 变体。假设一个电商团队想要测试单页结账流程是否比多步骤向导转化率更高：</p>

<pre><code class="kotlin">// Server-side: Two completely different checkout experiences
object CheckoutExperiments {

    fun getCheckoutDocument(user: User, cart: Cart): ByteArray {
        val variant = experimentService.getVariant(user.id, "checkout-flow")

        return when (variant) {
            "single-page" -&gt; captureSinglePageCheckout(cart)
            "multi-step" -&gt; captureMultiStepCheckout(cart)
            "express" -&gt; captureExpressCheckout(cart)  // New variant added without app update
            else -&gt; captureSinglePageCheckout(cart)
        }
    }

    private fun captureSinglePageCheckout(cart: Cart): ByteArray {
        return captureRemoteDocument(context, displayInfo, profile) {
            SinglePageCheckout(
                cart = cart,
                onPlaceOrder = { namedAction("placeOrder", cart.id) },
                onUpdateQuantity = { itemId, qty -&gt;
                    namedAction("updateQuantity", "$itemId:$qty")
                }
            )
        }
    }

    private fun captureMultiStepCheckout(cart: Cart): ByteArray {
        return captureRemoteDocument(context, displayInfo, profile) {
            MultiStepCheckout(
                cart = cart,
                steps = listOf("Shipping", "Payment", "Review"),
                onComplete = { namedAction("placeOrder", cart.id) }
            )
        }
    }
}
</code></pre>

<p>客户端完全不知道显示的是哪个版本：</p>

<pre><code class="kotlin">// Client-side: Completely agnostic to which variant is shown
@Composable
fun CheckoutScreen(viewModel: CheckoutViewModel) {
    val document by viewModel.checkoutDocument.collectAsState()

    document?.let { doc -&gt;
        RemoteDocumentPlayer(
            document = doc,
            onNamedAction = { name, value, stateUpdater -&gt;
                when (name) {
                    "placeOrder" -&gt; viewModel.placeOrder(value)
                    "updateQuantity" -&gt; {
                        val (itemId, qty) = value.split(":")
                        viewModel.updateQuantity(itemId, qty.toInt())
                    }
                }
            }
        )
    }
}
</code></pre>

<p>结果即时且实时，这意味着无需等待应用商店审核或用户反馈。你甚至可以添加全新的版本，例如“快速结账”，而无需对客户端进行任何更改。实验会持续运行，直到获得统计学意义上的显著性，然后将获胜版本推广到所有用户，同样无需发布新应用。</p>

<h3>实时内容更新</h3>

<p>内容密集型应用常常需要在原生性能和内容新鲜度之间寻求平衡。以新闻应用为例：文章需要丰富的格式、嵌入式媒体和交互元素，但同时也需要随着新闻事件的进展实时更新。</p>

<p>一家报道重大事件的新闻机构需要实时更新文章布局。编辑团队可以根据新闻事件的进展调整布局：</p>

<pre><code class="kotlin">// Server-side: Editorial team can update layout as story develops
class ArticleLayoutService {

    fun getArticleDocument(article: Article): ByteArray {
        return captureRemoteDocument(context, displayInfo, profile) {
            ArticleLayout(article)
        }
    }

    @Composable
    private fun ArticleLayout(article: Article) {
        Column(modifier = RemoteModifier.fillMaxSize().padding(16.dp)) {
            // Breaking news banner - can be added/removed instantly
            if (article.isBreaking) {
                BreakingNewsBanner(
                    modifier = RemoteModifier.fillMaxWidth()
                )
            }

            // Headline with dynamic styling
            Text(
                text = article.headline,
                style = if (article.isBreaking) {
                    HeadlineStyle.Breaking
                } else {
                    HeadlineStyle.Standard
                }
            )

            // Live updates indicator
            if (article.hasLiveUpdates) {
                LiveUpdatesIndicator(
                    lastUpdate = article.lastUpdate,
                    modifier = RemoteModifier.clickable {
                        namedAction("refreshArticle", article.id)
                    }
                )
            }

            // Rich content blocks - can include any Compose UI
            article.contentBlocks.forEach { block -&gt;
                when (block) {
                    is TextBlock -&gt; ArticleText(block)
                    is ImageBlock -&gt; ArticleImage(block)
                    is VideoBlock -&gt; VideoEmbed(block)
                    is LiveBlogBlock -&gt; LiveBlogTimeline(block)
                    is InteractiveChartBlock -&gt; DataVisualization(block)
                    is PullQuoteBlock -&gt; PullQuote(block)
                }
            }

            // Related articles - layout can be A/B tested
            RelatedArticles(
                articles = article.relatedArticles,
                onArticleClick = { namedAction("openArticle", it.id) }
            )
        }
    }
}
</code></pre>

<p>客户端只需渲染服务器提供的任何布局：</p>

<pre><code class="kotlin">// Client-side: Renders whatever layout the server sends
@Composable
fun ArticleScreen(articleId: String, viewModel: ArticleViewModel) {
    val document by viewModel.articleDocument.collectAsState()
    val refreshing by viewModel.isRefreshing.collectAsState()

    SwipeRefresh(
        state = rememberSwipeRefreshState(refreshing),
        onRefresh = { viewModel.refresh() }
    ) {
        document?.let { doc -&gt;
            RemoteDocumentPlayer(
                document = doc,
                onNamedAction = { name, value, _ -&gt;
                    when (name) {
                        "openArticle" -&gt; navController.navigate("article/$value")
                        "refreshArticle" -&gt; viewModel.refresh()
                        "playVideo" -&gt; videoPlayer.play(value)
                    }
                }
            )
        }
    }
}
</code></pre>

<p>你的团队无需修改应用即可更新文章布局，添加实时博客时间线、嵌入交互式图表和更改字体。当新闻事件有进展时，他们可以立即在所有相关文章上添加“突发新闻”横幅。</p>

<h3>避免代码膨胀的功能标志</h3>

<p>传统的功能标志需要将所有变体都包含在二进制文件中：</p>

<pre><code class="kotlin">// Traditional approach - all code ships, even unused variations
@Composable
fun HomeScreen() {
    when {
        featureFlags.newHomeV3 -&gt; NewHomeLayoutV3()  // Ships always
        featureFlags.newHomeV2 -&gt; NewHomeLayoutV2()  // Ships always
        else -&gt; OldHomeLayout()

        // Ships always
    }
}
</code></pre>

<p>这会带来几个问题。二进制文件会因为包含所有变体而增加应用程序的大小。即使未使用，也会包含无用代码。当功能标志配置错误时，可能会暴露未发布的功能，从而带来安全风险。随着时间的推移，旧的变体不断累积，导致技术债务不断增加。</p>

<p>使用 RemoteCompose，只会传输当前激活的变体：</p>

<pre><code class="kotlin">// Server-side: Only the active variation exists on the server
class HomeScreenService {
    fun getHomeDocument(user: User): ByteArray {
        return when (featureFlags.getHomeVariant(user)) {
            "v3" -&gt; captureHomeV3(user)
            "v2" -&gt; captureHomeV2(user)
            else -&gt; captureHomeDefault(user)
        }
    }
}

// Client-side: No conditional code, no dead code
@Composable
fun HomeScreen(document: CoreDocument) {
    RemoteDocumentPlayer(document = document)
    // That's it. No feature flags, no conditionals.
}
</code></pre>

<p>这消除了二进制文件膨胀，因为不会传输旧的变体；由于只存在服务器端代码，因此消除了无用代码；并且由于配置错误只会显示不同的 UI 而不是未发布的代码，因此降低了安全风险。</p>

<p>设想一个社交媒体应用正在逐步重新设计其信息流：</p>

<pre><code class="kotlin">// Server-side: Complete control over who sees what
class FeedLayoutService {

    fun getFeedDocument(user: User, posts: List&lt;Post&gt;): ByteArray {
        val variant = rolloutService.getFeedVariant(user)

        return captureRemoteDocument(context, displayInfo, profile) {
            when (variant) {
                FeedVariant.NEW_DESIGN -&gt; NewFeedLayout(posts)
                FeedVariant.NEW_DESIGN_COMPACT -&gt; NewFeedCompactLayout(posts)
                FeedVariant.CLASSIC -&gt; ClassicFeedLayout(posts)
            }
        }
    }
}

// Rollout service controls the percentage
class RolloutService {
    fun getFeedVariant(user: User): FeedVariant {
        // 5% get new design, 5% get compact variant, 90% get classic
        return when {
            user.id.hashCode() % 100 &lt; 5 -&gt; FeedVariant.NEW_DESIGN
            user.id.hashCode() % 100 &lt; 10 -&gt; FeedVariant.NEW_DESIGN_COMPACT
            else -&gt; FeedVariant.CLASSIC
        }
    }

    // Instant rollback if issues are detected
    fun emergencyRollback() {
        // All users immediately get classic layout
        // No app update needed
    }
}
</code></pre>

<p>如果新设计导致问题（例如崩溃、用户互动度下降或用户投诉），可以立即回滚。只需更改服务器配置即可。无需紧急发布应用。</p>

<h3>跨平台一致性</h3>

<p>RemoteCompose 的文档格式与平台无关。同一文档可以在手机、平板电脑、折叠屏设备和 Wear OS 设备上渲染，并由相应的平台播放器负责渲染。</p>

<pre><code class="bash">Creation (Server/Backend)  
    ↓  
RemoteComposeBuffer (Platform-independent binary format)  
    ↓  
┌─────────────────────────────────────────────────────────┐  
│

│
↓

↓

↓

↓
Android Phone

Android Tablet

Foldable Device

Wear OS
(Compose Player) (Compose Player)  (Compose Player)   (Wear Player)
</code></pre>

<p>假设一款健身应用在手机和手表应用上都显示锻炼总结。相同的数据会针对不同的设备尺寸进行优化，呈现不同的内容：</p>

<pre><code class="kotlin">// Server-side: Same data, different presentations
class WorkoutSummaryService {

    fun getPhoneDocument(workout: Workout): ByteArray {
        return captureRemoteDocument(context, phoneDisplayInfo, profile) {
            PhoneWorkoutSummary(workout)  // Full detailed view
        }
    }

    fun getWatchDocument(workout: Workout): ByteArray {
        return captureRemoteDocument(context, watchDisplayInfo, profile) {
            WatchWorkoutSummary(workout)  // Glanceable summary
        }
    }

    @Composable
    private fun PhoneWorkoutSummary(workout: Workout) {
        Column {
            WorkoutHeader(workout)
            HeartRateChart(workout.heartRateData)
            PaceChart(workout.paceData)
            SplitsTable(workout.splits)
            MapView(workout.route)
            ShareButton { namedAction("share", workout.id) }
        }
    }

    @Composable
    private fun WatchWorkoutSummary(workout: Workout) {
        // Optimized for small screen
        Column(modifier = RemoteModifier.fillMaxSize()) {
            Text(workout.type, style = WatchTypography.Title)
            Row {
                StatBox("Duration", workout.duration)
                StatBox("Distance", workout.distance)
            }
            MiniHeartRateIndicator(workout.avgHeartRate)
        }
    }
}
</code></pre>

<p>两款设备都显示锻炼数据，但布局针对各自的设备尺寸进行了优化。任一布局的更新都会立即生效，无需在任一平台上更新应用。</p>

<h3>缩短发布周期</h3>

<p>最显著的优势在于运营层面：UI 更改不再需要发布应用。考虑一下简单 UI 调整的开发周期。</p>

<p>传统方法大约需要两到四周。第一天和第二天是开发人员实现。第三天和第四天用于代码审查和修改。第五天到第七天用于质量保证测试。第八天和第九天处理发布准备和应用商店提交。第十天到第十四天：等待应用商店审核。第十五天到第三十天用户逐步采用，通常两周内会有 50% 到 70% 的用户更新。大多数用户在两到四周内不会看到变化。</p>

<p>RemoteCompose 方法只需一到两天即可完成。第一天和第二天是开发人员在服务器端实现。部署只需几分钟。所有用户都能立即看到变化。</p>

<p>这种速度优势对于节假日促销活动至关重要，你可以根据需要在当天部署季节性主题；对于服务中断的紧急消息，你可以即时更新 UI；对于快速迭代，你可以快速测试想法并快速失败；对于竞争响应，你可以以小时而不是几周的时间对市场变化做出反应。</p>

<p>以一个准备迎接黑色星期五的电商应用为例：</p>

<pre><code class="kotlin">// Traditional approach: Ship all variations weeks in advance
// Problem: All promotional code ships weeks early
// Risk: Date logic bugs could show promotions early
@Composable
fun HomeScreen() {
    val today = LocalDate.now()
    when {
        today == BlackFriday -&gt; BlackFridayHome()

        // Must ship by Oct 15
        today in BlackFridayWeek -&gt; BlackFridayWeekHome()   // Must ship by Oct 15
        today == CyberMonday -&gt; CyberMondayHome()

        // Must ship by Oct 15
        else -&gt; RegularHome()
    }
}

// Remote approach: Deploy each promotion on the exact day
// Benefit: Each promotion deploys on the exact minute needed
// Flexibility: Can react to competitor moves in real-time
class HomeScreenService {
    fun getHomeDocument(user: User): ByteArray {
        val promotion = promotionService.getCurrentPromotion()

        return captureRemoteDocument(context, displayInfo, profile) {
            when (promotion) {
                is BlackFridayPromotion -&gt; BlackFridayHome(promotion)
                is CyberMondayPromotion -&gt; CyberMondayHome(promotion)
                is FlashSale -&gt; FlashSaleHome(promotion)  // Can add new types anytime
                else -&gt; RegularHome()
            }
        }
    }
}
</code></pre>

<h3>状态管理：超越静态布局</h3>

<p>RemoteCompose 不仅限于静态布局。该框架包含一个状态管理系统，可以实现交互式、动态的 UI。</p>

<p><strong>远程状态变量</strong></p>

<p>状态可以嵌入文档中，并由客户端更新。这使得表单、计数器、切换开关和其他交互元素成为可能：</p>

<pre><code class="kotlin">// Creation side: Define interactive widget
@Composable
fun QuantitySelector(initialQuantity: Int) {
    var quantity by rememberRemoteState("quantity", initialQuantity)

    Row(
        modifier = RemoteModifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceBetween
    ) {
        IconButton(
            onClick = {
                if (quantity &gt; 1) {
                    quantity--
                    namedAction("quantityChanged", quantity.toString())
                }
            }
        ) {
            Icon(Icons.Minus)
        }

        Text(
            text = quantity.toString(),
            style = MaterialTheme.typography.headlineMedium
        )

        IconButton(
            onClick = {
                quantity++
                namedAction("quantityChanged", quantity.toString())
            }
        ) {
            Icon(Icons.Plus)
        }
    }
}
</code></pre>

<p>播放器端通过操作回调处理状态更新：</p>

<pre><code class="kotlin">// Player side: Handle state updates
RemoteDocumentPlayer(
    document = document,
    onNamedAction = { name, value, stateUpdater -&gt;
        when (name) {
            "quantityChanged" -&gt; {
                // Update cart
                cartManager.setQuantity(itemId, value.toInt())

                // Optionally update remote state directly
                stateUpdater.updateState { state -&gt;
                    state["quantity"] = RcInt(value.toInt())
                }
            }
        }
    }
)
</code></pre>

<p><strong>动画时间跟踪</strong></p>

<p>播放器跟踪动画时间并将其传递给文档，从而无需任何客户端动画代码即可实现基于时间的动画：</p>

<pre><code class="kotlin">// Server side: Define animated elements
@Composable
fun PulsingNotificationBadge(count: Int) {
    // Scale pulses between 0.9 and 1.1 over 1 second
    val scale = FloatExpression("0.9 + 0.2 * sin(time * 6.28)")

    // Opacity pulses between 0.7 and 1.0
    val opacity = FloatExpression("0.7 + 0.3 * sin(time * 6.28)")

    Box(
        modifier = RemoteModifier
            .scale(scale)
            .alpha(opacity)
            .background(Color.Red, CircleShape)
            .size(24.dp)
    ) {
        Text(
            text = count.toString(),
            color = Color.White,
            modifier = RemoteModifier.align(Alignment.Center)
        )
    }
}

// The player automatically:
// 1. Tracks elapsed time since document load
// 2. Evaluates expressions each frame
// 3. Updates visual properties
// No client animation code needed
</code></pre>

<p>这使得完全在文档格式中定义的流畅、高性能动画成为可能。表达式支持诸如 <code>sin</code>、<code>cos</code>、<code>lerp</code> 和 <code>clamp</code> 之类的数学函数，以及算术运算符和变量引用。</p>

<p><strong>双向通信</strong></p>

<p>操作系统支持文档与宿主应用之间的双向通信：</p>

<pre><code class="kotlin">// Document triggers actions for various purposes
@Composable
fun ProductDetailPage(product: Product) {
    Column {
        // Analytics tracking
        LaunchedEffect(Unit) {
            namedAction("analytics", "product_viewed:${product.id}")
        }

        ProductImage(product.imageUrl)

        // Navigation action
        TextButton(onClick = { namedAction("navigate", "/reviews/${product.id}") }) {
            Text("See all reviews")
        }

        // Cart action with data
        Button(onClick = { namedAction("addToCart", product.id) }) {
            Text("Add to Cart")
        }

        // State update action
        var isFavorite by rememberRemoteState("favorite", product.isFavorite)
        IconButton(
            onClick = {
                isFavorite = !isFavorite
                namedAction("toggleFavorite", "${product.id}:$isFavorite")
            }
        ) {
            Icon(if (isFavorite) Icons.Filled.Favorite else Icons.Outlined.Favorite)
        }
    }
}
</code></pre>

<p>宿主应用统一处理所有操作：</p>

<pre><code class="kotlin">// Host app handles all actions uniformly
RemoteDocumentPlayer(
    document = document,
    onNamedAction = { name, value, stateUpdater -&gt;
        when (name) {
            "analytics" -&gt; {
                val (event, id) = value.split(":")
                analytics.logEvent(event, mapOf("productId" to id))
            }
            "navigate" -&gt; navController.navigate(value)
            "addToCart" -&gt; {
                cartManager.add(value)
                // Update UI to show confirmation
                stateUpdater.updateState { state -&gt;
                    state["cartCount"] = RcInt((state["cartCount"] as? RcInt)?.value?.plus(1) ?: 1)
                }
            }
            "toggleFavorite" -&gt; {
                val (id, isFavorite) = value.split(":")
                favoritesManager.setFavorite(id, isFavorite.toBoolean())
            }
        }
    }
)
</code></pre>

<p>这种双向通信意味着远程文档可以完全集成到你应用的导航、分析、状态管理和业务逻辑中，而文档本身无需了解你的具体实现。</p>

<h3><strong>实际应用架构模式</strong></h3>

<p>让我们来探讨一下 RemoteCompose 如何融入实际应用架构。</p>

<p><strong>模式 1：混合架构（推荐）</strong></p>

<p>大多数应用都能从混合架构中获益：关键页面使用本地 Compose 代码构建，而动态内容区域则使用 RemoteCompose。</p>

<pre><code class="kotlin">// Navigation: Local Compose (fast, reliable)
@Composable
fun AppNavigation() {
    NavHost(navController, startDestination = "home") {
        composable("home") { HomeScreen() }
        composable("product/{id}") { ProductScreen(it.arguments?.getString("id")) }
        composable("cart") { CartScreen() }
        composable("checkout") { CheckoutScreen() }
    }
}

// Home screen: Remote (marketing can update freely)
@Composable
fun HomeScreen(viewModel: HomeViewModel = hiltViewModel()) {
    val document by viewModel.homeDocument.collectAsState()

    when (val state = document) {
        is Loading -&gt; LoadingIndicator()
        is Success -&gt; RemoteDocumentPlayer(
            document = state.document,
            onNamedAction = { name, value, _ -&gt; handleAction(name, value) }
        )
        is Error -&gt; LocalFallbackHome()  // Graceful degradation
    }
}

// Product screen: Hybrid (shell is local, content is remote)
@Composable
fun ProductScreen(productId: String, viewModel: ProductViewModel = hiltViewModel()) {
    val product by viewModel.product.collectAsState()
    val contentDocument by viewModel.contentDocument.collectAsState()

    Scaffold(
        topBar = { ProductTopBar(product) },  // Local: consistent navigation
        bottomBar = { AddToCartBar(product) } // Local: critical purchase flow
    ) { padding -&gt;
        // Remote: Rich product content, can be A/B tested
        contentDocument?.let { doc -&gt;
            RemoteDocumentPlayer(
                document = doc,
                modifier = Modifier.padding(padding)
            )
        }
    }
}
</code></pre>

<p><strong>模式 2：文档缓存以实现离线支持</strong></p>

<p>远程文档可以缓存以供离线访问：</p>

<pre><code class="kotlin">class DocumentRepository @Inject constructor(
    private val api: DocumentApi,
    private val cache: DocumentCache,
    private val connectivity: ConnectivityManager
) {
    suspend fun getDocument(key: String): CoreDocument {
        // Try cache first
        cache.get(key)?.let { cached -&gt;
            // Return cached immediately, refresh in background
            refreshInBackground(key)
            return cached
        }

        // No cache, must fetch
        return if (connectivity.isConnected) {
            fetchAndCache(key)
        } else {
            throw OfflineException("No cached document and no connectivity")
        }
    }

    private suspend fun fetchAndCache(key: String): CoreDocument {
        val bytes = api.fetchDocument(key)
        val document = RemoteComposeBuffer.deserialize(bytes)
        cache.store(key, document, ttl = 1.hours)
        return document
    }

    private fun refreshInBackground(key: String) {
        scope.launch {
            try {
                fetchAndCache(key)
            } catch (e: Exception) {
                // Silent failure, cached version is still valid
                Log.w(TAG, "Background refresh failed", e)
            }
        }
    }
}
</code></pre>

<p><strong>模式 3：文档预加载以实现流畅导航</strong></p>

<p>预加载用户可能访问的页面的文档：</p>

<pre><code class="kotlin">class DocumentPreloader @Inject constructor(
    private val repository: DocumentRepository
) {
    // Preload when user enters a screen
    fun preloadForScreen(screen: Screen) {
        val keysToPreload = when (screen) {
            is HomeScreen -&gt; listOf("featured", "categories", "promotions")
            is CategoryScreen -&gt; screen.subcategories.map { "category_${it.id}" }
            is ProductScreen -&gt; listOf("reviews_${screen.productId}", "related_${screen.productId}")
            else -&gt; emptyList()
        }

        keysToPreload.forEach { key -&gt;
            scope.launch {
                try {
                    repository.getDocument(key)  // Caches for later
                } catch (e: Exception) {
                    // Preload failure is not critical
                }
            }
        }
    }
}

// Usage in navigation
navController.addOnDestinationChangedListener { _, destination, arguments -&gt;
    preloader.preloadForScreen(destination.toScreen(arguments))
}
</code></pre>

<h3><strong>结论</strong></h3>

<p>RemoteCompose 代表了我们对 Android UI 开发思维方式的一次范式转变。通过将 Compose 布局转换为可移植文档格式，RemoteCompose 实现了服务器驱动的 UI、即时 A/B 测试、实时内容更新和跨平台一致性，同时保持了原生渲染性能。</p>

<p>该框架拥有包含 93 种以上操作的全面操作模型，充分展现了 Compose 的表达能力，包括动画、状态和交互。创建和播放的分离使得部署架构更加灵活：在后端生成具有完整 Compose 表达能力的文档，通过现有基础架构分发，并在任何 Android 设备上进行原生渲染。</p>

<p>关键在于找到合适的平衡点：对于动态、频繁变化的内容区域，使用 RemoteCompose；同时将关键流程保留在本地 Compose 代码中。这种混合方法在需要灵活性的地方提供服务器驱动 UI 的优势，在需要可靠性的地方提供编译代码的优势。</p>

<p>无论你是构建需要频繁更新布局的内容密集型应用、需要快速 A/B 测试的电子商务平台，还是需要快速迭代的企业级工具，RemoteCompose 都能为真正动态的 UI 提供架构基础。该框架处理了序列化、传输和渲染的复杂性，因此你可以专注于设计卓越的用户体验。</p>

<p>你可以观看他们最近关于<a href="https://speakerdeck.com/camaelon/introducing-remotecompose-break-your-ui-out-of-the-app-sandbox">RemoteCompose 简介：将你的 UI 从应用程序沙盒中解放出来</a>的演讲。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jetpack Compose中的阴影艺术]]></title>
    <link href="https://alexhilton.github.io/blog/2025/11/24/the-art-of-shadows-in-jetpack-compose/"/>
    <updated>2025-11-24T00:00:00+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/11/24/the-art-of-shadows-in-jetpack-compose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「The Art of Shadows in Jetpack Compose」，原文链接<a href="https://medium.com/proandroiddev/the-art-of-shadows-in-jetpack-compose-63a75070882f">https://medium.com/proandroiddev/the-art-of-shadows-in-jetpack-compose-63a75070882f</a>，由Stefano Natali发布于2025年10月4日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/1*UjyqMyVg002OIDJ1Hdee8Q.png" title="auto auto" ></a></p>

<!-- more -->


<p>UI 中的阴影发挥着至关重要的作用：它们在视觉上<strong>提升</strong>元素，指示着<strong>交互性</strong>，并提供用户操作的即时<strong>反馈</strong>。多年来，我们一直依赖于<strong>高度</strong>属性，但 Jetpack Compose 现在提供了一套强大的工具，可以对<strong>阴影渲染</strong>进行精细控制。</p>

<p>Google 最近新增了一个<a href="https://developer.android.com/develop/ui/compose/graphics/draw/shadows">文档页面</a>，其中包含一系列有趣的用例。本文将探索 Compose 中的主要阴影修改器，并深入讲解创建渐变和炫酷特效等高级技巧，从而提升应用的风格。</p>

<p>本文讨论的所有技巧的完整代码示例都可以在我的 GitHub 仓库 <a href="https://github.com/stefanoq21/ComposePlayground"><strong>Compose Playground</strong></a> 中找到。</p>

<h2>阴影修改器（Shadow Modifiers）</h2>

<p>添加阴影最简单但自定义程度最低的方法是使用 <strong>Modifier.shadow()</strong>。与以往一样，它的行为依赖于<strong>基于高度的阴影</strong>，模拟来自上方的光源，阴影深度直接取决于你提供的高度值。其主要限制在于阴影始终被裁剪到可合成对象的形状内，并且你无法自定义扩展、颜色色调或偏移等属性。</p>

<pre><code class="kotlin">Box(
    Modifier
        .size(100.dp)
        .shadow(
            elevation = 10.dp, 
            shape = RectangleShape
        )
        .background(Color.White)
)
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:704/1*7Nkm6z8Ls4FyvDqCcKToDw.png" alt="" /></p>

<p>让我们从一些新功能开始，这些功能赋予我们更强大的力量。使用 <strong>dropShadow()</strong>，我们可以在内容后面创建自定义阴影。这个修饰符是创建复杂阴影的关键，它允许对内容后面的阴影进行精细控制，使元素看起来像是被抬升了一样。</p>

<pre><code class="kotlin"> .dropShadow(
    shape = RoundedCornerShape(20.dp), shadow = Shadow(
            radius = 6.dp,
            spread = 2.dp,
            color = Color.Black.copy(alpha = 0.3f),
            offset = DpOffset(2.dp, 2.dp)
              )
            )
 .background(
    color = Color.White, shape = RoundedCornerShape(20.dp)
            )
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:990/1*kENF6x3L985dO65DSY0Zng.png" alt="" /></p>

<p>它使用 <strong>Shadow</strong> 参数，可以精确控制视觉效果。这个参数允许你使用几个关键属性来塑造阴影。 <strong>半径</strong> 决定了边缘的柔和度和扩散（模糊）程度。<strong>扩散</strong> 值控制阴影几何形状相对于可组合元素大小的扩展或收缩。最后，<strong>偏移</strong> 沿 <strong>X 轴和 Y 轴</strong>定位阴影，从而确定光源的视觉方向。结合阴影的<strong>颜色</strong>，这些属性可以实现完全自定义。</p>

<p>💡 <strong>顺序很重要：</strong>在修改器链中，<strong>dropShadow()</strong> 修改器必须出现在 <strong>background()</strong> 修改器<strong>之前</strong>，因为阴影先绘制，背景绘制在其上方。</p>

<p><strong>innerShadow()</strong> 修改器是 <strong>dropShadow()</strong> 的逆操作，它在可组合元素边界的<strong>内部</strong>创建阴影，从而实现元素凹陷或压入表面的视觉效果。与它的对应项一样，它也使用可自定义的<strong>Shadow</strong>对象，允许你使用<strong>半径</strong>、<strong>颜色</strong>、<strong>偏移</strong>和<strong>扩散</strong>来微调效果。</p>

<pre><code class="kotlin">.background(
    Color.White, shape = RoundedCornerShape(20.dp)
)
.innerShadow(
    shape = RoundedCornerShape(20.dp), shadow = Shadow(
        radius = 6.dp,
        spread = 2.dp,
        color = Color.Black.copy(alpha = 0.3f),
        offset = DpOffset(2.dp, 2.dp)
    )
)
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1108/1*a7KFFaTXCk4KC-sm9AYUoQ.png" alt="" /></p>

<p>💡<strong>再次强调，顺序很重要：</strong><strong>innerShadow()</strong>修改器<strong>必须</strong>放在<strong>background()</strong>修改器<strong>之后</strong>。如果将其放在背景之前，内容将绘制在阴影之上，完全遮盖阴影。</p>

<p>这些修改器的真正强大之处在于它们的自定义和组合。通过叠加<strong>innerShadow()</strong>和<strong>dropShadow()</strong>，你可以创建复杂而逼真的视觉效果。我们来看一些高级用例。</p>

<h2>高级技巧：组合和自定义阴影</h2>

<h3>自定义阴影</h3>

<p>当你在 <strong>dropShadow()</strong> 函数中将 <strong>Brush</strong> 对象而非纯色传递给 <strong>Shadow</strong> 对象时，自定义的强大功能便显而易见。此功能允许你使用 <strong>Brush.sweepGradient</strong> 创建渐变效果。此外，无论你使用标准形状还是完全自定义的几何体，阴影始终会贴合可组合对象的形状。</p>

<pre><code class="kotlin">.dropShadow(
    shape = MaterialShapes.Cookie12Sided.toShape(), shadow = Shadow(
        radius = 10.dp,
        spread = 6.dp,
        brush = Brush.sweepGradient(
            listOf(Color.Green, Color.Blue, Color.Yellow, Color.Green)
        ),
        offset = DpOffset(2.dp, 2.dp)
    )
)
.background(
    color = Color.White,
    shape = MaterialShapes.Cookie12Sided.toShape(),
)
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1122/1*a8xMvXOb3hS6icdGU0p1gg.png" alt="" /></p>

<h3>新粗犷主义阴影</h3>

<p>这种风格完美地展现了 <strong>dropShadow()</strong> 修改器在实现极致高对比度效果方面的强大功能。要实现新粗犷主义（Neobrutalism）那种粗犷、棱角分明的视觉效果，你必须使用 <code>dropShadow()</code> 函数，并设置模糊度为零，偏移量要明显，通常还要配合粗边框。具体来说，你需要同时设置 <code>radius = 0.dp</code> 和 <code>spread = 0.dp</code> 来消除扩散，然后应用鲜艳的色彩，并设置一个明显的偏移量，从而创建出标志性的锐利轮廓。</p>

<pre><code class="kotlin"> .dropShadow(
     shape = RoundedCornerShape(0.dp),
     shadow = Shadow(
        radius = 0.dp,
        spread = 0.dp,
        color = dropShadowColor,
        offset = DpOffset(x = 8.dp, 8.dp)
                    )
        )
 .border(
    8.dp, borderColor
        )
 .background(
    color = Color.White,
    shape = RoundedCornerShape(0.dp)
        )
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*bdPpm0XYPfTXMuoNrVQuZw.png" alt="" /></p>

<h3>具有动效的阴影</h3>

<p>阴影并非只是静态的；它们可以制作成动画，从而提供即时的用户反馈。我们将要探索的最后一个高级技巧是创建交互式阴影，使其在特定操作（例如点击或按下）时平滑过渡。这项技术对于模拟物理交互至关重要，它能直观地确认元素的抬升或状态发生了变化。</p>

<pre><code class="kotlin"> Box(Modifier.fillMaxSize()) {
        val interactionSource = remember { MutableInteractionSource() }
        val isPressed by interactionSource.collectIsPressedAsState()

        // Create transition with pressed state
        val transition = updateTransition(
            targetState = isPressed, label = "button_press_transition"
        )

        fun &lt;T&gt; buttonPressAnimation() = tween&lt;T&gt;(
            durationMillis = 400, easing = Ease
        )

        // Animate all properties using the transition
        val shadowAlpha by transition.animateFloat(
            label = "shadow_alpha", transitionSpec = { buttonPressAnimation() }) { pressed -&gt;
            if (pressed) 0f else 1f
        }

        //to animate the color
        val colorDropShadow by transition.animateColor(
            label = "shadow_color", transitionSpec = { buttonPressAnimation() }) { pressed -&gt;
            if (pressed) Color.Transparent else Color.Green.copy(alpha = (0.5f))
        }
        val innerShadowAlpha by transition.animateFloat(
            label = "inner_shadow_alpha", transitionSpec = { buttonPressAnimation() }) { pressed -&gt;
            if (!pressed) 0f else 1f
        }

        Box(
            Modifier
                .clickable(
                    interactionSource, indication = null
                ) {
                    //...
                }
                .width(300.dp)
                .height(200.dp)
                .align(Alignment.Center)
                .dropShadow(
                    shape = RoundedCornerShape(70.dp), shadow = Shadow(
                        radius = 10.dp,
                        spread = 0.dp,
                        color = Color.Green.copy(alpha = (0.5f)),
                        offset = DpOffset(x = 0.dp, 0.dp),
                        alpha = shadowAlpha
                    )
                )
                // note that the background needs to be defined before defining the inner shadow
                .background(
                    color = Color(0xFFFFFFFF), shape = RoundedCornerShape(70.dp)
                )
                .innerShadow(
                    shape = RoundedCornerShape(70.dp), shadow = Shadow(
                        radius = 8.dp,
                        spread = 4.dp,
                        color = Color.Green.copy(alpha = (0.5f)),
                        alpha = innerShadowAlpha,
                        offset = DpOffset(x = 0.dp, 0.dp)
                    )
                )
        ) {
            //...
        }
    }
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*idzAQ4lII7JweFZdCyfNqg.gif" alt="" /></p>

<p>好的，我们已经了解了如何使用 <strong>updateTransition</strong> API 来创建流畅的交互反馈。它首先使用 <strong>MutableInteractionSource</strong> 跟踪按下状态。该状态会驱动一个 <strong>400 毫秒的过渡动画</strong>，同时为两个方向相反的阴影添加动画效果。外部的 <strong>dropShadow</strong> 在按下时会淡出，而内部的 <strong>innerShadow</strong> 则会淡入。这种双阴影动画使组件从 <strong>抬升</strong> 状态平滑过渡到 <strong>凹陷</strong> 状态，从而在用户交互时提供清晰且动态的反馈。</p>

<h2>结论</h2>

<p>Compose 全新的阴影 API 标志着对传统 <strong>elevation</strong> 属性局限性的重大突破。它将核心概念拆分为 <strong>dropShadow()</strong> 和 <strong>innerShadow()</strong>，并赋予我们对 <strong>Shadow</strong> 对象属性的完全控制权。</p>

<p>无论你是打造简单的渐变效果、模拟物理深度，还是实现新粗野主义的高对比度视觉冲击，这种全新的自定义程度都意味着你的 <strong>UI 终于可以充分展现你设计的艺术愿景</strong>。</p>

<p>不妨尝试这些修饰符，为你的 Jetpack Compose 应用注入全新的创意维度！</p>

<p>如果你觉得这篇文章有趣，欢迎关注我，获取更多关于 Android 开发和 Jetpack Compose 的精彩内容。我会定期发布相关主题的文章。欢迎随时分享你的评论，或通过 <a href="https://bsky.app/profile/stefanoq21.bsky.social"><strong>Bluesky</strong></a> 或 <a href="http://www.linkedin.com/in/stefano-natali-q21"><strong>LinkedIn</strong></a> 与我联系，进行更深入的讨论。</p>

<p>祝你开心，编程快乐！</p>
]]></content>
  </entry>
  
</feed>
