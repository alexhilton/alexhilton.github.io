<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Compose | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/compose/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2025-08-01T21:29:31+08:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[学会用最优雅的姿式在Compose中显示富文本]]></title>
    <link href="https://alexhilton.github.io/blog/2025/07/30/styledstring-in-jetpack-compose/"/>
    <updated>2025-07-30T22:50:40+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/07/30/styledstring-in-jetpack-compose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「StyledString: A Better Pattern for Rich Text in Jetpack Compose」，原文链接<a href="https://proandroiddev.com/styledstring-a-better-pattern-for-rich-text-in-jetpack-compose-5930bde981b1">https://proandroiddev.com/styledstring-a-better-pattern-for-rich-text-in-jetpack-compose-5930bde981b1</a>，由Eury Pérez Beltré发布于2025年7月14日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*NS_T-i72tS5eOs5F0f_Tnw.png" title="auto auto" ></a></p>

<!-- more -->


<p>在 Jetpack Compose 中设置文本样式看似简单……但其实不然。在本文中，我们将探讨 AnnotatedString 的局限性，以及 StyledString 如何让富文本更易于管理。让我们来详细分析一下。👇</p>

<h2>📚 目录</h2>

<ol>
<li>引言：一个粗体字、一个链接，以及一大堆麻烦</li>
<li>AnnotatedString：样式过多，简洁性不足</li>
<li>StyledString 简介：一个 API 即可设置所有样式</li>
<li>StyledString 底层原理：API 背后的引擎</li>
<li>结语</li>
</ol>


<h2>引言：一个加粗的单词、一个链接，以及一大堆麻烦</h2>

<p>一开始，你拥有了 AnnotatedString 和一个 SpanStyle ，一切看起来都很顺畅。你想加粗一个单词？很简单✅。给某个东西加下划线？没问题。这甚至感觉有点有趣，尤其是在你像<a href="https://developer.android.com/develop/ui/compose/text/style-text#multiple-styles">官方文档</a>中那样手动构建整个字符串的时候。</p>

<p>但问题是：🧠</p>

<p>当你完全控制字符串时，这种方法非常有效。但当你处理实际内容：动态副本、本地化文本、从其他地方传入的段落，而你只需要设置其中一部分的样式时？</p>

<p>事情很快就变得很糟糕。</p>

<p>突然间，你需要跟踪子字符串、计算索引、应用样式，并连接点击监听器。只需对文本进行一次更改，你的逻辑就会像纸牌屋一样崩溃。🃏</p>

<p>你原本想要的只是加粗一个单词并让链接可点击。现在你深陷于样板代码中，祈祷一切都不会改变。</p>

<p>在这篇文章中，我将解释为什么 AnnotatedString 在实际 UI 中无法很好地扩展，并介绍一个我为了解决这个问题而构建的微型抽象。它叫做 StyledString，它的功能非常强大：💡 它确实做到了：</p>

<p><strong>让Compose 中的文本样式再次变得简单。</strong></p>

<h2>AnnotatedString：样式太多，简洁性不足</h2>

<p>首先，让我们称赞一下 AnnotatedString。它是一款强大的工具💪.</p>

<p>你可以使用一个 Text 可组合项来创建带样式、可点击、可交互的文本。想要让一个单词加粗，另一个单词像链接一样显示？完全可以。该 API 灵活、底层，并且由 Compose 本身的富文本引擎支持。</p>

<p>问题是，它只有<strong>在手动</strong>构建整个字符串时才能发挥最佳效果。</p>

<p>文档中的大多数示例如下所示：</p>

<pre><code class="Kotlin">buildAnnotatedString {
    append("Hello ")
    withStyle(style = SpanStyle(fontWeight = FontWeight.Bold)) {
        append("world")
    }
}
</code></pre>

<p>看起来不错，对吧？但棘手的地方就在这里。👀</p>

<p>如果你有一整段动态文本，比如一段本地化的字符串或一个从其他地方拉取的句子，而你只想为其中的部分内容添加样式，该怎么办？</p>

<p>现在你需要处理：</p>

<ul>
<li>查找要添加样式的子字符串</li>
<li>计算起始和结束索引</li>
<li>手动添加样式或注释</li>
<li>希望文本永远不变，否则一切都会崩溃。</li>
</ul>


<p>如果你需要多种样式，比如粗体单词、可点击的电子邮件和带下划线的 URL，动态地，事情很快就会变得混乱。🔥
这时，buildAnnotatedString 就会变成一堆脆弱的索引数学运算、重复的逻辑和样板代码，难以阅读，更难以维护。</p>

<p>当然，AnnotatedString 功能强大。但当你的文本是动态的，而你只想为其中的部分内容添加样式时？它很快就会变得索然无味。</p>

<h2>StyledString 隆重出场：一个 API 即可实现所有样式</h2>

<p>在与 AnnotatedString 纠结了无数次之后，我决定构建一个更好的东西。它并非一个庞大的库，也不是一个完整的样式框架。而是一个简单、兼容 Compose 的抽象，用于解决一个非常具体的问题。</p>

<p><strong>StyledString 来啦！👋</strong></p>

<p>它的目标很简单：让你定义字符串的哪些部分应该被设置样式或可点击，而无需担心 indexOf 、 addStyle 或 AnnotatedString.Builder 。你只需编写文本，告诉它需要设置哪些单词的样式，以及点击后该执行的操作。</p>

<p>它的实际效果如下：</p>

<pre><code class="Kotlin">// This list can be built in the ViewModel
val styledStrings = persistentListOf(
    StyledString.ClickableEmail(
        highlightedText = "support@example.com",
        email = "support@example.com",
        style = SpanStyle(
            color = Color.Blue,
            textDecoration = TextDecoration.Underline
        )
    ),
    StyledString.ClickableUrl(
        highlightedText = "website",
        url = "https://euryperez.dev",
        style = SpanStyle(
            color = Color.Blue,
            textDecoration = TextDecoration.Underline
        )
    )
)

// In your Compose Screen
StyledText(
    fullText = "Contact us at support@example.com or visit our website",
    styledStrings = styledStrings,
    style = MaterialTheme.typography.label,
    onClick = { styled -&gt;
        when (styled) {
            is ClickableEmail -&gt; openEmailClient(styled.email)
            is ClickableUrl -&gt; openUrl(styled.url)
        }
    }
)
</code></pre>

<p>就是这样。无需手动构建文本，无需索引计算，无需样板代码。只需简洁、易读、声明式的样式，即可与真实文本兼容。</p>

<p>由于 StyledString 支持 Simple 、 ClickableEmail 和 ClickableUrl 等类型，因此它易于在你的应用中扩展和复用。你可以获得可点击的、带样式的文本，而无需牺牲其合理性和可维护性。🙏</p>

<h2>StyledString 的底层：API 背后的引擎</h2>

<p>让我们揭开它的面纱，逐步了解 StyledString 的工作原理。🪄</p>

<p>当你在 UI 中使用 StyledText 时，🧠它可能感觉像魔法一样神奇，但在幕后，它只是一个简洁、易于组合的架构，旨在减少样式设计的痛苦，而不会增加不必要的复杂性。</p>

<p>本节涵盖了 StyledString 系统的每个部分，从样式的描述方式，到样式的查找、应用和在屏幕上渲染。</p>

<h3>🧱 1. 数据模型：StyledString 和 ClickableStyleString</h3>

<p>整个实用程序的核心是一个名为 StyledString 的密封接口。我们通过它来对需要以某种方式设置样式的文本片段进行建模。</p>

<pre><code class="Kotlin">@Immutable
sealed interface StyledString {
    val highlightedText: String
    val style: SpanStyle

    // Add `Simple` type

    // Add `ClickableEmail` type

    // Add `ClickableUrl` type
}
</code></pre>

<p>每个 StyledString 都需要两条信息：</p>

<ul>
<li>highlightedText：需要设置样式的文本的确切部分</li>
<li>style：定义其外观的 SpanStyle（颜色、下划线、字体粗细等）。</li>
</ul>


<p>然后，我们定义一些实现此接口的特定类型：</p>

<pre><code class="Kotlin">@Immutable
data class Simple(
    override val highlightedText: String,
    override val style: SpanStyle,
) : StyledString
</code></pre>

<p>这个是纯视觉效果的，它会改变文本的外观，但不响应点击。</p>

<p>然后我们介绍交互类型：</p>

<pre><code class="Kotlin">@Immutable
data class ClickableEmail(
    override val highlightedText: String,
    val email: String,
    override val style: SpanStyle,
) : StyledString, ClickableStyleString

@Immutable
data class ClickableUrl(
    override val highlightedText: String,
    val url: String,
    override val style: SpanStyle
) : StyledString, ClickableStyleString
</code></pre>

<p>它们执行相同的样式设置工作，但还携带额外的数据（例如点击时应打开的 URL 或电子邮件）。更重要的是，它们实现了第二个接口：ClickableStyleString。</p>

<pre><code class="Kotlin">sealed interface ClickableStyleString
</code></pre>

<p>这个小接口意义重大，它让我们能够区分纯视觉样式和应该响应点击的样式。这使得我们的点击处理逻辑简洁且类型安全。💡</p>

<p>你可以轻松添加更多变体，例如 @mentions、#hashtags 或电话号码，只需创建另一个数据类并选择性地实现ClickableStyleString 即可。</p>

<h3>🎯 2. 样式和链接：applyStyle</h3>

<p>一旦我们知道了哪些文本需要样式，我们就需要一种将这些样式应用于实际的 AnnotatedString 的方法。这就是 applyStyle() 的作用，它是一个简单的扩展函数，它根据 StyledString 的类型应用样式（和点击监听器）。</p>

<pre><code class="Kotlin">private fun AnnotatedString.Builder.applyStyle(
    styledString: StyledString,
    startIndex: Int,
    endIndex: Int,
    onClick: (ClickableStyleString) -&gt; Unit
) {
    when (styledString) {
        is StyledString.ClickableUrl -&gt; TODO()

        is StyledString.ClickableEmail -&gt; TODO()

        is StyledString.Simple -&gt; TODO()
    }
}
</code></pre>

<p>每次匹配每个 StyledString 时，都会调用一次此函数。现在让我们看看它做了什么：</p>

<pre><code class="Kotlin">is StyledString.ClickableUrl -&gt; {
    val linkAnnotation = LinkAnnotation.Url(
        url = styledString.url,
        styles = TextLinkStyles(style = styledString.style),
        linkInteractionListener = { onClick(styledString) }
    )
    addLink(linkAnnotation, startIndex, endIndex)
}
</code></pre>

<p>如果是 URL，我们会创建一个 LinkAnnotation.Url 对象，附加样式，并为其添加一个点击监听器。addLink 负责将其附加到正确的文本范围。</p>

<p>我们执行的操作类似，但针对电子邮件使用的是 LinkAnnotation.Clickable ：</p>

<pre><code class="Kotlin">is StyledString.ClickableEmail -&gt; {
    val linkAnnotation = LinkAnnotation.Clickable(
        tag = styledString.highlightedText,
        styles = TextLinkStyles(style = styledString.style),
        linkInteractionListener = { onClick(styledString) }
    )
    addLink(linkAnnotation, startIndex, endIndex)
}
</code></pre>

<p>如果样式只是视觉上的（不可点击），我们会应用常规跨度：</p>

<pre><code class="Kotlin">is StyledString.Simple -&gt; {
    addStyle(
        style = styledString.style, 
        start = startIndex, 
        end = endIndex
    )
}
</code></pre>

<p>这种分离将所有样式应用逻辑集中在一处。如果你想要支持新的链接类型或行为，只需更新此函数即可。</p>

<h3>🔍 3. 匹配文本：findAllOccurrences</h3>

<p>在应用样式之前，我们需要找到文本中所有出现指定highlightedText 的位置。这就是此函数的用途。</p>

<pre><code class="Kotlin">/**
 * Find all occurrences of a substring in a string, optionally ignoring case.
 *
 * @param substring The substring to search for.
 * @param ignoreCase Whether to perform a case-insensitive search.
 * @return A list of indices where the substring was found.
 */
private fun String.findAllOccurrences(
    substring: String,
    ignoreCase: Boolean = false
): List&lt;Int&gt;
</code></pre>

<p>这将获取全文，并返回给定子字符串的每个匹配项的起始索引列表。</p>

<p>工作原理如下：</p>

<pre><code class="Kotlin">if (substring.isEmpty()) return emptyList()
</code></pre>

<p>对于空子字符串，快速提前退出。避免奇怪的边缘情况。然后，我们准备进行不区分大小写的搜索（如果需要）：</p>

<pre><code class="Kotlin">val indices = mutableListOf&lt;Int&gt;()
val searchString = if (ignoreCase) this.lowercase() else this
val searchSubstring = if (ignoreCase) substring.lowercase() else substring
</code></pre>

<p>现在我们遍历字符串，找到所有匹配项：</p>

<pre><code class="Kotlin">var startIndex = 0
val maxStartIndex = length - substring.length

while (startIndex &lt;= maxStartIndex) {
    val index = searchString.indexOf(searchSubstring, startIndex)
    if (index == -1) break
    indices.add(index)
    startIndex = index + 1
}
</code></pre>

<p>我们最终返回结果：</p>

<pre><code class="Kotlin">return indices.toList()
</code></pre>

<p>这使得我们的样式逻辑保持灵活性和弹性，无论我们设计的单词出现一次还是十几次。</p>

<h3>🧠 4. 构建 AnnotatedString：rememberStyledAnnotationString</h3>

<p>以下函数将所有内容整合在一起。它接收完整文本和你的StyledString 列表，并返回一个应用了所有样式的 AnnotatedString。</p>

<pre><code class="Kotlin">@Composable
fun rememberStyledAnnotationString(
    fullText: String,
    styledStrings: ImmutableList&lt;StyledString&gt;,
    ignoreCase: Boolean = false,
    onClick: (ClickableStyleString) -&gt; Unit
): AnnotatedString
</code></pre>

<p>我们确保使用 rememberUpdatedState() 来保持点击监听器的最新状态：</p>

<pre><code class="Kotlin">val currentOnClick by rememberUpdatedState(onClick)
</code></pre>

<p>然后我们使用记住来缓存工作，除非输入发生变化：</p>

<pre><code class="Kotlin">return remember(fullText, styledStrings, ignoreCase) {
  // TODO: build annotated string
}
</code></pre>

<p>我们首先附加完整的未样式化的文本。然后，对于每个 StyledString ，我们找到所有匹配的位置并应用样式：</p>

<pre><code class="Kotlin">buildAnnotatedString {
    append(fullText)

    styledStrings.fastForEach { styledStringInfo -&gt;
        val indices =
            fullText.findAllOccurrences(styledStringInfo.highlightedText, ignoreCase)

        indices.fastForEach { startIndex -&gt;
            val endIndex = startIndex + styledStringInfo.highlightedText.length
            applyStyle(styledStringInfo, startIndex, endIndex, currentOnClick)
        }
    }
}
</code></pre>

<p>这个循环使得样式设置能够动态且多目标化。你可以将任何本地化或运行时生成的字符串作为 fullText 传递，它仍然能够正确应用样式。</p>

<h3>🧩 5. 可组合项：StyledText</h3>

<p>最后，StyledText 可组合项将所有内容连接在一起。</p>

<pre><code class="Kotlin">@Composable
fun StyledText(
    fullText: String,
    styledStrings: ImmutableList&lt;StyledString&gt;,
    style: TextStyle,
    modifier: Modifier = Modifier,
    onClick: (ClickableStyleString) -&gt; Unit = {},
    ignoreCase: Boolean = false,
) {
    // TODO: Implementation
}
</code></pre>

<p>你传入全文、样式以及可选的点击处理程序。它的内部功能如下：</p>

<pre><code class="Kotlin">val annotatedString = rememberStyledAnnotationString(
    fullText = fullText,
    styledStrings = styledStrings,
    ignoreCase = ignoreCase,
    onClick = onClick
)
</code></pre>

<p>这调用了我们刚刚讲过的逻辑。它返回一个带样式的 AnnotatedString 。然后我们渲染它：</p>

<pre><code class="Kotlin">Text(
    modifier = modifier,
    text = annotatedString,
    style = style
)
</code></pre>

<p>它只是一个普通的 Compose Text 。但所有样式逻辑都已预先烘焙。现在，你的 UI 代码保持简洁且声明式。🌚</p>

<h3>⚡️ 6. StyledText 实践</h3>

<p>现在，让我们来看看 StyledText 的实践，为此，我整理了一个预览，你可以自己测试一下：</p>

<pre><code class="Kotlin">@PreviewLightDark
@Composable
private fun StyledTextPreview() {
    MyTheme {
        Box(
            modifier = Modifier
                .background(color = MaterialTheme.colors.background)
                .padding(16.dp)
        ) {
            // This list can be built in the ViewModel
            val styledStrings = persistentListOf(
                StyledString.ClickableEmail(
                    highlightedText = "support@example.com",
                    email = "support@example.com",
                    style = SpanStyle(
                        color = Color.Gray,
                        textDecoration = TextDecoration.Underline
                    )
                ),
                StyledString.ClickableUrl(
                    highlightedText = "website",
                    url = "https://euryperez.dev",
                    style = SpanStyle(
                        color = Color.Gray,
                        textDecoration = TextDecoration.Underline
                    )
                )
            )

            // In your Compose Screen
            StyledText(
                fullText = "Contact us at support@example.com or visit our website",
                styledStrings = styledStrings,
                style = MaterialTheme.typography.body2,
                color = MaterialTheme.colors.onBackground,
                onClick = { styled -&gt;
                    when (styled) {
                        is StyledString.ClickableEmail -&gt; TODO()
                        is StyledString.ClickableUrl -&gt; TODO()
                    }
                }
            )
        }
    }
}
</code></pre>

<p>你将在预览中看到以下内容：
<img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9Tc22BNoUfij54fBGQ7YCg.png" alt="StyledTextPreview" /></p>

<h3>✅ 总结：一个输出简洁的简单引擎</h3>

<p>总而言之，我们构建了一个完全可复用的 Compose 实用程序，它：</p>

<ul>
<li>使用 StyledString 以声明式方式描述样式</li>
<li>安全地区分可视样式和可点击样式</li>
<li>使用 applyStyle 应用 span 和 link</li>
<li>使用 findAllOccurrences 查找多个匹配项</li>
<li>以 Compose 稳定的方式组装所有内容</li>
<li>封装在一个简洁的 API 中：StyledText</li>
</ul>


<p>无需 indexOf ，无需复杂的范围逻辑，也无需复制粘贴 buildAnnotatedString样板代码。</p>

<p><a href="https://gist.github.com/euri16/614a460fe6a690ce57cd23cc41164b5a">点击此处</a>（链接：<a href="https://gist.github.com/euri16/614a460fe6a690ce57cd23cc41164b5a%EF%BC%89%E8%8E%B7%E5%8F%96%E5%AE%8C%E6%95%B4%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%82">https://gist.github.com/euri16/614a460fe6a690ce57cd23cc41164b5a%EF%BC%89%E8%8E%B7%E5%8F%96%E5%AE%8C%E6%95%B4%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%82</a></p>

<h2>结语🎯</h2>

<p>Jetpack Compose 赋予我们强大的功能，但并非总是最符合人体工程学的开箱即用工具。AnnotatedString 对于一次性需求来说非常棒，但一旦你的 UI 需要多种样式、复用模式或动态点击处理，它就会很快变得冗长。</p>

<p>这就是 StyledString 的用武之地。</p>

<p>它并非取代 AnnotatedString，而是对其进行包装，为你提供一种更安全、更清晰的方式来描述意图：</p>

<ul>
<li>→ “将此单词加粗”</li>
<li>→ “将此短语设为链接”</li>
<li>→ “为该字符串的每个实例设置样式”</li>
</ul>


<p>你无需再考虑文本偏移量和跨度范围，而是开始思考含义。结果：代码更简洁、样板更少，开发者体验更佳💆</p>

<h3>🧩 易于采用</h3>

<p>你无需重构整个应用即可使用 StyledString 。</p>

<p>只需将一两个 Text() 元素替换为 StyledText() 即可。将内联的 buildAnnotatedString { &hellip; } 块替换为 StyledString.Simple 或 ClickableUrl 的简单列表即可。</p>

<p>就这样，你就成功了。✨</p>

<h3>🛠️ 易于扩展</h3>

<p>还有其他用例吗？</p>

<ul>
<li>为 #hashtags 设置样式？</li>
<li>处理 @mentions？</li>
<li>自动检测电话号码？</li>
<li>添加图标或背景高亮？</li>
</ul>


<p>只需创建一个实现 StyledString 的新数据类，并在 applyStyle() 中处理它即可。系统的其余部分保持不变。</p>

<p>这种分离使你的文本逻辑模块化、可测试，并能够适应未来的设计或业务需求。</p>

<p>如果你有什么有趣的想法，别忘了在评论区分享。😉</p>

<h3>🫱 轮到你了</h3>

<p>现在你已经了解了它的工作原理（以及它实际需要的代码量有多小），那就在下一个 Compose 屏幕中尝试一下吧。不再需要繁琐的 AnnotatedString.Builder 代码。不再需要重复的 span 逻辑。只需描述你想要的内容，剩下的交给 StyledText 处理。</p>

<p><strong>让 Compose 中的文本样式再次变得简单。😎</strong></p>

<h3>🤝 感谢阅读</h3>

<p>如果你最终在项目中使用了 StyledString，请告诉我！看到这些微型模式在现实世界中落地总是很酷。👀</p>

<p>感谢阅读！如果你觉得这篇文章有用，请考虑分享给其他开发者，点赞或留言。这很有帮助。✌️</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[揭密Jetpack Compose中的PausableComposition]]></title>
    <link href="https://alexhilton.github.io/blog/2025/07/24/exploring-pausablecomposition/"/>
    <updated>2025-07-24T19:55:51+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/07/24/exploring-pausablecomposition</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Exploring PausableComposition internals in Jetpack Compose」，原文链接<a href="https://blog.shreyaspatil.dev/exploring-pausablecomposition-internals-in-jetpack-compose">https://blog.shreyaspatil.dev/exploring-pausablecomposition-internals-in-jetpack-compose</a>，由Shreyas Patil发布于2025年7月14日。</p></blockquote>

<p><a href=""><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1751791091096/4e5b36e3-485c-4079-88be-987082e7d67e.png?w=1600&amp;h=840&amp;fit=crop&amp;crop=entropy&amp;auto=compress,format&amp;format=webp" title="auto auto" ></a></p>

<!-- more -->


<p>嗨，Composers 们👋，在最近的 Compose 1.9.X 版本中，Compose-runtime 引入了一个名为 PausableComposition 的新内部 API，据称它可以解决性能问题。它听起来像魔法，但在底层，这一切都归功于一些非常巧妙的工程设计。在深入研究 Compose 运行时以更好地理解这一点时，我偶然发现了一个强大的内部工具，它使这一切成为可能。</p>

<p>这篇文章将深入分析这一机制：PausableComposition。这是 Compose 的内部 API，开发者无需了解它。但了解它的底层工作原理总是有益的。对于想要深入了解 Compose 如何实现其惊人性能的 Jetpack Compose 开发者来说，这篇探索文章将为你提供更清晰的视角。我们将深入运行时源代码，了解它的工作原理、它对性能如此重要的原因，以及如何协调所有组件以使我们的 UI 感觉如此流畅。让我们开始吧！</p>

<h2>缘起</h2>

<p>为了实现流畅的 60 帧/秒 (fps)，我们的应用需要在 16.7 毫秒内绘制每一帧。当用户滚动浏览 LazyColumn 时，必须在这个微小的窗口内创建、测量和绘制新的项目。</p>

<p>如果一个项目很复杂，包含嵌套布局、图片和大量逻辑，那么组合它所需的工作很容易超过 16 毫秒。当这种情况发生时，主线程会被阻塞，帧会丢失，用户会在滚动过程中看到“卡顿”或卡顿。😩</p>

<p>这正是 PausableComposition 的初衷。</p>

<h2>“做什么”：更智能的 Compose 方式</h2>

<p>想象一下，你是一位厨师，正在为一场活动准备一顿大餐。👨‍🍳 与其在第一位客人到来时慌乱地从头开始烹饪所有食材，不如提前几个小时做好准备工作。切菜、调酱、烤甜点。等到上桌时，最后的烹饪和组装速度会快得令人难以置信。</p>

<p>PausableComposition 将这种“准备工作”的理念带到了 Compose 中。它允许运行时：</p>

<ol>
<li>增量式 Compose：将大型 UI 元素的合成分解成更小、更易于管理的部分。</li>
<li>异步准备：在 UI 真正需要显示在屏幕上之前进行合成工作，通常利用帧间的空闲时间。</li>
</ol>


<p>这种可组合项的预热意味着，当某个项目最终滚动到视图中时，大部分繁重的工作已经完成，使其几乎可以立即显示。</p>

<p>为了直观地理解这一概念，请观看以下动画：</p>

<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1751997214840/f9f7308a-7b83-4a3d-9d38-e3ce6aa8d9a9.gif?auto=format,compress&amp;gif-q=60&amp;format=webm" alt="滚动帧时间线" /></p>

<p>滚动发生时，假设项目 A、B、C、D 和 E 已在屏幕上可见，下一个项目是 F。如果项目 F 的布局或结构复杂，需要更多时间进行布局计算或其他预处理才能在 UI 上渲染，则此预处理将在帧时间轴内分块进行（例如 16 毫秒）。因此，如果它需要 2 帧，则 F 所需的预处理会在 2 帧的空闲时间内完成，不会造成任何帧卡顿。最后，当需要显示时，它会被绘制到 UI 上。项目 G 和 H 也采用相同的流程。</p>

<h2>工作原理：核心组件</h2>

<p>通过查看运行时源代码，我们可以看到它是如何通过一些关键接口和类来处理的。虽然你不会直接使用这些 API，但理解它们可以揭示 LazyColumn 的性能提升。🕵️‍♂️</p>

<h3>生命周期：PausableComposition 及其控制器</h3>

<p>旅程从 PausableComposition 接口开始，该接口扩展了 ReusableComposition 并添加了暂停功能。</p>

<blockquote><p>关于 ReusableComposition 的简要说明：</p>

<p>在讨论暂停之前，我们先来了解一下什么是 ReusableComposition？它是一种特殊的组合，专为需要高效回收 UI 内容的高性能场景而设计。想象一下 LazyColumn 中的项目。ReusableComposition 不会销毁滚动到屏幕外的项目的整个组合，而是允许运行时停用它。这会保留底层 UI 节点，但会清除已记住的状态。然后，这个停用的组合可以快速地用新内容“重新填充”，从而节省了从头创建节点的成本。PausableComposition 直接构建于这个强大的回收基础之上。</p></blockquote>

<p>PausableComposition 的外观如下：</p>

<pre><code class="Kotlin">// https://cs.android.com/androidx/platform/frameworks/support/+/8d08d42d60f7cc7ec0034d0b7ff6fd953516d96a:compose/runtime/runtime/src/commonMain/kotlin/androidx/compose/runtime/PausableComposition.kt;l=66
sealed interface PausableComposition : ReusableComposition {
    fun setPausableContent(content: @Composable () -&gt; Unit): PausedComposition
    fun setPausableContentWithReuse(content: @Composable () -&gt; Unit): PausedComposition
}
</code></pre>

<p>（注意：该接口是密封的，因为它仅在 Compose 运行时内部具有一组封闭且有限的实现。这为编译器提供了更多信息来进行优化。）</p>

<p>调用 setPausableContent 不会立即组合界面。相反，它会返回一个 PausedComposition 对象，该对象充当逐步过程的控制器。</p>

<pre><code class="Kotlin">// https://cs.android.com/androidx/platform/frameworks/support/+/8d08d42d60f7cc7ec0034d0b7ff6fd953516d96a:compose/runtime/runtime/src/commonMain/kotlin/androidx/compose/runtime/PausableComposition.kt;l=112
sealed interface PausedComposition {
    val isComplete: Boolean
    fun resume(shouldPause: ShouldPauseCallback): Boolean
    fun apply()
    fun cancel()
}
</code></pre>

<p>这个生命周期最好以状态机的形式来表示：</p>

<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1751864148018/27512893-f186-47e7-9bdc-26036460aed7.png?auto=compress,format&amp;format=webp" alt="PausableComposition生命周期流程图" /></p>

<ul>
<li>resume(shouldPause: ShouldPauseCallback)：这是引擎。预取系统（此处指 LazyColumn 上下文）会反复调用 resume() 来执行大量的组合工作。神奇之处在于 shouldPause 回调。Compose 运行时会在组合过程中频繁调用此 lambda。如果它返回 true（例如，由于帧截止时间已近），则组合过程将停止，并将主线程交还给更重要的工作，例如绘制当前帧。</li>
<li>apply()：一旦 resume() 返回 true，即表示操作完成，就会调用 apply()。这会获取所有计算出的界面更改，并将其提交到实际的界面树中。</li>
<li>cancel()：如果用户滚动离开，并且不再需要预先组合的项目，则会调用 cancellation() 来丢弃工作并释放资源。</li>
</ul>


<h3>内部结构概览：PausedCompositionImpl</h3>

<p>上述状态机由内部的 PausedCompositionImpl 类管理。该类保存状态并连接所有部分。</p>

<pre><code class="Kotlin">// https://cs.android.com/androidx/platform/frameworks/support/+/8d08d42d60f7cc7ec0034d0b7ff6fd953516d96a:compose/runtime/runtime/src/commonMain/kotlin/androidx/compose/runtime/PausableComposition.kt;l=202
internal class PausedCompositionImpl(...) : PausedComposition {
    private var state = PausedCompositionState.InitialPending
    internal val pausableApplier = RecordingApplier(applier.current)
    // ...

    override fun resume(shouldPause: ShouldPauseCallback): Boolean {
        when (state) {
            PausedCompositionState.InitialPending -&gt; {
                // This is the first time resume() is called.
                // It starts the initial composition of the content.
                invalidScopes =
                    context.composeInitialPaused(composition, shouldPause, content)
                state = PausedCompositionState.RecomposePending
                if (invalidScopes.isEmpty()) markComplete()
            }
            PausedCompositionState.RecomposePending -&gt; {
                // This is for subsequent calls to resume().
                state = PausedCompositionState.Recomposing
                // It tells the Composer to continue where it left off,
                // processing any pending invalidations.
                invalidScopes =
                    context.recomposePaused(composition, shouldPause, invalidScopes)
                state = PausedCompositionState.RecomposePending
                if (invalidScopes.isEmpty()) markComplete()
            }
            // ... other states like Recomposing, Applied, Cancelled are handled here ...
        }
        return isComplete
    }

    override fun apply() {
        // ... other state checks ...
        if (state == PausedCompositionState.ApplyPending) {
            applyChanges() // The call site
            state = PausedCompositionState.Applied
        }
        // ...
    }

    private fun applyChanges() {
        // ...
        pausableApplier.playTo(applier, rememberManager)
        rememberManager.dispatchRememberObservers()
        rememberManager.dispatchSideEffects()
        // ...
    }
}
</code></pre>

<p>调用 resume() 时，它会检查其内部状态并采取相应的措施：</p>

<ul>
<li>InitialPending：首次调用时，它会通过调用 context.composeInitialPaused 启动合成过程。这会告知核心 ComposerImpl 开始执行 @Composable 内容，并执行 shouldPause 回调。</li>
<li>RecomposePending：后续调用时，它会通过调用 context.recomposePaused 继续工作。此方法用于处理合成中任何因状态变化而失效的部分，或继续之前暂停的工作。</li>
<li>Applier：在此过程中，ComposerImpl 将所有 UI 更改操作转发给 pausableApplier（即 RecordingApplier），该操作会进行缓冲，而不是立即应用。</li>
<li>此过程持续进行，直到工作完成或 shouldPause 回调返回 true。</li>
</ul>


<h3>RecordingApplier：推迟最后的润色</h3>

<p>一个关键的性能技巧是 RecordingApplier。调用 resume() 时，Composer 不会直接更改实时 UI 树。如果分小步执行，可能会很慢，并导致 UI 更新不完整，显得怪异。</p>

<p>PausableComposition 使用的是 RecordingApplier。这个特殊的 Applier 会将其应该执行的所有 UI 操作（例如“创建 Text 节点”、“设置其文本属性”或“添加子图像”）记录到一个内部列表中。</p>

<p>只有调用 PausedComposition.apply() 时，RecordingApplier 才会将其记录的操作列表“回放”到实际的 Applier 上，从而高效地单步更新 UI 树。PausedComposition 的公共 apply() 方法是一个简单的状态机守卫。真正的工作发生在内部的 applyChanges() 方法中（如上面的代码片段所示）。</p>

<p>当调用 applyChanges 时，它会按顺序执行三项关键操作：</p>

<ul>
<li>它会告诉 RecordingApplier 将其所有缓冲的命令播放到实际的 applier 上。这才是 UI 真正出现在屏幕上的关键。</li>
<li>它会为所有已创建的 RememberObservers（例如 DisposableEffect）调度所有 onRemembered 生命周期回调。</li>
<li>最后，它会运行在合成过程中排队的所有 SideEffect。</li>
</ul>


<p>这种有序的批处理过程确保 UI 高效更新，并且所有生命周期事件都在正确的时间发生。</p>

<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1751794209046/49f5c1c7-b424-4c7d-a017-8ba65bb7b2d3.png?auto=compress,format&amp;format=webp" alt="PausableComposition时序图" /></p>

<h2>使用了 PausableComposition 的 LazyList</h2>

<p>LazyList 已经开始使用 PausableComposition API了。在 LazyList 中，PausableComposition 并非独立工作，而是协同工作的系统的一部分。</p>

<ul>
<li>指挥器 (Recomposer)：主 Recomposer 负责控制节奏，驱动可见 UI 的逐帧更新。</li>
<li>规划器 (LazyLayoutPrefetchState)：当用户滚动时，此组件会预测哪些项目即将显示。</li>
<li>舞台管理器 (SubcomposeLayout)：这个强大的 SubcomposeLayout 是 LazyList 的基础。它的 SubcomposeLayoutState 可以在需要时为各个项目创建和管理合成。最重要的是，它提供了 createPausedPrecomposition() API。</li>
<li>舞台调度器 (PrefetchScheduler)：此调度器会在帧之间寻找空闲时间来执行规划器请求的预合成工作。</li>
</ul>


<p>了解此功能的开发过程也很有趣。在 LazyLayoutPrefetchState 文件中，你可以找到控制它的功能标志：</p>

<pre><code class="Kotlin">// A simplified look inside LazyLayoutPrefetchState.kt: https://cs.android.com/androidx/platform/frameworks/support/+/8d08d42d60f7cc7ec0034d0b7ff6fd953516d96a:compose/foundation/foundation/src/commonMain/kotlin/androidx/compose/foundation/lazy/layout/LazyLayoutPrefetchState.kt;l=647
if (ComposeFoundationFlags.isPausableCompositionInPrefetchEnabled) {
    // This is the future, modern path.
    performPausableComposition(key, contentType, average)
} else {
    // This is the older, non-pausable fallback.
    performFullComposition(key, contentType)
}
</code></pre>

<p>isPausableCompositionInPrefetchEnabled 这个标志充当了终止开关的作用。虽然它在源代码中的默认值为 false。如果你想在惰性布局（LazyColumn、LazyRow 等）中启用可暂停组合行为，我们可以简单地按如下方式启用它：</p>

<pre><code class="Kotlin">class MyApplication : Application() {
    fun onCreate() {
        ComposeFoundationFlags.isPausableCompositionInPrefetchEnabled = true
        super.onCreate()
    }
}
</code></pre>

<h3>规划器：LazyLayoutPrefetchState 详解</h3>

<p>LazyLayoutPrefetchState 是预取操作的核心。它的作用是获取来自 LazyLayout 的预测（例如，“第 25 项即将上线”），并将其转换为实际的预组合任务。</p>

<p>它通过 PrefetchHandleProvider 实现此操作，该提供者会创建一个 PrefetchRequest。此请求是 PrefetchScheduler 可以执行的工作单元。在这个请求中，我们找到了暂停逻辑的核心。</p>

<p>当 PrefetchScheduler 执行请求时，它会进入一个循环，在 PausableComposition 上调用 resume()。传递给 resume 的 lambda 表达式决定是否暂停。</p>

<p>因此，如果启用了上述功能标记，它将通过 Pausable Composition API 执行请求，如下所示：</p>

<pre><code class="Kotlin">// https://cs.android.com/androidx/platform/frameworks/support/+/8d08d42d60f7cc7ec0034d0b7ff6fd953516d96a:compose/foundation/foundation/src/commonMain/kotlin/androidx/compose/foundation/lazy/layout/LazyLayoutPrefetchState.kt;l=754
// Simplified from HandleAndRequestImpl inside LazyLayoutPrefetchState
private fun PrefetchRequestScope.performPausableComposition(...) {
    val composition = // get the composition for the item of the LazyLayout 
    pauseRequested = false

    while (!composition.isComplete &amp;&amp; !pauseRequested) {
        composition.resume {
            if (!pauseRequested) {
                // 1. Update how much time is left in this frame's idle window.
                updateElapsedAndAvailableTime()

                // 2. Save how long this work chunk took, to improve future estimates.
                averages.saveResumeTimeNanos(elapsedTimeNanos)

                // 3. The Core Decision: Is there enough time left to do another
                //    chunk of work without risking a frame drop?
                pauseRequested = !shouldExecute(
                    availableTimeNanos,
                    averages.resumeTimeNanos + averages.pauseTimeNanos,
                )
            }
            // 4. Return the decision to the composition engine.
            pauseRequested
        }
    }

    updateElapsedAndAvailableTime()
    if (pauseRequested) {
        // If we decided to pause, record how long the final pause check took.
        averages.savePauseTimeNanos(elapsedTimeNanos)
    } else {
        // If we finished without pausing, record the time for the final resume chunk.
        averages.saveResumeTimeNanos(elapsedTimeNanos)
    }
}
</code></pre>

<p>让我们分解一下这个逻辑：</p>

<ol>
<li>updateElapsedAndAvailableTime()：在恢复 lambda 函数内部，系统会不断检查距离下一帧需要绘制还剩多少时间。</li>
<li>averages.saveResumeTimeNanos(&hellip;)：它会记录每个小块合成工作所需的时间。这有助于它构建一个平均值 (averages) 来预测未来工作的成本。</li>
<li>!shouldExecute(&hellip;)：这是核心决策。它会将 availableTimeNanos 与预算进行比较。这个预算是一个智能估算：完成另一块工作所需的平均时间加上暂停所需的平均时间。如果时间不足，pauseRequested 会变为 true。</li>
<li>最终计时：在本次循环退出后（因为工作完成或请求暂停），会调用最后一次 updateElapsedAndAvailableTime()。这会捕获最后一个操作的时间。</li>
<li>保存平均值：然后系统会保存这个最终计时。如果请求了暂停，则它会影响 pauseTimeNanos。如果循环自然完成，则它会影响 resumeTimeNanos。这确保了用于未来预测的历史数据始终准确。</li>
</ol>


<p>这种自我调节的反馈循环允许预取器在系统空闲时保持积极主动，但在需要渲染 UI 时又能保持礼貌，尊重主线程。</p>

<h3>最后一步：应用预组合 UI</h3>

<p>那么，当屏幕上真正需要预组合的项目时会发生什么呢？这时 SubcomposeLayout 就占据了中心位置。在正常的测量过程中，它会为现在可见的项目调用其 subcompose 函数。在内部，这会触发最后一步。</p>

<pre><code class="Kotlin">// https://cs.android.com/androidx/platform/frameworks/support/+/8d08d42d60f7cc7ec0034d0b7ff6fd953516d96a:compose/ui/ui/src/commonMain/kotlin/androidx/compose/ui/layout/SubcomposeLayout.kt;l=1186
// Simplified from LayoutNodeSubcompositionsState inside SubcomposeLayout.kt
private fun NodeState.applyPausedPrecomposition(shouldComplete: Boolean) {
    val pausedComposition = this.pausedComposition
    if (pausedComposition != null) {
        // 1. If the work must be completed now...
        if (shouldComplete) {
            // ...force the composition to finish by looping `resume`
            // and always passing `false` to the `shouldPause` callback.
            while (!pausedComposition.isComplete) {
                pausedComposition.resume { false }
            }
        }
        // 2. Apply the changes to the real UI tree.
        pausedComposition.apply()
        this.pausedComposition = null // Clear the handle.
    }
}
</code></pre>

<p>当某个项目可见时，其组合不再是低优先级的后台任务，而是高优先级的同步任务。shouldComplete = true 参数确保所有剩余的组合工作立即完成，无需暂停。然后，apply() 被调用，完整的 UI 会立即显示在屏幕上。</p>

<p>它们如何协同工作：</p>

<p><img src="https://cdn.hashnode.com/res/hashnode/image/upload/v1751799217100/82837ef0-e97e-49c7-bee6-cd68ab1804ba.png?auto=compress,format&amp;format=webp" alt="LazyList滚动时序图" /></p>

<h2>结论</h2>

<p>深入研究 Compose 运行时后，PausableComposition 的设计堪称性能工程的杰作。</p>

<ul>
<li>它并非魔法，而是延迟：其核心理念是在紧急任务之前完成。通过在空闲时间合成项目，快速滚动时主线程所需的工作量会大大减少。</li>
<li>协作式和非阻塞式：shouldPause 回调是处理多任务的绝佳方式。它可以让长时间运行的合成任务优雅地让位于更紧急的当前帧渲染任务，从而直接防止卡顿。</li>
<li>通过批处理提高效率：RecordingApplier 通过将 UI 树中的许多小的独立更改分组为单个高效的更新，避免了这些更改带来的开销。</li>
</ul>


<p>虽然 PausableComposition 是一个你可能永远不会直接使用的内部功能，但了解它的存在和运作方式，可以让你真正体会到 Jetpack Compose 如此高性能的明智决策。下次你轻松流畅地滚动浏览复杂的 LazyColumn 时，你就会体会到这巧妙且精心编排的“舞蹈”是如何在表面之下进行的。✅ 这种架构不仅解决了当前的性能挑战，还为 Compose 未来更先进的渲染策略铺平了道路。</p>

<p>希望你已经了解了这个新 API 在 Jetpack Compose 中的工作原理。</p>

<p>太棒了！希望你从中获得了一些宝贵的见解。如果你喜欢这篇文章，请分享 😉，因为……</p>

<p>“分享即关爱”</p>

<p>谢谢！😄</p>

<p>让我们一起回顾 X （链接：<a href="https://twitter.com/imShreyasPatil%EF%BC%89%E7%9A%84%E6%9C%80%E6%96%B0%E5%8A%A8%E6%80%81%EF%BC%8C%E6%88%96%E8%80%85%E8%AE%BF%E9%97%AE%E6%88%91%E7%9A%84%E7%BD%91%E7%AB%99%EF%BC%88%E9%93%BE%E6%8E%A5%EF%BC%9Ahttps://shreyaspatil.dev/%EF%BC%89%E4%BA%86%E8%A7%A3%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84%E4%BF%A1%E6%81%AF">https://twitter.com/imShreyasPatil%EF%BC%89%E7%9A%84%E6%9C%80%E6%96%B0%E5%8A%A8%E6%80%81%EF%BC%8C%E6%88%96%E8%80%85%E8%AE%BF%E9%97%AE%E6%88%91%E7%9A%84%E7%BD%91%E7%AB%99%EF%BC%88%E9%93%BE%E6%8E%A5%EF%BC%9Ahttps://shreyaspatil.dev/%EF%BC%89%E4%BA%86%E8%A7%A3%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84%E4%BF%A1%E6%81%AF</a> 😎。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SnapshotFlow还是collectAsState？对于Jetpack Compose来说哪个更香？]]></title>
    <link href="https://alexhilton.github.io/blog/2025/07/16/snapshotflow-or-collectasstate/"/>
    <updated>2025-07-16T22:31:22+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/07/16/snapshotflow-or-collectasstate</id>
    <content type="html"><![CDATA[<p>本文译自「SnapshotFlow or collectAsState? How to pick the right tool for Jetpack Compose」，原文链接<a href="https://proandroiddev.com/snapshotflow-or-collectasstate-how-to-pick-the-right-tool-for-jetpack-compose-d6f1cc9d2123">https://proandroiddev.com/snapshotflow-or-collectasstate-how-to-pick-the-right-tool-for-jetpack-compose-d6f1cc9d2123</a>，由Dmitry Glazunov发布于2025年7月7日。</p>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*P0darOG2IeBIDWdY" title="auto auto" ></a></p>

<!-- more -->


<p>构建 UI 可能感觉很简单，直到需要订阅状态变化并有效处理副作用时之前。许多开发者过度使用 collectAsState，导致延迟和意外的重组（reComposition）。还有一些人听说过 snapshotFlow，但却不太明白既然 StateFlow 和 collectAsState 已经存在，为什么还需要它？</p>

<p>在这篇文章中，我将通过探索实际项目中简短且实用的示例，分享我对何时使用 snapshotFlow 以及何时更适合使用 collectAsState 的看法，帮助你避免项目中隐藏的 bug 和性能问题。</p>

<p>让我们来详细分析一下。</p>

<h2>collectAsState 的作用</h2>

<p>collectAsState 在 Compose 中订阅 Flow，并自动将其公开为State，以便在 UI 中轻松显示：</p>

<pre><code class="Kotlin">val uiState by viewModel.uiStateFlow.collectAsState()
Text(uiState.text)
</code></pre>

<p>要点：</p>

<ul>
<li>非常易于使用。</li>
<li>重组时自动取消并重新开始收集。</li>
<li>非常适合 ViewModel → UI 数据绑定。</li>
</ul>


<p>但是：</p>

<ul>
<li>每次发出新数据时都会触发重组，哪怕只是发生了微小的变化。</li>
<li>可组合项进入重组状态后立即开始收集。</li>
<li>不适用于观察 Compose 特有的状态，例如滚动或手势。</li>
</ul>


<h2>快照流 (snapshotFlow) 的作用</h2>

<p>快照流 (snapshotFlow) 将 Compose 状态（例如 LazyListState 、 derivedStateOf ）转换为冷流 (cold Flow)，让你无需进行不必要的重组即可对状态变化做出反应：</p>

<pre><code class="Kotlin">val listState = rememberLazyListState()

LaunchedEffect(Unit) {
    snapshotFlow { listState.firstVisibleItemIndex }
        .distinctUntilChanged()
        .collect { index -&gt;
            analytics.logScrollPosition(index)
        }
}
</code></pre>

<p>要点：</p>

<ul>
<li>非常适合 Compose 状态变化的副作用。</li>
<li>不会触发重组。</li>
<li>可在 LaunchedEffect 或协程中使用。</li>
</ul>


<p>但是：</p>

<ul>
<li>不会公开状态以进行直接 UI 渲染。</li>
<li>不会替代 CollectAsState 来实现 ViewModel → UI 更新。</li>
</ul>


<h2>何时使用 collectAsState</h2>

<ul>
<li>从 ViewModel 订阅 UI 的 Flow 或 StateFlow。</li>
<li>在 UI 中显示数据（文本、加载状态、获取的数据）。</li>
<li>用户需要看到的低频更新。</li>
</ul>


<p>避免使用：</p>

<ul>
<li>高频更新（滚动偏移、传感器数据）。</li>
<li>触发不需要 UI 更新的副作用。</li>
</ul>


<h2>何时使用 snaphotFlow</h2>

<ul>
<li>响应 Compose 状态（滚动、手势、动画）。</li>
<li>触发副作用但不会导致重组。</li>
<li>从 Compose 状态构建 Flow 管道（分析、延迟加载触发器）。</li>
</ul>


<p>避免使用：</p>

<ul>
<li>直接 UI 数据渲染。</li>
<li>用 viewModel → UI 流替换 collectAsState。</li>
</ul>


<h2>snapshotFlow 的实用示例</h2>

<p>错误体位：使用 snaphotFlow.collectAsState 进行动画进度</p>

<pre><code class="Kotlin">val progress by snapshotFlow { animationState.progress }
    .collectAsState(initial = 0f)

Text("Progress: ${(progress * 100).toInt()}%")
</code></pre>

<p>使用 snaphotFlow 和 collectAsState 来驱动动画进度的 UI 更新会导致每一帧都重新合成，从而导致卡顿，违背了 snaphotFlow 的初衷。</p>

<p>正确姿式：使用 snaphotFlow 在动画过程中进行分析</p>

<pre><code class="Kotlin">LaunchedEffect(Unit) {
    snapshotFlow { animationState.progress }
        .distinctUntilChanged { old, new -&gt;
            (old * 100).toInt() == (new * 100).toInt()
        }
        .collect { progress -&gt;
            analytics.logAnimationProgress(progress)
        }
}
</code></pre>

<p>这会跟踪动画进度，以便进行分析或记录，而不会触发 UI 重构。</p>

<h2>collectAsState 的实用示例</h2>

<p>错误体位：将 collectAsState 用于高频滚动数据</p>

<pre><code class="Kotlin">val scrollOffset by viewModel.scrollOffsetFlow.collectAsState()
Text("Offset: $scrollOffset")
</code></pre>

<p>这会在滚动的每个像素上触发重新合成，导致 CPU 过载。</p>

<p>正确姿式：使用 collectAsState 获取有意义的 UI 数据</p>

<pre><code class="Kotlin">val userName by viewModel.userNameFlow.collectAsState()
Text("Hello, $userName!")
</code></pre>

<p>这适用于显示用户需要查看且不经常更改的数据。</p>

<h2>结论</h2>

<p>collectAsState 和 snapshotFlow 相辅相成：</p>

<ul>
<li>使用 collectAsState 在 UI 中显示 ViewModel 数据。</li>
<li>使用 snapshotFlow 响应 Compose 状态变化的副作用，而无需触发重组。</li>
</ul>


<p>正确使用它们将帮助你避免不必要的重组，提升应用的响应速度，并保持 Compose 代码简洁、可扩展且可预测。</p>

<p>如果你觉得本文分析有用，请随时关注我以获取更多见解。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Kotlin Multiplatform项目中使用DataStore]]></title>
    <link href="https://alexhilton.github.io/blog/2025/06/04/datastore-in-kmp/"/>
    <updated>2025-06-04T23:05:35+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/06/04/datastore-in-kmp</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Implementing DataStore in Kotlin Multiplatform Projects」，原文链接<a href="https://carrion.dev/en/posts/datastore-in-kmp/">https://carrion.dev/en/posts/datastore-in-kmp/</a>，由 Ignacio Carrión发布于2025年5月9日。</p></blockquote>

<p>DataStore 是 Google 开发的一种现代数据存储解决方案，用于替代 SharedPreferences。它提供了一个一致、类型安全的 API，用于存储键值对和类型化对象，并支持 Kotlin 协程和 Flow。随着 Kotlin Multiplatform (KMP) 的最新进展，我们现在可以将 DataStore 集成到 KMP 项目中，从而实现跨平台共享偏好设置和数据存储代码。这篇博文探讨了如何在 KMP 环境中配置、实现和优化 DataStore。</p>

<p><a href=""><img src="file:///Users/alexhilton/Downloads/datastore.png" title="auto auto" ></a></p>

<!-- more -->


<h2>理解 Kotlin 多平台环境中的 DataStore</h2>

<p>KMP 中的 DataStore 旨在提供跨平台一致的 API，同时利用平台特定的存储机制。DataStore 有两种类型：</p>

<ol>
<li>Preferences DataStore：用于存储键值对</li>
<li>Proto DataStore：用于使用协议缓冲区存储类型化对象</li>
</ol>


<p>在 KMP 上下文中，DataStore：</p>

<ol>
<li>平台特定的实现提供实际的存储机制</li>
<li>API 使用协程和 Flow，跨平台保持一致</li>
</ol>


<p>这种方法使我们能够用通用代码定义数据访问模式，而底层存储操作则由平台特定的实现处理。</p>

<pre><code class="Kotlin">// In commonMain - DataStore interface
interface UserPreferences {
    val userData: Flow&lt;UserData&gt;
    suspend fun updateUsername(name: String)
    suspend fun updateEmail(email: String)
    suspend fun clearData()
}

// In commonMain - Data model
data class UserData(
    val username: String = "",
    val email: String = "",
    val isLoggedIn: Boolean = false
)
</code></pre>

<h2>在 KMP 项目中设置数据存储</h2>

<p>要将 DataStore 集成到你的 KMP 项目中，你需要正确配置构建文件。以下是分步指南：</p>

<h3>1. 在共享模块中配置 build.gradle.kts 文件</h3>

<pre><code class="Kotlin">plugins {
    kotlin("multiplatform")
    id("com.android.library")
    id("com.google.devtools.ksp") version "2.1.20-2.0.1" // For Proto DataStore
}

kotlin {
    androidTarget()
    iosX64()
    iosArm64()
    iosSimulatorArm64()

    sourceSets {
        val commonMain by getting {
            dependencies {
                // For Preferences DataStore
                implementation("androidx.datastore:datastore-preferences-core:1.1.0")

                // For coroutines
                implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3")
            }
        }
    }
}
</code></pre>

<h3>2. 从通用代码创建 DataStore 实例</h3>

<pre><code class="Kotlin">/**
 * 获取单例 DataStore 实例，如有必要则创建它。
 */
fun createDataStore(producePath: () -&gt; String): DataStore&lt;Preferences&gt; =
   PreferenceDataStoreFactory.createWithPath(
      produceFile = { producePath().toPath() }
   )

internal const val dataStoreFileName = "dice.preferences_pb"
</code></pre>

<h2>特定平台的考虑因素</h2>

<h3>Android 实现</h3>

<pre><code class="Kotlin">// shared/src/androidMain/kotlin/DataStore.kt

fun createDataStoreAndroid(context: Context): DataStore&lt;Preferences&gt; = createDataStore(
   producePath = { context.filesDir.resolve(dataStoreFileName).absolutePath }
)
</code></pre>

<h3>iOS 实现</h3>

<pre><code class="Kotlin">// shared/src/iosMain/kotlin/DataStore.kt

fun createDataStoreIOS(): DataStore&lt;Preferences&gt; = createDataStore(
   producePath = {
      val documentDirectory: NSURL? = NSFileManager.defaultManager.URLForDirectory(
         directory = NSDocumentDirectory,
         inDomain = NSUserDomainMask,
         appropriateForURL = null,
         create = false,
         error = null,
      )
      requireNotNull(documentDirectory).path + "/$dataStoreFileName"
   }
)
</code></pre>

<h2>实际示例：实现用户偏好存储库</h2>

<p>为了演示完整的实现，让我们创建一个使用 DataStore 的存储库：</p>

<pre><code class="Kotlin">// In commonMain
class UserPreferencesRepository(private val dataStore: PreferencesDataStore) {
    //定义preferences的键
    private object PreferenceKeys {
        val USERNAME = stringPreferencesKey("username")
        val EMAIL = stringPreferencesKey("email")
        val IS_LOGGED_IN = booleanPreferencesKey("is_logged_in")
    }

    // Get user data as a Flow
    val userData: Flow&lt;UserData&gt; = dataStore.data.map { preferences -&gt;
        UserData(
            username = preferences[PreferenceKeys.USERNAME] ?: "",
            email = preferences[PreferenceKeys.EMAIL] ?: "",
            isLoggedIn = preferences[PreferenceKeys.IS_LOGGED_IN] ?: false
        )
    }

    // Update username
    suspend fun updateUsername(name: String) {
        dataStore.updateData { preferences -&gt;
            preferences.toMutablePreferences().apply {
                this[PreferenceKeys.USERNAME] = name
            }
        }
    }

    // Update email
    suspend fun updateEmail(email: String) {
        dataStore.updateData { preferences -&gt;
            preferences.toMutablePreferences().apply {
                this[PreferenceKeys.EMAIL] = email
            }
        }
    }

    // Set login status
    suspend fun setLoggedIn(isLoggedIn: Boolean) {
        dataStore.updateData { preferences -&gt;
            preferences.toMutablePreferences().apply {
                this[PreferenceKeys.IS_LOGGED_IN] = isLoggedIn
            }
        }
    }

    // Clear all data
    suspend fun clearData() {
        dataStore.updateData { preferences -&gt;
            preferences.toMutablePreferences().apply {
                remove(PreferenceKeys.USERNAME)
                remove(PreferenceKeys.EMAIL)
                remove(PreferenceKeys.IS_LOGGED_IN)
            }
        }
    }
}

// In commonMain - ViewModel or Presenter
class UserViewModel(private val userPreferencesRepository: UserPreferencesRepository) {
    val userData: Flow&lt;UserData&gt; = userPreferencesRepository.userData

    suspend fun updateUserProfile(username: String, email: String) {
        if (username.isNotBlank()) {
            userPreferencesRepository.updateUsername(username)
        }

        if (email.isNotBlank()) {
            userPreferencesRepository.updateEmail(email)
        }
    }

    suspend fun login() {
        userPreferencesRepository.setLoggedIn(true)
    }

    suspend fun logout() {
        userPreferencesRepository.setLoggedIn(false)
    }

    suspend fun clearUserData() {
        userPreferencesRepository.clearData()
    }
}
</code></pre>

<h2>KMP 中的高级数据存储功能</h2>

<p>DataStore 提供了几种可在 KMP 环境中利用的高级功能：</p>

<h3>1. 用于类型化对象的 Proto DataStore</h3>

<p>如果你需要存储复杂对象，Proto DataStore 提供了一个类型安全的解决方案：</p>

<pre><code class="proto">// 在 .proto 文件中定义数据结构
syntax = "proto3";

option java_package = "com.example.app";
option java_multiple_files = true;

message UserPreferences {
  string username = 1;
  string email = 2;
  bool is_logged_in = 3;
}
</code></pre>

<pre><code class="Kotlin">// In commonMain - 创建序列化器
class UserPreferencesSerializer : Serializer&lt;UserPreferences&gt; {
    override val defaultValue: UserPreferences = UserPreferences.getDefaultInstance()

    override suspend fun readFrom(input: InputStream): UserPreferences {
        return UserPreferences.parseFrom(input)
    }

    override suspend fun writeTo(t: UserPreferences, output: OutputStream) {
        t.writeTo(output)
    }
}

// Proto DataStore 的平台特定实现
</code></pre>

<h3>2.数据迁移</h3>

<pre><code class="Kotlin">// In androidMain - 从 SharedPreferences 迁移到 DataStore
val dataStore = context.createDataStore(
    name = "user_preferences",
    produceMigrations = { context -&gt;
        listOf(
            SharedPreferencesMigration(
                context = context,
                sharedPreferencesName = "legacy_preferences"
            )
        )
    }
)
</code></pre>

<h3>3.处理异常</h3>

<pre><code class="Kotlin">// In commonMain - 数据操作过程中的异常处理
val userData = dataStore.data
    .catch { exception -&gt;
        // 处理异常（例如数据损坏）
        if (exception is IOException) {
            emit(emptyPreferences())
        } else {
            throw exception
        }
    }
    .map { preferences -&gt;
        // Map preferences to your data model
        UserData(
            username = preferences[USERNAME] ?: "",
            email = preferences[EMAIL] ?: ""
        )
    }
</code></pre>

<h2>KMP 中数据存储的最佳实践</h2>

<ol>
<li>利用协程和 Flow 进行异步操作

<ul>
<li>DataStore 操作本质上是异步的</li>
<li>使用 Flow 观察存储数据的变化</li>
<li>应用 Map、Filter 和 Combine 等 Flow 操作符进行数据转换</li>
</ul>
</li>
<li>创建存储库层

<ul>
<li>将 DataStore 操作抽象到存储库后面</li>
<li>这样可以更轻松地根据需要切换实现</li>
<li>为你的业务逻辑提供简洁的 API</li>
</ul>
</li>
<li>优雅地处理错误

<ul>
<li>使用 catch 操作符处理 Flow 中的异常</li>
<li>在无法读取数据时提供回退值</li>
<li>考虑为关键操作实现重试机制</li>
</ul>
</li>
<li>优化性能

<ul>
<li>最大限度地减少 DataStore 更新次数</li>
<li>将相关的更改集中处理</li>
<li>使用 distinctUntilChanged() 避免不必要的排放</li>
</ul>
</li>
<li>彻底测试你的 DataStore 代码

<ul>
<li>在 commonTest 中为你的存储库编写测试</li>
<li>使用测试替身模拟不同的场景</li>
</ul>
</li>
</ol>


<h2>结论</h2>

<p>将 DataStore 集成到 Kotlin Multiplatform 项目中，提供了一种现代化、类型安全的跨平台数据存储和访问方法。</p>

<p>本文概述的方法提供了一种实用的方法，可以跨平台共享首选项和数据存储逻辑，并且只需极少的平台特定代码。DataStore 对协程和 Flow 的支持使其与 KMP 项目完美契合，能够通过一致的 API 实现响应式和异步数据操作。</p>

<p>通过遵循本文概述的配置步骤、平台特定注意事项和最佳实践，你可以在 KMP 项目中成功实现 DataStore，并创建稳定、高效的跨平台数据存储解决方案，并且只需极少的平台特定代码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[揭秘原生View与Jetpack Compose之间的传送门]]></title>
    <link href="https://alexhilton.github.io/blog/2025/06/02/android-vies-in-compose/"/>
    <updated>2025-06-02T21:44:19+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/06/02/android-vies-in-compose</id>
    <content type="html"><![CDATA[<p>芳菲随春去，碧绿入夏来，不知不觉中<a href="https://juejin.cn/column/7367555191338467337">Compose专题</a>已经写了近40篇文章了，从Compose各组件的使用方法，到Compose的编程思想，再到内部原理和最佳实践。通过<a href="https://juejin.cn/column/7367555191338467337">这一系列的文章</a>相信对Compose已经有了足够的理解，能够在项目中进行实战和运用。学无止境，今天将继续学习，重点探讨如何在已有的项目中使用Compose。</p>

<p><a href=""><img src="file:///Users/alexhilton/Downloads/portal_2.png" title="auto auto" ></a></p>

<!-- more -->


<h2>缘起</h2>

<p>无疑Jetpack Compose是一个优秀的声明式UI框架，它与原生的View方式最大的区别，在于思考问题的方式上并不一样。声明式框架能把开发者从繁杂的命令式的UI细节中解放出来，重点思考一个好的体验应该是什么样子的，而具体的UI细节由框架来处理。尽管如此，毕竟Compose是近几年来发展起来的，现今大量的项目仍是原生View主导的。此外，Compose也还在发展中，有些特定业务领域如Camera，视频，3D渲染，还没有能力支持。因此，整合原生View和Compose是项目中很现实的一个难题，本文将重点讨论两个议题：一个是如何在原生View中嵌入Compose，另一个就是如何在Compose中嵌入原生View。</p>

<p><strong>注意：</strong> 本文中提到的两个组件ComposeView和AndroidView都仅在Jetpack Compose（for Android）生效，并不适用于跨平台的Compose Multiplatform。</p>

<h2>在原生View中嵌入Compose</h2>

<p>第一个传送门是如何进入Compose的世界。相信现在绝大多数项目都是基于原生View的，借助<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/ComposeView">ComposeView</a>就可以进入到Compose的世界。</p>

<pre><code class="Kotlin">    val composeView = ComposeView(context).apply {
                setContent {
                    // 这里调用Composables
                }
            }
</code></pre>

<p>ComposeView是View的一个子类，能够作为Compose的容器，在<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/ComposeView#setContent(kotlin.Function0">其setContent方法</a>)中提供一个Composable即可。ComposeView与其他View一样，可以用在View tree中，用在Fragment里和Activity里面。实际上作为平台的入口ComponentActivity用的也是ComposeView。</p>

<h3>在View层级中直接嵌入</h3>

<p>ComposeView就是一个普通的Android View，跟其他View的子类是一样的，所以可以把它放在任何可以使用View的地方，比如一个布局里面，作为一个页面的一部分。</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/container"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity"&gt;

    &lt;androidx.compose.ui.platform.ComposeView
        android:id="@+id/compose_view"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" /&gt;

    &lt;Button
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="WidgetButton"
        /&gt;
&lt;/LinearLayout&gt;
</code></pre>

<p><strong>注意：</strong> 尽管可以把ComposeView当成普通的View，直接嵌入到布局中，作为页面中的一部分，但这并不是一个好的做法，一来是不能发挥Compose的优势，另外Compose本身是有特定的生命周期的（重组），它需要知道平台的生命周期，以管控它自己的生命周期。而常规的View tree之中是没有平台生命周期的，因为常规的View tree并不关心平台的生命周期，view tree主要受窗口影响（attachToWindow，detachFromWindow），这个与平台组件的生命周期没有关系。</p>

<h3>用在Fragment中</h3>

<p>想要在某个Fragment中集成Compose的方式就是把ComposeView作为Fragment的根View即可：</p>

<pre><code class="Kotlin">class ExampleFragmentNoXml : Fragment() {

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        return ComposeView(requireContext()).apply {
            // 当View的宿主destroy时销毁组合
            setViewCompositionStrategy(ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed)
            setContent {
                MaterialTheme {
                    // 进入到Compose世界
                    Text("Hello Compose!")
                }
            }
        }
    }
}
</code></pre>

<h3>用在Activity中</h3>

<p>这其实是最好的方式，在一个新的页面窗口中使用Compose，这就能与其余view独立开来，是最为理想的。</p>

<pre><code class="Kotlin">class ExampleActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContent {
            MaterialTheme {
                Greeting(name = "compose")
            }
        }
    }
}

@Composable
fun Greeting(name: String) {
    Text(text = "Hello $name!")
}
</code></pre>

<h3>使用建议</h3>

<p>虽然ComposeView可以当成一个普通的View来使用，但最为合理的方式就是在一个新的Activity中才使用Compose，也就是说当有一个全新的页面时，考虑使用Compose来开发，这样才能发挥出它的价值。</p>

<p>除非有特别的需求，否则不要把ComposeView作为现有页面的一部分嵌入到View tree中（也就是作为页面的一部分）。</p>

<p>至于在Fragment中使用，如果是一个全新的页面，而非现有布局的一部分，那也可以考虑使用Compose。</p>

<p><strong>注意：</strong> 其根本原因在于，我们使用Jetpack Compose并不是图它能实现什么特别的UI效果，Compose能做的事情View都能做，甚至它不能做的事情View也能做。用Compose是因为它是声明式的UI框架，在开发效率和可扩展性上面有巨大的优势。所以，只应该在想要发挥声明式框架优势的时候，才考虑使用它，并且应该从一个全新的页面开始。</p>

<h2>在Compose中嵌入原生View</h2>

<p>Jetpack Compose提供了足够丰富的组件，足以应对常规的UI，但它毕竟还不是特别的成熟，总会遇到一些场景，发现Compose无法胜任，而且并不是通过自定义组件就能够解决的，比如一些特定领域的UI，如camera，如视频，如3D渲染。或者说，已经有了自定义好的View，并不想重复开发。再或者说对于一些三方的库，它并没有对应的Compose组件。这些场景就需要把原生的View嵌入到Compose之中。</p>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/viewinterop/package-summary#AndroidView(kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Function1,kotlin.Function1,kotlin.Function1">AndroidView</a>)就是专门用于把原生View嵌入到Compose中的一个特殊composable。它就像一个传送门一样，能把原生的View，无论是一个现成的自定义View，还是特定领域的View或者三方库的View，带入到Compose中，变成一个composable。</p>

<h3>AndroidView的使用方法</h3>

<p>AndroidView是一个composable，把它放在想要的位置即可。它有三个参数，一个是常规的Modifier用以约束这个composable的；另两个是lambda，一个是用于创建View的，返回一个View的实例，只会被调用一次；另一个就是用于更新View的，会被调用多次：</p>

<pre><code class="Kotlin">@Composable
fun CustomView() {
    var selectedItem by remember { mutableStateOf(0) }

    // 添加原生View到Compose
    AndroidView(
        modifier = Modifier.fillMaxSize(),
        factory = { context -&gt;
            // 创建View的实例
            MyView(context).apply {
                // 设置View的点击事件，更新状态，这会触发重组
                setOnClickListener {
                    selectedItem = 1
                }
            }
        },
        update = { view -&gt;
            // 更新View的状态
            // 这里读了状态，所以重组时update会被再次调用，view能拿到最新的状态
            view.selectedItem = selectedItem
        }
    )
}

@Composable
fun ContentExample() {
    Column(Modifier.fillMaxSize()) {
        Text("Look at this CustomView!")
        CustomView()
    }
}
</code></pre>

<p><strong>注意：</strong> factory仅会被调用一次，用于创建View实例，update会被调用多次，用于更新view的状态，包括初次组合时，也就是factory执行之后，就会调用update。AndroidView函数会帮助提供View需要的参数context，以及管理View的实例，所以update中会把view当作参数传给我们，所以我们完全没有必要再用额外的状态（remember）去缓存View的实例了。</p>

<h3>使用建议</h3>

<p>虽然AndroidView是一个传送门，可以连接两个世界，但是能不用还是不要用，非必要不使用。如果能用Compose搞定的事情，还是要用Compose来搞，比如用Canvas去实现自定义组件。</p>

<p>需要使用AndroidView的场景只有三个：一是有现成的自定义View，拿过来就可以用，不想二次开发；二是三方库的View；三就是Compose确实搞不定的特定领域，如WebView，如视频，如SurfaceView或者3D渲染（OpenGL ES）等等。除以之外，不建议使用。</p>

<p>还需要特别注意的是，如果原生的View交互比较复杂，不光是点击，还涉及Touch事件处理，处理事件的同时还要不断更新View的状态，那也不应该使用它。比较理想的情况是，嵌入的这个View是一个比较纯粹的生产者，比如它只产生事件，不需要再往回更新状态；或者是一个比较纯粹的消费者，比如它就负责展示，只需要塞数据就行了。</p>

<h2>总结</h2>

<p>网上的教程或者Demo中的世界是很美好的，往往都是一个新建的项目，一个新的页面，直接就进入了Compose世界，也都在讲Compose能做的事情。但现实的世界往往不是这样子的，极少情况下是全新开始的项目，往往需要与遗留代码打交道，需要实现的需求也是多种多样的。本文中介绍了两个传送门，ComposeView和AndroidView可以方便地连接原生View和Compose两个世界，为现实项目中遇到的问题提供了一个可行的解决方案。</p>

<h3>让Compose支持OpenGL ES</h3>

<ul>
<li><a href="https://stackoverflow.com/questions/78796021/how-to-render-opengl-alongside-jetpack-compose-ui-without-covering-other-element">How to render OpenGL alongside Jetpack Compose UI without covering other elements</a></li>
<li><a href="https://www.reddit.com/r/Kotlin/comments/on36sy/experiment_to_make_opengl_work_together_with/?rdt=62185">Experiment to make OpenGL work together with Jetpack Compose</a></li>
<li><a href="https://composables.com/foundation/androidexternalsurface">AndroidExternalSurface</a></li>
<li><a href="https://youtrack.jetbrains.com/issue/CMP-3810/Using-Open-GL-with-Compose-Multiplatform">Using Open GL with Compose Multiplatform</a></li>
</ul>


<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/migrate/interoperability-apis/compose-in-views">Using Compose in Views</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/migrate/interoperability-apis/views-in-compose">Using Views in Compose</a></li>
<li><a href="https://medium.com/@seungbae2/jetpack-compose-androidview-seamless-integration-of-android-views-into-compose-ui-644f217437d3">Jetpack Compose AndroidView: Seamless Integration of Android Views into Compose UI</a></li>
<li><a href="https://stackoverflow.com/questions/59995970/using-custom-views-with-jetpack-compose">Using Custom Views with Jetpack Compose</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
