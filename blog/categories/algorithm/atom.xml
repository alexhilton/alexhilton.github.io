<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2024-03-28T23:06:52+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Understanding KMP Algorithm]]></title>
    <link href="http://toughcoder.net/blog/2023/12/11/understanding-kmp-algortihm/"/>
    <updated>2023-12-11T22:21:17+08:00</updated>
    <id>http://toughcoder.net/blog/2023/12/11/understanding-kmp-algortihm</id>
    <content type="html"><![CDATA[<p>字符串模式匹配问题是非常重要且基础的问题，它是解决在目标字符串str中搜索模式字符串pattern出现的次数，或者索引位置。这个问题最为高效的方法就是著名的KMP算法，但这个算法不太好理解，毕竟是解决了从O(n<sup>2</sup>)的复杂度提升到线程O(n)的，今天就来学习并理解一下KMP算法。</p>

<p><a href=""><img src="https://www.boardinfinity.com/blog/content/images/2022/10/27c5585ec1e3503400.webp" title="auto auto" ></a></p>

<!-- more -->


<p>字符串模式匹配问题有很多变幻，比如从头匹配就是前缀匹配，从后就是后缀匹配，找出所有匹配的索引，找第一个，看是否有匹配等等。以及其他能转化为模式匹配的问题，比如回文相关问题，但本质都<strong>模式匹配</strong>问题。这里就以寻找模式pattern在str中的第一个索引位置为例题。</p>

<h2>暴力大法</h2>

<p>世上无难题，只要能用暴力不超时。很容易写出一个暴力方法：</p>

<pre><code class="Java">int index(String str, String pattern) {
    int n = str.length();
    int m = str.length();
    for (int i = 0; i &lt;= n - m; i++) {
        int j = 0;
        while (j &lt; m &amp;&amp; str.charAt(i + j) == pattern.charAt(j)) {
            j++;
        }
        if (j == m) {
            return i;
        }
    }
    return -1;
}
</code></pre>

<p>很明显暴力大法的时间复杂度是O(nm)，需要从str中的每一个字符开始尝试去匹配pattern。str的指针在尝试这一次匹配后，只能向前<strong>步进一个</strong>，这是暴力大法最大的问题。假如能有方法让它步进的快一些，那么就能显著 的提升效率，这就是KMP算法的牛逼之处。</p>

<h2><a href="https://en.wikipedia.org/wiki/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm">KMP算法</a></h2>

<p>KMP算法的牛逼之处就是利用<strong>预处理</strong>和已做过的<strong>上一次匹配</strong>来<strong>快速步进</strong>str的i指针，使总的匹配次数降到O(n + m)。</p>

<p>无论是否能理解，好在代码不长，就当模板题背下来吧。</p>

<pre><code class="java">    public int index(String str, String pattern) {
        char[] sc = str.toCharArray();
        char[] pc = pattern.toCharArray();
        int n = sc.length;
        int m = pc.length;
        int[] next = calcNext(pc);

        for (int i = 0, j = 0; i &lt; n; i++) {
            while (j &gt; 0 &amp;&amp; sc[i] != pc[j]) {
                j = next[j - 1];
            }
            if (sc[i] == pc[j]) {
                j++;
            }
            if (j == m) {
                return i - m + 1;
            }
        }

        return -1;
    }

    private int[] calcNext(char[] pattern) {
        int m = pattern.length;
        int[] next = new int[m];
        int k = 0;
        for (int i = 1; i &lt; m; i++) {
            while (k &gt; 0 &amp;&amp; pattern[k] != pattern[i]) {
                k = next[k - 1];
            }
            if (pattern[k] == pattern[i]) {
                k++;
            }
            next[i] = k;
        }
        return next;
    }
</code></pre>

<p><strong>next数组</strong>的现实意义是在pattern中当前字符之前的<strong>最长前后缀长度</strong>。前后缀就是即是前缀，又是后缀，比如&#8217;abcddabc&#8217;，这里&#8217;abc&#8217;就是这个字符串的前后缀。next数组长度与pattern长度一致，next[i]的意义是，在pattern中截止到pattern[i]的子串的最长前后缀长度。要牢记next数组的意义，这会是KMP的重点应用范围，比如题214回文问题。</p>

<p>整个KMP算法，匹配过程并不难理解，主串的指针i从不回溯，一直在前进，而模式串的j指针则不断的跳转到其next数组指示的位置。核心仍是next数组的计算方式，有些难于理解，当作模板背下来也行。当涉及<strong>最长前后缀</strong>的题目时，就可以拿出next数组来使用。</p>

<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">28. 找出字符串中第一个匹配项的下标</a>  </td>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/solutions/1650934/by-alexhilton-7n6e/">题解</a>  </td>
<td style="text-align:left;"> KMP板子题 </td>
</tr>
<tr>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/shortest-palindrome/description/">214. 最短回文串</a>  </td>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/shortest-palindrome/solutions/2562115/xi-you-yuan-su-214-zui-duan-hui-wen-chua-0nac/">题解</a>  </td>
<td style="text-align:left;"> next数组妙用 </td>
</tr>
<tr>
<td style="text-align:left;">  <a href=""></a>  </td>
<td style="text-align:left;">  <a href="">题解</a>  </td>
<td style="text-align:left;">  </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/kmp-algorithm-for-pattern-searching/">KMP Algorithm for Pattern Searching</a></li>
<li><a href="https://www.javatpoint.com/daa-knuth-morris-pratt-algorithm">The Knuth-Morris-Pratt (KMP)Algorithm</a></li>
<li><a href="https://cp-algorithms.com/string/prefix-function.html">Prefix function. Knuth–Morris–Pratt algorithm</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/83334559">KMP 算法详解</a></li>
<li><a href="https://www.cnblogs.com/dusf/p/kmp.html">KMP算法详解-彻底清楚了(转载+部分原创) </a></li>
<li><a href="http://data.biancheng.net/view/180.html">KMP算法（快速模式匹配算法）C语言详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/145536254">全网最通俗的KMP算法图解</a></li>
<li><a href="https://blog.csdn.net/weixin_46007276/article/details/104372119">数据结构KMP算法配图详解（超详细）</a></li>
<li><a href="https://www.cnblogs.com/lin0/p/16252948.html">图解KMP字符串匹配算法+代码实现</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[线性排序算法总结]]></title>
    <link href="http://toughcoder.net/blog/2023/10/26/understanding-linear-sorting-algorithm/"/>
    <updated>2023-10-26T23:04:18+08:00</updated>
    <id>http://toughcoder.net/blog/2023/10/26/understanding-linear-sorting-algorithm</id>
    <content type="html"><![CDATA[<p><strong>排序</strong>是程序设计中的最为基础也是最为重要的算法，从程序设计这一行业开始，便有了对排序的研究，至今到了人工智能大行其道的时代，算法科学家们对排序的探索仍未停止。这是因为计算机是处理信息的最为高效的工具，如何高效的处理信息则是计算机科学的重中之重，而要想高效的处理信息，就必须先对信息进行排序，因为各种高效率的信息检索必须要基于已排序的数据。</p>

<p><a href=""><img src="https://i0.wp.com/www.xamnation.com/wp-content/uploads/2020/07/sorting-algorithms.png?fit=2240%2C1260&amp;ssl=1" title="auto auto" ></a></p>

<!-- more -->


<p>总的来说排序算法分为三大类：</p>

<ol>
<li>常规排序，也称为低效排序，如冒泡排序，插入排序，选择排序等，复杂度是O(n<sup>2</sup>)，空间复杂度都为O(1)</li>
<li>高效排序，如谢尔排序，快速排序，归并排序，堆排序等，复杂度是O(nlogn)，空间复杂度一般为O(logn)</li>
<li>线性排序，或者叫做非比较排序，仅针对特定数据集（有固定范围的整数集合）有效，如计数排序，基数排序，桶排序等，复杂度是O(n)，但至少需要O(n)的空间复杂度</li>
</ol>


<p>排序算法属于编程的基础，相关的文章一大把，集大成者有Yu神的<a href="https://leetcode.cn/circle/discuss/eBo9UB/">十大排序从入门到入赘</a>。今天重点整理一下线性排序算法。</p>

<h2><a href="https://en.wikipedia.org/wiki/Counting_sort">计数排序</a></h2>

<p><img src="https://www.cdn.geeksforgeeks.org/wp-content/uploads/scene02521.jpg" alt="" /></p>

<p>计数排序的核心思想是<strong>统计输入数组每个元素的频次</strong>，然后按照频次表的顺序把原始数据都输出出来。它的输入必须是一组有固定范围的整数，而且范围不应该太大，否则空间浪费严重。具体步骤如下：</p>

<ol>
<li>找出输入数据的范围，即其最大值max，创建一个长度为max + 1的整数数组，这是频次数组freq</li>
<li>遍历输入数组，对其元素进行频次统计，也就是把元素当作频次数组的下标，来统计freq[arr[i]]++</li>
<li>遍历频次数组，按频次输出元素，得到的就是一个有序数组</li>
</ol>


<p>伪码如下：</p>

<pre><code class="python3">def countSort(arr):
    len = max(arr) + 1
    freq = [0] * len
    for x in arr:
        freq[x]++
    res = []
    for i in range(len):
        for k in range(freq[i]):
            res.append(i)
    return res
</code></pre>

<h3>具有稳定特质的计数排序</h3>

<p>默认的方法（上面描述）的<strong>是不稳定的</strong>，所谓排序的稳定性是指对于比较起来相等的两个元素能否在结果数组中保留它们在原数组的先后顺序。一般情况下，不需要稳定时也不用管。但当在其他地方使用计数排序时，如在基数排序中使用计数排序，那么稳定性就相当重要了。</p>

<p>如果想要稳定，就需要额外做些事情：<strong>要保证先放入的数先输出（在前面），后放的后输出（在后面）</strong>，可以对频次数组求前缀和，然后遍历频次时是从后往前遍历，同时更新频次：</p>

<pre><code class="python3">def stableCoutingSort(arr):
    n = len(arr)
    # find max to determine the range of input array
    len = max(arr) + 1
    freq = [0] * len
    # count the frequency
    for x in arr:
        freq[x]++
    # presum the frequency
    for i in range(1, len):
        freq[i] += frq[i - 1]
    # output by iterating backwardly
    out = [0] * n
    for i in range(n - 1, -1, -1):
        out[freq[arr[i]] - 1] = arr[i]
        freq[arr[i]]--
    return out
</code></pre>

<h3>应用条件</h3>

<p>需要十分注意，计数排序可应用的条件很严格，只有数据集是范围不大的正整数时才可以使用，要不然空间浪费严重。最适合应用计数排序的场景是数组数值范围很小，但元素数量很多，也就是说<strong>元素数量远大于数值范围</strong>，比如说基数排序中，针对每一数位排序时，就是典型应用计数排序的地方，这时数值范围只有0~9，元素数量可能很多，非常适合计数排序。</p>

<p>当然，有负数时也可以使用，这时需要把数据加上最小的负数，平移到0以后就可以了，比如最小值（负数）是min，那么转化为arr[i]-min即可。</p>

<h2><a href="https://en.wikipedia.org/wiki/Radix_sort">基数排序</a></h2>

<p><img src="https://image1.slideserve.com/2528167/radix-sort-in-action4-l.jpg" alt="" /></p>

<p>基数排序是以<strong>整数数制的数位为依据</strong>来排序，比如123，一共有3个数位分别是1，2和3。把数组中的每个元素都按照它们的每一个数位进行排序，之后即是结果，可以从低位到位的顺序（右到左），也可以从高位到低位的顺序（左到右）。针对每个数位排元素时可以应用计数排序。但要是<strong>稳定版本的计数排序</strong>，比如{11, 23, 25}三个数，先按最低位排序后是{11, 23, 25}，这时再按十分位排序时，如果不稳定就可能会排出{11, 25, 23}这样的结果，因此 需要稳定版本的排序。具体过程如下：</p>

<ol>
<li>求出最大数位，或者说<strong>最宽的数</strong>，对于整数来说也就是找出最大值，然后求出其数位宽度width</li>
<li>对每个数位进行循环，循环次数就是width，每一轮就是针对 一个数位排序，可以用稳定版本的计数排序</li>
<li>结束后就得到了结果</li>
</ol>


<pre><code class="python3">def radixSort(arr):
    n = len(arr)
    m = max(arr)
    width = 0
    base = 10
    while m != 0:
        width++
        m /= base
    out = [0] * n
    for i in range(width):
        freq = [0] * 10
        for x in arr:
            ridx = (x % base) / (base / 10)
            freq[ridx]++

        for j in range(1, 10):
            freq[j] += freq[j - 1]
        for j in range(n - 1, -1, -1):
            idx = (arr[j] % base) / (base / 10)
            out[freq[idx] - 1] = arr[j]
            freq[idx]--
        arr = out
        base *= 10

    return arr
</code></pre>

<h3>复杂度和应用范围</h3>

<p>跟三个变量有关，输入数组长度n，最大宽度width，以及数制数位的范围d，时间复杂度为O(width * (n + d))，对于常规整数来说d是10，而width顶多也就10左右（整数有范围的），都可忽略，因此时间复杂度是O(n)。空间复杂度也是O(n)。</p>

<p>基数排序可以应用于整数，对于有负数的情况，只需要把数平移到0以右就可以了。</p>

<p>另外，可以拓展到其他数制，比如16进制，8进制，甚至字符串也都可以。</p>

<h2><a href="https://en.wikipedia.org/wiki/Bucket_sort">桶排序</a></h2>

<p><img src="https://www.simplilearn.com/ice9/free_resources_article_thumb/Bucket-Sort-Algorithm-Soni/what-is-bucket-sort-algorithm.png" alt="" /></p>

<p>桶排序其实是<strong>分治</strong>，它的核心思想是把数据以一定的数据范围分成若干个桶，每个桶再应用其他的排序算法，然后再按照桶的顺序把桶里的数据接在一起就是结果了：</p>

<ol>
<li>确定数值范围min, max和桶数量k，然后得到一些区间</li>
<li>以这些区间来把数据进行分桶</li>
<li>每个桶单独排序</li>
<li>以桶的顺序 把结果连接在一起</li>
</ol>


<pre><code class="python3">def bucketSort(arr):
    n = len(arr)
    k = n / 4
    min = min(arr)
    max = max(arr)
    buckets = [[] for _ in range(k)]
    interval = (max - min) / (k - 1)
    for x in arr:
        bidx = int((x - min) / interval)
        buckets[bidx].append(x)

    for b in buckets:
        sort(b)
    out = []
    for b in buckets:
        out.extend(b)
    return out
</code></pre>

<h3>复杂度与适用范围</h3>

<p>复杂度取决 于桶的个数k以及每个桶的排序方法，如果采用O(n<sup>2</sup>)，那么就会是O(n<sup>2</sup> / k)，如果采用O(nlogn)就会是O(nlog(n/k))，空间复杂度是O(n)。</p>

<p>需要注意，<strong>桶排序适用于浮点型</strong>，只要是数就可以。至于稳定性，则要看桶内排序算法的选择。</p>

<p>其实，如果是整数，无论范围是啥样的，都没有必要采用桶排序，因为桶排序 的复杂度不会估于O(nlogn)的。而如果桶内再采用计数或者基数排序的话（假如输入的是整数数组）就相当于脱了裤子放屁，因为本可以不用分桶的，直接采用计数排序或者基数排序。</p>

<p>桶排序适用于<strong>数据在桶中分布较均匀</strong>的场景，这样性能会达到最优。因为如果桶分配的不均匀，假如某一个桶中集中了绝大部分数据，其他桶几乎没有，这跟不分桶有啥区别（就像一个极不平衡的二叉树一样）。</p>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/contains-duplicate-iii/description/">220. 存在重复元素 III</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/contains-duplicate-iii/solutions/2566509/xi-you-yuan-su-220-cun-zai-zhong-fu-yuan-7zh8/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>总结</h2>

<p>今天重点学习了三种非比较排序算法，都是线性复杂度的，但它们并不是普适的算法，都<strong>有着特定的应用场景</strong>。要深刻理解它的原理和适用范围，以在实际运用中能够根据实际的问题灵活选择。</p>

<p>对于整数集合而言，如果元数数量远大于其数值范围，那么就用计数排序；否则就用基数排序。</p>

<p>对于浮点数，可以考虑使用桶排序。</p>

<p>当然 不可以死学，这些算法背后的核心思想也是可以用来解其他的题目的，比如桶的分治思想，以及像基数的以数位来处理问题的思想，可以拓展到字符排序等等。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://leetcode.cn/circle/discuss/eBo9UB/">十大排序从入门到入赘</a></li>
<li><a href="https://www.geeksforgeeks.org/counting-sort/">Counting Sort – Data Structures and Algorithms Tutorials</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1684188">漫画：什么是计数排序？</a></li>
<li><a href="https://oi-wiki.org/basic/counting-sort/">计数排序</a></li>
<li><a href="https://www.geeksforgeeks.org/radix-sort/">Radix sort</a></li>
<li><a href="https://www.cnblogs.com/bigsai/p/13977411.html">八大排序算法—16张图搞懂基数排序</a></li>
<li><a href="https://oi-wiki.org/basic/radix-sort/">基数排序</a></li>
<li><a href="https://www.geeksforgeeks.org/bucket-sort-2/">Bucket sort</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/125737294">【算法】排序算法之桶排序</a></li>
<li><a href="https://oi-wiki.org/basic/bucket-sort/">桶排序</a></li>
<li><a href="http://data.biancheng.net/view/115.html">桶排序（箱排序）原理及其时间复杂度详解</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解摩尔投票算法]]></title>
    <link href="http://toughcoder.net/blog/2023/10/09/understanding-boyer-moore-voting-algorithm/"/>
    <updated>2023-10-09T20:40:58+08:00</updated>
    <id>http://toughcoder.net/blog/2023/10/09/understanding-boyer-moore-voting-algorithm</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm">摩尔投票法(Boyer–Moore majority vote algorithm)</a>，也称为『多数投票法』，这个算法解决的问题是：如何在任意多的候选人中，选出获利票数最多的那个。从算法的角度来说就是在一个长度为n的数组中，找出出现次数大于n/2的那个数，称为<strong>多数元素</strong>或者<strong>主要元素</strong>(Majority Element)。</p>

<p><a href=""><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.9kA_yyWm90PJSlwlt_XWMQHaEK?pid=ImgDet&amp;rs=1" title="auto auto" ></a></p>

<!-- more -->


<h2>理解摩尔投票算法</h2>

<p>它的核心思想是让不同的数『相互抵消』，那么剩下的那个数就是Majority Element。要这样来理解，把数组想像成为很多不同颜色的气球，不同颜色的气球相撞就会两两爆破，那么我们让这些不同颜色 的气球两两爆破，最后剩下的那个颜色一定是数量最多的气球。</p>

<p><img src="https://i0.wp.com/strategicpeacock.com/wp-content/uploads/2015/09/colorful-balloons-hd-wallpapers-download-colorful-balloons-images-free1.jpeg" alt="" /></p>

<p>它分为两个步骤：</p>

<ol>
<li>相互抵消</li>
<li>验证结果</li>
</ol>


<p>伪码如下：</p>

<pre><code class="python">def majorityElement(arr):
   # step 1: kill each other
   major = 0
   vote = 0
   for x in arr:
    if vote &gt; 0 and x != major:
        vote--
    else if vote == 0:
        major = x
        vote++
    else:
        vote++

   # verifty the major element
   count = 0
   for x in arr:
    if x == major:
        count++
   if count &gt; len(arr) / 2:
    return major
   else:
    return None
</code></pre>

<p>它的优点在于效率高，能够以O(n)的效率找到数组中的多数元素，并且不占用额外空间。如果能够确定数组中存在多数元素，那么第2步验证过程可以省略。否则的话还要再遍历一次数组，对第1步低消过程中留存下来的多数元素进行计数，验证其频次是否达到要求（如超过n/2）。</p>

<h2>证明</h2>

<p>该算法其实有一些前提，那就是超过n/2的多数元素只会有一个，可以用反证法来证明，如果存在两个多数元素，x是多数元素数量为m，y是另一个多数元素数量为n，根据定义，m和n都大于n/2是不可能的，与假设矛盾，因此原命题成立。</p>

<p><img src="https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_229_two_candidates.png" alt="" /></p>

<p>同理，还可以推广到超过n/3的多数最多有2个，超过n/m的多数元素最多有m-1个。</p>

<h2>典型题目</h2>

<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/majority-element/">169. 多数元素</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/majority-element/solutions/1395882/by-alexhilton-upn7/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/majority-element-ii/description/">229. 多数元素 II</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/majority-element-ii/solutions/2473700/xi-you-yuan-su-229-duo-shu-yuan-su-iiha-80mpo/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/boyer-moore-majority-voting-algorithm/">Boyer-Moore Majority Voting Algorithm</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1600607">图解算法 | 摩尔投票法求多数元素</a></li>
<li><a href="https://www.zhihu.com/question/49973163">如何理解摩尔投票算法？</a></li>
<li><a href="https://juejin.cn/post/6983311959588339743">使用摩尔投票法解决多数问题</a></li>
<li><a href="https://blog.csdn.net/qq_44443986/article/details/112366223">算法 摩尔投票算法(图解例题)</a></li>
<li><a href="https://blog.csdn.net/u014248127/article/details/79230221">摩尔投票算法( Boyer-Moore Voting Algorithm)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/104609555">摩尔投票法(Boyer–Moore majority vote algorithm)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hashing Hash and HashMap]]></title>
    <link href="http://toughcoder.net/blog/2023/07/13/hashing-hash-and-hashmap/"/>
    <updated>2023-07-13T23:17:13+08:00</updated>
    <id>http://toughcoder.net/blog/2023/07/13/hashing-hash-and-hashmap</id>
    <content type="html"><![CDATA[<p>哈希表(HashMap)或者叫做散列表，是非常常用的一种二维的键值对式的数据结构，用以非常高效的解决查询问题的。
其核心是Hashing，这是把一个对象映射到一个索引的过程，实现hashing的函数通常称为hash函数或者叫散列函数，基于hashing实现的数据结构称作HashMap，或者叫做散列表。</p>

<p><a href=""><img src="https://techdose.co.in/wp-content/uploads/2021/02/City-of-TL-2-1024x576.png" title="auto auto" ></a></p>

<!-- more -->


<h2><a href="https://www.techtarget.com/searchdatamanagement/definition/hashing">Hashing</a></h2>

<p><a href="https://www.educative.io/answers/what-is-hashing">哈希或者散列</a>，是一个映射的过程，把一个对象，一些值，一些数据，一个文件等等通过某些方式映射成为一个键，用这个键可以<strong>非常快速</strong>的找到对应的值，也即原数据。通常键都是以索引形式存在的，因为用索引去查找数组的元素是绝对的O(1)时间的。但，这只是哈希过程的一个普通应用实例。</p>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.LEfONm4SRcDy3upe46WUMQHaE7?pid=ImgDet&amp;rs=1" alt="" /></p>

<p>在更广泛的加密领域，哈希过程并不是为了查找，而是为了生成一种代表着原数据的签名，也就是用一个更为小巧的方便的数据（通常是字符串）作为原数据的代表，看到了签名，就认为是看到的是其原数据，当然，其实这也是一种查找过程。</p>

<p>所以，不失一般性，满足这样的关系hash(data) = key，就是一个hashing。还要注意这个过程是不可逆的，也就是不存在反函数g(key) = data，没有办法能从key逆推出data。</p>

<h2><a href="https://en.wikipedia.org/wiki/Hash_function">Hash</a></h2>

<p>通常称作Hash，Hash function，Hash algorithm，哈希函数，哈希算法或者散列函数，散列算法。是能够实现hashing的一个函数或者算法。</p>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.RKHyLYrEjVpCdQfJFUQy2AHaDq?pid=ImgDet&amp;rs=1" alt="" /></p>

<p>哈希算法是把一个对象转化为int的过程，最为常用的一种哈希方法就是用多项式乘素法，比如一个长度为n的byte数组payload，它的hash = payload[0]*P<sup>n-1</sup> + payload[1]*P<sup>n-2</sup> + &hellip; + payload[n-1]。</p>

<pre><code class="java">    // Other possible primes are: 31, 131, 1313, 13131, 131313
    public static final int P = 33;
    public static int hash(String s) {
        return hashBytes(s.toCharArray());
    }

    /*
     * Polynomial multiplication of prime:
     * hash = c[0]*P^(n-1) + c[1]*P^(n-2) + ... + s[n-1]
     */
    public static int hashBytes(char[] chars) {
        int hash = 0;
        for (char ch : chars) {
            hash = P * hash + ch;
        }

        return hash;
    }
</code></pre>

<p>像Java中的String用的就是这个算法，Prime选择可能不一样，常用的有31, 131, 1313, 13131, 131313。其他对象都可以使用此方法，因为任何对象都可以序列化为byte。可以看到hash算法没有考虑溢出，这样计算P的乘方，很快就会溢出，但是没关系，溢出会变成负数，并不影响hashing。在有些算法中会对一个很大的素数如10<sup>9</sup>+7取余，以让哈希值变得的不那么大。</p>

<p>另外，可以看出哈希算法是O(L)的，这里L是输入数据的长度，比如对于字符串来说就是字符串的长度，假如是一个很长很长很长的字符串，那么计算其hash可能会很久很久，因此当使用HashMap时，可能就会变得很慢。</p>

<h3>参考资料</h3>

<ul>
<li><a href="https://www.zhihu.com/question/20820286">什么是哈希算法？</a></li>
<li><a href="https://wingsxdu.com/posts/algorithms/cryptographic-hashing-function/">加密哈希算法的实现原理</a></li>
<li><a href="https://segmentfault.com/a/1190000021199728">图解一致性哈希算法</a></li>
<li><a href="https://www.cnblogs.com/barrywxx/p/10739871.html">经典Hash函数的实现</a></li>
<li><a href="https://houbb.github.io/2018/05/30/hash-impl">Hash 算法实现</a></li>
<li><a href="https://developer.aliyun.com/article/1012265">Hash算法详细介绍与实现(一)</a></li>
<li><a href="https://developer.aliyun.com/article/1015830">Hash 算法详细介绍与实现 (二)</a></li>
</ul>


<h2><a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">HashMap</a>/<a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html">HashSet</a></h2>

<p>基于Hashing和Hash构建出来的用于高效查询的数据结构。</p>

<p><img src="https://cdn.educba.com/academy/wp-content/uploads/2019/11/hashmap-in-java.png" alt="" /></p>

<h3>参考资料</h3>

<ul>
<li><a href="https://www.interviewcake.com/concept/java/hash-map">Data structure Hash Table</a></li>
<li><a href="https://www.geeksforgeeks.org/hashing-data-structure/">Hashing Data Structure</a></li>
<li><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html">Java 8系列之重新认识HashMap</a></li>
<li><a href="https://pdai.tech/md/java/collection/java-map-HashMap&amp;HashSet.html">Map - HashSet &amp; HashMap 源码解析</a></li>
<li><a href="https://xie.infoq.cn/article/01538faefd4816128ede4212a">了解 HashMap 数据结构，超详细！</a></li>
</ul>


<h2><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html">ConcurrentHashMap</a></h2>

<p>线程安全的哈希表，采用分段式读加锁的方式来提高并发效率。</p>

<h3>参考资料</h3>

<ul>
<li><a href="https://www.cnblogs.com/zerotomax/p/8687425.html">ConcurrentHashMap源码分析(1.8)</a></li>
<li><a href="https://javaguide.cn/java/collection/concurrent-hash-map-source-code.html">ConcurrentHashMap 源码分析</a></li>
<li><a href="https://juejin.cn/post/7045955943296679949">ConcurrentHashMap源码分析</a></li>
</ul>


<h2><a href="https://en.wikipedia.org/wiki/Hash_collision">哈希碰撞Hash Collision</a></h2>

<p>哈希算法针对不同的原始数据却产生了相同的键，这就是哈希碰撞，因为最理想的hashing是一一对应，同样的原始数据（也就是相等的两个对象）肯定会产生相同的键，这时我们认为数据是同一份（相等的），但不同的数据（也即不相等）却产生了相同的键，就需要进行特殊处理，这会增加复杂度。哈希碰撞是不可避免的，同时也是一个衡量指标，即好的哈希函数会产生较少的合理碰撞（也就是因为数据边界和算法能力导致的碰撞）。</p>

<p><img src="https://ts1.cn.mm.bing.net/th/id/R-C.b7b51eed3f8027b11a32e091363c26f7?rik=scKHPWTjDjuM5Q&amp;riu=http%3a%2f%2fjustinparrtech.com%2fJustinParr-Tech%2fwp-content%2fuploads%2fHashing-Passwords_Hash-Collision.png&amp;ehk=Cs%2fOrEQS48SFm8KbaMfL0mOJxPm3AfjQlJvsMeddGP4%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" /></p>

<p>哈希碰撞会降低效率和安全性，比如说服务器通常会把客户端的request先暂存起来，去异步处理，当有了response后，再找到其对应的request然后给其回复response。这一过程，一般会有哈希表来存储request。假如哈希函数选择的不好，比如用request当中的某一个String字段来作为request的Key的话，就有可能被恶意攻击。哈希表常规的效率是很高的，一旦有哈希碰撞就会变成链表复杂度会上升为O(n<sup>2</sup>)。而String的hash是容易产生碰撞，假如恶意客户端发现了是用String作为Key的，那么就可以用能产生哈希碰撞的String来生成不同的request，这样就会让服务器短时间内负载特别高而且宕机。这是一种基于哈希碰撞的古老的攻击方式。</p>

<p>所以一般服务器使用的哈希函数都是要特别设计，不能采用太普通 的哈希算法。</p>

<h3>参考资料</h3>

<ul>
<li><a href="https://www.ruanyifeng.com/blog/2018/09/hash-collision-and-birthday-attack.html">哈希碰撞与生日攻击</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1776352">HASH碰撞问题一直没真正搞懂？这下不用慌了</a></li>
<li><a href="https://segmentfault.com/a/1190000041421664">哈希理解、哈希碰撞（hash冲突）及处理</a></li>
<li><a href="https://www.baeldung.com/cs/hash-collision-weak-vs-strong-resistance">Hash Collision: Weak and Strong Resistance</a></li>
</ul>


<h2><a href="https://en.wikipedia.org/wiki/Rolling_hash">滚动哈希Rolling Hash</a></h2>

<p>是一种哈希算法，使用一个固定长度的窗口（通常远小于数据本身的长度）在数据中滑动，能以更高的效率计算出数据的哈希值（键）。通常会被用于检查文章的相似性（是否存在抄袭），查找重复的子串等。因为滚动哈希是在一个长的序列中以一个固定的窗口在计算，所以特别擅长在接近无限的序列中探测重复子序列，比如网络流模式探测，视频重复帧识别等等。</p>

<p><img src="https://www.francofernando.com/assets/img/blog/algorithms/rolling-hash/rolling-hash-1.png" alt="" /></p>

<p>一个典型的Rolling hash实现：</p>

<pre><code class="java">public static ArrayList&lt;Integer&gt; rollingHash(String payload, int window, int p, int mod) {
        final int n = payload.length();
        ArrayList&lt;Integer&gt; hashValues = new ArrayList&lt;&gt;(n - window + 1);
        int power = 1;
        for (int i = 0; i &lt; window - 1; i++) {
            power *= p;
            power %= mod;
        }

        int hash = 0;
        for (int i = 0; i &lt; window; i++) {
            hash = (hash * p + payload.charAt(i)) % mod;
        }
        hashValues.add(hash);

        for (int i = 1; i &lt; n - window + 1; i++) {
            hash = (hash - power * payload.charAt(i - 1)) % mod;
            hash = (hash * p + payload.charAt(i + window - 1)) % mod;
            hashValues.add(hash);
        }

        return hashValues;
    }

    public static void main(String[] args) {
        String payload = "abcabcabc";
        int window = 3;
        ArrayList&lt;Integer&gt; hashes = rollingHash(payload, window, 31, MOD);
        System.out.println("Rolling hash of " + payload + ", window size " + window);
        IntStream.range(0, hashes.size())
                .mapToObj(i -&gt; i + "-&gt;" + payload.substring(i, i + window) + " whose hash is " + hashes.get(i))
                .forEach(System.out::println);
    }
    // outputs
    //Rolling hash of abcabcabc, window size 3
    //0-&gt;abc whose hash is 96354
    //1-&gt;bca whose hash is 97344
    //2-&gt;cab whose hash is 98244
    //3-&gt;abc whose hash is 96354
    //4-&gt;bca whose hash is 97344
    //5-&gt;cab whose hash is 98244
    //6-&gt;abc whose hash is 96354
</code></pre>

<p>可以看出，字符串是&#8221;abcabcabc&#8221;，有三个重复子串，Rolling hash能清查的找到，看Rolling hash输出中的0，3和6个元素（即子串&#8221;abc&#8221;），另外两个重复子串&#8221;bca&#8221;，是1和4，以及&#8221;cab&#8221;，是2和5。</p>

<p>Rolling hash是O(n)的，每个子串的比较都是O(1)，是相当高效的算法，是用于解决子串查找，重复子串查找的利器。</p>

<h3>参考资料</h3>

<ul>
<li><a href="https://www.geeksforgeeks.org/introduction-to-rolling-hash-data-structures-and-algorithms/">Introduction to Rolling Hash – Data Structures and Algorithms</a></li>
<li><a href="https://juejin.cn/post/7180323231918882874">(Rabin-Karp算法)匹配字符串（滚动哈希）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/564537288">滚动哈希（Rolling Hash）</a></li>
<li><a href="https://www.cnblogs.com/sunchi/p/13632779.html">滚动hash实现字符串匹配</a></li>
</ul>


<h3>典型问题</h3>

<p>哈希表作为一种极基础的数据结构，提供以O(1)时间查询的能力，所以是刷题当中最为常用的辅助数据结构，没有之一。但其实HashMap/HashSet并不 真的O(1)，它只是摊还分析的时间复杂度能到O(1)，但真实的运行效率不可能达到O(1)，一旦发生哈希碰撞就会上升到O(n<sup>2</sup>)。并且还有扩容和自动装箱autobox等隐形开销，hash函数本身也有开销一般是O(L)的，所以HashMap真实的运行效率并不高。</p>

<p>但哈希表是一种hashing的实现，更为重要的是体现了hashing的映射思想。所以，在有些时候虽然用到了哈希表，但不一定要用HashMap。比如像英文字母到索引的映射，以及数据范围不大的自然数到索引的映射，这本质上也是hashing，但用数组就可以了，并且这是真正的O(1)。</p>

<p>哈希表一般当作基础设施来使用，所以没有专门的题，关于哈希的题目一般都是滚动哈希的，并且难度都不小。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/repeated-dna-sequences/solution/187-zhong-fu-de-dnaxu-lie-by-alexhilton-5or9/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-palindrome/description/">214. 最短回文串</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-palindrome/solutions/2562115/xi-you-yuan-su-214-zui-duan-hui-wen-chua-0nac/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/equal-row-and-column-pairs/description/">2352. 相等行列对</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/equal-row-and-column-pairs/solutions/2655876/xi-you-yuan-su-2352-xiang-deng-xing-lie-7ojcl/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304227729113121">哈希算法</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TopK问题，堆和快速选择]]></title>
    <link href="http://toughcoder.net/blog/2023/07/11/topk/"/>
    <updated>2023-07-11T22:35:15+08:00</updated>
    <id>http://toughcoder.net/blog/2023/07/11/topk</id>
    <content type="html"><![CDATA[<p>TopK问题是很常见的一种问题，它的描述是从一个数据集或者序列中取出前k大（或者前k小），或者说找出第k大（第k小）。最为典型的就是 <a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/215-shu-zu-zhong-de-di-kge-zui-da-yuan-s-0lm6/">题215. 数组中的第K个最大元素</a>。解决TopK需要的是最基础的数据结构和算法，不但可以考查编码基本功，更能考查思维能力。</p>

<p><a href=""><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.2aULRows_3CiTGr1IQamzgHaE-?pid=ImgDet&amp;rs=1" title="auto auto" ></a></p>

<!-- more -->


<p>为了方便，后面就以找前k大为主要示例：输入长度为n的整数数组，找出前k大的数，1 &lt;= k &lt;= n。</p>

<h2>排序大法</h2>

<p>解决TopK问题，最简单也是最为暴力的做法就是排序，如果数据是有序的，无论你想找前k大或者第k大，都是非常容易的了。</p>

<p><img src="https://programs.wiki/images/wiki/01f03444af1b72507fd4d18f22f94d67.jpg" alt="" /></p>

<p>问题就转化为排序问题了，至于排序有O(n<sup>2</sup>)的冒泡，选择和插入， 以及高效一些的归并和快速排序。如果是特殊数据集还可以用计数排序（也叫桶排序）。关于排序算法的教程太多了，就不重复了，可以参考Yu神的 <a href="https://leetcode.cn/circle/discuss/eBo9UB/">十大排序从入门到入赘</a>。</p>

<p>用排序来解决TopK问题可行但并不高效，比如k特别小时，n特别大时效率就会特别差。甚至，对于序列（也就是输入数据接近无限）时，可能没有办法先排序再去选择前k大了。</p>

<h2>堆<a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">Heap</a></h2>

<p>堆是一个逻辑上的二叉树式的数据结构，但实现上通常用数组来实现，它保证根节点是所有元素中最大的称作最大堆或者大根堆，或者最小的称作最小堆或者小根堆。有些地方也称之为优先队列，比如在大Java中的就叫做<a href="https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html">PriorityQueue</a>。</p>

<p><img src="https://www.cdn.geeksforgeeks.org/wp-content/uploads/MinHeapAndMaxHeap.png" alt="" /></p>

<p>以最大堆为例，它保证根节点永远不小于两个子节点，假如堆的大小（也即元素总数）是k，那么根节点就是这k个元素中的最大值，维护一次堆（Heapify）的代价是log(k)，只需要不断的比较根节点和子节点即可，所以复杂度是二叉树的高度即log(k)。对于TopK问题，可以创建一个大小为k的最小堆，把n个数都填到堆里，当堆未满时，直接塞，如果满时了，堆顶是最小值，如果新元素小于最小值可直接跳过，它不可能成为TopK；否则先移除堆顶然后再塞，最后堆里面剩下的就是前k大元素，这样复杂度会降到nlog(k)，当n特别大，k远小于n时，或者说对n接近无穷的序列时，用最小堆的效率会明显的高于排序大法。</p>

<p><img src="https://programs.wiki/images/wiki/219e46ebbe75d147a8f2d508a9b1890a.jpg" alt="" /></p>

<p>堆（优先队列）是一种非常常见且基础的数据结构，标准库中都有，可以拿来就用，但是学习手撸一个堆更能加深理解。</p>

<h3>堆的实现</h3>

<p>来手撸一个最大堆。最常见的就是二叉堆，也就是说逻辑上是一个二叉树，但实际的存储一般是用数组，索引0就是根节点root（又叫堆顶），索引i它的左子节点是在索引2*i+1，右子节点是在2*i+2。</p>

<p>需要不断的<strong>维护堆的特性</strong>，也即是它的<strong>根节点总是大于两个子节点</strong>，要时刻保持这种性质。主要难点在于向堆中添加一个元素时，先把此元素放在数组最后，也即树中最右下的叶子节点，然后不断的向上更新：如果此元素大于其父节点，就互换直到它小于其父节点。</p>

<p>另外需要维护的地方就是移除堆顶，堆顶是堆中的最大元素，它大于其两个子节点。大哥没了，就要重新选大哥：因为逻辑上是一个二叉树，所以只需要解决一个最小的树即可，其余可以递归处理。从父节点，左子节点和右子节点中取最大的，与父节点互换，然后再递归处理刚刚转换过的子树，即可。</p>

<p>废话这么多，其实代码比较精简，也较容易理解，还是直接上代码吧：</p>

<pre><code class="java">/**
 * A bound Max Heap of int type elements.
 * This is a binary heap with array as the underlying container.
 */
public class MaxHeap {
    public static final int INF = Integer.MAX_VALUE;

    private final int capacity;
    private int size;
    /*
     * Put the elements into an array, but the logical relationship is a binary tree.
     * 0 is the root;
     * i's left child is 2*i + 1, right child is 2*i + 2;
     * i's parent is (i-1) / 2.
     */
    private final int[] elements;

    public MaxHeap(int capacity) {
        this.capacity = capacity;
        size = 0;
        elements = new int[capacity];
    }

    /**
     * Nothing happens if heap is full.
     */
    public void offer(int e) {
        if (isFull()) {
            // Overflowed.
            return;
        }
        /*
         * Put the new element at the end of the heap.
         * Push it up until it is less than its parent.
         */
        size++;
        int i = size - 1;
        elements[i] = e;

        while (i != 0 &amp;&amp; elements[parent(i)] &lt; elements[i]) {
            swap(i, parent(i));
            i = parent(i);
        }
    }

    public int heapSize() {
        return size;
    }

    public int peek() {
        if (isEmpty()) {
            return INF;
        }
        return elements[0];
    }

    public void clear() {
        size = 0;
    }

    public int poll() {
        if (isEmpty()) {
            return INF;
        }
        if (size == 1) {
            size--;
            return elements[0];
        }

        /*
         * Root is the max value in the heap, will remove and return it to caller.
         * Push down the tree and select the max of left and right as the new parent.
         */
        int root = elements[0];
        elements[0] = elements[size - 1];
        size--;
        heapify(0);
        return root;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean isFull() {
        return size == capacity;
    }

    /*
     * Heapify the sub-tree rooted with index i.
     * Find the largest value of parent, left and right;
     * If the parent is the largest, we are done.
     * Swap parent with the largest node, now parent is the largest;
     * Keep heapifying the swapped sub-tree.
     */
    private void heapify(int i) {
        int l = left(i);
        int r = right(i);
        int largest = i;
        if (l &lt; size &amp;&amp; elements[l] &gt; elements[i]) {
            largest = l;
        }
        if (r &lt; size &amp;&amp; elements[r] &gt; elements[largest]) {
            largest = r;
        }
        if (largest != i) {
            swap(i, largest);
            heapify(largest);
        }
    }

    private void swap(int i, int j) {
        if (i == j) {
            return;
        }
        int t = elements[i];
        elements[i] = elements[j];
        elements[j] = t;
    }

    private int parent(int i) {
        return (i - 1) / 2;
    }

    private int left(int i) {
        return (i &lt;&lt; 1) + 1;
    }

    private int right(int i) {
        return (i &lt;&lt; 1) + 2;
    }
}
</code></pre>

<p>完整<a href="https://github.com/alexhilton/EffectiveAlgorithm/blob/main/datastructure/src/main/java/MaxHeap.java">代码在这里</a>。</p>

<p>这就是最基础的一种二叉堆(Binary Heap)的实现。注意基础堆是用于快速找最大值或者最小值，是O(1)的，其他的操作如查询非最大值或者最小值，或者移除某个特定的元素，效率差会变成O(n)的。</p>

<p>为此，还有其他的实现方式如<a href="https://brilliant.org/wiki/binomial-heap/">Binomial Heap</a>和<a href="https://brilliant.org/wiki/fibonacci-heap/">Fibonacci Heap</a>，这两种堆除了保证堆的基本特质外，还能把其他的操作也降低到log(n)的复杂度。</p>

<h3>堆的应用</h3>

<p>一是用来排序，通常称作堆排序，把n个元素都入堆，然后依次把堆顶取出来，这样就能得到一个有序数组了。复杂度是nlog(n)。</p>

<p>另外，就是用于解决topK问题了。更为实际一点的应用就是Job Scheduling，把一坨Job加入堆中，每次取堆顶（优先级最高的Job）来执行。</p>

<h2><a href="https://en.wikipedia.org/wiki/Quickselect">Quick select</a></h2>

<p>快速选择是快速排序衍生出来的一个算法，专门适用以线性复杂度O(n)来解决TopK问题。为此我们先复习快速排序算法，然后再解释快速选择原理。</p>

<p><img src="https://image3.slideserve.com/6106968/quick-select-visualization-l.jpg" alt="" /></p>

<h3>快速排序</h3>

<p>这是一个非常经典又基础的算法，是算法入门的必讲算法。快速排序的<strong>核心思想是分治</strong>(Divide and Conquer)，核心技巧是<strong>分区(partition)</strong>，选取一个<strong>轴元素作为分界点(pivot)</strong>，把<strong>小于轴的元素</strong>都放在它<strong>左边</strong>，把<strong>大于它的元素</strong>都放在其<strong>右边</strong>，然后再用同样的方法处理左边和右边。伪码如下：</p>

<pre><code class="java">void quickSort(int[] arr, int start, int end) {
    if (start == end) return
    int p = partition(arr, start, end);
    quickSort(arr, start, p-1);
    quickSort(arr, p, end);
}
</code></pre>

<h3>分区</h3>

<p>分区partition是快排的核心技巧，当然也是快速选择的核心，它是先选出一个轴元素pivot，然后以它为界把数组分成两段。比如说数组arr = [5,3,7,1,8,2,9,4]。如果选择索引位置0，元素5作为pivot，那么partition之后的数组会变为arr=[3,1,2,4,5,7,8,9]，partition的返回值，是pivot元素在分区之后的新索引p，即此例中的索引4。可以看出经过partition后，数组左区[0,p-1]都是小于pivot的，而右区[p,n-1]则是大于等于pivot的。这就是分区的作用。</p>

<p>分区算法轴元素的选择至关重要，为了达到最好的效果，在区间内随机选择一个索引位置的元素作为pivot是最理想的，摊还分析后可以达到O(n)。快排的复杂则是nlog(n)。</p>

<p>对于数组arr，做partition的具体做法是：</p>

<ol>
<li>随机选择一个元素为轴元素，记其索引为pivot</li>
<li>先把pivot与最后一个元素交换swap(arr, pivot, end)，注意交换后轴元素在end，即arr[end]</li>
<li>用双指针，左指针left总是指针向小于轴元素arr[end]的最后一个元素，也即分区好了时的左边界的最后一个位置。</li>
<li>右指针right则从start开始，遍历到end - 1，如果arr[right]小于轴，即arr[right]&lt;arr[end]，则交换并更新左指针</li>
<li>最后left索引即是轴应该在的索引，与轴交换swap(arr, left, end)</li>
<li>返回left。这是分区后的轴所在的位置。</li>
</ol>


<p>代码如下：</p>

<pre><code class="java">    private int partition(Random random, int[] nums, int start, int end) {        int pivot = random.nextInt(end - start + 1) + start;        swap(nums, pivot, end);        int left = start - 1;        for (int right = start; right &lt; end; right++) {            if (nums[right] &lt; nums[end]) {                left++;                swap(nums, left, right);            }        }        left++;        swap(nums, left, end);        return left;    }
</code></pre>

<p>记住，<strong>分区返回一个轴的索引，轴左边的元素都小于轴，轴右边的元素都大于轴</strong>。这是快速排序和快速选择的核心奥妙精华所在。</p>

<h3>快速选择</h3>

<p>基于分区就能开发出快速选择算法。对于长度为n的数组arr，进行partition后，得到一个轴的位置pivot，[0,pivot-1]都小于arr[pivot]，而[pivot+1,n-1]都大于arr[pivot]。那么，对于想找出前k大的TopK问题而方，如果pivot=n-k，那么[pivot, n - 1]分区后的右边部分不就刚好前k大元素么？</p>

<p>有同学举手问了，咋可能那么巧嘛。这位同学请先坐下，不巧也没关系，如果pivot大于n-k，说明比pivot大的数不够k个，就得往左找，所以在左部分递归处理就可以了；同理，如果pivot小于n-k，说明右部分太多了，往右找即可。代码大概这样子的：</p>

<pre><code class="java">    public int findKthLargest(int[] nums, int k) {        Random random = new Random();        int target = nums.length - k;        int start = 0;        int end = nums.length - 1;        int index = partition(random, nums, start, end);        while (index != target) {            if (index &gt; target) {                end = index - 1;            } else {                start = index + 1;            }            index = partition(random, nums, start, end);        }        return nums[index];    }
</code></pre>

<p>这是迭代式的，看起来可能不那么直观，我们用递归来写，就相当直观了：</p>

<pre><code class="java">int quickSelect(arr, start, end, k) {
    if (start == end) {
         return start;
    }
    int p = partition(arr, start, end);
    if (p == n - k) {
        return p;
    } else if (p &lt; n - k) {
        return quickSelect(arr, p + 1, end, k);
    } else {
        return quickSelect(arr, start, p - 1, k - p);
    }
}
</code></pre>

<h2>总结</h2>

<p>TopK问题是非常常见且基础的一个问题，通常是融合在了其他问题里面，不会以比较直观的方式求TopK。如果是问题中的一个子问题，那么通常用堆来当作辅助数据结构是最优的做法。如果TopK问题是最问题的最后一步的话，那么排序或者用快速选择也是可以的。</p>

<h2>典型问题</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/215-shu-zu-zhong-de-di-kge-zui-da-yuan-s-0lm6/">题解</a> </td>
<td style="text-align:left;"> 典型TopK问题 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并 K 个升序链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-k-sorted-lists/solution/by-alexhilton-zctb/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sliding-window-maximum/solution/239-hua-dong-chuang-kou-zui-da-zhi-xian-fwypk/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/top-k-frequent-elements/solution/by-alexhilton-xhxc/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/k-closest-points-to-origin/">973. 最接近原点的 K 个点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/k-closest-points-to-origin/solution/xi-you-yuan-su-973-zui-jie-jin-yuan-dian-xtze/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/wiggle-sort-ii/">324. 摆动排序 II</a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/total-cost-to-hire-k-workers/description/">2462. 雇佣 K 位工人的总代价</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/total-cost-to-hire-k-workers/solutions/2647991/xi-you-yuan-su-2462-gu-yong-k-wei-gong-r-doyh/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/heap-data-structure/">Heap Data Structure</a></li>
<li><a href="https://www.programiz.com/dsa/heap-data-structure">Heap Data Structure</a></li>
<li><a href="https://blog.csdn.net/guoweimelon/article/details/50904346">堆树（最大堆、最小堆）详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/362129090">数据结构之最大堆</a></li>
<li><a href="https://www.geeksforgeeks.org/quickselect-algorithm/">Quickselect Algorithm</a></li>
<li><a href="https://aticleworld.com/quickselect-algorithm/">Quickselect Algorithm: Quick Select Algorithm With Example Code</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/64627590">Top K 问题的最优解 - 快速选择算法（Quickselect）</a></li>
<li><a href="https://nicodechal.github.io/2020/01/12/quick-sort-and-quick-selection/">快速排序 ( QuickSort ) 和快速选择 ( QuickSelection )</a></li>
<li><a href="https://juejin.cn/post/6844903774004183047">算法必学：经典的 Top K 问题</a></li>
<li><a href="https://segmentfault.com/a/1190000041127350">面试被问TopK问题，可以这样优雅的解答</a></li>
<li><a href="https://blog.csdn.net/z50L2O08e2u4afToR9A/article/details/82837278">拜托，面试别再问我TopK了！！！</a></li>
<li><a href="https://leetcode.cn/circle/discuss/eBo9UB/">十大排序从入门到入赘</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
