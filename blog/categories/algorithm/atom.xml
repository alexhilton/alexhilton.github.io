<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2023-07-10T22:09:45+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[DFS in Depth]]></title>
    <link href="http://toughcoder.net/blog/2023/06/15/dfs-in-depth/"/>
    <updated>2023-06-15T21:56:31+08:00</updated>
    <id>http://toughcoder.net/blog/2023/06/15/dfs-in-depth</id>
    <content type="html"><![CDATA[<p><a href="http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy/">前面一篇文章</a>讲解了<a href="https://en.wikipedia.org/wiki/Depth-first_search">DFS</a>的基本概念和基础的使用方法，但不够深入，DFS的应用是很广泛的，不论是枚举状态或者路径，还是递归，其本质上都是DFS。今天就来好好的理解一下DFS的内在本质，并学会在树，在图以及在回溯中的应用。</p>

<p><a href=""><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.kOp9h97z5AGxyxs-q2u_8AHaHP?pid=ImgDet&amp;rs=1" title="auto auto" ></a></p>

<!-- more -->


<h2>回顾DFS</h2>

<p>深度优先搜索，是指沿着某一路径方向，一直遍历到叶子节点为止，然后再回到初始顶点，换个方向继续。</p>

<p><img src="https://image4.slideserve.com/8160117/dfs-pseudocode-l.jpg" alt="" /></p>

<p>这里就不过多的重复了，因为在<a href="http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy/">前一篇文章</a>里面已经讲过了，看那篇文章就好。</p>

<p>注意<strong>理解DFS的本质</strong>，DFS的本质就是<strong>递归</strong>，因此用递归式的DFS效率是最高的，如果是迭代式则要借助栈，伪码参见<a href="http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy/">前一篇文章</a>。</p>

<h2>DFS树的遍历</h2>

<p>树的常规遍历，涉及路径的问题，如查找 某一个路径，或者查找所有的路径都非常适合用DFS，效率也非常的高。</p>

<p>对于涉及树的层序的时候，如果是寻找层级内的某种状态，如层和，层最大值层最小值等，也是可以用DFS的。这方面可以参考<a href="http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy/">前面的文章</a>，以及关于<a href="http://toughcoder.net/blog/2022/08/18/binary-tree-made-easy/">二叉树的文章</a>。</p>

<h2>路径问题</h2>

<p>寻找特定的路径，或者枚举所有可能的路径就非常适合用DFS来求解。这其实是回溯算法，回溯其实就是用递归来枚举所有状态，这也是DFS的本质。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/all-paths-from-source-to-target/description/">797. 所有可能的路径</a> </td>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/all-paths-from-source-to-target/solutions/1951745/797-suo-you-ke-neng-de-lu-jing-by-alexhi-70xm/">题解</a>  </td>
<td style="text-align:left;">   </td>
</tr>
<tr>
<td style="text-align:left;">  <a href=""></a> </td>
<td style="text-align:left;">  <a href="">题解</a>  </td>
<td style="text-align:left;">   </td>
</tr>
<tr>
<td style="text-align:left;">  <a href=""></a> </td>
<td style="text-align:left;">  <a href="">题解</a>  </td>
<td style="text-align:left;">   </td>
</tr>
<tr>
<td style="text-align:left;">  <a href=""></a> </td>
<td style="text-align:left;">  <a href="">题解</a>  </td>
<td style="text-align:left;">   </td>
</tr>
</tbody>
</table>


<h2>图的遍历</h2>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/flood-fill/description/">733. 图像渲染</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/flood-fill/solutions/1788931/733-tu-xiang-xuan-ran-by-alexhilton-mem7/">题解</a> </td>
<td style="text-align:left;">  </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-islands/solutions/1636556/200-dao-yu-shu-liang-by-alexhilton-cexx/">题解</a> </td>
<td style="text-align:left;">  </td>
</tr>
<tr>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a> </td>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/max-area-of-island/solutions/1786740/by-alexhilton-9eby/">题解</a>  </td>
<td style="text-align:left;">   </td>
</tr>
</tbody>
</table>


<h2>有返回值的DFS</h2>

<p>有返回值的情况略为复杂，常规的DFS，特别是递归式，只以标记当成返回结果的，函数本身并没有返回值，但有时候光做标记还不够，还需要额外的信息作为是否有解的判断，这时就需要额外的返回值，通常用dfs函数的返回值作为判断。</p>

<p>写返回值时就要小心一些，当超过边界了，或者确定无解的情况下时<strong>返回无解状态（如false）</strong>，DFS过程中已标记过了的地方直接返回有解（如true），然后<strong>递归 调用，并把递归 的所有结果合并起来当作 返回值</strong>。这里特别要注意的是要把下一步都递归了，再合并结果，因为DFS除了有返回值外，它还会做标记，如果简单的进行与，会因为<strong>布尔操作符的short-circuit</strong>原因导致某些分支没走下去，最后的标记状态肯定就不对。</p>

<pre><code class="kotlin">    private fun dfs(g: Array&lt;IntArray&gt;, i: Int, j: Int): Boolean {
        if (i &lt; 0 || i &gt;= g.size || j &lt; 0 || j &gt;= g[0].size) {
            return false
        }

        if (g[i][j] == 1) {
            return true
        }
        g[i][j] = 1

        val n = dfs(g, i - 1, j)
        val w = dfs(g, i, j - 1)
        val s = dfs(g, i + 1, j)
        val e = dfs(g, i, j + 1)
        return n &amp;&amp; w &amp;&amp; s &amp;&amp; e
    }
</code></pre>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/number-of-closed-islands/">1254. 统计封闭岛屿的数目</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-closed-islands/solutions/2290858/xi-you-yuan-su-1254-tong-ji-feng-bi-dao-5e98a/">题解</a> </td>
<td style="text-align:left;">   </td>
</tr>
<tr>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/number-of-enclaves/">1020. 飞地的数量</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-enclaves/solutions/2292106/xi-you-yuan-su-1020-fei-di-de-shu-liang-gawj8/">题解</a> </td>
<td style="text-align:left;">  </td>
</tr>
<tr>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/count-sub-islands/description/">1905. 统计子岛屿</a> </td>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/count-sub-islands/solutions/2292277/xi-you-yuan-su-1905-tong-ji-zi-dao-yu-bf-ws6r/">题解</a>  </td>
<td style="text-align:left;">   </td>
</tr>
</tbody>
</table>


<h2>着色法DFS</h2>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/find-eventual-safe-states/description/">802. 找到最终的安全状态</a> </td>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/find-eventual-safe-states/solutions/916155/zhao-dao-zui-zhong-de-an-quan-zhuang-tai-yzfz/">题解</a>  </td>
<td style="text-align:left;">   </td>
</tr>
<tr>
<td style="text-align:left;">  <a href=""></a> </td>
<td style="text-align:left;">  <a href="">题解</a>  </td>
<td style="text-align:left;">   </td>
</tr>
<tr>
<td style="text-align:left;">  <a href=""></a> </td>
<td style="text-align:left;">  <a href="">题解</a>  </td>
<td style="text-align:left;">   </td>
</tr>
</tbody>
</table>


<h2>枚举+DFS（回溯）</h2>

<p>如前所述，DFS的本质就是枚举所有状态，这其实也是回溯算法的核心所在，关于回溯可以<a href="http://toughcoder.net/blog/2022/09/04/backtracking-algorithm-explained/">参考另外的文章</a>。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/water-and-jug-problem/description/">365. 水壶问题</a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> 建模是难点，如何定义状态 </td>
</tr>
<tr>
<td style="text-align:left;">  <a href=""></a> </td>
<td style="text-align:left;">  <a href="">题解</a>  </td>
<td style="text-align:left;">   </td>
</tr>
<tr>
<td style="text-align:left;">  <a href=""></a> </td>
<td style="text-align:left;">  <a href="">题解</a>  </td>
<td style="text-align:left;">   </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.javatpoint.com/depth-first-search-algorithm">DFS (Depth First Search) algorithm</a></li>
<li><a href="https://www.simplilearn.com/tutorials/data-structure-tutorial/dfs-algorithm">Learn Depth-First Search(DFS) Algorithm From Scratch</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BFS in Graph Made Easy]]></title>
    <link href="http://toughcoder.net/blog/2023/06/14/graph-bfs-made-easy/"/>
    <updated>2023-06-14T23:07:20+08:00</updated>
    <id>http://toughcoder.net/blog/2023/06/14/graph-bfs-made-easy</id>
    <content type="html"><![CDATA[<p><a href="http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy/">前面一篇文章</a>讲解过BFS和DFS的基本概念常见用法，今天专注于图论中的BFS，来深入的探讨一下BFS在图论的搜索中的应用，并总结相关解题技巧。</p>

<p><a href=""><img src="https://tutorialhorizon.com/static/media/algorithms/2015/05/Graph-BFS.gif" title="auto auto" ></a></p>

<!-- more -->


<p>本文假定已经熟知图论的基本知识，比如图的表示方式和一些基本概念等，如不熟悉可以<a href="http://toughcoder.net/blog/2022/09/08/graph-data-structure-made-easy/">参考此文</a>。</p>

<h2>基础（单源）BFS</h2>

<p>基础的BFS通常是单源的，也就是以某一个顶点为起点。借助队列(FIFO先入先出队列)，把起点入队，然后不断的从队出取出顶点，访问与其连通的顶点，直到队列为空。为了防止重复遍历，需要在遍历过程中做标记。因为这个比较基础，我们在<a href="http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy/">前一篇文章</a>中已有伪码，所以这里就不再重复了。</p>

<p>这是最基础的BFS，当然 也是最重要的，因为更为复杂的玩法也是基于此的，因此要烂熟于心，有一些板子题，可以时常拿出来复习一下：</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-islands/solution/200-dao-yu-shu-liang-by-alexhilton-cexx/">题解</a> </td>
<td style="text-align:left;"> 邻接矩阵，矩阵式基础BFS板子题 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/max-area-of-island/solution/by-alexhilton-9eby/">题解</a> </td>
<td style="text-align:left;"> 邻接矩阵，矩阵式基础BFS板子题 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/flood-fill/">733. 图像渲染</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/flood-fill/solution/733-tu-xiang-xuan-ran-by-alexhilton-mem7/">题解</a> </td>
<td style="text-align:left;"> 邻接矩阵，矩阵式基础BFS板子题 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/count-sub-islands/description/">1905. 统计子岛屿</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/count-sub-islands/solutions/2292277/xi-you-yuan-su-1905-tong-ji-zi-dao-yu-bf-ws6r/">题解</a> </td>
<td style="text-align:left;">  邻接矩阵，矩阵式基础BFS板子题 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/description/">1466. 重新规划路线</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/solutions/2301538/xi-you-yuan-su-1466-zhong-xin-gui-hua-lu-juiu/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/keys-and-rooms/description/">841. 钥匙和房间</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/keys-and-rooms/solutions/2193103/xi-you-yuan-su-841-yao-chi-he-fang-jian-hcqfy/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>多方向邻接</h2>

<p>对于矩阵来说一般的邻接是四个方向，上下左右，但有时斜角也算邻接，这就有了八个方向，整体遍历的套路不变，只不过在找邻接顶点时要考虑八个方向。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/">1091. 二进制矩阵中的最短路径</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/solution/xi-you-yuan-su-1091-er-jin-zhi-ju-zhen-z-gxba/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/pond-sizes-lcci/">面试题 16.19. 水域大小</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/pond-sizes-lcci/solution/xi-you-yuan-su-mian-shi-ti-1619-shui-yu-m0azj/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2><a href="https://mathworld.wolfram.com/BipartiteGraph.html">二分图判定</a>之着色法BFS</h2>

<p>先要讲下<strong><a href="https://en.wikipedia.org/wiki/Bipartite_graph">二分图</a></strong>的定义：对于图中的<strong>任意两顶点u和v</strong>，如果它们有一条边<strong>直接相连</strong>，那么u和v必须<strong>属于不同的集合</strong>。更为学术一点的说法是：如果能将一个图的顶点集合分割为两个独立的子集A和B，并使略中的每一条边的两个节点一个来自于A集合，一个来自于B集合，就将这个图称为<strong>二分图</strong>。</p>

<p><img src="https://www.researchgate.net/profile/Ehdieh_Khaledian/publication/327213774/figure/download/fig1/AS:671177970294792@1537032706486/a-Example-showing-the-bipartite-graph-of-the-organism-cluster-relationship-Left-side.ppm" alt="" /></p>

<p>有些题目，并不会这么直接的告诉你这是一个判定二分图，而且会做一些信息隐藏，一般而言，如果 涉及把一个图的顶点进行归类，只分为两类，并且有边直连的顶点要归在不同的类别中，那么这就是一个二分图判定问题，比如题886，给你的是某人不喜欢的一群人，显然有边连接的顶点要归属于不同的集合，那么这就是一个二分图判定题。</p>

<p>可以用着色法BFS来判定二分图，大概的算法流程如下：</p>

<ol>
<li>用一个与顶点集合一样大的整数数组（或者其他结构）用作颜色标记，0是未着色（也就是还未访问），1着成红色，2着成绿色</li>
<li>任选一个顶点作为起点，着色为1（红色），加入队列，开始BFS</li>
<li>当队列不为空时，取出当前顶点u，遍历与u直连的顶点v，如果v还未着色，则把它加入队列，并着为3-color[u]；如果v已着色，且与color[u]着色一样，则说明不是二分图，返回F并终止遍历；</li>
<li>重复3直到队列为空，说明可以把所有顶点着为不同的色，也即是二分图，返回T</li>
</ol>


<p>伪码如下：</p>

<pre><code class="python3">start = 0
color = [0] * n
queue = deque()
queue.add(start)
color[start] = 1
while len(queue) &gt; 0:
    u = queue.popleft()
    for v in graph[u]:
        if color[v] == 0:
            color[v] = 3 - color[u]
            queue.add(v)
        elif color[v] == color[u]:
            return False
return True
</code></pre>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/is-graph-bipartite/description/">785. 判断二分图</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/is-graph-bipartite/solutions/2306267/xi-you-yuan-su-785-pan-duan-er-fen-tu-zh-mmdh/">题解</a> </td>
<td style="text-align:left;"> 二分图判定板子题 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/possible-bipartition/">886. 可能的二分法</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/possible-bipartition/solution/886-ke-neng-de-er-fen-fa-by-alexhilton-5au7/">题解</a> </td>
<td style="text-align:left;">  二分图判定模板题  </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><strong>注意</strong>：二分图是把图的顶点进行分类到不同的集合，这是并查集最为擅长的应用场景，因此用并查集解决二分图判定更为高效和优雅。关于<a href="http://toughcoder.net/blog/2022/09/08/disjoint-set-data-structure/">并查集可以参考此文</a>。</p>

<h2>多源BFS</h2>

<p>基础的BFS<strong>只有一个起点</strong>，把图中的<strong>某一个顶点</strong>最先放入队列，然后开始BFS。但有些场景，以单个顶点为起点不能解决问题。这类问题的特点一般是求某一类顶点的极值，比如0-1矩阵中，求0最近的1，或者求1最近的0。这里的要点在于说单个顶点通过BFS找到的值并不一定是全局最优解。而如果以每个顶点都做一遍BFS又会导致复杂度太高，不但复杂度超高，而且有时候会难以编码（大致的思路是有的，但难以转化为具体的代码）。这时就要用到更为复杂一些的多源BFS来求解。</p>

<p>需要应用多源BFS题目的特点是与<strong>多个顶点相关</strong>，并求一个<strong>全局最优解</strong>，也就是说求<strong>顶点集合</strong>到另一个<strong>顶点集合</strong>的距离或者路径长度。有时候我们还需要运用逆向思维，反向思考，以使问题简化，比如虽然题目求0到1的距离，但如果反着去计算1到0的距离，反倒更为方便一些，那么就需要把顶点集合反一下。</p>

<p>多源BFS的套路：</p>

<ol>
<li>依据题目信息，看是否要把顶点集互换一下，大部分的题目是需要互换的</li>
<li>把点集都加入到队列中，同时入队的还有一个初始状态，比如求最短路径，可以把MAX_INTEGER加进去</li>
<li>以这些点集为起始，去做BFS，同时更新状态，这与常规BFS就一样了</li>
<li>为了防止重复遍历也是要做标记的，这与常规BFS一样，可以用步骤3里面与顶点一起入队的状态来当作标记，比如是MAX_INTEGER时肯定是还未访问到，是其他值时说明已访问过了</li>
<li>遍历过程中，可以求得全局最优解</li>
</ol>


<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/01-matrix/description/">542. 01 矩阵</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/01-matrix/solutions/1790257/by-alexhilton-ngwy/">题解</a> </td>
<td style="text-align:left;"> 点集互换，多源BFS模板题，多源最短路径 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-bridge/description/">934. 最短的桥</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-bridge/solutions/1922745/934-zui-duan-de-qiao-by-alexhilton-mkxy/">题解</a> </td>
<td style="text-align:left;"> 多源BFS，数圈圈 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotting-oranges/description/">994. 腐烂的橘子</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotting-oranges/solutions/1794075/994-fu-lan-de-ju-zi-by-alexhilton-6g10/">题解</a> </td>
<td style="text-align:left;"> 多源BFS </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/as-far-from-land-as-possible/description/">1162. 地图分析</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/as-far-from-land-as-possible/solution/xi-you-yuan-su-1162-di-tu-fen-xi-duo-yua-7c8t/">题解</a> </td>
<td style="text-align:left;"> 点集互换，多源最短路径 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-path-with-alternating-colors/description/">1129. 颜色交替的最短路径</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-path-with-alternating-colors/solutions/2091594/1129-yan-se-jiao-ti-de-zui-duan-lu-jing-cwm57/">题解</a> </td>
<td style="text-align:left;"> 双源BFS </td>
</tr>
</tbody>
</table>


<h2>圈式BFS</h2>

<p>单源多源都可以，重点不是起点的多少，而是要在遍历的时候注意数圈层。BFS的特点是像水波一样一层一层，一圈一圈的由起点向外传播，有时候我们需要对这些层和圈进行计数。</p>

<p>其实，这个跟树的层序遍历是一样的，树的遍历大法可以<a href="http://toughcoder.net/blog/2022/08/18/binary-tree-made-easy/">参考 这个文章</a>，如果对树的层序遍历熟悉了，那么图的数圈圈也就会了。做法就是添加下一层时做一下标记，就可以了，并不复杂。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-bridge/description/">934. 最短的桥</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-bridge/solutions/1922745/934-zui-duan-de-qiao-by-alexhilton-mkxy/">题解</a> </td>
<td style="text-align:left;"> 多源BFS，数圈圈 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>泛图BFS（枚举）</h2>

<p>图是一个很广泛的概念，任何事情都可以视为一个顶点，事物之间的联系可视一条边，状态也可以视为一个顶点，一个状态变化 为另一个状态可视为一条边，因此图论的搜索，或者说图论的遍历方式可以广泛的应用。</p>

<p>BFS的遍历特点是能找到<strong>两个顶点之间的最短路径</strong>，因此，当找一些<strong>状态与状态之间的最少变化次数</strong>之类的问题时，经过适当的建模后，便可以用图论的BFS来求解。</p>

<p>针对广泛图应用BFS的套路：</p>

<ol>
<li>针对 状态进行建模，确定状态的变化规律</li>
<li>搞清楚状态的变化 规律后就可以建图了，要注意图是否是无限图，如果是无限图就必须找遍历搜索的边界</li>
<li>把起点加入队列，确定标记方案，然后开始做BFS</li>
<li>注意边界，包括重复标记，以及搜索的边界，以防止进入死循环</li>
</ol>


<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/jump-game-iii/solutions/">1306. 跳跃游戏 III</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/jump-game-iii/solutions/2302494/1306-tiao-yue-you-xi-iii-by-alexhilton-uayu/">题解</a> </td>
<td style="text-align:left;"> 模板题，本身是数组边界固定 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/minimum-jumps-to-reach-home/description/">1654. 到家的最少跳跃次数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/minimum-jumps-to-reach-home/solutions/2302780/xi-you-yuan-su-1654-dao-jia-de-zui-shao-mrilp/">题解</a> </td>
<td style="text-align:left;"> 容易想到BFS，确定右界是关键 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/minimum-genetic-mutation/">433. 最小基因变化</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/minimum-genetic-mutation/solutions/2303783/433-zui-xiao-ji-yin-bian-hua-by-alexhilt-vc3x/">题解</a> </td>
<td style="text-align:left;"> 枚举状态的模板题 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/open-the-lock/">752. 打开转盘锁</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/open-the-lock/solutions/2303829/xi-you-yuan-su-752-da-kai-zhuan-pan-suo-b6ulp/">题解</a> </td>
<td style="text-align:left;"> 枚举状态的模板题 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><strong>注意</strong>：本质上，这属于枚举，我们枚举各种状态，然后找到想要的答案。用BFS来枚举是寻找两种状态之间的最少变化 次数。而DFS枚举则用于查找所有的可行方案，这其实就是回溯算法了。图论真的博大精深，与各种算法融合在一起。</p>

<h2>复杂状态处理</h2>

<p>图的遍历可复杂也可简单，重点并不是遍历方式如DFS，单源BFS或者多源BFS，而且遍历到每个节点时，对节点状态的处理，这里可能会千变万化，有些难题就难在对状态的处理，有些是状态太复杂了，要想办法压缩 以达到可处理的地步（如题847），有些则是状态变化 太多了（如题417）。这有点类似于<a href="http://toughcoder.net/blog/2022/09/08/introduction-to-dynamic-programming/">动态规划</a>，是没有固定的套路的，只能靠平时积累以及分析建模能力了。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-path-visiting-all-nodes/description/">847. 访问所有节点的最短路径</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-path-visiting-all-nodes/solutions/2301703/xi-you-yuan-su-847-fang-wen-suo-you-jie-jvpcz/">题解</a> </td>
<td style="text-align:left;"> 多源BFS，状态压缩 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/">1926. 迷宫中离入口最近的出口</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/solution/xi-you-yuan-su-1926-mi-gong-zhong-chi-ru-fxvi/">题解</a> </td>
<td style="text-align:left;"> 单源最短路 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>双向BFS</h2>

<p>无论是单源还是多源做BFS时一般都是一个方向的，也就是说把起始顶点或者点集加入队列作为起点，向着目标顶点或者点集或者说终点去BFS遍历。通常情况下，这没什么问题。</p>

<p>但当数据量特别大时，或者状态的计算比较复杂时，这样效率就不够高了，这时需要更为复杂的玩法。其实前面说的起点和终点都是相对的，图的搜索遍历其实是不分方向的，起点到终点的最短距离，与终点到起点的最短距离其实是一样的，反过来你把终点当成起点来做BFS也是一样的（前面讲多源BFS时就提到过逆向思维，把点集对换，其实就是从原终点当作新起点做BFS）。</p>

<p>那么，假如同时从起点开始，和从终点开始一起做BFS，当两个BFS相遇时（同时到达相同的一层顶点时）搜索完成，是不是搜索效率就会加倍？这就是双向BFS的核心思想。另外，为了保证平衡性和效率，每次要<strong>优先把队列元素数量小</strong>的一个方向向前推进。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/word-ladder/description/">127. 单词接龙</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/word-ladder/solution/xi-you-yuan-su-127-dan-ci-jie-long-bfs-b-52ia/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/">1091. 二进制矩阵中的最短路径</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/solution/xi-you-yuan-su-1091-er-jin-zhi-ju-zhen-z-gxba/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>逆向遍历</h2>

<p>图的遍历都是从某些顶点出发，去寻找另外的顶点。有些时候是起始顶点已知，比如前面提到的常规遍历问题，无论是单源还是多源，都是起点是已知的固定的一个顶点集合。</p>

<p>但有时候，起点并不固定，但终点是固定的，这时候就需要运用逆向思维，从这些固定的终点出发做遍历，进而求解。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/pacific-atlantic-water-flow/">417. 太平洋大西洋水流问题</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/pacific-atlantic-water-flow/solution/xi-you-yuan-su-417-tai-ping-yang-da-xi-y-jami/">题解</a>  </td>
<td style="text-align:left;"> 典型的终点固定，起点不固定，从终点出发遍历  </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>拓朴排序</h2>

<p>对于有向无环图而言，拓朴排序能够把顶点按依赖顺序排成线性列表，用的也是BFS来实现的，<a href="http://toughcoder.net/blog/2022/09/08/topological-sorting/">详情可以参考此文</a>。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://leetcode.cn/circle/discuss/FyPTTM/">图论算法，拿得起放得下</a></li>
<li><a href="https://www.hackerearth.com/practice/algorithms/graphs/breadth-first-search/tutorial/">Breadth First Search</a></li>
<li><a href="https://www.geeksforgeeks.org/multi-source-shortest-path-in-unweighted-graph/">Multi Source Shortest Path in Unweighted Graph</a></li>
<li><a href="https://www.geeksforgeeks.org/bipartite-graph/">Check whether a given graph is Bipartite or not</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[String Problems Archive]]></title>
    <link href="http://toughcoder.net/blog/2023/03/19/string-problem-archive/"/>
    <updated>2023-03-19T10:24:09+08:00</updated>
    <id>http://toughcoder.net/blog/2023/03/19/string-problem-archive</id>
    <content type="html"><![CDATA[<p>字符串即由字符组成的线性数组结构，可以理解为字符数组或者字符列表，但元素的集合是有限集合，通常是英文字符，数字和算术运算符号。可以说数组和列表的常见问题和技巧都可以应用于字符串，但因为是有限集合，所以又有一些独特的问题和技巧，今天就来总结一下。</p>

<p><a href=""><img src="https://cdn.programiz.com/sites/tutorial2program/files/c-strings.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>编程技巧</h2>

<h3>转成字符数组来遍历</h3>

<p>对于Java语言来说charAt(i)非常的慢，所以如果需要多次遍历，或者多次获利某个索引位置的字符，最好先转成字符数组toCharArray()，这样效率会高出很多。对于其他语言像Python3和Kotlin则没必要，因为本来就可以像常规数组(列表)一样遍历。</p>

<h3>用桶代替哈希表</h3>

<p>字符串的每个元素是有限集合，所以要尽可能的用桶来代替哈希表，每当需要对字符计数，或者做映射的时候，都可以先尝试用桶。
比如小写英文字母，就可以用一个长度为26的整数数组来计数，字符与索引的转化关系是ch-&lsquo;a&#8217;，同理可以扩展到大写ch-&#8216;A&#8217;，甚至数字字符ch-&#8216;0&#8217;。</p>

<h3>字符与索引相互转化</h3>

<p>前面提到了用桶，就是把字符转化为索引。反过来也是可行的。目标字符ch = (char) (i + &lsquo;a&rsquo;)就把索引转为小写，大写和数字字符也是同理的。</p>

<h4>Java/C/C++</h4>

<p>传统语言里面char相当于无符号整数，所以可以直接强行互转：</p>

<pre><code class="Java">char ch = (char) (i + 'a');
int idx = ch - 'a'
</code></pre>

<h4>Python3</h4>

<p>大Python3中要用ord()和chr()来进行字符到整数的互转</p>

<pre><code class="Python3">idx = ord(ch) - ord('a')
ch = chr(idx + ord('a'))
</code></pre>

<h4>Kotlin</h4>

<p>因为Kotlin中没有所谓的基础类型，都是对象，所以就用对象提供的方法即可。字符转为整数用Char.code，要把数字字符转为对应字面的整数用Char.digitToInt，如:</p>

<pre><code class="Kotlin">val ch: Char = '3'
println("ch as int ${ch.code}, ch digit as int ${ch.digitToInt()}")
// ch as int 51, ch digit as int 3
</code></pre>

<p>如果是想转成其他进制的整数，可以传入基数作为参数，如：</p>

<pre><code class="Kotlin">val hexCh = 'F'
println("hex ch ${hexCh.digitToInt(16)}") // 15
</code></pre>

<p>因为是基于JVM的，所以字符也可以用于计算，比如idx = ch - &lsquo;a&#8217;，这是完全没有问题的。</p>

<pre><code class="Kotlin">    val a = 'a'
    var idx = 'd' - a
    val aidx = idx + 7
    println("idx $idx, aidx to ch ${(aidx + 'a'.code).toChar()}")
    //idx 3, aidx to ch k
</code></pre>

<p>反过来，整数转到字符，用Int.toChar()就可以了，会按ASCII的code值去转。另外，如果想转成数字字符用Character.forDigit(ch, radix):</p>

<pre><code class="Kotlin">val d = 8
println(" int to char ${d.toChar()}, to digit char ${Character.forDigit(d, 10)}")
</code></pre>

<h3>字符数组/列表转为String</h3>

<p>涉及字符的题目，一般需要转成字符数组处理后，再把字符数组转成字符串。</p>

<p>对于Java来说，String的构造方法支持传入char[]作为参数。</p>

<p>而Python3，其实就是字符列表转为字串，可以用join方法，这个方法是str提供的方法，用一个str当作分隔符来把一个列表连接起来：</p>

<pre><code class="Python3">chars = ['H', 'e', 'l', 'l', 'o']
''.join(chars) # "Hello"
</code></pre>

<p>同样，Kotlin中也有joinToString方法，它对数组和列表都支持，可以传入一个参数作为分隔符：</p>

<pre><code class="Kotlin">val chars = charArrayOf('H', 'e', 'l', 'l', 'o')
val res = chars.joinToString("")
</code></pre>

<h3>压缩到位运算</h3>

<p>如果字符集合特别有限，比如只有有限几个字符，或者只有小写，只有大写，这时可以更进一步的，用位运算来进行优化。小写字符只有26个，一个整数有32位可以用，完全够用。</p>

<p>当满足以下两个条件时就可以考虑用位运算来优化：仅涉及两个状态，有和没有；另外就是字符或者组合后的集合范围在32个以内。</p>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sort-characters-by-frequency/">451. 根据字符出现频率排序</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sort-characters-by-frequency/solution/451-gen-ju-zi-fu-chu-xian-pin-lu-pai-xu-01mur/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>变位词</h2>

<p>变位词是指对于一个字符串，把某几个字符位置换一下之后得到的字符串，与原串互为变位词。其实变位词不局限于字符串，对于任何一个线性列表来说，把某几个元素位置变一下就是互为变位词了。变位词有两大特点：字符集合是一样的，种类一样，频次也一样，但排列不一样。</p>

<p>基于它的特点，涉及变位词的问题，就变成了字符频次统计的问题了，如果两个字符串的字符频次一样，那么就互为变位词。另外的处理方式就是排序，因为只是排列不一样，所以按照同一规则排序后，两字符串就相同了，那么通过排序 来验证也可以可行的。具体处理时，要依据不同的条件来灵活选择具体的识别方式。</p>

<p>需要注意的是，当用频次统计法时，记得用桶而不是直接用哈希表。</p>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/group-anagrams/solution/49-zi-mu-yi-wei-ci-fen-zu-by-alexhilton-ni22/">题解</a> </td>
<td style="text-align:left;"> 排序法 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>回文</h2>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-palindromic-substring/solution/">5. 最长回文子串</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-palindromic-substring/solution/5-zui-chang-hui-wen-zi-chuan-by-alexhilt-6kvt/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>状态压缩</h2>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/repeated-dna-sequences/solution/187-zhong-fu-de-dnaxu-lie-by-alexhilton-5or9/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>其他</h2>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基础利器之Stack和Queue]]></title>
    <link href="http://toughcoder.net/blog/2023/03/05/stack-and-queue/"/>
    <updated>2023-03-05T10:11:21+08:00</updated>
    <id>http://toughcoder.net/blog/2023/03/05/stack-and-queue</id>
    <content type="html"><![CDATA[<p>在基础的数据结构中栈和队列使用极其广泛，其用法也很多，今天就来总结一下栈和队列的使用方法和相关的题目。</p>

<p><a href=""><img src="https://i0.wp.com/www.dineshonjava.com/wp-content/uploads/2017/01/stack-queue.png?fit=523%2C228&amp;ssl=1" title="auto auto" ></a></p>

<!-- more -->


<h2>队列Queue</h2>

<p><img src="https://www.wisdomjobs.com/tutorials/representation-of-a-fifo-queue.png" alt="" /></p>

<h3>基本概念</h3>

<p>队列是一个线性数据 结构，特点是先入先出，也就是能保证先入队的元素先出队，也即FIFO First In First Out。与现实生活中的排队是一样的。</p>

<h3>基础应用</h3>

<p>应用很广泛，像消息队列，任务队列，以及像滑动窗口。</p>

<h4>典型题目</h4>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/qIsx9U/">剑指 Offer II 041. 滑动窗口的平均值</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/qIsx9U/solution/by-alexhilton-1c5a/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-circular-queue/">622. 设计循环队列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-circular-queue/solution/622-she-ji-xun-huan-dui-lie-by-alexhilto-adr5/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h3>中级应用</h3>

<p>BFS要用到队列。</p>

<p>BFS可以<a href="http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy/">参考另外一个文章</a>。</p>

<h4>典型题目</h4>

<h3>高级应用</h3>

<p>单调队列，队列中的元素以非递增顺序或者非递减顺序排列。</p>

<p>单调队列<a href="http://toughcoder.net/blog/2022/08/15/secret-weapon-monotonic-stack/">参见另外一个文章</a>。</p>

<h2>栈Stack</h2>

<p><img src="https://holycoders.com/content/images/2020/06/Stack.png" alt="" /></p>

<h3>基本概念</h3>

<p>也是一个线性结构，与队列类似，但它是先入后出，或者说后入先出，FILO First In Last Out。现实生活中也有，比如像盘子，通常是叠在一起的，这就是一个栈，一个一个叠 在一起，最后放上去的，最先拿下来用。</p>

<h3>基础应用</h3>

<p>程序运行时会用到栈，函数的调用会用到栈。还有一些模拟的场景也会用到栈，比如像处理括号和表达式一类的问题时。</p>

<h4>典型题目</h4>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/valid-parentheses/solution/by-alexhilton-8tcu/">题解</a> </td>
<td style="text-align:left;"> 栈模拟 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/min-stack/solution/by-alexhilton-20au/">题解</a> </td>
<td style="text-align:left;"> 栈模拟 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/asteroid-collision/">735. 行星碰撞</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/asteroid-collision/solution/by-alexhilton-87ks/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-frequency-stack/">895. 最大频率栈</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-frequency-stack/solution/by-alexhilton-xdq9/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/validate-stack-sequences/">946. 验证栈序列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/validate-stack-sequences/solution/946-yan-zheng-zhan-xu-lie-by-alexhilton-cjjq/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/build-an-array-with-stack-operations/">1441. 用栈操作构建数组</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/build-an-array-with-stack-operations/solution/1441-yong-zhan-cao-zuo-gou-jian-shu-zu-b-sw1y/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h3>中级应用</h3>

<p>DFS需要用到栈.</p>

<p>DFS可以<a href="http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy/">参考另外一个文章</a>。</p>

<h3>高级应用</h3>

<p>单调栈<a href="http://toughcoder.net/blog/2022/08/15/secret-weapon-monotonic-stack/">参见另外一个文章</a>。</p>

<h2>双端队列Deque</h2>

<p>双端队列Deque读作dek，是两端都可以入队和出队，因此它即可以用作栈也可以用作队列，在实际使用中是最多的，大多数时候都尽可能用双端队列。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Design Problems Archive]]></title>
    <link href="http://toughcoder.net/blog/2023/02/09/design-problems-archive/"/>
    <updated>2023-02-09T20:58:57+08:00</updated>
    <id>http://toughcoder.net/blog/2023/02/09/design-problems-archive</id>
    <content type="html"><![CDATA[<p>设计类习题是指要求设计一个类以完成某种特定需求，不是很复杂，通常一个类就能搞定，整体代码也不会特别长，但又能考察到一些基本的知识点，或者一些基本的技巧。通常是由一些日常中常见的任务经过简化而来。</p>

<p><a href=""><img src="http://www.dreamtemplate.com/blog/wp-content/uploads/2012/05/p228.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>因为通常都不会特别复杂，用常规的数据结构就能实现，此类问题最为关键的是要理清需求，各种边界条件的处理。一般情况下哈希表加上线性的结构如队栈或者链表就能解决。不用往复杂了想，常规数据结构，常用技术就能搞定，关键还是要读懂需求。</p>

<h2>典型问题</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/lru-cache/solution/by-alexhilton-xdf0/">题解</a> </td>
<td style="text-align:left;"> 哈希表，双向链表 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/min-stack/solution/by-alexhilton-20au/">题解</a> </td>
<td style="text-align:left;"> 栈 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/implement-queue-using-stacks/solution/by-alexhilton-hj5r/">题解</a> </td>
<td style="text-align:left;">  栈，队列 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/">304. 二维区域和检索 - 矩阵不可变</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/solution/xi-you-yuan-su-304-er-wei-qu-yu-he-jian-uqui5/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/encode-and-decode-tinyurl/">535. TinyURL 的加密与解密</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/encode-and-decode-tinyurl/solution/by-alexhilton-lz1t/">题解</a> </td>
<td style="text-align:left;"> 哈希表 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-circular-queue/">622. 设计循环队列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-circular-queue/solution/622-she-ji-xun-huan-dui-lie-by-alexhilto-adr5/">题解</a> </td>
<td style="text-align:left;"> 队列 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-circular-deque/">641. 设计循环双端队列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-circular-deque/solution/by-alexhilton-ve31/">题解</a> </td>
<td style="text-align:left;"> 队列 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/online-stock-span/">901. 股票价格跨度</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/online-stock-span/solution/by-alexhilton-piye/">题解</a> </td>
<td style="text-align:left;">  单调栈 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/complete-binary-tree-inserter/">919. 完全二叉树插入器</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/complete-binary-tree-inserter/solution/by-alexhilton-msqn/">题解</a> </td>
<td style="text-align:left;"> 队列，BFS </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-skiplist/">1206. 设计跳表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-skiplist/solution/1206-she-ji-tiao-biao-by-alexhilton-sd06/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-an-ordered-stream/">1656. 设计有序流</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-an-ordered-stream/solution/by-alexhilton-cev5/">题解</a> </td>
<td style="text-align:left;"> 队列 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-authentication-manager/">1797. 设计一个验证系统</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-authentication-manager/solution/1797-she-ji-yi-ge-yan-zheng-xi-tong-by-a-copl/">题解</a> </td>
<td style="text-align:left;"> 哈希表，双向链表，LRUCache </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/qIsx9U/">剑指 Offer II 041. 滑动窗口的平均值</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/qIsx9U/solution/by-alexhilton-1c5a/">题解</a> </td>
<td style="text-align:left;"> 队列 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
</feed>
