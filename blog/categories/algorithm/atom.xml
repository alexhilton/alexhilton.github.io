<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2023-02-08T21:08:37+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[链表问题总结]]></title>
    <link href="http://toughcoder.net/blog/2023/01/31/mastering-linkedlist/"/>
    <updated>2023-01-31T23:18:57+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/31/mastering-linkedlist</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Linked_list">链表LinkedList</a>是一种线性的非连续数据结构，优势是随机删除和添加特别高效，但随机访问效率差。因为链表边界条件较多，容易出错，所以还是比较常见的一类题目。但链表常见的问题就那么多，总结起来就那么几个，想要掌握还是比较容易的。</p>

<p><a href=""><img src="https://myeasytuts.com/wp-content/uploads/2020/04/Linked-List-in-Swift.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>单链表</h2>

<p>单链表是出现频率最高的，虽然现实中很少用它，因为它的效率差，现实中一般多用双向链表。单链表也即是每个节点只有一个指针，指向下一个节点，只能从前往后的顺序来遍历，如果想对某一个节点进行操作，必须找到这个节点的前一个节点。
<img src="https://www.testingdocs.com/questions/wp-content/uploads/Single-Linked-List.png" alt="" /></p>

<h3>哨兵节点</h3>

<p>哨兵节点是指在输入的头节点的前面加一个节点，它的值没有任何意义，它的存在是为了简化逻辑。通常用于添加和删除操作中，如果输入的头节点是null，那么就需要特殊处理，而用了哨兵节点，就可以简化逻辑。</p>

<p>比如说，常规的添加和删除：</p>

<pre><code class="java">    public static ListNode normalAppend(ListNode head, int value) {
        ListNode newNode = new ListNode(value);
        // ugly
        if (head == null) {
            return newNode;
        }

        ListNode current = head;
        while (current.next != null) {
            current = current.next;
        }

        current.next = newNode;
        return head;
    }

    public static ListNode normalDelete(ListNode head, int value) {
          // ugly
        if (head == null) {
            return null;
        }
        // ugly
        if (head.val == value) {
            return head.next;
        }

        ListNode current = head;
        while (current.next != null) {
            if (current.next.val == value) {
                current.next = current.next.next;
                break;
            }
            current = current.next;
        }

        return head;
    }
</code></pre>

<p>可以看到为了处理头节点是null的情况要加很多逻辑，但如果使用哨兵节点，逻辑就会非常简单：</p>

<pre><code class="java">    public static ListNode append(ListNode head, int value) {
        ListNode dummy = new ListNode(0, head);

        ListNode current = dummy;
        while (current.next != null) {
            current = current.next;
        }
        current.next = new ListNode(value);
        return dummy.next;
    }

    public static ListNode delete(ListNode head, int value) {
        ListNode dummy = new ListNode(0, head);

        ListNode current = dummy;
        while (current.next != null) {
            if (current.next.val == value) {
                current.next = current.next.next;
                break;
            }
            current = current.next;
        }

        return dummy.next;
    }
</code></pre>

<p>哨兵节点的作用是要能简化逻辑，一般用在需要考虑头节点为null的情况，或者当使用双指针，需要从-1位置出发时。但不要滥用，要真能起到简化逻辑才可以。另外就是注意哨兵节点的值要尽可能与常规节点的值区分开来，否则把哨兵节点当成常规节点就会出错。</p>

<h3>反转</h3>

<p>链表反转是基础的操作，有三种方式：<strong>迭代，逆向构造式</strong>；<strong>借助栈，顺向构建</strong>；和<strong>递归式</strong>，详见206的题解。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reverse-linked-list/solution/206-fan-zhuan-lian-biao-by-alexhilton-6ttd/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/palindrome-linked-list/solution/by-alexhilton-pcab/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br/></p>

<h3>遍历和随机访问</h3>

<p>主要是为了查找某个节点，以进行其他操作。需要别注意的是单链表必须 要找到前一个节点才可以，所以遍历的终止条件一般都是curr.next == target。高级的方法就是<strong>双指针</strong>和<strong>快慢指针</strong>，双指针是指两个指针指向不同的位置，然后以同样的速度向前移动；而快慢指针的特点是一个跑的快（两倍步长到next.next），一个跑的慢（常规步长到next），通常从同一个起点出发，注意它们之间是有区别的。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/19-shan-chu-lian-biao-de-dao-shu-di-n-ge-xa3i/">题解</a> </td>
<td style="text-align:left;"> 双指针 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/linked-list-components/">817. 链表组件</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/linked-list-components/solution/by-alexhilton-0raa/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/">面试题 02.02. 返回倒数第 k 个节点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/solution/by-alexhilton-us40/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/middle-of-the-linked-list/solution/by-alexhilton-0uz4/">题解</a> </td>
<td style="text-align:left;"> 快慢指针 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="">1290. 二进制链表转整数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/convert-binary-number-in-a-linked-list-to-integer/solution/by-alexhilton-h6oe/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br/></p>

<h3>插入和删除</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/solution/by-alexhilton-p9ch/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/solution/82-shan-chu-pai-xu-lian-biao-zhong-de-zh-cmlv/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/solution/by-alexhilton-u8ul/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-duplicate-node-lcci/">面试题 02.01. 移除重复节点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-duplicate-node-lcci/solution/by-alexhilton-u6rm/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-linked-list-elements/solution/by-alexhilton-qvkv/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/delete-node-in-a-linked-list/">237. 删除链表中的节点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/delete-node-in-a-linked-list/solution/by-alexhilton-3c7t/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br/></p>

<h3>链表合并</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-two-sorted-lists/solution/21-he-bing-liang-ge-you-xu-lian-biao-by-2pafg/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-k-sorted-lists/solution/by-alexhilton-zctb/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sort-list/solution/by-alexhilton-tqk5/">题解</a> </td>
<td style="text-align:left;"> 寻找中间点，归并排序 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-in-between-linked-lists/">1669. 合并两个链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-in-between-linked-lists/solution/by-alexhilton-gl5m/">题解</a> </td>
<td style="text-align:left;"> 严格来说不算合并，主要涉及删除和插入，以及随机访问 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br/></p>

<h3>相交链表</h3>

<p>属于高级题目，但套路单一，当作基本套路记住就行了。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/solution/by-alexhilton-jhos/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/solution/114-er-cha-shu-zhan-kai-wei-lian-biao-by-3mke/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br/></p>

<h3>环形链表</h3>

<p>主要分两种，一种是链表部分成环；另外就是整个链表就是环（首尾相接），套路也比较单一，记住就行了。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/4ueAj6/">剑指 Offer II 029. 排序的循环链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/4ueAj6/solution/by-alexhilton-dr5w/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/linked-list-cycle/solution/141-huan-xing-lian-biao-by-alexhilton-pzk1/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/linked-list-cycle-ii/solution/by-alexhilton-u2dm/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br/></p>

<h3>综合</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/solution/114-er-cha-shu-zhan-kai-wei-lian-biao-by-3mke/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/lru-cache/solution/by-alexhilton-xdf0/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br/></p>

<h2>双向链表</h2>

<p>每个节点有两个指针分别指向下一个节点和前一个节点，这是在实际工作中使用的最多的链表形式，绝大部分操作与单链表是一样的，也是线性的。</p>

<p><img src="https://www.studytonight.com/data-structures/images/doubly-linked-list-1.png" alt="" /></p>

<p>双向链表因为有两个指针，所以在删除或者插入的时候需要小心处理好四个指针，其他的东西与单链表是一样的。</p>

<h2>跳表 SkipList</h2>

<p>这是以链表为基础能构造出来的最复杂的数据结构，是二维链表形式，它能够实现log(n)级别的各种操作，效率非常之高，在很多地方替代了平衡二叉树（二叉树只有达到平衡才能到最高的效率，所以工程中使用的二叉树肯定要平衡）。
<img src="https://pic2.zhimg.com/v2-17f6e0c031067f3d2a1d5b8f0e586ff5_r.jpg" alt="" /></p>

<p>首先，要明确一下问题，跳表也好，二叉树也好，是解决有序数据集的查询效率的。对于数量为n的数据集来说，如果是无序的肯定是O(n)，但如果数据有序，比如一个排好序的数组或者列表就可以用二分查找，或者用BST（二叉搜索树）时间复杂度都会降低到O(log<sup>n</sup>)。也就是说跳表解决的问题是有序列数据集的查询问题。</p>

<h3>基本原理</h3>

<p>前面说了，对于有序数据集，如果是用数组或者列表来存储，查询 效率肯定是O(log<sup>n</sup>)的，但是连续结构有一个问题就是它的插入和删除是O(n)的。链表呢虽然插入和删除可以做到O(1)，但是它的随机访问（也即查询）慢要O(n)。那么对于一个有序的单链表来说，有没有办法可以提升它的查询效率呢？（插入和删除以及修改都要以查询为先，只有找到了才方便做插删改）。我们要利用数据已排好序，假如能像BST或者二分那样，能把数据集缩小，就可以提升效率。</p>

<p>假如有一个现成的指针指向有序单链表的中间，那么就可以把中单节点的值与目标值比较，如果目标值大于中间节点，那目标值肯定 在后半段，否则就在前半段。假如有更多的中间节点指针，是不是就是二分查找了？可以用空间换时间，给有序单链表建立索引层，每一层也是一个单链表，它会把下面一层链表分成几段，底层是数据集，即有序单链表。这样，从最上层往下层走，就可以把数据集缩小到一个很小的范围内。极端情况下，可以在1/2，1/4，1/8. &hellip; 建立索引层，那这是不是就变成BST了？</p>

<p>这就是跳表的核心想。查询的时候总是从最上层开始，因为每一层也是一个有序链表，当下一个节点值大于目标值时，就需要向下走，然后从这一层的这个节点开始，先向后查询，下一个节点大于目标值时，再向下走，这样当前指针就会一层一层的来回跳着走，故名跳表。</p>

<h3>实现细节</h3>

<p>跳表的原理并不复杂，容易理解，但从原理到编码仍有很多细节需要考虑，比如如何表示每一层？以及分多少层，分层多能提升效率，但分层多占用的空间也越大，而且如果分的过细，不就变成了二叉树了么。以及说在哪些节点建立索引（也即分层），是按固定的位置（1/2, &frac14;&hellip;）还是按什么规律，因为这直接会影响查询效率。</p>

<h4>如何实现分层</h4>

<p>分层在节点中实现，常规的节点有一个指针next指向下一个节点，在跳表中节点的next指针是一个数组，数组的长度depth就是这个节点的层数，以此实现分层，0层是底层，level-1是最上层。这样就能实现每层两个方向的遍历方式，每一层的next指针就是这一层的链表，通过curr.next[i]就能向后遍历。下楼（也即从上层往下一层走）就是level-1就下去了。</p>

<p>当然 这里也可以用指针，比如节点有两个指针一个是next，指向同层的后面的节点，以及down，指针下一层的同位置的指针。但并无概念上的区别，总之层的实现是在每个节点上面的。</p>

<p>从大的维度来说，整体仍是一个从左向右的单链表，分层是在每个节点上面的实现的。</p>

<h4>在哪里分层</h4>

<p>固定位置分层不可取，因为这就是BST的方式啊，数据集的变化可不会因为位置而改变，比如以1/2, 1/4和1/8这几个位置来分层，那假如数据向1/4后的位置集中了，这就会不平衡，就必须做平衡，会比较麻烦（这也是各种平衡二叉树的痛点）。</p>

<p>跳表用一个比较骚的方式，随机化分层，一个长度为n的有序单链表，每个节点都有机会建立分层索引，这样摊还分析后，整体的效率是最好的。</p>

<p>同时，为了防止分层过于集中，还设立了最大层限制MAX_DEPTH。具体的策略是预先设置一个阈值P（0 &lt; P &lt; 1)，每次随机生成一个0~1的浮点数，如果它大于P，那么这个节点的层数加1，否则就返回当前层数（即保持层数不变）。</p>

<h4>哨兵节点</h4>

<p>为了方便，可以加入哨兵节点head，head犹为重要，这是整个数据结构的入口，并且有了head后插入和删除的逻辑都能得到简化。</p>

<h3>标准实现</h3>

<p>为了简单，节点值用整数，节点值的有效范围可以设定为0~n-1，长度共是n。</p>

<h4>节点</h4>

<p>节点，与单链表很像，一个代表值的int，以及一个数组，代表next指针。</p>

<p>需要注意，一个节点的层数在创建节点时就确定了，在节点的生命周期过程中其层数不会变化。因为对跳表数据结构产生变化 的操作只有插入和删除，插入是生成新的节点，插入时层数已确定；删除是把节点移除，自然也没必要再去改变节点本身了。所以节点的数据类型是Immutable的。</p>

<h4>构造</h4>

<p>跳表其实就是一个单链表表，所以整体数据结构也不复杂，一个哨兵入口的头节点head，还有当前的最大层数level，和两个阈值P_FACTOR是要不要增加层深的阈值以及最大层数MAX_LEVEL。</p>

<h4>查询</h4>

<p>从头节点入口，从其最高层开始查询，具体查询过程与单链表是一样的，持有当前指针，当前指针初化为head节点，不断向后遍历curr直到curr.next[level].val大于目标值，然后走到下一层，继续向后遍历。直到最底层，如果curr.next[0].val等于目标值则找到，否则就是没有，不存在。</p>

<h4>删除</h4>

<h4>插入</h4>

<h4>修改</h4>

<p>一般的实现中不会不回修改的接口，因为修改就是删除原节点，然后再插入新节点，所以用删除和插入就可以实现了，没必要再添加一个方法。</p>

<h3>相关题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-skiplist/">1206. 设计跳表</a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/data-structures/linked-list/">Linked List Data Structure</a></li>
<li><a href="https://www.javatpoint.com/singly-linked-list">Linked List</a></li>
<li><a href="https://www.tutorialspoint.com/data_structures_algorithms/linked_list_algorithms.htm">Data Structure and Algorithms - Linked List</a></li>
<li><a href="https://www.programiz.com/dsa/linked-list">Linked list Data Structure</a></li>
<li><a href="https://www.simplilearn.com/tutorials/data-structure-tutorial/linked-list-in-data-structure">Linked List in A Data Structure: All You Need to Know</a></li>
<li><a href="https://www.geeksforgeeks.org/skip-list/">Skip List | Set 1 (Introduction)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/33674267">SkipList的原理与实现</a></li>
<li><a href="https://www.jianshu.com/p/9d8296562806">Skip List&ndash;跳表（全网最详细的跳表文章没有之一）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/108386262">详解SkipList跳跃链表【含代码】</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/339750543">跳表(skiplist)分析设计与实现(Java)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数学相关题目]]></title>
    <link href="http://toughcoder.net/blog/2023/01/09/mathematics-problem-set/"/>
    <updated>2023-01-09T22:03:57+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/09/mathematics-problem-set</id>
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6/107037">数学</a>是自然科学之母，数学也是算法之母，有一些数学相关的题目需要总结一下。当然暴力法也都是可以解决的，但是通过数学一些公式的引入会提升时间效率。</p>

<p><a href=""><img src="https://ts1.cn.mm.bing.net/th/id/R-C.ba01d095b9f9a650e61d8f49d2b28519?rik=rVVFOj18ozgpZw&amp;riu=http%3a%2f%2fwww.pixelstalk.net%2fwp-content%2fuploads%2f2016%2f05%2fMath-Mathematics-Formula-Wallpaper-for-PC.jpg&amp;ehk=%2bfTho6j8Ym8wGaYhOjf%2bGXs56O7AyL38fNlEbHjIzqQ%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" title="auto auto" ></a></p>

<!-- more -->


<h2>数学题目的特点</h2>

<p>用暴力法或者模拟法也可以解决。</p>

<p>运用相关的数学知识或者数学公式，可以提升效率。</p>

<p>一般都可以使用查表大法。</p>

<h2>数论</h2>

<p>主要是以整数为基础的一些题目，一般会涉及素数，数位等。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/add-digits/">258. 各位相加</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/add-digits/solution/by-alexhilton-uehk/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/prime-arrangements/">1175. 质数排列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/prime-arrangements/solution/by-alexhilton-p5rj/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/count-integers-with-even-digit-sum/">2180. 统计各位数字之和为偶数的整数个数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/count-integers-with-even-digit-sum/solution/2180-tong-ji-ge-wei-shu-zi-zhi-he-wei-ou-mc2e/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>数组轮转</h2>

<p>一般就是把数组的元素按照一定的规则进行移动和轮转。一般涉及LCM（最小公倍数）。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotate-array/solution/189-lun-zhuan-shu-zu-by-alexhilton-1ih4/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/minimum-number-of-operations-to-reinitialize-a-permutation/">1806. 还原排列的最少操作步数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/minimum-number-of-operations-to-reinitialize-a-permutation/solution/1806-huan-yuan-pai-lie-de-zui-shao-cao-z-mqq1/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>矩阵</h2>

<p>矩阵在数学中是非常重要的概念，在计算机科学中矩阵也是非常的重要，像在图形图像以及人工智能领域矩阵都有非常重要的应用。矩阵在编程语言中的表示也非常的容易一般用一个二维数组就可以表示一个矩阵。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotate-array/solution/189-lun-zhuan-shu-zu-by-alexhilton-1ih4/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/minimum-number-of-operations-to-reinitialize-a-permutation/">1806. 还原排列的最少操作步数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/minimum-number-of-operations-to-reinitialize-a-permutation/solution/1806-huan-yuan-pai-lie-de-zui-shao-cao-z-mqq1/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>计算几何</h2>

<p>几何相关的题目也是比较常见的，但通常都是离散化的，一般主要涉及直线，三角形和圆。</p>

<p>计算几何相关问题最需要注意的问题就是精度问题，特别是当坐标是以整数形式给出的时候，这时计算斜率要用乘法，而不能直接用除法。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotate-image/solution/by-alexhilton-5das/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reshape-the-matrix/">566. 重塑矩阵</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reshape-the-matrix/solution/566-zhong-su-ju-zhen-by-alexhilton-nb09/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/check-if-matrix-is-x-matrix/">2319. 判断矩阵是否是一个 X 矩阵</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/check-if-matrix-is-x-matrix/solution/by-alexhilton-083v/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>其他</h2>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/gray-code/">89. 格雷编码</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/gray-code/solution/by-alexhilton-rjx8/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/unique-binary-search-trees/solution/by-alexhilton-y089/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://zhuanlan.zhihu.com/p/497110875">数学是什么？什么是数学？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/301338035">刷算法题必备的数学考点汇总</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搞懂动态规划之状态压缩]]></title>
    <link href="http://toughcoder.net/blog/2022/12/26/understanding-bitmask-dynamic-programming/"/>
    <updated>2022-12-26T12:10:24+08:00</updated>
    <id>http://toughcoder.net/blog/2022/12/26/understanding-bitmask-dynamic-programming</id>
    <content type="html"><![CDATA[<p>动态规划算法博大精深，非常的广泛而复杂。但动态规划离不开状态的存储和转移，要想用动态规划来求解一个问题，必须把问题分解为多个子问题，然后再用状态来记录以解决子问题，最终通过状态转移以得到整个问题的解。根据问题的不同，状态也会有不同的定义，比如有些是用整数来代表计数，有些是用布尔来代表True/False（或者0/1）的状态。</p>

<p><a href=""><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.w0EUQBEfTpJW2jcJ-TeghAHaDU?pid=ImgDet&amp;rs=1" title="auto auto" ></a></p>

<!-- more -->


<p>如果状态可以用True/False（或者0/1）来代表时，那么可以进一步的利用位运算，利用计算机的bit的特点，一个bit可以是0也可以是1，足以表示一个状态，那么就可以把整体的状态只用一个或者几个有限的整数来表示了，这就是状态压缩。</p>

<p>更进一步的，其实可以拓展一下，不光局限在动态规划里面，凡是用到True/False（或者0/1，选与不选等）的辅助存储时，都可以尝试用位运算来代表数组或者哈希表，这其实也是状态压缩。广义上来讲，把一坨用数组或者哈希表表示的状态压缩成为一个整数或者几个有限的整数就是状态压缩。</p>

<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br /></p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.cnblogs.com/labuladong/p/13940269.html">状态压缩：对动态规划进行降维打击</a></li>
<li><a href="https://cp-wiki.vercel.app/dynamic-programming/bitmask-dp/">Bitmask DP</a></li>
<li><a href="https://blog.csdn.net/qq_40722827/article/details/116400306">动态规划之状态压缩DP详细介绍和例题练习</a></li>
<li><a href="https://oi-wiki.org/dp/state/">OI wiki 状压DP</a></li>
<li><a href="https://blog.nowcoder.net/n/fcc30eadb2b44395862194814e819315">【状压DP】状态压缩动态规划入门超详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/131585177">动态规划——状态压缩DP</a></li>
<li><a href="https://www.cnblogs.com/mxrmxr/p/9799832.html">状态压缩入门</a></li>
<li><a href="https://github.com/cormacpayne/Data-Structures-and-Algorithms/blob/master/dynamic-programming/bitmask-dynamic-programming/bitmask-dynamic-programming.md#:~:text=Bitmask%20DP%20is%20a%20type%20of%20dynamic%20programming,or%20a%20binary%20string%20representation%20of%20the%20number.">Bitmask Dynamic Programming</a></li>
<li><a href="https://www.geeksforgeeks.org/bitmasking-and-dynamic-programming-set-1-count-ways-to-assign-unique-cap-to-every-person/">Bitmasking and Dynamic Programming | Set 1 (Count ways to assign unique cap to every person)</a></li>
<li><a href="https://www.geeksforgeeks.org/bitmasking-dynamic-programming-set-2-tsp/">Bitmasking and Dynamic Programming | Set-2 (TSP)</a></li>
<li><a href="https://algo.monster/problems/bitmask_intro">Bitmask and Dynamic Programming</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[前缀和与差分数组简介]]></title>
    <link href="http://toughcoder.net/blog/2022/09/25/intro-to-diff-array/"/>
    <updated>2022-09-25T09:44:51+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/25/intro-to-diff-array</id>
    <content type="html"><![CDATA[<p>在数组相关的问题中前缀和与差分数组是使用使用比较多的辅助数组，能有效的提升效率。前缀和就是数组中到当前元素的和；差分数组是一个辅助数组，每个元素是原数组相邻元素之差，故命名为差分数组，它在原数组区间修改等操作上能辅助提升效率。</p>

<p><a href=""><img src="https://cdn.luogu.com.cn/upload/image_hosting/n0yy6qgd.png" title="auto auto" ></a></p>

<!-- more -->


<h2>一维前缀和</h2>

<p>前缀和的定义不复杂，对于一维列表来说，前缀和是一个辅助列表，前缀和中的元素i，就是原列表中从元素0到元素i的累加和，即preSum[i] = sum(nums, 0, i)。</p>

<pre><code>preSum[0] = nums[0]
preSum[1] = nums[0] + nums[1] = preSum[0] + nums[1]
preSum[2] = nums[0] + nums[1] + nums[2] = preSum[1] + nums[2]
preSum[n-1]= nums[0] + nums[1] + ... + nums[n - 1] = preSum[n - 2] + nums[n - 1]
</code></pre>

<p>代码实现就是这个样的：</p>

<pre><code class="java">    private void init() {
        if (size &lt; 1) {
            return;
        }
        preSum[0] = nums[0];

        for (int i = 1; i &lt; size; i++) {
            preSum[i] = preSum[i - 1] + nums[i];
        }
    }
</code></pre>

<h3>前缀和的应用</h3>

<p>前缀和最大的作用就是能够以常数时间求出一维列表的区间和，或者说连续子列表的和。</p>

<p>比如给定一个列表nums，长度是n，如果想求出子列表[l, r]，都是闭区间的子列表的和，就可以用前缀和。朴素做法很容易想到，就是从遍历区间[l, r]累加即可，显然这是O(n)复杂度，如果查询就一次两次的，当然 也可以，但如果查询次数多了，显然效率差，如果查询m次，时间复杂度会上升到O(mn)。</p>

<p>区间和[l, r]，记为sum(l, r) = nums[l] + nums[l + 1] + &hellip; + nums[r-1] + nums[r]，是可以转化用前缀和来求解的，过程如下：</p>

<pre><code>sum(l, r) = nums[l] + nums[l + 1] + ... + nums[r-1] + nums[r]
           = nums[0] + nums[1] +... + nums[l-1] + nums[l] + ... nums[r-1] + nums[r] - (nums[0] + nums[1] +...+ nums[l-1])
           = preSum[r] - preSum[l-1]
</code></pre>

<p>事先计算前缀和列表，就可以直接以一次减法求出区间和：</p>

<pre><code class="java">    private int regionSum(int i, int j) {
        if (i == 0) {
            return preSum[j];
        }
        return preSum[j] - preSum[i - 1];
    }
</code></pre>

<p><a href="https://github.com/alexhilton/EffectiveAlgorithm/blob/main/datastructure/src/main/java/AuxiliaryArray.java">完整代码看这里</a>。</p>

<h3>前缀和典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/subarray-sum-equals-k/solution/by-alexhilton-eh11/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/find-the-highest-altitude/">1732. 找到最高海拔</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/find-the-highest-altitude/solution/1732-zhao-dao-zui-gao-hai-ba-by-alexhilt-fxhn/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>差分数组</h2>

<p>与前缀和类似，差分数组也是一个常用的辅助数组。它的定义是原数组相邻两元素之差：
<code>
diff[i] = nums[i] - nums[i - 1]
diff[0] = nums[0]
diff[1] = nums[1] - nums[0]
diff[2] = nums[2] - nums[1]
diff[n-1] = nums[n-1] - nums[n-2]
</code>
不难发现，差分数组是前缀和的逆运算，也就是说把差分数组diff求它的前缀和，刚好能得到原始数组：
<code>
nums[0] = diff[0]
nums[1] = nums[0] + nums[1] - nums[0] = diff[0] + diff[1]
nums[2] = nums[0] + nums[1] - nums[0] + nums[2] - nums[1] = diff[0] + diff[1] + diff[2]
nums[n-1] = nums[0] + nums[1] - nums[0] + ... nums[n-1] - nums[n-2] = diff[0] + ... diff[n-1]
</code></p>

<h3>差分数组的作用</h3>

<p>差分数组的作用是能快速的对区间更新。区间更新是指对于数组nums，长度为n，想要对区间[l, r]做更新，比如都加上一个数x，或者都减去一个数y。常规的实现肯定遍历[l, r]然后对每个元素做更新，这是线性时间O(n)的，而用差分数组可以在常数时间完成区间更新。</p>

<pre><code>nums[l, r] + x = nums[l] + x, nums[l + 1] + x, ... nums[r-1] + x, nums[r] + x
                  = diff[l] + x, diff[l + 1], .... diff[r-1], diff[r], diff[r + 1] - x
                  = diff[l] + x, diff[r+1] - x
</code></pre>

<p>可以看出，只对差分数组的区间两端做加减法就可以实现原数组区间增加。当然了，如果想得出原数组的真实修改后的结果，仍需要对差分数组做前缀和才可以，因为差分数组的前缀和才是原始数组。所以，<strong>差分数组是一个辅助数组，它的作用不像前缀和那样明显，它只能配合使用，无法单独使用</strong>。（单独使用仍要用O(n)来计算前缀和才能得到原始数组，失去了意义）。</p>

<p>差分数组与前缀和通常作为辅助数组一起使用，以解决快速区间查询和区间修改，这便是树状数组，理解 了前缀和和差分数组的作用，对于理解 树状数组有很大的帮助。树状数组的具体原理与应用可以<a href="http://toughcoder.net/blog/2022/09/06/intro-to-binary-indexed-tree/">参考 这篇文章。</a></p>

<h3>差分典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/calculate-amount-paid-in-taxes/">2303. 计算应缴税款总额</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/calculate-amount-paid-in-taxes/solution/by-alexhilton-eq50/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>拓展到二维</h2>

<p>一维上能做的事情，肯定 都能拓展到二维，对于二维列表也就是说矩阵，也可以使用前缀和和差分，差分本来的应用比较有限，不像前缀和可以单独应用，并且二维差分要复杂的多得多，所以这里就讨论一下二维前缀和。</p>

<p>假设一个矩阵为matrix，尺寸是mxn，即m行n列，对于它的任意一个格子{i, j}和前缀和preSum[i, j]等于其左上部分的所有元素之和。</p>

<pre><code>preSum[0, 0] = matrix[0, 0]
preSum[0, 1] = matrix[0, 0] + matrix[0,1] = preSum[0, 0] + matrix[0, 1]
preSum[1, 0] = matrix[0, 0] + matrix[1, 0] = preSum[0, 0] + matrix[1, 0]
preSum[1, 1] = matrix[0,0] + matrix[0,1] + matrix[1,0] + matrix[1,1] = preSum[0, 1] + preSum[1, 0] + nums[1,1] - preSum[0,0]
preSum[i, j] = preSum[i-1,j] + preSum[i, j-1] + matrix[i,j] - preSum[i-1,j-1]
</code></pre>

<pre><code class="java">    private void init() {
        preSum = new int[m][n];

        if (m &lt; 1 || n &lt; 1) {
            return;
        }

        preSum[0][0] = matrix[0][0];
        preSum[1][0] = preSum[0][0] + matrix[1][0];
        preSum[0][1] = preSum[0][0] + matrix[0][1];

        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                preSum[i][j] = preSum[i][j - 1] + preSum[i - 1][j] + matrix[i][j] - preSum[i - 1][j - 1];
            }
        }
    }
</code></pre>

<h3>二维前缀和的应用</h3>

<p>与一维前缀和类似，二维前缀和的应用用于快速求出区间和，比如求子矩阵和，求[r1,c1]到[r2,c2]之间的子矩阵之和，就可以应用二维前缀和，可以从O(mn)的复杂度降到O(1)。</p>

<pre><code>sum[r1,c1]~[r2,c2] = preSum[r2,c2] - preSum[r2,c1-1] - preSum[r1-1, c2] + preSum[r1-1, c1-1]
</code></pre>

<pre><code class="java">    public int regionSum(int r1, int c1, int r2, int c2) {
        if (r1 == 0 &amp;&amp; c1 == 0) {
            return preSum[r2][c2];
        }
        return preSum[r2][c2] - preSum[r2][c1 - 1] - preSum[r1 - 1][c2] + preSum[r1 - 1][c1 - 1];
    }
</code></pre>

<p>两个坐标[r1,c1]和[r2,c2]把矩阵分成了三个区域，一是[0, 0]~[r2,c2]这就是preSum[r2,c2]，二是[0,0]~[r2,c1-1]，三是[0,0]~[r1-1,c2]，相减，多减了一个公共区域[0,0]~[r1-1,c1-1]，所以要加回来。</p>

<p><a href="https://github.com/alexhilton/EffectiveAlgorithm/blob/main/datastructure/src/main/java/AuxiliaryMatrix.java">完整代码看这里</a>。</p>

<p>前缀和与差分数组一般作为辅助数组使用，理解了它们的原理对于理解更复杂的数组结构如树状数组是非常有帮助的，<a href="http://toughcoder.net/blog/2022/09/06/intro-to-binary-indexed-tree/">关于树状数组可以参考 此文</a>。</p>

<h2>拓展到后缀和最值</h2>

<p>前缀和是最常用的一种前缀辅助数组，但并不局限于此，也可以用后缀和，视具体情况而定。</p>

<p>另外，还可以拓展到最值，就是说前缀最值（最小值最大值），或者后缀最小值最大值，也可以帮助降低复杂度。</p>

<h2>典型问题</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/my-calendar-ii/">731. 我的日程安排表 II</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/my-calendar-ii/solution/by-alexhilton-bggq/">题解</a> </td>
<td style="text-align:left;"> TreeMap当作差分数组 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/partition-array-into-disjoint-intervals/">915. 分割数组</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/partition-array-into-disjoint-intervals/solution/by-alexhilton-9eh3/">题解</a> </td>
<td style="text-align:left;"> 后缀最小值辅助数组 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/global-and-local-inversions/">775. 全局倒置与局部倒置</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/global-and-local-inversions/solution/by-alexhilton-xagt/">题解</a> </td>
<td style="text-align:left;"> 后缀最小值 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.jianshu.com/p/2a4e861b44ae">差分数组</a></li>
<li><a href="https://blog.csdn.net/qq_31601743/article/details/105352885">什么是差分数组？</a></li>
<li><a href="https://blog.csdn.net/Miracle_ps/article/details/126573360">【LeetCode】一文吃透差分数组（附例题）</a></li>
<li><a href="https://blog.csdn.net/qq_44786250/article/details/100056975">差分数组是个啥？能干啥？怎么用？（差分详解+例题）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/117569086">【朝夕的ACM笔记】算法基础-前缀和</a></li>
<li><a href="https://blog.csdn.net/qq_45914558/article/details/107385862">前缀和【超详细讲解前缀和】</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/436526162">前缀和</a></li>
<li><a href="https://juejin.cn/post/7005057884555837476">面试必会的算法题——前缀和</a></li>
<li><a href="https://juejin.cn/post/6944913393627168798">什么是前缀和?</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/107778275">前缀和技巧</a></li>
<li><a href="https://blog.csdn.net/weixin_45629285/article/details/111146240">前缀和与差分 图文并茂 超详细整理（全网最通俗易懂）</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Dijkstra Algorithm]]></title>
    <link href="http://toughcoder.net/blog/2022/09/12/understanding-dijkstra-algorithm/"/>
    <updated>2022-09-12T10:49:54+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/12/understanding-dijkstra-algorithm</id>
    <content type="html"><![CDATA[<p>最短路径问题，是图论中经常遇到的问题，对于非加权图，用广度优先搜索（BFS）就可以找到两个顶点之间的最短路径（最少边数），但对于加权图，就需要用到著名的犾克斯特拉算法（<a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra Algorithm</a>）。</p>

<p><a href=""><img src="https://www.researchgate.net/profile/Atta_Ur_Rehman14/publication/331484960/figure/fig1/AS:732550733512704@1551665113143/Illustration-of-Dijkstras-algorithm.ppm" title="auto auto" ></a></p>

<!-- more -->


<h2>思路</h2>

<p>犾克斯特拉算法的核心思想是：</p>

<ol>
<li>以起步的顶点作为<strong>当前顶点</strong></li>
<li>检查当前顶点的所有邻接顶点，计算当前顶点到所有其邻接顶点的权重，并记录下来</li>
<li>从<strong>未访问过</strong>的邻接顶点中，选择一个总权重最小的顶点，作为下一个<strong>当前顶点</strong></li>
<li>重复第3步，直到图中所有的顶点都被访问过</li>
</ol>


<p>这样就能得到起步顶点到其他所有顶点的最短路径（最小权重）。</p>

<p><img src="https://img-blog.csdnimg.cn/201902261948522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc5NTkyMQ==,size_16,color_FFFFFF,t_70" alt="" /></p>

<h2>实例</h2>

<p>前面的思路听起来还是不够清爽，我们来看一个具体的实例，比如计算不同的城市之间的飞行费用问题，就可以用Dijkstra算法来求解，一共有五个城市，以及它们之间的航班费用：</p>

<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>


<script>mermaid.initialize({startOnLoad:true});</script>


<div class="mermaid">
flowchart LR;
    A([Atlanta])
    B([Boston])
    C([Chicago])
    D([Denver])
    E([El Paso])
        A&#45;&#45; 100 &#45;&#45;>B;
    A&#45;&#45; 160 &#45;&#45;>D;    B&#45;&#45; 120 &#45;&#45;>C;    B&#45;&#45; 180 &#45;&#45;>D;    D&#45;&#45; 40 &#45;&#45;>C;
    D&#45;&#45; 140 &#45;&#45;>E;
    </div>


<p>以Atlanta为起点，来计算到其他几个城市的最小飞行费用，为方便用一个表格来展现Dijkstra算法的每一步：</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 步骤 </th>
<th style="text-align:left;"> 当前顶点 </th>
<th style="text-align:center;"> Atlanta </th>
<th style="text-align:center;"> Boston </th>
<th style="text-align:center;"> Chicago </th>
<th style="text-align:center;"> Denver </th>
<th style="text-align:center;"> El Paso </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 初始化 </td>
<td style="text-align:left;"> n/a </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:left;"> inf为正无穷，代表还未有计算的距离  </td>
</tr>
<tr>
<td style="text-align:left;"> 第1步<br/>起始顶点作为当前顶点 </td>
<td style="text-align:left;"> Atlanta </td>
<td style="text-align:center;"> 0 </td>
<td style="text-align:center;"> 100 </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:center;"> 160 </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:left;"> Atlanta能到达Boston和Denver，是邻接 的顶点 直接填权重 </td>
</tr>
<tr>
<td style="text-align:left;"> 第2步<br/>未访问顶点Boston和Denver中选择权重小的Boston </td>
<td style="text-align:left;"> Boston </td>
<td style="text-align:center;"> 0 </td>
<td style="text-align:center;"> 100 </td>
<td style="text-align:center;"> 220 </td>
<td style="text-align:center;"> 160 </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:left;"> 到Boston的费用是100，以此为基础，<br/>Boston到Chicago是120，所以起始点到Chicago的费用是220。<br/>Boston到Denver是180再加上基础100就是280，它大于Atlanta直飞Denver，所以这个放弃 </td>
</tr>
<tr>
<td style="text-align:left;"> 第3步<br/>未访问的中Denver最小，所以用Denver </td>
<td style="text-align:left;"> Denver </td>
<td style="text-align:center;"> 0 </td>
<td style="text-align:center;"> 100 </td>
<td style="text-align:center;"> 200 </td>
<td style="text-align:center;"> 160 </td>
<td style="text-align:center;"> 300 </td>
<td style="text-align:left;"> 到Denver的费用是160，以此为基础，<br/>Denver到Chicago是40，经Denver到Chicago更划算，所以到Chicago更新为200；<br/>Denver还可以到达El Paso费用是300 </td>
</tr>
<tr>
<td style="text-align:left;"> 第4步<br/>未访问的中Chicago最小，所以用Chicago </td>
<td style="text-align:left;"> Chicago </td>
<td style="text-align:center;"> 0 </td>
<td style="text-align:center;"> 100 </td>
<td style="text-align:center;"> 200 </td>
<td style="text-align:center;"> 160 </td>
<td style="text-align:center;"> 280 </td>
<td style="text-align:left;"> 到Chicago的费用是200，以此为基础，<br/>Chicago到El Paso是80，经Chicago到El Paso更划算，所以到El Paso更新为280 </td>
</tr>
<tr>
<td style="text-align:left;"> 第5步<br/>只有El Paso未访问了，所以用El Paso </td>
<td style="text-align:left;"> El Paso </td>
<td style="text-align:center;"> 0 </td>
<td style="text-align:center;"> 100 </td>
<td style="text-align:center;"> 200 </td>
<td style="text-align:center;"> 160 </td>
<td style="text-align:center;"> 280 </td>
<td style="text-align:left;"> 到El Paso的费用是280，以此为基础，<br/>El Paso到Boston是100，不划算，所以不用更新。<br/>所有顶点都访问过了，这就是Atlanta出发到所有城市的最小飞行费用 </td>
</tr>
</tbody>
</table>


<h2>实现</h2>

<p>Dijkstra算法比较复杂，它的时间空间复杂度都比较高。算法的输入是一个加树图，和一个起始顶点，输出则是一个列表，表示起始顶点到其他顶点的最短路径。</p>

<h3>实现思路</h3>

<ol>
<li>创建一个结果列表，长度是顶点数量N，尽管其实不管起始顶点，但为了方便还是加上，用以存储起始顶点到所有顶点的最小距离，列表初始化为正无穷</li>
<li>创建一个标记列表，长度是N，用以标记顶点是否访问过，在选择下一个当前节点时，以及判断算法是否结束时，都需要用到此列表</li>
<li>选择实始顶点为当前顶点</li>
<li>把当前节点加入到标记列表中</li>
<li>更新最小距离列表：以当前顶点为基础，计算到它的每个邻接顶点的距离（也即基础值加上与其邻接的边的权重），如果距离小于结果列表中的距离，就更新结果列表</li>
<li>选择下一个当前顶点：遍历结果列表，找最小值，并且还未访问过（不在标记列表里），作为下一个当前顶点</li>
<li>重复第4到第6步，直到所有顶点都已标记，这时在第6步肯定 找不到下一个当前顶点</li>
</ol>


<h3>伪代码</h3>

<p>有了前面的实现思路，就不难写出伪代码：</p>

<pre><code>creat a list with length of N distanceList, init with MAX
create a set visitedSet
currentNode = start
distanceList[start] = 0
while currentNode is not null:
    add currentNode to visitedSet

    base = distanceList[currentNode]
    for each node adjacent with currentNode:
         if node.weight + base &lt; distanceList[node]:
              distanceList[node] = node.weight + base

    min = null
    for each node in distanceList:
        if node not in visitedSet and min &gt; distanceList[node]:
              min = node;
    currentNode = min
</code></pre>

<h3>示例代码</h3>

<p>到了代码层面的实现，需要灵活选择数据结构，如果顶点可以方便的用下标来代表的话，那么就可以用数组代替列表，否则可能就要使用哈希表。这里为了方便，用下标来代表顶点：0代表Atlanta，1代表Boston，2代表Chicago，3代表Denver，4代表El Paso，这样就都可以用数组来当列表用。</p>

<p>图用矩阵来表示，每一行代表到另一个城市的费用，其实默认值可以都用0，在计算费用时就不用特殊处理了，但为了体现邻接顶点，所以没有连通的顶点用-1，自己用0，相邻的顶点才有权重。</p>

<pre><code class="java">public class DijkstraAlgorithm {
    public static int[] dijkstra(int[][] graph, int start) {
        final int n = graph.length;
        int[] distance = new int[n];
        boolean[] visited = new boolean[n];
        Arrays.fill(distance, Integer.MAX_VALUE);
        Arrays.fill(visited, false);
        distance[start] = 0;
        int current = start;
        while (current != -1) {
            // Mark as current node as visited
            visited[current] = true;

            // Update the shortest distance for the nodes adjacent with current node
            final int base = distance[current];
            int[] neighbors = graph[current];
            for (int i = 0; i &lt; n; i++) {
                if (neighbors[i] == -1) {
                    // Skip not adjacent node
                    continue;
                }
                if (base + neighbors[i] &lt; distance[i]) {
                    distance[i] = base + neighbors[i];
                }
            }

            // Pick next current node
            int min = -1;
            for (int i = 0; i &lt; n; i++) {
                if (!visited[i] &amp;&amp; (min == -1 || distance[min] &gt; distance[i])) {
                    min = i;
                }
            }

            current = min;
        }

        return distance;
    }

    public static void main(String[] args) {
        String[] cities = {"Atlanta", "Boston", "Chicago", "Denver", "El Paso"};
        int[][] graph = {
                {0, 100, -1, 160, -1},
                {-1, 0, 120, 180, -1},
                {-1, -1, 0, -1, 80},
                {-1, -1, 40, 0, 140},
                {-1, 100, -1, -1, 0},
        };
        int start = 0;
        int[] shortestPath = dijkstra(graph, start);
        IntStream.range(start + 1, graph.length)
                .mapToObj(i -&gt; "Shortest distance from " + cities[start] + " to " + cities[i] + ": " + shortestPath[i])
                .forEach(System.out::println);
    }
}
</code></pre>

<p>输出结果：</p>

<pre><code>Shortest distance from Atlanta to Boston: 100
Shortest distance from Atlanta to Chicago: 200
Shortest distance from Atlanta to Denver: 160
Shortest distance from Atlanta to El Paso: 280
</code></pre>

<h2>应用</h2>

<p>Dijkstra算法只能用于有向无环加权图（DAG），且没有负权重的情况下，才可以正常工作。并且，它的复杂度较高，如果顶点数量为n，那么它的时间复杂度会达到O(n<sup>2</sup>)。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/">Dijkstra’s Shortest Path Algorithm</a></li>
<li><a href="https://www.freecodecamp.org/news/dijkstras-shortest-path-algorithm-visual-introduction/">Dijkstra&rsquo;s Shortest Path Algorithm - A Detailed and Visual Introduction</a></li>
<li><a href="https://www.programiz.com/dsa/dijkstra-algorithm">Dijkstra&rsquo;s Algorithm</a></li>
<li><a href="https://brilliant.org/wiki/dijkstras-short-path-finder/">Dijkstra&rsquo;s Shortest Path Algorithm</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/338414118">Dijkstra算法详解 通俗易懂</a></li>
<li><a href="https://blog.csdn.net/lbperfect123/article/details/84281300">Dijkstra算法图文详解</a></li>
<li><a href="https://blog.csdn.net/qq_35644234/article/details/60870719">最短路径问题&mdash;Dijkstra算法详解</a></li>
<li><a href="https://www.cnblogs.com/dijkstra2003/p/7222182.html">Dijkstra 最短路径算法 秒懂详解</a></li>
<li><a href="https://www.cnblogs.com/goldsunshine/p/12978305.html">一篇文章讲透Dijkstra最短路径算法</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
