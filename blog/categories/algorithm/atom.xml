<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2023-08-08T22:47:03+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Hashing Hash and HashMap]]></title>
    <link href="http://toughcoder.net/blog/2023/07/13/hashing-hash-and-hashmap/"/>
    <updated>2023-07-13T23:17:13+08:00</updated>
    <id>http://toughcoder.net/blog/2023/07/13/hashing-hash-and-hashmap</id>
    <content type="html"><![CDATA[<p>哈希表(HashMap)或者叫做散列表，是非常常用的一种二维的键值对式的数据结构，用以非常高效的解决查询问题的。
其核心是Hashing，这是把一个对象映射到一个索引的过程，实现hashing的函数通常称为hash函数或者叫散列函数，基于hashing实现的数据结构称作HashMap，或者叫做散列表。</p>

<p><a href=""><img src="https://techdose.co.in/wp-content/uploads/2021/02/City-of-TL-2-1024x576.png" title="auto auto" ></a></p>

<!-- more -->


<h2><a href="https://www.techtarget.com/searchdatamanagement/definition/hashing">Hashing</a></h2>

<p><a href="https://www.educative.io/answers/what-is-hashing">哈希或者散列</a>，是一个映射的过程，把一个对象，一些值，一些数据，一个文件等等通过某些方式映射成为一个键，用这个键可以<strong>非常快速</strong>的找到对应的值，也即原数据。通常键都是以索引形式存在的，因为用索引去查找数组的元素是绝对的O(1)时间的。但，这只是哈希过程的一个普通应用实例。</p>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.LEfONm4SRcDy3upe46WUMQHaE7?pid=ImgDet&amp;rs=1" alt="" /></p>

<p>在更广泛的加密领域，哈希过程并不是为了查找，而是为了生成一种代表着原数据的签名，也就是用一个更为小巧的方便的数据（通常是字符串）作为原数据的代表，看到了签名，就认为是看到的是其原数据，当然，其实这也是一种查找过程。</p>

<p>所以，不失一般性，满足这样的关系hash(data) = key，就是一个hashing。还要注意这个过程是不可逆的，也就是不存在反函数g(key) = data，没有办法能从key逆推出data。</p>

<h2><a href="https://en.wikipedia.org/wiki/Hash_function">Hash</a></h2>

<p>通常称作Hash，Hash function，Hash algorithm，哈希函数，哈希算法或者散列函数，散列算法。是能够实现hashing的一个函数或者算法。</p>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.RKHyLYrEjVpCdQfJFUQy2AHaDq?pid=ImgDet&amp;rs=1" alt="" /></p>

<p>哈希算法是把一个对象转化为int的过程，最为常用的一种哈希方法就是用多项式乘素法，比如一个长度为n的byte数组payload，它的hash = payload[0]*P<sup>n-1</sup> + payload[1]*P<sup>n-2</sup> + &hellip; + payload[n-1]。</p>

<pre><code class="java">    // Other possible primes are: 31, 131, 1313, 13131, 131313
    public static final int P = 33;
    public static int hash(String s) {
        return hashBytes(s.toCharArray());
    }

    /*
     * Polynomial multiplication of prime:
     * hash = c[0]*P^(n-1) + c[1]*P^(n-2) + ... + s[n-1]
     */
    public static int hashBytes(char[] chars) {
        int hash = 0;
        for (char ch : chars) {
            hash = P * hash + ch;
        }

        return hash;
    }
</code></pre>

<p>像Java中的String用的就是这个算法，Prime选择可能不一样，常用的有31, 131, 1313, 13131, 131313。其他对象都可以使用此方法，因为任何对象都可以序列化为byte。可以看到hash算法没有考虑溢出，这样计算P的乘方，很快就会溢出，但是没关系，溢出会变成负数，并不影响hashing。在有些算法中会对一个很大的素数如10<sup>9</sup>+7取余，以让哈希值变得的不那么大。</p>

<p>另外，可以看出哈希算法是O(L)的，这里L是输入数据的长度，比如对于字符串来说就是字符串的长度，假如是一个很长很长很长的字符串，那么计算其hash可能会很久很久，因此当使用HashMap时，可能就会变得很慢。</p>

<h3>参考资料</h3>

<ul>
<li><a href="https://www.zhihu.com/question/20820286">什么是哈希算法？</a></li>
<li><a href="https://wingsxdu.com/posts/algorithms/cryptographic-hashing-function/">加密哈希算法的实现原理</a></li>
<li><a href="https://segmentfault.com/a/1190000021199728">图解一致性哈希算法</a></li>
<li><a href="https://www.cnblogs.com/barrywxx/p/10739871.html">经典Hash函数的实现</a></li>
<li><a href="https://houbb.github.io/2018/05/30/hash-impl">Hash 算法实现</a></li>
<li><a href="https://developer.aliyun.com/article/1012265">Hash算法详细介绍与实现(一)</a></li>
<li><a href="https://developer.aliyun.com/article/1015830">Hash 算法详细介绍与实现 (二)</a></li>
</ul>


<h2><a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">HashMap</a>/<a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashSet.html">HashSet</a></h2>

<p>基于Hashing和Hash构建出来的用于高效查询的数据结构。</p>

<p><img src="https://cdn.educba.com/academy/wp-content/uploads/2019/11/hashmap-in-java.png" alt="" /></p>

<h3>参考资料</h3>

<ul>
<li><a href="https://www.interviewcake.com/concept/java/hash-map">Data structure Hash Table</a></li>
<li><a href="https://www.geeksforgeeks.org/hashing-data-structure/">Hashing Data Structure</a></li>
<li><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html">Java 8系列之重新认识HashMap</a></li>
<li><a href="https://pdai.tech/md/java/collection/java-map-HashMap&amp;HashSet.html">Map - HashSet &amp; HashMap 源码解析</a></li>
<li><a href="https://xie.infoq.cn/article/01538faefd4816128ede4212a">了解 HashMap 数据结构，超详细！</a></li>
</ul>


<h2><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentHashMap.html">ConcurrentHashMap</a></h2>

<p>线程安全的哈希表，采用分段式读加锁的方式来提高并发效率。</p>

<h3>参考资料</h3>

<ul>
<li><a href="https://www.cnblogs.com/zerotomax/p/8687425.html">ConcurrentHashMap源码分析(1.8)</a></li>
<li><a href="https://javaguide.cn/java/collection/concurrent-hash-map-source-code.html">ConcurrentHashMap 源码分析</a></li>
<li><a href="https://juejin.cn/post/7045955943296679949">ConcurrentHashMap源码分析</a></li>
</ul>


<h2><a href="https://en.wikipedia.org/wiki/Hash_collision">哈希碰撞Hash Collision</a></h2>

<p>哈希算法针对不同的原始数据却产生了相同的键，这就是哈希碰撞，因为最理想的hashing是一一对应，同样的原始数据（也就是相等的两个对象）肯定会产生相同的键，这时我们认为数据是同一份（相等的），但不同的数据（也即不相等）却产生了相同的键，就需要进行特殊处理，这会增加复杂度。哈希碰撞是不可避免的，同时也是一个衡量指标，即好的哈希函数会产生较少的合理碰撞（也就是因为数据边界和算法能力导致的碰撞）。</p>

<p><img src="https://ts1.cn.mm.bing.net/th/id/R-C.b7b51eed3f8027b11a32e091363c26f7?rik=scKHPWTjDjuM5Q&amp;riu=http%3a%2f%2fjustinparrtech.com%2fJustinParr-Tech%2fwp-content%2fuploads%2fHashing-Passwords_Hash-Collision.png&amp;ehk=Cs%2fOrEQS48SFm8KbaMfL0mOJxPm3AfjQlJvsMeddGP4%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" /></p>

<p>哈希碰撞会降低效率和安全性，比如说服务器通常会把客户端的request先暂存起来，去异步处理，当有了response后，再找到其对应的request然后给其回复response。这一过程，一般会有哈希表来存储request。假如哈希函数选择的不好，比如用request当中的某一个String字段来作为request的Key的话，就有可能被恶意攻击。哈希表常规的效率是很高的，一旦有哈希碰撞就会变成链表复杂度会上升为O(n<sup>2</sup>)。而String的hash是容易产生碰撞，假如恶意客户端发现了是用String作为Key的，那么就可以用能产生哈希碰撞的String来生成不同的request，这样就会让服务器短时间内负载特别高而且宕机。这是一种基于哈希碰撞的古老的攻击方式。</p>

<p>所以一般服务器使用的哈希函数都是要特别设计，不能采用太普通 的哈希算法。</p>

<h3>参考资料</h3>

<ul>
<li><a href="https://www.ruanyifeng.com/blog/2018/09/hash-collision-and-birthday-attack.html">哈希碰撞与生日攻击</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1776352">HASH碰撞问题一直没真正搞懂？这下不用慌了</a></li>
<li><a href="https://segmentfault.com/a/1190000041421664">哈希理解、哈希碰撞（hash冲突）及处理</a></li>
<li><a href="https://www.baeldung.com/cs/hash-collision-weak-vs-strong-resistance">Hash Collision: Weak and Strong Resistance</a></li>
</ul>


<h2><a href="https://en.wikipedia.org/wiki/Rolling_hash">滚动哈希Rolling Hash</a></h2>

<p>是一种哈希算法，使用一个固定长度的窗口（通常远小于数据本身的长度）在数据中滑动，能以更高的效率计算出数据的哈希值（键）。通常会被用于检查文章的相似性（是否存在抄袭），查找重复的子串等。因为滚动哈希是在一个长的序列中以一个固定的窗口在计算，所以特别擅长在接近无限的序列中探测重复子序列，比如网络流模式探测，视频重复帧识别等等。</p>

<p><img src="https://www.francofernando.com/assets/img/blog/algorithms/rolling-hash/rolling-hash-1.png" alt="" /></p>

<p>一个典型的Rolling hash实现：</p>

<pre><code class="java">public static ArrayList&lt;Integer&gt; rollingHash(String payload, int window, int p, int mod) {
        final int n = payload.length();
        ArrayList&lt;Integer&gt; hashValues = new ArrayList&lt;&gt;(n - window + 1);
        int power = 1;
        for (int i = 0; i &lt; window - 1; i++) {
            power *= p;
            power %= mod;
        }

        int hash = 0;
        for (int i = 0; i &lt; window; i++) {
            hash = (hash * p + payload.charAt(i)) % mod;
        }
        hashValues.add(hash);

        for (int i = 1; i &lt; n - window + 1; i++) {
            hash = (hash - power * payload.charAt(i - 1)) % mod;
            hash = (hash * p + payload.charAt(i + window - 1)) % mod;
            hashValues.add(hash);
        }

        return hashValues;
    }

    public static void main(String[] args) {
        String payload = "abcabcabc";
        int window = 3;
        ArrayList&lt;Integer&gt; hashes = rollingHash(payload, window, 31, MOD);
        System.out.println("Rolling hash of " + payload + ", window size " + window);
        IntStream.range(0, hashes.size())
                .mapToObj(i -&gt; i + "-&gt;" + payload.substring(i, i + window) + " whose hash is " + hashes.get(i))
                .forEach(System.out::println);
    }
    // outputs
    //Rolling hash of abcabcabc, window size 3
    //0-&gt;abc whose hash is 96354
    //1-&gt;bca whose hash is 97344
    //2-&gt;cab whose hash is 98244
    //3-&gt;abc whose hash is 96354
    //4-&gt;bca whose hash is 97344
    //5-&gt;cab whose hash is 98244
    //6-&gt;abc whose hash is 96354
</code></pre>

<p>可以看出，字符串是&#8221;abcabcabc&#8221;，有三个重复子串，Rolling hash能清查的找到，看Rolling hash输出中的0，3和6个元素（即子串&#8221;abc&#8221;），另外两个重复子串&#8221;bca&#8221;，是1和4，以及&#8221;cab&#8221;，是2和5。</p>

<p>Rolling hash是O(n)的，每个子串的比较都是O(1)，是相当高效的算法，是用于解决子串查找，重复子串查找的利器。</p>

<h3>参考资料</h3>

<ul>
<li><a href="https://www.geeksforgeeks.org/introduction-to-rolling-hash-data-structures-and-algorithms/">Introduction to Rolling Hash – Data Structures and Algorithms</a></li>
<li><a href="https://juejin.cn/post/7180323231918882874">(Rabin-Karp算法)匹配字符串（滚动哈希）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/564537288">滚动哈希（Rolling Hash）</a></li>
<li><a href="https://www.cnblogs.com/sunchi/p/13632779.html">滚动hash实现字符串匹配</a></li>
</ul>


<h3>典型问题</h3>

<p>哈希表作为一种极基础的数据结构，提供以O(1)时间查询的能力，所以是刷题当中最为常用的辅助数据结构，没有之一。但其实HashMap/HashSet并不 真的O(1)，它只是摊还分析的时间复杂度能到O(1)，但真实的运行效率不可能达到O(1)，一旦发生哈希碰撞就会上升到O(n<sup>2</sup>)。并且还有扩容和自动装箱autobox等隐形开销，hash函数本身也有开销一般是O(L)的，所以HashMap真实的运行效率并不高。</p>

<p>但哈希表是一种hashing的实现，更为重要的是体现了hashing的映射思想。所以，在有些时候虽然用到了哈希表，但不一定要用HashMap。比如像英文字母到索引的映射，以及数据范围不大的自然数到索引的映射，这本质上也是hashing，但用数组就可以了，并且这是真正的O(1)。</p>

<p>哈希表一般当作基础设施来使用，所以没有专门的题，关于哈希的题目一般都是滚动哈希的，并且难度都不小。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/repeated-dna-sequences/solution/187-zhong-fu-de-dnaxu-lie-by-alexhilton-5or9/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304227729113121">哈希算法</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[TopK问题，堆和快速选择]]></title>
    <link href="http://toughcoder.net/blog/2023/07/11/topk/"/>
    <updated>2023-07-11T22:35:15+08:00</updated>
    <id>http://toughcoder.net/blog/2023/07/11/topk</id>
    <content type="html"><![CDATA[<p>TopK问题是很常见的一种问题，它的描述是从一个数据集或者序列中取出前k大（或者前k小），或者说找出第k大（第k小）。最为典型的就是 <a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/215-shu-zu-zhong-de-di-kge-zui-da-yuan-s-0lm6/">题215. 数组中的第K个最大元素</a>。解决TopK需要的是最基础的数据结构和算法，不但可以考查编码基本功，更能考查思维能力。</p>

<p><a href=""><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.2aULRows_3CiTGr1IQamzgHaE-?pid=ImgDet&amp;rs=1" title="auto auto" ></a></p>

<!-- more -->


<p>为了方便，后面就以找前k大为主要示例：输入长度为n的整数数组，找出前k大的数，1 &lt;= k &lt;= n。</p>

<h2>排序大法</h2>

<p>解决TopK问题，最简单也是最为暴力的做法就是排序，如果数据是有序的，无论你想找前k大或者第k大，都是非常容易的了。</p>

<p><img src="https://programs.wiki/images/wiki/01f03444af1b72507fd4d18f22f94d67.jpg" alt="" /></p>

<p>问题就转化为排序问题了，至于排序有O(n<sup>2</sup>)的冒泡，选择和插入， 以及高效一些的归并和快速排序。如果是特殊数据集还可以用计数排序（也叫桶排序）。关于排序算法的教程太多了，就不重复了，可以参考Yu神的 <a href="https://leetcode.cn/circle/discuss/eBo9UB/">十大排序从入门到入赘</a>。</p>

<p>用排序来解决TopK问题可行但并不高效，比如k特别小时，n特别大时效率就会特别差。甚至，对于序列（也就是输入数据接近无限）时，可能没有办法先排序再去选择前k大了。</p>

<h2>堆<a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">Heap</a></h2>

<p>堆是一个逻辑上的二叉树式的数据结构，但实现上通常用数组来实现，它保证根节点是所有元素中最大的称作最大堆或者大根堆，或者最小的称作最小堆或者小根堆。有些地方也称之为优先队列，比如在大Java中的就叫做<a href="https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html">PriorityQueue</a>。</p>

<p><img src="https://www.cdn.geeksforgeeks.org/wp-content/uploads/MinHeapAndMaxHeap.png" alt="" /></p>

<p>以最大堆为例，它保证根节点永远不小于两个子节点，假如堆的大小（也即元素总数）是k，那么根节点就是这k个元素中的最大值，维护一次堆（Heapify）的代价是log(k)，只需要不断的比较根节点和子节点即可，所以复杂度是二叉树的高度即log(k)。对于TopK问题，可以创建一个大小为k的最小堆，把n个数都填到堆里，当堆未满时，直接塞，如果满时了，堆顶是最小值，如果新元素小于最小值可直接跳过，它不可能成为TopK；否则先移除堆顶然后再塞，最后堆里面剩下的就是前k大元素，这样复杂度会降到nlog(k)，当n特别大，k远小于n时，或者说对n接近无穷的序列时，用最小堆的效率会明显的高于排序大法。</p>

<p><img src="https://programs.wiki/images/wiki/219e46ebbe75d147a8f2d508a9b1890a.jpg" alt="" /></p>

<p>堆（优先队列）是一种非常常见且基础的数据结构，标准库中都有，可以拿来就用，但是学习手撸一个堆更能加深理解。</p>

<h3>堆的实现</h3>

<p>来手撸一个最大堆。最常见的就是二叉堆，也就是说逻辑上是一个二叉树，但实际的存储一般是用数组，索引0就是根节点root（又叫堆顶），索引i它的左子节点是在索引2*i+1，右子节点是在2*i+2。</p>

<p>需要不断的<strong>维护堆的特性</strong>，也即是它的<strong>根节点总是大于两个子节点</strong>，要时刻保持这种性质。主要难点在于向堆中添加一个元素时，先把此元素放在数组最后，也即树中最右下的叶子节点，然后不断的向上更新：如果此元素大于其父节点，就互换直到它小于其父节点。</p>

<p>另外需要维护的地方就是移除堆顶，堆顶是堆中的最大元素，它大于其两个子节点。大哥没了，就要重新选大哥：因为逻辑上是一个二叉树，所以只需要解决一个最小的树即可，其余可以递归处理。从父节点，左子节点和右子节点中取最大的，与父节点互换，然后再递归处理刚刚转换过的子树，即可。</p>

<p>废话这么多，其实代码比较精简，也较容易理解，还是直接上代码吧：</p>

<pre><code class="java">/**
 * A bound Max Heap of int type elements.
 * This is a binary heap with array as the underlying container.
 */
public class MaxHeap {
    public static final int INF = Integer.MAX_VALUE;

    private final int capacity;
    private int size;
    /*
     * Put the elements into an array, but the logical relationship is a binary tree.
     * 0 is the root;
     * i's left child is 2*i + 1, right child is 2*i + 2;
     * i's parent is (i-1) / 2.
     */
    private final int[] elements;

    public MaxHeap(int capacity) {
        this.capacity = capacity;
        size = 0;
        elements = new int[capacity];
    }

    /**
     * Nothing happens if heap is full.
     */
    public void offer(int e) {
        if (isFull()) {
            // Overflowed.
            return;
        }
        /*
         * Put the new element at the end of the heap.
         * Push it up until it is less than its parent.
         */
        size++;
        int i = size - 1;
        elements[i] = e;

        while (i != 0 &amp;&amp; elements[parent(i)] &lt; elements[i]) {
            swap(i, parent(i));
            i = parent(i);
        }
    }

    public int heapSize() {
        return size;
    }

    public int peek() {
        if (isEmpty()) {
            return INF;
        }
        return elements[0];
    }

    public void clear() {
        size = 0;
    }

    public int poll() {
        if (isEmpty()) {
            return INF;
        }
        if (size == 1) {
            size--;
            return elements[0];
        }

        /*
         * Root is the max value in the heap, will remove and return it to caller.
         * Push down the tree and select the max of left and right as the new parent.
         */
        int root = elements[0];
        elements[0] = elements[size - 1];
        size--;
        heapify(0);
        return root;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean isFull() {
        return size == capacity;
    }

    /*
     * Heapify the sub-tree rooted with index i.
     * Find the largest value of parent, left and right;
     * If the parent is the largest, we are done.
     * Swap parent with the largest node, now parent is the largest;
     * Keep heapifying the swapped sub-tree.
     */
    private void heapify(int i) {
        int l = left(i);
        int r = right(i);
        int largest = i;
        if (l &lt; size &amp;&amp; elements[l] &gt; elements[i]) {
            largest = l;
        }
        if (r &lt; size &amp;&amp; elements[r] &gt; elements[largest]) {
            largest = r;
        }
        if (largest != i) {
            swap(i, largest);
            heapify(largest);
        }
    }

    private void swap(int i, int j) {
        if (i == j) {
            return;
        }
        int t = elements[i];
        elements[i] = elements[j];
        elements[j] = t;
    }

    private int parent(int i) {
        return (i - 1) / 2;
    }

    private int left(int i) {
        return (i &lt;&lt; 1) + 1;
    }

    private int right(int i) {
        return (i &lt;&lt; 1) + 2;
    }
}
</code></pre>

<p>完整<a href="https://github.com/alexhilton/EffectiveAlgorithm/blob/main/datastructure/src/main/java/MaxHeap.java">代码在这里</a>。</p>

<p>这就是最基础的一种二叉堆(Binary Heap)的实现。注意基础堆是用于快速找最大值或者最小值，是O(1)的，其他的操作如查询非最大值或者最小值，或者移除某个特定的元素，效率差会变成O(n)的。</p>

<p>为此，还有其他的实现方式如<a href="https://brilliant.org/wiki/binomial-heap/">Binomial Heap</a>和<a href="https://brilliant.org/wiki/fibonacci-heap/">Fibonacci Heap</a>，这两种堆除了保证堆的基本特质外，还能把其他的操作也降低到log(n)的复杂度。</p>

<h3>堆的应用</h3>

<p>一是用来排序，通常称作堆排序，把n个元素都入堆，然后依次把堆顶取出来，这样就能得到一个有序数组了。复杂度是nlog(n)。</p>

<p>另外，就是用于解决topK问题了。更为实际一点的应用就是Job Scheduling，把一坨Job加入堆中，每次取堆顶（优先级最高的Job）来执行。</p>

<h2><a href="https://en.wikipedia.org/wiki/Quickselect">Quick select</a></h2>

<p>快速选择是快速排序衍生出来的一个算法，专门适用以线性复杂度O(n)来解决TopK问题。为此我们先复习快速排序算法，然后再解释快速选择原理。</p>

<p><img src="https://image3.slideserve.com/6106968/quick-select-visualization-l.jpg" alt="" /></p>

<h3>快速排序</h3>

<p>这是一个非常经典又基础的算法，是算法入门的必讲算法。快速排序的<strong>核心思想是分治</strong>(Divide and Conquer)，核心技巧是<strong>分区(partition)</strong>，选取一个<strong>轴元素作为分界点(pivot)</strong>，把<strong>小于轴的元素</strong>都放在它<strong>左边</strong>，把<strong>大于它的元素</strong>都放在其<strong>右边</strong>，然后再用同样的方法处理左边和右边。伪码如下：</p>

<pre><code class="java">void quickSort(int[] arr, int start, int end) {
    if (start == end) return
    int p = partition(arr, start, end);
    quickSort(arr, start, p-1);
    quickSort(arr, p, end);
}
</code></pre>

<h3>分区</h3>

<p>分区partition是快排的核心技巧，当然也是快速选择的核心，它是先选出一个轴元素pivot，然后以它为界把数组分成两段。比如说数组arr = [5,3,7,1,8,2,9,4]。如果选择索引位置0，元素5作为pivot，那么partition之后的数组会变为arr=[3,1,2,4,5,7,8,9]，partition的返回值，是pivot元素在分区之后的新索引p，即此例中的索引4。可以看出经过partition后，数组左区[0,p-1]都是小于pivot的，而右区[p,n-1]则是大于等于pivot的。这就是分区的作用。</p>

<p>分区算法轴元素的选择至关重要，为了达到最好的效果，在区间内随机选择一个索引位置的元素作为pivot是最理想的，摊还分析后可以达到O(n)。快排的复杂则是nlog(n)。</p>

<p>对于数组arr，做partition的具体做法是：</p>

<ol>
<li>随机选择一个元素为轴元素，记其索引为pivot</li>
<li>先把pivot与最后一个元素交换swap(arr, pivot, end)，注意交换后轴元素在end，即arr[end]</li>
<li>用双指针，左指针left总是指针向小于轴元素arr[end]的最后一个元素，也即分区好了时的左边界的最后一个位置。</li>
<li>右指针right则从start开始，遍历到end - 1，如果arr[right]小于轴，即arr[right]&lt;arr[end]，则交换并更新左指针</li>
<li>最后left索引即是轴应该在的索引，与轴交换swap(arr, left, end)</li>
<li>返回left。这是分区后的轴所在的位置。</li>
</ol>


<p>代码如下：</p>

<pre><code class="java">    private int partition(Random random, int[] nums, int start, int end) {        int pivot = random.nextInt(end - start + 1) + start;        swap(nums, pivot, end);        int left = start - 1;        for (int right = start; right &lt; end; right++) {            if (nums[right] &lt; nums[end]) {                left++;                swap(nums, left, right);            }        }        left++;        swap(nums, left, end);        return left;    }
</code></pre>

<p>记住，<strong>分区返回一个轴的索引，轴左边的元素都小于轴，轴右边的元素都大于轴</strong>。这是快速排序和快速选择的核心奥妙精华所在。</p>

<h3>快速选择</h3>

<p>基于分区就能开发出快速选择算法。对于长度为n的数组arr，进行partition后，得到一个轴的位置pivot，[0,pivot-1]都小于arr[pivot]，而[pivot+1,n-1]都大于arr[pivot]。那么，对于想找出前k大的TopK问题而方，如果pivot=n-k，那么[pivot, n - 1]分区后的右边部分不就刚好前k大元素么？</p>

<p>有同学举手问了，咋可能那么巧嘛。这位同学请先坐下，不巧也没关系，如果pivot大于n-k，说明比pivot大的数不够k个，就得往左找，所以在左部分递归处理就可以了；同理，如果pivot小于n-k，说明右部分太多了，往右找即可。代码大概这样子的：</p>

<pre><code class="java">    public int findKthLargest(int[] nums, int k) {        Random random = new Random();        int target = nums.length - k;        int start = 0;        int end = nums.length - 1;        int index = partition(random, nums, start, end);        while (index != target) {            if (index &gt; target) {                end = index - 1;            } else {                start = index + 1;            }            index = partition(random, nums, start, end);        }        return nums[index];    }
</code></pre>

<p>这是迭代式的，看起来可能不那么直观，我们用递归来写，就相当直观了：</p>

<pre><code class="java">int quickSelect(arr, start, end, k) {
    if (start == end) {
         return start;
    }
    int p = partition(arr, start, end);
    if (p == n - k) {
        return p;
    } else if (p &lt; n - k) {
        return quickSelect(arr, p + 1, end, k);
    } else {
        return quickSelect(arr, start, p - 1, k - p);
    }
}
</code></pre>

<h2>总结</h2>

<p>TopK问题是非常常见且基础的一个问题，通常是融合在了其他问题里面，不会以比较直观的方式求TopK。如果是问题中的一个子问题，那么通常用堆来当作辅助数据结构是最优的做法。如果TopK问题是最问题的最后一步的话，那么排序或者用快速选择也是可以的。</p>

<h2>典型问题</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solution/215-shu-zu-zhong-de-di-kge-zui-da-yuan-s-0lm6/">题解</a> </td>
<td style="text-align:left;"> 典型TopK问题 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并 K 个升序链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-k-sorted-lists/solution/by-alexhilton-zctb/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sliding-window-maximum/solution/239-hua-dong-chuang-kou-zui-da-zhi-xian-fwypk/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/top-k-frequent-elements/solution/by-alexhilton-xhxc/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/k-closest-points-to-origin/">973. 最接近原点的 K 个点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/k-closest-points-to-origin/solution/xi-you-yuan-su-973-zui-jie-jin-yuan-dian-xtze/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/wiggle-sort-ii/">324. 摆动排序 II</a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/heap-data-structure/">Heap Data Structure</a></li>
<li><a href="https://www.programiz.com/dsa/heap-data-structure">Heap Data Structure</a></li>
<li><a href="https://blog.csdn.net/guoweimelon/article/details/50904346">堆树（最大堆、最小堆）详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/362129090">数据结构之最大堆</a></li>
<li><a href="https://www.geeksforgeeks.org/quickselect-algorithm/">Quickselect Algorithm</a></li>
<li><a href="https://aticleworld.com/quickselect-algorithm/">Quickselect Algorithm: Quick Select Algorithm With Example Code</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/64627590">Top K 问题的最优解 - 快速选择算法（Quickselect）</a></li>
<li><a href="https://nicodechal.github.io/2020/01/12/quick-sort-and-quick-selection/">快速排序 ( QuickSort ) 和快速选择 ( QuickSelection )</a></li>
<li><a href="https://juejin.cn/post/6844903774004183047">算法必学：经典的 Top K 问题</a></li>
<li><a href="https://segmentfault.com/a/1190000041127350">面试被问TopK问题，可以这样优雅的解答</a></li>
<li><a href="https://blog.csdn.net/z50L2O08e2u4afToR9A/article/details/82837278">拜托，面试别再问我TopK了！！！</a></li>
<li><a href="https://leetcode.cn/circle/discuss/eBo9UB/">十大排序从入门到入赘</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DFS in Depth]]></title>
    <link href="http://toughcoder.net/blog/2023/06/15/dfs-in-depth/"/>
    <updated>2023-06-15T21:56:31+08:00</updated>
    <id>http://toughcoder.net/blog/2023/06/15/dfs-in-depth</id>
    <content type="html"><![CDATA[<p><a href="http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy/">前面一篇文章</a>讲解了<a href="https://en.wikipedia.org/wiki/Depth-first_search">DFS</a>的基本概念和基础的使用方法，但不够深入，DFS的应用是很广泛的，不论是枚举状态或者路径，还是递归，其本质上都是DFS。今天就来好好的理解一下DFS的内在本质，并学会在树，在图以及在回溯中的应用。</p>

<p><a href=""><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.kOp9h97z5AGxyxs-q2u_8AHaHP?pid=ImgDet&amp;rs=1" title="auto auto" ></a></p>

<!-- more -->


<h2>回顾DFS</h2>

<p>深度优先搜索，是指沿着某一路径方向，一直遍历到叶子节点为止，然后再回到初始顶点，换个方向继续。</p>

<p><img src="https://image4.slideserve.com/8160117/dfs-pseudocode-l.jpg" alt="" /></p>

<p>这里就不过多的重复了，因为在<a href="http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy/">前一篇文章</a>里面已经讲过了，看那篇文章就好。</p>

<p>注意<strong>理解DFS的本质</strong>，DFS的本质就是<strong>递归</strong>，因此用递归式的DFS效率是最高的，如果是迭代式则要借助栈，伪码参见<a href="http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy/">前一篇文章</a>。</p>

<h2>DFS树的遍历</h2>

<p>树的常规遍历，涉及路径的问题，如查找 某一个路径，或者查找所有的路径都非常适合用DFS，效率也非常的高。</p>

<p>对于涉及树的层序的时候，如果是寻找层级内的某种状态，如层和，层最大值层最小值等，也是可以用DFS的。这方面可以参考<a href="http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy/">前面的文章</a>，以及关于<a href="http://toughcoder.net/blog/2022/08/18/binary-tree-made-easy/">二叉树的文章</a>。</p>

<h2>路径问题</h2>

<p>寻找特定的路径，或者枚举所有可能的路径就非常适合用DFS来求解。这其实是回溯算法，回溯其实就是用递归来枚举所有状态，这也是DFS的本质。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/all-paths-from-source-to-target/description/">797. 所有可能的路径</a> </td>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/all-paths-from-source-to-target/solutions/1951745/797-suo-you-ke-neng-de-lu-jing-by-alexhi-70xm/">题解</a>  </td>
<td style="text-align:left;">   </td>
</tr>
<tr>
<td style="text-align:left;">  <a href=""></a> </td>
<td style="text-align:left;">  <a href="">题解</a>  </td>
<td style="text-align:left;">   </td>
</tr>
<tr>
<td style="text-align:left;">  <a href=""></a> </td>
<td style="text-align:left;">  <a href="">题解</a>  </td>
<td style="text-align:left;">   </td>
</tr>
<tr>
<td style="text-align:left;">  <a href=""></a> </td>
<td style="text-align:left;">  <a href="">题解</a>  </td>
<td style="text-align:left;">   </td>
</tr>
</tbody>
</table>


<h2>图的遍历</h2>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/flood-fill/description/">733. 图像渲染</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/flood-fill/solutions/1788931/733-tu-xiang-xuan-ran-by-alexhilton-mem7/">题解</a> </td>
<td style="text-align:left;">  </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-islands/solutions/1636556/200-dao-yu-shu-liang-by-alexhilton-cexx/">题解</a> </td>
<td style="text-align:left;">  </td>
</tr>
<tr>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a> </td>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/max-area-of-island/solutions/1786740/by-alexhilton-9eby/">题解</a>  </td>
<td style="text-align:left;">   </td>
</tr>
</tbody>
</table>


<h2>有返回值的DFS</h2>

<p>有返回值的情况略为复杂，常规的DFS，特别是递归式，只以标记当成返回结果的，函数本身并没有返回值，但有时候光做标记还不够，还需要额外的信息作为是否有解的判断，这时就需要额外的返回值，通常用dfs函数的返回值作为判断。</p>

<p>写返回值时就要小心一些，当超过边界了，或者确定无解的情况下时<strong>返回无解状态（如false）</strong>，DFS过程中已标记过了的地方直接返回有解（如true），然后<strong>递归 调用，并把递归 的所有结果合并起来当作 返回值</strong>。这里特别要注意的是要把下一步都递归了，再合并结果，因为DFS除了有返回值外，它还会做标记，如果简单的进行与，会因为<strong>布尔操作符的short-circuit</strong>原因导致某些分支没走下去，最后的标记状态肯定就不对。</p>

<pre><code class="kotlin">    private fun dfs(g: Array&lt;IntArray&gt;, i: Int, j: Int): Boolean {
        if (i &lt; 0 || i &gt;= g.size || j &lt; 0 || j &gt;= g[0].size) {
            return false
        }

        if (g[i][j] == 1) {
            return true
        }
        g[i][j] = 1

        val n = dfs(g, i - 1, j)
        val w = dfs(g, i, j - 1)
        val s = dfs(g, i + 1, j)
        val e = dfs(g, i, j + 1)
        return n &amp;&amp; w &amp;&amp; s &amp;&amp; e
    }
</code></pre>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/number-of-closed-islands/">1254. 统计封闭岛屿的数目</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-closed-islands/solutions/2290858/xi-you-yuan-su-1254-tong-ji-feng-bi-dao-5e98a/">题解</a> </td>
<td style="text-align:left;">   </td>
</tr>
<tr>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/number-of-enclaves/">1020. 飞地的数量</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-enclaves/solutions/2292106/xi-you-yuan-su-1020-fei-di-de-shu-liang-gawj8/">题解</a> </td>
<td style="text-align:left;">  </td>
</tr>
<tr>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/count-sub-islands/description/">1905. 统计子岛屿</a> </td>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/count-sub-islands/solutions/2292277/xi-you-yuan-su-1905-tong-ji-zi-dao-yu-bf-ws6r/">题解</a>  </td>
<td style="text-align:left;">   </td>
</tr>
</tbody>
</table>


<h2>着色法DFS</h2>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/find-eventual-safe-states/description/">802. 找到最终的安全状态</a> </td>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/find-eventual-safe-states/solutions/916155/zhao-dao-zui-zhong-de-an-quan-zhuang-tai-yzfz/">题解</a>  </td>
<td style="text-align:left;">   </td>
</tr>
<tr>
<td style="text-align:left;">  <a href=""></a> </td>
<td style="text-align:left;">  <a href="">题解</a>  </td>
<td style="text-align:left;">   </td>
</tr>
<tr>
<td style="text-align:left;">  <a href=""></a> </td>
<td style="text-align:left;">  <a href="">题解</a>  </td>
<td style="text-align:left;">   </td>
</tr>
</tbody>
</table>


<h2>枚举+DFS（回溯）</h2>

<p>如前所述，DFS的本质就是枚举所有状态，这其实也是回溯算法的核心所在，关于回溯可以<a href="http://toughcoder.net/blog/2022/09/04/backtracking-algorithm-explained/">参考另外的文章</a>。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/water-and-jug-problem/description/">365. 水壶问题</a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> 建模是难点，如何定义状态 </td>
</tr>
<tr>
<td style="text-align:left;">  <a href=""></a> </td>
<td style="text-align:left;">  <a href="">题解</a>  </td>
<td style="text-align:left;">   </td>
</tr>
<tr>
<td style="text-align:left;">  <a href=""></a> </td>
<td style="text-align:left;">  <a href="">题解</a>  </td>
<td style="text-align:left;">   </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.javatpoint.com/depth-first-search-algorithm">DFS (Depth First Search) algorithm</a></li>
<li><a href="https://www.simplilearn.com/tutorials/data-structure-tutorial/dfs-algorithm">Learn Depth-First Search(DFS) Algorithm From Scratch</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BFS in Graph Made Easy]]></title>
    <link href="http://toughcoder.net/blog/2023/06/14/graph-bfs-made-easy/"/>
    <updated>2023-06-14T23:07:20+08:00</updated>
    <id>http://toughcoder.net/blog/2023/06/14/graph-bfs-made-easy</id>
    <content type="html"><![CDATA[<p><a href="http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy/">前面一篇文章</a>讲解过BFS和DFS的基本概念常见用法，今天专注于图论中的BFS，来深入的探讨一下BFS在图论的搜索中的应用，并总结相关解题技巧。</p>

<p><a href=""><img src="https://tutorialhorizon.com/static/media/algorithms/2015/05/Graph-BFS.gif" title="auto auto" ></a></p>

<!-- more -->


<p>本文假定已经熟知图论的基本知识，比如图的表示方式和一些基本概念等，如不熟悉可以<a href="http://toughcoder.net/blog/2022/09/08/graph-data-structure-made-easy/">参考此文</a>。</p>

<h2>基础（单源）BFS</h2>

<p>基础的BFS通常是单源的，也就是以某一个顶点为起点。借助队列(FIFO先入先出队列)，把起点入队，然后不断的从队出取出顶点，访问与其连通的顶点，直到队列为空。为了防止重复遍历，需要在遍历过程中做标记。因为这个比较基础，我们在<a href="http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy/">前一篇文章</a>中已有伪码，所以这里就不再重复了。</p>

<p>这是最基础的BFS，当然 也是最重要的，因为更为复杂的玩法也是基于此的，因此要烂熟于心，有一些板子题，可以时常拿出来复习一下：</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-islands/solution/200-dao-yu-shu-liang-by-alexhilton-cexx/">题解</a> </td>
<td style="text-align:left;"> 邻接矩阵，矩阵式基础BFS板子题 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/max-area-of-island/solution/by-alexhilton-9eby/">题解</a> </td>
<td style="text-align:left;"> 邻接矩阵，矩阵式基础BFS板子题 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/flood-fill/">733. 图像渲染</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/flood-fill/solution/733-tu-xiang-xuan-ran-by-alexhilton-mem7/">题解</a> </td>
<td style="text-align:left;"> 邻接矩阵，矩阵式基础BFS板子题 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/count-sub-islands/description/">1905. 统计子岛屿</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/count-sub-islands/solutions/2292277/xi-you-yuan-su-1905-tong-ji-zi-dao-yu-bf-ws6r/">题解</a> </td>
<td style="text-align:left;">  邻接矩阵，矩阵式基础BFS板子题 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/description/">1466. 重新规划路线</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/solutions/2301538/xi-you-yuan-su-1466-zhong-xin-gui-hua-lu-juiu/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/keys-and-rooms/description/">841. 钥匙和房间</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/keys-and-rooms/solutions/2193103/xi-you-yuan-su-841-yao-chi-he-fang-jian-hcqfy/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>多方向邻接</h2>

<p>对于矩阵来说一般的邻接是四个方向，上下左右，但有时斜角也算邻接，这就有了八个方向，整体遍历的套路不变，只不过在找邻接顶点时要考虑八个方向。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/">1091. 二进制矩阵中的最短路径</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/solution/xi-you-yuan-su-1091-er-jin-zhi-ju-zhen-z-gxba/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/pond-sizes-lcci/">面试题 16.19. 水域大小</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/pond-sizes-lcci/solution/xi-you-yuan-su-mian-shi-ti-1619-shui-yu-m0azj/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2><a href="https://mathworld.wolfram.com/BipartiteGraph.html">二分图判定</a>之着色法BFS</h2>

<p>先要讲下<strong><a href="https://en.wikipedia.org/wiki/Bipartite_graph">二分图</a></strong>的定义：对于图中的<strong>任意两顶点u和v</strong>，如果它们有一条边<strong>直接相连</strong>，那么u和v必须<strong>属于不同的集合</strong>。更为学术一点的说法是：如果能将一个图的顶点集合分割为两个独立的子集A和B，并使略中的每一条边的两个节点一个来自于A集合，一个来自于B集合，就将这个图称为<strong>二分图</strong>。</p>

<p><img src="https://www.researchgate.net/profile/Ehdieh_Khaledian/publication/327213774/figure/download/fig1/AS:671177970294792@1537032706486/a-Example-showing-the-bipartite-graph-of-the-organism-cluster-relationship-Left-side.ppm" alt="" /></p>

<p>有些题目，并不会这么直接的告诉你这是一个判定二分图，而且会做一些信息隐藏，一般而言，如果 涉及把一个图的顶点进行归类，只分为两类，并且有边直连的顶点要归在不同的类别中，那么这就是一个二分图判定问题，比如题886，给你的是某人不喜欢的一群人，显然有边连接的顶点要归属于不同的集合，那么这就是一个二分图判定题。</p>

<p>可以用着色法BFS来判定二分图，大概的算法流程如下：</p>

<ol>
<li>用一个与顶点集合一样大的整数数组（或者其他结构）用作颜色标记，0是未着色（也就是还未访问），1着成红色，2着成绿色</li>
<li>任选一个顶点作为起点，着色为1（红色），加入队列，开始BFS</li>
<li>当队列不为空时，取出当前顶点u，遍历与u直连的顶点v，如果v还未着色，则把它加入队列，并着为3-color[u]；如果v已着色，且与color[u]着色一样，则说明不是二分图，返回F并终止遍历；</li>
<li>重复3直到队列为空，说明可以把所有顶点着为不同的色，也即是二分图，返回T</li>
</ol>


<p>伪码如下：</p>

<pre><code class="python3">start = 0
color = [0] * n
queue = deque()
queue.add(start)
color[start] = 1
while len(queue) &gt; 0:
    u = queue.popleft()
    for v in graph[u]:
        if color[v] == 0:
            color[v] = 3 - color[u]
            queue.add(v)
        elif color[v] == color[u]:
            return False
return True
</code></pre>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/is-graph-bipartite/description/">785. 判断二分图</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/is-graph-bipartite/solutions/2306267/xi-you-yuan-su-785-pan-duan-er-fen-tu-zh-mmdh/">题解</a> </td>
<td style="text-align:left;"> 二分图判定板子题 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/possible-bipartition/">886. 可能的二分法</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/possible-bipartition/solution/886-ke-neng-de-er-fen-fa-by-alexhilton-5au7/">题解</a> </td>
<td style="text-align:left;">  二分图判定模板题  </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><strong>注意</strong>：二分图是把图的顶点进行分类到不同的集合，这是并查集最为擅长的应用场景，因此用并查集解决二分图判定更为高效和优雅。关于<a href="http://toughcoder.net/blog/2022/09/08/disjoint-set-data-structure/">并查集可以参考此文</a>。</p>

<h2>多源BFS</h2>

<p>基础的BFS<strong>只有一个起点</strong>，把图中的<strong>某一个顶点</strong>最先放入队列，然后开始BFS。但有些场景，以单个顶点为起点不能解决问题。这类问题的特点一般是求某一类顶点的极值，比如0-1矩阵中，求0最近的1，或者求1最近的0。这里的要点在于说单个顶点通过BFS找到的值并不一定是全局最优解。而如果以每个顶点都做一遍BFS又会导致复杂度太高，不但复杂度超高，而且有时候会难以编码（大致的思路是有的，但难以转化为具体的代码）。这时就要用到更为复杂一些的多源BFS来求解。</p>

<p>需要应用多源BFS题目的特点是与<strong>多个顶点相关</strong>，并求一个<strong>全局最优解</strong>，也就是说求<strong>顶点集合</strong>到另一个<strong>顶点集合</strong>的距离或者路径长度。有时候我们还需要运用逆向思维，反向思考，以使问题简化，比如虽然题目求0到1的距离，但如果反着去计算1到0的距离，反倒更为方便一些，那么就需要把顶点集合反一下。</p>

<p>多源BFS的套路：</p>

<ol>
<li>依据题目信息，看是否要把顶点集互换一下，大部分的题目是需要互换的</li>
<li>把点集都加入到队列中，同时入队的还有一个初始状态，比如求最短路径，可以把MAX_INTEGER加进去</li>
<li>以这些点集为起始，去做BFS，同时更新状态，这与常规BFS就一样了</li>
<li>为了防止重复遍历也是要做标记的，这与常规BFS一样，可以用步骤3里面与顶点一起入队的状态来当作标记，比如是MAX_INTEGER时肯定是还未访问到，是其他值时说明已访问过了</li>
<li>遍历过程中，可以求得全局最优解</li>
</ol>


<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/01-matrix/description/">542. 01 矩阵</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/01-matrix/solutions/1790257/by-alexhilton-ngwy/">题解</a> </td>
<td style="text-align:left;"> 点集互换，多源BFS模板题，多源最短路径 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-bridge/description/">934. 最短的桥</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-bridge/solutions/1922745/934-zui-duan-de-qiao-by-alexhilton-mkxy/">题解</a> </td>
<td style="text-align:left;"> 多源BFS，数圈圈 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotting-oranges/description/">994. 腐烂的橘子</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotting-oranges/solutions/1794075/994-fu-lan-de-ju-zi-by-alexhilton-6g10/">题解</a> </td>
<td style="text-align:left;"> 多源BFS </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/as-far-from-land-as-possible/description/">1162. 地图分析</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/as-far-from-land-as-possible/solution/xi-you-yuan-su-1162-di-tu-fen-xi-duo-yua-7c8t/">题解</a> </td>
<td style="text-align:left;"> 点集互换，多源最短路径 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-path-with-alternating-colors/description/">1129. 颜色交替的最短路径</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-path-with-alternating-colors/solutions/2091594/1129-yan-se-jiao-ti-de-zui-duan-lu-jing-cwm57/">题解</a> </td>
<td style="text-align:left;"> 双源BFS </td>
</tr>
</tbody>
</table>


<h2>圈式BFS</h2>

<p>单源多源都可以，重点不是起点的多少，而是要在遍历的时候注意数圈层。BFS的特点是像水波一样一层一层，一圈一圈的由起点向外传播，有时候我们需要对这些层和圈进行计数。</p>

<p>其实，这个跟树的层序遍历是一样的，树的遍历大法可以<a href="http://toughcoder.net/blog/2022/08/18/binary-tree-made-easy/">参考 这个文章</a>，如果对树的层序遍历熟悉了，那么图的数圈圈也就会了。做法就是添加下一层时做一下标记，就可以了，并不复杂。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-bridge/description/">934. 最短的桥</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-bridge/solutions/1922745/934-zui-duan-de-qiao-by-alexhilton-mkxy/">题解</a> </td>
<td style="text-align:left;"> 多源BFS，数圈圈 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>泛图BFS（枚举）</h2>

<p>图是一个很广泛的概念，任何事情都可以视为一个顶点，事物之间的联系可视一条边，状态也可以视为一个顶点，一个状态变化 为另一个状态可视为一条边，因此图论的搜索，或者说图论的遍历方式可以广泛的应用。</p>

<p>BFS的遍历特点是能找到<strong>两个顶点之间的最短路径</strong>，因此，当找一些<strong>状态与状态之间的最少变化次数</strong>之类的问题时，经过适当的建模后，便可以用图论的BFS来求解。</p>

<p>针对广泛图应用BFS的套路：</p>

<ol>
<li>针对 状态进行建模，确定状态的变化规律</li>
<li>搞清楚状态的变化 规律后就可以建图了，要注意图是否是无限图，如果是无限图就必须找遍历搜索的边界</li>
<li>把起点加入队列，确定标记方案，然后开始做BFS</li>
<li>注意边界，包括重复标记，以及搜索的边界，以防止进入死循环</li>
</ol>


<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/jump-game-iii/solutions/">1306. 跳跃游戏 III</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/jump-game-iii/solutions/2302494/1306-tiao-yue-you-xi-iii-by-alexhilton-uayu/">题解</a> </td>
<td style="text-align:left;"> 模板题，本身是数组边界固定 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/minimum-jumps-to-reach-home/description/">1654. 到家的最少跳跃次数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/minimum-jumps-to-reach-home/solutions/2302780/xi-you-yuan-su-1654-dao-jia-de-zui-shao-mrilp/">题解</a> </td>
<td style="text-align:left;"> 容易想到BFS，确定右界是关键 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/minimum-genetic-mutation/">433. 最小基因变化</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/minimum-genetic-mutation/solutions/2303783/433-zui-xiao-ji-yin-bian-hua-by-alexhilt-vc3x/">题解</a> </td>
<td style="text-align:left;"> 枚举状态的模板题 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/open-the-lock/">752. 打开转盘锁</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/open-the-lock/solutions/2303829/xi-you-yuan-su-752-da-kai-zhuan-pan-suo-b6ulp/">题解</a> </td>
<td style="text-align:left;"> 枚举状态的模板题 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/water-and-jug-problem/">365. 水壶问题</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/water-and-jug-problem/solution/xi-you-yuan-su-365-shui-hu-wen-ti-bfs-by-shah/">题解</a> </td>
<td style="text-align:left;"> 建模定义状态，转换状态 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><strong>注意</strong>：本质上，这属于枚举，我们枚举各种状态，然后找到想要的答案。用BFS来枚举是寻找两种状态之间的最少变化 次数。而DFS枚举则用于查找所有的可行方案，这其实就是回溯算法了。图论真的博大精深，与各种算法融合在一起。</p>

<h2>复杂状态处理</h2>

<p>图的遍历可复杂也可简单，重点并不是遍历方式如DFS，单源BFS或者多源BFS，而且遍历到每个节点时，对节点状态的处理，这里可能会千变万化，有些难题就难在对状态的处理，有些是状态太复杂了，要想办法压缩 以达到可处理的地步（如题847），有些则是状态变化 太多了（如题417）。这有点类似于<a href="http://toughcoder.net/blog/2022/09/08/introduction-to-dynamic-programming/">动态规划</a>，是没有固定的套路的，只能靠平时积累以及分析建模能力了。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-path-visiting-all-nodes/description/">847. 访问所有节点的最短路径</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-path-visiting-all-nodes/solutions/2301703/xi-you-yuan-su-847-fang-wen-suo-you-jie-jvpcz/">题解</a> </td>
<td style="text-align:left;"> 多源BFS，状态压缩 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/">1926. 迷宫中离入口最近的出口</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/solution/xi-you-yuan-su-1926-mi-gong-zhong-chi-ru-fxvi/">题解</a> </td>
<td style="text-align:left;"> 单源最短路 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>双向BFS</h2>

<p>无论是单源还是多源做BFS时一般都是一个方向的，也就是说把起始顶点或者点集加入队列作为起点，向着目标顶点或者点集或者说终点去BFS遍历。通常情况下，这没什么问题。</p>

<p>但当数据量特别大时，或者状态的计算比较复杂时，这样效率就不够高了，这时需要更为复杂的玩法。其实前面说的起点和终点都是相对的，图的搜索遍历其实是不分方向的，起点到终点的最短距离，与终点到起点的最短距离其实是一样的，反过来你把终点当成起点来做BFS也是一样的（前面讲多源BFS时就提到过逆向思维，把点集对换，其实就是从原终点当作新起点做BFS）。</p>

<p>那么，假如同时从起点开始，和从终点开始一起做BFS，当两个BFS相遇时（同时到达相同的一层顶点时）搜索完成，是不是搜索效率就会加倍？这就是双向BFS的核心思想。另外，为了保证平衡性和效率，每次要<strong>优先把队列元素数量小</strong>的一个方向向前推进。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/word-ladder/description/">127. 单词接龙</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/word-ladder/solution/xi-you-yuan-su-127-dan-ci-jie-long-bfs-b-52ia/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/">1091. 二进制矩阵中的最短路径</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-path-in-binary-matrix/solution/xi-you-yuan-su-1091-er-jin-zhi-ju-zhen-z-gxba/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>逆向遍历</h2>

<p>图的遍历都是从某些顶点出发，去寻找另外的顶点。有些时候是起始顶点已知，比如前面提到的常规遍历问题，无论是单源还是多源，都是起点是已知的固定的一个顶点集合。</p>

<p>但有时候，起点并不固定，但终点是固定的，这时候就需要运用逆向思维，从这些固定的终点出发做遍历，进而求解。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/pacific-atlantic-water-flow/">417. 太平洋大西洋水流问题</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/pacific-atlantic-water-flow/solution/xi-you-yuan-su-417-tai-ping-yang-da-xi-y-jami/">题解</a>  </td>
<td style="text-align:left;"> 典型的终点固定，起点不固定，从终点出发遍历  </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>拓朴排序</h2>

<p>对于有向无环图而言，拓朴排序能够把顶点按依赖顺序排成线性列表，用的也是BFS来实现的，<a href="http://toughcoder.net/blog/2022/09/08/topological-sorting/">详情可以参考此文</a>。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://leetcode.cn/circle/discuss/FyPTTM/">图论算法，拿得起放得下</a></li>
<li><a href="https://www.hackerearth.com/practice/algorithms/graphs/breadth-first-search/tutorial/">Breadth First Search</a></li>
<li><a href="https://www.geeksforgeeks.org/multi-source-shortest-path-in-unweighted-graph/">Multi Source Shortest Path in Unweighted Graph</a></li>
<li><a href="https://www.geeksforgeeks.org/bipartite-graph/">Check whether a given graph is Bipartite or not</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[String Problems Archive]]></title>
    <link href="http://toughcoder.net/blog/2023/03/19/string-problem-archive/"/>
    <updated>2023-03-19T10:24:09+08:00</updated>
    <id>http://toughcoder.net/blog/2023/03/19/string-problem-archive</id>
    <content type="html"><![CDATA[<p>字符串即由字符组成的线性数组结构，可以理解为字符数组或者字符列表，但元素的集合是有限集合，通常是英文字符，数字和算术运算符号。可以说数组和列表的常见问题和技巧都可以应用于字符串，但因为是有限集合，所以又有一些独特的问题和技巧，今天就来总结一下。</p>

<p><a href=""><img src="https://cdn.programiz.com/sites/tutorial2program/files/c-strings.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>编程技巧</h2>

<h3>转成字符数组来遍历</h3>

<p>对于Java语言来说charAt(i)非常的慢，所以如果需要多次遍历，或者多次获利某个索引位置的字符，最好先转成字符数组toCharArray()，这样效率会高出很多。对于其他语言像Python3和Kotlin则没必要，因为本来就可以像常规数组(列表)一样遍历。</p>

<h3>用桶代替哈希表</h3>

<p>字符串的每个元素是有限集合，所以要尽可能的用桶来代替哈希表，每当需要对字符计数，或者做映射的时候，都可以先尝试用桶。
比如小写英文字母，就可以用一个长度为26的整数数组来计数，字符与索引的转化关系是ch-&lsquo;a&#8217;，同理可以扩展到大写ch-&#8216;A&#8217;，甚至数字字符ch-&#8216;0&#8217;。</p>

<h3>字符与索引相互转化</h3>

<p>前面提到了用桶，就是把字符转化为索引。反过来也是可行的。目标字符ch = (char) (i + &lsquo;a&rsquo;)就把索引转为小写，大写和数字字符也是同理的。</p>

<h4>Java/C/C++</h4>

<p>传统语言里面char相当于无符号整数，所以可以直接强行互转：</p>

<pre><code class="Java">char ch = (char) (i + 'a');
int idx = ch - 'a'
</code></pre>

<h4>Python3</h4>

<p>大Python3中要用ord()和chr()来进行字符到整数的互转</p>

<pre><code class="Python3">idx = ord(ch) - ord('a')
ch = chr(idx + ord('a'))
</code></pre>

<h4>Kotlin</h4>

<p>因为Kotlin中没有所谓的基础类型，都是对象，所以就用对象提供的方法即可。字符转为整数用Char.code，要把数字字符转为对应字面的整数用Char.digitToInt，如:</p>

<pre><code class="Kotlin">val ch: Char = '3'
println("ch as int ${ch.code}, ch digit as int ${ch.digitToInt()}")
// ch as int 51, ch digit as int 3
</code></pre>

<p>如果是想转成其他进制的整数，可以传入基数作为参数，如：</p>

<pre><code class="Kotlin">val hexCh = 'F'
println("hex ch ${hexCh.digitToInt(16)}") // 15
</code></pre>

<p>因为是基于JVM的，所以字符也可以用于计算，比如idx = ch - &lsquo;a&#8217;，这是完全没有问题的。</p>

<pre><code class="Kotlin">    val a = 'a'
    var idx = 'd' - a
    val aidx = idx + 7
    println("idx $idx, aidx to ch ${(aidx + 'a'.code).toChar()}")
    //idx 3, aidx to ch k
</code></pre>

<p>反过来，整数转到字符，用Int.toChar()就可以了，会按ASCII的code值去转。另外，如果想转成数字字符用Character.forDigit(ch, radix):</p>

<pre><code class="Kotlin">val d = 8
println(" int to char ${d.toChar()}, to digit char ${Character.forDigit(d, 10)}")
</code></pre>

<h3>字符数组/列表转为String</h3>

<p>涉及字符的题目，一般需要转成字符数组处理后，再把字符数组转成字符串。</p>

<p>对于Java来说，String的构造方法支持传入char[]作为参数。</p>

<p>而Python3，其实就是字符列表转为字串，可以用join方法，这个方法是str提供的方法，用一个str当作分隔符来把一个列表连接起来：</p>

<pre><code class="Python3">chars = ['H', 'e', 'l', 'l', 'o']
''.join(chars) # "Hello"
</code></pre>

<p>同样，Kotlin中也有joinToString方法，它对数组和列表都支持，可以传入一个参数作为分隔符：</p>

<pre><code class="Kotlin">val chars = charArrayOf('H', 'e', 'l', 'l', 'o')
val res = chars.joinToString("")
</code></pre>

<h3>压缩到位运算</h3>

<p>如果字符集合特别有限，比如只有有限几个字符，或者只有小写，只有大写，这时可以更进一步的，用位运算来进行优化。小写字符只有26个，一个整数有32位可以用，完全够用。</p>

<p>当满足以下两个条件时就可以考虑用位运算来优化：仅涉及两个状态，有和没有；另外就是字符或者组合后的集合范围在32个以内。</p>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sort-characters-by-frequency/">451. 根据字符出现频率排序</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sort-characters-by-frequency/solution/451-gen-ju-zi-fu-chu-xian-pin-lu-pai-xu-01mur/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>变位词</h2>

<p>变位词是指对于一个字符串，把某几个字符位置换一下之后得到的字符串，与原串互为变位词。其实变位词不局限于字符串，对于任何一个线性列表来说，把某几个元素位置变一下就是互为变位词了。变位词有两大特点：字符集合是一样的，种类一样，频次也一样，但排列不一样。</p>

<p>基于它的特点，涉及变位词的问题，就变成了字符频次统计的问题了，如果两个字符串的字符频次一样，那么就互为变位词。另外的处理方式就是排序，因为只是排列不一样，所以按照同一规则排序后，两字符串就相同了，那么通过排序 来验证也可以可行的。具体处理时，要依据不同的条件来灵活选择具体的识别方式。</p>

<p>需要注意的是，当用频次统计法时，记得用桶而不是直接用哈希表。</p>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/group-anagrams/solution/49-zi-mu-yi-wei-ci-fen-zu-by-alexhilton-ni22/">题解</a> </td>
<td style="text-align:left;"> 排序法 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>回文</h2>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-palindromic-substring/solution/">5. 最长回文子串</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-palindromic-substring/solution/5-zui-chang-hui-wen-zi-chuan-by-alexhilt-6kvt/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>状态压缩</h2>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/repeated-dna-sequences/solution/187-zhong-fu-de-dnaxu-lie-by-alexhilton-5or9/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>其他</h2>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
</feed>
