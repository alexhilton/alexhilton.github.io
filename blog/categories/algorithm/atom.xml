<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2022-09-11T22:42:39+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[图论基础知识]]></title>
    <link href="http://toughcoder.net/blog/2022/09/08/graph-data-structure-made-easy/"/>
    <updated>2022-09-08T18:05:45+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/08/graph-data-structure-made-easy</id>
    <content type="html"><![CDATA[<p>图（<a href="https://en.wikipedia.org/wiki/Graph_(abstract_data_type">Graph</a>)）是一个由节点和边组成的略复杂的二维数据结构，通常用于表示物体之间的关系。</p>

<p><a href=""><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.-HB8jzKKYmCKNH9ui2LDpwHaDH?pid=ImgDet&amp;rs=1" title="auto auto" ></a></p>

<!-- more -->


<h2>图的基础知识</h2>

<p>图由节点（Vertex）和边（Edge）组成，节点之间会有边来连接以表示某种关系。逻辑上的形状会是这样子的：
<img src="https://www.thecrazyprogrammer.com/wp-content/uploads/2017/08/Graph-Data-Structure.png" alt="" /></p>

<p>图的节点通常用于表示物体或者数值，变化较少，图的复杂性主要就体现在边上面，比如有些是有向的，有些是无向的，还有指向自己的。</p>

<h3>路径 Path</h3>

<p>在一个图中，路径是一系列节点和边，其中的节点都由边连接</p>

<h3>路径长度 Path length</h3>

<p>两个节点之间的边的数量称为路径长度</p>

<h3>简单路径 Simple Path</h3>

<p>一个路径所经过的节点没有重复的，就称为简单路径</p>

<h3>根 Root</h3>

<p>如果一个节点，由它出发的路径可以连通到所有节点，那么这个节点称作图根</p>

<h3>环 Cycle</h3>

<p>存在路径起始节点相同，就形成了环</p>

<h3>度 Degrees</h3>

<p>针对 节点而言，经过一个节点的所有边的数量之和，称之为节点的度</p>

<h3>入度 In degress</h3>

<p>对于有向图而言，以节点为终点的边的数量，称这节点的入度。</p>

<h3>出度 Out degrees</h3>

<p>对于有向图而言，从一个节点出发的边的数量，称为节点的出度。</p>

<h2>图的分类</h2>

<h3>空图 Null graph</h3>

<p>也就是只有顶点，没有边的图，样子大概是这样：</br>
<img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.QifCHVxIx4myhHIXgxapLQAAAA?pid=ImgDet&amp;rs=1" alt="" /></p>

<h3>有限图 Finite graph</h3>

<p>顶点和边的数量是有限的，接触到的绝大多数图都是有限图。</p>

<h3>无限图 Infinite graph</h3>

<p>顶点和边的数量是无限的</br>
<img src="https://www.researchgate.net/profile/David-Evans-81/publication/225108378/figure/fig1/AS:393838129631243@1470909735860/The-infinite-graph-A-6.png" alt="" /></p>

<h3>完全图 Complete graph</h3>

<p>所有节点都是有路径连通的</br>
<img src="https://miro.medium.com/max/7954/1*q0tQ1svUWfN05kWsZ_Uo2g.jpeg" alt="" /></p>

<h3>权重图 Weighted graph</h3>

<p>每一条边都有一个数值表示的权重以代表两个节点之间的某种成本</p>

<p><img src="https://i1.wp.com/algorithms.tutorialhorizon.com/files/2018/03/Weighted-Graph.png?ssl=1" alt="" /></p>

<h3>无向图 Undirected graph</h3>

<p>连接节点之间的边是没有方向的，称之为无向图，它也是普通 的图</p>

<h3>有向图 Directed graph</h3>

<p>每条边都是有方向的，对于两个节点来说v[i]和v[j]来说，e[i,j]=(v[i],v[j])，它与e[j,i]=(v[j],v[i])是不一样的，有向图通常用于表示物体之间的依赖关系</p>

<p><img src="https://www.filepicker.io/api/file/1KMTR25HS2OzpZcpy0mJ" alt="" /></p>

<h3>连通图 Connected graph</h3>

<p>任意两节点都连通，称之为连通图也叫强连通图。</p>

<h3>非连通图 Disconnected graph</h3>

<p>有两个节点没有边连接，就称为非连通图。</p>

<h3>自环</h3>

<p>也就是某个节点有一条边是自己连接着自己，这个有向和无向图都可以有</p>

<h3>有环图 Cyclic graph</h3>

<p>起点和终点相同的路径，就形成了环。如果图中存在一个环，就是有环图。</p>

<p><img src="https://www.droidtechknow.com/programming/data-structure/an-introduction-to-graph-data-structure/images/graph-example.jpg" alt="" /></p>

<h3>无环图 Acyclic graph</h3>

<p>图中没有环就是无环图</p>

<h3>有向无环图 Directed Acyclic Graph</h3>

<p>有向图中不存在环就是DAG，这是比较重要的一种图，拓扑排序 可以验证DAG。</p>

<p><img src="https://wiki.swarma.org/images/c/cd/A_DAG_G.png" alt="" /></p>

<ul>
<li><a href="https://www.geeksforgeeks.org/introduction-to-graphs/">Introduction to Graphs</a></li>
</ul>


<h2>图的表示方法</h2>

<p>图的表示方法一般有邻接矩阵法和邻接表法。</p>

<h3>邻接矩阵 Adjacency Matrix</h3>

<p>对于有n个顶点的图来说要创建一个nxn的矩阵来表示此图，每一个格子[i,j]表示顶点v[i]到v[j]是连通的，有一条边存在，如果是有向图，则[j,i]表示v[j]到v[i]的边。另外，如果有权重，格子的值也可以表示边的权重。
<img src="https://educativesite.com/wp-content/uploads/2019/09/incidence-matrix.png" alt="" />
因为用矩阵一般比较浪费空间，比如顶点较多，但边较少时，就有点浪费空间。一般，矩阵通常就是一类单独的矩阵类搜索问题，直接应用图的搜索方法。</p>

<h3>邻接表 Adjacency List</h3>

<p>也就是列表的列表，先用一个链表代表所有的顶点，然后这个链表的元素是这个与这个顶点相连的所有顶点组成的列表。
<img src="https://cdn.programiz.com/sites/tutorial2program/files/adjacency-list.png" alt="" />
通常是用数组加链表的形式，主表用数组或者可变长数组，因为这些都是顶点，有可能会随时从某个顶点开始遍历，所以要用随机访问效率高一些的数组。与顶点相连的顶点列表一般用链表，因为它方便删除和插入，且遍历一般都是从顶点开始遍历。</p>

<p><img src="https://ts1.cn.mm.bing.net/th/id/R-C.4fe11a408a41fa5509274d85a4c09c1f?rik=YfKo9VJ94v7kxw&amp;riu=http%3a%2f%2fprogressivecoder.com%2fwp-content%2fuploads%2f2020%2f12%2fadjacency-list.png&amp;ehk=WAS3o3piPNsR6QCXSeDCVsjO%2fcuyO6KisgW5kv4uwYQ%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" /></p>

<p>但，也要看实际情况，有时候用哈希表也可以，键是每个顶点，值为顶点所连接的顶点列表，顶点列表可以用列表，也可以用Set等等。</p>

<p><img src="https://condor.depaul.edu/glancast/393class/docs/images/topsort7C++.gif" alt="" /></p>

<p>邻接表的实现方式比较自由，只要能从一个顶点出发，方便的找到与其相连的顶点，就可以。具体的，可以依据实际数据情况来灵活选择，比如说顶点如果是某一个范围内的整数，那么可能用数组就更方便一些，如果是字串或者其他的，可能用哈希表就更方便一些。</p>

<ul>
<li><a href="https://www.geeksforgeeks.org/graph-and-its-representations/">Graph and its representations</a></li>
</ul>


<h2>图与树的关系</h2>

<p>图是一个比较大的概念，只要是有节点与节点相连接就可以看作是图，数组（可视为下标与元素的连接），哈希表（键与值的连接），树，链表都可以看作是图。这些数据结构是一种特殊的图，强加了很多其他规则，就比如树，有一个根，有多个子节点。</p>

<p><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.sELEF-9VK_G1wwU413LUFgAAAA?pid=ImgDet&amp;rs=1" alt="" /></p>

<p>适用于图的很多算法也适用树，比如DFS和BFS对树也是适用的。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/">Graph Data Structure And Algorithms</a></li>
<li><a href="https://www.programiz.com/dsa/graph">Graph Data Stucture</a></li>
<li><a href="https://medium.com/data-structures-and-algorithms/graph-dd2b72c32f1f">Graph</a></li>
<li><a href="https://www.simplilearn.com/tutorials/data-structure-tutorial/graphs-in-data-structure">Your One-Stop Solution For Graphs In Data Structures</a></li>
<li><a href="https://www.runoob.com/data-structures/graph-theory.html">图论基础和表示</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/124259930">【朝夕的ACM笔记】图论-图论基础概念</a></li>
<li><a href="https://blog.csdn.net/Karen_Yu_/article/details/78776354">图论基础知识总结（一）</a></li>
<li><a href="https://cuigeg.github.io/2017/06/27/Graph-theory/">这一点点的图论基础</a></li>
<li><a href="https://labuladong.github.io/algo/2/22/50/">图论基础及遍历算法</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1922486">图论算法基础（修订版）</a></li>
<li><a href="https://www.cnblogs.com/BlairGrowing/p/13637688.html">图论&mdash;-基础知识 </a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解并运用并查集]]></title>
    <link href="http://toughcoder.net/blog/2022/09/08/disjoint-set-data-structure/"/>
    <updated>2022-09-08T17:27:05+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/08/disjoint-set-data-structure</id>
    <content type="html"><![CDATA[<p><a href="">并查集</a>（<a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">Disjoint-set Data Structure</a>）是一种树形的结构，用于处理<strong>不相交</strong>的集合的高效的查询(find)和合并(union)问题。主要有两种操作一是查询(find)，也就是查询某个元素是否属于某个集合；二是合并(union)，也即把某个加入到某个集合中，这里的集合都是无交集的。通过路径压缩，并查集的查询和合并都可以达到常数级别O(1)。</p>

<p><a href=""><img src="https://images.xiaozhuanlan.com/photo/2019/891afdf6961c0eab3d3aa28a3f355e12.png" title="auto auto" ></a></p>

<!-- more -->


<h2>朋友关系问题</h2>

<p>先来看一个问题，比如有一个朋友关系的问题，两个人可以成为朋友关系，两两是朋友的一群人就形成了一个朋友圈，那么如何快速判断某两个是不是朋友关系呢？又如何让两个人成为朋友呢？</p>

<p>一个可行的方法是用图的搜索，两个人的朋友关系可以视为图的一条边，一个朋友圈就是相互连通的一个图，查看两人是否是朋友关系，可以从一个人出发，不断遍历相连的边，看能否到达另一个人，但这样效率有点低，每次查询 都会是线性时间，因为都要遍历一遍图才知道。</p>

<p>我们换个思路，可以为一个朋友图指定一个『圈长』，把关系改成其他人都直接跟圈长相连，或者每个人都能找到自己的圈长，这时判断两个人是不是在同一个朋友圈内，就看它们的圈长是不是同一个人就可以了，这就是并查集。</p>

<p><img src="https://red-green-rewrite.github.io/images/maze/disjoint-set-merge-3+7.png" alt="" /></p>

<h2>并查集的概念与基本实现</h2>

<p>并查集用以表示不相交的集合，逻辑上它是一种扁平的树形结构，每一个树代表一个集合，树的根就是这个集合的『圈长』，或者叫做一个集合的代表（representative）。并查集支持两种操作，查询（find） 和合并（union），查询是看两个元素是否属于同一个集合，合并则是把两个集合合并成为一个集合。</p>

<p>并查集的精髓就在于它的『圈长』机制，我们不管具体某个元素它的路径与关系，每个元素都只关心自己的圈长，它能找到自己的圈长就可以，因此查询是否属于同一个集合就看元素的圈长是否是同一个；合并，也非常简单，两个集合合并，就是把其中一个圈长的圈长设置为另一个圈长就可以了。</p>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.ywrpxwo6g4mKItHNwrzyVgHaFU?pid=ImgDet&amp;rs=1" alt="" /></p>

<h3>具体实现</h3>

<p>需要注意，虽然并查集逻辑上是一种树形结构，但一般情况都用线性的数组来实现并查集。比如用一个长度为n的数组来表示并查集，实际上我们只关心圈长，所以下标为i的元素就是i的圈长，一般命名为parent，也就是说parent[i]就是i的圈长，或者顺着它就能找到圈长（树的根），而parent[i]=i则是一个集合的『圈长』（representative）。</p>

<p>初始时，每个元素都是独立的，每个元素都独立成团，自己就是圈长，也即parent[i]=i。当有元素合并了，就把它们指向同一个圈长，比如parent[8]=6，parent[1]=6，parent[2]=4，parent[3]=4，parent[9]=4，parent[7]=4，这样就知道一共有三个集合，其中5独自成一个集合，1和8还有6是同一个集合6是他们的圈长，2，3，9，7，4是同一个集合4是圈长，画出图来就是这样的：</p>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.aqoDLciI4xvo7AnTDg3KRQHaFI?pid=ImgDet&amp;rs=1" alt="" /></p>

<h3>查询与合并</h3>

<p>查询某两个元素是否属于同一个集合，就是归结来查找每个人所属集合的圈长（representative），然后判断是否是同一个元素，因此问题归结为圈长的查找。比如2的父节点是4，而parent[4]=4，它就是圈长，所以2的圈长是4；再看7，它的父节点是9，而9的父节点是4，4是圈长，因此2和7属于同一个集合。</p>

<p>合并，也是类似的，而且更加简单，先查询要合并是否属于同一个集合，如果属于那自然就不用合并了。如果不是，那就找到各自的圈长，然后把某一个圈长的圈长设为另一个即可。比如想把5和8合并，5独自成圈，而8的圈长是6，那么把5的圈长设置为6，parent[5]=6，就合并完成了。</p>

<p><strong>注意</strong>：并查集的具体实现要看实际数据类型，比如集合元素个休是一个0~n范围内的整数，那么自然用数据非常方便，或者能够方便的转化为数组的下标时，用数组也行。否则也可以用哈希表。因为元素只要能递归的向上找到它的圈长（树的根）就行。</p>

<h2>路径压缩</h2>

<p>从前面的例子来看，查询过程其实是O(n)的，因为某个元素的父节点不一定就是圈长，为了找到圈长要递归的找下去，直到找到圈长为止，即只有找到了parent[i]=i，才算找到了圈长。这样每次查询都是线性时间，就会导致并查集整体效率变成O(n<sup>2</sup>)的。</p>

<p>因为并查集是处理集合问题，也就是说我们只关系某两个元素是否属于同一个集合，至于它跟其他元素之间的关系并不重要，我们只希望快速的找到它的圈长就可以了，那么我们在查找圈长的过程中，就可以把元素都直接指向其圈长，比如前面的7，它的父节点是9，不是圈长，我们查找后发现圈长是4，那么在查询过程中就可以把parent[7]=4，让7的父节点变成圈长。这样做的好处是，下次再查询时就能直接找到圈长了，变成了O(1)，不用再线性去查找了，这便是路径压缩。路径压缩的复杂度是常数级别的，可以用摊还分析来证明。</p>

<p>最终树变成了扁平的，集合中的每一个元素都直接指向圈长：</p>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.v4afq3bNSl3SnFPKfVM3jwHaCO?pid=ImgDet&amp;rs=1" alt="" /></p>

<h2>按秩合并</h2>

<p>合并的时候是把一个集合的圈长的圈长设置为另一个集合的圈长，比如前面5和8要合并，5的圈长是5，8的圈长是6，这时其实有两种可行方法，可以把5的圈长设为6，即parent[5]=6，但也可以把6的圈长设置为5啊，即parent[6]=5，逻辑上都可行的，但应该用哪种呢？</p>

<p>逻辑上并无对错，要从效率上来比较哪个更好。前面提到了，常规查询是线性时间的，集合是树形的，树的高度越高，那么找到圈长的时间就越长，路径压缩后树才会变得扁平，因此，可以认为树的高度是越小越好的。由此来看，把5的圈长设置为6效率更高，6这个集合高度是2，如果把6的圈长设置为5，那么树的高度会变成3，需要一次路径压缩才可以；相反，如果把5的圈长设置为6，即parent[5]=6，那么树的高度还是2，不需要额外的路径压缩了。所以应该把高度小的集合并到高度大的集合中去。</p>

<p>那么，可以用另外一个数组rank来表示集合的秩，即rank[i]是i所属于集合的秩，也就是树的高度，当合并的时候就可以参考 rank来进行更高效的合并，总是把秩低的往秩高的上面的合并。只看圈长的秩就可以了，因为合并的时候是两个圈长在打架。</p>

<h2>实例</h2>

<p>还是来一个具体的实例，来演示并查集的思路和具体实现。把朋友圈关系进行抽象，用数字0~n来代表N个人，N=n+1，实现一个并查集，并进行查询和合并操作。</p>

<pre><code class="java">public class DisjointSet {
    private int size;
    private int[] parent;
    private int[] rank;

    public DisjointSet(int size) {
        this.size = size;
        parent = new int[size];
        rank = new int[size];
        init();
    }

    private void init() {
        for (int i = 0; i &lt; size; i++) {
            parent[i] = i;
        }
    }

    public void union(int x, int y) {
        int xRoot = find(x);
        int yRoot = find(y);

        if (xRoot == yRoot) {
            // In the same set already, do nothing
            return;
        }

        // Union by rank, ruled by higher rank.
        if (rank[xRoot] &lt; rank[yRoot]) {
            parent[xRoot] = yRoot;
        } else if (rank[xRoot] &gt; rank[yRoot]) {
            parent[yRoot] = xRoot;
        } else {
            parent[xRoot] = yRoot;
            rank[yRoot]++;
        }
    }

    public int find(int x) {
        if (parent[x] == x) {
            return x;
        }

        // Path compression
        int root = find(parent[x]);
        // Make each node point to its root
        parent[x] = root;
        return root;
    }

    public static void main(String[] args) {
        DisjointSet dset = new DisjointSet(5);
        dset.union(0, 2);
        dset.union(4, 2);
        dset.union(1, 3);

        System.out.println("True: " + (dset.find(4) == dset.find(0)));
        System.out.println("False: " + (dset.find(1) == dset.find(0)));
    }
}
</code></pre>

<h2>并查集的应用</h2>

<p>可以发现并查集是一个<strong>很优雅</strong>的数据结构，它的实现很简单，效率却非常高。凡是涉及不相交集合的查找与合并问题，都可以使用并查集来解决问题。这里最为关键的是集合元素之间不能有交集，也就是说除以我们指定的圈长方式来划分集合以外，不能有其他的约束条件，否则并查集就失效了。比如说现实生活中的人，可以以工作所在的公司来划分集合，也可以以住的小区来划分，假如题目中两个约束条件都在，那就没有办法应用并查集了。</p>

<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-consecutive-sequence/solution/by-alexhilton-ip97/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/disjoint-set-data-structures/">Disjoint Set Data Structures</a></li>
<li><a href="https://cp-algorithms.com/data_structures/disjoint_set_union.html">Disjoint Set Union</a></li>
<li><a href="https://www.javatpoint.com/disjoint-set-data-structure">Disjoint set data structure</a></li>
<li><a href="https://www.techiedelight.com/disjoint-set-data-structure-union-find-algorithm/">Disjoint–Set Data Structure (Union–Find Algorithm)</a></li>
<li><a href="https://www.hackerearth.com/practice/notes/disjoint-set-union-union-find/">Disjoint Set Union (Union Find)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/93647900">算法学习笔记(1) : 并查集</a></li>
<li><a href="https://oi-wiki.org/ds/dsu/">并查集</a></li>
<li><a href="https://www.cnblogs.com/onlyblues/p/14668087.html">并查集算法 </a></li>
<li><a href="https://segmentfault.com/a/1190000022952886">图解并查集，附赠几道 Leetcode 练手题</a></li>
<li><a href="https://blog.csdn.net/weixin_44176696/article/details/106434770">简单并查集讲解（并+查）与代码实现</a></li>
<li><a href="https://zh-spike.github.io/studyRepo/Algorithm/Notes/AdvancedDataStructure/%E5%B9%B6%E6%9F%A5%E9%9B%86/">并查集</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解拓扑排序]]></title>
    <link href="http://toughcoder.net/blog/2022/09/08/topological-sorting/"/>
    <updated>2022-09-08T16:41:37+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/08/topological-sorting</id>
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/5223807">拓扑排序</a>（<a href="https://en.wikipedia.org/wiki/Topological_sorting">Topological Sorting</a>）是指将一个有向无环图（Directed Acyclic Graph）的所有顶点排成一个线性序列，使得图中的起始节点总是排在终止节点的前面，这是有向图每一个边都有起始节点和终止节点。这个名字有点容易混淆，它跟排序算法没有任何关系，拓扑排序仅是针对有向无环图，找到所有节点的一个可达的线性顺序。</p>

<p><a href=""><img src="https://iq.opengenus.org/content/images/2020/03/topo1-1.png" title="auto auto" ></a></p>

<!-- more -->


<p>关于图的基本概念可以<a href="http://toughcoder.net/blog/2022/09/08/graph-data-structure-made-easy/">参阅这个文章</a>。</p>

<h2>理解拓扑排序</h2>

<p>拓扑排序是针对有向无环图才有意义，它是有向无环图所有顶点的一个线性序列，每个顶点只出现一次，所有顶点都要出现，如果有一条边是从顶点v[i]到v[j]的，那么在拓扑排序中v[i]一定要排在v[j]的前面。</p>

<p><img src="https://wiki.swarma.org/images/c/cd/A_DAG_G.png" alt="" /></p>

<p>有向无环图不一定存在拓扑排序，比如图不是全连通的，有些节点之间没有路径连接。但存在拓扑排序的一定是有向无环图，因此拓扑排序可以用来验证一个图是否是有向无环图。</p>

<h2>拓扑排序的意义</h2>

<p>拓扑排序通常代表着顶点之间的依赖关系，比如软件库的依赖关系，比如课程之间的依赖关系，比如任务调度中的依赖关系等，拓扑排序能够保证任务正确执行，被依赖的肯定 能先执行完，两个顶点（代表的任务）要么是有依赖关系的，要么是没有关系的，在拓扑排序中肯定 不会存在依赖错乱。</p>

<h2>拓扑排序的实现方法</h2>

<p>借助BFS可以实现拓扑排序。</p>

<p><img src="https://www.omegaxyz.com/wp-content/uploads/2019/02/topological2.jpg" alt="" /></p>

<h3>实现思路</h3>

<ol>
<li>先计算顶点的入度，入度是针对 有向图而言的，以顶点为终点的边的数量称为顶点的入度</li>
<li>从入度为为0的顶点开始，把它放入队列</li>
<li>每次从队列中取出顶点，打印出来。然后把这个节点所能直接连通的节点入度减1，并取出入度为0的顶点放入队列</li>
<li>重复第3步，直到没有入度为0的顶点，这时应该所有顶点都遍历到了，如果还有剩余顶点，说明有环</li>
</ol>


<p><img src="https://www.omegaxyz.com/wp-content/uploads/2019/02/topological.png" alt="" /></p>

<pre><code class="java">        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        IntStream.range(0, numCourses)
            .filter(i -&gt; inDegrees[i] == 0)
            .forEach(queue::offer);

        while (!queue.isEmpty()) {
            int from = queue.poll();
            for (int v : graph.get(from)) {
                inDegrees[v]--;
                if (inDegrees[v] == 0) {
                    queue.offer(v);
                }
            }
        }
</code></pre>

<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/course-schedule/solution/by-alexhilton-r7hf/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/ur2n8P/">剑指 Offer II 115. 重建序列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/ur2n8P/solution/by-alexhilton-qc9l/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/topological-sorting/">Topological Sorting</a></li>
<li><a href="https://www.interviewcake.com/concept/java/topological-sort">Topological Sort</a></li>
<li><a href="https://www.hackerearth.com/practice/algorithms/graphs/topological-sort/tutorial/">Topological Sort</a></li>
<li><a href="https://www.scaler.com/topics/data-structures/topological-sort-algorithm/">Topological Sort Algorithm</a></li>
<li><a href="https://cp-algorithms.com/graph/topological-sort.html">Topological Sorting</a></li>
<li><a href="https://www.javatpoint.com/topological-sorting">Topological Sorting</a></li>
<li><a href="https://songlee24.github.io/2015/05/07/topological-sorting/">拓扑排序（Topological Sorting）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/135094687">图文详解面试常考算法 —— 拓扑排序</a></li>
<li><a href="https://oi-wiki.org/graph/topo/">拓扑排序</a></li>
<li><a href="https://www.cnblogs.com/bigsai/p/11489260.html">拓扑排序详解与实现</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记忆化搜索简介]]></title>
    <link href="http://toughcoder.net/blog/2022/09/08/memorization-search/"/>
    <updated>2022-09-08T16:03:31+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/08/memorization-search</id>
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/4275706">记忆化搜索</a>（Memorization Search），是指在做搜索过程中（比如DFS或者动态规划中）把重叠的子问题的解或者状态存储下来，以防止重复计算。最为常见的就是图搜索方法BFS和DFS时都要对已搜索过的节点进行标记以防止重复遍历，这就是一种记忆化搜索方法。再如动态规划的重复子问题，用数组进行缓存以防止重复计算，这也是一种记忆化搜索方法。</p>

<p><a href=""><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.3-yxYgu36IJsH2oONsdqFQHaEe?pid=ImgDet&amp;rs=1" title="auto auto" ></a></p>

<!-- more -->


<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/memoization-1d-2d-and-3d/">Memoization (1D, 2D and 3D)</a></li>
<li><a href="https://oi-wiki.org/dp/memo/">记忆化搜索</a></li>
<li><a href="https://blog.csdn.net/hjf1201/article/details/78680814">记忆化搜索专题</a></li>
<li><a href="https://blog.csdn.net/u010700335/article/details/44136339">记忆化搜索（搜索+dp思想）</a></li>
<li><a href="https://www.cnblogs.com/jinkun113/p/12531918.html">[知识点] 4.1 记忆化搜索与动态规划</a></li>
<li><a href="https://www.zhihu.com/question/60730045">记忆化搜索与动态规划等价吗？</a></li>
<li><a href="http://yudaer.github.io/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/">记忆化搜索</a></li>
<li><a href="https://www.luogu.com.cn/blog/interestingLSY/memdfs-and-dp">聊聊动态规划与记忆化搜索</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/438406757">记忆化搜索 —— 搜索 or 动态规划 ？</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[动态规划从入门到放弃]]></title>
    <link href="http://toughcoder.net/blog/2022/09/08/introduction-to-dynamic-programming/"/>
    <updated>2022-09-08T11:26:06+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/08/introduction-to-dynamic-programming</id>
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408">动态规划</a>(<a href="https://en.wikipedia.org/wiki/Dynamic_programming">Dynamic Programming</a>)动态规划是用来求解具有最优子结构性质问题的一种方法。通俗的来说如果一个问题可以分成多个子问题或者分成多个步骤，每个子问题有多个解或者每个步骤有多个选择，最终求整体问题的一个最优解（最大值，最小值，方法总数，是否可行等等），这样的问题就适合用动态规划来求解。</p>

<p>动态规划一般可分为自顶而下式和自下而上式，自顶而下是通过递归，但因为涉及大量重复计算而导致时间复杂度过高，所以一般都是采用自下而上式，借助额外的空间来缓存子问题的解，减少重复计算从而降低时间复杂度，与<a href="https://baike.baidu.com/item/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/4275706">记忆化搜索</a>有点类似。</p>

<p><a href=""><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.1-yqbboBtUIUqcYV1V1p5gHaEK?pid=ImgDet&amp;rs=1" title="auto auto" ></a></p>

<!-- more -->


<h2>动态规划的适用范围</h2>

<h3>最优子结构性质</h3>

<p><a href="https://blog.csdn.net/lanchunhui/article/details/52480106">最优子结构特性</a>（<a href="https://en.wikipedia.org/wiki/Optimal_substructure">Optimal Substructure</a>）是指一个问题可以分成多个子问题，每个问题的最优解凑成整个问题的最优解。</p>

<h3>重叠子问题性质</h3>

<p>重叠子问题(<a href="https://en.wikipedia.org/wiki/Overlapping_subproblems">Overlapping subproblems</a>)是指一个问题可以分成多个子问题，每个子问题的解会重复使用多次，也就说后一个子问题的解需要使用到前一个子问题的解。最为典型的就是Fibonacci数列，也就是常说的自上而下的方式来实现动态规划（递归式），因为子问题重复，所以为了提升效率必须把子问题的解存储下来以防止重复计算。</p>

<h2>寻找状态转移方程</h2>

<p>动态规划并不像排序或者二分查找那样有具体的形式，它更是一种策略而非具体的算法，发现一个题目可以用动态规划求解时，还远远不够，要想写出代码，必须推导出来状态转移方程，这才是动态规划的核心，而动态如何定义，又如何转移要视具体的问题而定变化万千，所以说动态规划是最难的一类题，没有之一。</p>

<p>一般而言状态转移方程要以结果为导向，也就是说用这个方程能得到问题的解，这依然是一句废话，要通过大量的练习才能掌握。</p>

<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.programiz.com/dsa/dynamic-programming">Dynamic Programming</a></li>
<li><a href="https://towardsdatascience.com/understanding-dynamic-programming-75238de0db0d">Understanding Dynamic Programming</a></li>
<li><a href="https://www.geeksforgeeks.org/dynamic-programming/">Dynamic Programming</a></li>
<li><a href="https://www.freecodecamp.org/news/demystifying-dynamic-programming-3efafb8d4296/">Demystifying Dynamic Programming</a></li>
<li><a href="http://web.mit.edu/15.053/www/AMP-Chapter-11.pdf">Dynamic Programming</a></li>
<li><a href="https://www.javatpoint.com/dynamic-programming">Dynamic Programming</a></li>
<li><a href="https://oi-wiki.org/dp/">动态规划部分</a></li>
<li><a href="https://juejin.cn/post/6951922898638471181">看一遍就理解：动态规划详解</a></li>
<li><a href="https://houbb.github.io/2020/01/23/data-struct-learn-07-base-dp">五大基本算法之动态规划算法 DP dynamic programming</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/137992855">一文搞定动态规划问题（附DP所有问题链接）</a></li>
<li><a href="https://www.zhihu.com/question/23995189">什么是动态规划（Dynamic Programming）？动态规划的意义是什么？</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1692068">动态规划一篇就够了 全网第二详细, 逐步理解, 万字总结</a></li>
<li><a href="https://blog.csdn.net/u013309870/article/details/75193592">算法-动态规划 Dynamic Programming&ndash;从菜鸟到老鸟</a></li>
<li><a href="https://www.javatpoint.com/optimal-substructure-property">Optimal Substructure Property</a></li>
<li><a href="https://stackoverflow.com/questions/33563230/optimal-substructure-in-dynamic-programing">Optimal substructure in Dynamic Programing</a></li>
<li><a href="https://afteracademy.com/blog/optimal-substructure-and-overlapping-subproblems">Optimal Substructure and Overlapping Subproblems</a></li>
<li><a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84.md">动态规划答疑篇</a></li>
<li><a href="https://www.zhihu.com/question/52165201">动态规划的最优子结构问题，有什么样的问题它不满足最优子结构？</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1695752">深入浅出理解动态规划（二） | 最优子结构</a></li>
<li><a href="https://blog.nowcoder.net/n/7390417560b54107b421b13b47adea88">动态规划（最优子结构、重叠子问题）——附代码示例</a></li>
<li><a href="https://www.geeksforgeeks.org/overlapping-subproblems-property-in-dynamic-programming-dp-1/">Overlapping Subproblems Property in Dynamic Programming | DP-1</a></li>
<li><a href="https://www.geeksforgeeks.org/optimal-substructure-property-in-dynamic-programming-dp-2/?ref=lbp">Optimal Substructure Property in Dynamic Programming | DP-2</a></li>
<li><a href="https://stackoverflow.com/questions/64499367/what-are-overlapping-subproblems-in-dynamic-programming-dp">What are overlapping subproblems in Dynamic Programming (DP)?</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
