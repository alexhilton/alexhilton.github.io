<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2023-01-20T23:07:51+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[数学相关题目]]></title>
    <link href="http://toughcoder.net/blog/2023/01/09/mathematics-problem-set/"/>
    <updated>2023-01-09T22:03:57+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/09/mathematics-problem-set</id>
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6/107037">数学</a>是自然科学之母，数学也是算法之母，有一些数学相关的题目需要总结一下。当然暴力法也都是可以解决的，但是通过数学一些公式的引入会提升时间效率。</p>

<p><a href=""><img src="https://ts1.cn.mm.bing.net/th/id/R-C.ba01d095b9f9a650e61d8f49d2b28519?rik=rVVFOj18ozgpZw&amp;riu=http%3a%2f%2fwww.pixelstalk.net%2fwp-content%2fuploads%2f2016%2f05%2fMath-Mathematics-Formula-Wallpaper-for-PC.jpg&amp;ehk=%2bfTho6j8Ym8wGaYhOjf%2bGXs56O7AyL38fNlEbHjIzqQ%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" title="auto auto" ></a></p>

<!-- more -->


<h2>数学题目的特点</h2>

<p>用暴力法或者模拟法也可以解决。</p>

<p>运用相关的数学知识或者数学公式，可以提升效率。</p>

<p>一般都可以使用查表大法。</p>

<h2>数论</h2>

<p>主要是以整数为基础的一些题目，一般会涉及素数，数位等。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/happy-number/">202. 快乐数</a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/add-digits/">258. 各位相加</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/add-digits/solution/by-alexhilton-uehk/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/prime-arrangements/">1175. 质数排列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/prime-arrangements/solution/by-alexhilton-p5rj/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/count-integers-with-even-digit-sum/">2180. 统计各位数字之和为偶数的整数个数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/count-integers-with-even-digit-sum/solution/2180-tong-ji-ge-wei-shu-zi-zhi-he-wei-ou-mc2e/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>数组轮转</h2>

<p>一般就是把数组的元素按照一定的规则进行移动和轮转。一般涉及LCM（最小公倍数）。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotate-array/solution/189-lun-zhuan-shu-zu-by-alexhilton-1ih4/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/minimum-number-of-operations-to-reinitialize-a-permutation/">1806. 还原排列的最少操作步数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/minimum-number-of-operations-to-reinitialize-a-permutation/solution/1806-huan-yuan-pai-lie-de-zui-shao-cao-z-mqq1/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>计算几何</h2>

<p>几何相关的题目也是比较常见的，但通常都是离散化的，一般主要涉及直线，三角形和圆。</p>

<p>计算几何相关问题最需要注意的问题就是精度问题，特别是当坐标是以整数形式给出的时候，这时计算斜率要用乘法，而不能直接用除法。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/max-points-on-a-line/">149. 直线上最多的点数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/max-points-on-a-line/solution/by-alexhilton-gksh/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/projection-area-of-3d-shapes/">883. 三维形体投影面积</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/projection-area-of-3d-shapes/solution/by-alexhilton-9252/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/valid-boomerang/">1037. 有效的回旋镖</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/valid-boomerang/solution/by-alexhilton-1noz/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>其他</h2>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/unique-binary-search-trees/solution/by-alexhilton-y089/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://zhuanlan.zhihu.com/p/497110875">数学是什么？什么是数学？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/301338035">刷算法题必备的数学考点汇总</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搞懂动态规划之状态压缩]]></title>
    <link href="http://toughcoder.net/blog/2022/12/26/understanding-bitmask-dynamic-programming/"/>
    <updated>2022-12-26T12:10:24+08:00</updated>
    <id>http://toughcoder.net/blog/2022/12/26/understanding-bitmask-dynamic-programming</id>
    <content type="html"><![CDATA[<p>动态规划算法博大精深，非常的广泛而复杂。但动态规划离不开状态的存储和转移，要想用动态规划来求解一个问题，必须把问题分解为多个子问题，然后再用状态来记录以解决子问题，最终通过状态转移以得到整个问题的解。根据问题的不同，状态也会有不同的定义，比如有些是用整数来代表计数，有些是用布尔来代表True/False（或者0/1）的状态。</p>

<p><a href=""><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.w0EUQBEfTpJW2jcJ-TeghAHaDU?pid=ImgDet&amp;rs=1" title="auto auto" ></a></p>

<!-- more -->


<p>如果状态可以用True/False（或者0/1）来代表时，那么可以进一步的利用位运算，利用计算机的bit的特点，一个bit可以是0也可以是1，足以表示一个状态，那么就可以把整体的状态只用一个或者几个有限的整数来表示了，这就是状态压缩。</p>

<p>更进一步的，其实可以拓展一下，不光局限在动态规划里面，凡是用到True/False（或者0/1，选与不选等）的辅助存储时，都可以尝试用位运算来代表数组或者哈希表，这其实也是状态压缩。广义上来讲，把一坨用数组或者哈希表表示的状态压缩成为一个整数或者几个有限的整数就是状态压缩。</p>

<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br /></p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.cnblogs.com/labuladong/p/13940269.html">状态压缩：对动态规划进行降维打击</a></li>
<li><a href="https://cp-wiki.vercel.app/dynamic-programming/bitmask-dp/">Bitmask DP</a></li>
<li><a href="https://blog.csdn.net/qq_40722827/article/details/116400306">动态规划之状态压缩DP详细介绍和例题练习</a></li>
<li><a href="https://oi-wiki.org/dp/state/">OI wiki 状压DP</a></li>
<li><a href="https://blog.nowcoder.net/n/fcc30eadb2b44395862194814e819315">【状压DP】状态压缩动态规划入门超详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/131585177">动态规划——状态压缩DP</a></li>
<li><a href="https://www.cnblogs.com/mxrmxr/p/9799832.html">状态压缩入门</a></li>
<li><a href="https://github.com/cormacpayne/Data-Structures-and-Algorithms/blob/master/dynamic-programming/bitmask-dynamic-programming/bitmask-dynamic-programming.md#:~:text=Bitmask%20DP%20is%20a%20type%20of%20dynamic%20programming,or%20a%20binary%20string%20representation%20of%20the%20number.">Bitmask Dynamic Programming</a></li>
<li><a href="https://www.geeksforgeeks.org/bitmasking-and-dynamic-programming-set-1-count-ways-to-assign-unique-cap-to-every-person/">Bitmasking and Dynamic Programming | Set 1 (Count ways to assign unique cap to every person)</a></li>
<li><a href="https://www.geeksforgeeks.org/bitmasking-dynamic-programming-set-2-tsp/">Bitmasking and Dynamic Programming | Set-2 (TSP)</a></li>
<li><a href="https://algo.monster/problems/bitmask_intro">Bitmask and Dynamic Programming</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[前缀和与差分数组简介]]></title>
    <link href="http://toughcoder.net/blog/2022/09/25/intro-to-diff-array/"/>
    <updated>2022-09-25T09:44:51+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/25/intro-to-diff-array</id>
    <content type="html"><![CDATA[<p>在数组相关的问题中前缀和与差分数组是使用使用比较多的辅助数组，能有效的提升效率。前缀和就是数组中到当前元素的和；差分数组是一个辅助数组，每个元素是原数组相邻元素之差，故命名为差分数组，它在原数组区间修改等操作上能辅助提升效率。</p>

<p><a href=""><img src="https://cdn.luogu.com.cn/upload/image_hosting/n0yy6qgd.png" title="auto auto" ></a></p>

<!-- more -->


<h2>一维前缀和</h2>

<p>前缀和的定义不复杂，对于一维列表来说，前缀和是一个辅助列表，前缀和中的元素i，就是原列表中从元素0到元素i的累加和，即preSum[i] = sum(nums, 0, i)。</p>

<pre><code>preSum[0] = nums[0]
preSum[1] = nums[0] + nums[1] = preSum[0] + nums[1]
preSum[2] = nums[0] + nums[1] + nums[2] = preSum[1] + nums[2]
preSum[n-1]= nums[0] + nums[1] + ... + nums[n - 1] = preSum[n - 2] + nums[n - 1]
</code></pre>

<p>代码实现就是这个样的：</p>

<pre><code class="java">    private void init() {
        if (size &lt; 1) {
            return;
        }
        preSum[0] = nums[0];

        for (int i = 1; i &lt; size; i++) {
            preSum[i] = preSum[i - 1] + nums[i];
        }
    }
</code></pre>

<h3>前缀和的应用</h3>

<p>前缀和最大的作用就是能够以常数时间求出一维列表的区间和，或者说连续子列表的和。</p>

<p>比如给定一个列表nums，长度是n，如果想求出子列表[l, r]，都是闭区间的子列表的和，就可以用前缀和。朴素做法很容易想到，就是从遍历区间[l, r]累加即可，显然这是O(n)复杂度，如果查询就一次两次的，当然 也可以，但如果查询次数多了，显然效率差，如果查询m次，时间复杂度会上升到O(mn)。</p>

<p>区间和[l, r]，记为sum(l, r) = nums[l] + nums[l + 1] + &hellip; + nums[r-1] + nums[r]，是可以转化用前缀和来求解的，过程如下：</p>

<pre><code>sum(l, r) = nums[l] + nums[l + 1] + ... + nums[r-1] + nums[r]
           = nums[0] + nums[1] +... + nums[l-1] + nums[l] + ... nums[r-1] + nums[r] - (nums[0] + nums[1] +...+ nums[l-1])
           = preSum[r] - preSum[l-1]
</code></pre>

<p>事先计算前缀和列表，就可以直接以一次减法求出区间和：</p>

<pre><code class="java">    private int regionSum(int i, int j) {
        if (i == 0) {
            return preSum[j];
        }
        return preSum[j] - preSum[i - 1];
    }
</code></pre>

<p><a href="https://github.com/alexhilton/EffectiveAlgorithm/blob/main/datastructure/src/main/java/AuxiliaryArray.java">完整代码看这里</a>。</p>

<h3>前缀和典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/subarray-sum-equals-k/solution/by-alexhilton-eh11/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/find-the-highest-altitude/">1732. 找到最高海拔</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/find-the-highest-altitude/solution/1732-zhao-dao-zui-gao-hai-ba-by-alexhilt-fxhn/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>差分数组</h2>

<p>与前缀和类似，差分数组也是一个常用的辅助数组。它的定义是原数组相邻两元素之差：
<code>
diff[i] = nums[i] - nums[i - 1]
diff[0] = nums[0]
diff[1] = nums[1] - nums[0]
diff[2] = nums[2] - nums[1]
diff[n-1] = nums[n-1] - nums[n-2]
</code>
不难发现，差分数组是前缀和的逆运算，也就是说把差分数组diff求它的前缀和，刚好能得到原始数组：
<code>
nums[0] = diff[0]
nums[1] = nums[0] + nums[1] - nums[0] = diff[0] + diff[1]
nums[2] = nums[0] + nums[1] - nums[0] + nums[2] - nums[1] = diff[0] + diff[1] + diff[2]
nums[n-1] = nums[0] + nums[1] - nums[0] + ... nums[n-1] - nums[n-2] = diff[0] + ... diff[n-1]
</code></p>

<h3>差分数组的作用</h3>

<p>差分数组的作用是能快速的对区间更新。区间更新是指对于数组nums，长度为n，想要对区间[l, r]做更新，比如都加上一个数x，或者都减去一个数y。常规的实现肯定遍历[l, r]然后对每个元素做更新，这是线性时间O(n)的，而用差分数组可以在常数时间完成区间更新。</p>

<pre><code>nums[l, r] + x = nums[l] + x, nums[l + 1] + x, ... nums[r-1] + x, nums[r] + x
                  = diff[l] + x, diff[l + 1], .... diff[r-1], diff[r], diff[r + 1] - x
                  = diff[l] + x, diff[r+1] - x
</code></pre>

<p>可以看出，只对差分数组的区间两端做加减法就可以实现原数组区间增加。当然了，如果想得出原数组的真实修改后的结果，仍需要对差分数组做前缀和才可以，因为差分数组的前缀和才是原始数组。所以，<strong>差分数组是一个辅助数组，它的作用不像前缀和那样明显，它只能配合使用，无法单独使用</strong>。（单独使用仍要用O(n)来计算前缀和才能得到原始数组，失去了意义）。</p>

<p>差分数组与前缀和通常作为辅助数组一起使用，以解决快速区间查询和区间修改，这便是树状数组，理解 了前缀和和差分数组的作用，对于理解 树状数组有很大的帮助。树状数组的具体原理与应用可以<a href="http://toughcoder.net/blog/2022/09/06/intro-to-binary-indexed-tree/">参考 这篇文章。</a></p>

<h2>拓展到二维</h2>

<p>一维上能做的事情，肯定 都能拓展到二维，对于二维列表也就是说矩阵，也可以使用前缀和和差分，差分本来的应用比较有限，不像前缀和可以单独应用，并且二维差分要复杂的多得多，所以这里就讨论一下二维前缀和。</p>

<p>假设一个矩阵为matrix，尺寸是mxn，即m行n列，对于它的任意一个格子{i, j}和前缀和preSum[i, j]等于其左上部分的所有元素之和。</p>

<pre><code>preSum[0, 0] = matrix[0, 0]
preSum[0, 1] = matrix[0, 0] + matrix[0,1] = preSum[0, 0] + matrix[0, 1]
preSum[1, 0] = matrix[0, 0] + matrix[1, 0] = preSum[0, 0] + matrix[1, 0]
preSum[1, 1] = matrix[0,0] + matrix[0,1] + matrix[1,0] + matrix[1,1] = preSum[0, 1] + preSum[1, 0] + nums[1,1] - preSum[0,0]
preSum[i, j] = preSum[i-1,j] + preSum[i, j-1] + matrix[i,j] - preSum[i-1,j-1]
</code></pre>

<pre><code class="java">    private void init() {
        preSum = new int[m][n];

        if (m &lt; 1 || n &lt; 1) {
            return;
        }

        preSum[0][0] = matrix[0][0];
        preSum[1][0] = preSum[0][0] + matrix[1][0];
        preSum[0][1] = preSum[0][0] + matrix[0][1];

        for (int i = 1; i &lt; m; i++) {
            for (int j = 1; j &lt; n; j++) {
                preSum[i][j] = preSum[i][j - 1] + preSum[i - 1][j] + matrix[i][j] - preSum[i - 1][j - 1];
            }
        }
    }
</code></pre>

<h3>二维前缀和的应用</h3>

<p>与一维前缀和类似，二维前缀和的应用用于快速求出区间和，比如求子矩阵和，求[r1,c1]到[r2,c2]之间的子矩阵之和，就可以应用二维前缀和，可以从O(mn)的复杂度降到O(1)。</p>

<pre><code>sum[r1,c1]~[r2,c2] = preSum[r2,c2] - preSum[r2,c1-1] - preSum[r1-1, c2] + preSum[r1-1, c1-1]
</code></pre>

<pre><code class="java">    public int regionSum(int r1, int c1, int r2, int c2) {
        if (r1 == 0 &amp;&amp; c1 == 0) {
            return preSum[r2][c2];
        }
        return preSum[r2][c2] - preSum[r2][c1 - 1] - preSum[r1 - 1][c2] + preSum[r1 - 1][c1 - 1];
    }
</code></pre>

<p>两个坐标[r1,c1]和[r2,c2]把矩阵分成了三个区域，一是[0, 0]~[r2,c2]这就是preSum[r2,c2]，二是[0,0]~[r2,c1-1]，三是[0,0]~[r1-1,c2]，相减，多减了一个公共区域[0,0]~[r1-1,c1-1]，所以要加回来。</p>

<p><a href="https://github.com/alexhilton/EffectiveAlgorithm/blob/main/datastructure/src/main/java/AuxiliaryMatrix.java">完整代码看这里</a>。</p>

<p>前缀和与差分数组一般作为辅助数组使用，理解了它们的原理对于理解更复杂的数组结构如树状数组是非常有帮助的，<a href="http://toughcoder.net/blog/2022/09/06/intro-to-binary-indexed-tree/">关于树状数组可以参考 此文</a>。</p>

<h2>拓展到后缀和最值</h2>

<p>前缀和是最常用的一种前缀辅助数组，但并不局限于此，也可以用后缀和，视具体情况而定。</p>

<p>另外，还可以拓展到最值，就是说前缀最值（最小值最大值），或者后缀最小值最大值，也可以帮助降低复杂度。</p>

<h2>典型问题</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/my-calendar-ii/">731. 我的日程安排表 II</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/my-calendar-ii/solution/by-alexhilton-bggq/">题解</a> </td>
<td style="text-align:left;"> TreeMap当作差分数组 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/partition-array-into-disjoint-intervals/">915. 分割数组</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/partition-array-into-disjoint-intervals/solution/by-alexhilton-9eh3/">题解</a> </td>
<td style="text-align:left;"> 后缀最小值辅助数组 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/global-and-local-inversions/">775. 全局倒置与局部倒置</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/global-and-local-inversions/solution/by-alexhilton-xagt/">题解</a> </td>
<td style="text-align:left;"> 后缀最小值 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.jianshu.com/p/2a4e861b44ae">差分数组</a></li>
<li><a href="https://blog.csdn.net/qq_31601743/article/details/105352885">什么是差分数组？</a></li>
<li><a href="https://blog.csdn.net/Miracle_ps/article/details/126573360">【LeetCode】一文吃透差分数组（附例题）</a></li>
<li><a href="https://blog.csdn.net/qq_44786250/article/details/100056975">差分数组是个啥？能干啥？怎么用？（差分详解+例题）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/117569086">【朝夕的ACM笔记】算法基础-前缀和</a></li>
<li><a href="https://blog.csdn.net/qq_45914558/article/details/107385862">前缀和【超详细讲解前缀和】</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/436526162">前缀和</a></li>
<li><a href="https://juejin.cn/post/7005057884555837476">面试必会的算法题——前缀和</a></li>
<li><a href="https://juejin.cn/post/6944913393627168798">什么是前缀和?</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/107778275">前缀和技巧</a></li>
<li><a href="https://blog.csdn.net/weixin_45629285/article/details/111146240">前缀和与差分 图文并茂 超详细整理（全网最通俗易懂）</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Dijkstra Algorithm]]></title>
    <link href="http://toughcoder.net/blog/2022/09/12/understanding-dijkstra-algorithm/"/>
    <updated>2022-09-12T10:49:54+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/12/understanding-dijkstra-algorithm</id>
    <content type="html"><![CDATA[<p>最短路径问题，是图论中经常遇到的问题，对于非加权图，用广度优先搜索（BFS）就可以找到两个顶点之间的最短路径（最少边数），但对于加权图，就需要用到著名的犾克斯特拉算法（<a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra Algorithm</a>）。</p>

<p><a href=""><img src="https://www.researchgate.net/profile/Atta_Ur_Rehman14/publication/331484960/figure/fig1/AS:732550733512704@1551665113143/Illustration-of-Dijkstras-algorithm.ppm" title="auto auto" ></a></p>

<!-- more -->


<h2>思路</h2>

<p>犾克斯特拉算法的核心思想是：</p>

<ol>
<li>以起步的顶点作为<strong>当前顶点</strong></li>
<li>检查当前顶点的所有邻接顶点，计算当前顶点到所有其邻接顶点的权重，并记录下来</li>
<li>从<strong>未访问过</strong>的邻接顶点中，选择一个总权重最小的顶点，作为下一个<strong>当前顶点</strong></li>
<li>重复第3步，直到图中所有的顶点都被访问过</li>
</ol>


<p>这样就能得到起步顶点到其他所有顶点的最短路径（最小权重）。</p>

<p><img src="https://img-blog.csdnimg.cn/201902261948522.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc5NTkyMQ==,size_16,color_FFFFFF,t_70" alt="" /></p>

<h2>实例</h2>

<p>前面的思路听起来还是不够清爽，我们来看一个具体的实例，比如计算不同的城市之间的飞行费用问题，就可以用Dijkstra算法来求解，一共有五个城市，以及它们之间的航班费用：</p>

<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>


<script>mermaid.initialize({startOnLoad:true});</script>


<div class="mermaid">
flowchart LR;
    A([Atlanta])
    B([Boston])
    C([Chicago])
    D([Denver])
    E([El Paso])
        A&#45;&#45; 100 &#45;&#45;>B;
    A&#45;&#45; 160 &#45;&#45;>D;    B&#45;&#45; 120 &#45;&#45;>C;    B&#45;&#45; 180 &#45;&#45;>D;    D&#45;&#45; 40 &#45;&#45;>C;
    D&#45;&#45; 140 &#45;&#45;>E;
    </div>


<p>以Atlanta为起点，来计算到其他几个城市的最小飞行费用，为方便用一个表格来展现Dijkstra算法的每一步：</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 步骤 </th>
<th style="text-align:left;"> 当前顶点 </th>
<th style="text-align:center;"> Atlanta </th>
<th style="text-align:center;"> Boston </th>
<th style="text-align:center;"> Chicago </th>
<th style="text-align:center;"> Denver </th>
<th style="text-align:center;"> El Paso </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 初始化 </td>
<td style="text-align:left;"> n/a </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:left;"> inf为正无穷，代表还未有计算的距离  </td>
</tr>
<tr>
<td style="text-align:left;"> 第1步<br/>起始顶点作为当前顶点 </td>
<td style="text-align:left;"> Atlanta </td>
<td style="text-align:center;"> 0 </td>
<td style="text-align:center;"> 100 </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:center;"> 160 </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:left;"> Atlanta能到达Boston和Denver，是邻接 的顶点 直接填权重 </td>
</tr>
<tr>
<td style="text-align:left;"> 第2步<br/>未访问顶点Boston和Denver中选择权重小的Boston </td>
<td style="text-align:left;"> Boston </td>
<td style="text-align:center;"> 0 </td>
<td style="text-align:center;"> 100 </td>
<td style="text-align:center;"> 220 </td>
<td style="text-align:center;"> 160 </td>
<td style="text-align:center;"> inf </td>
<td style="text-align:left;"> 到Boston的费用是100，以此为基础，<br/>Boston到Chicago是120，所以起始点到Chicago的费用是220。<br/>Boston到Denver是180再加上基础100就是280，它大于Atlanta直飞Denver，所以这个放弃 </td>
</tr>
<tr>
<td style="text-align:left;"> 第3步<br/>未访问的中Denver最小，所以用Denver </td>
<td style="text-align:left;"> Denver </td>
<td style="text-align:center;"> 0 </td>
<td style="text-align:center;"> 100 </td>
<td style="text-align:center;"> 200 </td>
<td style="text-align:center;"> 160 </td>
<td style="text-align:center;"> 300 </td>
<td style="text-align:left;"> 到Denver的费用是160，以此为基础，<br/>Denver到Chicago是40，经Denver到Chicago更划算，所以到Chicago更新为200；<br/>Denver还可以到达El Paso费用是300 </td>
</tr>
<tr>
<td style="text-align:left;"> 第4步<br/>未访问的中Chicago最小，所以用Chicago </td>
<td style="text-align:left;"> Chicago </td>
<td style="text-align:center;"> 0 </td>
<td style="text-align:center;"> 100 </td>
<td style="text-align:center;"> 200 </td>
<td style="text-align:center;"> 160 </td>
<td style="text-align:center;"> 280 </td>
<td style="text-align:left;"> 到Chicago的费用是200，以此为基础，<br/>Chicago到El Paso是80，经Chicago到El Paso更划算，所以到El Paso更新为280 </td>
</tr>
<tr>
<td style="text-align:left;"> 第5步<br/>只有El Paso未访问了，所以用El Paso </td>
<td style="text-align:left;"> El Paso </td>
<td style="text-align:center;"> 0 </td>
<td style="text-align:center;"> 100 </td>
<td style="text-align:center;"> 200 </td>
<td style="text-align:center;"> 160 </td>
<td style="text-align:center;"> 280 </td>
<td style="text-align:left;"> 到El Paso的费用是280，以此为基础，<br/>El Paso到Boston是100，不划算，所以不用更新。<br/>所有顶点都访问过了，这就是Atlanta出发到所有城市的最小飞行费用 </td>
</tr>
</tbody>
</table>


<h2>实现</h2>

<p>Dijkstra算法比较复杂，它的时间空间复杂度都比较高。算法的输入是一个加树图，和一个起始顶点，输出则是一个列表，表示起始顶点到其他顶点的最短路径。</p>

<h3>实现思路</h3>

<ol>
<li>创建一个结果列表，长度是顶点数量N，尽管其实不管起始顶点，但为了方便还是加上，用以存储起始顶点到所有顶点的最小距离，列表初始化为正无穷</li>
<li>创建一个标记列表，长度是N，用以标记顶点是否访问过，在选择下一个当前节点时，以及判断算法是否结束时，都需要用到此列表</li>
<li>选择实始顶点为当前顶点</li>
<li>把当前节点加入到标记列表中</li>
<li>更新最小距离列表：以当前顶点为基础，计算到它的每个邻接顶点的距离（也即基础值加上与其邻接的边的权重），如果距离小于结果列表中的距离，就更新结果列表</li>
<li>选择下一个当前顶点：遍历结果列表，找最小值，并且还未访问过（不在标记列表里），作为下一个当前顶点</li>
<li>重复第4到第6步，直到所有顶点都已标记，这时在第6步肯定 找不到下一个当前顶点</li>
</ol>


<h3>伪代码</h3>

<p>有了前面的实现思路，就不难写出伪代码：</p>

<pre><code>creat a list with length of N distanceList, init with MAX
create a set visitedSet
currentNode = start
distanceList[start] = 0
while currentNode is not null:
    add currentNode to visitedSet

    base = distanceList[currentNode]
    for each node adjacent with currentNode:
         if node.weight + base &lt; distanceList[node]:
              distanceList[node] = node.weight + base

    min = null
    for each node in distanceList:
        if node not in visitedSet and min &gt; distanceList[node]:
              min = node;
    currentNode = min
</code></pre>

<h3>示例代码</h3>

<p>到了代码层面的实现，需要灵活选择数据结构，如果顶点可以方便的用下标来代表的话，那么就可以用数组代替列表，否则可能就要使用哈希表。这里为了方便，用下标来代表顶点：0代表Atlanta，1代表Boston，2代表Chicago，3代表Denver，4代表El Paso，这样就都可以用数组来当列表用。</p>

<p>图用矩阵来表示，每一行代表到另一个城市的费用，其实默认值可以都用0，在计算费用时就不用特殊处理了，但为了体现邻接顶点，所以没有连通的顶点用-1，自己用0，相邻的顶点才有权重。</p>

<pre><code class="java">public class DijkstraAlgorithm {
    public static int[] dijkstra(int[][] graph, int start) {
        final int n = graph.length;
        int[] distance = new int[n];
        boolean[] visited = new boolean[n];
        Arrays.fill(distance, Integer.MAX_VALUE);
        Arrays.fill(visited, false);
        distance[start] = 0;
        int current = start;
        while (current != -1) {
            // Mark as current node as visited
            visited[current] = true;

            // Update the shortest distance for the nodes adjacent with current node
            final int base = distance[current];
            int[] neighbors = graph[current];
            for (int i = 0; i &lt; n; i++) {
                if (neighbors[i] == -1) {
                    // Skip not adjacent node
                    continue;
                }
                if (base + neighbors[i] &lt; distance[i]) {
                    distance[i] = base + neighbors[i];
                }
            }

            // Pick next current node
            int min = -1;
            for (int i = 0; i &lt; n; i++) {
                if (!visited[i] &amp;&amp; (min == -1 || distance[min] &gt; distance[i])) {
                    min = i;
                }
            }

            current = min;
        }

        return distance;
    }

    public static void main(String[] args) {
        String[] cities = {"Atlanta", "Boston", "Chicago", "Denver", "El Paso"};
        int[][] graph = {
                {0, 100, -1, 160, -1},
                {-1, 0, 120, 180, -1},
                {-1, -1, 0, -1, 80},
                {-1, -1, 40, 0, 140},
                {-1, 100, -1, -1, 0},
        };
        int start = 0;
        int[] shortestPath = dijkstra(graph, start);
        IntStream.range(start + 1, graph.length)
                .mapToObj(i -&gt; "Shortest distance from " + cities[start] + " to " + cities[i] + ": " + shortestPath[i])
                .forEach(System.out::println);
    }
}
</code></pre>

<p>输出结果：</p>

<pre><code>Shortest distance from Atlanta to Boston: 100
Shortest distance from Atlanta to Chicago: 200
Shortest distance from Atlanta to Denver: 160
Shortest distance from Atlanta to El Paso: 280
</code></pre>

<h2>应用</h2>

<p>Dijkstra算法只能用于有向无环加权图（DAG），且没有负权重的情况下，才可以正常工作。并且，它的复杂度较高，如果顶点数量为n，那么它的时间复杂度会达到O(n<sup>2</sup>)。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/">Dijkstra’s Shortest Path Algorithm</a></li>
<li><a href="https://www.freecodecamp.org/news/dijkstras-shortest-path-algorithm-visual-introduction/">Dijkstra&rsquo;s Shortest Path Algorithm - A Detailed and Visual Introduction</a></li>
<li><a href="https://www.programiz.com/dsa/dijkstra-algorithm">Dijkstra&rsquo;s Algorithm</a></li>
<li><a href="https://brilliant.org/wiki/dijkstras-short-path-finder/">Dijkstra&rsquo;s Shortest Path Algorithm</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/338414118">Dijkstra算法详解 通俗易懂</a></li>
<li><a href="https://blog.csdn.net/lbperfect123/article/details/84281300">Dijkstra算法图文详解</a></li>
<li><a href="https://blog.csdn.net/qq_35644234/article/details/60870719">最短路径问题&mdash;Dijkstra算法详解</a></li>
<li><a href="https://www.cnblogs.com/dijkstra2003/p/7222182.html">Dijkstra 最短路径算法 秒懂详解</a></li>
<li><a href="https://www.cnblogs.com/goldsunshine/p/12978305.html">一篇文章讲透Dijkstra最短路径算法</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图论基础知识]]></title>
    <link href="http://toughcoder.net/blog/2022/09/08/graph-data-structure-made-easy/"/>
    <updated>2022-09-08T18:05:45+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/08/graph-data-structure-made-easy</id>
    <content type="html"><![CDATA[<p>图（<a href="https://en.wikipedia.org/wiki/Graph_(abstract_data_type">Graph</a>)）是一个由节点和边组成的略复杂的二维数据结构，通常用于表示物体之间的关系。</p>

<p><a href=""><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.-HB8jzKKYmCKNH9ui2LDpwHaDH?pid=ImgDet&amp;rs=1" title="auto auto" ></a></p>

<!-- more -->


<h2>图的基础知识</h2>

<p>图由节点（Vertex）和边（Edge）组成，节点之间会有边来连接以表示某种关系。逻辑上的形状会是这样子的：
<img src="https://www.thecrazyprogrammer.com/wp-content/uploads/2017/08/Graph-Data-Structure.png" alt="" /></p>

<p>图的节点通常用于表示物体或者数值，变化较少，图的复杂性主要就体现在边上面，比如有些是有向的，有些是无向的，还有指向自己的。</p>

<h3>顶点</h3>

<p>顶点即Vertex，是图的基本单元，也称作节点。</p>

<h3>边</h3>

<p>边是Edge，两个顶点之间的连接称为边。分为无方向的，有方向的，和带权重的。</p>

<h3>权重</h3>

<p>权重，weight，是边的一个属性，一条边（也即两个顶点的连接）可以带有权重以表示某种成本。</p>

<h3>路径 Path</h3>

<p>在一个图中，路径是一系列节点和边，其中的节点都由边连接</p>

<h3>路径长度 Path length</h3>

<p>两个节点之间的边的数量称为路径长度</p>

<h3>简单路径 Simple Path</h3>

<p>一个路径所经过的节点没有重复的，就称为简单路径</p>

<h3>根 Root</h3>

<p>如果一个节点，由它出发的路径可以连通到所有节点，那么这个节点称作图根</p>

<h3>环 Cycle</h3>

<p>存在路径起始节点相同，就形成了环</p>

<h3>度 Degrees</h3>

<p>针对 节点而言，经过一个节点的所有边的数量之和，称之为节点的度</p>

<h3>入度 In degress</h3>

<p>对于有向图而言，以节点为终点的边的数量，称这节点的入度。</p>

<h3>出度 Out degrees</h3>

<p>对于有向图而言，从一个节点出发的边的数量，称为节点的出度。</p>

<h2>图的分类</h2>

<h3>空图 Null graph</h3>

<p>也就是只有顶点，没有边的图，样子大概是这样：</br>
<img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.QifCHVxIx4myhHIXgxapLQAAAA?pid=ImgDet&amp;rs=1" alt="" /></p>

<h3>有限图 Finite graph</h3>

<p>顶点和边的数量是有限的，接触到的绝大多数图都是有限图。</p>

<h3>无限图 Infinite graph</h3>

<p>顶点和边的数量是无限的</br>
<img src="https://www.researchgate.net/profile/David-Evans-81/publication/225108378/figure/fig1/AS:393838129631243@1470909735860/The-infinite-graph-A-6.png" alt="" /></p>

<h3>完全图 Complete graph</h3>

<p>所有节点都是有路径连通的</br>
<img src="https://miro.medium.com/max/7954/1*q0tQ1svUWfN05kWsZ_Uo2g.jpeg" alt="" /></p>

<h3>权重图 Weighted graph</h3>

<p>每一条边都有一个数值表示的权重以代表两个节点之间的某种成本</p>

<p><img src="https://i1.wp.com/algorithms.tutorialhorizon.com/files/2018/03/Weighted-Graph.png?ssl=1" alt="" /></p>

<h3>无向图 Undirected graph</h3>

<p>连接节点之间的边是没有方向的，称之为无向图，它也是普通 的图</p>

<h3>有向图 Directed graph</h3>

<p>每条边都是有方向的，对于两个节点来说v[i]和v[j]来说，e[i,j]=(v[i],v[j])，它与e[j,i]=(v[j],v[i])是不一样的，有向图通常用于表示物体之间的依赖关系</p>

<p><img src="https://www.filepicker.io/api/file/1KMTR25HS2OzpZcpy0mJ" alt="" /></p>

<h3>连通图 Connected graph</h3>

<p>任意两节点都连通，称之为连通图也叫强连通图。</p>

<h3>非连通图 Disconnected graph</h3>

<p>有两个节点没有边连接，就称为非连通图。</p>

<h3>自环</h3>

<p>也就是某个节点有一条边是自己连接着自己，这个有向和无向图都可以有</p>

<h3>有环图 Cyclic graph</h3>

<p>起点和终点相同的路径，就形成了环。如果图中存在一个环，就是有环图。</p>

<p><img src="https://www.droidtechknow.com/programming/data-structure/an-introduction-to-graph-data-structure/images/graph-example.jpg" alt="" /></p>

<h3>无环图 Acyclic graph</h3>

<p>图中没有环就是无环图</p>

<h3>有向无环图 Directed Acyclic Graph</h3>

<p>有向图中不存在环就是DAG，这是比较重要的一种图，拓扑排序 可以验证DAG。</p>

<p><img src="https://wiki.swarma.org/images/c/cd/A_DAG_G.png" alt="" /></p>

<ul>
<li><a href="https://www.geeksforgeeks.org/introduction-to-graphs/">Introduction to Graphs</a></li>
</ul>


<h2>图的表示方法</h2>

<p>图的表示方法一般有邻接矩阵法和邻接表法。</p>

<h3>邻接矩阵 Adjacency Matrix</h3>

<p>对于有n个顶点的图来说要创建一个nxn的矩阵来表示此图，每一个格子[i,j]表示顶点v[i]到v[j]是连通的，有一条边存在，如果是有向图，则[j,i]表示v[j]到v[i]的边。另外，如果有权重，格子的值也可以表示边的权重。
<img src="https://educativesite.com/wp-content/uploads/2019/09/incidence-matrix.png" alt="" />
因为用矩阵一般比较浪费空间，比如顶点较多，但边较少时，就有点浪费空间。一般，矩阵通常就是一类单独的矩阵类搜索问题，直接应用图的搜索方法。</p>

<h3>邻接表 Adjacency List</h3>

<p>也就是列表的列表，先用一个链表代表所有的顶点，然后这个链表的元素是这个与这个顶点相连的所有顶点组成的列表。
<img src="https://cdn.programiz.com/sites/tutorial2program/files/adjacency-list.png" alt="" />
通常是用数组加链表的形式，主表用数组或者可变长数组，因为这些都是顶点，有可能会随时从某个顶点开始遍历，所以要用随机访问效率高一些的数组。与顶点相连的顶点列表一般用链表，因为它方便删除和插入，且遍历一般都是从顶点开始遍历。</p>

<p><img src="https://ts1.cn.mm.bing.net/th/id/R-C.4fe11a408a41fa5509274d85a4c09c1f?rik=YfKo9VJ94v7kxw&amp;riu=http%3a%2f%2fprogressivecoder.com%2fwp-content%2fuploads%2f2020%2f12%2fadjacency-list.png&amp;ehk=WAS3o3piPNsR6QCXSeDCVsjO%2fcuyO6KisgW5kv4uwYQ%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" /></p>

<p>但，也要看实际情况，有时候用哈希表也可以，键是每个顶点，值为顶点所连接的顶点列表，顶点列表可以用列表，也可以用Set等等。</p>

<p><img src="https://condor.depaul.edu/glancast/393class/docs/images/topsort7C++.gif" alt="" /></p>

<p>邻接表的实现方式比较自由，只要能从一个顶点出发，方便的找到与其相连的顶点，就可以。具体的，可以依据实际数据情况来灵活选择，比如说顶点如果是某一个范围内的整数，那么可能用数组就更方便一些，如果是字串或者其他的，可能用哈希表就更方便一些。</p>

<ul>
<li><a href="https://www.geeksforgeeks.org/graph-and-its-representations/">Graph and its representations</a></li>
</ul>


<h2>图与树的关系</h2>

<p>图是一个比较大的概念，只要是有节点与节点相连接就可以看作是图，数组（可视为下标与元素的连接），哈希表（键与值的连接），树，链表都可以看作是图。这些数据结构是一种特殊的图，强加了很多其他规则，就比如树，有一个根，有多个子节点。</p>

<p><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.sELEF-9VK_G1wwU413LUFgAAAA?pid=ImgDet&amp;rs=1" alt="" /></p>

<p>适用于图的很多算法也适用树，比如DFS和BFS对树也是适用的。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/">Graph Data Structure And Algorithms</a></li>
<li><a href="https://www.programiz.com/dsa/graph">Graph Data Stucture</a></li>
<li><a href="https://medium.com/data-structures-and-algorithms/graph-dd2b72c32f1f">Graph</a></li>
<li><a href="https://www.simplilearn.com/tutorials/data-structure-tutorial/graphs-in-data-structure">Your One-Stop Solution For Graphs In Data Structures</a></li>
<li><a href="https://www.runoob.com/data-structures/graph-theory.html">图论基础和表示</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/124259930">【朝夕的ACM笔记】图论-图论基础概念</a></li>
<li><a href="https://blog.csdn.net/Karen_Yu_/article/details/78776354">图论基础知识总结（一）</a></li>
<li><a href="https://cuigeg.github.io/2017/06/27/Graph-theory/">这一点点的图论基础</a></li>
<li><a href="https://labuladong.github.io/algo/2/22/50/">图论基础及遍历算法</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1922486">图论算法基础（修订版）</a></li>
<li><a href="https://www.cnblogs.com/BlairGrowing/p/13637688.html">图论&mdash;-基础知识 </a></li>
</ul>

]]></content>
  </entry>
  
</feed>
