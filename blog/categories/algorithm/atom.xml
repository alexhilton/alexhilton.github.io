<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2022-09-08T21:51:32+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[图论基础知识]]></title>
    <link href="http://toughcoder.net/blog/2022/09/08/graph-data-structure-made-easy/"/>
    <updated>2022-09-08T18:05:45+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/08/graph-data-structure-made-easy</id>
    <content type="html"><![CDATA[<p>图（<a href="https://en.wikipedia.org/wiki/Graph_(abstract_data_type">Graph</a>)）是一个由节点和边组成的略复杂的数据结构，通常用于表示物体之间的关系。</p>

<p><a href=""><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.-HB8jzKKYmCKNH9ui2LDpwHaDH?pid=ImgDet&amp;rs=1" title="auto auto" ></a></p>

<!-- more -->


<h2>图的基础知识</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/introduction-to-graphs/">Introduction to Graphs</a>

<h2>图的表示方法</h2></li>
<li><a href="https://www.geeksforgeeks.org/graph-and-its-representations/">Graph and its representations</a>

<h2>参考资料</h2></li>
<li><a href="https://www.geeksforgeeks.org/graph-data-structure-and-algorithms/">Graph Data Structure And Algorithms</a></li>
<li><a href="https://www.programiz.com/dsa/graph">Graph Data Stucture</a></li>
<li><a href="https://medium.com/data-structures-and-algorithms/graph-dd2b72c32f1f">Graph</a></li>
<li><a href="https://www.simplilearn.com/tutorials/data-structure-tutorial/graphs-in-data-structure">Your One-Stop Solution For Graphs In Data Structures</a></li>
<li><a href="https://www.runoob.com/data-structures/graph-theory.html">图论基础和表示</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/124259930">【朝夕的ACM笔记】图论-图论基础概念</a></li>
<li><a href="https://blog.csdn.net/Karen_Yu_/article/details/78776354">图论基础知识总结（一）</a></li>
<li><a href="https://cuigeg.github.io/2017/06/27/Graph-theory/">这一点点的图论基础</a></li>
<li><a href="https://labuladong.github.io/algo/2/22/50/">图论基础及遍历算法</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1922486">图论算法基础（修订版）</a></li>
<li><a href="https://www.cnblogs.com/BlairGrowing/p/13637688.html">图论&mdash;-基础知识 </a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解并运用并查集]]></title>
    <link href="http://toughcoder.net/blog/2022/09/08/disjoint-set-data-structure/"/>
    <updated>2022-09-08T17:27:05+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/08/disjoint-set-data-structure</id>
    <content type="html"><![CDATA[<p><a href="">并查集</a>（<a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">Disjoint-set Data Structure</a>）是一种树形的结构，用于处理不相交的集合的高效的查询(find)和合并(union)问题。主要有两种操作一是查询(find)，也就是查询某个元素是否属于某个集合；二是合并(union)，也即把某个加入到某个集合中，这里的集合都是无交集的。通过路径压缩，并查集的查询和合并都可以达到常数级别O(1)。</p>

<p><a href=""><img src="https://images.xiaozhuanlan.com/photo/2019/891afdf6961c0eab3d3aa28a3f355e12.png" title="auto auto" ></a></p>

<!-- more -->


<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/disjoint-set-data-structures/">Disjoint Set Data Structures</a></li>
<li><a href="https://cp-algorithms.com/data_structures/disjoint_set_union.html">Disjoint Set Union</a></li>
<li><a href="https://www.javatpoint.com/disjoint-set-data-structure">Disjoint set data structure</a></li>
<li><a href="https://www.techiedelight.com/disjoint-set-data-structure-union-find-algorithm/">Disjoint–Set Data Structure (Union–Find Algorithm)</a></li>
<li><a href="https://www.hackerearth.com/practice/notes/disjoint-set-union-union-find/">Disjoint Set Union (Union Find)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/93647900">算法学习笔记(1) : 并查集</a></li>
<li><a href="https://oi-wiki.org/ds/dsu/">并查集</a></li>
<li><a href="https://www.cnblogs.com/onlyblues/p/14668087.html">并查集算法 </a></li>
<li><a href="https://segmentfault.com/a/1190000022952886">图解并查集，附赠几道 Leetcode 练手题</a></li>
<li><a href="https://blog.csdn.net/weixin_44176696/article/details/106434770">简单并查集讲解（并+查）与代码实现</a></li>
<li><a href="https://zh-spike.github.io/studyRepo/Algorithm/Notes/AdvancedDataStructure/%E5%B9%B6%E6%9F%A5%E9%9B%86/">并查集</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解拓扑排序]]></title>
    <link href="http://toughcoder.net/blog/2022/09/08/topological-sorting/"/>
    <updated>2022-09-08T16:41:37+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/08/topological-sorting</id>
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/5223807">拓扑排序</a>（<a href="https://en.wikipedia.org/wiki/Topological_sorting">Topological Sorting</a>）是指将一个有向无环图（Directed Acyclic Graph）的所有顶点排成一个线性序列，使得图中的起始节点总是排在终止节点的前面，这是有向图每一个边都有起始节点和终止节点。这个名字有点容易混淆，它跟排序算法没有任何关系，拓扑排序仅是针对有向无环图，找到所有节点的一个可达的线性顺序。</p>

<p><a href=""><img src="https://iq.opengenus.org/content/images/2020/03/topo1-1.png" title="auto auto" ></a></p>

<!-- more -->


<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/topological-sorting/">Topological Sorting</a></li>
<li><a href="https://www.interviewcake.com/concept/java/topological-sort">Topological Sort</a></li>
<li><a href="https://www.hackerearth.com/practice/algorithms/graphs/topological-sort/tutorial/">Topological Sort</a></li>
<li><a href="https://www.scaler.com/topics/data-structures/topological-sort-algorithm/">Topological Sort Algorithm</a></li>
<li><a href="https://cp-algorithms.com/graph/topological-sort.html">Topological Sorting</a></li>
<li><a href="https://www.javatpoint.com/topological-sorting">Topological Sorting</a></li>
<li><a href="https://songlee24.github.io/2015/05/07/topological-sorting/">拓扑排序（Topological Sorting）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/135094687">图文详解面试常考算法 —— 拓扑排序</a></li>
<li><a href="https://oi-wiki.org/graph/topo/">拓扑排序</a></li>
<li><a href="https://www.cnblogs.com/bigsai/p/11489260.html">拓扑排序详解与实现</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记忆化搜索简介]]></title>
    <link href="http://toughcoder.net/blog/2022/09/08/memorization-search/"/>
    <updated>2022-09-08T16:03:31+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/08/memorization-search</id>
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/4275706">记忆化搜索</a>（Memorization Search），是指在做搜索过程中（比如DFS或者动态规划中）把重叠的子问题的解或者状态存储下来，以防止重复计算。最为常见的就是图搜索方法BFS和DFS时都要对已搜索过的节点进行标记以防止重复遍历，这就是一种记忆化搜索方法。再如动态规划的重复子问题，用数组进行缓存以防止重复计算，这也是一种记忆化搜索方法。</p>

<p><a href=""><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.3-yxYgu36IJsH2oONsdqFQHaEe?pid=ImgDet&amp;rs=1" title="auto auto" ></a></p>

<!-- more -->


<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/memoization-1d-2d-and-3d/">Memoization (1D, 2D and 3D)</a></li>
<li><a href="https://oi-wiki.org/dp/memo/">记忆化搜索</a></li>
<li><a href="https://blog.csdn.net/hjf1201/article/details/78680814">记忆化搜索专题</a></li>
<li><a href="https://blog.csdn.net/u010700335/article/details/44136339">记忆化搜索（搜索+dp思想）</a></li>
<li><a href="https://www.cnblogs.com/jinkun113/p/12531918.html">[知识点] 4.1 记忆化搜索与动态规划</a></li>
<li><a href="https://www.zhihu.com/question/60730045">记忆化搜索与动态规划等价吗？</a></li>
<li><a href="http://yudaer.github.io/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/">记忆化搜索</a></li>
<li><a href="https://www.luogu.com.cn/blog/interestingLSY/memdfs-and-dp">聊聊动态规划与记忆化搜索</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/438406757">记忆化搜索 —— 搜索 or 动态规划 ？</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[动态规划从入门到放弃]]></title>
    <link href="http://toughcoder.net/blog/2022/09/08/introduction-to-dynamic-programming/"/>
    <updated>2022-09-08T11:26:06+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/08/introduction-to-dynamic-programming</id>
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/529408">动态规划</a>(<a href="https://en.wikipedia.org/wiki/Dynamic_programming">Dynamic Programming</a>)动态规划是用来求解具有最优子结构性质问题的一种方法。通俗的来说如果一个问题可以分成多个子问题或者分成多个步骤，每个子问题有多个解或者每个步骤有多个选择，最终求整体问题的一个最优解（最大值，最小值，方法总数，是否可行等等），这样的问题就适合用动态规划来求解。</p>

<p>动态规划一般可分为自顶而下式和自下而上式，自顶而下是通过递归，但因为涉及大量重复计算而导致时间复杂度过高，所以一般都是采用自下而上式，借助额外的空间来缓存子问题的解，减少重复计算从而降低时间复杂度，与<a href="https://baike.baidu.com/item/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/4275706">记忆化搜索</a>有点类似。</p>

<p><a href=""><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.1-yqbboBtUIUqcYV1V1p5gHaEK?pid=ImgDet&amp;rs=1" title="auto auto" ></a></p>

<!-- more -->


<h2>动态规划的适用范围</h2>

<h3>最优子结构性质</h3>

<p><a href="https://blog.csdn.net/lanchunhui/article/details/52480106">最优子结构特性</a>（<a href="https://en.wikipedia.org/wiki/Optimal_substructure">Optimal Substructure</a>）是指一个问题可以分成多个子问题，每个问题的最优解凑成整个问题的最优解。</p>

<h3>重叠子问题性质</h3>

<p>重叠子问题(<a href="https://en.wikipedia.org/wiki/Overlapping_subproblems">Overlapping subproblems</a>)是指一个问题可以分成多个子问题，每个子问题的解会重复使用多次，也就说后一个子问题的解需要使用到前一个子问题的解。最为典型的就是Fibonacci数列，也就是常说的自上而下的方式来实现动态规划（递归式），因为子问题重复，所以为了提升效率必须把子问题的解存储下来以防止重复计算。</p>

<h2>寻找状态转移方程</h2>

<p>动态规划并不像排序或者二分查找那样有具体的形式，它更是一种策略而非具体的算法，发现一个题目可以用动态规划求解时，还远远不够，要想写出代码，必须推导出来状态转移方程，这才是动态规划的核心，而动态如何定义，又如何转移要视具体的问题而定变化万千，所以说动态规划是最难的一类题，没有之一。</p>

<p>一般而言状态转移方程要以结果为导向，也就是说用这个方程能得到问题的解，这依然是一句废话，要通过大量的练习才能掌握。</p>

<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.programiz.com/dsa/dynamic-programming">Dynamic Programming</a></li>
<li><a href="https://towardsdatascience.com/understanding-dynamic-programming-75238de0db0d">Understanding Dynamic Programming</a></li>
<li><a href="https://www.geeksforgeeks.org/dynamic-programming/">Dynamic Programming</a></li>
<li><a href="https://www.freecodecamp.org/news/demystifying-dynamic-programming-3efafb8d4296/">Demystifying Dynamic Programming</a></li>
<li><a href="http://web.mit.edu/15.053/www/AMP-Chapter-11.pdf">Dynamic Programming</a></li>
<li><a href="https://www.javatpoint.com/dynamic-programming">Dynamic Programming</a></li>
<li><a href="https://oi-wiki.org/dp/">动态规划部分</a></li>
<li><a href="https://juejin.cn/post/6951922898638471181">看一遍就理解：动态规划详解</a></li>
<li><a href="https://houbb.github.io/2020/01/23/data-struct-learn-07-base-dp">五大基本算法之动态规划算法 DP dynamic programming</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/137992855">一文搞定动态规划问题（附DP所有问题链接）</a></li>
<li><a href="https://www.zhihu.com/question/23995189">什么是动态规划（Dynamic Programming）？动态规划的意义是什么？</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1692068">动态规划一篇就够了 全网第二详细, 逐步理解, 万字总结</a></li>
<li><a href="https://blog.csdn.net/u013309870/article/details/75193592">算法-动态规划 Dynamic Programming&ndash;从菜鸟到老鸟</a></li>
<li><a href="https://www.javatpoint.com/optimal-substructure-property">Optimal Substructure Property</a></li>
<li><a href="https://stackoverflow.com/questions/33563230/optimal-substructure-in-dynamic-programing">Optimal substructure in Dynamic Programing</a></li>
<li><a href="https://afteracademy.com/blog/optimal-substructure-and-overlapping-subproblems">Optimal Substructure and Overlapping Subproblems</a></li>
<li><a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84.md">动态规划答疑篇</a></li>
<li><a href="https://www.zhihu.com/question/52165201">动态规划的最优子结构问题，有什么样的问题它不满足最优子结构？</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1695752">深入浅出理解动态规划（二） | 最优子结构</a></li>
<li><a href="https://blog.nowcoder.net/n/7390417560b54107b421b13b47adea88">动态规划（最优子结构、重叠子问题）——附代码示例</a></li>
<li><a href="https://www.geeksforgeeks.org/overlapping-subproblems-property-in-dynamic-programming-dp-1/">Overlapping Subproblems Property in Dynamic Programming | DP-1</a></li>
<li><a href="https://www.geeksforgeeks.org/optimal-substructure-property-in-dynamic-programming-dp-2/?ref=lbp">Optimal Substructure Property in Dynamic Programming | DP-2</a></li>
<li><a href="https://stackoverflow.com/questions/64499367/what-are-overlapping-subproblems-in-dynamic-programming-dp">What are overlapping subproblems in Dynamic Programming (DP)?</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
