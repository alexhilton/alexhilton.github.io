<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2022-08-24T23:32:05+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[线段树让你不再惧怕区间问题]]></title>
    <link href="http://toughcoder.net/blog/2022/08/23/rmq-made-easy/"/>
    <updated>2022-08-23T23:58:27+08:00</updated>
    <id>http://toughcoder.net/blog/2022/08/23/rmq-made-easy</id>
    <content type="html"><![CDATA[<p><a href=""><img src="https://ts1.cn.mm.bing.net/th/id/R-C.c6c6bbd2b56e8b5c9ddc2dbf1e889309?rik=14ZVI1eUra2OGw&amp;riu=http%3a%2f%2fmedianet.kent.edu%2fsurveys%2fIAD06S-p2psearch-alok%2fimages%2fmin_max_range.jpg&amp;ehk=e1Pnkh9cs9629hf15dVM5nTmu9iDMqxP5Oo4iZy7jCc%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0)" title="auto auto" ></a></p>

<!-- more -->


<h2>典型问题</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/">1450. 在既定时间做作业的学生人数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/solution/by-alexhilton-60ye/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/my-calendar-ii/">731. 我的日程安排表 II</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/my-calendar-ii/solution/by-alexhilton-bggq/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/my-calendar-i/">729. 我的日程安排表 I</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/my-calendar-i/solution/by-alexhilton-ovl9/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-intervals/solution/by-alexhilton-a3ie/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://blog.csdn.net/huangzihaoal/article/details/81813454">【算法】线段树详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/106118909">算法学习笔记(14): 线段树</a></li>
<li><a href="https://oi-wiki.org/ds/seg/">线段树 OI Wiki</a></li>
<li><a href="https://www.cnblogs.com/AC-King/p/7789013.html">线段树详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/34150142">史上最详细的线段树教程</a></li>
<li><a href="https://www.cnblogs.com/RioTian/p/13409694.html">线段树 - 多组图带你从头到尾彻底理解线段树</a></li>
<li><a href="https://halfrost.com/segment_tree/">线段树 Segment Tree 实战</a></li>
<li><a href="https://blog.csdn.net/Yaokai_AssultMaster/article/details/79599809">线段树（segment tree)，看这一篇就够了</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编码常见技巧总结]]></title>
    <link href="http://toughcoder.net/blog/2022/08/23/most-used-tricks/"/>
    <updated>2022-08-23T11:04:45+08:00</updated>
    <id>http://toughcoder.net/blog/2022/08/23/most-used-tricks</id>
    <content type="html"><![CDATA[<p>在日常编码中有一些非常常用，但却很细节的小技巧，虽然有朴素的实现的方式，但如果能掌握一些高级技巧不但性能会更好，并且因为技巧比较流行，也不会影响可读性。最简单的例子就是除2和乘2，当然可以直接用乘法和除法，但如果用移位效果更好，也并不影响可读性，因为这是比较流行的做法。</p>

<p>这里就将总结一些常用的小技巧，以供日后查阅。</p>

<p><a href=""><img src="https://ts1.cn.mm.bing.net/th/id/R-C.3a082402d0c427749a5631fdbf6b98cc?rik=bx2gAAoi%2fUTUEw&amp;riu=http%3a%2f%2fpetbehavior.org%2fwp-content%2fuploads%2f2010%2f11%2fUSEFUL-DOG-TRICKS.jpg&amp;ehk=xPrkIcwPXM0ubFuXq9oLP96I0rTpkGU4RwClXsZbQpw%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" title="auto auto" ></a></p>

<!-- more -->


<h2>整数相关技巧</h2>

<h3>判断奇偶</h3>

<pre><code class="java">// 1. 朴素做法
if (n % 2 == 0) {
   // even
} else {
    // odd
}
// 2. 用移位
if ((n &amp; 0x01) == 0) {
   // even
} else {
  // odd
}
</code></pre>

<h3>乘2</h3>

<pre><code class="java">// 左移1位，相当于乘2
n &lt;&lt;= 1;
</code></pre>

<h3>除2</h3>

<pre><code class="java">// 右移1位，相当于除2
n &gt;&gt;= 1
</code></pre>

<h3>求2的k次幂</h3>

<pre><code class="java">// 朴素做法
a = (int) Math.pow(2, k);
// 1左移k次，就是2的k次幂
a = 1 &lt;&lt; k;
</code></pre>

<h2>边界</h2>

<h3>二分查找中间防溢出</h3>

<p>二分查找通常要计算区间的中间，比如这样：
<code>java
int left = 1;
int right = n;
while (left &lt; right) {
    int mid = (left + right) &gt;&gt; 1;
}
</code>
但这样计算有问题，当区间特别大时，比如超过了最大整数的一半时，那么用相加来计算就会整数溢出，从而出问题。更好的做法是用减法：
<code>java
int mid = left + ((right - left) &gt;&gt; 1);
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二叉树从入门到放弃]]></title>
    <link href="http://toughcoder.net/blog/2022/08/18/binary-tree-made-easy/"/>
    <updated>2022-08-18T21:59:41+08:00</updated>
    <id>http://toughcoder.net/blog/2022/08/18/binary-tree-made-easy</id>
    <content type="html"><![CDATA[<p>树是非常常见的一种数据结构，有着广泛的应用，而二叉树又是树中最最常见的树，值得好好的学习和总结。
树的定义可以<a href="https://www.programiz.com/dsa/trees">参考这里</a>，二叉树Binary Tree的定义<a href="http://cslibrary.stanford.edu/110/BinaryTrees.html#:~:text=A%20binary%20tree%20is%20made%20of%20nodes%2C%20where,binarytree%20with%20no%20elements%20--%20the%20empty%20tree.">在这里</a>，还有<a href="https://www.javatpoint.com/binary-search-tree">二叉搜索树Binar Search Tree</a>。</p>

<p><a href=""><img src="https://ts1.cn.mm.bing.net/th/id/R-C.0443658c5d6fda4db7615ed681a39cca?rik=H4456L%2b5IJAkrg&amp;riu=http%3a%2f%2f108.61.119.12%2fwp-content%2fuploads%2f2014%2f10%2fbinary-tree-1-pre-order.gif&amp;ehk=d%2bxB8RQ0QrVVDnUp8Zeo2ICWUFYmxcqCWMc2WIGlzmY%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" title="auto auto" ></a></p>

<!-- more -->


<h2>二叉树的常规遍历</h2>

<p>二叉树的常规遍历，其实也是<strong>深度优先</strong>遍历，分为三种先序，中序和后序。这里的所谓的前中后，是指<strong>子节点相对于根节点而言的</strong>。对于一个最小的二叉树，也就是只有一个左子节点和右子节点的树来说，先序，就是左右子节点在根节点之后，也即根在最前面，中序就是根在左右中间，而后序则是根在最后。以这个『1, 2, 3』为倒的最小树来说，前序即是[1, 2, 3]，中序是[2, 1, 3]而后序 是[2, 3, 1]。</p>

<p><img src="https://res.cloudinary.com/practicaldev/image/fetch/s--XWH6osdb--/c_imagga_scale,f_auto,fl_progressive,h_420,q_auto,w_1000/https://dev-to-uploads.s3.amazonaws.com/i/3072o3znskwf4wkbqshz.png" alt="" /></p>

<p>左子节点总是在右子节点前面，左子树总是在右子树前面的，且从整体树来看，遍历的顺序仍旧是<strong>从左下到右下</strong>，所以需要先找到最左下的一颗最小子树。</p>

<h3>递归式</h3>

<h3>迭代式</h3>

<h3>逆序遍历</h3>

<p>前面说了，二叉树的常规遍历仍旧是从左下向右下的，如果看成数组，那就相当于是从前往后的。但有些情况吧，逆序遍历会更方便，也跟数组一样，有时候从后向前遍历更为合适。逆序遍历并不难，只需要把左右子树的处理换个位置就行了，先找到最右下的最小子树，从右下往左下走。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">  <a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/solution/114-er-cha-shu-zhan-kai-wei-lian-biao-by-3mke/">题解</a></td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/most-frequent-subtree-sum/">508. 出现次数最多的子树元素和</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/most-frequent-subtree-sum/solution/by-alexhilton-ab5a/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/">538. 把二叉搜索树转换为累加树</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/solution/by-alexhilton-c8a0/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/by-alexhilton-q14h/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>二叉树的层序遍历</h2>

<p>也即是广度优先遍历，但普通的广度优先一般没啥用，实际题目中用的最多是层序遍历。</p>

<h3>基础广度优先遍历</h3>

<p>借助队列，先把根节点加入队列，利用队列的先进先出特性，从队首取出一个节点，并把它的子节点加入到队尾，直到队列为空为止，这样的遍历顺序 便是 基础的广度优先，但在实际中基本没啥用。</p>

<pre><code class="java">queue.offer(root);
while (!queue.isEmpty()) {
    TreeNode node = queue.poll();
    System.out.print(node.val);
    if (node.left != null) {
        queue.offer(node.left);
    }
    if (quuee.right != null) {
        queue.offer(node.right);
    }
}
</code></pre>

<h3>层序遍历</h3>

<p>树的特点是一层是父节点，一层是子节点，知道了父节点层，就能找到子节点层，要想对子节点层做操作必须知道其父节点层。因此层序遍历在实际题目中应用很广泛。</p>

<p>如何能知道每一层呢？其实如果能知道一层，就能知道其下一层，它们是递进的关系，也就分开了。幸运的是我们知道第一层（或者说最上面一层）对，它就是根节点，从它开始，就能找出每一层。具体的做法可以用计数法，计算每层的节点数，用以分
开；也可以用双队列法，一层存放父节点，一层存放子节点，然后交换两个列表，个人喜欢使用双队列法。</p>

<p>具体可以参考以下文章，以及题目中的题解都比较详细，就不重复了。</p>

<ol>
<li><a href="https://leetcode.cn/leetbook/read/data-structure-binary-tree/xej9yc/">层序遍历 - 介绍</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-by-leetcode-solution/">二叉树的层序遍历</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/solution/die-dai-di-gui-duo-tu-yan-shi-102er-cha-shu-de-cen/">迭代+递归 多图演示 102.二叉树的层次遍历</a></li>
</ol>


<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/solution/by-alexhilton-iv95/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/">107. 二叉树的层序遍历 II</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/solution/107-er-cha-shu-de-ceng-xu-bian-li-ii-by-2sibx/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/find-bottom-left-tree-value/">513. 找树左下角的值</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/find-bottom-left-tree-value/solution/by-alexhilton-m79i/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515. 在每个树行中找最大值</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/solution/by-alexhilton-6j1a/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/complete-binary-tree-inserter/">919. 完全二叉树插入器</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/complete-binary-tree-inserter/solution/by-alexhilton-msqn/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/add-one-row-to-tree/">623. 在二叉树中增加一行</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/add-one-row-to-tree/solution/623-zai-er-cha-shu-zhong-zeng-jia-yi-xin-4hn1/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/">1161. 最大层内元素和</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-level-sum-of-a-binary-tree/solution/by-alexhilton-anlb/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/deepest-leaves-sum/">1302. 层数最深叶子节点的和</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/deepest-leaves-sum/solution/1302-ceng-shu-zui-shen-xie-zi-jie-dian-d-o5my/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>路径相关问题</h2>

<p>路径定义不尽相同，有些路径是从根节点到叶子的算路径，有些则不必，前面说的都是竖着的路径，也就是从根节点出发到叶子节点，而有些则可以横着的，比如从左子节点经过根节点到右边节点的路径。路径相关的问题很多，且难度上升级一个量级，通常涉及动态规划。</p>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/binary-tree-paths/solution/by-alexhilton-xjyj/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/path-sum/solution/by-alexhilton-8y7e/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/solution/124-er-cha-shu-zhong-de-zui-da-lu-jing-h-deqd/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/diameter-of-binary-tree/solution/by-alexhilton-0ncn/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/solution/by-alexhilton-l5q4/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>二叉搜索树</h2>

<p>二叉搜索树Binary Search Tree（常简称作BST），是一种特殊的二叉树，它保证左子树小于根节点小于右子树，如果以中序遍历BST得到的会是一个严格递增的序列。
<img src="https://leetcode.com/problems/binary-search-tree-iterator/Figures/173/appr_1.png" alt="" />
<strong>BST是一个严格递增的序列</strong>，这就是BST的本质，与BST有关的题都要应用<strong>二分查找</strong>：从根节点开始，目标值等于当前节点值，就找到目标了，小于节点值就向左找，大于就向右找。写成代码就是这样：</p>

<pre><code class="java">TreeNode node = root;
while (node != null) {
    if (node.val == target) {
        return node;
    } else if (node.val &lt; target) {
        node = node.right;
    } else {
        node = node.left;
    }
}
return null;
</code></pre>

<p>这与<strong>二分查找</strong>是一样的，这就是BST的本质，深刻理解 了它的本质后，一切问题都会迎刃而解。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/solution/by-alexhilton-ufe4/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/solution/by-alexhilton-4nxa/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/validate-binary-search-tree/solution/by-alexhilton-eqbp/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/">235. 二叉搜索树的最近公共祖先</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/solution/by-alexhilton-yvgi/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/">653. 两数之和 IV - 输入 BST</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/two-sum-iv-input-is-a-bst/solution/by-alexhilton-o064/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://blog.csdn.net/Real_Fool_/article/details/113930623">数据结构：树(Tree)【详解】</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/90255760">数据结构中&#8221;树&#8221;的全面讲解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/443034942">数据结构&mdash;树（彻底理解递归算法）</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/solution/er-cha-shu-de-qian-xu-bian-li-by-leetcode-solution/">二叉树的前序遍历</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode-solutio/">二叉树的中序遍历</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/solution/dong-hua-yan-shi-94-er-cha-shu-de-zhong-xu-bian-li/">动画演示+三种实现 94. 二叉树的中序遍历</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/er-cha-shu-de-hou-xu-bian-li-by-leetcode-solution/">二叉树的后序遍历</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/solution/bang-ni-dui-er-cha-shu-bu-zai-mi-mang-che-di-chi-t/">「代码随想录」帮你对二叉树不再迷茫，彻底吃透前中后序递归法（递归三部曲）和迭代法（不统一写法与统一写法）
</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/solution/leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2/">史上最全遍历二叉树详解</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/solution/tu-jie-er-cha-shu-de-si-chong-bian-li-by-z1m/">图解 二叉树的四种遍历</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[表达式求值问题总结]]></title>
    <link href="http://toughcoder.net/blog/2022/08/18/solve-expression-evaluation/"/>
    <updated>2022-08-18T21:15:04+08:00</updated>
    <id>http://toughcoder.net/blog/2022/08/18/solve-expression-evaluation</id>
    <content type="html"><![CDATA[<p>在模拟范畴内表达式运算求值是比较典型的一类问题。</p>

<p><a href=""><img src="https://www.wikihow.com/images/thumb/7/73/Evaluate-an-Algebraic-Expression-Step-9.jpg/aid3181794-v4-728px-Evaluate-an-Algebraic-Expression-Step-9.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>问题分类</h2>

<p>表达式类问题一般输入都是以字串形式，所以第一个要点就是把一个字符串按语义拆解为符号，操作符和操作数。</p>

<p>第二个要点就是表达式的运算。</p>

<p>形式上又可分为后缀式和中缀式（也即正常顺序）。</p>

<p>操作符有些是只有加减法，有些则四则运算都有，这个会让难度上一个层次。</p>

<p>最难搞的就是括号，如果有括号的话，会让难度直接上一个数量级。</p>

<p>绝大多数场景都要用到栈，对于复杂的运算（四则）和有括号，因为涉及优先级和嵌套，所以要用到双栈，一个栈存操作符，一个栈存操作数。</p>

<h2>要点分析</h2>

<p>第一步就是拆解字串，把其分解成为<strong>操作符，符号</strong>和<strong>操作数</strong>。在拆解的时候最重要的就是当遇到某一个类型分类时，要把它当成一个整体全都解析出来，直到遇到不同类别的字符。比如说『-234+5』这样一个字串，第一个是符号，它不能单独存在，必须与其后的数字组合起来，这一坨直到加号『+』为止，是一个整体操作数<em>-234</em>。</p>

<p><strong>符号</strong>一般只出现在字符串的开头，具体的就是整个字串的第1个字符，以及等号右边的第1个字符（如果有等号的话）。</p>

<h2>典型问题</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/solve-the-equation/">640. 求解方程</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/solve-the-equation/solution/640-qiu-jie-fang-cheng-by-alexhilton-39m8/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/fraction-addition-and-subtraction/">592. 分数加减运算</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/fraction-addition-and-subtraction/solution/by-alexhilton-u0c1/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://blog.csdn.net/dl962454/article/details/121533289">表达式求值、后缀表达式、计算器系列</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/115807632">LeetCode 题解 | 224.基本计算器</a></li>
<li><a href="https://blog.csdn.net/qq_44831907/article/details/115434570">leetcode 227 基本计算器：表达式通用解题模板</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1804025">(Leetcode 2021 刷题计划) 150. 逆波兰表达式求值</a></li>
<li><a href="https://segmentfault.com/a/1190000005659574">[Leetcode] Basic Calculator/Evaluate Expression 设计计算器/中缀表达式求值</a></li>
<li><a href="https://github.com/SharingSource/LogicStack-LeetCode/wiki/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97">表达式计算</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247492602&amp;idx=1&amp;sn=135fd5b530189f13e0395414a6b47893&amp;chksm=fd9f48e5cae8c1f3ee1fc83f3410ebb9b8fb24209bf6f08640ba3ddaf4db27d338b9d3fd3cbe&amp;mpshare=1&amp;scene=24&amp;srcid=0819WR88Erc5IACHu22b7lmp&amp;sharer_sharetime=1660874768212&amp;sharer_shareid=ce2ca9c02939976c423003e993c5a62c#rd">双栈 : 表达式计算问题的通用解法</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247492653&amp;idx=1&amp;sn=53db69e634307b64b5d8d1845fb7baf5&amp;chksm=fd9f4f32cae8c624a8a2eef50a6917bdd834edc9e1bb18e16014062346506b2a3df3d24adb0e&amp;mpshare=1&amp;scene=24&amp;srcid=08190KPPnjPE9sQfHNUAEBnJ&amp;sharer_sharetime=1660874752279&amp;sharer_shareid=ce2ca9c02939976c423003e993c5a62c#rd">表达式计算问题的通用解法</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[秘密武器之单调栈]]></title>
    <link href="http://toughcoder.net/blog/2022/08/15/secret-weapon-monotonic-stack/"/>
    <updated>2022-08-15T23:50:29+08:00</updated>
    <id>http://toughcoder.net/blog/2022/08/15/secret-weapon-monotonic-stack</id>
    <content type="html"><![CDATA[<p>除了在树的遍历，DFS等常规场景使用栈(Stack)以外，针对某些特定的问题，还能以栈为主要手段进行非常巧妙的解题，栈中数据（通常是整数）的存储以<strong>单调递增</strong>或者<strong>单调递减</strong>的形式，新的元素入栈前通常要把小于它的或者大于它的元素出栈，习惯称之为<strong>单调栈</strong>。</p>

<p><a href=""><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.G8tf8vP5EZFKle0-aE0fIwHaE6?pid=ImgDet&amp;rs=1" title="auto auto" ></a></p>

<p>问题的常规解的时间复杂度通常会达到O(n<sup>2</sup>)或者O(nlog<sup>n</sup>)，但使用单调栈可以达到O(n)，思路非常的巧妙。</p>

<!-- more -->


<h2>单调栈的特点</h2>

<p>单调栈使用的数据结构就是栈，通常存储整数，可以入栈元素的下标，也可以直接把元素入栈。一般当需要计算元素之间的跨度时，比如像求面积，或者求天数时，这需要用元素的下标来计算，所以这时把元素下标入栈更为方便；其他情况直接入栈元素就可以。</p>

<p>单调栈，有二个重要的特性，一是栈，也要<strong>后进先出（FILO）</strong>，二是单调性，栈中的元素要么是递增的要么是递 减的。具体就单调性而言分为两类：</p>

<ol>
<li>单调<strong>递增栈:</strong>元素在栈中从栈底到栈顶是由大到小的，由此，<strong>出栈的序列</strong>是由小到大的，是递增的</li>
<li>单调<strong>递减栈:</strong>元素在栈中从栈底到栈顶是由小到大的，由此，<strong>出栈的序列</strong>是由大到小的，是递减的</li>
</ol>


<p>为了保持单调性，在入栈的时候，需要把破坏单调性的元素出栈，直到能够保持单调性。</p>

<p>可能不同的文章对单调性定义不同，有些是以栈中的顺序为主，有些是以出栈的序列为主，但只是概念上的不同理解而已，本质上并不无差别。本文将以<strong>出栈序列</strong>来定义。</p>

<h2>单调栈的适用性及其代码流程</h2>

<p>单调栈利用<strong>后进先出</strong>和单调性能够在一个一维数组中选出一个『下一个更大元素』或者『下一个更小元素』的序列，从而实现某些问题的解。</p>

<h3>代码流程</h3>

<p>它的典型流程，以单调递增栈为例，是：</p>

<ol>
<li>遍历输入列表（或者数组）</li>
<li>如果栈为空，或者当前元素（以下标形式或者元素）大于栈顶，直接入栈</li>
<li>否则，进行<strong>清栈：</strong>依据题目中<strong>某些约束条件</strong>，需要把栈中小于当前元素的元素出栈，然后把当前元素入栈</li>
<li>遍历完后，可能还需要清栈，栈中剩余的肯定 是不直接满足某些约束条件的，通常是对栈中元素直接以某些边界条件去计算结果</li>
</ol>


<p>另外，在实战中，还可以使用『哨兵』来简化逻辑，通常作为栈底，比如把-1（具体的数值需要依题而定）放在栈底，那么判断栈是否为空时就需要检查 是否忆到了哨兵元素。</p>

<h3>适用性</h3>

<p>单调栈应用范围不算大，它仅适合解决<strong>NEG问题</strong>，即Next Greater Element，下一个<strong>更大</strong>元素。注意，这里也可以更小的元素，也可以是前一个。</p>

<p>以一个简单的例子来说明，比如，有一个数组<strong>nums = [2, 1, 2, 4, 3]</strong>，返回一个等长数组，每个元素是当前索引在原数组中的『下一个更大』元素，如果没有就存-1。比如输入<strong>[2,1,2,4,3]</strong>就返回<strong>[4,2,4,-1,-1]</strong>。</p>

<p>这是典型的<strong>NEG问题</strong>。暴力解法容易想到，二次遍历就能找到，但会达到O(n<sup>2</sup>)的复杂度。</p>

<p>单调栈就能派上用场：整体思路就是还没有找到『更大』元素的元素先入栈，<strong>约束条件</strong>就是『更大的元素』，<strong>清栈</strong>就是把栈中小于当前元素的元素都弹出，因为它们已找到了『更大』元素，具体的：</p>

<ol>
<li>从前往后遍历，因为需要修改对应索引的值，所以栈中存索引比较方便</li>
<li>栈为空，或者当前元素[i]小于栈顶，就直接入栈</li>
<li>否则，清栈，把栈中小于当前元素出栈，因为它们忆找到『更大』元素了，就是当前元素[i]</li>
<li>遍历完成后，栈中可能有剩余元素，需要清栈，这些元素都没有找到『更大』元素的，直接存-1即可</li>
</ol>


<p>明显，这里用的是单调递增栈。只遍历一次，所有元素最多只入栈一次，所以时间复杂度是O(n)。</p>

<pre><code class="java">int[] result = new int[nums.length];
Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
for (int i = 0; i &lt; nums.length; i++) {
    if (stack.isEmpty() || nums[stack.peek()] &gt; nums[i]) {
        stack.push(i);
    } else {
        // 清栈
        while (!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; nums[i]) {
             result[stack.pop()] = nums[i];
        }
    }
}
// 清栈
while (!stack.isEmpty()) {
    result[stack.pop()] = -1;
}
</code></pre>

<h3>同一套路</h3>

<p>NEG是一类问题，用单调栈可解，但问题可能会被包装成各种问题，需要能够脱去外衣和内衣看到问题的本质。</p>

<p>比如，输入的是每日温度，找温度更高的一天，或者以身高为背景的问题，如只能看到比你矮的人的发型，如只能与比你矮的人交朋友等等。</p>

<h2>典型题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/next-greater-element-i/solution/by-alexhilton-z1m1/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/next-greater-element-ii/">503. 下一个更大元素 II</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/next-greater-element-ii/solution/by-alexhilton-m4xs/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/daily-temperatures/solution/by-alexhilton-vy0r/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/largest-rectangle-in-histogram">84. 柱状图中最大的矩形</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/solution/84-zhu-zhuang-tu-zhong-zui-da-de-ju-xing-nk72/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximal-rectangle">85. 最大矩形</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximal-rectangle/solution/by-alexhilton-zwd6/">题解</a>  </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/">768. 最多能完成排序的块 II</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/solution/768-zui-duo-neng-wan-cheng-pai-xu-de-kua-pp4l/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://liuzhenglaichn.gitbook.io/algorithm/monotonic-stack">Monotonic Stack</a></li>
<li><a href="https://x-czh.github.io/Algorithms-LeetCode/Topics/Monotonic-Stack-&amp;-Queue.html">Monotonic Stack &amp; Queue</a></li>
<li><a href="https://blog.csdn.net/lucky52529/article/details/89155694">[数据结构]——单调栈</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/346536592">算法学习笔记(67): 单调栈</a></li>
<li><a href="https://oi-wiki.org/ds/monotonous-stack/">单调栈</a></li>
<li><a href="https://www.cnblogs.com/liang24/p/14200734.html">单调栈技巧总结</a></li>
<li><a href="https://github.com/labuladong/fucking-algorithm/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/%E5%8D%95%E8%B0%83%E6%A0%88.md">单调栈</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26465701">刷题笔记6（浅谈单调栈）</a></li>
<li><a href="https://www.jianshu.com/p/6bbd3653a57f">单调栈和应用实践</a></li>
<li><a href="https://blog.csdn.net/nirendao/article/details/119065757">单调栈(monotonic stack)揭秘</a></li>
<li><a href="https://blog.csdn.net/Hanx09/article/details/108434955">单调栈与单调队列算法详解及LeetCode经典题目（Python）</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
