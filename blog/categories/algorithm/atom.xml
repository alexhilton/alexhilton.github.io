<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2023-06-15T21:51:44+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[BFS in Graph Made Easy]]></title>
    <link href="http://toughcoder.net/blog/2023/06/14/graph-bfs-made-easy/"/>
    <updated>2023-06-14T23:07:20+08:00</updated>
    <id>http://toughcoder.net/blog/2023/06/14/graph-bfs-made-easy</id>
    <content type="html"><![CDATA[<p><a href="http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy/">前面一篇文章</a>讲解过BFS和DFS的基本概念常见用法，今天专注于图论中的BFS，来深入的探讨一下BFS在图论的搜索中的应用，并总结相关解题技巧。</p>

<p><a href=""><img src="https://tutorialhorizon.com/static/media/algorithms/2015/05/Graph-BFS.gif" title="auto auto" ></a></p>

<!-- more -->


<p>本文假定已经熟知图论的基本知识，比如图的表示方式和一些基本概念等，如不熟悉可以<a href="http://toughcoder.net/blog/2022/09/08/graph-data-structure-made-easy/">参考此文</a>。</p>

<h2>基础（单源）BFS</h2>

<p>基础的BFS通常是单源的，也就是以某一个顶点为起点。借助队列(FIFO先入先出队列)，把起点入队，然后不断的从队出取出顶点，访问与其连通的顶点，直到队列为空。为了防止重复遍历，需要在遍历过程中做标记。因为这个比较基础，我们在<a href="http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy/">前一篇文章</a>中已有伪码，所以这里就不再重复了。</p>

<p>这是最基础的BFS，当然 也是最重要的，因为更为复杂的玩法也是基于此的，因此要烂熟于心，有一些板子题，可以时常拿出来复习一下：</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-islands/solution/200-dao-yu-shu-liang-by-alexhilton-cexx/">题解</a> </td>
<td style="text-align:left;"> 邻接矩阵，矩阵式基础BFS板子题 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/max-area-of-island/solution/by-alexhilton-9eby/">题解</a> </td>
<td style="text-align:left;"> 邻接矩阵，矩阵式基础BFS板子题 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/flood-fill/">733. 图像渲染</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/flood-fill/solution/733-tu-xiang-xuan-ran-by-alexhilton-mem7/">题解</a> </td>
<td style="text-align:left;"> 邻接矩阵，矩阵式基础BFS板子题 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/count-sub-islands/description/">1905. 统计子岛屿</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/count-sub-islands/solutions/2292277/xi-you-yuan-su-1905-tong-ji-zi-dao-yu-bf-ws6r/">题解</a> </td>
<td style="text-align:left;">  邻接矩阵，矩阵式基础BFS板子题 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/description/">1466. 重新规划路线</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/solutions/2301538/xi-you-yuan-su-1466-zhong-xin-gui-hua-lu-juiu/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/keys-and-rooms/description/">841. 钥匙和房间</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/keys-and-rooms/solutions/2193103/xi-you-yuan-su-841-yao-chi-he-fang-jian-hcqfy/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2><a href="https://mathworld.wolfram.com/BipartiteGraph.html">二分图判定</a>之着色法BFS</h2>

<p>先要讲下<strong><a href="https://en.wikipedia.org/wiki/Bipartite_graph">二分图</a></strong>的定义：对于图中的<strong>任意两顶点u和v</strong>，如果它们有一条边<strong>直接相连</strong>，那么u和v必须<strong>属于不同的集合</strong>。更为学术一点的说法是：如果能将一个图的顶点集合分割为两个独立的子集A和B，并使略中的每一条边的两个节点一个来自于A集合，一个来自于B集合，就将这个图称为<strong>二分图</strong>。</p>

<p><img src="https://www.researchgate.net/profile/Ehdieh_Khaledian/publication/327213774/figure/download/fig1/AS:671177970294792@1537032706486/a-Example-showing-the-bipartite-graph-of-the-organism-cluster-relationship-Left-side.ppm" alt="" /></p>

<p>有些题目，并不会这么直接的告诉你这是一个判定二分图，而且会做一些信息隐藏，一般而言，如果 涉及把一个图的顶点进行归类，只分为两类，并且有边直连的顶点要归在不同的类别中，那么这就是一个二分图判定问题，比如题886，给你的是某人不喜欢的一群人，显然有边连接的顶点要归属于不同的集合，那么这就是一个二分图判定题。</p>

<p>可以用着色法BFS来判定二分图，大概的算法流程如下：</p>

<ol>
<li>用一个与顶点集合一样大的整数数组（或者其他结构）用作颜色标记，0是未着色（也就是还未访问），1着成红色，2着成绿色</li>
<li>任选一个顶点作为起点，着色为1（红色），加入队列，开始BFS</li>
<li>当队列不为空时，取出当前顶点u，遍历与u直连的顶点v，如果v还未着色，则把它加入队列，并着为3-color[u]；如果v已着色，且与color[u]着色一样，则说明不是二分图，返回F并终止遍历；</li>
<li>重复3直到队列为空，说明可以把所有顶点着为不同的色，也即是二分图，返回T</li>
</ol>


<p>伪码如下：</p>

<pre><code class="python3">start = 0
color = [0] * n
queue = deque()
queue.add(start)
color[start] = 1
while len(queue) &gt; 0:
    u = queue.popleft()
    for v in graph[u]:
        if color[v] == 0:
            color[v] = 3 - color[u]
            queue.add(v)
        elif color[v] == color[u]:
            return False
return True
</code></pre>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/is-graph-bipartite/description/">785. 判断二分图</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/is-graph-bipartite/solutions/2306267/xi-you-yuan-su-785-pan-duan-er-fen-tu-zh-mmdh/">题解</a> </td>
<td style="text-align:left;"> 二分图判定板子题 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/possible-bipartition/">886. 可能的二分法</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/possible-bipartition/solution/886-ke-neng-de-er-fen-fa-by-alexhilton-5au7/">题解</a> </td>
<td style="text-align:left;">  二分图判定模板题  </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><strong>注意</strong>：二分图是把图的顶点进行分类到不同的集合，这是并查集最为擅长的应用场景，因此用并查集解决二分图判定更为高效和优雅。关于<a href="http://toughcoder.net/blog/2022/09/08/disjoint-set-data-structure/">并查集可以参考此文</a>。</p>

<h2>多源BFS</h2>

<p>基础的BFS<strong>只有一个起点</strong>，把图中的<strong>某一个顶点</strong>最先放入队列，然后开始BFS。但有些场景，以单个顶点为起点不能解决问题。这类问题的特点一般是求某一类顶点的极值，比如0-1矩阵中，求0最近的1，或者求1最近的0。这里的要点在于说单个顶点通过BFS找到的值并不一定是全局最优解。而如果以每个顶点都做一遍BFS又会导致复杂度太高，不但复杂度超高，而且有时候会难以编码（大致的思路是有的，但难以转化为具体的代码）。这时就要用到更为复杂一些的多源BFS来求解。</p>

<p>需要应用多源BFS题目的特点是与<strong>多个顶点相关</strong>，并求一个<strong>全局最优解</strong>，也就是说求<strong>顶点集合</strong>到另一个<strong>顶点集合</strong>的距离或者路径长度。有时候我们还需要运用逆向思维，反向思考，以使问题简化，比如虽然题目求0到1的距离，但如果反着去计算1到0的距离，反倒更为方便一些，那么就需要把顶点集合反一下。</p>

<p>多源BFS的套路：</p>

<ol>
<li>依据题目信息，看是否要把顶点集互换一下，大部分的题目是需要互换的</li>
<li>把点集都加入到队列中，同时入队的还有一个初始状态，比如求最短路径，可以把MAX_INTEGER加进去</li>
<li>以这些点集为起始，去做BFS，同时更新状态，这与常规BFS就一样了</li>
<li>为了防止重复遍历也是要做标记的，这与常规BFS一样，可以用步骤3里面与顶点一起入队的状态来当作标记，比如是MAX_INTEGER时肯定是还未访问到，是其他值时说明已访问过了</li>
<li>遍历过程中，可以求得全局最优解</li>
</ol>


<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/01-matrix/description/">542. 01 矩阵</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/01-matrix/solutions/1790257/by-alexhilton-ngwy/">题解</a> </td>
<td style="text-align:left;"> 点集互换，多源BFS模板题 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-bridge/description/">934. 最短的桥</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-bridge/solutions/1922745/934-zui-duan-de-qiao-by-alexhilton-mkxy/">题解</a> </td>
<td style="text-align:left;"> 多源BFS，数圈圈 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotting-oranges/description/">994. 腐烂的橘子</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotting-oranges/solutions/1794075/994-fu-lan-de-ju-zi-by-alexhilton-6g10/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/as-far-from-land-as-possible/description/">1162. 地图分析</a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> 点集互换，多源最短路径 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-path-with-alternating-colors/description/">1129. 颜色交替的最短路径</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-path-with-alternating-colors/solutions/2091594/1129-yan-se-jiao-ti-de-zui-duan-lu-jing-cwm57/">题解</a> </td>
<td style="text-align:left;"> 双源BFS </td>
</tr>
</tbody>
</table>


<h2>圈式BFS</h2>

<p>单源多源都可以，重点不是起点的多少，而是要在遍历的时候注意数圈层。BFS的特点是像水波一样一层一层，一圈一圈的由起点向外传播，有时候我们需要对这些层和圈进行计数。</p>

<p>其实，这个跟树的层序遍历是一样的，树的遍历大法可以<a href="http://toughcoder.net/blog/2022/08/18/binary-tree-made-easy/">参考 这个文章</a>，如果对树的层序遍历熟悉了，那么图的数圈圈也就会了。做法就是添加下一层时做一下标记，就可以了，并不复杂。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-bridge/description/">934. 最短的桥</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-bridge/solutions/1922745/934-zui-duan-de-qiao-by-alexhilton-mkxy/">题解</a> </td>
<td style="text-align:left;"> 多源BFS，数圈圈 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>泛图BFS（枚举）</h2>

<p>图是一个很广泛的概念，任何事情都可以视为一个顶点，事物之间的联系可视一条边，状态也可以视为一个顶点，一个状态变化 为另一个状态可视为一条边，因此图论的搜索，或者说图论的遍历方式可以广泛的应用。</p>

<p>BFS的遍历特点是能找到<strong>两个顶点之间的最短路径</strong>，因此，当找一些<strong>状态与状态之间的最少变化次数</strong>之类的问题时，经过适当的建模后，便可以用图论的BFS来求解。</p>

<p>针对广泛图应用BFS的套路：</p>

<ol>
<li>针对 状态进行建模，确定状态的变化规律</li>
<li>搞清楚状态的变化 规律后就可以建图了，要注意图是否是无限图，如果是无限图就必须找遍历搜索的边界</li>
<li>把起点加入队列，确定标记方案，然后开始做BFS</li>
<li>注意边界，包括重复标记，以及搜索的边界，以防止进入死循环</li>
</ol>


<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/jump-game-iii/solutions/">1306. 跳跃游戏 III</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/jump-game-iii/solutions/2302494/1306-tiao-yue-you-xi-iii-by-alexhilton-uayu/">题解</a> </td>
<td style="text-align:left;"> 模板题，本身是数组边界固定 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/minimum-jumps-to-reach-home/description/">1654. 到家的最少跳跃次数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/minimum-jumps-to-reach-home/solutions/2302780/xi-you-yuan-su-1654-dao-jia-de-zui-shao-mrilp/">题解</a> </td>
<td style="text-align:left;"> 容易想到BFS，确定右界是关键 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/water-and-jug-problem/description/">365. 水壶问题</a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> 建模是难点，如何定义状态 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/minimum-genetic-mutation/">433. 最小基因变化</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/minimum-genetic-mutation/solutions/2303783/433-zui-xiao-ji-yin-bian-hua-by-alexhilt-vc3x/">题解</a> </td>
<td style="text-align:left;"> 枚举状态的模板题 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/open-the-lock/">752. 打开转盘锁</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/open-the-lock/solutions/2303829/xi-you-yuan-su-752-da-kai-zhuan-pan-suo-b6ulp/">题解</a> </td>
<td style="text-align:left;"> 枚举状态的模板题 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><strong>注意</strong>：本质上，这属于枚举，我们枚举各种状态，然后找到想要的答案。用BFS来枚举是寻找两种状态之间的最少变化 次数。而DFS枚举则用于查找所有的可行方案，这其实就是回溯算法了。图论真的博大精深，与各种算法融合在一起。</p>

<h2>复杂状态处理</h2>

<p>图的遍历可复杂也可简单，重点并不是遍历方式如DFS，单源BFS或者多源BFS，而且遍历到每个节点时，对节点状态的处理，这里可能会千变万化，有些难题就难在对状态的处理，有些是状态太复杂了，要想办法压缩 以达到可处理的地步（如题847），有些则是状态变化 太多了（如题417）。这有点类似于<a href="http://toughcoder.net/blog/2022/09/08/introduction-to-dynamic-programming/">动态规划</a>，是没有固定的套路的，只能靠平时积累以及分析建模能力了。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-path-visiting-all-nodes/description/">847. 访问所有节点的最短路径</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/shortest-path-visiting-all-nodes/solutions/2301703/xi-you-yuan-su-847-fang-wen-suo-you-jie-jvpcz/">题解</a> </td>
<td style="text-align:left;"> 多源BFS，状态压缩 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/pacific-atlantic-water-flow/">417. 太平洋大西洋水流问题</a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/nearest-exit-from-entrance-in-maze/">1926. 迷宫中离入口最近的出口</a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>双向BFS</h2>

<p>无论是单源还是多源做BFS时一般都是一个方向的，也就是说把起始顶点或者点集加入队列作为起点，向着目标顶点或者点集或者说终点去BFS遍历。通常情况下，这没什么问题。</p>

<p>但当数据量特别大时，或者状态比较复杂时，这样效率就不够高了，这时需要更为复杂的玩法。其实前面说的起点和终点都是相对的，图的搜索遍历其实是不分方向的，起点到终点的最短距离，与终点到起点的最短距离其实是一样的，反过来你把终点当成起点来做BFS也是一样的（前面讲多源BFS时就提到过逆向思维，把点集对换，其实就是从原终点当作新起点做BFS）。</p>

<p>那么，假如同时从起点开始，和从终点开始一起做BFS，当两个BFS相遇时（同时到达相同的一层顶点时）搜索完成，是不是搜索效率就会加倍？这就是双向BFS的核心思想。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/word-ladder/description/">127. 单词接龙</a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>拓朴排序</h2>

<p>对于有向无环图而言，拓朴排序能够把顶点按依赖顺序排成线性列表，用的也是BFS来实现的，<a href="http://toughcoder.net/blog/2022/09/08/topological-sorting/">详情可以参考此文</a>。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://leetcode.cn/circle/discuss/FyPTTM/">图论算法，拿得起放得下</a></li>
<li><a href="https://www.hackerearth.com/practice/algorithms/graphs/breadth-first-search/tutorial/">Breadth First Search</a></li>
<li><a href="https://www.geeksforgeeks.org/multi-source-shortest-path-in-unweighted-graph/">Multi Source Shortest Path in Unweighted Graph</a></li>
<li><a href="https://www.geeksforgeeks.org/bipartite-graph/">Check whether a given graph is Bipartite or not</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[String Problems Archive]]></title>
    <link href="http://toughcoder.net/blog/2023/03/19/string-problem-archive/"/>
    <updated>2023-03-19T10:24:09+08:00</updated>
    <id>http://toughcoder.net/blog/2023/03/19/string-problem-archive</id>
    <content type="html"><![CDATA[<p>字符串即由字符组成的线性数组结构，可以理解为字符数组或者字符列表，但元素的集合是有限集合，通常是英文字符，数字和算术运算符号。可以说数组和列表的常见问题和技巧都可以应用于字符串，但因为是有限集合，所以又有一些独特的问题和技巧，今天就来总结一下。</p>

<p><a href=""><img src="https://cdn.programiz.com/sites/tutorial2program/files/c-strings.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>编程技巧</h2>

<h3>转成字符数组来遍历</h3>

<p>对于Java语言来说charAt(i)非常的慢，所以如果需要多次遍历，或者多次获利某个索引位置的字符，最好先转成字符数组toCharArray()，这样效率会高出很多。对于其他语言像Python3和Kotlin则没必要，因为本来就可以像常规数组(列表)一样遍历。</p>

<h3>用桶代替哈希表</h3>

<p>字符串的每个元素是有限集合，所以要尽可能的用桶来代替哈希表，每当需要对字符计数，或者做映射的时候，都可以先尝试用桶。
比如小写英文字母，就可以用一个长度为26的整数数组来计数，字符与索引的转化关系是ch-&lsquo;a&#8217;，同理可以扩展到大写ch-&#8216;A&#8217;，甚至数字字符ch-&#8216;0&#8217;。</p>

<h3>字符与索引相互转化</h3>

<p>前面提到了用桶，就是把字符转化为索引。反过来也是可行的。目标字符ch = (char) (i + &lsquo;a&rsquo;)就把索引转为小写，大写和数字字符也是同理的。</p>

<h4>Java/C/C++</h4>

<p>传统语言里面char相当于无符号整数，所以可以直接强行互转：</p>

<pre><code class="Java">char ch = (char) (i + 'a');
int idx = ch - 'a'
</code></pre>

<h4>Python3</h4>

<p>大Python3中要用ord()和chr()来进行字符到整数的互转</p>

<pre><code class="Python3">idx = ord(ch) - ord('a')
ch = chr(idx + ord('a'))
</code></pre>

<h4>Kotlin</h4>

<p>因为Kotlin中没有所谓的基础类型，都是对象，所以就用对象提供的方法即可。字符转为整数用Char.code，要把数字字符转为对应字面的整数用Char.digitToInt，如:</p>

<pre><code class="Kotlin">val ch: Char = '3'
println("ch as int ${ch.code}, ch digit as int ${ch.digitToInt()}")
// ch as int 51, ch digit as int 3
</code></pre>

<p>如果是想转成其他进制的整数，可以传入基数作为参数，如：</p>

<pre><code class="Kotlin">val hexCh = 'F'
println("hex ch ${hexCh.digitToInt(16)}") // 15
</code></pre>

<p>因为是基于JVM的，所以字符也可以用于计算，比如idx = ch - &lsquo;a&#8217;，这是完全没有问题的。</p>

<pre><code class="Kotlin">    val a = 'a'
    var idx = 'd' - a
    val aidx = idx + 7
    println("idx $idx, aidx to ch ${(aidx + 'a'.code).toChar()}")
    //idx 3, aidx to ch k
</code></pre>

<p>反过来，整数转到字符，用Int.toChar()就可以了，会按ASCII的code值去转。另外，如果想转成数字字符用Character.forDigit(ch, radix):</p>

<pre><code class="Kotlin">val d = 8
println(" int to char ${d.toChar()}, to digit char ${Character.forDigit(d, 10)}")
</code></pre>

<h3>字符数组/列表转为String</h3>

<p>涉及字符的题目，一般需要转成字符数组处理后，再把字符数组转成字符串。</p>

<p>对于Java来说，String的构造方法支持传入char[]作为参数。</p>

<p>而Python3，其实就是字符列表转为字串，可以用join方法，这个方法是str提供的方法，用一个str当作分隔符来把一个列表连接起来：</p>

<pre><code class="Python3">chars = ['H', 'e', 'l', 'l', 'o']
''.join(chars) # "Hello"
</code></pre>

<p>同样，Kotlin中也有joinToString方法，它对数组和列表都支持，可以传入一个参数作为分隔符：</p>

<pre><code class="Kotlin">val chars = charArrayOf('H', 'e', 'l', 'l', 'o')
val res = chars.joinToString("")
</code></pre>

<h3>压缩到位运算</h3>

<p>如果字符集合特别有限，比如只有有限几个字符，或者只有小写，只有大写，这时可以更进一步的，用位运算来进行优化。小写字符只有26个，一个整数有32位可以用，完全够用。</p>

<p>当满足以下两个条件时就可以考虑用位运算来优化：仅涉及两个状态，有和没有；另外就是字符或者组合后的集合范围在32个以内。</p>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sort-characters-by-frequency/">451. 根据字符出现频率排序</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sort-characters-by-frequency/solution/451-gen-ju-zi-fu-chu-xian-pin-lu-pai-xu-01mur/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>变位词</h2>

<p>变位词是指对于一个字符串，把某几个字符位置换一下之后得到的字符串，与原串互为变位词。其实变位词不局限于字符串，对于任何一个线性列表来说，把某几个元素位置变一下就是互为变位词了。变位词有两大特点：字符集合是一样的，种类一样，频次也一样，但排列不一样。</p>

<p>基于它的特点，涉及变位词的问题，就变成了字符频次统计的问题了，如果两个字符串的字符频次一样，那么就互为变位词。另外的处理方式就是排序，因为只是排列不一样，所以按照同一规则排序后，两字符串就相同了，那么通过排序 来验证也可以可行的。具体处理时，要依据不同的条件来灵活选择具体的识别方式。</p>

<p>需要注意的是，当用频次统计法时，记得用桶而不是直接用哈希表。</p>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/group-anagrams/solution/49-zi-mu-yi-wei-ci-fen-zu-by-alexhilton-ni22/">题解</a> </td>
<td style="text-align:left;"> 排序法 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>回文</h2>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-palindromic-substring/solution/">5. 最长回文子串</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-palindromic-substring/solution/5-zui-chang-hui-wen-zi-chuan-by-alexhilt-6kvt/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>状态压缩</h2>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/repeated-dna-sequences/">187. 重复的DNA序列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/repeated-dna-sequences/solution/187-zhong-fu-de-dnaxu-lie-by-alexhilton-5or9/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>其他</h2>

<h3>典型问题</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基础利器之Stack和Queue]]></title>
    <link href="http://toughcoder.net/blog/2023/03/05/stack-and-queue/"/>
    <updated>2023-03-05T10:11:21+08:00</updated>
    <id>http://toughcoder.net/blog/2023/03/05/stack-and-queue</id>
    <content type="html"><![CDATA[<p>在基础的数据结构中栈和队列使用极其广泛，其用法也很多，今天就来总结一下栈和队列的使用方法和相关的题目。</p>

<p><a href=""><img src="https://i0.wp.com/www.dineshonjava.com/wp-content/uploads/2017/01/stack-queue.png?fit=523%2C228&amp;ssl=1" title="auto auto" ></a></p>

<!-- more -->


<h2>队列Queue</h2>

<p><img src="https://www.wisdomjobs.com/tutorials/representation-of-a-fifo-queue.png" alt="" /></p>

<h3>基本概念</h3>

<p>队列是一个线性数据 结构，特点是先入先出，也就是能保证先入队的元素先出队，也即FIFO First In First Out。与现实生活中的排队是一样的。</p>

<h3>基础应用</h3>

<p>应用很广泛，像消息队列，任务队列，以及像滑动窗口。</p>

<h4>典型题目</h4>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/qIsx9U/">剑指 Offer II 041. 滑动窗口的平均值</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/qIsx9U/solution/by-alexhilton-1c5a/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-circular-queue/">622. 设计循环队列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-circular-queue/solution/622-she-ji-xun-huan-dui-lie-by-alexhilto-adr5/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h3>中级应用</h3>

<p>BFS要用到队列。</p>

<p>BFS可以<a href="http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy/">参考另外一个文章</a>。</p>

<h4>典型题目</h4>

<h3>高级应用</h3>

<p>单调队列，队列中的元素以非递增顺序或者非递减顺序排列。</p>

<p>单调队列<a href="http://toughcoder.net/blog/2022/08/15/secret-weapon-monotonic-stack/">参见另外一个文章</a>。</p>

<h2>栈Stack</h2>

<p><img src="https://holycoders.com/content/images/2020/06/Stack.png" alt="" /></p>

<h3>基本概念</h3>

<p>也是一个线性结构，与队列类似，但它是先入后出，或者说后入先出，FILO First In Last Out。现实生活中也有，比如像盘子，通常是叠在一起的，这就是一个栈，一个一个叠 在一起，最后放上去的，最先拿下来用。</p>

<h3>基础应用</h3>

<p>程序运行时会用到栈，函数的调用会用到栈。还有一些模拟的场景也会用到栈，比如像处理括号和表达式一类的问题时。</p>

<h4>典型题目</h4>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/valid-parentheses/solution/by-alexhilton-8tcu/">题解</a> </td>
<td style="text-align:left;"> 栈模拟 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/min-stack/solution/by-alexhilton-20au/">题解</a> </td>
<td style="text-align:left;"> 栈模拟 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/asteroid-collision/">735. 行星碰撞</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/asteroid-collision/solution/by-alexhilton-87ks/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-frequency-stack/">895. 最大频率栈</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-frequency-stack/solution/by-alexhilton-xdq9/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/validate-stack-sequences/">946. 验证栈序列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/validate-stack-sequences/solution/946-yan-zheng-zhan-xu-lie-by-alexhilton-cjjq/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/build-an-array-with-stack-operations/">1441. 用栈操作构建数组</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/build-an-array-with-stack-operations/solution/1441-yong-zhan-cao-zuo-gou-jian-shu-zu-b-sw1y/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h3>中级应用</h3>

<p>DFS需要用到栈.</p>

<p>DFS可以<a href="http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy/">参考另外一个文章</a>。</p>

<h3>高级应用</h3>

<p>单调栈<a href="http://toughcoder.net/blog/2022/08/15/secret-weapon-monotonic-stack/">参见另外一个文章</a>。</p>

<h2>双端队列Deque</h2>

<p>双端队列Deque读作dek，是两端都可以入队和出队，因此它即可以用作栈也可以用作队列，在实际使用中是最多的，大多数时候都尽可能用双端队列。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Design Problems Archive]]></title>
    <link href="http://toughcoder.net/blog/2023/02/09/design-problems-archive/"/>
    <updated>2023-02-09T20:58:57+08:00</updated>
    <id>http://toughcoder.net/blog/2023/02/09/design-problems-archive</id>
    <content type="html"><![CDATA[<p>设计类习题是指要求设计一个类以完成某种特定需求，不是很复杂，通常一个类就能搞定，整体代码也不会特别长，但又能考察到一些基本的知识点，或者一些基本的技巧。通常是由一些日常中常见的任务经过简化而来。</p>

<p><a href=""><img src="http://www.dreamtemplate.com/blog/wp-content/uploads/2012/05/p228.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>因为通常都不会特别复杂，用常规的数据结构就能实现，此类问题最为关键的是要理清需求，各种边界条件的处理。一般情况下哈希表加上线性的结构如队栈或者链表就能解决。不用往复杂了想，常规数据结构，常用技术就能搞定，关键还是要读懂需求。</p>

<h2>典型问题</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/lru-cache/solution/by-alexhilton-xdf0/">题解</a> </td>
<td style="text-align:left;"> 哈希表，双向链表 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/min-stack/solution/by-alexhilton-20au/">题解</a> </td>
<td style="text-align:left;"> 栈 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/implement-queue-using-stacks/solution/by-alexhilton-hj5r/">题解</a> </td>
<td style="text-align:left;">  栈，队列 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/">304. 二维区域和检索 - 矩阵不可变</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/range-sum-query-2d-immutable/solution/xi-you-yuan-su-304-er-wei-qu-yu-he-jian-uqui5/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/encode-and-decode-tinyurl/">535. TinyURL 的加密与解密</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/encode-and-decode-tinyurl/solution/by-alexhilton-lz1t/">题解</a> </td>
<td style="text-align:left;"> 哈希表 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-circular-queue/">622. 设计循环队列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-circular-queue/solution/622-she-ji-xun-huan-dui-lie-by-alexhilto-adr5/">题解</a> </td>
<td style="text-align:left;"> 队列 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-circular-deque/">641. 设计循环双端队列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-circular-deque/solution/by-alexhilton-ve31/">题解</a> </td>
<td style="text-align:left;"> 队列 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/online-stock-span/">901. 股票价格跨度</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/online-stock-span/solution/by-alexhilton-piye/">题解</a> </td>
<td style="text-align:left;">  单调栈 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/complete-binary-tree-inserter/">919. 完全二叉树插入器</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/complete-binary-tree-inserter/solution/by-alexhilton-msqn/">题解</a> </td>
<td style="text-align:left;"> 队列，BFS </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-skiplist/">1206. 设计跳表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-skiplist/solution/1206-she-ji-tiao-biao-by-alexhilton-sd06/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-an-ordered-stream/">1656. 设计有序流</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-an-ordered-stream/solution/by-alexhilton-cev5/">题解</a> </td>
<td style="text-align:left;"> 队列 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-authentication-manager/">1797. 设计一个验证系统</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-authentication-manager/solution/1797-she-ji-yi-ge-yan-zheng-xi-tong-by-a-copl/">题解</a> </td>
<td style="text-align:left;"> 哈希表，双向链表，LRUCache </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/qIsx9U/">剑指 Offer II 041. 滑动窗口的平均值</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/qIsx9U/solution/by-alexhilton-1c5a/">题解</a> </td>
<td style="text-align:left;"> 队列 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[链表问题总结]]></title>
    <link href="http://toughcoder.net/blog/2023/01/31/mastering-linkedlist/"/>
    <updated>2023-01-31T23:18:57+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/31/mastering-linkedlist</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Linked_list">链表LinkedList</a>是一种线性的非连续数据结构，优势是随机删除和添加特别高效，但随机访问效率差。因为链表边界条件较多，容易出错，所以还是比较常见的一类题目。但链表常见的问题就那么多，总结起来就那么几个，想要掌握还是比较容易的。</p>

<p><a href=""><img src="https://myeasytuts.com/wp-content/uploads/2020/04/Linked-List-in-Swift.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>单链表</h2>

<p>单链表是出现频率最高的，虽然现实中很少用它，因为它的效率差，现实中一般多用双向链表。单链表也即是每个节点只有一个指针，指向下一个节点，只能从前往后的顺序来遍历，如果想对某一个节点进行操作，必须找到这个节点的前一个节点。
<img src="https://www.testingdocs.com/questions/wp-content/uploads/Single-Linked-List.png" alt="" /></p>

<h3>哨兵节点</h3>

<p>哨兵节点是指在输入的头节点的前面加一个节点，它的值没有任何意义，它的存在是为了简化逻辑。通常用于添加和删除操作中，如果输入的头节点是null，那么就需要特殊处理，而用了哨兵节点，就可以简化逻辑。</p>

<p>比如说，常规的添加和删除：</p>

<pre><code class="java">    public static ListNode normalAppend(ListNode head, int value) {
        ListNode newNode = new ListNode(value);
        // ugly
        if (head == null) {
            return newNode;
        }

        ListNode current = head;
        while (current.next != null) {
            current = current.next;
        }

        current.next = newNode;
        return head;
    }

    public static ListNode normalDelete(ListNode head, int value) {
          // ugly
        if (head == null) {
            return null;
        }
        // ugly
        if (head.val == value) {
            return head.next;
        }

        ListNode current = head;
        while (current.next != null) {
            if (current.next.val == value) {
                current.next = current.next.next;
                break;
            }
            current = current.next;
        }

        return head;
    }
</code></pre>

<p>可以看到为了处理头节点是null的情况要加很多逻辑，但如果使用哨兵节点，逻辑就会非常简单：</p>

<pre><code class="java">    public static ListNode append(ListNode head, int value) {
        ListNode dummy = new ListNode(0, head);

        ListNode current = dummy;
        while (current.next != null) {
            current = current.next;
        }
        current.next = new ListNode(value);
        return dummy.next;
    }

    public static ListNode delete(ListNode head, int value) {
        ListNode dummy = new ListNode(0, head);

        ListNode current = dummy;
        while (current.next != null) {
            if (current.next.val == value) {
                current.next = current.next.next;
                break;
            }
            current = current.next;
        }

        return dummy.next;
    }
</code></pre>

<p>哨兵节点的作用是要能简化逻辑，一般用在需要考虑头节点为null的情况，或者当使用双指针，需要从-1位置出发时。但不要滥用，要真能起到简化逻辑才可以。另外就是注意哨兵节点的值要尽可能与常规节点的值区分开来，否则把哨兵节点当成常规节点就会出错。</p>

<h3>反转</h3>

<p>链表反转是基础的操作，有三种方式：<strong>迭代，逆向构造式</strong>；<strong>借助栈，顺向构建</strong>；和<strong>递归式</strong>，详见206的题解。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reverse-linked-list/solution/206-fan-zhuan-lian-biao-by-alexhilton-6ttd/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/palindrome-linked-list/solution/by-alexhilton-pcab/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br/></p>

<h3>遍历和随机访问</h3>

<p>主要是为了查找某个节点，以进行其他操作。需要别注意的是单链表必须 要找到前一个节点才可以，所以遍历的终止条件一般都是curr.next == target。高级的方法就是<strong>双指针</strong>和<strong>快慢指针</strong>，双指针是指两个指针指向不同的位置，然后以同样的速度向前移动；而快慢指针的特点是一个跑的快（两倍步长到next.next），一个跑的慢（常规步长到next），通常从同一个起点出发，注意它们之间是有区别的。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/19-shan-chu-lian-biao-de-dao-shu-di-n-ge-xa3i/">题解</a> </td>
<td style="text-align:left;"> 双指针 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/solution/by-alexhilton-p9ch/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/solution/xi-you-yuan-su-25-k-ge-yi-zu-fan-zhuan-l-i2ej/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotate-list/">61. 旋转链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotate-list/solution/xi-you-yuan-su-61-xuan-zhuan-lian-biao-l-dsdj/">题解</a> </td>
<td style="text-align:left;"> 与题19类似 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/linked-list-components/">817. 链表组件</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/linked-list-components/solution/by-alexhilton-0raa/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/">面试题 02.02. 返回倒数第 k 个节点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/kth-node-from-end-of-list-lcci/solution/by-alexhilton-us40/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/middle-of-the-linked-list/solution/by-alexhilton-0uz4/">题解</a> </td>
<td style="text-align:left;"> 快慢指针 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="">1290. 二进制链表转整数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/convert-binary-number-in-a-linked-list-to-integer/solution/by-alexhilton-h6oe/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br/></p>

<h3>插入和删除</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/solution/by-alexhilton-p9ch/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/solution/82-shan-chu-pai-xu-lian-biao-zhong-de-zh-cmlv/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/solution/by-alexhilton-u8ul/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-duplicate-node-lcci/">面试题 02.01. 移除重复节点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-duplicate-node-lcci/solution/by-alexhilton-u6rm/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-linked-list-elements/solution/by-alexhilton-qvkv/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/delete-node-in-a-linked-list/">237. 删除链表中的节点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/delete-node-in-a-linked-list/solution/by-alexhilton-3c7t/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br/></p>

<h3>链表合并</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-two-sorted-lists/solution/21-he-bing-liang-ge-you-xu-lian-biao-by-2pafg/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-k-sorted-lists/solution/by-alexhilton-zctb/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/sort-list/solution/by-alexhilton-tqk5/">题解</a> </td>
<td style="text-align:left;"> 寻找中间点，归并排序 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reorder-list/">143. 重排链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reorder-list/solution/cbi-jiao-you-tiao-li-de-yi-chong-xie-fa-l56fx/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-in-between-linked-lists/">1669. 合并两个链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-in-between-linked-lists/solution/by-alexhilton-gl5m/">题解</a> </td>
<td style="text-align:left;"> 严格来说不算合并，<br/>主要涉及删除和插入，<br/>以及随机访问 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br/></p>

<h3>相交链表</h3>

<p>属于高级题目，但套路单一，当作基本套路记住就行了。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/solution/by-alexhilton-jhos/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/solution/114-er-cha-shu-zhan-kai-wei-lian-biao-by-3mke/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br/></p>

<h3>环形链表</h3>

<p>主要分两种，一种是链表部分成环；另外就是整个链表就是环（首尾相接），套路也比较单一，记住就行了。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/4ueAj6/">剑指 Offer II 029. 排序的循环链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/4ueAj6/solution/by-alexhilton-dr5w/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/linked-list-cycle/solution/141-huan-xing-lian-biao-by-alexhilton-pzk1/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/linked-list-cycle-ii/solution/by-alexhilton-u2dm/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br/></p>

<h3>综合</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/solution/114-er-cha-shu-zhan-kai-wei-lian-biao-by-3mke/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/lru-cache/solution/by-alexhilton-xdf0/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-linked-list/solution/xi-you-yuan-su-707-she-ji-lian-biao-lian-hcpr/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a> </td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a> </td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p><br/></p>

<h2>双向链表</h2>

<p>每个节点有两个指针分别指向下一个节点和前一个节点，这是在实际工作中使用的最多的链表形式，绝大部分操作与单链表是一样的，也是线性的。</p>

<p><img src="https://www.studytonight.com/data-structures/images/doubly-linked-list-1.png" alt="" /></p>

<p>双向链表因为有两个指针，所以在删除或者插入的时候需要小心处理好四个指针，其他的东西与单链表是一样的。另外，双链表为了达到最好的效果要使用两个哨兵节点，一个是head，指向头节点，一个是tail是末尾节点。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-authentication-manager/">1797. 设计一个验证系统</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-authentication-manager/solution/1797-she-ji-yi-ge-yan-zheng-xi-tong-by-a-copl/">题解</a> </td>
<td style="text-align:left;"> 双向链表，哈希表<br/>LURCache </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>跳表 SkipList</h2>

<p>这是以链表为基础能构造出来的最复杂的数据结构，是二维链表形式，它能够实现log(n)级别的各种操作，效率非常之高，在很多地方替代了平衡二叉树（二叉树只有达到平衡才能到最高的效率，所以工程中使用的二叉树肯定要平衡）。
<img src="https://pic2.zhimg.com/v2-17f6e0c031067f3d2a1d5b8f0e586ff5_r.jpg" alt="" /></p>

<p>首先，要明确一下问题，跳表也好，二叉树也好，是解决有序数据集的查询效率的。对于数量为n的数据集来说，如果是无序的肯定是O(n)，但如果数据有序，比如一个排好序的数组或者列表就可以用二分查找，或者用BST（二叉搜索树）时间复杂度都会降低到O(log<sup>n</sup>)。也就是说跳表解决的问题是有序列数据集的查询问题。</p>

<h3>基本原理</h3>

<p>前面说了，对于有序数据集，如果是用数组或者列表来存储，查询 效率肯定是O(log<sup>n</sup>)的，但是连续结构有一个问题就是它的插入和删除是O(n)的。链表呢虽然插入和删除可以做到O(1)，但是它的随机访问（也即查询）慢要O(n)。那么对于一个有序的单链表来说，有没有办法可以提升它的查询效率呢？（插入和删除以及修改都要以查询为先，只有找到了才方便做插删改）。我们要利用数据已排好序，假如能像BST或者二分那样，能把数据集缩小，就可以提升效率。</p>

<p>假如有一个现成的指针指向有序单链表的中间，那么就可以把中单节点的值与目标值比较，如果目标值大于中间节点，那目标值肯定 在后半段，否则就在前半段。假如有更多的中间节点指针，是不是就是二分查找了？可以用空间换时间，给有序单链表建立索引层，每一层也是一个单链表，它会把下面一层链表分成几段，底层是数据集，即有序单链表。这样，从最上层往下层走，就可以把数据集缩小到一个很小的范围内。极端情况下，可以在1/2，1/4，1/8. &hellip; 建立索引层，那这是不是就变成BST了？</p>

<p>这就是跳表的核心想。查询的时候总是从最上层开始，因为每一层也是一个有序链表，当下一个节点值大于目标值时，就需要向下走，然后从这一层的这个节点开始，先向后查询，下一个节点大于目标值时，再向下走，这样当前指针就会一层一层的来回跳着走，故名跳表。</p>

<h3>实现细节</h3>

<p>跳表的原理并不复杂，容易理解，但从原理到编码仍有很多细节需要考虑，比如如何表示每一层？以及分多少层，分层多能提升效率，但分层多占用的空间也越大，而且如果分的过细，不就变成了二叉树了么。以及说在哪些节点建立索引（也即分层），是按固定的位置（1/2, &frac14;&hellip;）还是按什么规律，因为这直接会影响查询效率。</p>

<h4>如何实现分层</h4>

<p>分层在节点中实现，常规的节点有一个指针next指向下一个节点，在跳表中节点的next指针是一个数组，数组的长度就是这个节点的层数，以此实现分层，0层是底层，level-1是最上层。这样就能实现每层两个方向的遍历方式，每一层的next指针就是这一层的链表，通过curr.next[i]就能向后遍历。下楼（也即从上层往下一层走）就是level-1就下去了。</p>

<p>当然 这里也可以用指针，比如节点有两个指针一个是next，指向同层的后面的节点，以及down，指针下一层的同位置的指针。但并无概念上的区别，总之层的实现是在每个节点上面的。</p>

<p>从大的维度来说，整体仍是一个从左向右的单链表，分层是在每个节点上面的实现的。</p>

<h4>在哪里分层</h4>

<p>固定位置分层不可取，因为这就是BST的方式啊，数据集的变化可不会因为位置而改变，比如以1/2, 1/4和1/8这几个位置来分层，那假如数据向1/4后的位置集中了，这就会不平衡，就必须做平衡，会比较麻烦（这也是各种平衡二叉树的痛点）。</p>

<p>跳表用一个比较骚的方式，随机化分层，一个长度为n的有序单链表，每个节点都有机会建立分层索引，这样摊还分析后，整体的效率是最好的。</p>

<p>同时，为了防止分层过于集中，还设立了最大层限制MAX_DEPTH。具体的策略是预先设置一个阈值P（0 &lt; P &lt; 1)，每次随机生成一个0~1的浮点数，如果它大于P，那么这个节点的层数加1，否则就返回当前层数（即保持层数不变）。</p>

<pre><code class="java">    private int randomLevel() {
        int lv = 1;
        while (random.nextDouble() &lt; P_FACTOR &amp;&amp; lv &lt; MAX_LEVEL) {
            lv++;
        }
        return lv;
    }
</code></pre>

<h4>哨兵节点</h4>

<p>为了方便，可以加入哨兵节点head，head犹为重要，这是整个数据结构的入口，并且有了head后插入和删除的逻辑都能得到简化。</p>

<h3>标准实现</h3>

<p>为了简单，节点值用整数，节点值的有效范围可以设定为0~n-1，长度共是n。</p>

<h4>节点</h4>

<p>节点，与单链表很像，一个代表值的int，以及一个数组，代表next指针。</p>

<p>需要注意，一个节点的层数在创建节点时就确定了，在节点的生命周期过程中其层数不会变化。因为对跳表数据结构产生变化 的操作只有插入和删除，插入是生成新的节点，插入时层数已确定；删除是把节点移除，自然也没必要再去改变节点本身了。所以节点的数据类型是Immutable的。</p>

<pre><code class="java">    private static final class Node {
        final int value;
        final Node[] next;

        Node(int value, int level) {
            this.value = value;
            next = new Node[level];
        }
    }
</code></pre>

<h4>构造</h4>

<p>跳表其实就是一个单链表表，所以整体数据结构也不复杂，一个哨兵入口的头节点head，还有当前节点中的最大层数level，和两个阈值P_FACTOR是要不要增加层深的阈值以及最大层数MAX_LEVEL。</p>

<pre><code class="java">    private static final int INF = 1000;
    private static final int MAX_LEVEL = 32;
    private static final double P_FACTOR = 0.25;
    private final Node head;
    private int level;
    private final Random random;

    public SkipList() {
        head = new Node(-INF, MAX_LEVEL);
        level = 0;
        random = new Random();
    }
</code></pre>

<h4>查询</h4>

<p>从头节点入口，从其最高层开始查询，具体查询过程与单链表是一样的，持有当前指针，当前指针初化为head节点，不断向后遍历curr直到curr.next[level].val大于目标值，然后走到下一层，继续向后遍历。直到最底层，如果curr.next[0].val等于目标值则找到，否则就是没有，不存在。</p>

<pre><code class="java">    public boolean search(int target) {
        Node curr = head;
        for (int i = level - 1; i &gt;= 0; i--) {
            while (curr.next[i] != null &amp;&amp; curr.next[i].value &lt; target) {
                curr = curr.next[i];
            }
        }

        if (curr.next[0] != null &amp;&amp; curr.next[0].value == target) {
            return true;
        }

        return false;
    }
</code></pre>

<h4>删除</h4>

<pre><code class="java">    public boolean delete(int target) {
        Node[] updates = new Node[MAX_LEVEL];

        Node curr = head;
        for (int i = level - 1; i &gt;= 0; i--) {
            while (curr.next[i] != null &amp;&amp; curr.next[i].value &lt; target) {
                curr = curr.next[i];
            }
            updates[i] = curr;
        }
        curr = curr.next[0];
        if (curr == null || curr.value != target) {
            // target not exist
            return false;
        }

        for (int i = 0; i &lt; level; i++) {
            if (updates[i].next[i] != curr) {
                break;
            }
            updates[i].next[i] = curr.next[i];
        }
        while (level &gt; 1 &amp;&amp; head.next[level - 1] == null) {
            level--;
        }
        return true;
    }
</code></pre>

<h4>插入</h4>

<pre><code class="java">    public void insert(int value) {
        Node[] updates = new Node[MAX_LEVEL];
        Arrays.fill(updates, head);

        Node curr = head;
        for (int i = level - 1; i &gt;= 0; i--) {
            while (curr.next[i] != null &amp;&amp; curr.next[i].value &lt; value) {
                curr = curr.next[i];
            }
            updates[i] = curr;
        }

        int lv = randomLevel();
        level = Math.max(level, lv);
        Node newNode = new Node(value, lv);

        for (int i = 0; i &lt; lv; i++) {
            newNode.next[i] = updates[i].next[i];
            updates[i].next[i] = newNode;
        }
    }
</code></pre>

<h4>修改</h4>

<p>一般的实现中不会不回修改的接口，因为修改就是删除原节点，然后再插入新节点，所以用删除和插入就可以实现了，没必要再添加一个方法。</p>

<h4>运行</h4>

<p>为了方便加一个调试方法</p>

<pre><code class="java">     public void dump() {
        for (int i = level - 1; i &gt;= 0; i--) {
            StringBuilder sb = new StringBuilder();
            sb.append(String.format("L #%3d [ ", i));
            Node curr = head;
            Node bottomCurr = head;
            while (bottomCurr != null) {
                if (curr != null &amp;&amp; curr.value == bottomCurr.value) {
                    if (curr == head) {
                        sb.append("-Inf -&gt; ");
                    } else {
                        sb.append(String.format("%5d -&gt; ", curr.value));
                    }
                    curr = curr.next[i];
                } else {
                    sb.append("         ");
                }
                bottomCurr = bottomCurr.next[0];
            }
            sb.append(" null ]");
            System.out.println(sb);
        }
    }

    public static void main(String[] args) {
        SkipList sl = new SkipList();
        int n = 100;
        Random rand = new Random();
        int[] values = new int[7];
        for (int i = 0; i &lt; values.length; i++) {
            values[i] = rand.nextInt(n);
            sl.insert(values[i]);
        }
        System.out.println("After insertion.");
        sl.dump();
        for (int i = 0; i &lt; 3; i++) {
            int target = values[i * 2];
            System.out.println("Searching (true) " + target + " -&gt; " + sl.search(target));
        }
        System.out.println("Delete some.");
        for (int i = 0; i &lt; 3; i++) {
            int target = values[rand.nextInt(n) % values.length];
            System.out.println("Deleting (true) " + target + " -&gt; " + sl.delete(target));
        }
        int target = rand.nextInt(n);
        System.out.println("Deleting " + target + " -&gt; " + sl.delete(target));
        target = rand.nextInt(n);
        System.out.println("Deleting " + target + " -&gt; " + sl.delete(target));
        sl.dump();
        System.out.println("Insert some more.");
        for (int i = 0; i &lt; 4; i++) {
            sl.insert(rand.nextInt(n));
        }
        sl.dump();
    }
</code></pre>

<p>运行结果，要用等宽字体看才有效果：</p>

<pre><code class="bash">After insertion.
L #  3 [ -Inf -&gt;                               29 -&gt;                             null ]
L #  2 [ -Inf -&gt;             16 -&gt;             29 -&gt;                             null ]
L #  1 [ -Inf -&gt;     7 -&gt;    16 -&gt;             29 -&gt;             57 -&gt;           null ]
L #  0 [ -Inf -&gt;     7 -&gt;    16 -&gt;    21 -&gt;    29 -&gt;    44 -&gt;    57 -&gt;    88 -&gt;  null ]
Searching (true) 16 -&gt; true
Searching (true) 29 -&gt; true
Searching (true) 57 -&gt; true
Delete some.
Deleting (true) 16 -&gt; true
Deleting (true) 29 -&gt; true
Deleting (true) 57 -&gt; true
Deleting 75 -&gt; false
Deleting 80 -&gt; false
L #  1 [ -Inf -&gt;     7 -&gt;                             null ]
L #  0 [ -Inf -&gt;     7 -&gt;    21 -&gt;    44 -&gt;    88 -&gt;  null ]
Insert some more.
L #  1 [ -Inf -&gt;     7 -&gt;                      37 -&gt;    41 -&gt;             82 -&gt;           null ]
L #  0 [ -Inf -&gt;     7 -&gt;    17 -&gt;    21 -&gt;    37 -&gt;    41 -&gt;    44 -&gt;    82 -&gt;    88 -&gt;  null ]
</code></pre>

<p><a href="https://github.com/alexhilton/EffectiveAlgorithm/blob/main/datastructure/src/main/java/linkedlist/SkipList.java">完整代码在这里</a>。</p>

<h3>相关题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-skiplist/">1206. 设计跳表</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/design-skiplist/solution/1206-she-ji-tiao-biao-by-alexhilton-sd06/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/data-structures/linked-list/">Linked List Data Structure</a></li>
<li><a href="https://www.javatpoint.com/singly-linked-list">Linked List</a></li>
<li><a href="https://www.tutorialspoint.com/data_structures_algorithms/linked_list_algorithms.htm">Data Structure and Algorithms - Linked List</a></li>
<li><a href="https://www.programiz.com/dsa/linked-list">Linked list Data Structure</a></li>
<li><a href="https://www.simplilearn.com/tutorials/data-structure-tutorial/linked-list-in-data-structure">Linked List in A Data Structure: All You Need to Know</a></li>
<li><a href="https://www.geeksforgeeks.org/skip-list/">Skip List | Set 1 (Introduction)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/33674267">SkipList的原理与实现</a></li>
<li><a href="https://www.jianshu.com/p/9d8296562806">Skip List&ndash;跳表（全网最详细的跳表文章没有之一）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/108386262">详解SkipList跳跃链表【含代码】</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/339750543">跳表(skiplist)分析设计与实现(Java)</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
