<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2022-09-04T08:53:59+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[回溯算法从入门到精通]]></title>
    <link href="http://toughcoder.net/blog/2022/09/04/backtracking-algorithm-explained/"/>
    <updated>2022-09-04T08:16:04+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/04/backtracking-algorithm-explained</id>
    <content type="html"><![CDATA[<p>回溯(Backtracking)是指在求解的过程中，不断的试探每一步的所有可能的解，如果发现不符合要求，就回退到最初的状态，尝试另外一种可能，直到所有的可能的解都找到。它与DFS的思想是一致的。</p>

<p>回溯通常用来解决的问题是，问题会分成很多步骤，每一步面临多个选择，有多种可能性，需要一个一个的尝试，最终需要找到所有的可能的解。回溯通常用递归来实现，并且它的时间复杂度一般都比较高。它基本上就是穷举和暴力搜索一样，但通过各种奇技淫巧可以做剪枝以降低复杂度。</p>

<p>最为经典的回溯算法问题就是迷宫问题，比如从一个格子a，出发，有二个方向，还不知道哪个是对的，那就分别向前走，一直走，直到撞墙了，或者到了死路了，才知道这个方向是错的；然后回退到a，按个方向继续走，这就是经典的回溯。</p>

<p><a href=""><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.WZQpfmaWBboOu2d1G3ar0gHaE8?pid=ImgDet&amp;rs=1" title="auto auto" ></a></p>

<!-- more -->


<p><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.5sU8HuB5SNkBeZqVTYShqQHaFj?pid=ImgDet&amp;rs=1" alt="" /></p>

<p><img src="https://image2.slideserve.com/4888360/backtracking1-l.jpg" alt="" /></p>

<h2>穷举问题</h2>

<p>穷举，也就是穷尽所有的可能性，最为代表性的问题就是组合排列问题，这是回溯的典型问题。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/permutations/solution/by-alexhilton-k4r5/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/combinations/">77. 组合</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/combinations/solution/by-alexhilton-hrj9/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/letter-case-permutation/">784. 字母大小写全排列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/letter-case-permutation/solution/by-alexhilton-c4lx/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/subsets/">78. 子集</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/subsets/solution/by-alexhilton-1ego/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://techwithkp.com/backtracking-algorithm-explained-with-examples/">Backtracking Algorithm Explained With Examples</a></li>
<li><a href="https://www.programiz.com/dsa/backtracking-algorithm">Backtracking Algorithm</a></li>
<li><a href="https://www.simplilearn.com/tutorials/data-structure-tutorial/backtracking-algorithm">What is Backtracking Algorithm? Types, Examples &amp; its Application</a></li>
<li><a href="https://www.freecodecamp.org/news/backtracking-algorithms-explained/">Backtracking Algorithms Explained</a></li>
<li><a href="https://blog.csdn.net/a1241692733/article/details/123029578">Leetcode 刷题笔记(二十) ——回溯算法篇之分割、子集、全排列问题</a></li>
<li><a href="http://c.biancheng.net/view/3400.html">回溯算法详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/165083789">回溯算法详细总结</a></li>
<li><a href="https://blog.csdn.net/weiyuefei/article/details/79316653">[回溯算法] 五大常用算法之回溯法</a></li>
<li><a href="https://www.jianshu.com/p/dd3c3f3e84c0">小白带你学&ndash;回溯算法</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/93530380">回溯算法套路详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/308282208">关于回溯算法，你该了解这些！</a></li>
<li><a href="https://blog.csdn.net/m0_52824954/article/details/123467217">彻底搞懂回溯算法（本文真的很详细）</a></li>
<li><a href="https://www.cnblogs.com/Curryxin/p/15139654.html">【算法】回溯</a></li>
<li><a href="https://blog.csdn.net/weixin_43208423/article/details/101081544">理解回溯算法——回溯算法的初学者指南</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BFS and DFS Made Easy]]></title>
    <link href="http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy/"/>
    <updated>2022-09-02T22:43:13+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy</id>
    <content type="html"><![CDATA[<p>深度优先搜索和广度优先搜索在二维数据结构中有着非常重要和广泛的应用，今天就来好好的学习和总结一下这两种遍历方法。</p>

<p><a href=""><img src="https://image1.slideserve.com/3266131/generic-dfs-and-bfs-n.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>基础概念和代码模板</h2>

<p>先来学习一下基础的概念，其实也并不复杂。</p>

<h3>广度优先搜索</h3>

<p>BFS（Breadth First Search）是指优先把与当前节点相连的节点遍历，然后再把相连的节点的所有相连节点遍历，直到所有节点都遍历完。看起来就是一层一层的遍历（树），或者一圈一圈的遍历，像水中的波浪一样从中心点不断向外扩散。</p>

<p>它的遍历特点是，能把最近的两个节点优先遍历到，换句话说，它能找到从某个节点开始到另一个节点的最短路径，这一点相当重要，因此在图相关的搜索中用的较多一些。
<img src="https://www.guru99.com/images/1/020820_0543_BreadthFirs1.png" alt="" />
<img src="https://image1.slideserve.com/1838814/breadth-first-search1-n.jpg" alt="" /></p>

<h3>深度优先搜索</h3>

<p>DFS（Depth First Search），顺着节点的一个方向，不断深入，专注于一个方向直到这个方向上没有节点了（到达了叶子，或者到达了边界，或者最后一个节点）；然后再回到最初的节点，换一个方向，继续前行，直到所有节点都遍历完成。它的特点是只认准一个方向，不撞南墙不回头。</p>

<p>DFS在树中应用是最多的，因为树只有两个方向，一个左子树一个右子树。通常DFS用来解决特定路径相关的问题。
<img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.ccpQCah8fvV1NBvExUtwPgHaFj?pid=ImgDet&amp;rs=1" alt="" />
<img src="https://totheinnovation.com/wp-content/uploads/2021/01/DFS.jpg" alt="" /></p>

<h2>在树中的应用</h2>

<p>树的遍历和路径相关的问题，一般用DFS较为方便，树是最方便用递归的，因此递归 式DFS是解决树的遍历和路径的最广泛的方法。比如，经典的树三种遍历方式（前，中后）如果用递归式DFS来写就相当的简洁。可以<a href="http://toughcoder.net/blog/2022/08/18/binary-tree-made-easy/">参考这篇文章</a>来学习更多关于树的知识。
<img src="https://ts1.cn.mm.bing.net/th/id/R-C.8ceefec538766c3ddf768cea06cc1e15?rik=rr1dG%2bcUB9lblw&amp;riu=http%3a%2f%2fwww.crazyforcode.com%2fwp-content%2fuploads%2f2016%2f04%2fDFS.png&amp;ehk=mijFhhVLUHbPmAS9hIQz8z2gIQG%2fH7pE5QgwSuDB%2bOA%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" /></p>

<p>DFS对于树的大多数问题都是较好的选择，但有一类题，就是层序遍历相关的问题，DFS可能没有优势，因为层序遍历就是用BFS最为直接，通常实践得知，对于树来说，通常BFS的效率要差于DFS。而且对于树来说，BFS能搞定的问题，DFS也一定可以。</p>

<p>那么如何用DFS解决与层有关的问题呢？要借助额外的数据来标记当前节点是在哪一层。树DFS的遍历特点是仍旧是从左下到右下的，而且也是从上到下的（前序而言），因此DFS最先遇到的节点，肯定 是这 一层的第一个节点。DFS也是知道当前节点是属于哪一层的，根节点是第1 层，下一层就是第2层，可以把这个作为参数在DFS过程中传递。额外的数据可以是哈希表，键值就是层序号，值可以节点，当某一层为空时，来的肯定是第一个节点，如果某一层已存在，就可以追加节点，或者依据条件做运算。这样最终也能实现关于层的操作。最为典型的就是<a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">题662. 二叉树最大宽度</a>。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">662. 二叉树最大宽度</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/solution/by-alexhilton-2be9/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>在图中的应用</h2>

<p>对于图来说，因为它可能有多个方向，像矩阵有四个，常规图可能有更多个与其相连的节点，而图的搜索通常是发生在相连的多个节点之间的，因此在图的搜索里面BFS的应用更为广泛。像求一些最短路径，最近距离，拓朴排序等都是用的BFS。</p>

<h3>矩阵表示的图</h3>

<h3>邻接表表示的图</h3>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-islands/solution/200-dao-yu-shu-liang-by-alexhilton-cexx/">题解</a> </td>
<td style="text-align:left;"> 基础 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/max-area-of-island/solution/by-alexhilton-9eby/">题解</a> </td>
<td style="text-align:left;"> 基础 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/flood-fill/">733. 图像渲染</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/flood-fill/solution/733-tu-xiang-xuan-ran-by-alexhilton-mem7/">题解</a> </td>
<td style="text-align:left;"> 单源BFS/DFS </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/01-matrix/">542. 01 矩阵</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/01-matrix/solution/by-alexhilton-ngwy/">题解</a> </td>
<td style="text-align:left;"> 多源BFS </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotting-oranges/">994. 腐烂的橘子</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotting-oranges/solution/994-fu-lan-de-ju-zi-by-alexhilton-6g10/">题解</a> </td>
<td style="text-align:left;"> 多源BFS </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://blog.csdn.net/g11d111/article/details/76169861">BFS——广度优先算法（Breadth First Search）</a></li>
<li><a href="https://samuel92.blog.csdn.net/article/details/75645970">DFS——深度优先算法（Depth First Search）</a></li>
<li><a href="https://www.guru99.com/difference-between-bfs-and-dfs.html">BFS Vs. DFS: Know the Difference with Example</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[双指针总结]]></title>
    <link href="http://toughcoder.net/blog/2022/08/25/summary-of-double-pointers/"/>
    <updated>2022-08-25T22:06:31+08:00</updated>
    <id>http://toughcoder.net/blog/2022/08/25/summary-of-double-pointers</id>
    <content type="html"><![CDATA[<p>双指针是指用两个引用或者索引，或者某种键为主的操作手段，在很多场景有重要的应用，比如链表。有些时候还能成为比较巧妙的解题手段。今天就来总结一下双指针的使用。</p>

<p><a href=""><img src="https://ducmanhphan.github.io/img/Algorithm/two-pointer/two-pointers-in-two-sequences.png" title="auto auto" ></a></p>

<!-- more -->


<h2>双指针的套路</h2>

<p>根据不同的场合和用法，双指针可以分为<strong>同向双指针</strong>和<strong>对撞指针</strong>。</p>

<h3>同向双指针</h3>

<p>又可以细分为滑动窗口，以及快慢指针。</p>

<h4>滑动窗口</h4>

<p>两个指针，通常一个慢一个快，之间的子数组具有某种特质，快指针（也称右指针）正常向前遍历，新元素会加入，同时左指针也会向前移动，就像一个向前开动的公交车一样。</p>

<p>有些窗口大小是固定的，有些则是不固定的，看具体情况而定，新元素进入以及窗口中的元素移出窗口也要视题目中的具体条件而定。</p>

<h4>快慢指针</h4>

<p>最为经典的场景就是解决一坨单链表问题，比如找链表的中间节点，或者找环，以及归并等等。</p>

<p>此外，快慢指针也常用于数组，通常是涉及数组的元素移动，此类型的要点就是一个指针正常遍历原数组，此为快指针，一个指针用指向结果数组，快指针正常遍历，慢指针依据某些条件才向后移动。</p>

<h3>对撞指针</h3>

<p>就是一个从前往后遍历，一个从后往前遍历，循环中止条件是两指针相遇，通常用在二分查找，回文相关，反转数组列表，或者其他场合。</p>

<h2>双指针技巧</h2>

<p>双指针，除了以上几种比较典型之外啊，其实也挺宽泛的，只要用了两个以上的指针（下标）就算得上是双指针，也没啥固定的模式。</p>

<p>但有时，有两个常见的技巧能大幅优化效率和代码，一个就是<strong>逆向思维</strong>，比如一些涉及归并的题目中，如果用常规思路，从前往后，可能用额外空间才可以，但如果从后往前，或者从两头往中间，可能就打开了一片新天地。这里的正向和逆向视具体情况而定，比如有些归并类的是直觉上是从前往后，那这就是正向，从后往前则是逆向；再如一些中间分段的数组如山峰或者山谷形的，从间往往两头是正向，那从两头往中间则逆向。如题977。</p>

<p>还有一个技巧是，如果要求返回数组的顺序由原数组决定，但数据 的选择由计算规则确定，也就是说我们是在计算后的数组上应用双指针进行选择，但又要返回原数据中的数据顺序，这时呢，其实可以不必直接用双指针在计算后的数组中选择结果，可以先行移动指针到目标范围，然后再遍历去选择结果。典型的问题是题658。</p>

<h2>典型问题</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 要点说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/solution/by-alexhilton-a4qc/">题解</a> </td>
<td style="text-align:left;"> 经典对撞指针 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/find-k-closest-elements/">658. 找到 K 个最接近的元素</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/find-k-closest-elements/solution/by-alexhilton-ixrs/">题解</a> </td>
<td style="text-align:left;"> 先移指针到目标范围，再选择结果 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/squares-of-a-sorted-array/solution/977-you-xu-shu-zu-de-ping-fang-by-alexhi-hcu8/">题解</a> </td>
<td style="text-align:left;"> 逆向思维</td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/container-with-most-water/solution/by-alexhilton-1va8/">题解</a> </td>
<td style="text-align:left;"> 对撞指针 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reverse-words-in-a-string-iii/">557. 反转字符串中的单词 III</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reverse-words-in-a-string-iii/solution/by-alexhilton-qn2n/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotate-array/solution/189-lun-zhuan-shu-zu-by-alexhilton-1ih4/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/middle-of-the-linked-list/solution/by-alexhilton-0uz4/">题解</a> </td>
<td style="text-align:left;"> 经典快慢指针 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/19-shan-chu-lian-biao-de-dao-shu-di-n-ge-xa3i/">题解</a> </td>
<td style="text-align:left;"> 经典快慢指针 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/permutation-in-string/">567. 字符串的排列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/permutation-in-string/solution/by-alexhilton-80gu/">题解</a> </td>
<td style="text-align:left;"> 经典滑动窗口 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-by-alexhilton-ecxc/">题解</a> </td>
<td style="text-align:left;"> 滑动窗口 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Binary Search Made Easy]]></title>
    <link href="http://toughcoder.net/blog/2022/08/25/binary-search-made-easy/"/>
    <updated>2022-08-25T21:11:45+08:00</updated>
    <id>http://toughcoder.net/blog/2022/08/25/binary-search-made-easy</id>
    <content type="html"><![CDATA[<p>二分查找是效率特别高的一种算法，它能将线性复杂度O(n)降低到对数级别O(log<sup>n</sup>)。但它对输入数据有要求，比如对于数组来说必须是排序的，否则是不能应用二分的。今天就来理解一下二分查找，然后总结常见的题目和注意事项。</p>

<p><a href=""><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.eYVdL0QhR65_z_bxbevPWAHaE7?pid=ImgDet&amp;rs=1" title="auto auto" ></a></p>

<!-- more -->


<h2>理解二分查找</h2>

<p>二分查找的特点是每次能把输入数据分成一半，这样不断的二分下去，直到只剩下一个。所以能应用二分查找的最重要的条件是要能够依据某种条件把输入数据分为两段，最常见的是排序数组查找，但并不限于这个，只要能依据某种条件把数据分成二份，就可以应用二分查找，比如数据是某种情况下的单调性？或者数据有明显的断崖，或者数据是山峰形状的，或者是山谷形状的都可以应用二分查找。二分查找博大精深，需要好好体会其<strong>二分</strong>的内涵。</p>

<p>对于升序排序数组查找的标准二分代码模板：</p>

<pre><code class="java">int left = 0;
int right = n - 1;
while (left &lt;= right) {
    int mid = left + ((right - left) &gt;&gt; 1);
    if (nums[mid] == target) {
        return mid;
    } else if (nums[mid] &gt; target) {
        right = mid - 1;
    } else {
        left = mid + 1;
    }
}
return -1;
</code></pre>

<h2>注意事项</h2>

<p>注意事项就是，区间的开闭，以及中间索引的计算。循环的退出条件一般都是有等号的left &lt;= right时循环。</p>

<p>对于有些情况索引会特别的大，造成计算中间索引时会发生溢出，这时就要先减后加，以防溢出：</p>

<pre><code class="java">int mid = left + ((right - left) &gt;&gt; 1);
</code></pre>

<p>另外，这里的括号都不可省略，虽然移位符的优先级高于加法，但如果left等于right时，不加括号这个运算会出错。</p>

<h2>常见题目</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/solution/by-alexhilton-a4qc/">题解</a> </td>
<td style="text-align:left;"> 标准二分查找 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/find-k-closest-elements/">658. 找到 K 个最接近的元素</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/find-k-closest-elements/solution/by-alexhilton-ixrs/">题解</a> </td>
<td style="text-align:left;"> 找第一个小于等x的位置 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/squares-of-a-sorted-array/solution/977-you-xu-shu-zu-de-ping-fang-by-alexhi-hcu8/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/first-bad-version/">278. 第一个错误的版本</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/first-bad-version/solution/278-di-yi-ge-cuo-wu-de-ban-ben-by-alexhi-rs7n/">题解</a> </td>
<td style="text-align:left;"> 如何防范溢出 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/binary-search/solution/704-er-fen-cha-zhao-by-alexhilton-ts16/">题解</a> </td>
<td style="text-align:left;"> 标准二分查找 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/solution/by-alexhilton-ufe4/">题解</a> </td>
<td style="text-align:left;"> BST中的二分查找 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[线段树让你不再惧怕区间问题]]></title>
    <link href="http://toughcoder.net/blog/2022/08/23/rmq-made-easy/"/>
    <updated>2022-08-23T23:58:27+08:00</updated>
    <id>http://toughcoder.net/blog/2022/08/23/rmq-made-easy</id>
    <content type="html"><![CDATA[<p><a href=""><img src="https://ts1.cn.mm.bing.net/th/id/R-C.c6c6bbd2b56e8b5c9ddc2dbf1e889309?rik=14ZVI1eUra2OGw&amp;riu=http%3a%2f%2fmedianet.kent.edu%2fsurveys%2fIAD06S-p2psearch-alok%2fimages%2fmin_max_range.jpg&amp;ehk=e1Pnkh9cs9629hf15dVM5nTmu9iDMqxP5Oo4iZy7jCc%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0)" title="auto auto" ></a></p>

<!-- more -->


<h2>典型问题</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/">1450. 在既定时间做作业的学生人数</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/solution/by-alexhilton-60ye/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/my-calendar-ii/">731. 我的日程安排表 II</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/my-calendar-ii/solution/by-alexhilton-bggq/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/my-calendar-i/">729. 我的日程安排表 I</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/my-calendar-i/solution/by-alexhilton-ovl9/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/merge-intervals/solution/by-alexhilton-a3ie/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://blog.csdn.net/huangzihaoal/article/details/81813454">【算法】线段树详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/106118909">算法学习笔记(14): 线段树</a></li>
<li><a href="https://oi-wiki.org/ds/seg/">线段树 OI Wiki</a></li>
<li><a href="https://www.cnblogs.com/AC-King/p/7789013.html">线段树详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/34150142">史上最详细的线段树教程</a></li>
<li><a href="https://www.cnblogs.com/RioTian/p/13409694.html">线段树 - 多组图带你从头到尾彻底理解线段树</a></li>
<li><a href="https://halfrost.com/segment_tree/">线段树 Segment Tree 实战</a></li>
<li><a href="https://blog.csdn.net/Yaokai_AssultMaster/article/details/79599809">线段树（segment tree)，看这一篇就够了</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&amp;mid=2247493262&amp;idx=1&amp;sn=2d8e192a5767b49b9a13a6192ab3b833">关于 RMQ 的若干解法</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
