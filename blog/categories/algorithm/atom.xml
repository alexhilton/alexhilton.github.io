<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2022-09-06T23:26:37+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[树状树组简介]]></title>
    <link href="http://toughcoder.net/blog/2022/09/06/intro-to-binary-indexed-tree/"/>
    <updated>2022-09-06T21:22:36+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/06/intro-to-binary-indexed-tree</id>
    <content type="html"><![CDATA[<p>树状数组，即Binary Indexed Tree，简单来理解就是用数组来表示一颗树，它的实际存储结构是数组，但元素之间的逻辑关系是树。通常用于解决区间问题和快速计算前缀和的问题。</p>

<p><a href=""><img src="https://www.cdn.geeksforgeeks.org/wp-content/uploads/BITSum.png" title="auto auto" ></a></p>

<!-- more -->


<h2>参考资料</h2>

<ul>
<li><a href="https://halfrost.com/binary_indexed_tree/">聊聊树状数组 Binary Indexed Tree</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/99167607">算法和数据结构 | 树状数组（Binary Indexed Tree）</a></li>
<li><a href="https://www.topcoder.com/thrive/articles/Binary%20Indexed%20Trees">BINARY INDEXED TREES</a></li>
<li><a href="https://blog.csdn.net/Yaokai_AssultMaster/article/details/79492190">树状数组（Binary Indexed Tree），看这一篇就够了</a></li>
<li><a href="https://blog.csdn.net/bestsort/article/details/80796531">树状数组 数据结构详解与模板(可能是最详细的了)</a></li>
<li><a href="https://www.cnblogs.com/Last--Whisper/p/13823614.html">树状数组（BIT）—— 一篇就够了</a></li>
<li><a href="https://blog.csdn.net/flushhip/article/details/79165701">树状数组简单易懂的详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/93795692">算法学习笔记(2) : 树状数组</a></li>
<li><a href="https://www.cnblogs.com/xenny/p/9739600.html">树状数组详解</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to Trie]]></title>
    <link href="http://toughcoder.net/blog/2022/09/06/introduction-to-trie/"/>
    <updated>2022-09-06T11:41:14+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/06/introduction-to-trie</id>
    <content type="html"><![CDATA[<p><a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209">字典树</a>，<a href="https://en.wikipedia.org/wiki/Trie">Trie</a>（发音与try一样），也叫前缀树，是在一个树状数据结构中存储一个字典中的所有单词，以快速的实现前缀搜索和单词搜索的数据结构。前缀树是一个多叉树，每个节点会有多个子节点，具体子节点 数量取决于字符集的大小，除了根节点以外，每个节点代表字典中的一个字符，从根节点开始的路径代表着一个前缀或者一个单词。</p>

<p><a href=""><img src="https://pic2.zhimg.com/v2-cb9b476f3856b7ae68a00af6911c07a9_b.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>Trie通常用于解决单词搜索和前缀匹配一类的问题，特点是输入的字符集合有限（通常是仅有小写字母），给一组字符串作为输入字典（这就是字典），然后涉及前缀或者单词搜索，符合这几个条件的问题就可以考虑使用Trie来解决。</p>

<h2><a href="https://en.wikipedia.org/wiki/Trie">Trie</a>的标准实现</h2>

<p>标准的Trie是一个树形结构，其节点是TrieNode，有一个构建字典方法通常是插入一个字符串，以及查询方法search通常是一个完整单词，还有一个前缀查询方法startsWith。</p>

<p>节点的实现，对于大多数情况下依据字符集而定，通常情况下都是只有小写英文字符，所以用一个长度为26的数组即可，因为是树状，要能找到子节点，所以这个数组的类型仍是TrieNode，下标可以作为当前节点的字符。同时可以添加额外的字段 用以标记，到当前节点是否是一个完整单词。</p>

<pre><code class="java">class Trie {
    private static class TrieNode {
        TrieNode[] children;
        boolean isWord;

        TrieNode() {
            children = new TrieNode[26];
            isWord = false;
        }
    }

    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    public void insert(String word) {
        if (word == null || word.length() == 0) {
            return;
        }
        TrieNode node = root;
        for (char ch : word.toCharArray()) {
            int idx = ch - 'a';
            if (node.children[idx] == null) {
                node.children[idx] = new TrieNode();
            }
            node = node.children[idx];
        }
        node.isWord = true;
    }

    public boolean search(String word) {
        if (word == null || word.length() == 0) {
            return false;
        }
        TrieNode node = root;
        for (char ch : word.toCharArray()) {
            int idx = ch - 'a';
            if (node.children[idx] == null) {
                return false;
            }
            node = node.children[idx];
        }
        return node.isWord;
    }

    public boolean startsWith(String prefix) {
        if (prefix == null || prefix.length() == 0) {
            return false;
        }
        TrieNode node = root;
        for (char ch : prefix.toCharArray()) {
            int idx = ch - 'a';
            if (node.children[idx] == null) {
                return false;
            }
            node = node.children[idx];
        }

        return true;
    }
}
</code></pre>

<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMDE3MDk3OC1iZDdmYzQyZDFhODdmMTkxLnBuZw?x-oss-process=image/format,png" alt="" /></p>

<h2>解题技巧</h2>

<p>对于标准实现中，每个节点只有一个额外的字段用以标记到此节点时的路径是否是一个单词。</p>

<p>其实这里也可以加入更多的字段，比如输入字符串携带的其他信息，这样当搜索时遇到匹配，就可以直接提取出这些额外的信息，较复杂的问题必然有单词匹配或者前缀匹配以外的信息需要融合，这时节点就需要多定义一些字段。最为典型的就是题745。</p>

<h2>典型问题</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/implement-trie-prefix-tree/solution/by-alexhilton-8p2z/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/replace-words/">648. 单词替换</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/replace-words/solution/by-alexhilton-dr8k/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-common-prefix/">14. 最长公共前缀</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-common-prefix/solution/by-alexhilton-ajgh/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/implement-magic-dictionary/">676. 实现一个魔法字典</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/implement-magic-dictionary/solution/by-alexhilton-f3jt/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/prefix-and-suffix-search/">745. 前缀和后缀搜索</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/prefix-and-suffix-search/solution/by-alexhilton-qbjy/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://simpledevcode.wordpress.com/2018/12/04/trie-data-structure-from-scratch/">Trie data structure from scratch</a></li>
<li><a href="https://www.toptal.com/java/the-trie-a-neglected-data-structure">The Trie Data Structure: A Neglected Gem</a></li>
<li><a href="https://oi-wiki.org/string/trie/">字典树 (Trie)</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/trie-data-structure-in-c-plus-plus">Trie Data Structure in C/C++</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/28891541">数据结构与算法：字典树（前缀树）</a></li>
<li><a href="https://segmentfault.com/a/1190000040801084">一文搞懂字典树</a></li>
<li><a href="https://pdai.tech/md/algorithm/alg-basic-tree-trie.html">树 - 前缀树(Trie Tree)</a></li>
<li><a href="https://blog.csdn.net/yuzhiqiang666/article/details/80711441">数据结构与算法（十一）Trie字典树</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[回溯算法从入门到精通]]></title>
    <link href="http://toughcoder.net/blog/2022/09/04/backtracking-algorithm-explained/"/>
    <updated>2022-09-04T08:16:04+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/04/backtracking-algorithm-explained</id>
    <content type="html"><![CDATA[<p>回溯(Backtracking)是指在求解的过程中，不断的试探每一步的所有可能的解，如果发现不符合要求，就回退到最初的状态，尝试另外一种可能，直到所有的可能的解都找到。它与DFS的思想是一致的。</p>

<p><a href=""><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.WZQpfmaWBboOu2d1G3ar0gHaE8?pid=ImgDet&amp;rs=1" title="auto auto" ></a></p>

<!-- more -->


<p>回溯通常用来解决的问题是，问题会分成很多步骤，每一步面临多个选择，有多种可能性，需要一个一个的尝试，最终需要找到所有的可能的解。回溯通常用递归来实现，并且它的时间复杂度一般都比较高。它基本上就是穷举和暴力搜索一样，但通过各种奇技淫巧可以做剪枝以降低复杂度。</p>

<p><img src="https://image2.slideserve.com/4888360/backtracking1-l.jpg" alt="" /></p>

<p>最为经典的回溯算法问题就是迷宫问题，比如从一个格子a，出发，有二个方向，还不知道哪个是对的，那就分别向前走，一直走，直到撞墙了，或者到了死路了，才知道这个方向是错的；然后回退到a，按个方向继续走，这就是经典的回溯。</p>

<p><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.5sU8HuB5SNkBeZqVTYShqQHaFj?pid=ImgDet&amp;rs=1" alt="" /></p>

<h2>穷举问题</h2>

<p>穷举，也就是穷尽所有的可能性，最为代表性的问题就是组合排列问题，这是回溯的典型问题。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/permutations/solution/by-alexhilton-k4r5/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/combinations/">77. 组合</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/combinations/solution/by-alexhilton-hrj9/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/letter-case-permutation/">784. 字母大小写全排列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/letter-case-permutation/solution/by-alexhilton-c4lx/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/subsets/">78. 子集</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/subsets/solution/by-alexhilton-1ego/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://techwithkp.com/backtracking-algorithm-explained-with-examples/">Backtracking Algorithm Explained With Examples</a></li>
<li><a href="https://www.programiz.com/dsa/backtracking-algorithm">Backtracking Algorithm</a></li>
<li><a href="https://www.simplilearn.com/tutorials/data-structure-tutorial/backtracking-algorithm">What is Backtracking Algorithm? Types, Examples &amp; its Application</a></li>
<li><a href="https://www.freecodecamp.org/news/backtracking-algorithms-explained/">Backtracking Algorithms Explained</a></li>
<li><a href="https://blog.csdn.net/a1241692733/article/details/123029578">Leetcode 刷题笔记(二十) ——回溯算法篇之分割、子集、全排列问题</a></li>
<li><a href="http://c.biancheng.net/view/3400.html">回溯算法详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/165083789">回溯算法详细总结</a></li>
<li><a href="https://blog.csdn.net/weiyuefei/article/details/79316653">[回溯算法] 五大常用算法之回溯法</a></li>
<li><a href="https://www.jianshu.com/p/dd3c3f3e84c0">小白带你学&ndash;回溯算法</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/93530380">回溯算法套路详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/308282208">关于回溯算法，你该了解这些！</a></li>
<li><a href="https://blog.csdn.net/m0_52824954/article/details/123467217">彻底搞懂回溯算法（本文真的很详细）</a></li>
<li><a href="https://www.cnblogs.com/Curryxin/p/15139654.html">【算法】回溯</a></li>
<li><a href="https://blog.csdn.net/weixin_43208423/article/details/101081544">理解回溯算法——回溯算法的初学者指南</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BFS and DFS Made Easy]]></title>
    <link href="http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy/"/>
    <updated>2022-09-02T22:43:13+08:00</updated>
    <id>http://toughcoder.net/blog/2022/09/02/bfs-and-dfs-made-easy</id>
    <content type="html"><![CDATA[<p>深度优先搜索和广度优先搜索在二维数据结构中有着非常重要和广泛的应用，今天就来好好的学习和总结一下这两种遍历方法。</p>

<p><a href=""><img src="https://image1.slideserve.com/3266131/generic-dfs-and-bfs-n.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>基础概念和代码模板</h2>

<p>先来学习一下基础的概念，其实也并不复杂。</p>

<h3>广度优先搜索</h3>

<p>BFS（Breadth First Search）是指优先把与当前节点相连的节点遍历，然后再把相连的节点的所有相连节点遍历，直到所有节点都遍历完。看起来就是一层一层的遍历（树），或者一圈一圈的遍历，像水中的波浪一样从中心点不断向外扩散。</p>

<p>它的遍历特点是，能把最近的两个节点优先遍历到，换句话说，它能找到从某个节点开始到另一个节点的最短路径，这一点相当重要，因此在图相关的搜索中用的较多一些。
<img src="https://www.guru99.com/images/1/020820_0543_BreadthFirs1.png" alt="" />
<img src="https://image1.slideserve.com/1838814/breadth-first-search1-n.jpg" alt="" /></p>

<h3>深度优先搜索</h3>

<p>DFS（Depth First Search），顺着节点的一个方向，不断深入，专注于一个方向直到这个方向上没有节点了（到达了叶子，或者到达了边界，或者最后一个节点）；然后再回到最初的节点，换一个方向，继续前行，直到所有节点都遍历完成。它的特点是只认准一个方向，不撞南墙不回头。</p>

<p>DFS在树中应用是最多的，因为树只有两个方向，一个左子树一个右子树。通常DFS用来解决特定路径相关的问题。
<img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.ccpQCah8fvV1NBvExUtwPgHaFj?pid=ImgDet&amp;rs=1" alt="" />
<img src="https://totheinnovation.com/wp-content/uploads/2021/01/DFS.jpg" alt="" /></p>

<h2>在树中的应用</h2>

<p>树的遍历和路径相关的问题，一般用DFS较为方便，树是最方便用递归的，因此递归 式DFS是解决树的遍历和路径的最广泛的方法。比如，经典的树三种遍历方式（前，中后）如果用递归式DFS来写就相当的简洁。可以<a href="http://toughcoder.net/blog/2022/08/18/binary-tree-made-easy/">参考这篇文章</a>来学习更多关于树的知识。
<img src="https://ts1.cn.mm.bing.net/th/id/R-C.8ceefec538766c3ddf768cea06cc1e15?rik=rr1dG%2bcUB9lblw&amp;riu=http%3a%2f%2fwww.crazyforcode.com%2fwp-content%2fuploads%2f2016%2f04%2fDFS.png&amp;ehk=mijFhhVLUHbPmAS9hIQz8z2gIQG%2fH7pE5QgwSuDB%2bOA%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" /></p>

<p>DFS对于树的大多数问题都是较好的选择，但有一类题，就是层序遍历相关的问题，DFS可能没有优势，因为层序遍历就是用BFS最为直接，通常实践得知，对于树来说，通常BFS的效率要差于DFS。而且对于树来说，BFS能搞定的问题，DFS也一定可以。</p>

<p>那么如何用DFS解决与层有关的问题呢？要借助额外的数据来标记当前节点是在哪一层。树DFS的遍历特点是仍旧是从左下到右下的，而且也是从上到下的（前序而言），因此DFS最先遇到的节点，肯定 是这 一层的第一个节点。DFS也是知道当前节点是属于哪一层的，根节点是第1 层，下一层就是第2层，可以把这个作为参数在DFS过程中传递。额外的数据可以是哈希表，键值就是层序号，值可以节点，当某一层为空时，来的肯定是第一个节点，如果某一层已存在，就可以追加节点，或者依据条件做运算。这样最终也能实现关于层的操作。最为典型的就是<a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">题662. 二叉树最大宽度</a>。</p>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">662. 二叉树最大宽度</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/solution/by-alexhilton-2be9/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>在图中的应用</h2>

<p>对于图来说，因为它可能有多个方向，像矩阵有四个，常规图可能有更多个与其相连的节点，而图的搜索通常是发生在相连的多个节点之间的，因此在图的搜索里面BFS的应用更为广泛。像求一些最短路径，最近距离，拓朴排序等都是用的BFS。</p>

<h3>矩阵表示的图</h3>

<h3>邻接表表示的图</h3>

<h3>典型题目</h3>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/number-of-islands/solution/200-dao-yu-shu-liang-by-alexhilton-cexx/">题解</a> </td>
<td style="text-align:left;"> 基础 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/max-area-of-island/">695. 岛屿的最大面积</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/max-area-of-island/solution/by-alexhilton-9eby/">题解</a> </td>
<td style="text-align:left;"> 基础 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/flood-fill/">733. 图像渲染</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/flood-fill/solution/733-tu-xiang-xuan-ran-by-alexhilton-mem7/">题解</a> </td>
<td style="text-align:left;"> 单源BFS/DFS </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/01-matrix/">542. 01 矩阵</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/01-matrix/solution/by-alexhilton-ngwy/">题解</a> </td>
<td style="text-align:left;"> 多源BFS </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotting-oranges/">994. 腐烂的橘子</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotting-oranges/solution/994-fu-lan-de-ju-zi-by-alexhilton-6g10/">题解</a> </td>
<td style="text-align:left;"> 多源BFS </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>

<ul>
<li><a href="https://blog.csdn.net/g11d111/article/details/76169861">BFS——广度优先算法（Breadth First Search）</a></li>
<li><a href="https://samuel92.blog.csdn.net/article/details/75645970">DFS——深度优先算法（Depth First Search）</a></li>
<li><a href="https://www.guru99.com/difference-between-bfs-and-dfs.html">BFS Vs. DFS: Know the Difference with Example</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[双指针总结]]></title>
    <link href="http://toughcoder.net/blog/2022/08/25/summary-of-double-pointers/"/>
    <updated>2022-08-25T22:06:31+08:00</updated>
    <id>http://toughcoder.net/blog/2022/08/25/summary-of-double-pointers</id>
    <content type="html"><![CDATA[<p>双指针是指用两个引用或者索引，或者某种键为主的操作手段，在很多场景有重要的应用，比如链表。有些时候还能成为比较巧妙的解题手段。今天就来总结一下双指针的使用。</p>

<p><a href=""><img src="https://ducmanhphan.github.io/img/Algorithm/two-pointer/two-pointers-in-two-sequences.png" title="auto auto" ></a></p>

<!-- more -->


<h2>双指针的套路</h2>

<p>根据不同的场合和用法，双指针可以分为<strong>同向双指针</strong>和<strong>对撞指针</strong>。</p>

<h3>同向双指针</h3>

<p>又可以细分为滑动窗口，以及快慢指针。</p>

<h4>滑动窗口</h4>

<p>两个指针，通常一个慢一个快，之间的子数组具有某种特质，快指针（也称右指针）正常向前遍历，新元素会加入，同时左指针也会向前移动，就像一个向前开动的公交车一样。</p>

<p>有些窗口大小是固定的，有些则是不固定的，看具体情况而定，新元素进入以及窗口中的元素移出窗口也要视题目中的具体条件而定。</p>

<h4>快慢指针</h4>

<p>最为经典的场景就是解决一坨单链表问题，比如找链表的中间节点，或者找环，以及归并等等。</p>

<p>此外，快慢指针也常用于数组，通常是涉及数组的元素移动，此类型的要点就是一个指针正常遍历原数组，此为快指针，一个指针用指向结果数组，快指针正常遍历，慢指针依据某些条件才向后移动。</p>

<h3>对撞指针</h3>

<p>就是一个从前往后遍历，一个从后往前遍历，循环中止条件是两指针相遇，通常用在二分查找，回文相关，反转数组列表，或者其他场合。</p>

<h2>双指针技巧</h2>

<p>双指针，除了以上几种比较典型之外啊，其实也挺宽泛的，只要用了两个以上的指针（下标）就算得上是双指针，也没啥固定的模式。</p>

<p>但有时，有两个常见的技巧能大幅优化效率和代码，一个就是<strong>逆向思维</strong>，比如一些涉及归并的题目中，如果用常规思路，从前往后，可能用额外空间才可以，但如果从后往前，或者从两头往中间，可能就打开了一片新天地。这里的正向和逆向视具体情况而定，比如有些归并类的是直觉上是从前往后，那这就是正向，从后往前则是逆向；再如一些中间分段的数组如山峰或者山谷形的，从间往往两头是正向，那从两头往中间则逆向。如题977。</p>

<p>还有一个技巧是，如果要求返回数组的顺序由原数组决定，但数据 的选择由计算规则确定，也就是说我们是在计算后的数组上应用双指针进行选择，但又要返回原数据中的数据顺序，这时呢，其实可以不必直接用双指针在计算后的数组中选择结果，可以先行移动指针到目标范围，然后再遍历去选择结果。典型的问题是题658。</p>

<h2>典型问题</h2>

<table>
<thead>
<tr>
<th style="text-align:left;"> 题目 </th>
<th style="text-align:left;"> 题解 </th>
<th style="text-align:left;"> 要点说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/solution/by-alexhilton-a4qc/">题解</a> </td>
<td style="text-align:left;"> 经典对撞指针 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/find-k-closest-elements/">658. 找到 K 个最接近的元素</a> </td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/find-k-closest-elements/solution/by-alexhilton-ixrs/">题解</a> </td>
<td style="text-align:left;"> 先移指针到目标范围，再选择结果 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">977. 有序数组的平方</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/squares-of-a-sorted-array/solution/977-you-xu-shu-zu-de-ping-fang-by-alexhi-hcu8/">题解</a> </td>
<td style="text-align:left;"> 逆向思维</td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/container-with-most-water/solution/by-alexhilton-1va8/">题解</a> </td>
<td style="text-align:left;"> 对撞指针 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reverse-words-in-a-string-iii/">557. 反转字符串中的单词 III</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/reverse-words-in-a-string-iii/solution/by-alexhilton-qn2n/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/rotate-array/solution/189-lun-zhuan-shu-zu-by-alexhilton-1ih4/">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/middle-of-the-linked-list/solution/by-alexhilton-0uz4/">题解</a> </td>
<td style="text-align:left;"> 经典快慢指针 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/19-shan-chu-lian-biao-de-dao-shu-di-n-ge-xa3i/">题解</a> </td>
<td style="text-align:left;"> 经典快慢指针 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/permutation-in-string/">567. 字符串的排列</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/permutation-in-string/solution/by-alexhilton-80gu/">题解</a> </td>
<td style="text-align:left;"> 经典滑动窗口 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></td>
<td style="text-align:left;"> <a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-by-alexhilton-ecxc/">题解</a> </td>
<td style="text-align:left;"> 滑动窗口 </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
<tr>
<td style="text-align:left;"> <a href=""></a></td>
<td style="text-align:left;"> <a href="">题解</a> </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<h2>参考资料</h2>
]]></content>
  </entry>
  
</feed>
