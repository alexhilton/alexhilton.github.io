<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Designpattern | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/designpattern/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2023-01-11T22:56:41+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Understanding the Observer Pattern]]></title>
    <link href="http://toughcoder.net/blog/2023/01/11/understanding-observer-pattern/"/>
    <updated>2023-01-11T22:21:24+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/11/understanding-observer-pattern</id>
    <content type="html"><![CDATA[<p>观察者模式是用于解耦的，把不同功能的类，而又对某一共同事件或者消息感兴趣解耦开来，使双方互不知道对方。常规的实现是通过接口的方式来把需要关注的消息封装起来，双方各自实现接口即可。</p>

<p><a href=""><img src="https://i1.wp.com/www.jeremyshanks.com/wp-content/uploads/2018/04/The-Observer-Pattern.jpg?fit=750%2C750" title="auto auto" ></a></p>

<!-- more -->


<h2>理解观察者模式</h2>

<h3>什么是观察者模式</h3>

<p>观察者模式Observer pattern
非常基础的，用于解耦发布类型的，对象之间有消息依赖的一种设计模式。讲解可以<a href="https://blog.csdn.net/itachi85/article/details/50773358">参考这个</a>。
它的特点是，用接口来隔离主题对象（被关注者）和观察者，观察者被动接收来自主题的变化，然后更新自己的状态。
它的特点是，代码层面有直接的依赖，也就是说Observable与Observer相互知道对方的存在，且代码上面有直接的编译依赖关系。
是同步的，也就是说Observable触发了通知后，Observer立即得到消息，并进行更新自己状态的动作。
通常是一对多，也就是只有一个Observable，但是可以有多个Observer。
通常不涉及并发。
所以，它通常用在同一个模块内部，小范围，局部的发布关系。</p>

<p>观察者模式出面的比较早，而且是一个基础模式，随着软件科技的发展，软件越来越复杂，比如组件的出现，多中间件的出现，远程（服务器客户端），并发和多线程多进程的出现，导致观察者模式不再适用，需要升级。</p>

<h3>观察者模式的示例</h3>

<h3>什么时候用观察者械</h3>

<h2>发布-订阅模式</h2>

<p>这时就是出现了发布-订阅者模式（Publisher-Subscriber pattern）
讲解可以看<a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber">这里</a>和<a href="http://www.code2succeed.com/pub-sub/">这里</a>
向外发布消息的叫Publisher，它与Observable类似，但最重要的区别在于，它不知道Subscriber的存在，它是直接像一个第三方的消息队列，或者叫做消息平台，发布消息。而Subscriber，也是直接向消息队列或者消息平台订阅。
组件间，甚至是不同的应用之间的发布模型。
异步的，就说是发布者是往消息队列发消息，然后就算发布完成了。订阅者是从消息队列拿消息。Publisher与Subscriber之间并无同步关系。一个消息发布出去，接收时间不确定。
对应该关系自由，可以多对多，也可以多对一或者一对多。
支持并发。
安卓里面非常著名的EventBus就是这一模式的经典实现。以及Linux世界里的dbus也是这种。</p>

<p>关于观察者模式与发布者模式区别可以看<a href="https://hackernoon.com/observer-vs-pub-sub-pattern-50d3b27f838c">这篇文章</a>。</p>

<h2>生产者消费者模式</h2>

<p>再有一个比较类似的就是生产者和消费者模式(Producer consumer patter）
更为复杂，为异步而生，通常涉及多线程。</p>

<h2>参考资料</h2>

<ul>
<li><a href="http://www.ni.com/tutorial/3023/zhs/">LabVIEW​之​生产​者/​消费​者​架构</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/how-to-implement-a-producer-consumer-dataflow-pattern">How to: Implement a producer-consumer dataflow pattern</a></li>
<li><a href="https://dzone.com/articles/producer-consumer-pattern">The Producer Consumer Pattern</a></li>
<li><a href="https://learn.microsoft.com/en-us/dotnet/standard/events/observer-design-pattern">Observer Design Pattern</a></li>
<li><a href="https://www.tutorialspoint.com/design_pattern/observer_pattern.htm">Design Patterns - Observer Pattern</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
