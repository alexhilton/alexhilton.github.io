<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rxjava | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/rxjava/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2023-01-05T23:15:23+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Introduction to RxJava]]></title>
    <link href="http://toughcoder.net/blog/2023/01/05/introduction-to-rxjava/"/>
    <updated>2023-01-05T22:57:44+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/05/introduction-to-rxjava</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/ReactiveX/RxJava">RxJava</a>是一个异步数据流式的开源库，已流行于Android开发行业中多年，现在已经变成了Android开发的一个标配，几乎所有，是的几乎所有的项目都会使用它（即使大部分人并没有真的在用它）。也几乎每个开发人员的简历中都会写着熟悉RxJava，甚至是精通RxJava，可见它的流行程度，今天就来学习一下RxJava的基本使用。</p>

<p><a href=""><img src="https://ts1.cn.mm.bing.net/th/id/R-C.8bf825c83d71d679305006ad8877881f?rik=ntxCAiBD5wztvw&amp;riu=http%3a%2f%2fwww.allaboutweb.biz%2fwp-content%2fuploads%2f2018%2f04%2fWhat-is-RxJava.jpg&amp;ehk=K75BZ9hKVA%2bAu7Gjm9QXOAtzL3uOtKQeoRkvFi1KDAA%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" title="auto auto" ></a></p>

<!-- more -->


<h2>理解Observable</h2>

<p>一个Observable就是一个会发出事件的机器，这里事件是一个数据的意思。就好比marble球，一个Observable就是一个可以不断发射出marble的机器。</p>

<p>可以把它想像成一个无限列表，但并不是常规意义上的List，因为它是异步的，这里异步的意思是，同一个时间内，你看不到所有的元素，对于常规意义上的列表是同步的，意思是拿到列表时，里面的数据 全在。但Obsersable是异步的，拿到Obsersable时，可能还没有数据。数据是有时序的，有点类似于信号。如果你收集齐了Obserable发出的所有数据，假设它是有限的（比如从一个真正列表创建的Obserable），那么得到的就是一个列表。</p>

<p>Observable最佳的类比就是一个物理信号，是有时域上的概念。</p>

<h2>常见的Operator</h2>

<h3>Map</h3>

<p>比较容易理解，把Obserable发出的事件进行转换。提供一个函数，输入就是Observable发出的数据，输出就是转换后的结果。针对发出的事件每个都应用提供的函数。</p>

<h3>concatMap</h3>

<p>与flatMap类似，保证顺序。</p>

<h3>flatMap</h3>

<p>先做map，然后再做flat，把二维结构展平为一维，也即是把Obserable of Obserable展平为一个Obserable。传入的map函数必须是返回一个Observable，也即是把常规数据转化为一个Obserable。</p>

<p>此外，它的每个map操作可以是并行的，不能保证先后顺序，如果想保证顺序要使用concatMap。</p>

<h3>switchMap</h3>

<h3>combineLatest</h3>

<p>Operator就是数据的管道，用以把各种不同的数据发射器(Observable)连接起来，一起组成一个能够从源头数据，通过管道计算，最终生成符合预期的数据，流出到Observer（也即Subscriber）那里</p>

<h2>常见的技巧</h2>

<h3>RxBinding只能被subscribe一次</h3>

<p>一般来说一个Observable，只能被subscribe一次。</p>

<p>但总的说 是分为冷和热，对于冷的，一般是有限集合的Observable，它可以被subscribe无限次，且每个observer接收到的东西是一样的。</p>

<p>但对于热的，就不一样，有些可以被subscribe多次，有些则不能。</p>

<p>subscribe多个Observer叫做multicast。
对于cold的，可以通过ConnectableObesrver，通过connect，来让几个Oberver同步接收来自Observable的emission。</p>

<p>但是对于hot的Obervable，如何 让 不同的Observer同步接收emission呢？
就比如说RxBinding中的大部分来自于View的事件Observable，都是hot的，并且，它们默认情况下，不能被multicast，只有最后一个subscribe的Observer，才可以接收事件。</p>

<p>这时就需要把Observable share一下。通过share()，之后就可以multicast了。</p>

<h3>如何做Recursion</h3>

<p>有一些场景是会出现循环，或者说Recursion的，比如说像文件遍历，对于文件夹的操作，是需要Recursion的。</p>

<p>这里就有两种场景，一种会在某个节点停留，用户具体进一步操作才会深入的遍历的情况，比如像文件浏览器，展示的就是当前的文件夹，用户点子目录，才会更进一步。这种场景，需要Hold住当前的文件夹，但当有新的文件夹变成当前文件夹时，它需要更新数据，这种数据产生的闭环，可以用Subject来解决。</p>

<p>但，如果是一个完整的遍历流程，从根节点开始，一直到所有的叶子为止，那么用subject可能就不太合适。这时就需要用一些Recursion来解决，可以看一些网络上的例子。需要用到常规的recursion方式，先要弄一个方法，在里面做出reactive chain，就是在Reactive链里面再调用这个方法，以此递归下去。不过，不知道这个当有一些耗时操作时，会不会造成堆积，以及会不会有资源释放的问题，有待考查。</p>

<p>Reactive这玩意儿，确实难度较大，想写出符合Reactive规范，且正确的代码还是相当难的。而且它难以调试，有时候完全不知道错在哪里。</p>

<h2>书籍推荐</h2>

<p>RxJava的学习曲线 非常之陡峭，它融合了异步，多线程，函数式编程和响应式编程，集多种编程范式于一体，要想真正的用好RxJava需要深度理解RxJava本身，更需要函数式和响应式编程的一些思维。必须要以Reactive的方式来架构你的应用程序，这才能真正算得上使用了RxJava。比如仅是用了几个Observable，用了几个operator，但是整体项目的代码仍是状态变量散落一大堆，这根本不叫用了RxJava，这仅仅是把RxJava当成工具来用了，并没真正践行它的精髓思想。</p>

<p>要想学好RxJava必须要啃书，它的学习曲线陡峭，并不是看了文档就能用（那根本不叫Reactive，仅是把RxJava当成工具类了），通过啃书达到一定的理解深度，然后再在项目中去实践。</p>

<h3>《Learning RxJava》</h3>

<p>这本书对于深入的理解RxJava本身非常有帮助，它比官方文档要详细得多，具体给你解释什么是Observable，什么是Observer以及各种operator，并且都带有实例。这本书，不建议从头读到尾，而是要像文档一样对待，需要深入理解哪个知点点的时候就去具体看那一章节就好。</p>

<p>书中的示例非常短小精悍，但能非常好的帮助你理解对应的知识点。</p>

<p>这本书的目的是让你更深入的了解RxJava这一库的本身，也就是说让你更好的了解工具本身。但这远远不够，即使把这本书看完，你仍旧会是把RxJava当成一个工具类来使用。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/">ReactiveX/RxJava文档中文版</a></li>
<li><a href="https://reactivex.io/">ReactiveX</a></li>
<li><a href="https://github.com/ReactiveX/RxJava">RxJava</a></li>
<li><a href="https://www.journaldev.com/19300/rxjava-flatmap-switchmap-concatmap">RxJava flatMap, switchMap, concatMap</a></li>
<li><a href="https://www.androidhive.info/RxJava/map-flatmap-switchmap-concatmap/">RxJava Operators – Understanding Map, FlatMap, SwitchMap and ConcatMap</a></li>
<li><a href="https://juejin.cn/post/6844903914022633486">从源码查看RxJava中的map和flatMap的用法与区别</a></li>
<li><a href="https://www.jianshu.com/p/0cd258eecf60">这可能是最好的RxJava 2.x 教程（完结版）</a></li>
<li><a href="https://gank.io/post/560e15be2dca930e00da1083">给 Android 开发者的 RxJava 详解</a></li>
<li><a href="https://colobu.com/2016/07/25/understanding-rxjava-thread-model/">理解RxJava的线程模型</a></li>
<li><a href="https://www.baeldung.com/rxjava-multiple-subscribers-observable">RxJava One Observable, Multiple Subscribers</a></li>
<li><a href="https://www.baeldung.com/rx-java">Introduction to RxJava</a></li>
<li><a href="https://medium.com/bystevenp/comment-trees-and-recursion-with-rxjava-d147a904610a">Comment Trees and Recursion with RxJava</a></li>
<li><a href="https://stackoverflow.com/questions/31246088/how-to-do-recursive-observable-call-in-rxjava">How To Do Recursive Observable Call in RxJava?</a></li>
<li><a href="https://medium.com/@stevenlow1983/rx-java-and-recursion-719f8ee1977a">RX Java and Recursion</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
