<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rxjava | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/rxjava/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2023-01-11T22:56:41+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Upgrade to RxJava 3]]></title>
    <link href="http://toughcoder.net/blog/2023/01/10/upgrade-to-rxjava-3/"/>
    <updated>2023-01-10T21:36:44+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/10/upgrade-to-rxjava-3</id>
    <content type="html"><![CDATA[<p>RxJava从2015年问世，2016到2017开始流行，在2018到2019左右达到顶峰，几乎无人不会RxJava，无项目不用RxJava。这期间项目本身也在迭代，从1.0版本，到2.0版本，行业内流行最广的，用的人最多的，项目使用也最多的仍是2.0版本。时过境迁，现在虽然RxJava是一个项目的标配，但是现在它的受关注度，没有前几年高了，但仍有必要研究一下它的最新版本RxJava 3。</p>

<p><a href=""><img src="https://i0.wp.com/blog.mallow-tech.com/wp-content/uploads/2017/03/Multithreading-with-rxjava.png?fit=820%2C400&amp;ssl=1" title="auto auto" ></a></p>

<!-- more -->


<h2><a href="https://github.com/ReactiveX/RxJava">RxJava</a>的前世今生</h2>

<p>RxJava从诞生致今一共有三个大版本，区别都比较明显。最初是RxJava 1.0版本，它的特点是异步和数据流，核心思想仍是这些，但其它与<a href="https://reactivex.io/">Reactive Extensions</a>基本上是同步在迭代的，因此RxJava 1并不是完全符合Reactive Extensions规范的，并且它是基于Java 6.0语言的，对一些新的Java特性的支持并不好。</p>

<p>后来Rx编程范式渐渐流行起来，以及Java语言本身的发现，所以就有了RxJava 2.0，它是Reactive Extensions的一个标准实现，也就是说从RxJava 2.0开始，是完全符合Rx规范的。RxJava 2.0版本并不是基于1.0版本的迭代，而是完全重写的，基于Rx规范从新实现的。对一些东西如函数的定义，以及像方法的名字都进行了规范化。这也是流行最广泛的一个版本，坊间绝大多数资料都是基于RxJava 2的，很多其他三方的开源库，如RxAndroid等也都基于此。</p>

<p>RxJava 2.0版本有单独的groudId是<strong>io.reactivex.rxjava2</strong>，可以用以区分。</p>

<h2>RxJava 3.0</h2>

<p>技术仍在不断的演进，RxJava最新的版本是3.0，它是基于2.0的迭代，并没有像1.0到2.0那样完全重写。主要的变化 是更加符合Rx规范，性能进一步的提高。1.0和2.0都已停止维护了。它也有单独的groudId是<strong>io.reactivex.rxjava3</strong>，可以与2.0进行区分。</p>

<h3>包结构变化</h3>

<p>代码层面的包名是有明显变化的，对代码进行了更好的组织。1.0和2.0都是在io.reactivex，到了3.0组件都有了单独的package。</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> Component </th>
<th style="text-align:left;"> RxJava 2 </th>
<th style="text-align:left;"> RxJava 3 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> Core </td>
<td style="text-align:left;"> io.reactivex </td>
<td style="text-align:left;"> io.reactivex.rxjava3.core </td>
</tr>
<tr>
<td style="text-align:center;"> Annotations </td>
<td style="text-align:left;"> io.reactivex.annotations </td>
<td style="text-align:left;"> io.reactivex.rxjava3.annotations </td>
</tr>
<tr>
<td style="text-align:center;"> Disposables </td>
<td style="text-align:left;"> io.reactivex.disposables </td>
<td style="text-align:left;"> io.reactivex.rxjava3.disposables </td>
</tr>
<tr>
<td style="text-align:center;"> Exceptions </td>
<td style="text-align:left;"> io.reactivex.exceptions </td>
<td style="text-align:left;"> io.reactivex.rxjava3.exceptions </td>
</tr>
<tr>
<td style="text-align:center;"> Functions </td>
<td style="text-align:left;"> io.reactivex.functions </td>
<td style="text-align:left;"> io.reactivex.rxjava3.functions </td>
</tr>
<tr>
<td style="text-align:center;"> Flowables </td>
<td style="text-align:left;"> io.reactivex.flowables </td>
<td style="text-align:left;"> io.reactivex.rxjava3.flowables </td>
</tr>
<tr>
<td style="text-align:center;"> Observables </td>
<td style="text-align:left;"> io.reactivex.observables </td>
<td style="text-align:left;"> io.reactivex.rxjava3.observables </td>
</tr>
<tr>
<td style="text-align:center;"> Subjects </td>
<td style="text-align:left;"> io.reactivex.subjects </td>
<td style="text-align:left;"> io.reactivex.rxjava3.subjects </td>
</tr>
<tr>
<td style="text-align:center;"> Processors </td>
<td style="text-align:left;"> io.reactivex.processors </td>
<td style="text-align:left;"> io.reactivex.rxjava3.processors </td>
</tr>
<tr>
<td style="text-align:center;"> Observers </td>
<td style="text-align:left;"> io.reactivex.observers </td>
<td style="text-align:left;"> io.reactivex.rxjava3.observers </td>
</tr>
<tr>
<td style="text-align:center;"> Subscribers </td>
<td style="text-align:left;"> io.reactivex.subscribers </td>
<td style="text-align:left;"> io.reactivex.rxjava3.subscribers </td>
</tr>
<tr>
<td style="text-align:center;"> Parallel </td>
<td style="text-align:left;"> io.reactivex.parallel </td>
<td style="text-align:left;"> io.reactivex.rxjava3.parallel </td>
</tr>
<tr>
<td style="text-align:center;"> Internal </td>
<td style="text-align:left;"> io.reactivex.internal </td>
<td style="text-align:left;"> io.reactivex.rxjava3.internal </td>
</tr>
</tbody>
</table>


<p>使用起来更加的清晰和规范，并且不与老版本有冲突。</p>

<h3>与Java 8更好的融合</h3>

<p>另外一个重大改进就是与新版本的Java，即Java 8有了更好的融合，支持了好多Java 8中的数据类型。比如Optional和Stream：</p>

<ul>
<li>Observable.fromOptional()</li>
<li>Observable.fromStream</li>
<li>Observable.mapOptional</li>
<li>Observable.blockingStream</li>
<li>Observable.flatMapStream</li>
</ul>


<h3>行为变化</h3>

<p>因为RxJava 2.0是符合Rx规范的，所以大部分功能和核心概念在3.0上面是没有变化的。只有在一些高级的概念上面有一些差别，比如错误处理有加强，以前在2.0时有些error会丢失，并且不会被处理，3.0上加强了error的流动，保证它能到达Subscriber。</p>

<p>另外一个重要变化 就是在multicast，也即针对Hot Observables的共享问题，多了一个reset方法，以让所有Subscriber都接收到同样的数据。</p>

<p>还有就是Flowable有了pause的功能。</p>

<h3>三方库的兼容</h3>

<p>还要注意三方库如Retrofit adapter，RxAndroid以及RxBinding等也是与RxJava的版本绑定的，要注意它们之间版本的匹配。</p>

<h2>升级建议</h2>

<p>因为RxJava 1并不完全符合Rx规范，所以如果还在用RxJava 1，那么是要立即升级到3.0。</p>

<p>因为RxJava 2.0是最流行的版本，所以现在大部分项目使用的应该是RxJava 2.0。那么就要看项目本身的情况，如果RxJava 2.0能完全满足项目的需要，没有用到太多高级的特性（如multicast或者Flowable），而且项目中重点引用RxJava的部分也基本上成成熟了，此种情况下，其实不建议升级到3.0，因为不会带来多少收益。</p>

<p>相反，如果使用了大量的高级特性，甚至还遇到了RxJava本身导致的问题，并且项目中还在大量使用RxJava，未来新功能的开发也会使用RxJava，那么还是尽早升级为妙。同时要注意，RxJava是一个流行的库，有很多三方库的依赖于它，版本一旦变动，会引发链式反应，要注意版本的匹配，以免发生不兼容的情况。</p>

<p>可以到这里找到<a href="https://github.com/ReactiveX/RxJava/releases">最新的版本</a>。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://github.com/ReactiveX/RxJava/wiki/What's-different-in-3.0">What&rsquo;s different in 3.0</a></li>
<li><a href="https://prog.world/whats-new-in-rxjava-3/#:~:text=There%20was%20a%20problem%20with%20hot%20sources%20in,to%20enable%20newly%20connected%20subscribers%20to%20process%20data.">What’s New in RxJava 3</a></li>
<li><a href="https://stackoverflow.com/questions/38423079/differences-between-rxjava1-and-rxjava2">Differences between RxJava1 and RxJava2</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Beyond RxJava]]></title>
    <link href="http://toughcoder.net/blog/2023/01/07/beyond-rxjava/"/>
    <updated>2023-01-07T09:47:50+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/07/beyond-rxjava</id>
    <content type="html"><![CDATA[<p>RxJava是一种编程范式，它并不是一个库，而是一种编程思想，一种解决问题的新思路，一种架构思想。因此，基于RxJava还有大量的其他的库，可以一起更容易让用RxJava构建应用程序。</p>

<p>其他书籍和文档也有提及，这些东西称为<a href="https://github.com/davidmoten/rxjava-extras">RxJava Extras</a>。</p>

<p><a href=""><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.YSq989RaoMIlYVnsxoBOLQHaE8?pid=ImgDet&amp;rs=1" title="auto auto" ></a></p>

<!-- more -->


<h2><a href="https://github.com/ReactiveX/RxAndroid">RxAndroid</a></h2>

<p>这是Jake Wharton大神弄的，但其实这个库里面的东西比较少。</p>

<p>最为常用的就是Schedulers之中的AndroidScheduler.main()，这个是在切线程时常用到的。其他的好像也没啥。</p>

<h2><a href="https://github.com/JakeWharton/RxBinding">RxBinding</a></h2>

<p>主要是处理Android UI的响应事件，它把UI响应事件，如OnClick，onTouch和onTextChanged等变成一个Observable。方便创建数据流。</p>

<p>虽然从语义上理解，这些UI事件的Observable应该是hot的，但是它们并不支持multicast。也就是说如果想用UI事件创建的Observable，创建两个数据处理流程，就需要去multicast。</p>

<p>方法就是可以用share()，之后就可以multicast了。</p>

<p>但这里也需要处理资源清理问题，因为事件都是通过向View添加listener来实现的，那么如何及时的清理listener，这个需要研究一下。</p>

<h2><a href="https://github.com/tbruyelle/RxPermissions">RxPermissions</a></h2>

<p>专门处理权限问题。权限，因为必须先调用request，然后在onActivityResult里面去处理，所以你的代码逻辑必然会被分成两段：</p>

<p>初始化时，比如：</p>

<pre><code class="python">onCreate
if permission granted
   doOurThings
else request permissions

onActivityResult
if permission granted:
   do Our things
</code></pre>

<p>如果以Rx方式来理解，权限也是一个数据流，可能来一个granted或者rejected的权限，虽然状态不一样，但都可以理解 为权限数据，而且数据的发射是异步的，你不知道什么时候数据来。因此完全可以用Rx的方式来处理权限。</p>

<p>尝试失败，因为依赖无法添加。尝试网上解决方案仍无效，依赖无法添加。暂先放弃。
后面再观察一下吧，如果真心想用，只有以源码方式来集成，试用。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.jianshu.com/p/517c3f4c7bc1">RxAndroid使用初探—简洁、优雅、高效</a></li>
<li><a href="https://github.com/ReactiveX/RxAndroid/wiki">RxAndroid Extensions</a></li>
<li><a href="https://www.jianshu.com/p/34cf96b72102">RxBinding详解: 规范而强大的安卓UI响应式编程</a></li>
<li><a href="https://juejin.cn/post/6844903886507999246">RxPermissions使用总结</a></li>
<li><a href="https://www.raywenderlich.com/books/reactive-programming-with-kotlin">Reactive Programming with Kotlin</a></li>
<li><a href="https://github.com/davidmoten/rxjava2-extras">Utilities for use with RxJava 2</a></li>
<li><a href="https://github.com/davidmoten/rxjava-extras">Utilities for use with rxjava</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to RxJava]]></title>
    <link href="http://toughcoder.net/blog/2023/01/05/introduction-to-rxjava/"/>
    <updated>2023-01-05T22:57:44+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/05/introduction-to-rxjava</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/ReactiveX/RxJava">RxJava</a>是一个异步数据流式的开源库，已流行于Android开发行业中多年，现在已经变成了Android开发的一个标配，几乎所有，是的几乎所有的项目都会使用它（即使大部分人并没有真的在用它）。也几乎每个开发人员的简历中都会写着熟悉RxJava，甚至是精通RxJava，可见它的流行程度，今天就来学习一下RxJava的基本使用。</p>

<p><a href=""><img src="https://ts1.cn.mm.bing.net/th/id/R-C.8bf825c83d71d679305006ad8877881f?rik=ntxCAiBD5wztvw&amp;riu=http%3a%2f%2fwww.allaboutweb.biz%2fwp-content%2fuploads%2f2018%2f04%2fWhat-is-RxJava.jpg&amp;ehk=K75BZ9hKVA%2bAu7Gjm9QXOAtzL3uOtKQeoRkvFi1KDAA%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" title="auto auto" ></a></p>

<!-- more -->


<h2>理解基本的范式</h2>

<p>RxJava是Reactive Extensions的Java实现，是基于数据流的响应式编程范式，同时结合了函数式编程，准确的来说它是函数式响应式编程范式FRP(Functional Reacive Programming)。核心思想是数据流和响应式。
一个Observable就是一个会发出事件的机器，这里事件是一个数据的意思。就好比marble球，一个Observable就是一个可以不断发射出marble的机器，它就是一个数据流。
<img src="https://ts1.cn.mm.bing.net/th/id/R-C.2f9fed625ff00e7f0cfa51632f7b9644?rik=8AI5UL%2fV%2bFQO2Q&amp;riu=http%3a%2f%2fwww.philosophicalhacker.com%2fwp-content%2fuploads%2f2015%2f06%2fwe_know_rxjava_is_observer_plus_iterator.jpg&amp;ehk=3KXNE20j2MAeyThqdNT%2bZX9DHY2wRHvlVLLrCeusLCc%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" />
可以把它想像成一个无限列表，但并不是常规意义上的List，因为它是异步的，这里异步的意思是，同一个时间内，你看不到所有的元素，对于常规意义上的列表是同步的，意思是拿到列表时，里面的数据 全在。但Observable是异步的，拿到Observable时，可能还没有数据。数据是有时序的，有点类似于信号。如果你收集齐了Observable发出的所有数据，假设它是有限的（比如从一个真正列表创建的Observable），那么得到的就是一个列表。</p>

<p>Observable最佳的类比就是一个物理信号，是有时域上的概念。</p>

<p><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.L_gen2R661qqPG-UbhM2lAHaDl?pid=ImgDet&amp;rs=1" alt="" /></p>

<p>Subscriber是数据的消费者，它是对数据的响应，由它来体现响应式Reactive。</p>

<p>我们需要做的就是把数据封装成为一个Observable，然后定义好一个响应数据的Subscriber，这就是FRP了。</p>

<pre><code class="java"> Observable.just("Hello, world of RxJava!")
           .subscribe(helloLabel::setText);
</code></pre>

<h2>常见的Operator</h2>

<h3>Map</h3>

<p>比较容易理解，把Observable发出的事件进行转换。提供一个单元函数（一个输入参数，一个输出参数），输入就是Observable发出的数据，输出就是转换后的结果。针对发出的事件每个都应用提供的函数。
<img src="https://www.adictosaltrabajo.com/wp-content/uploads/2017/06/rxjava_android_map.png" alt="" /></p>

<h3>concatMap</h3>

<p>与flatMap类似，保证顺序。</p>

<h3>flatMap</h3>

<p>先做map，然后再做flat，把二维结构展平为一维，也即是把Observable of Observable展平为一个Observable。传入的map函数必须是返回一个Observable，也即是把常规数据转化为一个Observable。</p>

<p>此外，它的每个map操作可以是并行的，不能保证先后顺序，如果想保证顺序要使用concatMap。</p>

<h3>switchMap</h3>

<h3>combineLatest</h3>

<p>Operator就是数据的管道，用以把各种不同的数据发射器(Observable)连接起来，一起组成一个能够从源头数据，通过管道计算，最终生成符合预期的数据，流出到Subscriber那里。</p>

<h2>常见的技巧</h2>

<h3>感知冷热</h3>

<p>Observable是一个数据流，可视为一个事件发射器，不断的向下游发送数据(emission)。但数据何时发送，以及发送多少，是有一些细微区别的，这就引出了Observable是有冷热之分(Cold vs Hot)。</p>

<p>在《Learning RxJava》这本书中有一个非常形象的比喻，cold Observables就像音乐CD，每次播放都能得到相同的内容。对于所有Subscriber来说，无论你啥时候去subscribe，都能得到同样的数据流，这就是cold的。大多数以数据集为基础创建的Observable都是cold的，如Observable.just, Observable.fromIterable以及像从数据库或者文件存储中读取的数据。</p>

<pre><code class="java">         Observable&lt;String&gt; source = Observable.just("alpha", "beta", "gamma");
        source.subscribe(s -&gt; System.out.println("Subscriber #1 received: " + s));

        source.subscribe(s -&gt; System.out.println("Subscriber #2 received: " + s));

         //Subscriber #1 received: alpha
        //Subscriber #1 received: beta
        //Subscriber #1 received: gamma
        //Subscriber #2 received: alpha
        //Subscriber #2 received: beta
        //Subscriber #2 received: gamma
</code></pre>

<p>Hot Observables则是像一个音乐广播电台，你今天收听到的内容，跟昨天收听到的内容是不一样的。不同的时间去subscribe会得到不一样的数据流，晚些subscribe就会错失前面的数据，这便是hot Observables。像一些无限数据集（比如社交信息，或者新闻信息），与时间有关的数据（如interval），以及用户事件都属于hot Observables。</p>

<h3>RxBinding只能被subscribe一次</h3>

<p>一般来说一个Observable，只能被subscribe一次。</p>

<p>但总的说 是分为冷和热，对于冷的，一般是有限集合的Observable，它可以被subscribe无限次，且每个Subscriber接收到的东西是一样的。</p>

<p>但对于热的，就不一样，有些可以被subscribe多次，有些则不能。</p>

<p>给一个Observable subscribe多个Subscriber的行为叫做multicast。
对于cold的，可以通过ConnectableObesrver，通过connect，来让几个Subscriber同步接收来自Observable的emission。</p>

<p>但是对于hot的Observable，如何 让 不同的Subscriber同步接收emission呢？
就比如说RxBinding中的大部分来自于View的事件Observable，都是hot的，并且，它们默认情况下，不能被multicast，只有最后一个subscribe的Observer，才可以接收事件。</p>

<p>这时就需要把Observable share一下。通过share()，之后就可以multicast了。</p>

<h3>如何做Recursion</h3>

<p>有一些场景是会出现循环，或者说Recursion的，比如说像文件遍历，对于文件夹的操作，是需要Recursion的。</p>

<p>这里就有两种场景，一种会在某个节点停留，用户具体进一步操作才会深入的遍历的情况，比如像文件浏览器，展示的就是当前的文件夹，用户点子目录，才会更进一步。这种场景，需要Hold住当前的文件夹，但当有新的文件夹变成当前文件夹时，它需要更新数据，这种数据产生的闭环，可以用Subject来解决。</p>

<p>但，如果是一个完整的遍历流程，从根节点开始，一直到所有的叶子为止，那么用subject可能就不太合适。这时就需要用一些Recursion来解决，可以看一些网络上的例子。需要用到常规的recursion方式，先要弄一个方法，在里面做出reactive chain，就是在Reactive链里面再调用这个方法，以此递归下去。不过，不知道这个当有一些耗时操作时，会不会造成堆积，以及会不会有资源释放的问题，有待考查。</p>

<p>Reactive这玩意儿，确实难度较大，想写出符合Reactive规范，且正确的代码还是相当难的。而且它难以调试，有时候完全不知道错在哪里。</p>

<h2>书籍推荐</h2>

<p>RxJava的学习曲线 非常之陡峭，它融合了异步，多线程，函数式编程和响应式编程，集多种编程范式于一体，要想真正的用好RxJava需要深度理解RxJava本身，更需要函数式和响应式编程的一些思维。必须要以Reactive的方式来架构你的应用程序，这才能真正算得上使用了RxJava。比如仅是用了几个Observable，用了几个operator，但是整体项目的代码仍是状态变量散落一大堆，这根本不叫用了RxJava，这仅仅是把RxJava当成工具来用了，并没真正践行它的精髓思想。</p>

<p>要想学好RxJava必须要啃书，它的学习曲线陡峭，并不是看了文档就能用（那根本不叫Reactive，仅是把RxJava当成工具类了），通过啃书达到一定的理解深度，然后再在项目中去实践。</p>

<h3>《Learning RxJava》</h3>

<p>这本书对于深入的理解RxJava本身非常有帮助，它比官方文档要详细得多，具体给你解释什么是Observable，什么是Observer以及各种operator，并且都带有实例。这本书，不建议从头读到尾，而是要像文档一样对待，需要深入理解哪个知点点的时候就去具体看那一章节就好。</p>

<p>书中的示例非常短小精悍，但能非常好的帮助你理解对应的知识点。</p>

<p>这本书的目的是让你更深入的了解RxJava这一库的本身，也就是说让你更好的了解工具本身。但这远远不够，即使把这本书看完，你仍旧会是把RxJava当成一个工具类来使用。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://mcxiaoke.gitbooks.io/rxdocs/content/">ReactiveX/RxJava文档中文版</a></li>
<li><a href="https://reactivex.io/">ReactiveX</a></li>
<li><a href="https://github.com/ReactiveX/RxJava">RxJava</a></li>
<li><a href="https://www.journaldev.com/19300/rxjava-flatmap-switchmap-concatmap">RxJava flatMap, switchMap, concatMap</a></li>
<li><a href="https://www.androidhive.info/RxJava/map-flatmap-switchmap-concatmap/">RxJava Operators – Understanding Map, FlatMap, SwitchMap and ConcatMap</a></li>
<li><a href="https://juejin.cn/post/6844903914022633486">从源码查看RxJava中的map和flatMap的用法与区别</a></li>
<li><a href="https://www.jianshu.com/p/0cd258eecf60">这可能是最好的RxJava 2.x 教程（完结版）</a></li>
<li><a href="https://gank.io/post/560e15be2dca930e00da1083">给 Android 开发者的 RxJava 详解</a></li>
<li><a href="https://colobu.com/2016/07/25/understanding-rxjava-thread-model/">理解RxJava的线程模型</a></li>
<li><a href="https://www.baeldung.com/rxjava-multiple-subscribers-observable">RxJava One Observable, Multiple Subscribers</a></li>
<li><a href="https://www.baeldung.com/rx-java">Introduction to RxJava</a></li>
<li><a href="https://medium.com/bystevenp/comment-trees-and-recursion-with-rxjava-d147a904610a">Comment Trees and Recursion with RxJava</a></li>
<li><a href="https://stackoverflow.com/questions/31246088/how-to-do-recursive-observable-call-in-rxjava">How To Do Recursive Observable Call in RxJava?</a></li>
<li><a href="https://medium.com/@stevenlow1983/rx-java-and-recursion-719f8ee1977a">RX Java and Recursion</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
