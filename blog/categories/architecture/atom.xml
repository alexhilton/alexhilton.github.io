<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Architecture | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/architecture/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2025-09-24T22:42:05+08:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[面向开发者的系统设计：像建筑师一样思考]]></title>
    <link href="https://alexhilton.github.io/blog/2025/09/24/system-design-for-developers/"/>
    <updated>2025-09-24T22:31:48+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/09/24/system-design-for-developers</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「System Design for Developers: Think Like an Architect」，原文链接<a href="https://towardsdev.com/system-design-for-developers-think-like-an-architect-87f32882ca28">https://towardsdev.com/system-design-for-developers-think-like-an-architect-87f32882ca28</a>，由Saurabh Singh发布于2025年8月25日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/1*b1eSMQdryXSteTJredbMtA.png" title="auto auto" ></a></p>

<!-- more -->


<blockquote><p>“建筑是一种社会行为，也是人类活动的物质舞台。”—— Spiro Kostof</p></blockquote>

<p>正如建筑师不会在没有蓝图的情况下开始建造一样，开发者也不应该在没有系统设计的情况下开始编码。然而，许多开发者直接进入实现阶段，却发现自己陷入了技术债务、性能瓶颈和架构噩梦的迷宫之中，而这些本可以通过适当的规划来避免。</p>

<p>系统设计是一门艺术和科学，它定义系统的架构、组件、模块、接口和数据，以满足特定需求。它就像一座屹立百年的房屋和一座因自身重量而倒塌的房屋之间的区别。</p>

<h2>建筑师的思维方式：分解复杂问题</h2>

<h2>分层思考，而非直线思考</h2>

<p>想象一下，你正在设计一座摩天大楼。你不会先决定第 47 层的墙壁要刷什么颜色。你会先从地基开始，然后是结构框架，接着是电气和管道系统，最后是室内设计。</p>

<p>软件系统也遵循同样的原则。想象一下<strong>可视化页面构建器应用程序</strong>——想想 Webflow、Wix 或 Squarespace 等工具，它们允许用户通过拖放界面创建网页，而无需编写代码。这些系统非常复杂，用户可以：</p>

<ul>
<li>将组件（按钮、图片、文本块）从库拖放到画布上</li>
<li>通过可视化控件自定义属性（颜色、字体、大小）</li>
<li>在构建过程中实时预览页面</li>
<li>将网站直接发布到 Web 上</li>
<li>与团队成员实时协作</li>
</ul>


<p>架构师无需深入研究拖放功能的实现细节，而是首先思考：</p>

<p>基础层：核心实体有哪些？</p>

<p>页面、组件、模板、用户、项目</p>

<p>结构层：这些实体之间如何关联？</p>

<p>用户创建项目
项目包含页面
页面由组件组成
组件可以保存为模板</p>

<p>系统层：它们如何通信？</p>

<ul>
<li>用于 CRUD 操作的 RESTful API</li>
<li>用于实时协作的 WebSocket 连接</li>
<li>用于组件更新的事件驱动架构</li>
</ul>


<p><strong>界面层</strong>：用户如何交互？</p>

<ul>
<li>用于项目管理的仪表盘</li>
<li>用于页面编辑的画布</li>
<li>用于选择的组件库</li>
<li>用于测试的预览模式</li>
</ul>


<p>正如软件工程师 Grady Booch 曾经说过的：“优秀软件的功能在于化繁为简。” 这种分层方法将极其复杂的内容转化为易于管理的模块。</p>

<h2>📝 互动练习：分层架构</h2>

<p><strong>现在就拿起纸笔！</strong>在继续阅读之前，请尝试以下方法：</p>

<ol>
<li><strong>画四个水平矩形</strong>，并将它们叠放在一起</li>
<li><strong>从上到下分别标注</strong>：界面、系统、结构、基础</li>
<li><strong>选择你日常使用的任何应用</strong>（Netflix、Amazon、WhatsApp）</li>
<li><strong>在每一层</strong>中填入你认为应该填入的内容</li>
</ol>


<p>Netflix 示例：_</p>

<ul>
<li>界面：搜索栏、视频播放器、推荐</li>
<li>系统：流媒体服务、推荐引擎、用户身份验证</li>
<li>结构：用户观看电影，电影有评分</li>
<li>基础：用户、电影、评分、订阅</li>
</ul>


<p><strong>为什么要画这个？</strong>你的大脑对你手绘内容的记忆力比你刚刚阅读的内容强 6 倍。这张简单的草图会让你立刻理解文章的其余部分。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:2000/1*k5g3kjh3ugcfUf5CWJjoFw.jpeg" alt="我在重新设计视频平台架构时画了这张草图。产品经理终于明白了为什么我们不能简单地“添加一个功能”——他能看到它会影响到哪个层级。这张图避免了3个月的技术债务！" /></p>

<h2>分解策略</h2>

<p>分解复杂问题就像解剖手表。你需要了解每个齿轮、弹簧和机械装置，然后才能构建或修复整个钟表。</p>

<p><strong>功能分解示例</strong>：可视化页面构建器</p>

<pre><code class="python">Page Builder System
├── Authentication &amp; Authorization
│   ├── User registration/login
│   ├── Role-based permissions
│   └── Session management
├── Project Management
│   ├── Project CRUD operations
│   ├── Version control
│   └── Collaboration features
├── Page Editor
│   ├── Canvas rendering engine
│   ├── Component management
│   ├── Drag-and-drop interface
│   └── Real-time preview
├── Component Library
│   ├── Built-in components
│   ├── Custom components
│   └── Template system
└── Export &amp; Publishing
    ├── Static site generation
    ├── Hosting integration
    └── SEO optimization
</code></pre>

<p>每个分支都可以独立开发、单独测试，并系统地集成。这种方法遵循 Unix 哲学：“专心做好一件事。”</p>

<h2>📝 互动练习：系统分解树</h2>

<p><strong>又该画草图了！</strong> 这个练习可以训练你的“架构师大脑”：</p>

<ol>
<li><strong>画一个树形结构</strong>，以“页面构建器”为根</li>
<li><strong>添加 5 个主要分支</strong>（思考：哪些是大块？）</li>
<li><strong>在每个分支下，添加 2-3 个叶子</strong>（较小的部分）</li>
<li><strong>使用简单的方框和线条</strong>——无需复杂的图表！</li>
</ol>


<p><em>你的绘图可能看起来像：</em></p>

<pre><code class="gherkin">Page Builder
   /

   |

   |

   \
 Auth  Pages  Components  Export
  |

  |

  |

  |
Login  Create   Library   HTML
Signup Edit

Custom

PDF
</code></pre>

<p><strong>神奇时刻</strong>：当你无法进一步分解一个方框时，这可能就是一个开发人员一周的工作。如果觉得方框太大，就进一步分解它！</p>

<h2>可扩展性：今天构建，应对未来的问题</h2>

<h2>成长型思维</h2>

<blockquote><p>“种一棵树的最佳时机是20年前，其次是现在。”——中国谚语</p></blockquote>

<p>可扩展性规划就像为房子选择地基。你可能从一栋小屋开始，但如果你计划扩建成一座豪宅，你就需要一个能够支撑未来发展的地基。</p>

<p>考虑三个可扩展性维度：</p>

<p><strong>垂直扩展（向上扩展）</strong>：就像在建筑物中增加更多楼层</p>

<ul>
<li>增加现有服务器上的 CPU、RAM 或存储空间</li>
<li>简单但存在物理限制</li>
<li>单点故障</li>
</ul>


<p><strong>水平扩展（向外扩展）</strong>：就像在综合体中建造更多建筑物</p>

<ul>
<li>添加更多服务器以分散负载</li>
<li>更复杂但几乎不受限制</li>
<li>更好的容错能力</li>
</ul>


<p><strong>功能扩展</strong>：就像为不同用途建造专用建筑物</p>

<ul>
<li>微服务架构</li>
<li>每个服务处理特定功能</li>
<li>独立扩展和部署</li>
</ul>


<h2>可扩展性的红绿灯系统</h2>

<p><strong>🟢 绿灯决策（第一天）</strong>：</p>

<ul>
<li>简单的单体架构</li>
<li>单一数据库</li>
<li>使用 Redis 进行基本缓存</li>
<li>静态资源的 CDN</li>
</ul>


<p><strong>🟡 黄灯决策（流量增长）</strong>：</p>

<ul>
<li>数据库只读副本</li>
<li>应用服务器集群</li>
<li>API 速率限制</li>
<li>监控和报警系统</li>
</ul>


<p><strong>🔴 红灯决策（高流量）</strong>：</p>

<ul>
<li>微服务架构</li>
<li>数据库分片</li>
<li>用于异步处理的消息队列</li>
<li>自动扩展基础设施</li>
</ul>


<p>对于我们的页面构建器示例，你可以从一个简单的 Python FastAPI 服务器和 PostgreSQL 数据库开始。随着流量的增长，你将引入：</p>

<ol>
<li><strong>缓存层</strong>：用于会话存储和频繁访问的模板的 Redis</li>
<li><strong>CDN</strong>：用于服务组件资源和生成页面的 CloudFront</li>
<li><strong>数据库优化</strong>：用于分析的读取副本，为不同域提供独立的数据库</li>
<li><strong>服务分离</strong>：用于渲染、文件管理和用户管理的专用微服务</li>
</ol>


<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*93OTsJ_L4-7WhICsL2EL4w.jpeg" alt="我绘制产品目标的草图" /></p>

<h2>📝 互动练习：扩展演进</h2>

<p><strong>这张图将成为你的扩展路线图！</strong></p>

<ol>
<li>在你的纸上<strong>画三列</strong>，分别标记为：“第 1 天”、“第 6 个月”、“第 2 年”</li>
<li><p><strong>在每一列中，画出你的架构图：</strong></p></li>
<li><p>第 1 天：画两个方框（前端、API），下方画一个圆柱体（数据库）</p></li>
<li>第 6 个月：添加更多方框（Redis 缓存、CDN 云、负载均衡器）</li>
<li>第 2 年：将 API 方框拆分成多个小方框（用户服务、项目服务等）</li>
</ol>


<p><strong>3. 在各列之间画箭头</strong>，展示演进过程</p>

<p><strong>4. 在每列上方画一些简笔画</strong>，展示用户数量：100 → 1 万 → 100 万</p>

<p><strong>从你的图中得出的关键洞察：</strong>注意复杂性是如何逐渐增长的，而不是一下子增长的。这就是真实系统演进的方式！</p>

<h2>职责三位一体：数据库、API 和前端</h2>

<h2>三层架构理念</h2>

<p>将 Web 应用程序想象成一家餐厅：</p>

<p><strong>前端（餐厅）</strong>：客户互动的地方</p>

<ul>
<li>用户界面和体验</li>
<li>输入验证和格式化</li>
<li>状态管理和路由</li>
</ul>


<p><strong>API（厨房）</strong>：魔法发生的地方</p>

<ul>
<li>业务逻辑处理</li>
<li>数据转换和验证</li>
<li>与外部服务集成</li>
</ul>


<p><strong>数据库（食品储藏室）</strong>：食材存储的地方</p>

<ul>
<li>数据持久化和检索</li>
<li>数据完整性和关系</li>
<li>性能优化</li>
</ul>


<blockquote><p>“好的架构不在于结构本身，而在于它所创造的空间。” — 安藤忠雄</p></blockquote>

<h2>📝 互动练习：餐厅架构</h2>

<p><strong>让我们通过一个绘画练习来具体化这一点：</strong></p>

<ol>
<li><p><strong>绘制一个简单的餐厅平面图</strong>，其中包含三个区域：</p></li>
<li><p>餐厅（顾客就座的地方）</p></li>
<li>厨房（准备食物的地方）</li>
<li>储藏室（存放食材的地方）</li>
</ol>


<p><strong>2. 现在绘制箭头表示数据流向：</strong></p>

<ul>
<li>顾客点餐 → 厨房</li>
<li>厨房索取食材 → 储藏室</li>
<li><p>厨房送出准备好的食物 → 餐厅</p></li>
<li><p><strong>为每个区域标注相应的 Web 对应项：</strong></p></li>
<li><p>餐厅 = 前端</p></li>
<li>厨房 = API</li>
<li>储藏室 = 数据库</li>
</ul>


<p><strong>为什么这样做有效：</strong>现在你的大脑已经对抽象的系统概念有了物理隐喻。每次设计系统时，想象一下这家餐厅的场景！</p>

<h2>职责边界</h2>

<p><strong>数据库职责</strong>：</p>

<pre><code class="python">-- ✅ Good: Database handles data integrity
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);
</code></pre>

<pre><code class="python">-- ✅ Good: Database enforces relationships
CREATE TABLE pages (
    id SERIAL PRIMARY KEY,
    project_id INTEGER REFERENCES projects(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL
);
</code></pre>

<p><strong>API 职责</strong>（Python 和 FastAPI）：</p>

<pre><code class="python"># ✅ Good: API handles business logic
from fastapi import FastAPI, HTTPException, Depends
from pydantic import BaseModel
</code></pre>

<pre><code class="python">app = FastAPI()@app.post("/api/pages")
async def create_page(
    page_data: PageCreateModel,
    current_user: User = Depends(get_current_user)
):
    # Validate user permissions
    if not can_user_edit_project(current_user, page_data.project_id):
        raise HTTPException(status_code=403, detail="Unauthorized")

        # Apply business rules
    page = await create_page_with_defaults(page_data)

    # Return appropriate response
    return {"page": page, "message": "Page created successfully"}
</code></pre>

<p><strong>前端职责</strong>（Angular）：</p>

<pre><code class="javascript">// ✅ Good: Frontend handles user interaction
@Component({
  selector: 'app-page-editor',
  templateUrl: './page-editor.component.html'
})
export class PageEditorComponent {
  components: Component[] = [];
  isLoading = false;

  constructor(private apiService: ApiService) {}

  // Handle user interactions
  onComponentDrop(component: Component, position: Position): void {
    this.isLoading = true;

    this.apiService.addComponent(component, position)
      .subscribe({
        next: (result) =&gt; this.updateComponents(result),
        error: (error) =&gt; this.handleError(error),
        complete: () =&gt; this.isLoading = false
      });
  }
}
</code></pre>

<h2>架构模式：伟大系统的基石</h2>

<h2>模型-视图-控制器 (MVC)：经典模式</h2>

<p>MVC 就像组织一场戏剧演出：</p>

<ul>
<li><strong>模型</strong>：剧本和故事（数据和业务逻辑）</li>
<li><strong>视图</strong>：舞台和演员（用户界面）</li>
<li><strong>控制器</strong>：导演（模型和（查看）</li>
</ul>


<pre><code class="coffeescript"># Model: Page data and operations
from sqlalchemy import Column, Integer, String, JSON
from sqlalchemy.ext.declarative import declarative_base
</code></pre>

<pre><code class="python">Base = declarative_base()class PageModel(Base):
    __tablename__ = "pages"

    id = Column(Integer, primary_key=True)
    title = Column(String(255), nullable=False)
    components = Column(JSON)
    project_id = Column(Integer, nullable=False)

    async def save(self, db_session):
        db_session.add(self)
        await db_session.commit()
        return self
</code></pre>

<pre><code class="coffeescript">// View: Page rendering (Angular Component)
@Component({
  selector: 'app-page-view',
  template: `
    &lt;div class="page"&gt;
      &lt;h1&gt;&lt;/h1&gt;
      &lt;app-component 
        *ngFor="let component of pageModel.components"
        [componentData]="component"&gt;
      &lt;/app-component&gt;
    &lt;/div&gt;
  `
})
export class PageViewComponent {
  @Input() pageModel: PageModel;
}
</code></pre>

<pre><code class="javascript">// Controller: Coordination logic (Angular Service)
@Injectable({
  providedIn: 'root'
})
export class PageController {
  constructor(private apiService: ApiService) {}

  async updateTitle(pageId: number, newTitle: string): Promise&lt;void&gt; {
    const updatedPage = await this.apiService.updatePage(pageId, { title: newTitle });
    // Emit event to refresh view
    this.pageUpdated.emit(updatedPage);
  }
}
</code></pre>

<h2>事件驱动架构：神经系统</h2>

<p>事件驱动架构就像人类的神经系统——当某个部分发生事件时，其他部分会自动做出反应。</p>

<pre><code class="python"># Event system for page builder
from typing import Dict, List, Callable
import asyncio
</code></pre>

<pre><code class="python">class EventBus:
    def __init__(self):
        self.listeners: Dict[str, List[Callable]] = {}

        def on(self, event: str, callback: Callable):
        if event not in self.listeners:
            self.listeners[event] = []
        self.listeners[event].append(callback)

        async def emit(self, event: str, data: dict):
        callbacks = self.listeners.get(event, [])
        await asyncio.gather(*[callback(data) for callback in callbacks])# Usage
event_bus = EventBus()# Auto-save feature
@event_bus.on('component:added')
async def auto_save_handler(data):
    await auto_save(data['page_id'])
    await show_save_indicator()# Analytics tracking
@event_bus.on('component:added')
async def analytics_handler(data):
    analytics.track('Component Added', {
        'component_type': data['component']['type'],
        'page_id': data['page_id']
    })
</code></pre>

<h2>微服务：专业团队</h2>

<p>微服务就像一个爵士乐团——每个音乐家（服务）都是各自乐器的专家，但他们共同努力，创造出美妙的音乐。</p>

<pre><code class="bash"># Docker Compose for Page Builder Microservices
version: '3.8'
services:
  user-service:
    image: pagebuilder/user-service:python
    environment:
      - DATABASE_URL=postgresql://users_db
      - REDIS_URL=redis://redis:6379
    ports:
      - "8001:8000"

      project-service:
    image: pagebuilder/project-service:python
    environment:
      - DATABASE_URL=postgresql://projects_db
    ports:
      - "8002:8000"

      rendering-service:
    image: pagebuilder/rendering-service:python
    environment:
      - REDIS_URL=redis://redis:6379
      - S3_BUCKET=pagebuilder-assets
    ports:
      - "8003:8000"

      frontend:
    image: pagebuilder/angular-frontend
    ports:
      - "4200:80"
    environment:
      - API_GATEWAY_URL=http://api-gateway:8080

      api-gateway:
    image: pagebuilder/api-gateway:python
    environment:
      - USER_SERVICE_URL=http://user-service:8000
      - PROJECT_SERVICE_URL=http://project-service:8000
      - RENDERING_SERVICE_URL=http://rendering-service:8000
    ports:
      - "8080:8000"
</code></pre>

<h2>何时使用每种模式</h2>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*Kx0t7cKSgdtO0Q1PpRiLXg.jpeg" alt="这是我在一次架构评审会上画的草图，当时团队就各种模式争论了两个小时。这张图在5分钟内就结束了这场争论——每个人都清楚地看到了他们的项目与一个模式的对应关系。现在，我把这张照片保存在手机里，每次架构讨论时都会拿出来用。" /></p>

<p><strong>在以下情况下使用 MVC</strong>：</p>

<ul>
<li>构建传统 Web 应用程序</li>
<li>团队熟悉该模式</li>
<li>需要清晰的关注点分离</li>
</ul>


<p><strong>在以下情况下使用事件驱动</strong>：</p>

<ul>
<li>实时功能很重要</li>
<li>需要多个系统响应变化</li>
<li>需要松散耦合</li>
</ul>


<p><strong>在以下情况下使用微服务</strong>：</p>

<ul>
<li>团队规模 > 10 名开发人员</li>
<li>不同部分的扩展能力不同</li>
<li>独立部署至关重要</li>
</ul>


<p>正如 Martin Fowler 所言：“傻瓜也能写出计算机能理解的代码。优秀的程序员写出人类能理解的代码。”</p>

<h2>📝 互动练习：架构模式比较</h2>

<p><strong>创建你的个人架构模式速查表：</strong></p>

<ol>
<li>在你的纸上<strong>画出三个部分</strong>：“MVC”、“事件驱动”、“微服务”</li>
<li><p><strong>对于 MVC：</strong>画出三个相连的方框（模型 ↔ 控制器 ↔ 视图）</p></li>
<li><p>在下面写上：“适合：传统应用，清晰的分离”</p></li>
</ol>


<p><strong>3.对于事件驱动：</strong> 画一个中心圆圈，标记为“事件总线”，并用箭头向外辐射到多个方框。</p>

<ol>
<li>在下面写：“适用于：实时功能，松耦合”</li>
</ol>


<p><strong>5. 对于微服务：</strong> 画 6-8 个独立的小方框，并用虚线连接它们。</p>

<ul>
<li>在下面写：“适用于：大型团队，独立扩展”</li>
</ul>


<p><strong>6. 添加决策树：</strong> 从问题到模式画箭头：</p>

<ul>
<li>“团队少于 5 人？” → MVC</li>
<li>“需要实时功能吗？” → 事件驱动</li>
<li>“多个团队？” → 微服务</li>
</ul>


<p><strong> 将此图放在手边！</strong> 这是你未来任何项目的架构决策流程图。</p>

<h2>绘制真正有用的系统图</h2>

<h2>视觉传达的艺术</h2>

<blockquote><p>“一图胜千言，但一张好的图表胜过千次会议。” — 未知</p></blockquote>

<p>系统图是软件架构的蓝图。它们应该讲述一个故事，而不是制造混乱。</p>

<h2>📝 互动练习：图表层次结构</h2>

<p><strong>练习三层系统图绘制方法：</strong></p>

<p><strong>第一层 - 上下文（30 秒绘制）：</strong></p>

<ol>
<li><strong>绘制三个形状</strong>：圆形（用户）、矩形（你的系统）、云（外部服务）</li>
<li><strong>用带标签的箭头连接</strong>：“HTTP 请求”、“API 调用”、“数据同步”</li>
<li><strong>这回答了</strong>“我们的系统连接到什么？”</li>
</ol>


<p><strong>第二层 - 容器（2 分钟绘制）：</strong></p>

<ol>
<li><strong>将系统矩形分成四个部分</strong>：前端、API 网关、服务、数据库</li>
<li><strong>用箭头</strong>显示它们之间的数据流**</li>
<li><strong>这回答了</strong>“主要部分是什么？”</li>
</ol>


<p><strong>第三级——组件（5 分钟绘制）：</strong></p>

<ol>
<li><strong>选择一个容器（例如前端）并将其分解</strong>为模块</li>
<li><strong>展示模块如何在该容器内交互</strong></li>
<li><strong>这将回答</strong>“这个组件内部是如何工作的？”</li>
</ol>


<p><strong>本练习的强大之处：</strong>只需选择要绘制的图纸，即可在任何细节层面解释任何系统！</p>

<h2>图表的层次结构</h2>

<p><strong>上下文图</strong>：30,000 英尺的视角</p>

<pre><code class="inform7">[Users] --&gt; [Page Builder System] --&gt; [CDN]
           |
           v
      [Database]
</code></pre>

<p><strong>容器图</strong>：构建模块</p>

<pre><code class="inform7">[Web Browser] --&gt; [Load Balancer] --&gt; [Web Application]
                                         |
                                         v
[File Storage] &lt;-- [API Gateway] &lt;-- [Cache Layer]
                        |
                        v
                   [Database Cluster]
</code></pre>

<p><strong>组件图</strong>：内部结构</p>

<pre><code class="mathematica">Web Application:
├── Authentication Module
├── Project Management Module
├── Page Editor Module
│   ├── Canvas Component
│   ├── Toolbar Component
│   └── Properties Panel
├── Component Library Module
└── Export Module
</code></pre>

<h2>有效的图表绘制原则</h2>

<ol>
<li><strong>从用户旅程开始</strong>：每个图表都应该回答“数据如何从用户操作流向结果？”</li>
<li><strong>使用一致的符号</strong>：矩形表示进程，圆柱体表示数据存储，圆形表示外部实体</li>
<li><strong>清晰地显示关系</strong>：箭头应指示数据流方向并进行标记</li>
<li><strong>分层图表</strong>：从高层开始，然后放大到特定区域</li>
<li><strong>包含不愉快的路径</strong>：显示错误处理和故障场景</li>
</ol>


<h2>整合：可视化页面构建器案例研究</h2>

<p>让我们为我们的可视化页面构建器设计一个完整的系统架构：</p>

<h2>高层架构</h2>

<pre><code class="coq">Frontend (Angular)
├── Editor Canvas Module
├── Component Library Module  
├── Project Dashboard Module
└── Shared Services
</code></pre>

<pre><code class="scss">API Gateway (Python/FastAPI)
├── Authentication Service
├── Project Service
├── Component Service
└── Rendering ServiceData Layer
├── PostgreSQL (structured data)
├── Redis (caching)
└── S3 (file storage)Infrastructure
├── CDN (CloudFront)
├── Load Balancer
└── Auto-scaling Groups
</code></pre>

<h2>组件添加的数据流</h2>

<ol>
<li><strong>用户操作</strong>：将组件从库拖到画布</li>
<li><strong>前端</strong>：验证位置，发送 API 请求</li>
<li><strong>API 网关</strong>：验证请求，路由到组件服务</li>
<li><strong>组件服务</strong>：验证业务规则，更新数据库</li>
<li><strong>事件总线</strong>：发出“component_added”事件</li>
<li><strong>渲染服务</strong>：生成更新后的页面预览</li>
<li><strong>WebSocket</strong>：通知其他协作者</li>
<li><strong>前端</strong>：使用新组件更新 UI</li>
</ol>


<h2>📝 互动练习：数据流映射</h2>

<p><strong>将这个抽象的流程转化为一个可视化的故事：</strong></p>

<ol>
<li><strong>在一个流程中画出 8 个方框</strong>（每个方框对应上面的每个步骤）</li>
<li><strong>用箭头连接它们</strong>以显示顺序</li>
<li><strong>在每个方框上方写出所需时间</strong>：“50 毫秒”、“200 毫秒”、“100 毫秒”等。</li>
<li><strong>在每个方框下方，注明可能出现的问题</strong>：“网络超时”、“身份验证失败”、“数据库宕机”</li>
<li><p><strong>现在画出第二个版本</strong>，展示步骤 4 失败时会发生什么：</p></li>
<li><p>用红色虚线画一条“悲伤的路径”箭头</p></li>
<li>显示返回给用户的错误消息</li>
<li>添加重试逻辑和回退选项</li>
</ol>


<p><strong>本练习将教会你：</strong>每个用户操作实际上都是一个复杂的系统编排。绘制箭头可以帮助你在生产环境中发生潜在故障之前发现它们！</p>

<p><strong>额外提示：</strong> 为箭头添加颜色代码——绿色代表正常路径，红色代表错误，蓝色代表重试。</p>

<h2>可扩展性考虑因素</h2>

<p><strong>流量模式</strong>：</p>

<ul>
<li>高读取操作（浏览页面）</li>
<li>突发写入操作（编辑会话）</li>
<li>大文件上传（图片、资源）</li>
</ul>


<p><strong>扩展策略</strong>：</p>

<ul>
<li>将渲染后的页面缓存在 CDN 中</li>
<li>使用只读副本进行页面浏览</li>
<li>将大文件处理排队</li>
<li>实现 WebSocket 连接池</li>
</ul>


<h2>要点：适用于任何 Web 应用程序的原则</h2>

<h2>系统设计的黄金法则</h2>

<ol>
<li><strong>从简单开始，规划复杂</strong>：从单体应用开始，但要针对微服务进行设计</li>
<li><strong>快速失败，快速学习</strong>：从第一天开始构建监控和报警功能</li>
<li><strong>数据为王</strong>：先设计数据模型，其他一切都水到渠成</li>
<li><strong>安全性不可或缺</strong>：在每一层都构建身份验证和授权机制</li>
<li><strong>性能是关键特性</strong>：用户更容易注意到应用程序运行缓慢，而不是功能缺失</li>
</ol>


<h2>架构清单</h2>

<p>在编写第一行代码之前编写代码时，请问自己：</p>

<ul>
<li>[ ] 核心实体及其关系是什么？</li>
<li>[ ] 该系统如何处理 10 倍于当前流量的情况？</li>
<li>[ ] 单点故障点在哪里？</li>
<li>[ ] 不同的团队将如何在该系统上协作？</li>
<li>[ ] 出现问题时会发生什么？</li>
<li>[ ] 我们将如何监控和调试问题？</li>
<li>[ ] 安全隐患是什么？</li>
</ul>


<h2>📝 互动练习：你的系统设计模板</h2>

<p><strong>创建你的个人系统设计模板，可用于任何项目：</strong></p>

<ol>
<li><strong>绘制一个包含以下部分的空白模板：</strong></li>
</ol>


<pre><code class="bash">┌────── 实体与关系 ────────┐ ┌───── 流量与扩展 ─────┐  │ │ │ │ │ │ │ 
└────────────────────────┘ └────────────────────┘ ┌─ 故障点 ──────
─────┐ ┌──── 团队边界 ────┐ │ │ │ │ │ │ 
└─────────────────────┘ └──────────────────────┘
</code></pre>

<ol>
<li><p><strong>填写我们的页面构建器示例：</strong></p></li>
<li><p>实体：用户、项目、页面、组件</p></li>
<li>流量：浏览时读取量大，编辑时写入量大</li>
<li>故障：数据库宕机、CDN 速度慢、WebSocket 断开连接</li>
<li>团队：前端团队、API 团队、基础设施团队</li>
</ol>


<p><strong>2. 复制此模板</strong> — 将其用于未来的每个项目</p>

<p><strong>为什么有效：</strong> 拥有一致的思维框架可以防止你忘记关键方面。你的绘图将成为你的系统设计清单！</p>

<h2>你的绘图之旅：从草图到系统</h2>

<p>如果你完成了本文的绘图练习，那么你现在拥有：</p>

<ol>
<li><strong>分层架构模板</strong>（用于分解任何复杂系统）</li>
<li><strong>分解树方法</strong>（用于组织开发工作）</li>
<li><strong>扩展演进路线图</strong>（用于规划发展阶段）</li>
<li><strong>餐厅隐喻图</strong>（用于解释三层架构）</li>
<li><strong>架构模式对比图</strong>（用于选择正确的方法）</li>
<li><strong>三层图表系统</strong>（用于在任何细节层面进行沟通）</li>
<li><strong>数据流映射技术</strong>（用于理解系统交互）</li>
<li><strong>可复用系统设计模板</strong>（用于一致的项目规划）</li>
</ol>


<p><strong>这些手绘图表比任何昂贵的工具都更有价值</strong>，因为：</p>

<ul>
<li>通过绘制它们，你的大脑建立了更深层次的联系</li>
<li>你可以随时随地重新创建它们</li>
<li>它们根据你对系统的理解进行个性化定制</li>
<li>它们弥合了抽象概念与实践之间的差距实施</li>
</ul>


<p><strong>保留你的图纸！</strong> 把它们贴在你的显示器上，用手机拍照，或者创建一个“系统设计速写本”，让它随着每个项目的进展而不断更新。</p>

<h2>总结</h2>

<blockquote><p>“架构师身处两个世界之间。你必须愿意打破基本的假设。”——安藤忠雄</p></blockquote>

<p>系统设计并非要创造完美的架构，而是要做出明智的权衡。每个决策都有其后果，每个模式都有其利弊，每个解决方案都会产生新的问题需要解决。</p>

<p>最好的架构师并非精通所有模式和技术，而是能够倾听需求、理解约束，并设计出能够与用户和组织和谐共存的系统。</p>

<p>记住：你不仅仅是在构建软件，你还在为团队未来的成功奠定基础。构建好它，清晰地记录它，并始终做好演进的准备。</p>

<p>俗话说，“几周的编码时间可以节省数小时的规划时间。” 投资于系统设计，未来的你（和团队）会感谢你。</p>

<p>千个应用程序的旅程始于一个精心设计的系统。今天就开始像架构师一样思考，见证你的应用程序从脆弱的原型转变为经得起时间考验的强大、可扩展的平台。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android ViewModel数据加载：基于Flow架构的最佳实践]]></title>
    <link href="https://alexhilton.github.io/blog/2025/09/22/viewmodel-loading/"/>
    <updated>2025-09-22T22:50:00+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/09/22/viewmodel-loading</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Android ViewModel Data Loading: Best Practices and Flow-Based Architecture」，原文链接<a href="https://funkymuse.dev/posts/properly-load-data/">https://funkymuse.dev/posts/properly-load-data/</a>，由FunkyMuse于2025年8月29日。</p></blockquote>

<p>Android 开发中的架构讨论经常引发激烈的争论——有时褒贬不一。撰写这些主题的文章并不容易，但这正是它的价值所在。</p>

<p>本文阐述了我对数据加载模式的独到见解，这些见解源于我的经验以及近期手术后的恢复（其中一次手术仍在进行中）。</p>

<p>不妨将此视为我在 2025 年对数据加载模式的理解和技能的概述。</p>

<p>我可能比其他人更晚加入这场讨论，但迟做总比不做好。</p>

<h2>挑战：Android ViewModel 中常见的数据加载反模式</h2>

<p>“大多数”Android 开发者使用 ViewModel 来管理 UI 状态，这些状态由视图（Fragment、Activity 或可组合组件）收集。为了显示有意义的内容，你需要从真实数据源加载数据，将其转换为视图状态，然后公开以供使用。</p>

<p>以前是 LiveData，现在是 Flow，它充当视图和 ViewModel 之间的粘合剂（大多数情况下）。有一些解决方案使用 <a href="https://github.com/cashapp/molecule">molecule</a>，但这超出了我们的讨论范围。</p>

<p><a href=""><img src="https://funkymuse.dev/assets/img/load_data/zhui.png" title="auto auto" ></a></p>

<!-- more -->


<p>正如这篇 <a href="https://x.com/github_skydoves/status/1829315087611707848">Twitter 讨论</a> 所示，大多数开发者在 <code>ViewModel</code> 的 init {} 块中加载数据。虽然这种方法看似合乎逻辑，但它带来了一些架构问题，Ian Lake 和其他人认为这是反模式——包括使用 <code>LaunchedEffect</code> 进行数据加载。</p>

<p><a href="https://funkymuse.dev/assets/img/load_data/jokes.png"><img src="https://funkymuse.dev/assets/img/load_data/jokes.png" alt="Irony" /></a></p>

<p>讽刺的是，即使是官方示例有时也会与这些最佳做法相矛盾：</p>

<p><a href="https://funkymuse.dev/assets/img/load_data/irony.png"><img src="https://funkymuse.dev/assets/img/load_data/irony.png" alt="Irony" /></a></p>

<h3>开发者为何选择 init {} 块（以及它为何存在问题）</h3>

<p>ViewModel 的 init {} 块的吸引力显而易见——它确保数据加载在配置更改后依然有效，从而避免了不必要的 API 调用或数据库读取。然而，这种方法也带来了四个关键问题：</p>

<h4>问题 1：导航返回栈复杂化</h4>

<p>使用 init {} 进行数据加载时，返回到包含现有 ViewModel 的屏幕不会触发重新初始化。这迫使开发者在 onStart 或 onResume 中添加变通逻辑来检查数据新鲜度，从而创建难以维护的意大利面条式代码。</p>

<h4>问题 2：调度程序竞争条件</h4>

<p>在 init {} 中加载数据通常使用 viewModelScope，它在 Dispatchers.Main.immediate 上运行。这种即时调度程序可能会导致竞争条件，即数据处理在 UI 组合之前就已完成，尤其是在 Jetpack Compose 应用中。</p>

<p><a href="https://funkymuse.dev/assets/img/load_data/darkness.png"><img src="https://funkymuse.dev/assets/img/load_data/darkness.png" alt="Darkness" /></a></p>

<h4>问题 #3：数据过期问题</h4>

<p>现代 CRUD 应用程序需要更新数据。用户可能会从其他屏幕返回，或者在相当长一段时间后从暂停状态恢复。<code>init {}</code> 方法没有提供内置的数据新鲜度验证机制。</p>

<h4>问题 #4：测试困难</h4>

<p>每次运行测试时，你都必须构建 ViewModel 才能成功运行该特定测试用例的 <code>init {}</code> 代码块。</p>

<h2>基于 Flow 的解决方案：将冷流转换为热流</h2>

<p>该解决方案利用 Kotlin Flows——具体来说，使用 StateFlow 和适当的共享策略将冷流转换为热流。可以将其视为 Katy Perry 的“Hot N Cold”方法，但所有边缘情况的行为都是可预测的。</p>

<h3>构建基础：用例和 ViewModel 结构</h3>

<p><strong>请注意，此代码仅用于演示目的，如何构建由你决定，除加载部分外，并非最佳实践</strong></p>

<pre><code class="kotlin">inline fun &lt;reified T : ViewModel&gt; provideFactory(
    crossinline creator: () -&gt; T
) = viewModelFactory {
    initializer {
        creator()
    }
}
</code></pre>

<p><em>注意：此工厂模式仅用于演示目的</em></p>

<p>我们的用例处理数据检索、格式化和业务逻辑转换：</p>

<pre><code class="kotlin">class GetUserDetailsUseCase private constructor(
    private val authRepository: AuthRepository = AuthRepository(),
    private val dispatcher: CoroutineDispatcher = Dispatchers.IO,
    private val billingCache: BillingCache = BillingCache.create(),
    private val dateFormatter: DateFormatter = DataFormatter()
) {
    suspend fun execute(): Result&lt;UserDetails&gt; =
        withContext(dispatcher) {
            val userDetails: Result&lt;UserDetailsResponseModel&gt; = authRepository.getUserDetails()

            userDetails.map { details -&gt;
                UserDetails(
                    creationDate = dateFormatter.format(
                        details.creationDate,
                        DateFormatter.Format.UTC_SHORT
                    ).getOrNull(),
                    avatarUrl = details.avatar,
                    isPremium = billingCache.isPremium(),
                    email = details.email
                )
            }
        }

    companion object {
        fun create() = GetUserDetailsUseCase()
    }
}
</code></pre>

<p>此用例封装了从存储库检索数据、日期格式化、高级状态验证以及准备用户信息以供显示。</p>

<pre><code class="kotlin">internal class UserAccountDetailsViewModel private constructor(
    private val getUserDetailsUseCase: GetUserDetailsUseCase = GetUserDetailsUseCase.create(),
) : ViewModel() {
    data class ViewState(
        val isLoading: Boolean = false,
        val isError: Boolean = false,
        val userInfo: UserInfo? = null
    ) {
        data class UserInfo(
            val displayEmail: String,
            val avatarUrl: String?,
            val showPremiumBadge: Boolean,
            val memberSince: String?
        )
    }

    val userDetails: Flow&lt;ViewState&gt; = flow {
        emit(
            getUserDetailsUseCase.execute()
                .fold(
                    onSuccess = {
                        ViewState(
                            isLoading = false,
                            isError = false,
                            userInfo = ViewState.UserInfo(
                                displayEmail = it.email,
                                avatarUrl = it.avatarUrl,
                                showPremiumBadge = it.isPremium,
                                memberSince = it.creationDate?.toString()
                            )
                        )
                    },

                    onFailure = {
                        ViewState(isLoading = false, isError = true)
                    }
                )
        )
    }.stateIn(
        viewModelScope,
        SharingStarted.WhileSubscribed(5_000),
        ViewState(isLoading = true, isError = false)
    )

    companion object {
        fun factory() = provideFactory { UserAccountDetailsViewModel() }
    }
}
</code></pre>

<p>这种方法有几个关键优势：</p>

<ul>
<li><strong>数据新鲜度</strong>：5 秒超时时间与 Android 的 ANR 阈值一致，确保在超时后收集器重新出现时数据能够刷新。</li>
<li><strong>配置变更处理</strong>：在超时窗口内，即使配置发生变化，数据也能持久保存。</li>
<li><strong>资源效率</strong>：避免不必要的网络调用，以实现快速导航模式。</li>
</ul>


<p><em>专业提示：对于需要实时数据新鲜度的应用程序，请将超时时间设置为 0</em></p>

<h3>添加用户交互：实现刷新功能</h3>

<p>实际应用程序需要用户主动发起的数据刷新功能。产品经理喜欢滑动刷新，但我们的基本流程无法适应这种模式。让我们来增强我们的架构：</p>

<p>我们使用在主流程收集器中触发的 <code>MutableSharedFlow</code> 来实现这一点：</p>

<pre><code class="kotlin">internal class UserAccountDetailsViewModel private constructor(
    private val getUserDetailsUseCase: GetUserDetailsUseCase = GetUserDetailsUseCase.create(),
) : ViewModel(), IntentAware&lt;UserAccountDetailsViewModel.ViewState.Intents&gt; {
    data class ViewState(
        val isLoading: Boolean = false,
        val isError: Boolean = false,
        val userInfo: UserInfo? = null
    ) {
        data class UserInfo(
            val displayEmail: String,
            val avatarUrl: String?,
            val showPremiumBadge: Boolean,
            val memberSince: String?
        )

        sealed class Intents {
            data object Refresh : Intents()
        }
    }

    private val refreshListener = MutableSharedFlow&lt;Unit&gt;()

    val userDetails: Flow&lt;ViewState&gt; = flow {
        emit(getUserDetailsState())
        refreshListener.collect {
            emit(ViewState(isLoading = true, isError = false))
            emit(getUserDetailsState())
        }
    }.stateIn(
        viewModelScope,
        SharingStarted.WhileSubscribed(5_000),
        ViewState(isLoading = true, isError = false)
    )

    private suspend fun getUserDetailsState(): ViewState = getUserDetailsUseCase.execute()
        .fold(
            onSuccess = {
                ViewState(
                    isLoading = false,
                    isError = false,
                    userInfo = ViewState.UserInfo(
                        displayEmail = it.email,
                        avatarUrl = it.avatarUrl,
                        showPremiumBadge = it.isPremium,
                        memberSince = it.creationDate?.toString()
                    )
                )
            },

            onFailure = {
                ViewState(isLoading = false, isError = true)
            }
        )

    override fun onIntent(intent: ViewState.Intents) {
        when (intent) {
            ViewState.Intents.Refresh -&gt; {
                viewModelScope.launch {
                    refreshListener.emit(Unit)
                }
            }
        }
    }

    companion object {
        fun factory() = provideFactory { UserAccountDetailsViewModel() }
    }
}
</code></pre>

<p>完美！我们成功重构了重复的数据加载逻辑，并实现了刷新功能。然而，这还不算完。</p>

<h3>优化状态管理：消除冗余状态输出</h3>

<p>为了避免不必要的 UI 更新，我们将添加 <code>distinctUntilChanged()</code> 来过滤重复的状态输出。</p>

<h3>处理复杂的状态更新</h3>

<p>对于意图修改 UI 状态而不需要重新加载数据的场景，我们需要在流程操作中访问当前状态。例如，切换电子邮件可见性——这需要修改状态而不是重新加载数据。</p>

<pre><code class="kotlin">data class ViewState(
    val isLoading: Boolean = false,
    val isError: Boolean = false,
    val isEmailVisible: Boolean = false,
    val userInfo: UserInfo? = null
) {
    data class UserInfo(
        val displayEmail: String,
        val avatarUrl: String?,
        val showPremiumBadge: Boolean,
        val memberSince: String?
    )

    sealed class Intents {

        data object Refresh : Intents()
        data class ToggleEmailVisibility(val isEmailVisible: Boolean) : Intents()
    }

    sealed class StateParameters {
        data class EmailVisibilityChanged(val isEmailVisible: Boolean) : StateParameters()
        data object Refresh : StateParameters()
    }
}

private val refreshListener = MutableSharedFlow&lt;ViewState.StateParameters&gt;()

val userDetails: Flow&lt;ViewState&gt; = flow {
    emit(getUserDetailsState())

    refreshListener.collect { refreshParams -&gt;
        when (refreshParams) {
            is ViewState.StateParameters.EmailVisibilityChanged -&gt; {
                //do some changes here
            }

            ViewState.StateParameters.Refresh -&gt; {
                emit(ViewState(isLoading = true, isError = false))
                emit(getUserDetailsState())
            }
        }
    }
}
    .distinctUntilChanged()
    .stateIn(
        viewModelScope,
        SharingStarted.WhileSubscribed(5_000),
        ViewState(isLoading = true, isError = false)
    )
</code></pre>

<p>这里的挑战在于如何在流程中访问当前状态。让我们通过内部跟踪状态来解决这个问题：</p>

<pre><code class="kotlin">internal class UserAccountDetailsViewModel private constructor(
    private val getUserDetailsUseCase: GetUserDetailsUseCase = GetUserDetailsUseCase.create(),
) : ViewModel(), IntentAware&lt;UserAccountDetailsViewModel.ViewState.Intents&gt; {
    data class ViewState(
        val isLoading: Boolean = false,
        val isError: Boolean = false,
        val isEmailVisible: Boolean = false,
        val userInfo: UserInfo? = null
    ) {
        data class UserInfo(
            val displayEmail: String,
            val avatarUrl: String?,
            val showPremiumBadge: Boolean,
            val memberSince: String?
        )

        sealed class Intents {
            data object Refresh : Intents()
            data class ToggleEmailVisibility(val isEmailVisible: Boolean) : Intents()
        }

        sealed class StateTriggers {
            data class EmailVisibilityChanged(val isEmailVisible: Boolean) : StateTriggers()
            data object Refresh : StateTriggers()
        }
    }

    private var currentState = ViewState(isLoading = true, isError = false)

    private val refreshListener = MutableSharedFlow&lt;ViewState.StateTriggers&gt;()

    val userDetails: Flow&lt;ViewState&gt; = flow {
        emit(getUserDetailsState())

        refreshListener.collect { refreshParams -&gt;
            when (refreshParams) {
                is ViewState.StateTriggers.EmailVisibilityChanged -&gt; {
                    emit(currentState.copy(isEmailVisible = refreshParams.isEmailVisible))
                }
                ViewState.StateTriggers.Refresh -&gt; {
                    emit(ViewState(isLoading = true, isError = false))
                    emit(getUserDetailsState())
                }
            }
        }
    }
        .distinctUntilChanged()
        .onEach {
            currentState = it
        }
        .stateIn(
            viewModelScope,
            SharingStarted.WhileSubscribed(5_000),
            currentState
        )

    private suspend fun getUserDetailsState(): ViewState = getUserDetailsUseCase.execute()
        .fold(
            onSuccess = {
                ViewState(
                    isLoading = false,
                    isError = false,
                    userInfo = ViewState.UserInfo(
                        displayEmail = it.email,
                        avatarUrl = it.avatarUrl,
                        showPremiumBadge = it.isPremium,
                        memberSince = it.creationDate?.toString()
                    )
                )
            },

            onFailure = {
                ViewState(isLoading = false, isError = true)
            }
        )

    override fun onIntent(intent: ViewState.Intents) {
        when (intent) {
            ViewState.Intents.Refresh -&gt; {
                viewModelScope.launch {
                    refreshListener.emit(ViewState.StateTriggers.Refresh)
                }
            }

            is ViewState.Intents.ToggleEmailVisibility -&gt; {
                viewModelScope.launch {
                    refreshListener.emit(ViewState.StateTriggers.EmailVisibilityChanged(intent.isEmailVisible))
                }
            }
        }
    }

    companion object {
        fun factory() = provideFactory { UserAccountDetailsViewModel() }
    }
}
</code></pre>

<h3>智能数据缓存：条件加载策略</h3>

<p>现在我们可以实现复杂的缓存行为了。由于 <code>currentState</code> 在 ViewModel 生命周期内持续存在，我们可以立即发出缓存数据，并仅在必要时有条件地加载新数据：</p>

<pre><code class="kotlin">internal class UserAccountDetailsViewModel private constructor(
    private val getUserDetailsUseCase: GetUserDetailsUseCase = GetUserDetailsUseCase.create(),
) : ViewModel(), IntentAware&lt;UserAccountDetailsViewModel.ViewState.Intents&gt; {
    data class ViewState(
        val isLoading: Boolean = false,
        val isError: Boolean = false,
        val isEmailVisible: Boolean = false,
        val userInfo: UserInfo? = null
    ) {
        val isDataLoaded get() = userInfo != null

        data class UserInfo(
            val displayEmail: String,
            val avatarUrl: String?,
            val showPremiumBadge: Boolean,
            val memberSince: String?
        )

        sealed class Intents {
            data object Refresh : Intents()
            data class ToggleEmailVisibility(val isEmailVisible: Boolean) : Intents()
        }

        sealed class StateTriggers {
            data class EmailVisibilityChanged(val isEmailVisible: Boolean) : StateTriggers()
            data object Refresh : StateTriggers()
        }
    }

    private var currentState = ViewState(isLoading = true, isError = false)

    private val refreshListener = MutableSharedFlow&lt;ViewState.StateTriggers&gt;()

    val userDetails: Flow&lt;ViewState&gt; = flow {
        emit(currentState)

        //i added error check just because this is for demonstration of this edge case

        if (currentState.isDataLoaded.not() || currentState.isError) {
            emit(getUserDetailsState())
        }

        refreshListener.collect { refreshParams -&gt;
            when (refreshParams) {
                is ViewState.StateTriggers.EmailVisibilityChanged -&gt; {
                    emit(currentState.copy(isEmailVisible = refreshParams.isEmailVisible))
                }

                ViewState.StateTriggers.Refresh -&gt; {
                    emit(ViewState(isLoading = true, isError = false))
                    emit(getUserDetailsState())
                }
            }
        }
    }
        .distinctUntilChanged()
        .onEach {
            currentState = it
        }

        .stateIn(
            viewModelScope,
            SharingStarted.WhileSubscribed(5_000),
            currentState
        )

    private suspend fun getUserDetailsState(): ViewState = getUserDetailsUseCase.execute()
        .fold(
            onSuccess = {
                ViewState(
                    isLoading = false,
                    isError = false,
                    userInfo = ViewState.UserInfo(
                        displayEmail = it.email,
                        avatarUrl = it.avatarUrl,
                        showPremiumBadge = it.isPremium,
                        memberSince = it.creationDate?.toString()
                    )
                )
            },

            onFailure = {
                ViewState(isLoading = false, isError = true)
            }
        )

    override fun onIntent(intent: ViewState.Intents) {
        when (intent) {
            ViewState.Intents.Refresh -&gt; {
                viewModelScope.launch {
                    refreshListener.emit(ViewState.StateTriggers.Refresh)
                }
            }

            is ViewState.Intents.ToggleEmailVisibility -&gt; {
                viewModelScope.launch {
                    refreshListener.emit(ViewState.StateTriggers.EmailVisibilityChanged(intent.isEmailVisible))
                }
            }
        }
    }

    companion object {
        fun factory() = provideFactory { UserAccountDetailsViewModel() }
    }
}
</code></pre>

<p>此模式提供智能缓存——即使在 5 秒超时后，你也可以根据具体需求选择是否重新获取数据：</p>

<ul>
<li><strong>昂贵的 API 调用</strong>：在 ViewModel 中缓存数据以减少网络开销</li>
<li><strong>静态后端数据</strong>：避免对很少更改的信息进行不必要的请求</li>
<li><strong>实时需求</strong>：强制刷新需要更新数据的应用程序</li>
</ul>


<h3>创建可复用的抽象</h3>

<p>重复编写此模式会变得非常繁琐。让我们从 ViewModel 扩展函数开始，创建可复用的抽象：</p>

<pre><code class="kotlin">fun &lt;T, R&gt; ViewModel.loadData(
    initialState: T,
    loadData: suspend FlowCollector&lt;T&gt;.(currentState: T) -&gt; Unit,
    refreshMechanism: SharedFlow&lt;R&gt;? = null,
    timeout: Long = 5_000,
    refreshData: (suspend FlowCollector&lt;T&gt;.(currentState: T, refreshParams: R) -&gt; Unit)? = null,
): StateFlow&lt;T&gt; {

    if (refreshMechanism != null) {
        requireNotNull(refreshData) {
            "You've provided a refresh mechanism but no way to refresh the data"
        }
    }

    if (refreshData != null) {
        requireNotNull(refreshMechanism) {
            "You've provided a refresh data but no mechanism to refresh the data"
        }
    }

    var latestValue = initialState

    return flow {
        emit(latestValue)

        loadData(latestValue)

        refreshMechanism?.collect { refreshParams -&gt;
            if (refreshData != null) {
                refreshData(latestValue, refreshParams)
            }
        }
    }
        .distinctUntilChanged()
        .onEach {
            latestValue = it
        }
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(timeout),
            initialValue = initialState
        )
}

fun &lt;T&gt; ViewModel.loadData(
    initialState: T,
    loadData: suspend FlowCollector&lt;T&gt;.(currentState: T) -&gt; Unit,
    timeout: Long = 5_000,
): StateFlow&lt;T&gt; {
    var latestValue = initialState

    return flow {
        emit(latestValue)
        loadData(latestValue)
    }
        .onEach {
            latestValue = it
        }
        .distinctUntilChanged()
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(timeout),
            initialValue = initialState
        )
}
</code></pre>

<p>有了我们抽象的扩展函数，ViewModel 变得更加简洁：</p>

<p><em>注意：此抽象涵盖了 90% 的常见用例，但不支持复杂的流程链式操作</em></p>

<pre><code class="kotlin">internal class UserAccountDetailsViewModel private constructor(
    private val getUserDetailsUseCase: GetUserDetailsUseCase = GetUserDetailsUseCase.create(),
) : ViewModel(), IntentAware&lt;UserAccountDetailsViewModel.ViewState.Intents&gt; {
    data class ViewState(
        val isLoading: Boolean = false,
        val isError: Boolean = false,
        val isEmailVisible: Boolean = false,
        val userInfo: UserInfo? = null
    ) {
        val isDataLoaded get() = userInfo != null

        data class UserInfo(
            val displayEmail: String,
            val avatarUrl: String?,
            val showPremiumBadge: Boolean,
            val memberSince: String?
        )

        sealed class Intents {
            data object Refresh : Intents()
            data class ToggleEmailVisibility(val isEmailVisible: Boolean) : Intents()
        }

        sealed class StateTriggers {
            data class EmailVisibilityChanged(val isEmailVisible: Boolean) : StateTriggers()
            data object Refresh : StateTriggers()
        }
    }

    private val refreshListener = MutableSharedFlow&lt;ViewState.StateTriggers&gt;()

    val userDetails = loadData(
        initialState = ViewState(isLoading = true, isError = false),
        loadData = { currentState -&gt;
            if (currentState.isDataLoaded.not() || currentState.isError.not()) {
                emit(getUserDetailsState())
            }
        },
        refreshMechanism = refreshListener,
        refreshData = { currentState, refreshParams -&gt;
            when (refreshParams) {
                is ViewState.StateTriggers.EmailVisibilityChanged -&gt; {
                    emit(currentState.copy(isEmailVisible = refreshParams.isEmailVisible))
                }

                ViewState.StateTriggers.Refresh -&gt; {
                    emit(ViewState(isLoading = true, isError = false))
                    emit(getUserDetailsState())
                }
            }
        }
    )

    private suspend fun getUserDetailsState(): ViewState = getUserDetailsUseCase.execute()
        .fold(
            onSuccess = {
                ViewState(
                    isLoading = false,
                    isError = false,
                    userInfo = ViewState.UserInfo(
                        displayEmail = it.email,
                        avatarUrl = it.avatarUrl,
                        showPremiumBadge = it.isPremium,
                        memberSince = it.creationDate?.toString()
                    )
                )
            },

            onFailure = {
                ViewState(isLoading = false, isError = true)
            }
        )

    override fun onIntent(intent: ViewState.Intents) {
        when (intent) {
            ViewState.Intents.Refresh -&gt; {
                viewModelScope.launch {
                    refreshListener.emit(ViewState.StateTriggers.Refresh)
                }
            }

            is ViewState.Intents.ToggleEmailVisibility -&gt; {
                viewModelScope.launch {
                    refreshListener.emit(ViewState.StateTriggers.EmailVisibilityChanged(intent.isEmailVisible))
                }
            }
        }
    }

    companion object {
        fun factory() = provideFactory { UserAccountDetailsViewModel() }
    }
}
</code></pre>

<p>我们可以通过创建更复杂的基类来消除重复的 <code>refreshListener</code> 声明：</p>

<pre><code class="kotlin">abstract class ViewModelLoader&lt;State : Any, Intent : Any, Trigger : Any&gt; : ViewModel() {
    private val _trigger by lazy { MutableSharedFlow&lt;Trigger&gt;() }

    fun &lt;T&gt; loadData(
        initialState: T,
        loadData: suspend FlowCollector&lt;T&gt;.(currentState: T) -&gt; Unit,
        triggerData: (suspend FlowCollector&lt;T&gt;.(currentState: T, triggerParams: Trigger) -&gt; Unit)? = null,
        timeout: Long = 5000L, //matching ANR timeout in Android
    ): StateFlow&lt;T&gt; {
        var latestValue = initialState

        return flow {
            emit(latestValue)

            loadData(latestValue)

            if (triggerData != null) {
                _trigger.collect { triggerParams -&gt;
                    triggerData(this, latestValue, triggerParams)
                }
            }
        }
            .distinctUntilChanged()
            .onEach {
                latestValue = it
            }

            .stateIn(
                scope = viewModelScope,
                started = SharingStarted.WhileSubscribed(timeout),
                initialValue = initialState
            )
    }

    abstract val state: StateFlow&lt;State&gt;

    val currentState get() = state.value

    open fun onIntent(intent: Intent) {}

    protected fun sendTrigger(trigger: Trigger) {
        viewModelScope.launch {
            _trigger.emit(trigger)
        }
    }
}
</code></pre>

<p>我们的最终实现将变得非常简洁且易于维护：</p>

<pre><code class="kotlin">internal class UserAccountDetailsViewModel private constructor(
    private val getUserDetailsUseCase: GetUserDetailsUseCase = GetUserDetailsUseCase.create(),
) : ViewModelLoader&lt;UserAccountDetailsViewModel.ViewState, UserAccountDetailsViewModel.ViewState.Intents, UserAccountDetailsViewModel.ViewState.StateTriggers&gt;() {
    data class ViewState(
        val isLoading: Boolean = false,
        val isError: Boolean = false,
        val isEmailVisible: Boolean = false,
        val userInfo: UserInfo? = null
    ) {
        val isDataLoaded get() = userInfo != null

        data class UserInfo(
            val displayEmail: String,
            val avatarUrl: String?,
            val showPremiumBadge: Boolean,
            val memberSince: String?
        )

        sealed class Intents {
            data object Refresh : Intents()
            data class ToggleEmailVisibility(val isEmailVisible: Boolean) : Intents()
        }

        sealed class StateTriggers {
            data class EmailVisibilityChanged(val isEmailVisible: Boolean) : StateTriggers()
            data object Refresh : StateTriggers()
        }
    }

    override val state = loadData(
        initialState = ViewState(isLoading = true, isError = false),
        loadData = { currentState -&gt;
            if (currentState.isDataLoaded.not() || currentState.isError.not()) {
                emit(getUserDetailsState())
            }
        },

        triggerData = { currentState, refreshParams -&gt;
            when (refreshParams) {
                is ViewState.StateTriggers.EmailVisibilityChanged -&gt; {
                    emit(currentState.copy(isEmailVisible = refreshParams.isEmailVisible))
                }

                ViewState.StateTriggers.Refresh -&gt; {
                    emit(ViewState(isLoading = true, isError = false))
                    emit(getUserDetailsState())
                }
            }
        }
    )

    private suspend fun getUserDetailsState(): ViewState = getUserDetailsUseCase.execute()

        .fold(
            onSuccess = {
                ViewState(
                    isLoading = false,
                    isError = false,
                    userInfo = ViewState.UserInfo(
                        displayEmail = it.email,
                        avatarUrl = it.avatarUrl,
                        showPremiumBadge = it.isPremium,
                        memberSince = it.creationDate?.toString()
                    )
                )
            },

            onFailure = {
                ViewState(isLoading = false, isError = true)
            }
        )

    override fun onIntent(intent: ViewState.Intents) {
        when (intent) {
            ViewState.Intents.Refresh -&gt; {
                sendTrigger(ViewState.StateTriggers.Refresh)
            }

            is ViewState.Intents.ToggleEmailVisibility -&gt; {
                sendTrigger(ViewState.StateTriggers.EmailVisibilityChanged(intent.isEmailVisible))
            }
        }
    }

    companion object {
        fun factory() = provideFactory { UserAccountDetailsViewModel() }
    }
}
</code></pre>

<h3>处理 UI 状态复杂性</h3>

<p>此抽象使用布尔标志（<code>isLoading</code>、<code>isError</code>），这些标志可能会创建模糊状态。为了更清晰地管理状态，可以考虑使用密封类：</p>

<pre><code class="kotlin">@Immutable
sealed interface UIState {
    @Immutable
    data object Success : UIState
    @Immutable
    data object Error : UIState
    @Immutable
    data object Idle : UIState
    @Immutable
    data object Loading : UIState
}
</code></pre>

<p>对于需要同时显示错误信息（例如 Snackbars）和现有数据的场景，你可以创建更复杂的状态持有者：</p>

<pre><code class="kotlin">@Immutable
data class UIStateHolder&lt;out T&gt;(
    val uiState: UIState = UIState.Idle,
    val payload: T? = null
)
</code></pre>

<p>这种方法可以实现灵活的 UI 状态管理，同时保持 UI 状态和数据负载之间的明确分离，但可能会增加认知负荷，并引入更多的映射行为和解包逻辑。</p>

<h3>超越 ViewModel</h3>

<p>此模式不仅限于 ViewModel。通过提供自定义协程作用域，你可以在任何组件（可组合组件、存储库或业务逻辑层）中使用此数据加载方法。</p>

<h2>流组合模式</h2>

<p>这种方法的优点还在于可以组合多个数据源。以下是处理单流和双流的示例：</p>

<pre><code class="kotlin">inline fun &lt;reified T, R&gt; ViewModel.loadFlow(
    initialState: R,
    flow: Flow&lt;T&gt;,
    crossinline transform: suspend CoroutineScope.(newValue: T, currentState: R) -&gt; R,
    timeout: Long = 0,
): StateFlow&lt;R&gt; {

    var latestValue = initialState

    return flow
        .map { newValue -&gt;
            coroutineScope {
                transform(newValue, latestValue)
            }
        }

        .onEach {
            latestValue = it
        }.stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(timeout),
            initialValue = latestValue
        )
}
</code></pre>

<p>组合双流的示例：</p>

<pre><code class="kotlin">inline fun &lt;reified T1, reified T2, R&gt; ViewModel.loadFlow(
    initialState: R,
    flow1: Flow&lt;T1&gt;,
    flow2: Flow&lt;T2&gt;,
    crossinline transform: suspend CoroutineScope.(newValue1: T1, newValue2: T2, currentState: R) -&gt; R,
    timeout: Long = 0,
): StateFlow&lt;R&gt; {

    var latestValue = initialState

    return combine(flow1, flow2) { value1, value2 -&gt;
        coroutineScope {
            transform(value1, value2, latestValue)
        }
    }
        .onEach {
            latestValue = it
        }.stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(timeout),
            initialValue = latestValue
        )
}
</code></pre>

<p>这些扩展允许你轻松组合多个数据源，同时保持相同的智能缓存和状态管理原则。</p>

<h3>测试基于流的 ViewModel</h3>

<p>在结束之前，让我们探索如何使用 fakes 和 Turbine 进行流测试，正确地测试我们的 <code>UserAccountDetailsViewModel</code> 实现。</p>

<h4>使用 Fakes 和 Turbine 设置测试依赖项</h4>

<pre><code class="kotlin">@OptIn(ExperimentalCoroutinesApi::class)
class UserAccountDetailsViewModelTest {
    private val testDispatcher = StandardTestDispatcher()

    private val fakeGetUserDetailsUseCase = FakeGetUserDetailsUseCase()

    private lateinit var viewModel: UserAccountDetailsViewModel

    @Before
    fun setUp() {
        Dispatchers.setMain(testDispatcher)
        viewModel = UserAccountDetailsViewModel(fakeGetUserDetailsUseCase)
    }

    @After
    fun tearDown() {
        Dispatchers.resetMain()
    }
}

// Fake implementation for realistic testing, this sounds funny to write haha
class FakeGetUserDetailsUseCase {
    private var shouldReturnError = false

    private var userDetailsToReturn: UserDetails? = null

    private var executionCount = 0

    fun setSuccessResponse(userDetails: UserDetails) {
        this.userDetailsToReturn = userDetails
        this.shouldReturnError = false
    }

    fun setErrorResponse() {
        this.shouldReturnError = true
        this.userDetailsToReturn = null
    }

    // Expose execution count when testing caching/performance behavior
    fun getExecutionCount() = executionCount

    fun reset() {
        executionCount = 0
    }

    suspend fun execute(): Result&lt;UserDetails&gt; {
        executionCount++

        delay(50) // Simulate network delay

        return if (shouldReturnError) {
            Result.failure(Exception("Network error"))
        } else {
            Result.success(userDetailsToReturn ?: createDefaultUserDetails())
        }
    }

    private fun createDefaultUserDetails() = UserDetails(
        email = "default@example.com",
        avatarUrl = null,
        isPremium = false,
        creationDate = "2023-01-01"
    )
}
</code></pre>

<h4>成功和失败场景的参数化测试</h4>

<pre><code class="kotlin">@ParameterizedTest
@ValueSource(booleans = [true, false])
fun `should handle both success and error scenarios`(shouldSucceed: Boolean) = runTest {
    // Given

    if (shouldSucceed) {
        fakeGetUserDetailsUseCase.setSuccessResponse(
            UserDetails(
                email = "success@example.com",
                avatarUrl = "https://avatar.url",
                isPremium = true,
                creationDate = "2023-01-01"
            )
        )
    } else {
        fakeGetUserDetailsUseCase.setErrorResponse()
    }

    // When

    viewModel.state.test {
        advanceUntilIdle()

        // Then Focus on behavior, not implementation details

        if (shouldSucceed) {
            awaitItem() // Loading state

            val successState = awaitItem()

            assertThat(successState.isLoading).isFalse()

            assertThat(successState.isError).isFalse()

            assertThat(successState.userInfo?.displayEmail).isEqualTo("success@example.com")

            assertThat(successState.userInfo?.showPremiumBadge).isTrue()
        } else {
            awaitItem() // Loading state

            val errorState = awaitItem()

            assertThat(errorState.isLoading).isFalse()

            assertThat(errorState.isError).isTrue()

            assertThat(errorState.userInfo).isNull()
        }
    }
}

@Test
fun `should refresh data when refresh intent is triggered`() = runTest {
    // Given Initial successful load
    fakeGetUserDetailsUseCase.setSuccessResponse(
        UserDetails(
            email = "initial@example.com",
            avatarUrl = null,
            isPremium = false,
            creationDate = "2022-01-01"
        )
    )

    viewModel.state.test {
        advanceUntilIdle()

        awaitItem() // Loading

        val initialState = awaitItem() // Success

        assertThat(initialState.userInfo?.displayEmail).isEqualTo("initial@example.com")

        // Change response and trigger refresh
        fakeGetUserDetailsUseCase.setSuccessResponse(
            UserDetails(
                email = "refreshed@example.com",
                avatarUrl = "https://new-avatar.url",
                isPremium = true,
                creationDate = "2023-01-01"
            )
        )

        viewModel.onIntent(ViewState.Intents.Refresh)

        advanceUntilIdle()

        // Then
        awaitItem() // Loading during refresh

        val refreshedState = awaitItem() // New Success

        assertThat(refreshedState.isLoading).isFalse()

        assertThat(refreshedState.userInfo?.displayEmail).isEqualTo("refreshed@example.com")

        assertThat(refreshedState.userInfo?.showPremiumBadge).isTrue()

        // Verify both initial load and refresh were called
        assertThat(fakeGetUserDetailsUseCase.getExecutionCount()).isEqualTo(2)
    }
}
</code></pre>

<h4>测试仅 UI 状态变化</h4>

<pre><code class="kotlin">@Test
fun `should toggle email visibility without triggering data reload`() = runTest {
    // Given Successful initial load
    fakeGetUserDetailsUseCase.setSuccessResponse(
        UserDetails(
            email = "test@example.com",
            avatarUrl = null,
            isPremium = false,
            creationDate = "2023-01-01"
        )
    )

    viewModel.state.test {
        advanceUntilIdle()

        awaitItem() // Loading

        val loadedState = awaitItem() // Success

        assertThat(loadedState.userInfo?.displayEmail).isEqualTo("test@example.com")

        assertThat(loadedState.isEmailVisible).isFalse()

        // When Toggle email visibility

        viewModel.onIntent(ViewState.Intents.ToggleEmailVisibility(isEmailVisible = true))

        advanceUntilIdle()

        // Then
        val toggledState = awaitItem()

        assertThat(toggledState.isEmailVisible).isTrue()

        assertThat(toggledState.userInfo?.displayEmail).isEqualTo("test@example.com")

        assertThat(fakeGetUserDetailsUseCase.getExecutionCount()).isEqualTo(1)
    }
}
</code></pre>

<h4>测试数据缓存行为</h4>

<pre><code class="kotlin">@Test
fun `should use cached data when returning to screen quickly`() = runTest {
    // Given

    fakeGetUserDetailsUseCase.setSuccessResponse(
        UserDetails(
            email = "cached@example.com",
            avatarUrl = null,
            isPremium = true,
            creationDate = "2023-01-01"
        )
    )

    // When First collection

    viewModel.state.test {
        advanceUntilIdle()

        awaitItem() // Loading

        val firstState = awaitItem() // Success

        assertThat(firstState.userInfo?.displayEmail).isEqualTo("cached@example.com")

        cancel() // Simulate leaving screen
    }

    // When Quick return (simulating navigation back within timeout)

    viewModel.state.test {
        advanceUntilIdle()

        // Then Should have cached data immediately (no Loadin)

        val cachedState = awaitItem()

        assertThat(cachedState.isLoading).isFalse()

        assertThat(cachedState.userInfo?.displayEmail).isEqualTo("cached@example.com")

        expectNoEvents()
    }

    assertThat(fakeGetUserDetailsUseCase.getExecutionCount()).isEqualTo(1)
}
</code></pre>

<h4>测试错误恢复</h4>

<pre><code class="kotlin">@Test
fun `should recover from Error on successful refresh`() = runTest {
    // Given Initial error

    fakeGetUserDetailsUseCase.setErrorResponse()

    viewModel.state.test {
        advanceUntilIdle()

        awaitItem() // Loading

        val errorState = awaitItem() // Error

        assertThat(errorState.isError).isTrue()

        // When Fix the response and refresh

        fakeGetUserDetailsUseCase.setSuccessResponse(
            UserDetails(
                email = "recovered@example.com",
                avatarUrl = null,
                isPremium = false,
                creationDate = "2023-01-01"
            )
        )

        viewModel.onIntent(ViewState.Intents.Refresh)

        advanceUntilIdle()

        // Then Should recover successfully

        awaitItem() // Loading during refresh

        val recoveredState = awaitItem() // Success

        assertThat(recoveredState.isError).isFalse()

        assertThat(recoveredState.userInfo?.displayEmail).isEqualTo("recovered@example.com")

        assertThat(fakeGetUserDetailsUseCase.getExecutionCount()).isEqualTo(2)
    }
}
</code></pre>

<h3>为什么要测试基于流的 ViewModel 的原则</h3>

<p>哦……这可能会引发一些争论，但这里有一篇很棒的文章，它提供了更好的描述，并且不会影响本文关于我为什么使用 Fakes 的目的。这里有一个简短的总结，可以补充文章顶部</p>

<ol>
<li><strong>使用 Fakes 而非 Mocks</strong>：Fake 提供逼真的行为，并且更易于维护，尤其是在如今 LLM 的帮助下……</li>
<li><strong>参数化测试</strong>：用一个测试用例同时测试成功和失败路径</li>
<li><strong>使用 Turbine 进行流程测试</strong>：简洁、富有表现力的流程测试，并进行适当的状态验证</li>
<li><strong>测试状态转换</strong>：验证完整的状态流程，而不仅仅是最终状态</li>
<li><strong>谨慎执行计数</strong>：仅在测试缓存、性能或重试行为时验证调用计数</li>
<li><strong>关注行为</strong>：测试用户体验，而不是实现细节（我想这一点显而易见）</li>
</ol>


<h3>结论</h3>

<p>本文对 Android ViewModel 中基于流程的数据加载的探索，解决了传统 <code>init {}</code> 块方法的根本挑战。虽然涵盖所有架构变体会很繁琐，但该模式成功处理了大约 90% 的常见用例。</p>

<p>抽象基类方法（<code>ViewModelLoader</code>）提供了最可预测和可维护的解决方案，它提供：</p>

<ul>
<li><strong>可预测的状态管理</strong>：清晰的状态触发器和意图处理</li>
<li><strong>内置测试支持</strong>：具有适当协程处理的可测试架构</li>
<li><strong>灵活性</strong>：易于扩展效果和混合 MVI 模式</li>
<li><strong>缓存和刷新</strong>：缓存和刷新机制（本文将尽可能详细地介绍）</li>
</ul>


<h3>关键要点</h3>

<ol>
<li><strong>基于流的加载</strong>消除了竞争条件，提高了测试的简易性，并解决了 <code>init {}</code> 块中固有的回栈问题</li>
<li><strong>具有适当共享策略的 StateFlow</strong> 提供了最佳的生命周期感知数据管理</li>
<li><strong>抽象层</strong>减少了样板代码，同时保持了灵活性</li>
<li><strong>全面的测试</strong>确保所有用例的可靠性</li>
</ol>


<p>请记住，这只是众多架构方法中的一种，它解决了我的问题，但可能无法解决你的问题。我们的目标是了解潜在问题并评估此解决方案是否符合你的特定需求。随着时间的推移，这个解决方案将经历许多变化，甚至可能被淘汰。最近，我更多地投入到使用 Ktor 进行后端开发，这本身就是一次很棒的体验。</p>

<p>该架构成功地为 iOS 和 Android 平台上的 <a href="https://wallhub.app/">WallHub</a> 提供了支持，证明了其在现实世界中的“可行性”以及跨平台适应性（如果可以这么说的话）。</p>

<p>继续潜水，直到下一篇文章……</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android应用的架构演进]]></title>
    <link href="https://alexhilton.github.io/blog/2025/09/13/architectual-evolution-of-an-android-app/"/>
    <updated>2025-09-13T20:34:01+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/09/13/architectual-evolution-of-an-android-app</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Architectural Evolution of and Android app」，原文链接<a href="https://herrbert74.github.io/posts/architectural-evolution-of-an-app/">https://herrbert74.github.io/posts/architectural-evolution-of-an-app/</a>，由Zsolt Bertalan发布于20258月19日。</p></blockquote>

<p><a href=""><img src="https://herrbert74.github.io/assets/img/posts/20250818_arch_evolution.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>本文将解释 Android 应用在发展过程中可能经历的各个阶段。不同的架构可能看起来截然不同（更不用说对细节的不同看法），但其背后的理念是相同的。我将通过整洁架构 (Clean Architecture) 和我的 <a href="https://github.com/herrbert74/FlickSlate">FlickSlate</a> 代码库（链接：<a href="https://github.com/herrbert74/FlickSlate%EF%BC%89%E6%9D%A5%E8%A7%A3%E9%87%8A%E8%BF%99%E4%B8%80%E7%82%B9%E3%80%82">https://github.com/herrbert74/FlickSlate%EF%BC%89%E6%9D%A5%E8%A7%A3%E9%87%8A%E8%BF%99%E4%B8%80%E7%82%B9%E3%80%82</a></p>

<p>我还想介绍一下大型应用中的常见模式：<strong>超级层</strong> 和 <strong>功能组</strong>。每当我开发的应用达到一定规模时，都会用到这些模式，但我从未制定过相关的基本规则。我希望把它们写下来，能让我和其他人更容易理解。</p>

<h3>超级层</h3>

<p>你可能还记得我之前的文章，我的应用有一个独立的<strong>领域层</strong>，<strong>数据层和展现层（从现在开始是UI层）</strong>都依赖于它。这些是基本的水平层。包含它们的垂直层也称为功能层。</p>

<p>我创造了 <strong>“超级层”</strong> 这个术语，是为了在基本水平层之上引入一个更广泛的层次结构。我们需要它们，因为水平层的范围可能有所不同，这意味着它们不仅可以涵盖功能层，还可以涵盖更广泛的范围。我将定义<strong>功能层</strong>、<strong>功能组</strong>、<strong>应用级（共享）</strong>和<strong>多应用级（基础）</strong> 超级层。</p>

<p>请参阅下图。</p>

<p><img src="file:///Users/alexhilton/Downloads/arch-envolve-1.png" alt="" /></p>

<p>在我上面解释的基本情况下，我们有<strong>功能层</strong>，其中整洁架构层仅在功能层内部可见。</p>

<p>接下来，<strong>功能组</strong>层是介于应用范围层和功能范围层之间的中间层。由于它是对超级层的最后且最不明显的补充，我将在稍后详细讨论。</p>

<p><strong>共享、通用或应用范围层</strong>通常包含与业务相关或整个应用独有的类。这是可以添加领域、数据和 UI 模块的最低层。</p>

<p><strong>基础层、基础设施层或基础结构层</strong>可以跨多个应用使用。它不包含领域、数据或 UI 层，但包含这些层之间通用的类。我通常有一个<strong>Kotlin 模块和一个 Android 基础模块</strong>。我创建了 <a href="https://bitbucket.org/babestudios/babestudiosbase/src/master/">BaBeStudios-Base</a> 库项目（<a href="https://bitbucket.org/babestudios/babestudiosbase/src/master/%EF%BC%89%EF%BC%8C%E4%BB%A5%E4%BE%BF%E5%9C%A8%E5%A4%9A%E4%B8%AA%E5%BA%94%E7%94%A8%E4%B8%AD%E5%A4%8D%E7%94%A8%E8%BF%99%E4%BA%9B%E6%A8%A1%E5%9D%97%EF%BC%8C%E4%BD%86%E6%88%91%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%AD%E4%B9%9F%E6%9C%89%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%B0%9A%E6%9C%AA%E5%8C%85%E5%90%AB%E5%9C%A8%E8%AF%A5%E5%BA%93%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E3%80%82">https://bitbucket.org/babestudios/babestudiosbase/src/master/%EF%BC%89%EF%BC%8C%E4%BB%A5%E4%BE%BF%E5%9C%A8%E5%A4%9A%E4%B8%AA%E5%BA%94%E7%94%A8%E4%B8%AD%E5%A4%8D%E7%94%A8%E8%BF%99%E4%BA%9B%E6%A8%A1%E5%9D%97%EF%BC%8C%E4%BD%86%E6%88%91%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%AD%E4%B9%9F%E6%9C%89%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%B0%9A%E6%9C%AA%E5%8C%85%E5%90%AB%E5%9C%A8%E8%AF%A5%E5%BA%93%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E3%80%82</a> BaBeStudios-Base 也可从 <a href="https://mvnrepository.com/artifact/io.bitbucket.babestudios">MavenCentral</a> 获取，但目前尚无相关文档。</p>

<p>随着应用程序规模的扩大和模块的引入，你需要引入上述各层。</p>

<p>接下来，让我们看看随着应用程序规模的扩大，我通常采取的模块化步骤。</p>

<h3>步骤 1：单模块</h3>

<p>当你确定应用程序规模不会超过<strong>最大规模</strong>，或者时间紧迫时，你可以选择单模块应用程序或单体应用。我不确定单模块应用程序的最大规模是多少。这可能因人而异。</p>

<p>此最大规模也不同于<strong>阈值规模，你应该从该阈值开始模块化应用程序</strong>，或者更通俗地说，你应该从该阈值切换到流程的下一步。我认为阈值大小远小于单模块应用程序的最大大小，这意味着你应该在达到该限制之前就开始模块化。</p>

<p>对于大多数应用程序，我甚至建议<strong>从模块化开始</strong>，而不是从单个模块开始，因为与接近限制（比如 10 或 20 kLOC）时才开始模块化相比，这样做的开销和干扰程度要小得多。</p>

<p>这是一个单模块应用程序的包树示例。</p>

<pre><code class="bash">├── data
│   ├── database
│   ├── local
│   ├── repository
│   └── remote
├── domain
│   ├── api
│   ├── model
│   └── usecase
├── presentation
│   ├── master
│   └── detail
└── shared
</code></pre>

<p>上面图中的叶子节点代表包，它们可以包含此处未显示的其他包。下面我将展示一个类似的模块结构，其中以冒号开头的名称代表模块，双冒号代表根模块。</p>

<h3>步骤 2：简单模块化</h3>

<p>对于<strong>小型应用程序</strong>，我使用简单模块化，而不是下一章的完全模块化。这里我们只介绍<strong>每个功能的模块</strong>。每个功能将包含一个领域模块，以及依赖于领域模块的数据和呈现模块（在我的例子中）。</p>

<p>我们还引入了一个<strong>共享模块</strong>，其中包含所有功能模块的通用代码。</p>

<p>应用程序的超层由一条<strong>水平线</strong>分隔。每个层都依赖于其下方的所有层。数据和呈现依赖于领域模块，但这并未在图中显示。</p>

<pre><code class="bash">::feature:Feature A

├── :feature/:featurea/:data
├── :feature/:featurea/:domain 
└── :feature/:featurea/:presentation  

::feature:Feature B

├── :feature/:featureb/:data
├── :feature/:featureb/:domain
└── :feature/:featureb/:presentation 

 ::feature:Feature C  

├── :feature/:featurec/:data
├── :feature/:featurec/:domain 
└── :feature/:featurec/:presentation


::shared:data

├── database
├── local
├── repository
└── remote

::shared:domain

├── api
├── model
└── usecase

::shared:presentation

├── compose
├── design
└── util


::base:kotlin  
</code></pre>

<h3>步骤 4：功能组</h3>

<p>当你的应用完全模块化后，共享层会逐渐成为单体应用，并成为构建过程中的<strong>瓶颈</strong>。</p>

<p>我经常在超过一定规模的应用（大约 50 到 80 kLOC）时遇到这种情况。你需要共享太多内容，因此你的<strong>共享领域模块和展示模块</strong>变得过大。你开始注意到，在所有垂直模块之间共享代码也是一种浪费，因为你只想在两个或最多三个或四个模块之间共享代码。你会发现越来越多的新代码被添加到这些模块中，而<strong>增量缓存</strong>的效率越来越低，因为你频繁地修改代码，导致它们失效。</p>

<p>你可能会说，可以通过适当地重构和构建应用程序，或者复制一些代码来避免这种情况，但这可能比你想象的要难。我发现这些建议并没有起到什么帮助作用。或者你可能手头有一个遗留应用，没有时间完美地重构所有内容。</p>

<p>我目前解决这个问题的方法是识别<strong>功能组</strong>，即一组具有大量公共依赖项的功能。这样，你就可以通过创建<strong>更具凝聚力</strong>的模块，水平拆分共享层中的部分代码。</p>

<p>我最近开发的所有大型应用中都有两个不同的功能组。</p>

<p>第一个功能组与<strong>核心业务</strong>功能相关：例如，一个模块围绕产品列表，另一个模块围绕产品详情，第三个模块围绕收藏产品。因此，我们可以将这个功能组命名为<strong>产品</strong>。另一个功能组围绕<strong>支付、广告或订阅</strong>，或者有时是这些功能的组合。这关系到应用的盈利方式。因此，我们可以将功能组命名为<strong>“支付”</strong>。</p>

<p>大型应用中可能会有五个或更多功能组。每个功能组将包含领域模块、数据模块和演示模块（如果需要）。</p>

<pre><code class="bash">feature/Feature A

feature/Feature B

feature/Feature C

feature/Feature D

feature/Feature E

feature/Feature F


:data

:domain

:presentation


:kotlin-base  
</code></pre>

<h3>何时使用哪一步？</h3>

<p>你肯定希望将单体应用用于永远不会投入生产或一次性使用的应用程序。这些应用程序可以是<strong>概念验证</strong> (PoC, Proof of Concept) 应用程序、用于第三方错误的<strong>最小可复现示例</strong> (MRE, Minimum Reproducible Example) 应用程序，或用于求职申请的<strong>测试挑战</strong>应用程序。</p>

<p>对于所有其他情况，我建议先从部分或完全模块化开始，然后根据需要升级到下一步，或者尽可能提前升级，以减少以后的麻烦。</p>

<p>你可以在我的 <a href="https://github.com/herrbert74/FlickSlate">FlickSlate</a> 代码库（链接：<a href="https://github.com/herrbert74/FlickSlate%EF%BC%89%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%8A%E8%BF%B0%EF%BC%88%E5%A4%A7%E9%83%A8%E5%88%86%EF%BC%89%E5%86%85%E5%AE%B9%E7%9A%84%E6%9C%89%E6%95%88%E7%A4%BA%E4%BE%8B%EF%BC%8C%E6%88%91%E6%9C%80%E8%BF%91%E5%B0%86%E5%85%B6%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BA%86%E5%AE%8C%E5%85%A8%E6%A8%A1%E5%9D%97%E5%8C%96%E9%98%B6%E6%AE%B5%E3%80%82%E8%99%BD%E7%84%B6%E4%B8%BA%E6%97%B6%E8%BF%87%E6%97%A9%EF%BC%8C%E4%BD%86%E6%9C%89%E5%8A%A9%E4%BA%8E%E6%BC%94%E7%A4%BA%E8%BF%99%E4%BA%9B%E5%8E%9F%E5%88%99%E3%80%82%E5%BD%93%E7%84%B6%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%81%BF%E5%85%8D%E4%BB%A5%E5%90%8E%E7%9A%84%E9%BA%BB%E7%83%A6%E3%80%82">https://github.com/herrbert74/FlickSlate%EF%BC%89%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%8A%E8%BF%B0%EF%BC%88%E5%A4%A7%E9%83%A8%E5%88%86%EF%BC%89%E5%86%85%E5%AE%B9%E7%9A%84%E6%9C%89%E6%95%88%E7%A4%BA%E4%BE%8B%EF%BC%8C%E6%88%91%E6%9C%80%E8%BF%91%E5%B0%86%E5%85%B6%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BA%86%E5%AE%8C%E5%85%A8%E6%A8%A1%E5%9D%97%E5%8C%96%E9%98%B6%E6%AE%B5%E3%80%82%E8%99%BD%E7%84%B6%E4%B8%BA%E6%97%B6%E8%BF%87%E6%97%A9%EF%BC%8C%E4%BD%86%E6%9C%89%E5%8A%A9%E4%BA%8E%E6%BC%94%E7%A4%BA%E8%BF%99%E4%BA%9B%E5%8E%9F%E5%88%99%E3%80%82%E5%BD%93%E7%84%B6%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%81%BF%E5%85%8D%E4%BB%A5%E5%90%8E%E7%9A%84%E9%BA%BB%E7%83%A6%E3%80%82</a></p>

<p>FlickSlate 尚未升级到功能组。这毫无意义，因为共享层还无法拆分为功能组。该应用没有盈利功能，所以只能对节目进行分组，不过目前共享层已经完美地实现了这一点。</p>

<p>这篇文章主要源于我对互联网上关于何时以及如何模块化的建议一概而论的不满：要么建议不加区分地进行模块化，要么有人对任何进行模块化的人大喊“过度工程”。我希望这篇文章能帮助你在何时以及如何进行模块化方面做出更明智的决定。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Kotlin ViewModel中正确处理相同的UI组件交互]]></title>
    <link href="https://alexhilton.github.io/blog/2025/07/01/handling-ui-action/"/>
    <updated>2025-07-01T22:34:20+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/07/01/handling-ui-action</id>
    <content type="html"><![CDATA[<p>本文译自「Handling UI Actions the Right Way in Kotlin ViewModels」，原文链接<a href="https://proandroiddev.com/handling-ui-actions-the-right-way-in-kotlin-viewmodels-119a06bb43ef">https://proandroiddev.com/handling-ui-actions-the-right-way-in-kotlin-viewmodels-119a06bb43ef</a>，由Vaibhav Jaiswal发布于2025年4月16日。</p>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MLROq8NAKOSnutBMj3WivQ.png" title="auto auto" ></a></p>

<!-- more -->


<h2>缘起</h2>

<p>作为Android开发者，我们经常会遇到需要在多个ViewModel中实现相同或者非常类似UI功能的情况。</p>

<p>例如，我们有多个页面，它们具有类似的功能，例如显示帖子、撰写评论或处理用户交互。</p>

<p>在每个ViewModel中分别处理这些UI交互很快就会变得混乱，导致大量的代码重复。随着应用规模的扩大和页面数量的增加，这个问题会变得更加棘手，导致代码库难以维护，并带来可扩展性问题。</p>

<p>对于这种代码重复问题，我们Android开发者常用的几种常见解决方案包括：</p>

<ul>
<li>额外的辅助类方法</li>
<li>“继承”或“使用委托的组合”方法</li>
</ul>


<p>在以下章节中，我们将详细探讨这些解决方案，了解每种方法如何解决代码重复问题，并重点介绍每种方法的局限性。然后，我们将深入探讨我的解决方案，它基于这些想法，并解决了它们的局限性，从而实现了更高效的UI交互管理。</p>

<blockquote><p>这个解决方案我已经在<a href="https://medial.app/"> Medial 的应用</a>（链接 <a href="https://medial.app/%EF%BC%89%E4%BB%A3%E7%A0%81%E5%BA%93%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%BF%87%E4%BA%86%E2%80%94%E2%80%94%E5%B0%86">https://medial.app/%EF%BC%89%E4%BB%A3%E7%A0%81%E5%BA%93%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%BF%87%E4%BA%86%E2%80%94%E2%80%94%E5%B0%86</a> UI交互处理代码变成了近乎即插即用的体验。</p></blockquote>

<p>我的解决方案根本不建议使用 BaseViewModel，也不基于 BaseViewModel。BaseViewModel 只是一个例子，用来说明我们可以使用从任何其他类/接口继承的功能，这些类/接口可以是 BaseViewModel、ViewModel、Decompose 的 ComponentContext 或其他任何东西。</p>

<h2>⚡️ TL;DR: 处理ViewModel中的共享UI交互</h2>

<p>当在多个页面上显示相同的UI组件时，在每个ViewModel中处理它们的交互会导致重复和逻辑混乱。我们探索了三种方法来解决这个问题：</p>

<ol>
<li>辅助类方法</li>
<li>➖ 简单，但无法覆写任何行为</li>
<li>➖ 并非ViewModel的直接功能</li>
<li>通过 Kotlin 委托进行组合</li>
<li>✅ 更好的设计，支持覆写行为。</li>
<li>➖ 无法访问viewModelScope或其他ViewModel功能。</li>
<li>➖ 无法从任何其他继承类访问任何内容。</li>
<li>💡 我的解决方案 — 使用带有默认函数的接口</li>
<li>✅ 简洁、可复用，支持覆写（Override）行为。</li>
<li>✅ 完全访问ViewModel功能或任何其他继承类的功能。</li>
<li>✅ 只需从接口实现即可轻松插入任何 ViewModel</li>
</ol>


<p>本博客中的所有解决方案均在<a href="https://github.com/Vaibhav2002/Ui-Intreraction-Handler-Sample">此示例项目</a>（链接 <a href="https://github.com/Vaibhav2002/Ui-Intreraction-Handler-Sample%EF%BC%89%E4%B8%AD%E5%AE%9E%E7%8E%B0%EF%BC%9A">https://github.com/Vaibhav2002/Ui-Intreraction-Handler-Sample%EF%BC%89%E4%B8%AD%E5%AE%9E%E7%8E%B0%EF%BC%9A</a></p>

<h2>🏗️ 设置</h2>

<p>假设我们有一个后置UI 元素，它有一些UI 交互，并像 MVI 建议的那样，在一个密封的界面中呈现。</p>

<pre><code class="Kotlin">sealed interface PostAction {
    data class Clicked(val id: String) : PostAction
    data class LikeClicked(val id: String) : PostAction
    data class ShareClicked(val id: String) : PostAction
}
</code></pre>

<p>我们还有一个 BaseViewModel 类，用于保存每个ViewModel所需的通用功能</p>

<pre><code class="Kotlin">abstract class BaseViewModel : ViewModel() {

    var showShackBar by mutableStateOf("")
    var showBottomSheet by mutableStateOf("")

    fun navigate() {
      // 实现
    }

    fun showSnackbar(message: String) {
      showSnackBar = message
    }
}
</code></pre>

<h3>额外的辅助类方法</h3>

<p>在这种方法中，我们创建一个单独的辅助类来封装UI交互的处理。我们将这个类作为ViewModel的一个属性。</p>

<p>首先，我们定义一个辅助类 PostActionHandler 来处理交互。</p>

<pre><code class="Kotlin">class PostActionHandler(private val viewModel: BaseViewModel) {

    fun handleAction(action: PostAction) = when (action) {
        is PostAction.Clicked -&gt; viewModel.navigate()
        is PostAction.LikeClicked -&gt; viewModel.showSnackBar("Liked")
        is PostAction.ShareClicked -&gt; { /* 实现 */ }
    }
}
</code></pre>

<p>现在，在 PostScreenViewModel 中我们创建一个 PostActionHandler 实例</p>

<pre><code class="Kotlin">class PostScreenViewModel : BaseViewModel() {
    val actionHandler = PostActionHandler(this)
}

@Composable
fun PostScreen(viewModel: PostScreenViewModel) {
    PostItem(onAction = viewModel.actionHandler::handleAction)
}

@Composable
fun PostItem(onAction: (PostAction) -&gt; Unit) {

}
</code></pre>

<p>虽然这种方法确实解决了跨多个ViewModel重复代码的问题，但它也存在一些主要缺点，这些缺点包括：</p>

<ul>
<li>🚫 自定义功能有限：由于 PostActionHandler 是一个封装类，我们无法覆写任何行为。</li>
<li>🚫 通过属性访问：我们不是将功能添加到ViewModel本身，而是将其作为ViewModel的一个属性添加。</li>
</ul>


<p><strong>无法覆写（Override）行为是这种方法不建议用于UI交互处理的主要原因。</strong></p>

<h2>🧬 使用 Kotlin 委托进行组合（优雅但受限的解决方案）</h2>

<p>这是互联网上解决这个问题的标准方法，也是最受推荐的方法。该解决方案基于继承，但不是继承自某个类，这样就无法再扩展任何类。我们利用 Kotlin 委托将实现委托给另一个类，这样就无需扩展某个类，也无需再终止继承。</p>

<p>以下是我们实现该解决方案的方法</p>

<pre><code class="Kotlin">interface PostActionHandler {
    suspend fun handleAction(action: PostAction)
}

class PostActionHandlerImpl : PostActionHandler {

    override fun handleAction(action: PostAction) = when (action) {
        is PostAction.Clicked -&gt; handlePostClick(action.id)
        is PostAction.LikeClicked -&gt; handleLikeClick(action.id)
        is PostAction.ShareClicked -&gt; handleShareClick(action.id)
    }

    private fun handlePostClick(id: String) { }

    private fun handleLikeClick(id: String) { }

    private fun handleShareClick(id: String) { }

}
</code></pre>

<p>这就是我们的使用方法</p>

<pre><code class="Kotlin">class PostViewModel : BaseViewModel(), PostActionHandler by PostActionHandlerImpl() {

}

@Composable
fun PostScreen(viewModel: PostViewModel) {
    PostItem(onAction = viewModel::handleAction)
}

@Composable
fun PostItem(onAction: (PostAction) -&gt; Unit) {

}
</code></pre>

<p>这种方法解决了额外辅助类方法中存在的所有问题。</p>

<ul>
<li>✅ 覆写行为：通过使用接口和委托，我们可以轻松地覆写任何行为。</li>
<li>✅ 更简洁的设计：功能直接成为ViewModel的一部分，允许我们像调用原生ViewModel方法一样调用这些函数。</li>
</ul>


<p>然而，这种方法有一个主要缺点，使其在处理UI交互和UI逻辑方面不够完善。</p>

<h3>访问从其他类继承的功能</h3>

<p>此模式的一个主要挑战是我们无法访问从其他类继承的功能，因为我们无法传递引用。</p>

<p>让我们看看这个限制带来了哪些挑战：</p>

<ul>
<li>无法访问ViewModel功能：我们无法从实现类访问任何ViewModel功能。这是因为我们无法在实现类中传递当前类的引用。</li>
<li>无法使用 viewModelScope：此限制带来的一个主要警告是，我们无法使用 viewModelScope，因此无法直接启动协程。我们必须在 viewModel 中创建包装函数，这会破坏可重用性，因为现在可组合函数会调用我们的ViewModel函数。</li>
</ul>


<p>当我们尝试将其作为构造函数参数传递时，Android Studio 会抛出一个错误：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xcJAyapM8023-hqu06vwUw.png" alt="Kotlin Compiler showing error when passing “this”" /></p>

<h2>🧩 我的解决方案：使用接口默认函数进行组合</h2>

<p>在我自己实现使用委托的 Composition 方案时，我遇到了一个难题：如何传递当前ViewModel的引用来访问viewModelScope 和我的 BaseViewModel 功能。后来我想起了 Kotlin 接口中的默认函数，于是尝试了这个方案，完美地解决了这个问题。</p>

<p>通过这个方案，我可以：</p>

<ul>
<li>💡 支持功能重写</li>
<li>🔗 完全访问我的BaseViewModel和ViewModel 的功能，例如viewModelScope 等，或任何其他类的功能。</li>
<li>❌ 无需单独的实现类</li>
</ul>


<blockquote><p>在我们<a href="https://medial.app/"> Medial 的应用</a>（链接 <a href="https://medial.app/%EF%BC%89%E7%94%9F%E4%BA%A7%E4%BB%A3%E7%A0%81%E4%B8%AD%EF%BC%8C%E6%88%91%E9%9B%86%E6%88%90%E4%BA%86%E8%BF%99%E4%B8%AA%E6%96%B9%E6%A1%88%EF%BC%8C%E4%BB%A5%E7%AE%80%E5%8C%96ViewModel%E5%A4%84%E7%90%86UI%E4%BA%A4%E4%BA%92%E7%9A%84%E6%96%B9%E5%BC%8F%E3%80%82%E7%BB%93%E6%9E%9C%E5%A6%82%E4%BD%95%EF%BC%9F%E6%AF%8F%E4%B8%AA%E6%96%B0%E9%A1%B5%E9%9D%A2%E5%8F%AA%E9%9C%80%E5%AE%9E%E7%8E%B0%E8%BF%99%E4%B8%AA%E6%8E%A5%E5%8F%A3%EF%BC%8C%E7%84%B6%E5%90%8E%EF%BC%8C%E5%AE%83%E5%B0%B1%E5%B9%B2%E5%87%80%E5%88%A9%E8%90%BD%E5%9C%B0%E8%8E%B7%E5%BE%97%E4%BA%86%E5%8A%9F%E8%83%BD%E3%80%82">https://medial.app/%EF%BC%89%E7%94%9F%E4%BA%A7%E4%BB%A3%E7%A0%81%E4%B8%AD%EF%BC%8C%E6%88%91%E9%9B%86%E6%88%90%E4%BA%86%E8%BF%99%E4%B8%AA%E6%96%B9%E6%A1%88%EF%BC%8C%E4%BB%A5%E7%AE%80%E5%8C%96ViewModel%E5%A4%84%E7%90%86UI%E4%BA%A4%E4%BA%92%E7%9A%84%E6%96%B9%E5%BC%8F%E3%80%82%E7%BB%93%E6%9E%9C%E5%A6%82%E4%BD%95%EF%BC%9F%E6%AF%8F%E4%B8%AA%E6%96%B0%E9%A1%B5%E9%9D%A2%E5%8F%AA%E9%9C%80%E5%AE%9E%E7%8E%B0%E8%BF%99%E4%B8%AA%E6%8E%A5%E5%8F%A3%EF%BC%8C%E7%84%B6%E5%90%8E%EF%BC%8C%E5%AE%83%E5%B0%B1%E5%B9%B2%E5%87%80%E5%88%A9%E8%90%BD%E5%9C%B0%E8%8E%B7%E5%BE%97%E4%BA%86%E5%8A%9F%E8%83%BD%E3%80%82</a></p></blockquote>

<p>让我们来探索一下这个方案是如何解决我们的问题的。</p>

<h3>设计 ActionHandler 接口</h3>

<pre><code class="Kotlin">interface PostActionHandler {

    val viewModel: BaseViewModel

    fun handleAction(action: PostAction) = viewModel.viewModelScope.launch {
        when (action) {
            is PostAction.Clicked -&gt; handlePostClick(action.id)
            is PostAction.LikeClicked -&gt; handleLikeClick(action.id)
            is PostAction.ShareClicked -&gt; handleShareClick(action.id)
        }
    }

    suspend fun handlePostClick(id: String) {
        viewModel.navigate()
    }

    suspend fun handleLikeClick(id: String) {
        viewModel.showToast("Liked")
    }

    suspend fun handleShareClick(id: String) {
        // 实现
    }

}
</code></pre>

<h3>让我们的ViewModel实现这个接口</h3>

<pre><code class="Kotlin">class PostViewModel : BaseViewModel(), PostActionHandler {

    // 传入当前的baseViewModel
    override valViewModel= this

    override fun handleShareClick(id: String) {
        // 添加 override实现
    }

}
</code></pre>

<h3>这是它在 Composable 中的使用方式</h3>

<pre><code class="Kotlin">@Composable
private fun PostScreen(viewModel: PostViewModel) {
    PostItem(onAction = viewModel::handleAction)
}

@Composable
private fun PostItem(
    onAction: (PostAction) -&gt; Unit
) {

}
</code></pre>

<p>所以，正如你所见，我们只需要定义 viewModel 变量，就大功告成了，现在我们可以使用ViewModel和 BaseViewModel 提供的所有功能了。</p>

<p>请注意，我们是如何解决使用委托进行组合的主要缺点的：</p>

<ul>
<li>通过将 viewModel 引用保留为接口属性，我们可以轻松地在ViewModel中定义它。这使我们能够直接访问 BaseViewModel 或任何其他ViewModel提供的所有功能。</li>
<li>我们简化了 viewModelScope 的使用。现在，启动协程、收集流程以及执行其他任务都变得非常简单，无需任何复杂的变通方法或 hack。这就是此解决方案带来的优雅和简洁之处。</li>
</ul>


<p>这种方法只有一个小缺点，那就是</p>

<ul>
<li>我们必须在ViewModel中定义所有接口属性，这在大多数情况下是可以接受的，因为我们主要会引用 Repository 或 Domain Layer 类，以及一些可变状态（如果有的话）。</li>
</ul>


<p>这个问题比我们在这个解决方案中克服的缺点要小得多，这使得它成为处理任何共享UI交互或任何共享UI业务逻辑的最佳解决方案。</p>

<blockquote><p>嗯，这一部分比前面几部分简单得多。这里没有复杂的问题需要深入研究——只是一个简单的解决方案，它确实做到了它应该做的事情，并解决了我们所有的问题。</p></blockquote>

<h2>🥷🏻 让我们在实际用例中看看这个解决方案的实际应用。</h2>

<p>假设我们有一个主页面，它以列表形式显示各种UI元素，例如包含帖子和新闻等项目的动态。每个元素都包含一组用户交互，例如点赞帖子、分享新闻文章或导航到详情视图。我们的解决方案可以帮助我们高效地处理跨不同ViewModel的这些交互，确保以可扩展的方式处理通用功能。</p>

<h3>为每个UI组件设计UI交互</h3>

<p>然后，我们使用 Kotlin 的 Sealed 接口，像在典型的 MVI 架构中一样设计UI交互：</p>

<pre><code class="Kotlin">sealed interface PostAction {

    data class Clicked(val post: Post) : PostAction
    data class LikeClicked(val post: Post) : PostAction
    data class ShareClicked(val post: Post) : PostAction

}
</code></pre>

<pre><code class="Kotlin">sealed interface NewsAction {

    data class Clicked(val news: News) : NewsAction
    data class LikeClicked(val news: News) : NewsAction
    data class BookmarkClicked(val news: News) : NewsAction

}
</code></pre>

<h3>创建我们的动作处理程序接口</h3>

<pre><code class="Kotlin">interface PostActionHandler {

    val viewModel: BaseViewModel
    val postRepo: PostRepository

    fun handleAction(action: PostAction) = viewModel.viewModelScope.launch {
      when (action) {
          is PostAction.Clicked -&gt; handlePostClick(action.id)
          is PostAction.LikeClicked -&gt; handleLikeClick(action.id)
        }
    }

    suspend fun handlePostClick(id: String) {
      viewModel.navigate(......)
    }

    suspend fun handleLikeClick(id: String) {
      postRepo.like(id)
      viewModel.showSnackbar("Post Liked")
    }

}
</code></pre>

<pre><code class="Kotlin">interface NewsActionHandler {

    val viewModel: BaseViewModel
    val newsRepo: NewsRepository

    fun handleAction(action: NewsAction) = when (action) {
        is NewsAction.Clicked -&gt; handleNewsClick(action.id)
        is NewsAction.Bookmark -&gt; handleNewsBookmark(action.id)
    }

    fun handleNewsClick(id: String) {
      viewModel.navigate(.....)
    }

    fun handleNewsBookmark(id: String) {
      newsRepo.bookmark(id)
      viewModel.showSnackBar("News Bookmarked")
    }
}
</code></pre>

<p>如上所示，我们为每个数据模型创建了一个 Action Handler 接口。</p>

<p>我们在这里所做的就是遵循上一节所示的接口设计。</p>

<ul>
<li>我们有两个属性，分别是ViewModel和Repository 类。</li>
<li>我们分别创建了处理每个 Action 的函数。当然，这是可选的。我保留这种方式是为了方便覆写任何特定的行为，并且我们为每个 Action 类型分别调用相应的 Action 处理函数。</li>
</ul>


<h3>创建 ViewModel</h3>

<p>让我们构建一个实现这两个接口的 ViewModel，以继承它们的功能。</p>

<pre><code class="Kotlin">class HomeViewModel : BaseViewModel(), PostActionHandler, NewsActionHandler {

    override val viewModel = this
    override val postRepo = PostRepository()
    override val newsRepo = NewsRepository()

    /**
      ViewModel其余代码
    **/

}
</code></pre>

<p>然后，我们在ViewModel中定义必要的属性（ viewModel 、 postRepo 和 newsRepo ），这些属性会被两个接口使用。</p>

<p>这种设计消除了冗余，并保持了代码的简洁性，因为我们只需设置一次属性，只要属性名称相同，两个接口就可以无缝地与其交互。
这种方法保持了ViewModel的中心地位，同时又可以轻松处理不同组件的UI交互和业务逻辑。</p>

<h2>🪝连接一切：将操作连接到 UI</h2>

<pre><code class="Kotlin">@Composable
fun HomeScreen(viewModel: HomeViewModel) {
    LazyColumn {
        items(viewModel.items) {
            when(it) {
                is News -&gt; NewsCard(it, onAction = viewModel::handleAction)
                is Post -&gt; PostCard(it, onAction = viewModel::handleAction)
            }
        }
    }
}

@Composable
private fun NewsCard(
  news: News,
  onAction: (NewsAction) -&gt; Unit
) {

}

@Composable
private fun PostCard(
  post: Post,
  onAction: (PostAction) -&gt; Unit
) {

}
</code></pre>

<p>在我们的UI组件中，我们可以直接将这些函数用作ViewModel本身的函数，这样就完成了在 Screen 中添加交互处理的功能。</p>

<ul>
<li>现在，假设我们有另一个只显示新闻的页面（Screen）。我们需要做的就是在ViewModel中实现 NewsActionHandler 接口——就这样，一切就绪。</li>
<li>我们可以无缝地从 BaseViewModel 或ViewModel调用任何函数，从而能够在一个单一的、集中的位置实现完整的端到端功能。如果我们在多个位置显示相同的数据模型，这将非常有利。</li>
</ul>


<h2>📦 整合所有功能</h2>

<p>在这篇博文中，我们探讨了在扩展Android UI（基本上是任何 UI）时最容易被忽视的问题之一，即跨ViewModel的重复UI交互逻辑。我们探索了三种不同的方法来解决这个问题：</p>

<ol>
<li>辅助类 - 一种快速解决方案，但存在严格的限制。</li>
<li>使用委托进行组合——一种更现代的继承驱动解决方案，
但它难以从外部访问功能。</li>
<li>使用默认函数的接口（我的解决方案）——一种实用、优雅且灵活的方法，克服了前两种方法的所有限制。</li>
</ol>


<p>通过利用 Kotlin 的接口默认方法并将ViewModel作为接口内部的属性，我们解锁了完整的可扩展性，并能够从其他继承的类/接口访问扩展功能。</p>

<p>现在，让我们以表格的形式比较一下每个解决方案：</p>

<table>
<thead>
<tr>
<th> 好处                           </th>
<th> 通过辅助类                                       </th>
<th> 使用委托进行组合                             </th>
<th> 带有默认函数的接口 (✅ 最好)         </th>
</tr>
</thead>
<tbody>
<tr>
<td> 🔁 可重用性                                 </td>
<td>  ✅ Yes        </td>
<td>  ✅ Yes         </td>
<td>  ✅ Yes </td>
</tr>
<tr>
<td> 🧠 覆写行为                        </td>
<td> ❌ 不可能          </td>
<td> ✅ 可以，由于继承        </td>
<td> ✅  可以，由于继承           </td>
</tr>
<tr>
<td> 🔗 访问从其他来源继承的功能                 </td>
<td> ❌ 不可以，因为它是一个封装类      </td>
<td> ❌  不可以，因为我们无法传递当前引用       </td>
<td> ✅  可以，因为我们可以将继承类保留为接口属性    </td>
</tr>
<tr>
<td> 🏗️ 跨页面可扩展性                  </td>
<td> ⚠️ 差——当逻辑还涉及视图模型特定功能时会变得困难               </td>
<td> ✅ 更好——可重复使用的逻辑                    </td>
<td> ✅ 最佳——跨页面即插即用            </td>
</tr>
<tr>
<td> ✅ 最佳用例                               </td>
<td> 对于非UI交互封装功能                   </td>
<td> 业务逻辑重用，非UI上下文            </td>
<td> 多个ViewModel中需要的UI交互 </td>
</tr>
</tbody>
</table>


<p>你可以在<a href="https://github.com/Vaibhav2002/Ui-Intreraction-Handler-Sample">专用的 GitHub 代码库</a>（链接：<a href="https://github.com/Vaibhav2002/Ui-Intreraction-Handler-Sample%EF%BC%89%E4%B8%AD%E6%8E%A2%E7%B4%A2%E6%9C%AC%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%90%E5%88%B0%E7%9A%84%E6%89%80%E6%9C%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%82%E6%AC%A2%E8%BF%8E%E9%9A%8F%E6%84%8Fclone%E3%80%81fork%E6%88%96%E8%AF%95%E7%94%A8%E3%80%82">https://github.com/Vaibhav2002/Ui-Intreraction-Handler-Sample%EF%BC%89%E4%B8%AD%E6%8E%A2%E7%B4%A2%E6%9C%AC%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%90%E5%88%B0%E7%9A%84%E6%89%80%E6%9C%89%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%82%E6%AC%A2%E8%BF%8E%E9%9A%8F%E6%84%8Fclone%E3%80%81fork%E6%88%96%E8%AF%95%E7%94%A8%E3%80%82</a></p>

<h2>✌️ 告别</h2>

<p>总而言之，希望这篇博客能帮助你解锁一些强大的技巧，提升你的Kotlin 和UI处理知识。有了Kotlin 的界面默认函数，你的构建将更加简洁、快速，并兼顾长期可扩展性。</p>

<p>如果你喜欢这篇文章并想随时了解最新动态：</p>

<ul>
<li>查看我的 LinkedIn、GitHub 和 X 个人资料，了解我正在做的事情。</li>
<li>想要更多 Kotlin 的魔法？阅读我之前的博客，了解另一种可以让你的代码库更精简、更智能的技术。</li>
</ul>


<p>感谢你的阅读，希望你喜欢！🚀</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MVI架构：Compose中的响应式状态管理]]></title>
    <link href="https://alexhilton.github.io/blog/2025/06/25/reactive-state-in-compose/"/>
    <updated>2025-06-25T22:32:21+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/06/25/reactive-state-in-compose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Reactive State Management in Compose — MVI Architecture」，原文链接<a href="https://proandroiddev.com/reactive-state-management-in-compose-mvi-architecture-71546c9f1b52">https://proandroiddev.com/reactive-state-management-in-compose-mvi-architecture-71546c9f1b52</a>，由Davies Adedayo AbdulGafar发布于2025年4月22日。</p></blockquote>

<p>译注：原文作者虽然是基于Jetpack Compose来写的，但重点讨论的是应用的MVI架构方式，涉及的都是纯Kotlin语言层面的，以及Compose层面的，并不涉及平台特性，因此完全适用于跨平台的Compose Multiplatform。</p>

<p><a href=""><img src="/Users/alexhilton/Downloads/banner_reactive.png" title="auto auto" ></a></p>

<!-- more -->


<h2>MVI是什么鬼</h2>

<h3>MVI架构的基本概念</h3>

<p>MVI（模型-视图-意图）架构为 Android 应用程序中可扩展、稳健且可测试的 UI 状态管理提供了一种结构良好的方法。它强调代码简洁和关注点分离（Separation of Concerns），将应用程序划分为三个主要组件——模型(Model)、视图(View)和意图(Intent)——它们共同构成一个循环：意图 -> 视图模型 -> 模型 -> 视图，从而定义单向数据流（<strong>译注：</strong>这里的意图Intent是架构中的一个逻辑概念，与Android系统中的Intent没有关系）。此架构模式提供的不同角色有助于更轻松地理解和维护 UI 状态。从本质上讲，MVI 不仅仅是一种架构模式，而是一个旨在流畅响应变化的响应式系统。这种响应性是其定义特征之一，也是其最大的优势。</p>

<ul>
<li>单向数据流：指数据以单向流动——从模型流向视图，并以意图的形式返回。这确保了架构的清晰度、可预测性和易维护性。</li>
<li>关注点分离：指模型、视图和意图组件具有不同的角色。模型管理状态，视图处理 UI 渲染，意图捕获并传达用户操作。</li>
<li>不可变性（Immutability）：确保模型的状态一旦设置便保持不变。这保证了可预测性，消除了意外的副作用，并促进了稳定可靠的应用状态。</li>
<li>响应式：当状态发生变化时，UI 会自动更新。</li>
</ul>


<p>该架构分解为三个和谐的组件，它们以响应式流程协同工作：</p>

<ul>
<li>模型 (Model) 是单一事实来源，它是应用程序在任何特定时刻的状态快照。当此状态发生变化时，它会触发整个系统的级联响应式更新。UI 会在状态变化时自动更新，这凸显了这一核心的响应式原则。</li>
<li>视图 (View) 根据当前模型状态以响应式方式渲染用户所见内容。它订阅状态变化并自动进行转换以反映这些变化，而无需任何命令式更新调用。这种响应式渲染正是 MVI 如此强大的原因——视图始终与状态同步。</li>
<li>意图 (Intent) 完善了响应式电路，捕获用户交互并将其反馈回系统以创建新状态。这形成了一个持续的反馈循环：用户操作触发意图，意图产生新状态，新状态触发 UI 更新。</li>
</ul>


<p>当我们说 MVI 具有响应式特性时，我们指的是整个系统都是围绕自动响应变化而构建的。数据发生变化时，UI 无需手动更新，而是会自动反映当前状态。这种响应式特性能够创建一个动态、响应迅速的应用程序，让用户感觉生动活泼。</p>

<h3>MVI架构的典型实现方式</h3>

<p>在原生 Android 开发中，MVI 的大部分实现都放在 ViewModel 类中。以下是实现 MVI 模式的一种简单方法：</p>

<ol>
<li>我们打算建模的 UI 状态将实现为一个不可变的 Kotlin 数据类（data class），其字段保存着我们想要在视图中显示的状态。</li>
<li>StateFlow 是将整个架构绑定在一起的响应式粘合剂。这个观察者对象包装了模型，并将变化通知给视图，以便它反映新的状态。这个响应式管道确保任何状态变化都会自动传播到 UI。</li>
<li>目前，我们的意图可以实现为 ViewModel 中的公共函数。这些函数应该没有返回值，以确保视图只接收来自观察者的状态更新。类似于对象作为编程语言中的一等公民，可以通过引用传递，同样，函数也依赖于方法引用。我们利用这一点将意图传递给使用它的 UI 节点。我们无需编写复杂的类来建模意图，因为那样需要额外实现意图处理程序。</li>
</ol>


<p>以下是在 ViewModel 中实现 MVI 模式的模板。</p>

<pre><code class="Kotlin">class ScreenViewModel() : ViewModel() {
  private val _uiState: MutableStateFlow&lt;MyModel&gt; = MutableStateFlow(MyModel(...)) // private observer object

  val uiState: StateFlow&lt;MyModel&gt; = _uiState // observer object exposed as an immutable instance

  fun doUpdateOnState(...) { ... } // public function serves as an intent
  fun doAnotherUpdate(...) { ... }
}

data class MyModel(...)
</code></pre>

<p>新状态在 ViewModel 中生成，然后由观察 uiState 的视图使用。请注意，Intent 是如何作为触发状态更改的回调传递到可组合项页面的。</p>

<pre><code class="Kotlin">@Composable
 fun MyScreen(viewModel: ScreenViewModel) {
   val uiState: MyModel = viewModel.uiState.collectAsStateWithLifeCycle() // consumes the state produced in the viewModel

   MyScreenContent(
     uiState = uiState,
     doUpdate = viewModel::doUpdateOnState, // intent to do update
     doAnotherUpdate = viewModel::doAnotherUpdate // intent to do another update
   )
 }
</code></pre>

<p>这种反应模式通过 Kotlin 的 StateFlow 实现：</p>

<pre><code class="Kotlin">private val _uiState: MutableStateFlow&lt;MyModel&gt; = MutableStateFlow(MyModel(...))
val uiState: StateFlow&lt;MyModel&gt; = _uiState
</code></pre>

<p>在 UI 方面，这种反应性通过收集操作来表达，该操作消耗从 viewModel 生成的新状态。</p>

<pre><code class="Kotlin">val uiState = viewModel.uiState.collectAsStateWithLifeCycle()
</code></pre>

<p>这行代码建立了一个响应式连接，每当状态发生变化时都会自动刷新 UI。无需手动刷新调用或复杂的更新逻辑——系统本身就是响应式的。</p>

<h2>案例研究</h2>

<p>让我们采用更实用的方法，实现 MVI 模式来管理页面 状态。下图是一个页面，用户可以从给定的选项中选择所显示问题的答案。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:838/format:webp/0*uwa_-6EYNOhyNuNJ" alt="Case study" /></p>

<p>图片来源 — <a href="https://github.com/android/compose-samples/tree/v2024.01.00/Jetsurvey">Compose 示例 Jetsurvey</a>（译注：链接是<a href="https://github.com/android/compose-samples/tree/v2024.01.00/Jetsurvey%EF%BC%89%E3%80%82%E7%82%B9">https://github.com/android/compose-samples/tree/v2024.01.00/Jetsurvey%EF%BC%89%E3%80%82%E7%82%B9</a><a href="https://github.com/SahDavies/mvi-architecture-sample/">击此</a>（译注：链接是<a href="https://github.com/SahDavies/mvi-architecture-sample/%EF%BC%89%E5%A4%84%E6%9F%A5%E7%9C%8B%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0%E3%80%82">https://github.com/SahDavies/mvi-architecture-sample/%EF%BC%89%E5%A4%84%E6%9F%A5%E7%9C%8B%E5%AE%8C%E6%95%B4%E5%AE%9E%E7%8E%B0%E3%80%82</a></p>

<p>页面包含以下状态：</p>

<ol>
<li>问题</li>
<li>选项列表</li>
<li>问题计数</li>
<li>选择指示器</li>
<li>启用/禁用按钮</li>
</ol>


<p>此外，页面还提供以下用户操作的输入：</p>

<ol>
<li>获取下一个问题</li>
<li>获取上一个问题</li>
<li>选择一个选项</li>
<li>关闭/结束操作。这些操作用于将用户的意图传达给应用程序。</li>
</ol>


<p>保存页面状态的模型可以这样实现：</p>

<pre><code class="Kotlin">data class UiState(
  val questionCount: Int,
  val totalQuestion: Int,
  val question: Question,
  val userSelection: Option?
) {
  val hasNext: Boolean = questionCount &lt; totalQuestion
  val hasPrevious: Boolean = questionCount &gt; 1
}
</code></pre>

<p>如前所述，为了简单起见，我们使用公共函数来描述意图，这些函数没有返回值。我们在下面列举了将在 ViewModel 中实现的函数。</p>

<pre><code class="Kotlin">fun next() // 加载下一个问题
fun previous() // 加载上一个问题
fun onOptionSelected(selection: Option) // 激活选中选项的标识
</code></pre>

<p>在视图中调用的每个函数都会触发一个新的状态以供视图使用，这样我们的页面就是可预测和可测试的，因为每个用户交互都会产生一个新的不可变状态，可以在测试期间进行比较。</p>

<pre><code class="Kotlin">@Composable
fun QuestionScreen(
    modifier: Modifier = Modifier,
    onDone: () -&gt; Unit
) {
    BackHandler { /* Do nothing */ }
    val viewModel = QuestionViewModel(getQuestions())
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()

    QuestionScreenContent(
        uiState = uiState,
        onClickNext = viewModel::next,
        onClickPrevious = viewModel::previous,
        onOptionSelected = viewModel::onOptionSelected,
        onDone = onDone
    )
}
</code></pre>

<p>注意：并非所有带有状态的页面组件都能用 MVI 管理。有些组件由单独的状态持有类管理，有些则由可组合组件本身的内部状态管理——例如上图中的进度指示器。不真正处理业务逻辑的状态不应该使用 MVI 管理。</p>

<h2>超越基本响应式</h2>

<p>上述案例研究基于我们的页面需求，使用了一个模型的简单实现。编写 MVI 模式的模型实现有很多方法——根据页面需求进行实现——例如，一个包含加载和错误状态的页面。通常，最简单的方法是使用密封的类层次结构来实现——尽管如此，你也可以选择以不同的方式实现你自己的模型。</p>

<pre><code class="Kotlin">// 考虑加载和错误状态的模型
internal sealed class UiState {
    object Loading : UiState()
    @Immutable
    class Content(val myModel: UiModel) : UiState()    
    @Immutable
    class Error(val error: ErrorUiModel): UiState()
}
</code></pre>

<p>视图使用这种新类型的方式略有不同，如下所示：</p>

<pre><code class="Kotlin"> @Composable
 fun MyScreenContent(uiState: UiState) {
    when(uiState) {
        is Loading -&gt; LoadingScreen() 
        is Error -&gt; ErrorScreen(uiState.error)
        is Content -&gt; ContentScreen(uiState.myModel)
    }
 }

fun LoadingScreen() { /* implementation block */ }
fun ErrorScreen(error: ErrorUiModel) { /* implementation block */ }
fun ContentScreen(content: UiModel) { /* implementation block */ }
</code></pre>

<p>需要注意的是，这种模型是互斥的——它保证三个状态不会同时发生，而是一次发生一个，这有助于防止 UI 状态渲染中常见的错误。</p>

<h3>重写 Intent 实现</h3>

<p>Intent 实现也可以通过添加 Reducer/Handler 来修改，Reducer/Handler 是 ViewModel 中的一个公共函数，它会调用私有实现（辅助函数）来执行操作，并使用 when 表达式分支到相应的操作。</p>

<pre><code class="Kotlin">Class HomeScreenViewModel() : ViewModel() {
    /*
    * Some class properties
    */

    // our reducer/handler
    fun onHomeAction(action: HomeAction) {
        when (action) {
            is HomeAction.CategorySelected -&gt; onCategorySelected(action.category)
            is HomeAction.TopicFollowed -&gt; onTopicFollowed(action.topic)
            is HomeAction.HomeCategorySelected -&gt; onHomeCategorySelected(action.category)
            is HomeAction.ToggleTopicFollowed -&gt; onToggleTopicFollowed(action.topic)
        }
    }

    private fun onCategorySelected(category: CategoryInfo) { ... }

    private fun onTopicFollowed(topic: TopicInfo) { ... }

    private fun onToggleTopicFollowed(topic: TopicInfo) { ... }

    private fun onHomeCategorySelected(category: HomeCategory) { ... }
}
</code></pre>

<p>为了使此设置正常工作，我们定义了一个密封的接口层次结构，对应于每个操作，其子类属性用于保存参数，然后这些参数将通过视图中的 reducer/handler 传递给这些操作。</p>

<pre><code class="Kotlin">@Immutable
sealed interface HomeAction {
    data class CategorySelected(val category: CategoryInfo) : HomeAction
    data class HomeCategorySelected(val category: HomeCategory) : HomeAction
    data class TopicFollowed(val topic: TopicInfo) : HomeAction
    data class ToggleTopicFollowed(val topic: TopicInfo) : HomeAction
}
</code></pre>

<p>与我们第一次实现 Intent 时需要在视图中使用方法引用传递所有操作不同，这里我们只需要传递 Reducer/Handler。然后，决定需要调用哪个操作的责任就落在了调用者身上。</p>

<p>这是视图中的样子</p>

<pre><code class="Kotlin">@Composable
fun HomeScreen(viewModel: HomeScreenViewModel, onNavigate: (String) -&gt; Unit) {

    HomeContent(
        modifier = Modifier.padding(contentPadding),
        onHomeAction = viewModel::onHomeAction,
        onNavigate = onNavigate,
    )

}
</code></pre>

<p>HomeContent 可组合函数现在负责决定调用哪个操作，方法是实例化以下任意对象，然后使用实例化的对象调用 onHomeAction</p>

<pre><code class="Kotlin">    HomeAction.CategorySelected(category = CategoryInfo())
    HomeAction.HomeCategorySelected(category = HomeCategory())
    HomeAction.TopicFollowed(topic = TopicInfo())
    HomeAction.ToggleTopicFollowed(topic = TopicInfo())
</code></pre>

<p>请参阅下面的实际操作！</p>

<pre><code class="Kotlin">@Composable
private fun HomeContent(
    modifier: Modifier = Modifier,
    onHomeAction: (HomeAction) -&gt; Unit, // HomeAction是一个密封类型层次
    onNavigate: (String) -&gt; Unit,
) {
    val homeCategory = HomeAction.HomeCategorySelected(CategoryInfo())
    onHomeAction(homeCategory) // triggers a state change
}
</code></pre>

<p>即使增加了复杂度，核心的响应式原则依然保持不变。Reducer 只是提供了一种更有条理的方式来处理意图并生成新的状态，而从状态到 UI 的响应式流程保持不变。</p>

<p>这种实现方式使得迭代构建变得简单——无论我们需要对意图进行什么更改（无论是添加新的意图还是删除现有的意图），都不需要像我们最初的实现那样在很多地方进行重写；我们只需在处理程序中注册新的操作，然后在调用处理程序时根据具体情况实例化不同的对象即可。</p>

<p>总结一下这篇文章，MVI 最优雅的方面在于它如何创建一个完整的响应式链路：</p>

<ol>
<li>模型发出状态</li>
<li>视图使用状态并渲染 UI</li>
<li>用户与视图的交互生成意图</li>
<li>意图被处理以创建新的模型</li>
<li>这个循环以响应式的方式持续进行</li>
</ol>


<p>这种不间断的响应式循环确保你的应用程序始终与用户操作和后端数据保持同步。这不仅仅是响应变化——而是创建一个系统，让变化自然地通过预定义的响应式路径进行。</p>
]]></content>
  </entry>
  
</feed>
