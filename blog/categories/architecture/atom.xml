<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Architecture | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/architecture/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2025-10-16T20:12:27+08:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[灵活、现代的Android应用架构：完整分步指南]]></title>
    <link href="https://alexhilton.github.io/blog/2025/10/13/a-flexible-modern-android-app-architecture/"/>
    <updated>2025-10-13T23:05:25+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/10/13/a-flexible-modern-android-app-architecture</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「A flexible, modern Android app architecture: complete step-by-step」，原文链接<a href="https://proandroiddev.com/a-flexible-modern-android-app-architecture-complete-step-by-step-d76901e29993">https://proandroiddev.com/a-flexible-modern-android-app-architecture-complete-step-by-step-d76901e29993</a>，由Tom Colvin发布于2023年7月4日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:2000/0*ykKTTMXsKNzLJ7In" title="auto auto" ></a></p>

<!-- more -->


<p>我最近写了一篇关于<a href="https://juejin.cn/post/7553894051460694055">优秀 Android 应用架构背后的理论</a>的文章。这篇文章成为了我迄今为止最受欢迎的文章，许多人都慷慨地表示它对他们很有帮助。</p>

<p>最常见的问题之一是：“但是 X 呢？它不太符合规则。” 这就是为什么我一直说：</p>

<blockquote><p>要学习原则，而不是盲目遵循规则。</p></blockquote>

<p>本文旨在展示实践的一面：通过示例来教授 Android 架构。最重要的是，这意味着展示各种架构决策是如何制定的。我们会遇到有多种可能答案的情况，在每种情况下，我们都会依靠原则，而不是死记硬背一套规则。</p>

<p>所以，让我们一起构建一个应用程序吧。</p>

<h2>介绍我们将要构建的应用程序</h2>

<p>我们将为行星观测者构建一款应用程序。它看起来会像这样：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:640/1*7C7vCDdsppHzE1DQkI3QJA.gif" alt="应用程序（全球排名第一的行星观测应用程序）演示：添加示例行星、添加自定义行星、删除行星以及刷新" /></p>

<p>我们的应用程序将具有以下功能：</p>

<ul>
<li>列出你之前发现的所有行星</li>
<li>添加新发现的行星</li>
<li>删除行星（以防你意识到你的发现实际上只是望远镜镜头上的一小块痕迹）</li>
<li>添加一些示例行星，以便用户了解应用程序的工作原理</li>
</ul>


<p>它将具有离线数据缓存以及在线数据库访问功能。</p>

<p>与我的演示一样，我鼓励你尝试不同的做法：添加额外功能，考虑未来可能出现的规格变更，挑战自我。在这里，学习的重点在于<em>代码背后的思考过程</em>，而不是代码本身。所以，如果你想从本教程中获得最大收获，不要盲目地复制代码。</p>

<p>这是我们最终的仓库：<a href="https://github.com/tdcolvin/PlanetSpotters">https://github.com/tdcolvin/PlanetSpotters</a>。</p>

<h2>介绍我们将要使用的架构原则</h2>

<p>我们将参考 SOLID 原则、整洁架构原则以及 Google 自己的现代应用架构原则。</p>

<p>我们不会将这些原则视为硬性规定，因为我们足够聪明，能够构建更适合我们应用（尤其是更符合我们预期应用增长方式）的架构。例如，如果你严格遵循整洁架构，你将开发出稳定、可靠、可扩展的软件，但对于单一用途的应用来说，你的代码可能会过于复杂。Google 的原则可以生成更简单的代码，但如果有一天该应用可能由多个大型开发团队维护，则这些原则就不太适用了。</p>

<p>我们将从 Google 的拓扑结构开始，并在此过程中参考整洁架构。</p>

<p>Google 的拓扑结构如下：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1200/1*tuohW6OJuZD8tMcAYjPBSg.png" alt="" /></p>

<p>我们将逐步实现这些功能，<a href="https://juejin.cn/post/7553894051460694055">我的上一篇文章</a> 对每个部分都进行了更深入的介绍。这里再简单地概述一下：</p>

<h3>UI 层</h3>

<p>UI 层实现用户界面。它分为：</p>

<ul>
<li><strong>UI 元素</strong>，即用于在屏幕上绘制内容的所有专有代码。在 Android 中，主要选择是 Jetpack Compose（此处使用 <code>@Composable</code>）或 XML（此处包含你的 XML 文件和资源）。</li>
<li><strong>状态持有者</strong>，用于实现你偏好的 MVVM / MVC / MVP / &hellip; 拓扑结构。在此应用中，我们将使用视图模型。</li>
</ul>


<h3>领域层</h3>

<p>领域层用于包含高级业务逻辑的<strong>用例</strong>。例如​​，当我们想要添加一个星球时，AddPlanetUseCase 将描述执行此操作所需的一系列步骤。它只是“做什么”的列表，而不是“怎么做”的列表：例如，我们会说“保存 Planet 对象的数据”。这是一个高级指令。我们不会说“将其保存到本地缓存”，更不用说“使用 Room 数据库将其保存到本地缓存”了——这些底层实现细节应该放在其他地方。</p>

<h3>数据层</h3>

<p>Google 敦促我们为应用中的所有数据提供单一可信来源；也就是说，一种获取最终“正确”数据版本的方法。这就是数据层将要提供的内容（涵盖除描述用户刚刚输入内容的数据结构之外的所有数据结构）。它分为：</p>

<ul>
<li><strong>存储库</strong>，用于管理各种类型的数据。例如，我们将有一个行星数据存储库，它将提供对已发现行星的 CRUD（创建、读取、更新、删除）操作。它还将处理数据存储在本地缓存和远程缓存中的情况，为不同类型的操作选择合适的数据源，并管理当两个数据源包含不同数据副本时的处理方式。这里我们将讨论本地缓存，但我们不会讨论我们将使用哪些第三方技术来实现它。</li>
<li><strong>数据源</strong>，用于管理数据存储的具体细节。当存储库请求“远程存储 X”时，它会请求数据源执行此操作。数据源仅包含驱动专有技术所需的代码——可能是 Firebase、HTTP API 或其他技术。</li>
</ul>


<h2>良好的架构允许延迟决策</h2>

<p>在此阶段，我们已经了解了应用的功能，以及一些关于如何管理数据的基本想法。</p>

<p>还有一些事情我们尚未确定。我们还不知道 UI 的具体外观，也不知道将使用什么技术来构建它（Jetpack Compose、XML 等）。我们不知道本地缓存将采用何种形式。我们不知道将使用哪种专有解决方案来访问在线数据。我们不知道是否支持手机、平板电脑或其他设备。</p>

<p><strong>_问题：我们需要了解以上任何内容才能制定架构吗？</strong></p>

<p><strong>_答案：不需要！</strong></p>

<p>以上都是底层考虑因素（在整洁架构中，它们的代码位于最外层）。它们是<em>实现细节</em>，而不是<em>逻辑</em>。SOLID 的依赖倒置原则告诉我们，任何代码都不应依赖于它们。</p>

<p>换句话说，我们应该能够在不了解上述任何知识的情况下编写（并测试！）应用程序的其余代码。当我们了解上述问题的答案时，我们已经编写的任何代码都无需更改。</p>

<p>这意味着代码生产阶段可以在设计师完成设计之前以及利益相关者决定使用第三方技术之前开始。因此，<em>良好的架构允许延迟决策</em>。（并且能够灵活地撤销任何此类决策，而不会导致严重的代码问题）。</p>

<h2>我们项目的架构图</h2>

<p>这是我们将行星观测员的应用程序融入 Google 拓扑结构的初步尝试。</p>

<h3>数据层</h3>

<p>我们将有一个用于行星数据的<strong>存储库</strong>，以及两个<strong>数据源</strong>：一个用于本地缓存，一个用于远程数据。</p>

<h3>UI 层</h3>

<p>将​​有两个<strong>状态持有者</strong>，一个用于行星列表页面，另一个用于添加行星页面。每个页面还会有一组<strong>UI 元素</strong>，这些元素将使用目前尚待确定的技术编写。</p>

<h3>领域层</h3>

<p>有两种非常有效的领域层架构方法：</p>

<ol>
<li>我们可以只在重复业务逻辑的地方添加用例。在我们的应用中，唯一重复的逻辑是添加行星：用户添加示例行星列表和手动输入自己的行星详细信息时都需要它。因此，我们只创建一个用例：AddPlanetUseCase。在其他情况下（例如删除行星），状态持有者将直接与存储库交互。</li>
<li>我们可以为与存储库的每次交互添加用例，这样状态持有者和存储库之间就不会有任何直接联系。在这种情况下，我们将有添加行星、删除行星和列出行星的用例。</li>
</ol>


<p>第二种方法的好处是它遵循了整洁架构的规则。我个人认为这种方法对于大多数应用来说有点太重了，所以我倾向于选择第一种。这就是我们要做的。</p>

<p>这给了我们以下架构图：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*69Zaett5v82b0uzpF1dgOg.png" alt="我们应用的架构图：显示 UI、领域和数据层的架构图" /></p>

<h2>我们应该从哪些代码开始？</h2>

<p>规则是：</p>

<blockquote><p>从高层代码开始，然后逐步向下。</p></blockquote>

<p>这意味着首先要写出用例，因为这样做可以告诉我们存储库层有哪些需求。一旦我们知道存储库需要什么，我们就可以写出数据源需要什么来支持它。</p>

<p>同样，由于用例告诉我们用户可能采取的所有操作，我们就可以了解 UI 的所有输入和输出。由此，我们可以知道 UI 需要包含哪些内容，从而可以编写状态持有者（视图模型）。有了状态持有者，我们就知道需要编写哪些 UI 元素。</p>

<p>当然，一旦高级工程师和项目利益相关者就将要使用的技术达成一致，我们就可以无限期地推迟编写 UI 元素和数据源（即所有底层代码）。</p>

<p>理论到此结束。现在让我们开始构建应用程序。我会向你们详细介绍我们做出的决定。</p>

<h2>步骤 0：创建项目</h2>

<p>打开 Android Studio 并创建一个“无活动”项目：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*SQ52XlNqWwTEQ9GfsluAQA.png" alt="Android Studio“No Activity”项目" /></p>

<p>在下一个屏幕上，将其命名为 PlanetSpotters，其他内容保持不变：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*wkq8joirefCSsxeR-y3bnw.png" alt="Android Studio“新建项目”屏幕显示输入的名称为“PlanetSpotters”" /></p>

<h3>添加依赖注入</h3>

<p>我们需要一个依赖注入框架，它有助于应用 SOLID 的依赖倒置原则。 Hilt 是我最喜欢的选择，而且值得庆幸的是，它也是 Google 特别推荐的。</p>

<p>要 <a href="https://developer.android.com/training/dependency-injection/hilt-android">添加 Hilt</a>，请在根 Gradle 文件中添加以下内容：</p>

<pre><code class="groovy">plugins {
  ...
  id 'com.google.dagger.hilt.android' version '2.44.2' apply false
}
</code></pre>

<p>并在 app/build.gradle 文件中添加以下内容：</p>

<pre><code class="groovy">plugins {
  id 'kotlin-kapt'
  id 'com.google.dagger.hilt.android'
}

android {
  ...
  compileOptions {
    sourceCompatibility JavaVersion.VERSION_17
    targetCompatibility JavaVersion.VERSION_17
  }

  kotlinOptions {
    jvmTarget = '17'
  }
}

dependencies {
  implementation "com.google.dagger:hilt-android:2.44.2"
  kapt "com.google.dagger:hilt-compiler:2.44.2"
}

// Allow references to generated code
kapt {
  correctErrorTypes true
}
</code></pre>

<p>（请注意，我们在此处将兼容性设置为 Java 17，这是 Hilt 使用的 Kapt 的要求。你需要 Android Studio Flamingo 或更高版本）。</p>

<p>最后，添加 Application 类的重写，其中包含 <code>@HiltAndroidApp</code> 注解。也就是说，在应用的包文件夹（此处为 <code>com.tdcolvin.planetspotters</code>）中创建一个名为 PlanetSpottersApplication 的文件，内容如下：</p>

<pre><code class="kotlin">package com.tdcolvin.planetspotters

import android.app.Application
import dagger.hilt.android.HiltAndroidApp

@HiltAndroidApp
class PlanetSpottersApplication: Application()
</code></pre>

<p>……然后，通过将文件添加到清单中，告诉操作系统实例化它：</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"&gt;

    &lt;application
        ....
        android:name=".PlanetSpottersApplication"
        ...
    /&gt;

    ...
&lt;/manifest&gt;
</code></pre>

<p>一旦我们有了主 Activity，我们就需要为其添加 <code>@AndroidEntryPoint</code>。但现在，我们的 Hilt 设置就完成了。</p>

<p>最后，我们将通过在 app/build.gradle 中添加以下代码来添加对其他有用库的支持：</p>

<pre><code class="groovy">dependencies {
    ...

    //Coroutines
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.6.4'

    //viewModelScope
    implementation 'androidx.lifecycle:lifecycle-viewmodel-ktx:2.6.1'
}
</code></pre>

<h2>步骤 1：列出用户可以执行和查看的所有功能</h2>

<p>此步骤是编写用例和存储库的准备工作。回想一下，用例是用户可以执行的单个任务，并以高层次描述（描述“什么”，而不是“如何”）。</p>

<p>因此，让我们从写出这些任务开始；列出用户可以在应用中执行和查看的所有功能的详尽列表。</p>

<p>其中一些任务最终会被编码为用例。（事实上，在清晰架构下，所有此类任务都必须以用例的形式编写）。其他任务将由 UI 层直接与存储库层通信来完成。</p>

<p>这里需要一份书面规范。它不需要 UI 设计，但如果有的话，它无疑有助于可视化。</p>

<p>我们的列表如下：</p>

<h3>获取已发现行星的列表，该列表会自动更新</h3>

<p><strong>输入</strong>：无</p>

<p><strong>输出</strong>：Flow&lt;List<Planet>></p>

<p><strong>操作</strong>：从存储库请求当前已发现行星的列表，该列表必须以表单形式提供，以便在发生变更时及时通知我们。</p>

<h3>获取单个已发现行星的详细信息，该列表会自动更新</h3>

<p><strong>输入</strong>：String — 我们要获取的行星的 ID</p>

<p><strong>输出</strong>：Flow<Planet></p>

<p><strong>操作</strong>：从存储库请求具有指定 ID 的行星，并在发生变更时通知我们。</p>

<h3>添加/编辑新发现的行星</h3>

<p><strong>输入</strong>：</p>

<ul>
<li>planetId: String? — 如果非空，则为要编辑的行星的 ID。如果为空，则表示我们正在添加一颗新行星。</li>
<li>name：字符串 — 行星名称</li>
<li>distanceLy：浮点型 — 行星与地球的距离（光年）</li>
<li>discover：日期 — 发现日期</li>
</ul>


<p><strong>输出</strong>：无（完成即成功，无异常）</p>

<p><strong>操作</strong>：根据输入创建一个 Planet 对象，并将其传递给存储库（以添加到其数据源）</p>

<h3>添加一些示例行星</h3>

<p><strong>输入</strong>：无</p>

<p><strong>输出</strong>：无（出错时抛出）</p>

<p><strong>操作</strong>：请求存储库添加三颗示例行星，其发现日期为当前时间：Trenzalore（300 光年）、Skaro（0.5 光年）、Gallifrey（40 光年）。</p>

<h3>删除行星</h3>

<p><strong>输入</strong>：字符串 — 待删除行星的 ID</p>

<p><strong>输出</strong>：无（出错时抛出）</p>

<p><strong>操作</strong>：请求存储库删除具有指定 ID 的行星。</p>

<p>现在我们有了这个列表，我们就可以开始编写用例和存储库了。</p>

<h2>步骤 2：编写用例（Usec ases）</h2>

<p>从步骤 1 开始，我们得到了一个用户可以执行的任务列表。之前我们决定，在这些任务中，唯一要编写为用例的任​​务是“添加星球”。（我们决定只添加那些在应用的不同区域重复执行任务的用例）。</p>

<p>这样我们就有了一个可以在这里编写的用例：<strong>AddPlanetUseCase</strong>。</p>

<p>一个很棒的 Kotlin 技巧是将用例的逻辑放在 <code>operator fun invoke(…)</code> 函数中。这样就可以像调用函数一样调用代码来“调用”类实例，如下所示：</p>

<pre><code class="kotlin">val addPlanetUseCase: AddPlanetUseCase = …//Use our instance as if it were a function:
addPlanetUseCase(…)
</code></pre>

<p>这是我们使用该技巧编写的 AddPlanetUseCase 代码：</p>

<pre><code class="kotlin">class AddPlanetUseCase @Inject constructor(private val planetsRepository: PlanetsRepository) {
    suspend operator fun invoke(planet: Planet) {
        if (planet.name.isEmpty()) {
            throw Exception("Please specify a planet name")
        }
        if (planet.distanceLy &lt; 0) {
            throw Exception("Please enter a positive distance")
        }
        if (planet.discovered.after(Date())) {
            throw Exception("Please enter a discovery date in the past")
        }
        planetsRepository.addPlanet(planet)
    }
}
</code></pre>

<p>这里的 PlanetsRepository 是一个接口，它列出了存储库将拥有的方法。稍后会详细介绍（特别是为什么我们要创建接口而不是类）。但现在我们先创建它，这样我们的代码就能编译了：</p>

<pre><code class="kotlin">interface PlanetsRepository {
    suspend fun addPlanet(planet: Planet)
}
</code></pre>

<p>描述 Planet 的数据类型：</p>

<pre><code class="kotlin">data class Planet(
    val planetId: String?,
    val name: String,
    val distanceLy: Float,
    val discovered: Date
)
</code></pre>

<p>addPlanet 方法（类似于用例中的 invoke 函数）被声明为 <code>suspend</code>，因为我们知道它会涉及后台工作。稍后我们会向此接口添加更多方法，但目前这已经足够了。</p>

<p>顺便说一句，你可能会问，我们为什么要费心创建一个如此简单的用例？答案在于它可能会如何发展。未来它可能会变得更加复杂，而外部代码可以与这种复杂性隔离开来。</p>

<h2>步骤 2.1：测试用例</h2>

<p>我们现在已经编写了用例，但无法运行它。首先，它依赖于 <code>PlanetsRepository</code> 接口，而我们还没有它的实现。Hilt 不知道该如何处理它。</p>

<p>但我们可以编写测试，提供一个伪造的 <code>PlanetsRepository</code> 实例，并使用我们的测试框架运行它。这就是你现阶段应该做的事情。</p>

<p>由于这是一个关于架构的教程，测试的具体细节超出了范围，所以这一步留作练习。但请注意，良好的架构设计使我们能够将组件拆分成易于测试的部分。</p>

<h2>步骤 3：数据层，编写 PlanetsRepository</h2>

<p>请记住，存储库的作用是整理不同的数据源，管理它们之间的差异，并提供 CRUD 操作。</p>

<h3>使用依赖倒置和依赖注入</h3>

<p>根据整洁架构和依赖倒置原则（更多信息请参阅我的上一篇文章），我们希望避免外部代码依赖于存储库实现内部的代码。这样，用例或视图模型（例如）就不会受到存储库代码更改的影响。</p>

<p>这也解释了为什么我们之前将 PlanetsRepository 创建为接口（而不是类）。调用代码将仅依赖于接口，但它将通过依赖注入接收实现。现在我们将向接口添加更多方法，并创建它的实现，我们将其命名为 <strong>DefaultPlanetsRepository</strong>。</p>

<p>（补充：一些开发团队习惯将实现命名为 <code>&lt;接口名称&gt;Impl</code>；例如 <code>PlanetsRepositoryImpl</code>。我认为这种约定不利于代码可读性：类名应该能够说明实现接口的原因。所以我避免使用这种方式。但我还是提到了它，因为它的使用非常广泛。）</p>

<h3>使用 Kotlin Flows 实现数据可用</h3>

<p>如果你还没有接触过 <a href="https://developer.android.com/kotlin/flow">Kotlin Flows</a>，那就赶紧停下手头的工作，现在就去了解一下吧。它们将改变你的生活。</p>

<p>它们提供了一个数据“管道”，会随着新结果的出现而变化。只要调用者注册了该管道，他们就会在发生变更时收到更新。现在，我们的 UI 可以随着数据更新而自动更新，几乎无需任何额外操作。相比之下，过去我们必须手动向 UI 标记数据已更改。</p>

<p>其他解决方案，例如 RxJava 和 MutableLiveData，它们具有类似的功能，但它们不如 Flows 灵活易用。</p>

<h3>添加无处不在的 WorkResult 类</h3>

<p>WorkResult 类是数据层的常见返回值。它允许我们描述特定请求是否成功，如下所示：</p>

<pre><code class="kotlin">package com.tdcolvin.planetspotters.data.repository

sealed class WorkResult&lt;out R&gt; {
    data class Success&lt;out T&gt;(val data: T) : WorkResult&lt;T&gt;()
    data class Error(val exception: Exception) : WorkResult&lt;Nothing&gt;()
    object Loading : WorkResult&lt;Nothing&gt;()
}
</code></pre>

<p>调用代码可以检查给定的 WorkResult 是“Success”、“Error”还是“Loading”对象（后者表示请求尚未完成），从而确定请求是否成功。</p>

<h3>我们的存储库接口</h3>

<p>让我们将以上所有内容结合起来，制定构成 PlanetsRepository 的方法和属性的规范。</p>

<p>它有两种获取行星的方法。第一个方法通过 ID 获取单个行星：</p>

<pre><code class="kotlin">fun getPlanetFlow(planetId: String): Flow&lt;WorkResult&lt;Planet?&gt;&gt;
</code></pre>

<p>第二个方法获取一个代表行星列表的 Flow：</p>

<pre><code class="kotlin">fun getPlanetsFlow(): Flow&lt;WorkResult&lt;List&lt;Planet&gt;&gt;&gt;
</code></pre>

<p>这两个方法都是各自数据的唯一真实来源。每次我们都会返回存储在本地缓存中的数据，因为我们需要处理这些方法的频繁运行，而且本地数据比访问远程数据源更快、更便宜。但我们需要一个方法来刷新本地缓存。这将从远程数据源更新本地数据源：</p>

<pre><code class="kotlin">suspend fun refreshPlanets()
</code></pre>

<p>接下来我们需要添加、更新和删除行星的方法：</p>

<pre><code class="kotlin">suspend fun addPlanet(planet: Planet)suspend fun deletePlanet(planetId: String)
</code></pre>

<p>所以我们的界面现在看起来像这样：</p>

<pre><code class="kotlin">package com.tdcolvin.planetspotters.data.repository

...

interface PlanetsRepository {
    fun getPlanetsFlow(): Flow&lt;WorkResult&lt;List&lt;Planet&gt;&gt;&gt;
    fun getPlanetFlow(planetId: String): Flow&lt;WorkResult&lt;Planet?&gt;&gt;
    suspend fun refreshPlanets()
    suspend fun addPlanet(planet: Planet)
    suspend fun deletePlanet(planetId: String)
}
</code></pre>

<h3>边写边写数据源接口</h3>

<p>为了编写实现接口的类，我们需要关注数据源需要哪些方法。回想一下，我们有两个数据源：LocalDataSource 和 RemoteDataSource。我们还没有决定使用哪种第三方技术——而且现在也不需要。</p>

<p>现在让我们创建接口定义，以便我们边写边添加方法签名：</p>

<pre><code class="kotlin">package com.tdcolvin.planetspotters.data.source.local

interface LocalDataSource {
  //Ready to add method signatures here...
}
</code></pre>

<pre><code class="kotlin">package com.tdcolvin.planetspotters.data.source.remote

interface RemoteDataSource {
  //Ready to add method signatures here...
}
</code></pre>

<p>准备好填充这些接口后，我们现在可以编写 DefaultPlanetsRepository 了。让我们逐一调用这些方法：</p>

<h3>编写 getPlanetFlow() 和 getPlanetsFlow()</h3>

<p>这两个方法都很简单；我们返回本地数据源中的数据。 （为什么不使用远程数据源？因为本地数据源的存在是为了快速、轻量地访问数据。远程数据源可能始终是最新的，但速度很慢。如果我们确实需要最新的数据，那么我们可以在调用 getPlanetsFlow() 之前使用下面的 refershPlanets()。）</p>

<pre><code class="kotlin">override fun getPlanetsFlow(): Flow&lt;WorkResult&lt;List&lt;Planet&gt;&gt;&gt; {
    return localDataSource.getPlanetsFlow()
}

override fun getPlanetFlow(planetId: String): Flow&lt;WorkResult&lt;Planet?&gt;&gt; {
    return localDataSource.getPlanetFlow(planetId)
}
</code></pre>

<p>所以这依赖于 LocalDataSource 中的 getPlanetFlow() 和 getPlanetsFlow() 函数。我们现在将它们添加到接口中，以便代码能够编译。</p>

<pre><code class="kotlin">interface LocalDataSource {
    fun getPlanetsFlow(): Flow&lt;WorkResult&lt;List&lt;Planet&gt;&gt;&gt;
    fun getPlanetFlow(planetId: String): Flow&lt;WorkResult&lt;Planet?&gt;&gt;
}
</code></pre>

<h3>编写 refreshPlanets()</h3>

<p>要更新本地缓存，我们从远程数据源获取当前的行星列表，并将其保存到本地数据源。（然后，本地数据源可以“注意到”更改，并通过 getPlanetsFlow() 返回的 Flow 发出新的行星列表。）</p>

<pre><code class="kotlin">override suspend fun refreshPlanets() {
    val planets = remoteDataSource.getPlanets()
    localDataSource.setPlanets(planets)
}
</code></pre>

<p>这需要在每个数据源接口中创建一个新方法，现在如下所示：</p>

<pre><code class="kotlin">interface LocalDataSource {
    fun getPlanetsFlow(): Flow&lt;WorkResult&lt;List&lt;Planet&gt;&gt;&gt;
    fun getPlanetFlow(planetId: String): Flow&lt;WorkResult&lt;Planet?&gt;&gt;
    suspend fun setPlanets(planets: List&lt;Planet&gt;)
}
</code></pre>

<pre><code class="kotlin">interface RemoteDataSource {
    suspend fun getPlanets(): List&lt;Planet&gt;
}
</code></pre>

<p>注意所有这些方法都被声明为“suspend fun”。这将线程和协程上下文的责任转交给调用者。</p>

<h3>编写 addPlanet() 和 deletePlanet()</h3>

<p>这两个函数都遵循相同的模式：对远程数据源执行写入操作，如果成功，则将更改镜像到本地缓存。</p>

<p>我们期望远程数据源在 Planet 对象写入数据库后为其分配一个唯一的 ID，因此 RemoteDataSource 的 addPlanet() 函数返回一个更新后的 Planet 对象，该对象具有非空的ID（NonNull ID）。</p>

<pre><code class="kotlin">override suspend fun addPlanet(planet: Planet) {
    val planetWithId = remoteDataSource.addPlanet(planet)
    localDataSource.addPlanet(planetWithId)
}

override suspend fun deletePlanet(planetId: String) {
    remoteDataSource.deletePlanet(planetId)
    localDataSource.deletePlanet(planetId)
}
</code></pre>

<p>完成所有这些之后，最终的数据源接口如下：</p>

<pre><code class="kotlin">interface LocalDataSource {
    fun getPlanetsFlow(): Flow&lt;WorkResult&lt;List&lt;Planet&gt;&gt;&gt;
    fun getPlanetFlow(planetId: String): Flow&lt;WorkResult&lt;Planet?&gt;&gt;
    suspend fun setPlanets(planets: List&lt;Planet&gt;)
    suspend fun addPlanet(planet: Planet)
    suspend fun deletePlanet(planetId: String)
}
</code></pre>

<pre><code class="kotlin">interface RemoteDataSource {
    suspend fun getPlanets(): List&lt;Planet&gt;
    suspend fun addPlanet(planet: Planet): Planet
    suspend fun deletePlanet(planetId: String)
}
</code></pre>

<p>我们稍后会编写实现这些接口的代码，但现在，我们先来看看 UI。</p>

<h2>步骤 4：状态持有者，编写 PlanetsListViewModel</h2>

<p>回想一下，UI 层由 UI 元素和状态持有者层组成：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*Z0Px8K4iaChOzLPxDd9GPw.png" alt="UI层" /></p>

<p>目前我们还不知道要使用什么技术来绘制 UI，所以还不能编写 UI 元素层。但这没关系；我们可以继续编写状态持有者，而且一旦我们做出决定，它们就无需更改。这就是优秀架构的更多优势！</p>

<h3>编写 PlanetsListViewModel 的规范</h3>

<p>UI 将包含两个页面，一个用于列出和删除行星，另一个用于添加或编辑行星。PlanetsListViewModel 为前者提供支持。这意味着它需要将数据暴露给行星列表屏幕的 UI 元素，并且必须准备好在用户执行操作时接收来自 UI 元素的事件。</p>

<p>具体来说，我们的 PlanetsListViewModel 需要暴露：</p>

<ul>
<li>描述页面当前状态的 Flow（至关重要的是，它包含行星列表）</li>
<li>刷新列表的方法</li>
<li>删除行星的方法</li>
<li>添加示例行星的方法，帮助用户了解应用的功能</li>
</ul>


<h3>PlanetsListUiState 对象：页面的当前状态</h3>

<p>我发现将页面的整个状态包含在一个数据类中很有帮助：</p>

<pre><code class="kotlin">data class PlanetsListUiState(
    val planets: List&lt;Planet&gt; = emptyList(),
    val isLoading: Boolean = false,
    val isError: Boolean = false
)
</code></pre>

<p>请注意，我已将其与视图模型定义在同一个文件中。它仅包含简单对象：没有 Flow 等，只有原始类型、数组和简单的数据类。另请注意，所有字段都有默认值——这将在后面帮助我们。</p>

<p>（有一些很好的理由让你甚至不希望 Planet 对象出现在上面的代码中。整洁架构的纯粹主义者会指出，在 Planet 的定义和使用之间，层级跳跃太多了。状态提升原则告诉我们，只提供我们需要的精确数据。例如，现在我们只需要 Planet 的名称和距离，所以我们应该只提供这些，而不是整个 Planet 对象。我个人认为这不必要地增加了代码的复杂性，并使未来的修改更加困难，但你可以不同意！）</p>

<p>定义好之后，我们现在可以在视图模型中创建一个状态变量来暴露它：</p>

<pre><code class="kotlin">package com.tdcolvin.planetspotters.ui.planetslist

...

@HiltViewModel
class PlanetsListViewModel @Inject constructor(
    planetsRepository: PlanetsRepository
): ViewModel() {
    private val planets = planetsRepository.getPlanetsFlow()

    val uiState = planets.map { planets -&gt;
        when (planets) {
            is WorkResult.Error -&gt; PlanetsListUiState(isError = true)
            is WorkResult.Loading -&gt; PlanetsListUiState(isLoading = true)
            is WorkResult.Success -&gt; PlanetsListUiState(planets = planets.data)
        }
    }.stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5000),
        initialValue = PlanetsListUiState(isLoading = true)
    )
}
</code></pre>

<p>看看如何根据刚从存储库收到的不同类型的结果来创建“下一个”UI 状态？</p>

<p><code>.stateIn(…)</code> 的 <code>scope</code> 和 <code>started</code> 参数安全地限制了此 StateFlow 的生命周期。更多信息，请参阅 <a href="https://medium.com/androiddevelopers/consuming-flows-safely-in-jetpack-compose-cde014d0d5a3">Manual Vivo 的精彩文章</a>。</p>

<h3>添加示例行星</h3>

<p>为了添加这 3 个示例行星，我们反复调用为此创建的用例。</p>

<pre><code class="kotlin">fun addSamplePlanets() {
    viewModelScope.launch {
        val planets = arrayOf(
            Planet(name = "Skaro", distanceLy = 0.5F, discovered = Date()),
            Planet(name = "Trenzalore", distanceLy = 5F, discovered = Date()),
            Planet(name = "Galifrey", distanceLy = 80F, discovered = Date()),
        )
        planets.forEach { addPlanetUseCase(it) }
    }
}
</code></pre>

<h3>刷新和删除</h3>

<p>刷新和删除函数的结构非常相似，只需调用相应的存储库函数即可。</p>

<pre><code class="kotlin">fun deletePlanet(planetId: String) {
    viewModelScope.launch {
        planetsRepository.deletePlanet(planetId)
    }
}

fun refreshPlanetsList() {
    viewModelScope.launch {
        planetsRepository.refreshPlanets()
    }
}
</code></pre>

<h2>步骤 5：编写 AddEditPlanetViewModel</h2>

<p>AddEditPlanetViewModel 为用于添加新行星或编辑现有行星的屏幕提供支持。</p>

<p>正如我们之前所做的那样——事实上，这也是任何视图模型的良好实践——我们将为 UI 显示的所有内容定义一个数据类，并为其定义一个单一的数据源：</p>

<pre><code class="kotlin">data class AddEditPlanetUiState(
    val planetName: String = "",
    val planetDistanceLy: Float = 1.0F,
    val planetDiscovered: Date = Date(),
    val isLoading: Boolean = false,
    val isPlanetSaved: Boolean = false
)

@HiltViewModel
class AddEditPlanetViewModel @Inject constructor(): ViewModel() {
    private val _uiState = MutableStateFlow(AddEditPlanetUiState())
    val uiState: StateFlow&lt;AddEditPlanetUiState&gt; = _uiState.asStateFlow()
}
</code></pre>

<p>如果我们正在编辑一个星球（而不是添加一个新的星球），我们希望视图的初始状态代表该星球的当前状态。</p>

<p>按照良好实践，此屏幕只会传递我们正在编辑的星球的 ID。（我们不会传递整个 Planet 对象——这可能会变得太大太复杂）。Android 的 Lifecycle 组件为我们提供了一个 SavedStateHandle，我们可以从中获取星球 ID 并加载 Planet 对象：</p>

<pre><code class="kotlin">@HiltViewModel
class AddEditPlanetViewModel @Inject constructor(
    savedStateHandle: SavedStateHandle,
    private val planetsRepository: PlanetsRepository
): ViewModel() {
    private val planetId: String? = savedStateHandle[PlanetsDestinationsArgs.PLANET_ID_ARG]

    private val _uiState = MutableStateFlow(AddEditPlanetUiState())
    val uiState: StateFlow&lt;AddEditPlanetUiState&gt; = _uiState.asStateFlow()

    init {
        if (planetId != null) {
            loadPlanet(planetId)
        }
    }

    private fun loadPlanet(planetId: String) {
        _uiState.update { it.copy(isLoading = true) }
        viewModelScope.launch {
            val result = planetsRepository.getPlanetFlow(planetId).first()
            if (result !is WorkResult.Success || result.data == null) {
                _uiState.update { it.copy(isLoading = false) }
            }
            else {
                val planet = result.data
                _uiState.update {
                    it.copy(
                        isLoading = false,
                        planetName = planet.name,
                        planetDistanceLy = planet.distanceLy,
                        planetDiscovered = planet.discovered
                    )
                }
            }
        }
    }
}
</code></pre>

<p>请注意我们如何使用这种模式更新 UI 状态：</p>

<pre><code class="kotlin">_uiState.update { it.copy( ... ) }
</code></pre>

<p>只需一行简单的代码，即可创建一个新的 AddEditPlanetUiState，其值从前一个复制而来，并通过 uiState Flow 将其发送出去。</p>

<p>以下是使用该技术更新行星各项属性的函数：</p>

<pre><code class="kotlin">fun setPlanetName(name: String) {
    _uiState.update { it.copy(planetName = name) }
}

fun setPlanetDistanceLy(distanceLy: Float) {
    _uiState.update { it.copy(planetDistanceLy = distanceLy) }
}
</code></pre>

<p>最后，我们使用 AddPlanetUseCase 保存行星对象：</p>

<pre><code class="kotlin">class AddEditPlanetViewModel @Inject constructor(
    private val addPlanetUseCase: AddPlanetUseCase,
    ...
): ViewModel() {

    ...

    fun savePlanet() {
        viewModelScope.launch {
            addPlanetUseCase(
                Planet(
                    planetId = planetId,
                    name = _uiState.value.planetName,
                    distanceLy = uiState.value.planetDistanceLy,
                    discovered = uiState.value.planetDiscovered
                )
            )
            _uiState.update { it.copy(isPlanetSaved = true) }
        }
    }

    ...

}
</code></pre>

<h2>步骤 6：编写数据源和 UI 元素</h2>

<p>现在我们已经完成了整个架构，可以编写最底层的代码了。也就是 UI 元素和数据源。对于 UI 元素，我们可以选择使用 Jetpack Compose 来支持手机和平板电脑。对于本地数据源，我们可以使用 Room DB 编写缓存；对于远程数据源，我们可以模拟访问远程 API。</p>

<p>这些层应该尽可能精简。例如，UI 元素代码不应包含任何计算或逻辑，而应仅包含获取视图模型给定状态并将其显示在屏幕上所需的代码。逻辑是为视图模型编写的。</p>

<p>对于数据源，只需编写实现 LocalDataSource 和 RemoteDataSource 接口中函数所需的最少代码即可。</p>

<p>具体的第三方技术（例如 Compose 和 Room）不在本教程的讨论范围内，但你可以在<a href="https://github.com/tdcolvin/PlanetSpotters">代码仓库</a> 中查看这些层的示例实现。</p>

<h3>将底层代码留到最后</h3>

<p>请注意，我们能够将应用程序的这些部分留到最后。这非常有益，因为它为利益相关者提供了充足的时间来决定使用哪些第三方技术以及应用程序的外观。即使在编写代码之后，我们也可以撤销这些决定，而不会影响应用程序的任何其他部分。</p>

<p>完整的代码库位于：<a href="https://github.com/tdcolvin/PlanetSpotters">https://github.com/tdcolvin/PlanetSpotters</a>。</p>

<p>本教程有很多内容需要学习；祝贺你坚持到最后。希望本教程对你有所帮助。我没有徽章（更不用说文凭）可以颁发——但请随意（甚至鼓励）自己制作一个，并将结果发布在这里。</p>

<p>当然，如果你有任何问题或意见，或者你不同意某些观点（实际上<em>特别是</em>如果你不同意某些观点），请分享！请在此处留言，我会尽力回复所有人。</p>

<p>最后，我目前每周提供几节免费课程，帮助任何有 Android 开发或应用业务相关经验的人士。你可以在这里预约：<a href="https://calendly.com/tdcolvin/android-assistance">calendly.com/tdcolvin/android-assistance</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何构建Android应用：深入探讨原则而非规则]]></title>
    <link href="https://alexhilton.github.io/blog/2025/10/11/how-to-architect-an-android-app/"/>
    <updated>2025-10-11T21:34:02+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/10/11/how-to-architect-an-android-app</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「How to architect Android apps: a deep dive into principles, not rules」，原文链接<a href="https://proandroiddev.com/how-to-architect-android-apps-a-deep-dive-into-principles-not-rules-2f1eb7f26402">https://proandroiddev.com/how-to-architect-android-apps-a-deep-dive-into-principles-not-rules-2f1eb7f26402</a>，由Tom Colvin发布于2023年5月25日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:2000/0*kT0PbUHF8ld0sU0t" title="auto auto" ></a></p>

<!-- more -->


<p>大多数 Android 开发者都经历过这样的场景……你被要求为应用添加一个简单的功能，但这样做会迫使你修改其他部分，然后又修改其他部分，直到你的修改变得非常繁琐，无法测试。</p>

<p>你可能也开发过这样的应用，用一些不靠谱的方式进行修改比弄清楚如何正确地做某件事要容易得多。或者，应用某个部分的修改会导致数百个完全不相关的 bug 突然出现。</p>

<p>这些都是糟糕架构的标志。</p>

<p>因此，本文基于我的演讲《别跟架构作对》探讨如何构建优秀的应用架构。</p>

<h3>正确的方法</h3>

<p>因为当你构建了优秀的应用架构后，你会发现它安全可靠、可测试且易于维护。你将能够推迟诸如使用哪个后端之类的决策，并在之后相对轻松地撤销这些决策。对我们开发者来说，最重要的是，有一个明确的“正确方法”，可以正确地隔离需要隔离的部分，这意味着即使是最初级的开发者也能在团队中发挥作用。</p>

<p>关于构建软件架构的“正确”方法有很多建议，其中很多都相互矛盾。因此，在本文中，我将为你提供架构背后的“原则”，以便你能够自行决定什么架构适合你自己的应用。所以，本文探讨的是原则，而不是规则。</p>

<blockquote><p>要成为一名优秀的架构师，学习原则，而不是规则。这样，你就可以根据你的软件和团队定制合适的架构。</p></blockquote>

<h2>SOLID 规则</h2>

<p>SOLID 规则是许多架构框架的基础，因此必须完全理解。我不会深入探讨这些规则，因为其他人已经在这方面做得很好。不过，我们先简单回顾一下：</p>

<h3>S = 责任分离</h3>

<p>该原则规定，一个类或模块<em>应该只有一个更改理由</em>。或者说，它应该只对一个<em>参与者</em>负责。这本质上意味着：将那些将单独演进的事物隔离开来。</p>

<h3>O = 开放-封闭</h3>

<p>你的代码应该允许你通过添加代码而不是修改现有代码来添加新功能。</p>

<h3>L = 里氏替换</h3>

<p>以麻省理工学院计算机科学家 Barbara Liskov 的名字命名。该原则规定，你应该能够使用任何派生类来替换基类。最重要的是，在派生基类时，不应尝试更改其含义。</p>

<h3>I = 接口隔离</h3>

<p>不应强迫客户端使用不适合他们的接口。拥有多个包含一两个方法的小型接口，而不是一个大型接口，这并没有什么坏处。</p>

<h3>D = 依赖倒置</h3>

<p>高级类不应依赖于低级类。相反，它们应该都依赖于抽象。</p>

<p>正确应用依赖倒置原则可以正确形成架构边界。让我们更深入地了解其工作原理。</p>

<h2>架构边界和依赖倒置</h2>

<p>假设我们有一个应用允许用户创建和保存个人资料。我们使用 Firebase 来实现这一点。以下是一个简单的实现：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:800/1*qORZctRds2AE60uxiH4w5Q.png" alt="流程图显示 User 类的 saveProfile 方法直接调用 FirebaseProfileSaver 类，这是错误的，因为违反了依赖倒置原则" /></p>

<p>这里，User 类调用了 FirebaseProfileSaver 类中的方法，该方法使用 Firebase 保存个人资料。User 类被称为<em>高级</em>类，因为它包含业务逻辑（即，它是纯逻辑，而不是关于数据如何读写到系统的具体细节）。相比之下，“FirebaseProfileSaver”是一个<em>低级</em>类，之所以这样称呼是因为它包含实现细节，即为特定技术编写的代码。</p>

<p>这种布局违反了依赖倒置原则，因为高级的东西依赖于低级的东西。我所说的依赖，是指严格的源代码含义：在“User”类中，有一行代码写着“import x.y.FirebaseProfileSaver”或类似的代码。也许依赖关系被移除了几层——比如“User”导入了“X”，而“X”又导入了“Y”，而“Y”又导入了“FirebaseProfileSaver”——但关键在于，你可以沿着依赖关系的方向画一组箭头，最终从“User”指向“FirebaseProfileSaver”。</p>

<p>为什么这会是个问题？一个问题是Firebase的变更并不是孤立的。如果Firebase SDK有一天发生了变化，那么显然“FirebaseProfileSaver”也需要随之改变；但没有什么可以阻止这种情况发生，因为它会影响“User”及其依赖的任何内容。测试更改意味着测试所有内容。</p>

<p>而且它也不太灵活。如果我们想从 Firebase 迁移到其他远程存储提供商，我们最终可能不得不重写应用程序的大部分内容。</p>

<h3>依赖倒置：“插头插座”解决方案</h3>

<p>解决方案是将“FirebaseProfileSaver”设置为一种“插头”，将“User”类设置为一种“插座”。“User”类必须对“FirebaseProfileSaver”一无所知；但它可以在抽象中了解保存配置文件的过程。无论我们将什么“插头”插入“User”的“套接字”（可以是“FirebaseProfileSaver”、“RoomDatabaseProfileSaver”或“MyProprietaryAPIProfileSaver”），“套接字”都知道如何与之通信，因为从“套接字”的角度来看，它们的操作方式都相同。</p>

<p>因此，“FirebaseProfileSaver”被重构为适合该套接字的插头。</p>

<p>它看起来像这样：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1000/1*oZXp4UqYwNb2Rhdo2I0_cQ.png" alt="流程图展示了一个 User 类，其中包含一个 saveProfile 方法，它调用了 ProfileSaver 接口上的 saveProfile 方法。另外，FirebaseProfileSaver 类实现了该接口。右图：正确应用了依赖倒置原则" /></p>

<p>这里，<code>User</code> 类只知道如何抽象地与“<code>ProfileSaver</code>”交互。重要的是，它没有提及任何与 Firebase 相关的内容。</p>

<p>然后，<code>FirebaseProfileSaver</code> 实现了 <code>ProfileSaver</code> 接口。<code>User</code> 类对此一无所知，因此，至关重要的是，它的任何逻辑都不基于 Firebase 的工作方式。</p>

<p>这隔离了 Firebase 逻辑。我们可以像上图一样在低级代码和高级代码之间画一条红线。这条红线就是架构边界。</p>

<p>注意依赖关系箭头现在是如何从低级指向高级的。不再存在任何可以遵循的从“User”类开始到 Firebase 结束的依赖箭头序列。</p>

<h2>架构边界应该放在哪里？</h2>

<p>显然，正确设置架构边界对于良好的架构至关重要。从上文来看，边界似乎越多越好——但事实并非如此。</p>

<p>架构边界会带来维护开销。它们会产生更多代码，而且一旦设置了边界，每个未来的开发人员都必须遵守它。</p>

<p>而且，带有边界的代码可读性会大大降低。从上文来看，<code>User</code> 类的 <code>profileSaver.saveProfile()</code> 调用实际上触发了 Firebase 逻辑，这一点并不明显。因此，新开发人员的入职培训会变得更加棘手，代码审查也会更加困难。</p>

<p>整洁架构 (Clean Architecture) 是合理化架构边界的一种尝试。</p>

<h2>Android 应用的整洁架构怎么样？</h2>

<p>整洁架构是由资深架构师 Robert C Martin 整理的一套原则，它在一定程度上提供了一种将软件合理化为一组选定层级的方法，这些层级由架构边界划分。</p>

<p>其著名的图表如下所示：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*iq1PK8t-7rusKw4r" alt="著名的整洁架构图，出自罗伯特·C·马丁的著作《整洁架构》。整洁架构图由一系列同心圆组成。最内圈标记为实体，其次是用例，然后是接口适配器，最外圈是框架和驱动程序" /></p>

<p>这张分层图的中心是高级代码（即纯逻辑），外围是低级代码。它遵循依赖规则（本质上是 SOLID 依赖倒置原则的产物），该规则规定低级代码可以依赖于高级代码，但反过来则不行。因此，上图中表示依赖关系的箭头始终指向内部。</p>

<p>那么，这些层级由什么组成呢？</p>

<h3>用例和实体（黄色和红色圆圈）</h3>

<p>在清晰架构图的正中央，我们可以看到用例层和实体层。它们包含应用的业务逻辑。这些逻辑是控制应用行为的纯逻辑，与具体的实现细节无关。</p>

<p>这种区别可能会造成混淆，因此我们来举个例子。</p>

<p>一个保存用户个人资料的用例会执行以下操作：</p>

<ol>
<li>运行一些安全性/一致性检查。确保正在保存的个人资料包含有效数据，并且用户有权执行此操作。</li>
<li>远程保存数据</li>
<li>在本地缓存新的个人资料</li>
<li>通知 UI 需要更新</li>
</ol>


<p>你可以说这些都是业务逻辑，因为它们与“我们在做什么”有关，而不是“我们如何做”。例如，在步骤 2 中，我们不会说明使用哪个远程 API 来保存数据；在步骤 4 中，我们也不关心要更新的 UI 是 Android 手机屏幕、网页还是 PDF。</p>

<p>一个用例代表来自单个参与者的单一需求（请参阅上文 SOLID 的单一职责原则）。它也是一个完整的步骤列表——你无需执行任何其他操作即可保存配置文件，并且尝试仅运行其中的一部分步骤毫无意义。</p>

<h3>接口适配器（绿色圆圈）</h3>

<p>这是用例细节的体现。例如，当一个用例要求在本地缓存一些数据时，我们可以在这里讨论 SQL 数据库。我们仍然不会讨论特定品牌的 SQL 数据库——任何专有技术都应放在后面讨论。如果有多个数据源，则接口适配器层应该对它们进行整理并管理差异。</p>

<p>几乎所有 MVVM、MVC、MVP 等拓扑结构都应该放在这里。同样，这里不涉及专有技术——所以我们这里不讨论 Jetpack Compose 或 Android XML——但我们确实保存了这些部分将要使用的状态。</p>

<h3>框架和驱动程序（蓝色圆圈）</h3>

<p>所有使用专有技术的内容都放在这里。这些是<em>实现细节</em>。</p>

<p>Jetpack Compose 的 <code>@Composable</code> 代码也放在这里。HTML 代码也放在这里。此外，Firebase 代码、任何 API 的具体细节、SQL 命令以及任何标有 Room 注解（例如 <code>@Entity</code>）的内容也放在这里……</p>

<p>此层的代码很难测试，因为它通常依赖于专有技术。例如，Jetpack Compose 测试依赖于专门为 Jetpack Compose 编写的工具（或者可能是为 Android 编写的工具，但重点依然存在）。因此，请尽可能精简此层。逻辑应该放在更高的层级。这只是将接口适配器的要求“翻译”到你正在使用的特定技术所需的最低限度。</p>

<p>这一层也是<em>易失性的</em>。它可能会在没有你输入的情况下发生变化和中断。例如，如果你正在使用的 API 突然需要不同类型的身份验证，你将不得不修改代码以适应，无论时机是否合适或你是否愿意接受这种变化。同样，尽可能精简这一层可以减少此类更改对代码库其余部分的影响。</p>

<h2>Android 专用代码在 Clean Architecture 中位于何处？</h2>

<p>根据 Clean Architecture 的官方定义，Android 是一项专有技术，因此应将其限制在框架和驱动程序（蓝色）层。任何带有“import android.x.y”或“import androidx.x.y”的代码都不应超出此层。</p>

<p>这在实践中可能非常难以实现。</p>

<p>一个例子是权限请求，有时在视图模型（即接口适配器区域）中提及会更方便（且更具可读性）。</p>

<p>因此，这完美地诠释了为什么我希望本文关注的是“原则”而​​非“规则”。如果你为了遵循某条规则而费尽心思，那么请考虑其背后的原则——它们可能与你的情况相关，也可能不相关。</p>

<p>就此示例而言，我个人认为允许在接口适配器中提及 Android 是可以接受的。毕竟，你正在构建一款 Android 应用，除非你未来有相当大的可能性会与 iOS 或 Web 应用共享完全相同的代码库，否则你没有必要为了避免 Android 而修改代码。显然，iOS 和 Web 应用通常都有各自独立的代码库。</p>

<h2>什么造就了一款优秀的应用？我们如何构建它？</h2>

<p>一款应用应该专注于一件事，并且做好它。它的目的不会随着时间的推移而发生太大变化，尽管它在其生命周期中可能会推出许多新功能，但它的目标受众几乎从未改变（根据单一职责原则，它的角色始终相同）。事实上，如果利益相关者开始要求你的应用迎合其他类型的用户，你通常最好为他们创建一个新的应用，以便更好地满足他们的需求。微软并没有单一的 Office 应用；相反，它有独立的 Word、Excel 和 Powerpoint 应用，每个应用都由不同的用户使用，有着不同的需求。</p>

<p>所以你可能会说，整洁架构（Clean Architecture）——其中许多原则旨在保护你免受 Android 应用中不太可能发生的此类更改的影响——对于我们的目的来说实在太过繁琐。在很多情况下，我同意你的观点。</p>

<p>谷歌似乎也同意这一点。它自己的架构建议——称之为“现代应用架构”（Modern App Architecture）——是整洁架构的一个略微宽松的版本。</p>

<h2>Google 的现代应用架构</h2>

<p>Google 将其架构简化为三层：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:938/1*Y9TFujbKQzLtY1rJynlmSA.png" alt="Google 现代应用架构的拓扑结构：流程图展示了 Google 现代应用架构的三个层级。UI 层指向领域层（标记为可选）。数据层也指向领域层。" /></p>

<p>广义上讲，UI 层用于处理用户的输入和输出，并更新显示内容。领域层用于处理业务逻辑——几乎与 Clean Architecture 的用例完全相同。数据层用于从应用的存储机制读取和写入数据。</p>

<p>这是一种单向架构。状态仅向上流动，事件仅向下流动。</p>

<p>让我们更详细地了解这一切的含义。</p>

<h3>UI 层：UI 元素和状态持有者</h3>

<p><img src="https://miro.medium.com/v2/resize:fit:950/1*81Y6jlUs43MnvwwvBu7zzw.png" alt="现代应用架构的 UI 层：上图中 UI 层的扩展，显示它由 UI 元素和状态持有者组成" /></p>

<p>UI 层分为 UI 元素和状态持有者。</p>

<p>UI 元素部分仅包含为专有技术编写的代码。如果你使用的是 Jetpack Compose，请将你的 @Composable 代码放在此处。如果你使用的是 Fragments 和 XML，那么 @Composable 代码也放在此处。除此之外，没有其他内容。没有逻辑，也没有数据。</p>

<p>（“无逻辑”规则有时对于 XML 数据绑定的用户来说很困难。例如，数据绑定允许你完全在 XML 代码中实现摄氏度/华氏度切换。不要这样做。）</p>

<p>相比之下，逻辑和数据则放在状态持有者中。它们之所以被称为“领域层”，是因为它们保存着 UI 的状态。想想视图控制器。它们包含支持 UI 控件的变量——所以，假设你的 UI 有一个文本字段，那么包含该文本字段内容的变量就放在这里。</p>

<p>一个很好的建议是将这样的状态变量暴露给 Kotlin Flows。这巧妙地封装了它们的动态特性，并提供了一种内置机制来向 UI 发出需要更新的信号。</p>

<h3>领域层：用例</h3>

<p>领域层包含的用例与“清晰架构”中的用例完全相同。也就是说，它是由单个参与者执行单个任务所需步骤的完整列表。</p>

<p>但在 Google 的架构中，这一层是可选的。这意味着将纯业务逻辑放在状态持有者（比如视图模型）中并没有错。</p>

<p>当业务逻辑在多个状态持有者之间重用时，将业务逻辑提取到领域层中可以避免代码重复。比如说，应用程序的多个部分允许更新用户的个人资料；在这种情况下，你可以创建一个 <code>UpdateUserProfileUseCase</code> 并在需要的地方引用它。</p>

<h3>数据层：存储库和数据源</h3>

<p>数据层分为存储库和数据源。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:950/1*gmZwdLcQrrLRkSGnR3PL1w.png" alt="现代应用架构的数据层：现代应用架构图的扩展，显示数据层分为存储库和数据源" /></p>

<p>存储库负责提供数据和保存数据。它包含 <code>getUserProfile()</code> 和 <code>saveUserProfile(…)</code> 方法。</p>

<p>数据源执行专有工作，例如通过调用 API 或编写 SQL 命令。</p>

<p>通常，一个存储库负责多个数据源。例如，你可能将数据存储在远程存储库和相同的本地缓存中。每个存储库都将作为单独的数据源实现。然后，在读取用户个人资料时，存储库可能会尝试从本地缓存读取，如果缓存为空，则回退到远程数据库。这样，负责多个数据源的存储库必须协调使用哪个数据源以及如何同步它们。</p>

<p>再次强调，使用 Kotlin Flows 向调用者提供数据是一种很好的做法。</p>

<h2>比较 Google 的现代应用架构与 Clean Architecture</h2>

<p>你可能已经注意到，现代应用架构和 Clean Architecture 各自使用“层”一词来表示略有不同的含义。以下是它们之间的对应关系：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*9Ds8N-6LZNDNclnZEyX48w.png" alt="现代应用架构如何与 Clean Architecture 相适应：现代应用架构和 Clean Architecture 图表的比较，显示：UI 层与 Clean Architecture 的 UI 和 Presenter 对应（分别位于框架和驱动程序层以及接口适配器层）。领域层与 Clean Architecture 的用例层和实体层对应。数据层与 Clean Architecture 的存储库和 Presenter 对应（分别位于接口适配器层以及框架和驱动程序层）。" /></p>

<p>Google 的 UI 层与其数据层一样，位于 Clean Architecture 的外层两层（接口适配器、框架和驱动程序）。它的领域层完全等同于 Clean Architecture 的用例和实体。</p>

<p>其中一些界限比上图显示的要模糊一些。例如，Google 并不反对你将业务逻辑放置在 UI 层，这就是为什么它自己的领域层被标记为可选的原因。</p>

<p>UI 层和数据层都等同于 Clean Architecture 的接口适配器层和框架/驱动程序层。</p>

<h2>总结……</h2>

<p>本文深入探讨了良好架构背后的原则，并以两种常见范式为灵感：Clean Architecture 和 Google 的现代应用架构。</p>

<p>当然，你需要自行决定哪种架构最适合你的应用程序。我希望通过提供思路而不是僵化的框架，为你提供一个工具包，以便你自行做出决定。</p>

<p>我喜欢回答关于架构的具体问题，所以请随时在这里留下你的答案，我会尽快回复。当没有唯一的“正确”答案，而我们可以进行讨论时，这才是最有趣的。</p>

<p>在以后的文章中，我将使用上述内容逐步指导你使用 Kotlin 和 Compose 创建架构良好的示例应用程序。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面向开发者的系统设计：像建筑师一样思考]]></title>
    <link href="https://alexhilton.github.io/blog/2025/09/24/system-design-for-developers/"/>
    <updated>2025-09-24T22:31:48+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/09/24/system-design-for-developers</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「System Design for Developers: Think Like an Architect」，原文链接<a href="https://towardsdev.com/system-design-for-developers-think-like-an-architect-87f32882ca28">https://towardsdev.com/system-design-for-developers-think-like-an-architect-87f32882ca28</a>，由Saurabh Singh发布于2025年8月25日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/1*b1eSMQdryXSteTJredbMtA.png" title="auto auto" ></a></p>

<!-- more -->


<blockquote><p>“建筑是一种社会行为，也是人类活动的物质舞台。”—— Spiro Kostof</p></blockquote>

<p>正如建筑师不会在没有蓝图的情况下开始建造一样，开发者也不应该在没有系统设计的情况下开始编码。然而，许多开发者直接进入实现阶段，却发现自己陷入了技术债务、性能瓶颈和架构噩梦的迷宫之中，而这些本可以通过适当的规划来避免。</p>

<p>系统设计是一门艺术和科学，它定义系统的架构、组件、模块、接口和数据，以满足特定需求。它就像一座屹立百年的房屋和一座因自身重量而倒塌的房屋之间的区别。</p>

<h2>建筑师的思维方式：分解复杂问题</h2>

<h2>分层思考，而非直线思考</h2>

<p>想象一下，你正在设计一座摩天大楼。你不会先决定第 47 层的墙壁要刷什么颜色。你会先从地基开始，然后是结构框架，接着是电气和管道系统，最后是室内设计。</p>

<p>软件系统也遵循同样的原则。想象一下<strong>可视化页面构建器应用程序</strong>——想想 Webflow、Wix 或 Squarespace 等工具，它们允许用户通过拖放界面创建网页，而无需编写代码。这些系统非常复杂，用户可以：</p>

<ul>
<li>将组件（按钮、图片、文本块）从库拖放到画布上</li>
<li>通过可视化控件自定义属性（颜色、字体、大小）</li>
<li>在构建过程中实时预览页面</li>
<li>将网站直接发布到 Web 上</li>
<li>与团队成员实时协作</li>
</ul>


<p>架构师无需深入研究拖放功能的实现细节，而是首先思考：</p>

<p>基础层：核心实体有哪些？</p>

<p>页面、组件、模板、用户、项目</p>

<p>结构层：这些实体之间如何关联？</p>

<p>用户创建项目
项目包含页面
页面由组件组成
组件可以保存为模板</p>

<p>系统层：它们如何通信？</p>

<ul>
<li>用于 CRUD 操作的 RESTful API</li>
<li>用于实时协作的 WebSocket 连接</li>
<li>用于组件更新的事件驱动架构</li>
</ul>


<p><strong>界面层</strong>：用户如何交互？</p>

<ul>
<li>用于项目管理的仪表盘</li>
<li>用于页面编辑的画布</li>
<li>用于选择的组件库</li>
<li>用于测试的预览模式</li>
</ul>


<p>正如软件工程师 Grady Booch 曾经说过的：“优秀软件的功能在于化繁为简。” 这种分层方法将极其复杂的内容转化为易于管理的模块。</p>

<h2>📝 互动练习：分层架构</h2>

<p><strong>现在就拿起纸笔！</strong>在继续阅读之前，请尝试以下方法：</p>

<ol>
<li><strong>画四个水平矩形</strong>，并将它们叠放在一起</li>
<li><strong>从上到下分别标注</strong>：界面、系统、结构、基础</li>
<li><strong>选择你日常使用的任何应用</strong>（Netflix、Amazon、WhatsApp）</li>
<li><strong>在每一层</strong>中填入你认为应该填入的内容</li>
</ol>


<p>Netflix 示例：_</p>

<ul>
<li>界面：搜索栏、视频播放器、推荐</li>
<li>系统：流媒体服务、推荐引擎、用户身份验证</li>
<li>结构：用户观看电影，电影有评分</li>
<li>基础：用户、电影、评分、订阅</li>
</ul>


<p><strong>为什么要画这个？</strong>你的大脑对你手绘内容的记忆力比你刚刚阅读的内容强 6 倍。这张简单的草图会让你立刻理解文章的其余部分。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:2000/1*k5g3kjh3ugcfUf5CWJjoFw.jpeg" alt="我在重新设计视频平台架构时画了这张草图。产品经理终于明白了为什么我们不能简单地“添加一个功能”——他能看到它会影响到哪个层级。这张图避免了3个月的技术债务！" /></p>

<h2>分解策略</h2>

<p>分解复杂问题就像解剖手表。你需要了解每个齿轮、弹簧和机械装置，然后才能构建或修复整个钟表。</p>

<p><strong>功能分解示例</strong>：可视化页面构建器</p>

<pre><code class="python">Page Builder System
├── Authentication &amp; Authorization
│   ├── User registration/login
│   ├── Role-based permissions
│   └── Session management
├── Project Management
│   ├── Project CRUD operations
│   ├── Version control
│   └── Collaboration features
├── Page Editor
│   ├── Canvas rendering engine
│   ├── Component management
│   ├── Drag-and-drop interface
│   └── Real-time preview
├── Component Library
│   ├── Built-in components
│   ├── Custom components
│   └── Template system
└── Export &amp; Publishing
    ├── Static site generation
    ├── Hosting integration
    └── SEO optimization
</code></pre>

<p>每个分支都可以独立开发、单独测试，并系统地集成。这种方法遵循 Unix 哲学：“专心做好一件事。”</p>

<h2>📝 互动练习：系统分解树</h2>

<p><strong>又该画草图了！</strong> 这个练习可以训练你的“架构师大脑”：</p>

<ol>
<li><strong>画一个树形结构</strong>，以“页面构建器”为根</li>
<li><strong>添加 5 个主要分支</strong>（思考：哪些是大块？）</li>
<li><strong>在每个分支下，添加 2-3 个叶子</strong>（较小的部分）</li>
<li><strong>使用简单的方框和线条</strong>——无需复杂的图表！</li>
</ol>


<p><em>你的绘图可能看起来像：</em></p>

<pre><code class="gherkin">Page Builder
   /

   |

   |

   \
 Auth  Pages  Components  Export
  |

  |

  |

  |
Login  Create   Library   HTML
Signup Edit

Custom

PDF
</code></pre>

<p><strong>神奇时刻</strong>：当你无法进一步分解一个方框时，这可能就是一个开发人员一周的工作。如果觉得方框太大，就进一步分解它！</p>

<h2>可扩展性：今天构建，应对未来的问题</h2>

<h2>成长型思维</h2>

<blockquote><p>“种一棵树的最佳时机是20年前，其次是现在。”——中国谚语</p></blockquote>

<p>可扩展性规划就像为房子选择地基。你可能从一栋小屋开始，但如果你计划扩建成一座豪宅，你就需要一个能够支撑未来发展的地基。</p>

<p>考虑三个可扩展性维度：</p>

<p><strong>垂直扩展（向上扩展）</strong>：就像在建筑物中增加更多楼层</p>

<ul>
<li>增加现有服务器上的 CPU、RAM 或存储空间</li>
<li>简单但存在物理限制</li>
<li>单点故障</li>
</ul>


<p><strong>水平扩展（向外扩展）</strong>：就像在综合体中建造更多建筑物</p>

<ul>
<li>添加更多服务器以分散负载</li>
<li>更复杂但几乎不受限制</li>
<li>更好的容错能力</li>
</ul>


<p><strong>功能扩展</strong>：就像为不同用途建造专用建筑物</p>

<ul>
<li>微服务架构</li>
<li>每个服务处理特定功能</li>
<li>独立扩展和部署</li>
</ul>


<h2>可扩展性的红绿灯系统</h2>

<p><strong>🟢 绿灯决策（第一天）</strong>：</p>

<ul>
<li>简单的单体架构</li>
<li>单一数据库</li>
<li>使用 Redis 进行基本缓存</li>
<li>静态资源的 CDN</li>
</ul>


<p><strong>🟡 黄灯决策（流量增长）</strong>：</p>

<ul>
<li>数据库只读副本</li>
<li>应用服务器集群</li>
<li>API 速率限制</li>
<li>监控和报警系统</li>
</ul>


<p><strong>🔴 红灯决策（高流量）</strong>：</p>

<ul>
<li>微服务架构</li>
<li>数据库分片</li>
<li>用于异步处理的消息队列</li>
<li>自动扩展基础设施</li>
</ul>


<p>对于我们的页面构建器示例，你可以从一个简单的 Python FastAPI 服务器和 PostgreSQL 数据库开始。随着流量的增长，你将引入：</p>

<ol>
<li><strong>缓存层</strong>：用于会话存储和频繁访问的模板的 Redis</li>
<li><strong>CDN</strong>：用于服务组件资源和生成页面的 CloudFront</li>
<li><strong>数据库优化</strong>：用于分析的读取副本，为不同域提供独立的数据库</li>
<li><strong>服务分离</strong>：用于渲染、文件管理和用户管理的专用微服务</li>
</ol>


<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*93OTsJ_L4-7WhICsL2EL4w.jpeg" alt="我绘制产品目标的草图" /></p>

<h2>📝 互动练习：扩展演进</h2>

<p><strong>这张图将成为你的扩展路线图！</strong></p>

<ol>
<li>在你的纸上<strong>画三列</strong>，分别标记为：“第 1 天”、“第 6 个月”、“第 2 年”</li>
<li><p><strong>在每一列中，画出你的架构图：</strong></p></li>
<li><p>第 1 天：画两个方框（前端、API），下方画一个圆柱体（数据库）</p></li>
<li>第 6 个月：添加更多方框（Redis 缓存、CDN 云、负载均衡器）</li>
<li>第 2 年：将 API 方框拆分成多个小方框（用户服务、项目服务等）</li>
</ol>


<p><strong>3. 在各列之间画箭头</strong>，展示演进过程</p>

<p><strong>4. 在每列上方画一些简笔画</strong>，展示用户数量：100 → 1 万 → 100 万</p>

<p><strong>从你的图中得出的关键洞察：</strong>注意复杂性是如何逐渐增长的，而不是一下子增长的。这就是真实系统演进的方式！</p>

<h2>职责三位一体：数据库、API 和前端</h2>

<h2>三层架构理念</h2>

<p>将 Web 应用程序想象成一家餐厅：</p>

<p><strong>前端（餐厅）</strong>：客户互动的地方</p>

<ul>
<li>用户界面和体验</li>
<li>输入验证和格式化</li>
<li>状态管理和路由</li>
</ul>


<p><strong>API（厨房）</strong>：魔法发生的地方</p>

<ul>
<li>业务逻辑处理</li>
<li>数据转换和验证</li>
<li>与外部服务集成</li>
</ul>


<p><strong>数据库（食品储藏室）</strong>：食材存储的地方</p>

<ul>
<li>数据持久化和检索</li>
<li>数据完整性和关系</li>
<li>性能优化</li>
</ul>


<blockquote><p>“好的架构不在于结构本身，而在于它所创造的空间。” — 安藤忠雄</p></blockquote>

<h2>📝 互动练习：餐厅架构</h2>

<p><strong>让我们通过一个绘画练习来具体化这一点：</strong></p>

<ol>
<li><p><strong>绘制一个简单的餐厅平面图</strong>，其中包含三个区域：</p></li>
<li><p>餐厅（顾客就座的地方）</p></li>
<li>厨房（准备食物的地方）</li>
<li>储藏室（存放食材的地方）</li>
</ol>


<p><strong>2. 现在绘制箭头表示数据流向：</strong></p>

<ul>
<li>顾客点餐 → 厨房</li>
<li>厨房索取食材 → 储藏室</li>
<li><p>厨房送出准备好的食物 → 餐厅</p></li>
<li><p><strong>为每个区域标注相应的 Web 对应项：</strong></p></li>
<li><p>餐厅 = 前端</p></li>
<li>厨房 = API</li>
<li>储藏室 = 数据库</li>
</ul>


<p><strong>为什么这样做有效：</strong>现在你的大脑已经对抽象的系统概念有了物理隐喻。每次设计系统时，想象一下这家餐厅的场景！</p>

<h2>职责边界</h2>

<p><strong>数据库职责</strong>：</p>

<pre><code class="python">-- ✅ Good: Database handles data integrity
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);
</code></pre>

<pre><code class="python">-- ✅ Good: Database enforces relationships
CREATE TABLE pages (
    id SERIAL PRIMARY KEY,
    project_id INTEGER REFERENCES projects(id) ON DELETE CASCADE,
    title VARCHAR(255) NOT NULL
);
</code></pre>

<p><strong>API 职责</strong>（Python 和 FastAPI）：</p>

<pre><code class="python"># ✅ Good: API handles business logic
from fastapi import FastAPI, HTTPException, Depends
from pydantic import BaseModel
</code></pre>

<pre><code class="python">app = FastAPI()@app.post("/api/pages")
async def create_page(
    page_data: PageCreateModel,
    current_user: User = Depends(get_current_user)
):
    # Validate user permissions
    if not can_user_edit_project(current_user, page_data.project_id):
        raise HTTPException(status_code=403, detail="Unauthorized")

        # Apply business rules
    page = await create_page_with_defaults(page_data)

    # Return appropriate response
    return {"page": page, "message": "Page created successfully"}
</code></pre>

<p><strong>前端职责</strong>（Angular）：</p>

<pre><code class="javascript">// ✅ Good: Frontend handles user interaction
@Component({
  selector: 'app-page-editor',
  templateUrl: './page-editor.component.html'
})
export class PageEditorComponent {
  components: Component[] = [];
  isLoading = false;

  constructor(private apiService: ApiService) {}

  // Handle user interactions
  onComponentDrop(component: Component, position: Position): void {
    this.isLoading = true;

    this.apiService.addComponent(component, position)
      .subscribe({
        next: (result) =&gt; this.updateComponents(result),
        error: (error) =&gt; this.handleError(error),
        complete: () =&gt; this.isLoading = false
      });
  }
}
</code></pre>

<h2>架构模式：伟大系统的基石</h2>

<h2>模型-视图-控制器 (MVC)：经典模式</h2>

<p>MVC 就像组织一场戏剧演出：</p>

<ul>
<li><strong>模型</strong>：剧本和故事（数据和业务逻辑）</li>
<li><strong>视图</strong>：舞台和演员（用户界面）</li>
<li><strong>控制器</strong>：导演（模型和（查看）</li>
</ul>


<pre><code class="coffeescript"># Model: Page data and operations
from sqlalchemy import Column, Integer, String, JSON
from sqlalchemy.ext.declarative import declarative_base
</code></pre>

<pre><code class="python">Base = declarative_base()class PageModel(Base):
    __tablename__ = "pages"

    id = Column(Integer, primary_key=True)
    title = Column(String(255), nullable=False)
    components = Column(JSON)
    project_id = Column(Integer, nullable=False)

    async def save(self, db_session):
        db_session.add(self)
        await db_session.commit()
        return self
</code></pre>

<pre><code class="coffeescript">// View: Page rendering (Angular Component)
@Component({
  selector: 'app-page-view',
  template: `
    &lt;div class="page"&gt;
      &lt;h1&gt;&lt;/h1&gt;
      &lt;app-component 
        *ngFor="let component of pageModel.components"
        [componentData]="component"&gt;
      &lt;/app-component&gt;
    &lt;/div&gt;
  `
})
export class PageViewComponent {
  @Input() pageModel: PageModel;
}
</code></pre>

<pre><code class="javascript">// Controller: Coordination logic (Angular Service)
@Injectable({
  providedIn: 'root'
})
export class PageController {
  constructor(private apiService: ApiService) {}

  async updateTitle(pageId: number, newTitle: string): Promise&lt;void&gt; {
    const updatedPage = await this.apiService.updatePage(pageId, { title: newTitle });
    // Emit event to refresh view
    this.pageUpdated.emit(updatedPage);
  }
}
</code></pre>

<h2>事件驱动架构：神经系统</h2>

<p>事件驱动架构就像人类的神经系统——当某个部分发生事件时，其他部分会自动做出反应。</p>

<pre><code class="python"># Event system for page builder
from typing import Dict, List, Callable
import asyncio
</code></pre>

<pre><code class="python">class EventBus:
    def __init__(self):
        self.listeners: Dict[str, List[Callable]] = {}

        def on(self, event: str, callback: Callable):
        if event not in self.listeners:
            self.listeners[event] = []
        self.listeners[event].append(callback)

        async def emit(self, event: str, data: dict):
        callbacks = self.listeners.get(event, [])
        await asyncio.gather(*[callback(data) for callback in callbacks])# Usage
event_bus = EventBus()# Auto-save feature
@event_bus.on('component:added')
async def auto_save_handler(data):
    await auto_save(data['page_id'])
    await show_save_indicator()# Analytics tracking
@event_bus.on('component:added')
async def analytics_handler(data):
    analytics.track('Component Added', {
        'component_type': data['component']['type'],
        'page_id': data['page_id']
    })
</code></pre>

<h2>微服务：专业团队</h2>

<p>微服务就像一个爵士乐团——每个音乐家（服务）都是各自乐器的专家，但他们共同努力，创造出美妙的音乐。</p>

<pre><code class="bash"># Docker Compose for Page Builder Microservices
version: '3.8'
services:
  user-service:
    image: pagebuilder/user-service:python
    environment:
      - DATABASE_URL=postgresql://users_db
      - REDIS_URL=redis://redis:6379
    ports:
      - "8001:8000"

      project-service:
    image: pagebuilder/project-service:python
    environment:
      - DATABASE_URL=postgresql://projects_db
    ports:
      - "8002:8000"

      rendering-service:
    image: pagebuilder/rendering-service:python
    environment:
      - REDIS_URL=redis://redis:6379
      - S3_BUCKET=pagebuilder-assets
    ports:
      - "8003:8000"

      frontend:
    image: pagebuilder/angular-frontend
    ports:
      - "4200:80"
    environment:
      - API_GATEWAY_URL=http://api-gateway:8080

      api-gateway:
    image: pagebuilder/api-gateway:python
    environment:
      - USER_SERVICE_URL=http://user-service:8000
      - PROJECT_SERVICE_URL=http://project-service:8000
      - RENDERING_SERVICE_URL=http://rendering-service:8000
    ports:
      - "8080:8000"
</code></pre>

<h2>何时使用每种模式</h2>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*Kx0t7cKSgdtO0Q1PpRiLXg.jpeg" alt="这是我在一次架构评审会上画的草图，当时团队就各种模式争论了两个小时。这张图在5分钟内就结束了这场争论——每个人都清楚地看到了他们的项目与一个模式的对应关系。现在，我把这张照片保存在手机里，每次架构讨论时都会拿出来用。" /></p>

<p><strong>在以下情况下使用 MVC</strong>：</p>

<ul>
<li>构建传统 Web 应用程序</li>
<li>团队熟悉该模式</li>
<li>需要清晰的关注点分离</li>
</ul>


<p><strong>在以下情况下使用事件驱动</strong>：</p>

<ul>
<li>实时功能很重要</li>
<li>需要多个系统响应变化</li>
<li>需要松散耦合</li>
</ul>


<p><strong>在以下情况下使用微服务</strong>：</p>

<ul>
<li>团队规模 > 10 名开发人员</li>
<li>不同部分的扩展能力不同</li>
<li>独立部署至关重要</li>
</ul>


<p>正如 Martin Fowler 所言：“傻瓜也能写出计算机能理解的代码。优秀的程序员写出人类能理解的代码。”</p>

<h2>📝 互动练习：架构模式比较</h2>

<p><strong>创建你的个人架构模式速查表：</strong></p>

<ol>
<li>在你的纸上<strong>画出三个部分</strong>：“MVC”、“事件驱动”、“微服务”</li>
<li><p><strong>对于 MVC：</strong>画出三个相连的方框（模型 ↔ 控制器 ↔ 视图）</p></li>
<li><p>在下面写上：“适合：传统应用，清晰的分离”</p></li>
</ol>


<p><strong>3.对于事件驱动：</strong> 画一个中心圆圈，标记为“事件总线”，并用箭头向外辐射到多个方框。</p>

<ol>
<li>在下面写：“适用于：实时功能，松耦合”</li>
</ol>


<p><strong>5. 对于微服务：</strong> 画 6-8 个独立的小方框，并用虚线连接它们。</p>

<ul>
<li>在下面写：“适用于：大型团队，独立扩展”</li>
</ul>


<p><strong>6. 添加决策树：</strong> 从问题到模式画箭头：</p>

<ul>
<li>“团队少于 5 人？” → MVC</li>
<li>“需要实时功能吗？” → 事件驱动</li>
<li>“多个团队？” → 微服务</li>
</ul>


<p><strong> 将此图放在手边！</strong> 这是你未来任何项目的架构决策流程图。</p>

<h2>绘制真正有用的系统图</h2>

<h2>视觉传达的艺术</h2>

<blockquote><p>“一图胜千言，但一张好的图表胜过千次会议。” — 未知</p></blockquote>

<p>系统图是软件架构的蓝图。它们应该讲述一个故事，而不是制造混乱。</p>

<h2>📝 互动练习：图表层次结构</h2>

<p><strong>练习三层系统图绘制方法：</strong></p>

<p><strong>第一层 - 上下文（30 秒绘制）：</strong></p>

<ol>
<li><strong>绘制三个形状</strong>：圆形（用户）、矩形（你的系统）、云（外部服务）</li>
<li><strong>用带标签的箭头连接</strong>：“HTTP 请求”、“API 调用”、“数据同步”</li>
<li><strong>这回答了</strong>“我们的系统连接到什么？”</li>
</ol>


<p><strong>第二层 - 容器（2 分钟绘制）：</strong></p>

<ol>
<li><strong>将系统矩形分成四个部分</strong>：前端、API 网关、服务、数据库</li>
<li><strong>用箭头</strong>显示它们之间的数据流**</li>
<li><strong>这回答了</strong>“主要部分是什么？”</li>
</ol>


<p><strong>第三级——组件（5 分钟绘制）：</strong></p>

<ol>
<li><strong>选择一个容器（例如前端）并将其分解</strong>为模块</li>
<li><strong>展示模块如何在该容器内交互</strong></li>
<li><strong>这将回答</strong>“这个组件内部是如何工作的？”</li>
</ol>


<p><strong>本练习的强大之处：</strong>只需选择要绘制的图纸，即可在任何细节层面解释任何系统！</p>

<h2>图表的层次结构</h2>

<p><strong>上下文图</strong>：30,000 英尺的视角</p>

<pre><code class="inform7">[Users] --&gt; [Page Builder System] --&gt; [CDN]
           |
           v
      [Database]
</code></pre>

<p><strong>容器图</strong>：构建模块</p>

<pre><code class="inform7">[Web Browser] --&gt; [Load Balancer] --&gt; [Web Application]
                                         |
                                         v
[File Storage] &lt;-- [API Gateway] &lt;-- [Cache Layer]
                        |
                        v
                   [Database Cluster]
</code></pre>

<p><strong>组件图</strong>：内部结构</p>

<pre><code class="mathematica">Web Application:
├── Authentication Module
├── Project Management Module
├── Page Editor Module
│   ├── Canvas Component
│   ├── Toolbar Component
│   └── Properties Panel
├── Component Library Module
└── Export Module
</code></pre>

<h2>有效的图表绘制原则</h2>

<ol>
<li><strong>从用户旅程开始</strong>：每个图表都应该回答“数据如何从用户操作流向结果？”</li>
<li><strong>使用一致的符号</strong>：矩形表示进程，圆柱体表示数据存储，圆形表示外部实体</li>
<li><strong>清晰地显示关系</strong>：箭头应指示数据流方向并进行标记</li>
<li><strong>分层图表</strong>：从高层开始，然后放大到特定区域</li>
<li><strong>包含不愉快的路径</strong>：显示错误处理和故障场景</li>
</ol>


<h2>整合：可视化页面构建器案例研究</h2>

<p>让我们为我们的可视化页面构建器设计一个完整的系统架构：</p>

<h2>高层架构</h2>

<pre><code class="coq">Frontend (Angular)
├── Editor Canvas Module
├── Component Library Module  
├── Project Dashboard Module
└── Shared Services
</code></pre>

<pre><code class="scss">API Gateway (Python/FastAPI)
├── Authentication Service
├── Project Service
├── Component Service
└── Rendering ServiceData Layer
├── PostgreSQL (structured data)
├── Redis (caching)
└── S3 (file storage)Infrastructure
├── CDN (CloudFront)
├── Load Balancer
└── Auto-scaling Groups
</code></pre>

<h2>组件添加的数据流</h2>

<ol>
<li><strong>用户操作</strong>：将组件从库拖到画布</li>
<li><strong>前端</strong>：验证位置，发送 API 请求</li>
<li><strong>API 网关</strong>：验证请求，路由到组件服务</li>
<li><strong>组件服务</strong>：验证业务规则，更新数据库</li>
<li><strong>事件总线</strong>：发出“component_added”事件</li>
<li><strong>渲染服务</strong>：生成更新后的页面预览</li>
<li><strong>WebSocket</strong>：通知其他协作者</li>
<li><strong>前端</strong>：使用新组件更新 UI</li>
</ol>


<h2>📝 互动练习：数据流映射</h2>

<p><strong>将这个抽象的流程转化为一个可视化的故事：</strong></p>

<ol>
<li><strong>在一个流程中画出 8 个方框</strong>（每个方框对应上面的每个步骤）</li>
<li><strong>用箭头连接它们</strong>以显示顺序</li>
<li><strong>在每个方框上方写出所需时间</strong>：“50 毫秒”、“200 毫秒”、“100 毫秒”等。</li>
<li><strong>在每个方框下方，注明可能出现的问题</strong>：“网络超时”、“身份验证失败”、“数据库宕机”</li>
<li><p><strong>现在画出第二个版本</strong>，展示步骤 4 失败时会发生什么：</p></li>
<li><p>用红色虚线画一条“悲伤的路径”箭头</p></li>
<li>显示返回给用户的错误消息</li>
<li>添加重试逻辑和回退选项</li>
</ol>


<p><strong>本练习将教会你：</strong>每个用户操作实际上都是一个复杂的系统编排。绘制箭头可以帮助你在生产环境中发生潜在故障之前发现它们！</p>

<p><strong>额外提示：</strong> 为箭头添加颜色代码——绿色代表正常路径，红色代表错误，蓝色代表重试。</p>

<h2>可扩展性考虑因素</h2>

<p><strong>流量模式</strong>：</p>

<ul>
<li>高读取操作（浏览页面）</li>
<li>突发写入操作（编辑会话）</li>
<li>大文件上传（图片、资源）</li>
</ul>


<p><strong>扩展策略</strong>：</p>

<ul>
<li>将渲染后的页面缓存在 CDN 中</li>
<li>使用只读副本进行页面浏览</li>
<li>将大文件处理排队</li>
<li>实现 WebSocket 连接池</li>
</ul>


<h2>要点：适用于任何 Web 应用程序的原则</h2>

<h2>系统设计的黄金法则</h2>

<ol>
<li><strong>从简单开始，规划复杂</strong>：从单体应用开始，但要针对微服务进行设计</li>
<li><strong>快速失败，快速学习</strong>：从第一天开始构建监控和报警功能</li>
<li><strong>数据为王</strong>：先设计数据模型，其他一切都水到渠成</li>
<li><strong>安全性不可或缺</strong>：在每一层都构建身份验证和授权机制</li>
<li><strong>性能是关键特性</strong>：用户更容易注意到应用程序运行缓慢，而不是功能缺失</li>
</ol>


<h2>架构清单</h2>

<p>在编写第一行代码之前编写代码时，请问自己：</p>

<ul>
<li>[ ] 核心实体及其关系是什么？</li>
<li>[ ] 该系统如何处理 10 倍于当前流量的情况？</li>
<li>[ ] 单点故障点在哪里？</li>
<li>[ ] 不同的团队将如何在该系统上协作？</li>
<li>[ ] 出现问题时会发生什么？</li>
<li>[ ] 我们将如何监控和调试问题？</li>
<li>[ ] 安全隐患是什么？</li>
</ul>


<h2>📝 互动练习：你的系统设计模板</h2>

<p><strong>创建你的个人系统设计模板，可用于任何项目：</strong></p>

<ol>
<li><strong>绘制一个包含以下部分的空白模板：</strong></li>
</ol>


<pre><code class="bash">┌────── 实体与关系 ────────┐ ┌───── 流量与扩展 ─────┐  │ │ │ │ │ │ │ 
└────────────────────────┘ └────────────────────┘ ┌─ 故障点 ──────
─────┐ ┌──── 团队边界 ────┐ │ │ │ │ │ │ 
└─────────────────────┘ └──────────────────────┘
</code></pre>

<ol>
<li><p><strong>填写我们的页面构建器示例：</strong></p></li>
<li><p>实体：用户、项目、页面、组件</p></li>
<li>流量：浏览时读取量大，编辑时写入量大</li>
<li>故障：数据库宕机、CDN 速度慢、WebSocket 断开连接</li>
<li>团队：前端团队、API 团队、基础设施团队</li>
</ol>


<p><strong>2. 复制此模板</strong> — 将其用于未来的每个项目</p>

<p><strong>为什么有效：</strong> 拥有一致的思维框架可以防止你忘记关键方面。你的绘图将成为你的系统设计清单！</p>

<h2>你的绘图之旅：从草图到系统</h2>

<p>如果你完成了本文的绘图练习，那么你现在拥有：</p>

<ol>
<li><strong>分层架构模板</strong>（用于分解任何复杂系统）</li>
<li><strong>分解树方法</strong>（用于组织开发工作）</li>
<li><strong>扩展演进路线图</strong>（用于规划发展阶段）</li>
<li><strong>餐厅隐喻图</strong>（用于解释三层架构）</li>
<li><strong>架构模式对比图</strong>（用于选择正确的方法）</li>
<li><strong>三层图表系统</strong>（用于在任何细节层面进行沟通）</li>
<li><strong>数据流映射技术</strong>（用于理解系统交互）</li>
<li><strong>可复用系统设计模板</strong>（用于一致的项目规划）</li>
</ol>


<p><strong>这些手绘图表比任何昂贵的工具都更有价值</strong>，因为：</p>

<ul>
<li>通过绘制它们，你的大脑建立了更深层次的联系</li>
<li>你可以随时随地重新创建它们</li>
<li>它们根据你对系统的理解进行个性化定制</li>
<li>它们弥合了抽象概念与实践之间的差距实施</li>
</ul>


<p><strong>保留你的图纸！</strong> 把它们贴在你的显示器上，用手机拍照，或者创建一个“系统设计速写本”，让它随着每个项目的进展而不断更新。</p>

<h2>总结</h2>

<blockquote><p>“架构师身处两个世界之间。你必须愿意打破基本的假设。”——安藤忠雄</p></blockquote>

<p>系统设计并非要创造完美的架构，而是要做出明智的权衡。每个决策都有其后果，每个模式都有其利弊，每个解决方案都会产生新的问题需要解决。</p>

<p>最好的架构师并非精通所有模式和技术，而是能够倾听需求、理解约束，并设计出能够与用户和组织和谐共存的系统。</p>

<p>记住：你不仅仅是在构建软件，你还在为团队未来的成功奠定基础。构建好它，清晰地记录它，并始终做好演进的准备。</p>

<p>俗话说，“几周的编码时间可以节省数小时的规划时间。” 投资于系统设计，未来的你（和团队）会感谢你。</p>

<p>千个应用程序的旅程始于一个精心设计的系统。今天就开始像架构师一样思考，见证你的应用程序从脆弱的原型转变为经得起时间考验的强大、可扩展的平台。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android ViewModel数据加载：基于Flow架构的最佳实践]]></title>
    <link href="https://alexhilton.github.io/blog/2025/09/22/viewmodel-loading/"/>
    <updated>2025-09-22T22:50:00+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/09/22/viewmodel-loading</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Android ViewModel Data Loading: Best Practices and Flow-Based Architecture」，原文链接<a href="https://funkymuse.dev/posts/properly-load-data/">https://funkymuse.dev/posts/properly-load-data/</a>，由FunkyMuse于2025年8月29日。</p></blockquote>

<p>Android 开发中的架构讨论经常引发激烈的争论——有时褒贬不一。撰写这些主题的文章并不容易，但这正是它的价值所在。</p>

<p>本文阐述了我对数据加载模式的独到见解，这些见解源于我的经验以及近期手术后的恢复（其中一次手术仍在进行中）。</p>

<p>不妨将此视为我在 2025 年对数据加载模式的理解和技能的概述。</p>

<p>我可能比其他人更晚加入这场讨论，但迟做总比不做好。</p>

<h2>挑战：Android ViewModel 中常见的数据加载反模式</h2>

<p>“大多数”Android 开发者使用 ViewModel 来管理 UI 状态，这些状态由视图（Fragment、Activity 或可组合组件）收集。为了显示有意义的内容，你需要从真实数据源加载数据，将其转换为视图状态，然后公开以供使用。</p>

<p>以前是 LiveData，现在是 Flow，它充当视图和 ViewModel 之间的粘合剂（大多数情况下）。有一些解决方案使用 <a href="https://github.com/cashapp/molecule">molecule</a>，但这超出了我们的讨论范围。</p>

<p><a href=""><img src="https://funkymuse.dev/assets/img/load_data/zhui.png" title="auto auto" ></a></p>

<!-- more -->


<p>正如这篇 <a href="https://x.com/github_skydoves/status/1829315087611707848">Twitter 讨论</a> 所示，大多数开发者在 <code>ViewModel</code> 的 init {} 块中加载数据。虽然这种方法看似合乎逻辑，但它带来了一些架构问题，Ian Lake 和其他人认为这是反模式——包括使用 <code>LaunchedEffect</code> 进行数据加载。</p>

<p><a href="https://funkymuse.dev/assets/img/load_data/jokes.png"><img src="https://funkymuse.dev/assets/img/load_data/jokes.png" alt="Irony" /></a></p>

<p>讽刺的是，即使是官方示例有时也会与这些最佳做法相矛盾：</p>

<p><a href="https://funkymuse.dev/assets/img/load_data/irony.png"><img src="https://funkymuse.dev/assets/img/load_data/irony.png" alt="Irony" /></a></p>

<h3>开发者为何选择 init {} 块（以及它为何存在问题）</h3>

<p>ViewModel 的 init {} 块的吸引力显而易见——它确保数据加载在配置更改后依然有效，从而避免了不必要的 API 调用或数据库读取。然而，这种方法也带来了四个关键问题：</p>

<h4>问题 1：导航返回栈复杂化</h4>

<p>使用 init {} 进行数据加载时，返回到包含现有 ViewModel 的屏幕不会触发重新初始化。这迫使开发者在 onStart 或 onResume 中添加变通逻辑来检查数据新鲜度，从而创建难以维护的意大利面条式代码。</p>

<h4>问题 2：调度程序竞争条件</h4>

<p>在 init {} 中加载数据通常使用 viewModelScope，它在 Dispatchers.Main.immediate 上运行。这种即时调度程序可能会导致竞争条件，即数据处理在 UI 组合之前就已完成，尤其是在 Jetpack Compose 应用中。</p>

<p><a href="https://funkymuse.dev/assets/img/load_data/darkness.png"><img src="https://funkymuse.dev/assets/img/load_data/darkness.png" alt="Darkness" /></a></p>

<h4>问题 #3：数据过期问题</h4>

<p>现代 CRUD 应用程序需要更新数据。用户可能会从其他屏幕返回，或者在相当长一段时间后从暂停状态恢复。<code>init {}</code> 方法没有提供内置的数据新鲜度验证机制。</p>

<h4>问题 #4：测试困难</h4>

<p>每次运行测试时，你都必须构建 ViewModel 才能成功运行该特定测试用例的 <code>init {}</code> 代码块。</p>

<h2>基于 Flow 的解决方案：将冷流转换为热流</h2>

<p>该解决方案利用 Kotlin Flows——具体来说，使用 StateFlow 和适当的共享策略将冷流转换为热流。可以将其视为 Katy Perry 的“Hot N Cold”方法，但所有边缘情况的行为都是可预测的。</p>

<h3>构建基础：用例和 ViewModel 结构</h3>

<p><strong>请注意，此代码仅用于演示目的，如何构建由你决定，除加载部分外，并非最佳实践</strong></p>

<pre><code class="kotlin">inline fun &lt;reified T : ViewModel&gt; provideFactory(
    crossinline creator: () -&gt; T
) = viewModelFactory {
    initializer {
        creator()
    }
}
</code></pre>

<p><em>注意：此工厂模式仅用于演示目的</em></p>

<p>我们的用例处理数据检索、格式化和业务逻辑转换：</p>

<pre><code class="kotlin">class GetUserDetailsUseCase private constructor(
    private val authRepository: AuthRepository = AuthRepository(),
    private val dispatcher: CoroutineDispatcher = Dispatchers.IO,
    private val billingCache: BillingCache = BillingCache.create(),
    private val dateFormatter: DateFormatter = DataFormatter()
) {
    suspend fun execute(): Result&lt;UserDetails&gt; =
        withContext(dispatcher) {
            val userDetails: Result&lt;UserDetailsResponseModel&gt; = authRepository.getUserDetails()

            userDetails.map { details -&gt;
                UserDetails(
                    creationDate = dateFormatter.format(
                        details.creationDate,
                        DateFormatter.Format.UTC_SHORT
                    ).getOrNull(),
                    avatarUrl = details.avatar,
                    isPremium = billingCache.isPremium(),
                    email = details.email
                )
            }
        }

    companion object {
        fun create() = GetUserDetailsUseCase()
    }
}
</code></pre>

<p>此用例封装了从存储库检索数据、日期格式化、高级状态验证以及准备用户信息以供显示。</p>

<pre><code class="kotlin">internal class UserAccountDetailsViewModel private constructor(
    private val getUserDetailsUseCase: GetUserDetailsUseCase = GetUserDetailsUseCase.create(),
) : ViewModel() {
    data class ViewState(
        val isLoading: Boolean = false,
        val isError: Boolean = false,
        val userInfo: UserInfo? = null
    ) {
        data class UserInfo(
            val displayEmail: String,
            val avatarUrl: String?,
            val showPremiumBadge: Boolean,
            val memberSince: String?
        )
    }

    val userDetails: Flow&lt;ViewState&gt; = flow {
        emit(
            getUserDetailsUseCase.execute()
                .fold(
                    onSuccess = {
                        ViewState(
                            isLoading = false,
                            isError = false,
                            userInfo = ViewState.UserInfo(
                                displayEmail = it.email,
                                avatarUrl = it.avatarUrl,
                                showPremiumBadge = it.isPremium,
                                memberSince = it.creationDate?.toString()
                            )
                        )
                    },

                    onFailure = {
                        ViewState(isLoading = false, isError = true)
                    }
                )
        )
    }.stateIn(
        viewModelScope,
        SharingStarted.WhileSubscribed(5_000),
        ViewState(isLoading = true, isError = false)
    )

    companion object {
        fun factory() = provideFactory { UserAccountDetailsViewModel() }
    }
}
</code></pre>

<p>这种方法有几个关键优势：</p>

<ul>
<li><strong>数据新鲜度</strong>：5 秒超时时间与 Android 的 ANR 阈值一致，确保在超时后收集器重新出现时数据能够刷新。</li>
<li><strong>配置变更处理</strong>：在超时窗口内，即使配置发生变化，数据也能持久保存。</li>
<li><strong>资源效率</strong>：避免不必要的网络调用，以实现快速导航模式。</li>
</ul>


<p><em>专业提示：对于需要实时数据新鲜度的应用程序，请将超时时间设置为 0</em></p>

<h3>添加用户交互：实现刷新功能</h3>

<p>实际应用程序需要用户主动发起的数据刷新功能。产品经理喜欢滑动刷新，但我们的基本流程无法适应这种模式。让我们来增强我们的架构：</p>

<p>我们使用在主流程收集器中触发的 <code>MutableSharedFlow</code> 来实现这一点：</p>

<pre><code class="kotlin">internal class UserAccountDetailsViewModel private constructor(
    private val getUserDetailsUseCase: GetUserDetailsUseCase = GetUserDetailsUseCase.create(),
) : ViewModel(), IntentAware&lt;UserAccountDetailsViewModel.ViewState.Intents&gt; {
    data class ViewState(
        val isLoading: Boolean = false,
        val isError: Boolean = false,
        val userInfo: UserInfo? = null
    ) {
        data class UserInfo(
            val displayEmail: String,
            val avatarUrl: String?,
            val showPremiumBadge: Boolean,
            val memberSince: String?
        )

        sealed class Intents {
            data object Refresh : Intents()
        }
    }

    private val refreshListener = MutableSharedFlow&lt;Unit&gt;()

    val userDetails: Flow&lt;ViewState&gt; = flow {
        emit(getUserDetailsState())
        refreshListener.collect {
            emit(ViewState(isLoading = true, isError = false))
            emit(getUserDetailsState())
        }
    }.stateIn(
        viewModelScope,
        SharingStarted.WhileSubscribed(5_000),
        ViewState(isLoading = true, isError = false)
    )

    private suspend fun getUserDetailsState(): ViewState = getUserDetailsUseCase.execute()
        .fold(
            onSuccess = {
                ViewState(
                    isLoading = false,
                    isError = false,
                    userInfo = ViewState.UserInfo(
                        displayEmail = it.email,
                        avatarUrl = it.avatarUrl,
                        showPremiumBadge = it.isPremium,
                        memberSince = it.creationDate?.toString()
                    )
                )
            },

            onFailure = {
                ViewState(isLoading = false, isError = true)
            }
        )

    override fun onIntent(intent: ViewState.Intents) {
        when (intent) {
            ViewState.Intents.Refresh -&gt; {
                viewModelScope.launch {
                    refreshListener.emit(Unit)
                }
            }
        }
    }

    companion object {
        fun factory() = provideFactory { UserAccountDetailsViewModel() }
    }
}
</code></pre>

<p>完美！我们成功重构了重复的数据加载逻辑，并实现了刷新功能。然而，这还不算完。</p>

<h3>优化状态管理：消除冗余状态输出</h3>

<p>为了避免不必要的 UI 更新，我们将添加 <code>distinctUntilChanged()</code> 来过滤重复的状态输出。</p>

<h3>处理复杂的状态更新</h3>

<p>对于意图修改 UI 状态而不需要重新加载数据的场景，我们需要在流程操作中访问当前状态。例如，切换电子邮件可见性——这需要修改状态而不是重新加载数据。</p>

<pre><code class="kotlin">data class ViewState(
    val isLoading: Boolean = false,
    val isError: Boolean = false,
    val isEmailVisible: Boolean = false,
    val userInfo: UserInfo? = null
) {
    data class UserInfo(
        val displayEmail: String,
        val avatarUrl: String?,
        val showPremiumBadge: Boolean,
        val memberSince: String?
    )

    sealed class Intents {

        data object Refresh : Intents()
        data class ToggleEmailVisibility(val isEmailVisible: Boolean) : Intents()
    }

    sealed class StateParameters {
        data class EmailVisibilityChanged(val isEmailVisible: Boolean) : StateParameters()
        data object Refresh : StateParameters()
    }
}

private val refreshListener = MutableSharedFlow&lt;ViewState.StateParameters&gt;()

val userDetails: Flow&lt;ViewState&gt; = flow {
    emit(getUserDetailsState())

    refreshListener.collect { refreshParams -&gt;
        when (refreshParams) {
            is ViewState.StateParameters.EmailVisibilityChanged -&gt; {
                //do some changes here
            }

            ViewState.StateParameters.Refresh -&gt; {
                emit(ViewState(isLoading = true, isError = false))
                emit(getUserDetailsState())
            }
        }
    }
}
    .distinctUntilChanged()
    .stateIn(
        viewModelScope,
        SharingStarted.WhileSubscribed(5_000),
        ViewState(isLoading = true, isError = false)
    )
</code></pre>

<p>这里的挑战在于如何在流程中访问当前状态。让我们通过内部跟踪状态来解决这个问题：</p>

<pre><code class="kotlin">internal class UserAccountDetailsViewModel private constructor(
    private val getUserDetailsUseCase: GetUserDetailsUseCase = GetUserDetailsUseCase.create(),
) : ViewModel(), IntentAware&lt;UserAccountDetailsViewModel.ViewState.Intents&gt; {
    data class ViewState(
        val isLoading: Boolean = false,
        val isError: Boolean = false,
        val isEmailVisible: Boolean = false,
        val userInfo: UserInfo? = null
    ) {
        data class UserInfo(
            val displayEmail: String,
            val avatarUrl: String?,
            val showPremiumBadge: Boolean,
            val memberSince: String?
        )

        sealed class Intents {
            data object Refresh : Intents()
            data class ToggleEmailVisibility(val isEmailVisible: Boolean) : Intents()
        }

        sealed class StateTriggers {
            data class EmailVisibilityChanged(val isEmailVisible: Boolean) : StateTriggers()
            data object Refresh : StateTriggers()
        }
    }

    private var currentState = ViewState(isLoading = true, isError = false)

    private val refreshListener = MutableSharedFlow&lt;ViewState.StateTriggers&gt;()

    val userDetails: Flow&lt;ViewState&gt; = flow {
        emit(getUserDetailsState())

        refreshListener.collect { refreshParams -&gt;
            when (refreshParams) {
                is ViewState.StateTriggers.EmailVisibilityChanged -&gt; {
                    emit(currentState.copy(isEmailVisible = refreshParams.isEmailVisible))
                }
                ViewState.StateTriggers.Refresh -&gt; {
                    emit(ViewState(isLoading = true, isError = false))
                    emit(getUserDetailsState())
                }
            }
        }
    }
        .distinctUntilChanged()
        .onEach {
            currentState = it
        }
        .stateIn(
            viewModelScope,
            SharingStarted.WhileSubscribed(5_000),
            currentState
        )

    private suspend fun getUserDetailsState(): ViewState = getUserDetailsUseCase.execute()
        .fold(
            onSuccess = {
                ViewState(
                    isLoading = false,
                    isError = false,
                    userInfo = ViewState.UserInfo(
                        displayEmail = it.email,
                        avatarUrl = it.avatarUrl,
                        showPremiumBadge = it.isPremium,
                        memberSince = it.creationDate?.toString()
                    )
                )
            },

            onFailure = {
                ViewState(isLoading = false, isError = true)
            }
        )

    override fun onIntent(intent: ViewState.Intents) {
        when (intent) {
            ViewState.Intents.Refresh -&gt; {
                viewModelScope.launch {
                    refreshListener.emit(ViewState.StateTriggers.Refresh)
                }
            }

            is ViewState.Intents.ToggleEmailVisibility -&gt; {
                viewModelScope.launch {
                    refreshListener.emit(ViewState.StateTriggers.EmailVisibilityChanged(intent.isEmailVisible))
                }
            }
        }
    }

    companion object {
        fun factory() = provideFactory { UserAccountDetailsViewModel() }
    }
}
</code></pre>

<h3>智能数据缓存：条件加载策略</h3>

<p>现在我们可以实现复杂的缓存行为了。由于 <code>currentState</code> 在 ViewModel 生命周期内持续存在，我们可以立即发出缓存数据，并仅在必要时有条件地加载新数据：</p>

<pre><code class="kotlin">internal class UserAccountDetailsViewModel private constructor(
    private val getUserDetailsUseCase: GetUserDetailsUseCase = GetUserDetailsUseCase.create(),
) : ViewModel(), IntentAware&lt;UserAccountDetailsViewModel.ViewState.Intents&gt; {
    data class ViewState(
        val isLoading: Boolean = false,
        val isError: Boolean = false,
        val isEmailVisible: Boolean = false,
        val userInfo: UserInfo? = null
    ) {
        val isDataLoaded get() = userInfo != null

        data class UserInfo(
            val displayEmail: String,
            val avatarUrl: String?,
            val showPremiumBadge: Boolean,
            val memberSince: String?
        )

        sealed class Intents {
            data object Refresh : Intents()
            data class ToggleEmailVisibility(val isEmailVisible: Boolean) : Intents()
        }

        sealed class StateTriggers {
            data class EmailVisibilityChanged(val isEmailVisible: Boolean) : StateTriggers()
            data object Refresh : StateTriggers()
        }
    }

    private var currentState = ViewState(isLoading = true, isError = false)

    private val refreshListener = MutableSharedFlow&lt;ViewState.StateTriggers&gt;()

    val userDetails: Flow&lt;ViewState&gt; = flow {
        emit(currentState)

        //i added error check just because this is for demonstration of this edge case

        if (currentState.isDataLoaded.not() || currentState.isError) {
            emit(getUserDetailsState())
        }

        refreshListener.collect { refreshParams -&gt;
            when (refreshParams) {
                is ViewState.StateTriggers.EmailVisibilityChanged -&gt; {
                    emit(currentState.copy(isEmailVisible = refreshParams.isEmailVisible))
                }

                ViewState.StateTriggers.Refresh -&gt; {
                    emit(ViewState(isLoading = true, isError = false))
                    emit(getUserDetailsState())
                }
            }
        }
    }
        .distinctUntilChanged()
        .onEach {
            currentState = it
        }

        .stateIn(
            viewModelScope,
            SharingStarted.WhileSubscribed(5_000),
            currentState
        )

    private suspend fun getUserDetailsState(): ViewState = getUserDetailsUseCase.execute()
        .fold(
            onSuccess = {
                ViewState(
                    isLoading = false,
                    isError = false,
                    userInfo = ViewState.UserInfo(
                        displayEmail = it.email,
                        avatarUrl = it.avatarUrl,
                        showPremiumBadge = it.isPremium,
                        memberSince = it.creationDate?.toString()
                    )
                )
            },

            onFailure = {
                ViewState(isLoading = false, isError = true)
            }
        )

    override fun onIntent(intent: ViewState.Intents) {
        when (intent) {
            ViewState.Intents.Refresh -&gt; {
                viewModelScope.launch {
                    refreshListener.emit(ViewState.StateTriggers.Refresh)
                }
            }

            is ViewState.Intents.ToggleEmailVisibility -&gt; {
                viewModelScope.launch {
                    refreshListener.emit(ViewState.StateTriggers.EmailVisibilityChanged(intent.isEmailVisible))
                }
            }
        }
    }

    companion object {
        fun factory() = provideFactory { UserAccountDetailsViewModel() }
    }
}
</code></pre>

<p>此模式提供智能缓存——即使在 5 秒超时后，你也可以根据具体需求选择是否重新获取数据：</p>

<ul>
<li><strong>昂贵的 API 调用</strong>：在 ViewModel 中缓存数据以减少网络开销</li>
<li><strong>静态后端数据</strong>：避免对很少更改的信息进行不必要的请求</li>
<li><strong>实时需求</strong>：强制刷新需要更新数据的应用程序</li>
</ul>


<h3>创建可复用的抽象</h3>

<p>重复编写此模式会变得非常繁琐。让我们从 ViewModel 扩展函数开始，创建可复用的抽象：</p>

<pre><code class="kotlin">fun &lt;T, R&gt; ViewModel.loadData(
    initialState: T,
    loadData: suspend FlowCollector&lt;T&gt;.(currentState: T) -&gt; Unit,
    refreshMechanism: SharedFlow&lt;R&gt;? = null,
    timeout: Long = 5_000,
    refreshData: (suspend FlowCollector&lt;T&gt;.(currentState: T, refreshParams: R) -&gt; Unit)? = null,
): StateFlow&lt;T&gt; {

    if (refreshMechanism != null) {
        requireNotNull(refreshData) {
            "You've provided a refresh mechanism but no way to refresh the data"
        }
    }

    if (refreshData != null) {
        requireNotNull(refreshMechanism) {
            "You've provided a refresh data but no mechanism to refresh the data"
        }
    }

    var latestValue = initialState

    return flow {
        emit(latestValue)

        loadData(latestValue)

        refreshMechanism?.collect { refreshParams -&gt;
            if (refreshData != null) {
                refreshData(latestValue, refreshParams)
            }
        }
    }
        .distinctUntilChanged()
        .onEach {
            latestValue = it
        }
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(timeout),
            initialValue = initialState
        )
}

fun &lt;T&gt; ViewModel.loadData(
    initialState: T,
    loadData: suspend FlowCollector&lt;T&gt;.(currentState: T) -&gt; Unit,
    timeout: Long = 5_000,
): StateFlow&lt;T&gt; {
    var latestValue = initialState

    return flow {
        emit(latestValue)
        loadData(latestValue)
    }
        .onEach {
            latestValue = it
        }
        .distinctUntilChanged()
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(timeout),
            initialValue = initialState
        )
}
</code></pre>

<p>有了我们抽象的扩展函数，ViewModel 变得更加简洁：</p>

<p><em>注意：此抽象涵盖了 90% 的常见用例，但不支持复杂的流程链式操作</em></p>

<pre><code class="kotlin">internal class UserAccountDetailsViewModel private constructor(
    private val getUserDetailsUseCase: GetUserDetailsUseCase = GetUserDetailsUseCase.create(),
) : ViewModel(), IntentAware&lt;UserAccountDetailsViewModel.ViewState.Intents&gt; {
    data class ViewState(
        val isLoading: Boolean = false,
        val isError: Boolean = false,
        val isEmailVisible: Boolean = false,
        val userInfo: UserInfo? = null
    ) {
        val isDataLoaded get() = userInfo != null

        data class UserInfo(
            val displayEmail: String,
            val avatarUrl: String?,
            val showPremiumBadge: Boolean,
            val memberSince: String?
        )

        sealed class Intents {
            data object Refresh : Intents()
            data class ToggleEmailVisibility(val isEmailVisible: Boolean) : Intents()
        }

        sealed class StateTriggers {
            data class EmailVisibilityChanged(val isEmailVisible: Boolean) : StateTriggers()
            data object Refresh : StateTriggers()
        }
    }

    private val refreshListener = MutableSharedFlow&lt;ViewState.StateTriggers&gt;()

    val userDetails = loadData(
        initialState = ViewState(isLoading = true, isError = false),
        loadData = { currentState -&gt;
            if (currentState.isDataLoaded.not() || currentState.isError.not()) {
                emit(getUserDetailsState())
            }
        },
        refreshMechanism = refreshListener,
        refreshData = { currentState, refreshParams -&gt;
            when (refreshParams) {
                is ViewState.StateTriggers.EmailVisibilityChanged -&gt; {
                    emit(currentState.copy(isEmailVisible = refreshParams.isEmailVisible))
                }

                ViewState.StateTriggers.Refresh -&gt; {
                    emit(ViewState(isLoading = true, isError = false))
                    emit(getUserDetailsState())
                }
            }
        }
    )

    private suspend fun getUserDetailsState(): ViewState = getUserDetailsUseCase.execute()
        .fold(
            onSuccess = {
                ViewState(
                    isLoading = false,
                    isError = false,
                    userInfo = ViewState.UserInfo(
                        displayEmail = it.email,
                        avatarUrl = it.avatarUrl,
                        showPremiumBadge = it.isPremium,
                        memberSince = it.creationDate?.toString()
                    )
                )
            },

            onFailure = {
                ViewState(isLoading = false, isError = true)
            }
        )

    override fun onIntent(intent: ViewState.Intents) {
        when (intent) {
            ViewState.Intents.Refresh -&gt; {
                viewModelScope.launch {
                    refreshListener.emit(ViewState.StateTriggers.Refresh)
                }
            }

            is ViewState.Intents.ToggleEmailVisibility -&gt; {
                viewModelScope.launch {
                    refreshListener.emit(ViewState.StateTriggers.EmailVisibilityChanged(intent.isEmailVisible))
                }
            }
        }
    }

    companion object {
        fun factory() = provideFactory { UserAccountDetailsViewModel() }
    }
}
</code></pre>

<p>我们可以通过创建更复杂的基类来消除重复的 <code>refreshListener</code> 声明：</p>

<pre><code class="kotlin">abstract class ViewModelLoader&lt;State : Any, Intent : Any, Trigger : Any&gt; : ViewModel() {
    private val _trigger by lazy { MutableSharedFlow&lt;Trigger&gt;() }

    fun &lt;T&gt; loadData(
        initialState: T,
        loadData: suspend FlowCollector&lt;T&gt;.(currentState: T) -&gt; Unit,
        triggerData: (suspend FlowCollector&lt;T&gt;.(currentState: T, triggerParams: Trigger) -&gt; Unit)? = null,
        timeout: Long = 5000L, //matching ANR timeout in Android
    ): StateFlow&lt;T&gt; {
        var latestValue = initialState

        return flow {
            emit(latestValue)

            loadData(latestValue)

            if (triggerData != null) {
                _trigger.collect { triggerParams -&gt;
                    triggerData(this, latestValue, triggerParams)
                }
            }
        }
            .distinctUntilChanged()
            .onEach {
                latestValue = it
            }

            .stateIn(
                scope = viewModelScope,
                started = SharingStarted.WhileSubscribed(timeout),
                initialValue = initialState
            )
    }

    abstract val state: StateFlow&lt;State&gt;

    val currentState get() = state.value

    open fun onIntent(intent: Intent) {}

    protected fun sendTrigger(trigger: Trigger) {
        viewModelScope.launch {
            _trigger.emit(trigger)
        }
    }
}
</code></pre>

<p>我们的最终实现将变得非常简洁且易于维护：</p>

<pre><code class="kotlin">internal class UserAccountDetailsViewModel private constructor(
    private val getUserDetailsUseCase: GetUserDetailsUseCase = GetUserDetailsUseCase.create(),
) : ViewModelLoader&lt;UserAccountDetailsViewModel.ViewState, UserAccountDetailsViewModel.ViewState.Intents, UserAccountDetailsViewModel.ViewState.StateTriggers&gt;() {
    data class ViewState(
        val isLoading: Boolean = false,
        val isError: Boolean = false,
        val isEmailVisible: Boolean = false,
        val userInfo: UserInfo? = null
    ) {
        val isDataLoaded get() = userInfo != null

        data class UserInfo(
            val displayEmail: String,
            val avatarUrl: String?,
            val showPremiumBadge: Boolean,
            val memberSince: String?
        )

        sealed class Intents {
            data object Refresh : Intents()
            data class ToggleEmailVisibility(val isEmailVisible: Boolean) : Intents()
        }

        sealed class StateTriggers {
            data class EmailVisibilityChanged(val isEmailVisible: Boolean) : StateTriggers()
            data object Refresh : StateTriggers()
        }
    }

    override val state = loadData(
        initialState = ViewState(isLoading = true, isError = false),
        loadData = { currentState -&gt;
            if (currentState.isDataLoaded.not() || currentState.isError.not()) {
                emit(getUserDetailsState())
            }
        },

        triggerData = { currentState, refreshParams -&gt;
            when (refreshParams) {
                is ViewState.StateTriggers.EmailVisibilityChanged -&gt; {
                    emit(currentState.copy(isEmailVisible = refreshParams.isEmailVisible))
                }

                ViewState.StateTriggers.Refresh -&gt; {
                    emit(ViewState(isLoading = true, isError = false))
                    emit(getUserDetailsState())
                }
            }
        }
    )

    private suspend fun getUserDetailsState(): ViewState = getUserDetailsUseCase.execute()

        .fold(
            onSuccess = {
                ViewState(
                    isLoading = false,
                    isError = false,
                    userInfo = ViewState.UserInfo(
                        displayEmail = it.email,
                        avatarUrl = it.avatarUrl,
                        showPremiumBadge = it.isPremium,
                        memberSince = it.creationDate?.toString()
                    )
                )
            },

            onFailure = {
                ViewState(isLoading = false, isError = true)
            }
        )

    override fun onIntent(intent: ViewState.Intents) {
        when (intent) {
            ViewState.Intents.Refresh -&gt; {
                sendTrigger(ViewState.StateTriggers.Refresh)
            }

            is ViewState.Intents.ToggleEmailVisibility -&gt; {
                sendTrigger(ViewState.StateTriggers.EmailVisibilityChanged(intent.isEmailVisible))
            }
        }
    }

    companion object {
        fun factory() = provideFactory { UserAccountDetailsViewModel() }
    }
}
</code></pre>

<h3>处理 UI 状态复杂性</h3>

<p>此抽象使用布尔标志（<code>isLoading</code>、<code>isError</code>），这些标志可能会创建模糊状态。为了更清晰地管理状态，可以考虑使用密封类：</p>

<pre><code class="kotlin">@Immutable
sealed interface UIState {
    @Immutable
    data object Success : UIState
    @Immutable
    data object Error : UIState
    @Immutable
    data object Idle : UIState
    @Immutable
    data object Loading : UIState
}
</code></pre>

<p>对于需要同时显示错误信息（例如 Snackbars）和现有数据的场景，你可以创建更复杂的状态持有者：</p>

<pre><code class="kotlin">@Immutable
data class UIStateHolder&lt;out T&gt;(
    val uiState: UIState = UIState.Idle,
    val payload: T? = null
)
</code></pre>

<p>这种方法可以实现灵活的 UI 状态管理，同时保持 UI 状态和数据负载之间的明确分离，但可能会增加认知负荷，并引入更多的映射行为和解包逻辑。</p>

<h3>超越 ViewModel</h3>

<p>此模式不仅限于 ViewModel。通过提供自定义协程作用域，你可以在任何组件（可组合组件、存储库或业务逻辑层）中使用此数据加载方法。</p>

<h2>流组合模式</h2>

<p>这种方法的优点还在于可以组合多个数据源。以下是处理单流和双流的示例：</p>

<pre><code class="kotlin">inline fun &lt;reified T, R&gt; ViewModel.loadFlow(
    initialState: R,
    flow: Flow&lt;T&gt;,
    crossinline transform: suspend CoroutineScope.(newValue: T, currentState: R) -&gt; R,
    timeout: Long = 0,
): StateFlow&lt;R&gt; {

    var latestValue = initialState

    return flow
        .map { newValue -&gt;
            coroutineScope {
                transform(newValue, latestValue)
            }
        }

        .onEach {
            latestValue = it
        }.stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(timeout),
            initialValue = latestValue
        )
}
</code></pre>

<p>组合双流的示例：</p>

<pre><code class="kotlin">inline fun &lt;reified T1, reified T2, R&gt; ViewModel.loadFlow(
    initialState: R,
    flow1: Flow&lt;T1&gt;,
    flow2: Flow&lt;T2&gt;,
    crossinline transform: suspend CoroutineScope.(newValue1: T1, newValue2: T2, currentState: R) -&gt; R,
    timeout: Long = 0,
): StateFlow&lt;R&gt; {

    var latestValue = initialState

    return combine(flow1, flow2) { value1, value2 -&gt;
        coroutineScope {
            transform(value1, value2, latestValue)
        }
    }
        .onEach {
            latestValue = it
        }.stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(timeout),
            initialValue = latestValue
        )
}
</code></pre>

<p>这些扩展允许你轻松组合多个数据源，同时保持相同的智能缓存和状态管理原则。</p>

<h3>测试基于流的 ViewModel</h3>

<p>在结束之前，让我们探索如何使用 fakes 和 Turbine 进行流测试，正确地测试我们的 <code>UserAccountDetailsViewModel</code> 实现。</p>

<h4>使用 Fakes 和 Turbine 设置测试依赖项</h4>

<pre><code class="kotlin">@OptIn(ExperimentalCoroutinesApi::class)
class UserAccountDetailsViewModelTest {
    private val testDispatcher = StandardTestDispatcher()

    private val fakeGetUserDetailsUseCase = FakeGetUserDetailsUseCase()

    private lateinit var viewModel: UserAccountDetailsViewModel

    @Before
    fun setUp() {
        Dispatchers.setMain(testDispatcher)
        viewModel = UserAccountDetailsViewModel(fakeGetUserDetailsUseCase)
    }

    @After
    fun tearDown() {
        Dispatchers.resetMain()
    }
}

// Fake implementation for realistic testing, this sounds funny to write haha
class FakeGetUserDetailsUseCase {
    private var shouldReturnError = false

    private var userDetailsToReturn: UserDetails? = null

    private var executionCount = 0

    fun setSuccessResponse(userDetails: UserDetails) {
        this.userDetailsToReturn = userDetails
        this.shouldReturnError = false
    }

    fun setErrorResponse() {
        this.shouldReturnError = true
        this.userDetailsToReturn = null
    }

    // Expose execution count when testing caching/performance behavior
    fun getExecutionCount() = executionCount

    fun reset() {
        executionCount = 0
    }

    suspend fun execute(): Result&lt;UserDetails&gt; {
        executionCount++

        delay(50) // Simulate network delay

        return if (shouldReturnError) {
            Result.failure(Exception("Network error"))
        } else {
            Result.success(userDetailsToReturn ?: createDefaultUserDetails())
        }
    }

    private fun createDefaultUserDetails() = UserDetails(
        email = "default@example.com",
        avatarUrl = null,
        isPremium = false,
        creationDate = "2023-01-01"
    )
}
</code></pre>

<h4>成功和失败场景的参数化测试</h4>

<pre><code class="kotlin">@ParameterizedTest
@ValueSource(booleans = [true, false])
fun `should handle both success and error scenarios`(shouldSucceed: Boolean) = runTest {
    // Given

    if (shouldSucceed) {
        fakeGetUserDetailsUseCase.setSuccessResponse(
            UserDetails(
                email = "success@example.com",
                avatarUrl = "https://avatar.url",
                isPremium = true,
                creationDate = "2023-01-01"
            )
        )
    } else {
        fakeGetUserDetailsUseCase.setErrorResponse()
    }

    // When

    viewModel.state.test {
        advanceUntilIdle()

        // Then Focus on behavior, not implementation details

        if (shouldSucceed) {
            awaitItem() // Loading state

            val successState = awaitItem()

            assertThat(successState.isLoading).isFalse()

            assertThat(successState.isError).isFalse()

            assertThat(successState.userInfo?.displayEmail).isEqualTo("success@example.com")

            assertThat(successState.userInfo?.showPremiumBadge).isTrue()
        } else {
            awaitItem() // Loading state

            val errorState = awaitItem()

            assertThat(errorState.isLoading).isFalse()

            assertThat(errorState.isError).isTrue()

            assertThat(errorState.userInfo).isNull()
        }
    }
}

@Test
fun `should refresh data when refresh intent is triggered`() = runTest {
    // Given Initial successful load
    fakeGetUserDetailsUseCase.setSuccessResponse(
        UserDetails(
            email = "initial@example.com",
            avatarUrl = null,
            isPremium = false,
            creationDate = "2022-01-01"
        )
    )

    viewModel.state.test {
        advanceUntilIdle()

        awaitItem() // Loading

        val initialState = awaitItem() // Success

        assertThat(initialState.userInfo?.displayEmail).isEqualTo("initial@example.com")

        // Change response and trigger refresh
        fakeGetUserDetailsUseCase.setSuccessResponse(
            UserDetails(
                email = "refreshed@example.com",
                avatarUrl = "https://new-avatar.url",
                isPremium = true,
                creationDate = "2023-01-01"
            )
        )

        viewModel.onIntent(ViewState.Intents.Refresh)

        advanceUntilIdle()

        // Then
        awaitItem() // Loading during refresh

        val refreshedState = awaitItem() // New Success

        assertThat(refreshedState.isLoading).isFalse()

        assertThat(refreshedState.userInfo?.displayEmail).isEqualTo("refreshed@example.com")

        assertThat(refreshedState.userInfo?.showPremiumBadge).isTrue()

        // Verify both initial load and refresh were called
        assertThat(fakeGetUserDetailsUseCase.getExecutionCount()).isEqualTo(2)
    }
}
</code></pre>

<h4>测试仅 UI 状态变化</h4>

<pre><code class="kotlin">@Test
fun `should toggle email visibility without triggering data reload`() = runTest {
    // Given Successful initial load
    fakeGetUserDetailsUseCase.setSuccessResponse(
        UserDetails(
            email = "test@example.com",
            avatarUrl = null,
            isPremium = false,
            creationDate = "2023-01-01"
        )
    )

    viewModel.state.test {
        advanceUntilIdle()

        awaitItem() // Loading

        val loadedState = awaitItem() // Success

        assertThat(loadedState.userInfo?.displayEmail).isEqualTo("test@example.com")

        assertThat(loadedState.isEmailVisible).isFalse()

        // When Toggle email visibility

        viewModel.onIntent(ViewState.Intents.ToggleEmailVisibility(isEmailVisible = true))

        advanceUntilIdle()

        // Then
        val toggledState = awaitItem()

        assertThat(toggledState.isEmailVisible).isTrue()

        assertThat(toggledState.userInfo?.displayEmail).isEqualTo("test@example.com")

        assertThat(fakeGetUserDetailsUseCase.getExecutionCount()).isEqualTo(1)
    }
}
</code></pre>

<h4>测试数据缓存行为</h4>

<pre><code class="kotlin">@Test
fun `should use cached data when returning to screen quickly`() = runTest {
    // Given

    fakeGetUserDetailsUseCase.setSuccessResponse(
        UserDetails(
            email = "cached@example.com",
            avatarUrl = null,
            isPremium = true,
            creationDate = "2023-01-01"
        )
    )

    // When First collection

    viewModel.state.test {
        advanceUntilIdle()

        awaitItem() // Loading

        val firstState = awaitItem() // Success

        assertThat(firstState.userInfo?.displayEmail).isEqualTo("cached@example.com")

        cancel() // Simulate leaving screen
    }

    // When Quick return (simulating navigation back within timeout)

    viewModel.state.test {
        advanceUntilIdle()

        // Then Should have cached data immediately (no Loadin)

        val cachedState = awaitItem()

        assertThat(cachedState.isLoading).isFalse()

        assertThat(cachedState.userInfo?.displayEmail).isEqualTo("cached@example.com")

        expectNoEvents()
    }

    assertThat(fakeGetUserDetailsUseCase.getExecutionCount()).isEqualTo(1)
}
</code></pre>

<h4>测试错误恢复</h4>

<pre><code class="kotlin">@Test
fun `should recover from Error on successful refresh`() = runTest {
    // Given Initial error

    fakeGetUserDetailsUseCase.setErrorResponse()

    viewModel.state.test {
        advanceUntilIdle()

        awaitItem() // Loading

        val errorState = awaitItem() // Error

        assertThat(errorState.isError).isTrue()

        // When Fix the response and refresh

        fakeGetUserDetailsUseCase.setSuccessResponse(
            UserDetails(
                email = "recovered@example.com",
                avatarUrl = null,
                isPremium = false,
                creationDate = "2023-01-01"
            )
        )

        viewModel.onIntent(ViewState.Intents.Refresh)

        advanceUntilIdle()

        // Then Should recover successfully

        awaitItem() // Loading during refresh

        val recoveredState = awaitItem() // Success

        assertThat(recoveredState.isError).isFalse()

        assertThat(recoveredState.userInfo?.displayEmail).isEqualTo("recovered@example.com")

        assertThat(fakeGetUserDetailsUseCase.getExecutionCount()).isEqualTo(2)
    }
}
</code></pre>

<h3>为什么要测试基于流的 ViewModel 的原则</h3>

<p>哦……这可能会引发一些争论，但这里有一篇很棒的文章，它提供了更好的描述，并且不会影响本文关于我为什么使用 Fakes 的目的。这里有一个简短的总结，可以补充文章顶部</p>

<ol>
<li><strong>使用 Fakes 而非 Mocks</strong>：Fake 提供逼真的行为，并且更易于维护，尤其是在如今 LLM 的帮助下……</li>
<li><strong>参数化测试</strong>：用一个测试用例同时测试成功和失败路径</li>
<li><strong>使用 Turbine 进行流程测试</strong>：简洁、富有表现力的流程测试，并进行适当的状态验证</li>
<li><strong>测试状态转换</strong>：验证完整的状态流程，而不仅仅是最终状态</li>
<li><strong>谨慎执行计数</strong>：仅在测试缓存、性能或重试行为时验证调用计数</li>
<li><strong>关注行为</strong>：测试用户体验，而不是实现细节（我想这一点显而易见）</li>
</ol>


<h3>结论</h3>

<p>本文对 Android ViewModel 中基于流程的数据加载的探索，解决了传统 <code>init {}</code> 块方法的根本挑战。虽然涵盖所有架构变体会很繁琐，但该模式成功处理了大约 90% 的常见用例。</p>

<p>抽象基类方法（<code>ViewModelLoader</code>）提供了最可预测和可维护的解决方案，它提供：</p>

<ul>
<li><strong>可预测的状态管理</strong>：清晰的状态触发器和意图处理</li>
<li><strong>内置测试支持</strong>：具有适当协程处理的可测试架构</li>
<li><strong>灵活性</strong>：易于扩展效果和混合 MVI 模式</li>
<li><strong>缓存和刷新</strong>：缓存和刷新机制（本文将尽可能详细地介绍）</li>
</ul>


<h3>关键要点</h3>

<ol>
<li><strong>基于流的加载</strong>消除了竞争条件，提高了测试的简易性，并解决了 <code>init {}</code> 块中固有的回栈问题</li>
<li><strong>具有适当共享策略的 StateFlow</strong> 提供了最佳的生命周期感知数据管理</li>
<li><strong>抽象层</strong>减少了样板代码，同时保持了灵活性</li>
<li><strong>全面的测试</strong>确保所有用例的可靠性</li>
</ol>


<p>请记住，这只是众多架构方法中的一种，它解决了我的问题，但可能无法解决你的问题。我们的目标是了解潜在问题并评估此解决方案是否符合你的特定需求。随着时间的推移，这个解决方案将经历许多变化，甚至可能被淘汰。最近，我更多地投入到使用 Ktor 进行后端开发，这本身就是一次很棒的体验。</p>

<p>该架构成功地为 iOS 和 Android 平台上的 <a href="https://wallhub.app/">WallHub</a> 提供了支持，证明了其在现实世界中的“可行性”以及跨平台适应性（如果可以这么说的话）。</p>

<p>继续潜水，直到下一篇文章……</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android应用的架构演进]]></title>
    <link href="https://alexhilton.github.io/blog/2025/09/13/architectual-evolution-of-an-android-app/"/>
    <updated>2025-09-13T20:34:01+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/09/13/architectual-evolution-of-an-android-app</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Architectural Evolution of and Android app」，原文链接<a href="https://herrbert74.github.io/posts/architectural-evolution-of-an-app/">https://herrbert74.github.io/posts/architectural-evolution-of-an-app/</a>，由Zsolt Bertalan发布于20258月19日。</p></blockquote>

<p><a href=""><img src="https://herrbert74.github.io/assets/img/posts/20250818_arch_evolution.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>本文将解释 Android 应用在发展过程中可能经历的各个阶段。不同的架构可能看起来截然不同（更不用说对细节的不同看法），但其背后的理念是相同的。我将通过整洁架构 (Clean Architecture) 和我的 <a href="https://github.com/herrbert74/FlickSlate">FlickSlate</a> 代码库（链接：<a href="https://github.com/herrbert74/FlickSlate%EF%BC%89%E6%9D%A5%E8%A7%A3%E9%87%8A%E8%BF%99%E4%B8%80%E7%82%B9%E3%80%82">https://github.com/herrbert74/FlickSlate%EF%BC%89%E6%9D%A5%E8%A7%A3%E9%87%8A%E8%BF%99%E4%B8%80%E7%82%B9%E3%80%82</a></p>

<p>我还想介绍一下大型应用中的常见模式：<strong>超级层</strong> 和 <strong>功能组</strong>。每当我开发的应用达到一定规模时，都会用到这些模式，但我从未制定过相关的基本规则。我希望把它们写下来，能让我和其他人更容易理解。</p>

<h3>超级层</h3>

<p>你可能还记得我之前的文章，我的应用有一个独立的<strong>领域层</strong>，<strong>数据层和展现层（从现在开始是UI层）</strong>都依赖于它。这些是基本的水平层。包含它们的垂直层也称为功能层。</p>

<p>我创造了 <strong>“超级层”</strong> 这个术语，是为了在基本水平层之上引入一个更广泛的层次结构。我们需要它们，因为水平层的范围可能有所不同，这意味着它们不仅可以涵盖功能层，还可以涵盖更广泛的范围。我将定义<strong>功能层</strong>、<strong>功能组</strong>、<strong>应用级（共享）</strong>和<strong>多应用级（基础）</strong> 超级层。</p>

<p>请参阅下图。</p>

<p><img src="file:///Users/alexhilton/Downloads/arch-envolve-1.png" alt="" /></p>

<p>在我上面解释的基本情况下，我们有<strong>功能层</strong>，其中整洁架构层仅在功能层内部可见。</p>

<p>接下来，<strong>功能组</strong>层是介于应用范围层和功能范围层之间的中间层。由于它是对超级层的最后且最不明显的补充，我将在稍后详细讨论。</p>

<p><strong>共享、通用或应用范围层</strong>通常包含与业务相关或整个应用独有的类。这是可以添加领域、数据和 UI 模块的最低层。</p>

<p><strong>基础层、基础设施层或基础结构层</strong>可以跨多个应用使用。它不包含领域、数据或 UI 层，但包含这些层之间通用的类。我通常有一个<strong>Kotlin 模块和一个 Android 基础模块</strong>。我创建了 <a href="https://bitbucket.org/babestudios/babestudiosbase/src/master/">BaBeStudios-Base</a> 库项目（<a href="https://bitbucket.org/babestudios/babestudiosbase/src/master/%EF%BC%89%EF%BC%8C%E4%BB%A5%E4%BE%BF%E5%9C%A8%E5%A4%9A%E4%B8%AA%E5%BA%94%E7%94%A8%E4%B8%AD%E5%A4%8D%E7%94%A8%E8%BF%99%E4%BA%9B%E6%A8%A1%E5%9D%97%EF%BC%8C%E4%BD%86%E6%88%91%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%AD%E4%B9%9F%E6%9C%89%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%B0%9A%E6%9C%AA%E5%8C%85%E5%90%AB%E5%9C%A8%E8%AF%A5%E5%BA%93%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E3%80%82">https://bitbucket.org/babestudios/babestudiosbase/src/master/%EF%BC%89%EF%BC%8C%E4%BB%A5%E4%BE%BF%E5%9C%A8%E5%A4%9A%E4%B8%AA%E5%BA%94%E7%94%A8%E4%B8%AD%E5%A4%8D%E7%94%A8%E8%BF%99%E4%BA%9B%E6%A8%A1%E5%9D%97%EF%BC%8C%E4%BD%86%E6%88%91%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%AD%E4%B9%9F%E6%9C%89%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97%EF%BC%8C%E7%94%A8%E4%BA%8E%E5%B0%9A%E6%9C%AA%E5%8C%85%E5%90%AB%E5%9C%A8%E8%AF%A5%E5%BA%93%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E3%80%82</a> BaBeStudios-Base 也可从 <a href="https://mvnrepository.com/artifact/io.bitbucket.babestudios">MavenCentral</a> 获取，但目前尚无相关文档。</p>

<p>随着应用程序规模的扩大和模块的引入，你需要引入上述各层。</p>

<p>接下来，让我们看看随着应用程序规模的扩大，我通常采取的模块化步骤。</p>

<h3>步骤 1：单模块</h3>

<p>当你确定应用程序规模不会超过<strong>最大规模</strong>，或者时间紧迫时，你可以选择单模块应用程序或单体应用。我不确定单模块应用程序的最大规模是多少。这可能因人而异。</p>

<p>此最大规模也不同于<strong>阈值规模，你应该从该阈值开始模块化应用程序</strong>，或者更通俗地说，你应该从该阈值切换到流程的下一步。我认为阈值大小远小于单模块应用程序的最大大小，这意味着你应该在达到该限制之前就开始模块化。</p>

<p>对于大多数应用程序，我甚至建议<strong>从模块化开始</strong>，而不是从单个模块开始，因为与接近限制（比如 10 或 20 kLOC）时才开始模块化相比，这样做的开销和干扰程度要小得多。</p>

<p>这是一个单模块应用程序的包树示例。</p>

<pre><code class="bash">├── data
│   ├── database
│   ├── local
│   ├── repository
│   └── remote
├── domain
│   ├── api
│   ├── model
│   └── usecase
├── presentation
│   ├── master
│   └── detail
└── shared
</code></pre>

<p>上面图中的叶子节点代表包，它们可以包含此处未显示的其他包。下面我将展示一个类似的模块结构，其中以冒号开头的名称代表模块，双冒号代表根模块。</p>

<h3>步骤 2：简单模块化</h3>

<p>对于<strong>小型应用程序</strong>，我使用简单模块化，而不是下一章的完全模块化。这里我们只介绍<strong>每个功能的模块</strong>。每个功能将包含一个领域模块，以及依赖于领域模块的数据和呈现模块（在我的例子中）。</p>

<p>我们还引入了一个<strong>共享模块</strong>，其中包含所有功能模块的通用代码。</p>

<p>应用程序的超层由一条<strong>水平线</strong>分隔。每个层都依赖于其下方的所有层。数据和呈现依赖于领域模块，但这并未在图中显示。</p>

<pre><code class="bash">::feature:Feature A

├── :feature/:featurea/:data
├── :feature/:featurea/:domain 
└── :feature/:featurea/:presentation  

::feature:Feature B

├── :feature/:featureb/:data
├── :feature/:featureb/:domain
└── :feature/:featureb/:presentation 

 ::feature:Feature C  

├── :feature/:featurec/:data
├── :feature/:featurec/:domain 
└── :feature/:featurec/:presentation


::shared:data

├── database
├── local
├── repository
└── remote

::shared:domain

├── api
├── model
└── usecase

::shared:presentation

├── compose
├── design
└── util


::base:kotlin  
</code></pre>

<h3>步骤 4：功能组</h3>

<p>当你的应用完全模块化后，共享层会逐渐成为单体应用，并成为构建过程中的<strong>瓶颈</strong>。</p>

<p>我经常在超过一定规模的应用（大约 50 到 80 kLOC）时遇到这种情况。你需要共享太多内容，因此你的<strong>共享领域模块和展示模块</strong>变得过大。你开始注意到，在所有垂直模块之间共享代码也是一种浪费，因为你只想在两个或最多三个或四个模块之间共享代码。你会发现越来越多的新代码被添加到这些模块中，而<strong>增量缓存</strong>的效率越来越低，因为你频繁地修改代码，导致它们失效。</p>

<p>你可能会说，可以通过适当地重构和构建应用程序，或者复制一些代码来避免这种情况，但这可能比你想象的要难。我发现这些建议并没有起到什么帮助作用。或者你可能手头有一个遗留应用，没有时间完美地重构所有内容。</p>

<p>我目前解决这个问题的方法是识别<strong>功能组</strong>，即一组具有大量公共依赖项的功能。这样，你就可以通过创建<strong>更具凝聚力</strong>的模块，水平拆分共享层中的部分代码。</p>

<p>我最近开发的所有大型应用中都有两个不同的功能组。</p>

<p>第一个功能组与<strong>核心业务</strong>功能相关：例如，一个模块围绕产品列表，另一个模块围绕产品详情，第三个模块围绕收藏产品。因此，我们可以将这个功能组命名为<strong>产品</strong>。另一个功能组围绕<strong>支付、广告或订阅</strong>，或者有时是这些功能的组合。这关系到应用的盈利方式。因此，我们可以将功能组命名为<strong>“支付”</strong>。</p>

<p>大型应用中可能会有五个或更多功能组。每个功能组将包含领域模块、数据模块和演示模块（如果需要）。</p>

<pre><code class="bash">feature/Feature A

feature/Feature B

feature/Feature C

feature/Feature D

feature/Feature E

feature/Feature F


:data

:domain

:presentation


:kotlin-base  
</code></pre>

<h3>何时使用哪一步？</h3>

<p>你肯定希望将单体应用用于永远不会投入生产或一次性使用的应用程序。这些应用程序可以是<strong>概念验证</strong> (PoC, Proof of Concept) 应用程序、用于第三方错误的<strong>最小可复现示例</strong> (MRE, Minimum Reproducible Example) 应用程序，或用于求职申请的<strong>测试挑战</strong>应用程序。</p>

<p>对于所有其他情况，我建议先从部分或完全模块化开始，然后根据需要升级到下一步，或者尽可能提前升级，以减少以后的麻烦。</p>

<p>你可以在我的 <a href="https://github.com/herrbert74/FlickSlate">FlickSlate</a> 代码库（链接：<a href="https://github.com/herrbert74/FlickSlate%EF%BC%89%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%8A%E8%BF%B0%EF%BC%88%E5%A4%A7%E9%83%A8%E5%88%86%EF%BC%89%E5%86%85%E5%AE%B9%E7%9A%84%E6%9C%89%E6%95%88%E7%A4%BA%E4%BE%8B%EF%BC%8C%E6%88%91%E6%9C%80%E8%BF%91%E5%B0%86%E5%85%B6%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BA%86%E5%AE%8C%E5%85%A8%E6%A8%A1%E5%9D%97%E5%8C%96%E9%98%B6%E6%AE%B5%E3%80%82%E8%99%BD%E7%84%B6%E4%B8%BA%E6%97%B6%E8%BF%87%E6%97%A9%EF%BC%8C%E4%BD%86%E6%9C%89%E5%8A%A9%E4%BA%8E%E6%BC%94%E7%A4%BA%E8%BF%99%E4%BA%9B%E5%8E%9F%E5%88%99%E3%80%82%E5%BD%93%E7%84%B6%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%81%BF%E5%85%8D%E4%BB%A5%E5%90%8E%E7%9A%84%E9%BA%BB%E7%83%A6%E3%80%82">https://github.com/herrbert74/FlickSlate%EF%BC%89%E4%B8%AD%E6%89%BE%E5%88%B0%E4%B8%8A%E8%BF%B0%EF%BC%88%E5%A4%A7%E9%83%A8%E5%88%86%EF%BC%89%E5%86%85%E5%AE%B9%E7%9A%84%E6%9C%89%E6%95%88%E7%A4%BA%E4%BE%8B%EF%BC%8C%E6%88%91%E6%9C%80%E8%BF%91%E5%B0%86%E5%85%B6%E6%9B%B4%E6%96%B0%E5%88%B0%E4%BA%86%E5%AE%8C%E5%85%A8%E6%A8%A1%E5%9D%97%E5%8C%96%E9%98%B6%E6%AE%B5%E3%80%82%E8%99%BD%E7%84%B6%E4%B8%BA%E6%97%B6%E8%BF%87%E6%97%A9%EF%BC%8C%E4%BD%86%E6%9C%89%E5%8A%A9%E4%BA%8E%E6%BC%94%E7%A4%BA%E8%BF%99%E4%BA%9B%E5%8E%9F%E5%88%99%E3%80%82%E5%BD%93%E7%84%B6%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E9%81%BF%E5%85%8D%E4%BB%A5%E5%90%8E%E7%9A%84%E9%BA%BB%E7%83%A6%E3%80%82</a></p>

<p>FlickSlate 尚未升级到功能组。这毫无意义，因为共享层还无法拆分为功能组。该应用没有盈利功能，所以只能对节目进行分组，不过目前共享层已经完美地实现了这一点。</p>

<p>这篇文章主要源于我对互联网上关于何时以及如何模块化的建议一概而论的不满：要么建议不加区分地进行模块化，要么有人对任何进行模块化的人大喊“过度工程”。我希望这篇文章能帮助你在何时以及如何进行模块化方面做出更明智的决定。</p>
]]></content>
  </entry>
  
</feed>
