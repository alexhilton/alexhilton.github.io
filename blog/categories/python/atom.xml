<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Python | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/python/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2023-07-14T23:42:34+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python Runtime Environment]]></title>
    <link href="http://toughcoder.net/blog/2023/07/14/python-runtime-environment/"/>
    <updated>2023-07-14T22:46:17+08:00</updated>
    <id>http://toughcoder.net/blog/2023/07/14/python-runtime-environment</id>
    <content type="html"><![CDATA[<p><a href="https://www.python.org/">Python</a>是非常流行的通用编程语言，因其简洁和易读而广受喜爱，近年来由于深度学习的崛起更是让Python登顶为<a href="https://www.tiobe.com/tiobe-index/">最受欢迎的编程语言</a>。虽然已使用Python写了一些程序，但总是缺少深度的理解，加之前段时间因为升级pip导致一些依赖的module无法正常工作，于是要停下来把Python到底是如何工作的了解清楚。</p>

<p><a href=""><img src="https://ts1.cn.mm.bing.net/th/id/R-C.c953feda2b0afda299ccfbe1a9743f00?rik=zz1NU7tbEq3gJQ&amp;riu=http%3a%2f%2fwww.pc9.com%2fuploads%2f20190916%2f805079fa18cbca1ac696dfc8e5efdece.jpg&amp;ehk=tFZHTezwkONle9xLOfoCkQHlSjQvyAla02%2fvtEsdl9I%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" title="auto auto" ></a></p>

<!-- more -->


<p><strong>注意</strong>：这不是一个基础的教程，也不是一个系统的教程，假定读者有一定的编程开发经验，并且已有Python基础。</p>

<h2><a href="https://docs.python.org/3/tutorial/interpreter.html">Python解释器</a></h2>

<p>这是Python语言中最重要的东西，它负责运行你写的代码，把我们的代码作为输入塞给Python解释器，就能得到我们期望的输出。</p>

<p><strong>注意</strong>：本文中不纠结编译与解释的区别，以及说Python到底会不会把源代码进行编译。</p>

<p>现代比较流行的操作系统如Ubuntu LTS或者Mac OX都会预装Python，原因在于一方面Python太过流行，另外就是操作系统本身也会用到Python。</p>

<p><img src="https://techvidvan.com/tutorials/wp-content/uploads/sites/2/2020/03/how-python-interpreter-works.jpg" alt="" /></p>

<p>但需要特别注意的是，大Python有两个版本Python2和Python3，且并不兼容，稍学习过Python的都应该知道，现在Python2已经停止维护了，Python社区现只管Python3了，并且以后再说Python其实都是指Python3。本文当中除非特别说明，否则也都是Python3。</p>

<p>虽然说Python2已经停止维护了，但是由于历史的原因很多三方的库未能及时升级到Python3，所以现在的操作系统中仍会把两个版本的Python都集成，Python2的版本一般会是2.7.x，而Python3的版本一般会是3.7.x或者3.8.x。反正不会是最新的3.11或者3.14。</p>

<p>操作系统默认的命令python一般都仍指向Python2，而命令python3才是指向Python3。所以在使用解释器或者指定解释器的时候要注意。</p>

<p><strong>注意</strong>：操作系统一般把程序安装某个位置，然后在系统路径中只添加指向其安装位置的<a href="https://www.geeksforgeeks.org/soft-hard-links-unixlinux/">二进制文件的链接</a>，对于有兼容性不同版本的命令更是如此，比如/usr/bin/python，这是默认的命令，它是一个指向Python 2.7.x安装位置的一个链接。同理/usr/bin/python3也是一个链接。</p>

<p>可以用which命令来查看这些命令的最终指向：</p>

<pre><code class="bash">➜  ~ which python3
/Library/Frameworks/Python.framework/Versions/3.7/bin/python3
</code></pre>

<p>需要特别注意的是，操作系统自带的Python一般不是最新的，所以有时候可能有会升级的需要，一般用软件包管理工具如<a href="https://linux.die.net/man/8/apt-get">apt-get</a> 或者<a href="https://brew.sh/">brew</a>可以安装新版本的Python3，如3.11，但一般建议把它安装在一个不同的位置，也就是说不要直接覆盖操作系统预装的版本。并且，不要把默认链接python3指向新版本。这是因为，操作系统之所以选择特定的版本，是为了<strong>兼容性和稳定性</strong>，这个版本能保证操作系统的Python代码和库都能正常运行。如果我们用新版本覆盖了原装的，或者把默认的链接替换掉，有可能会对操作系统造成伤害，轻则发生奇怪的事情，重则可能要重装系统。</p>

<h3>交互式环境</h3>

<p><img src="https://www.circuitbasics.com/wp-content/uploads/2015/12/Python-and-python3-REPL.png" alt="" />
直接启动解释器会进入一个叫做<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL（Read Evaluate Print Loop）</a>的环境，这是脚本语言都会有的一个环境，它的是意思读取指令（也即我们输入的Python语句），执行，打印输出，然后循环上述步骤。直到给一个退出命令(exit())才会终止。</p>

<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy82eFcyRDk0cUJqSEw1Q01lOUVHWEFKTmJmbXJIanNwbkVtOGlheDlKTE1kWU0zSUZHYmZzRHdpY25ZV1h1ZU9jamNIRjBpY1BpYmtFbWljZUo4QTRUOG5KNWljZy82NDA?x-oss-process=image/format,png" alt="" /></p>

<p>另外一个更为高级一些的<a href="https://ipython.org/">交互式Python运行环境</a>就是非常著名的<a href="https://jupyter.org/">Jupyter</a>。</p>

<h3>命令行</h3>

<p>在Python世界里<a href="https://docs.python.org/3/tutorial/modules.html">模块Modules</a>是一个代码管理的基本单元，内置的库和三方的库都包含一个或者多个Module。Python有一个特殊功能，就是可以用命令行直接执行一个Module:</p>

<pre><code class="bash">python3 -m http.server 8000
</code></pre>

<p>这就启动了一个非常简单的HTTP server。它的作用就是把一个叫做http.server的Module直接运行起来。</p>

<h3>源代码式</h3>

<p>更多的时候我们会把Python代码写入一个文件，然后再塞给解释器去执行。写一个简单的hello.py：</p>

<pre><code class="python3">#!/usr/bin/env python3
print('Hello, world')
</code></pre>

<p>然后，运行它：
<code>bash
python3 hello.py
Hello, world
</code>
也可以直接执行hello.py
<code>bash
./hello.py
Hello, world
</code>
这里的区别就在于，前面加了解释器的，就会用命令行中的解释器去运行。而直接执行脚本文件，则会用第一行的叫做<a href="https://linuxhandbook.com/shebang/">shebang的东西</a>来找解释器，这里就是<strong>/usr/bin/env python3</strong>，这个意思是说用操作系统中的路径中的python3来作为解释器（作为执行这个脚本的命令）。</p>

<p>那么，利用shebang就可以指定特定的Python版本来运行脚本了。比如：</p>

<pre><code class="python3">#!/usr/local/opt/python@3.11
</code></pre>

<h3>环境变量</h3>

<p>解释器在运行代码的时候用到一些库，核心module以及三方module，那么解释器是如何找到这些东西的呢？</p>

<ul>
<li>PYTHONHOME 这是解释器的安装目录，通常用作module搜索的前缀来使用</li>
<li>PYTHONPATH 这是模块module的搜索目录，默认的是sys.path，这个是由Python预定义好了的，通过PYTHONPATH指定的搜索目录会加在sys.path的前面。所以如果想指定额外的Module目录或者想替换掉默认的module时就可以使用此变量。</li>
</ul>


<p>除了一些解释器需要的底层的动态库之外，最重要的就是模块module目录了，默认的module搜索目录由sys.path定义，可以通过两种方式查看它有哪些路径：</p>

<pre><code class="bash">➜  ~ python3 -m site
sys.path = [
    '/Users/alexhilton',
    '/Library/Frameworks/Python.framework/Versions/3.7/lib/python37.zip',
    '/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7',
    '/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/lib-dynload',
    '/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages',
]
USER_BASE: '/Users/alexhilton/Library/Python/3.7' (doesn't exist)
USER_SITE: '/Users/alexhilton/Library/Python/3.7/lib/python/site-packages' (doesn't exist)
ENABLE_USER_SITE: True
</code></pre>

<p>或者通过代码：</p>

<pre><code class="python3">➜  ~ python3
Python 3.7.3 (v3.7.3:ef4ec6ed12, Mar 25 2019, 16:52:21) 
[Clang 6.0 (clang-600.0.57)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; import sys
&gt;&gt;&gt; print(sys.path)
['', '/Library/Frameworks/Python.framework/Versions/3.7/lib/python37.zip', '/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7', '/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/lib-dynload', '/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages']
&gt;&gt;&gt; exit()
</code></pre>

<p>可以看到，它会包含当前路径，以及预定义的一些目录。重点看site-packages这个目录，这是所有第三方module安装的目录，Python的包管理工具pip也都是安装在些位置的。所以说，用pip安装完成后，不用特殊指定目录就能找到module。</p>

<h3>解决多版本的site-pakcages冲突</h3>

<p>每一个解释器都能找到它的site-packages，换句话说如果装了不同版本的Python，就会有多个site-packages路径。就比如，在我的电脑上面有三个版本的Python：</p>

<ul>
<li><p>Python2
系统中的默认python指向Python2
/usr/bin/python  2.7.16
site packages: &lsquo;/Library/Python/2.7/site-packages&rsquo;,</p></li>
<li><p>Python3.7
系统带有Python3，由命令/usr/local/bin/python3指向 /Library/Frameworks/Python.framework/Versions/3.7/bin/python3
site packages &lsquo;/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/site-packages&rsquo;,</p></li>
<li><p>Python3.11
由brew升级安装得到的。被安装在
二进制是在：/usr/local/opt/<a href="&#109;&#x61;&#105;&#x6c;&#116;&#x6f;&#x3a;&#112;&#121;&#116;&#104;&#111;&#x6e;&#x40;&#x33;&#46;&#49;&#49;">&#x70;&#x79;&#x74;&#104;&#111;&#110;&#64;&#x33;&#x2e;&#49;&#x31;</a>
site-packages  /usr/local/lib/python3.11/site-packages</p></li>
</ul>


<p>那么，假如想要把三个site-packages里面的module都得到使用的话，就可以用<strong>PYTHONPATH</strong>来把三个路径都加进来。</p>

<h2><a href="https://www.jetbrains.com/pycharm/">IDE(PyCharm)</a></h2>

<p>对于集成开发环境（IDE）来说，也是可以配置的，几乎都可以配置从解释器，到环境变量都是<a href="https://intellipaat.com/blog/tutorial/pycharm-tutorial/how-to-configure-pycharm-interpreter/?US">可以配置的</a>。</p>

<p><img src="https://intellipaat.com/blog/wp-content/uploads/2020/01/i5-768x495.png" alt="" /></p>

<h2><a href="https://pypi.org/project/pip/">pip</a></h2>

<p>pip是Python的<a href="https://pypi.org/project/pip/">包管理工具</a>，可以用它来安装Python生态中的第三方module，可以理解为apt-get之于Ubutu，brew之于Mac，只不过pip能安装都是Python的module。基础的使用教程可以<a href="https://www.runoob.com/w3cnote/python-pip-install-usage.html">看这里</a>。</p>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.lnjh5MWQRVvUHrqx4TH1SwHaHa?pid=ImgDet&amp;rs=1" alt="" /></p>

<p><strong>注意</strong>：pip是与Python版本绑定的，比如pip对应于Python2，pip3对应Python3，因为它是包管理工具，它下载的module都会安装在对应的site-packages里面，而从前面的讨论知道每个解释器是有自己的site-packages，因此pip要对其解释器对应，这样才能安装到正确的位置上。</p>

<p>这样就会有问题，比如安装了多个版本，那么最后一个安装的Python版本的pip会把之前的都覆盖掉。比如我的电脑上最后用brew安装了Python 3.11，然后pip就被替换成了python3.11的，且pip与pip3是一样的了，它安装的module都是在Python 3.11的那个site-packages里面。</p>

<pre><code class="bash">➜  ~ pip3 --version
pip 23.1.2 from /usr/local/lib/python3.11/site-packages/pip (python 3.11)
➜  ~ pip --version
pip 23.1.2 from /usr/local/lib/python3.11/site-packages/pip (python 3.11)
</code></pre>

<p>注意，因为/usr/local/bin/python3 仍链向了系统预装的python3.7，所以3.11并未有真正的安装成功，最后的系统链接并未有完全修改掉，比如python3仍指向预装的3.7。但比较神奇的是pip被替换为了3.11的。而且，它的site位置也与预装 的不一致了。因为我之前已经用pip3安装了很多三方Module，安装了Python3.11后突然报错找不到module了，原因就在于，现在pip认识的site 位置（3.11的），只有比较少的库，而原来的，仍在原来的位置。</p>

<h2><a href="https://docs.python.org/3/tutorial/venv.html">Virtual Environment</a></h2>

<p>由于可能有多个Python版本，会有不同的site-packages，可能会比较混乱，因此就有了虚拟运行环境这一个的技术，它可以为某一个项目，或者某一类项目设定一个虚拟运行环境，在这个环境里面可以安装任何module，它与宿主操作系统，和其他虚拟环境都是隔离的，互不影响。</p>

<p><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.xF4itTOl_0EWotnQsd7IJAHaEL?pid=ImgDet&amp;rs=1" alt="" /></p>

<p>虚拟环境还能解决依赖地狱问题，比如A项目需要依赖一个1.0版本的module C，但B项目却需要依赖1.4版本的module C，这时如果都在操作系统本机环境去折腾就相当麻烦，也极容易打破项目的稳定性，甚至会影响操作系统的稳定性。这时虚拟环境就能很好的解决这个问题。</p>

<h3><a href="https://docs.python.org/zh-cn/3/library/venv.html">venv</a></h3>

<h3><a href="https://pypi.org/project/virtualenv/">virtualenv</a></h3>

<h3>How it works</h3>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.knowledgehut.com/blog/programming/run-python-scripts">How To Run Your Python Scripts</a></li>
<li><a href="https://indianpythonista.wordpress.com/2018/01/04/how-python-runs/">How Python runs?</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/341481537">python虚拟环境管理工具venv教程</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/338424040">Python虚拟环境Virtualenv详解</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/269805011">如何使用 virtualenv 创建 Python 虚拟环境？</a></li>
<li><a href="https://www.infoworld.com/article/3239675/virtualenv-and-venv-python-virtual-environments-explained.html">Virtualenv and venv: Python virtual environments explained</a></li>
<li><a href="https://www.cnblogs.com/doublexi/p/15783355.html">python多环境管理（venv与virtualenv）</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python字符串编码答疑]]></title>
    <link href="http://toughcoder.net/blog/2020/03/06/understanding-python-string-encoding/"/>
    <updated>2020-03-06T22:21:49+08:00</updated>
    <id>http://toughcoder.net/blog/2020/03/06/understanding-python-string-encoding</id>
    <content type="html"><![CDATA[<h2>Python 2中的字符串分类</h2>

<p>在Python 2中字符串，有两个类型，一个是str，一个是unicode。str可以理解为ASCII的字符列表，说白了，只能存储ASCII字符，如果赋个中文值，会报错；而unicode是支持非ASCII字符的。这个与C语言中的字符非常类似char[]只能存ASCII字符串，而wchar[]才可以存储Unidcode字符串。</p>

<p><a href=""><img src="https://www.kodefork.com/media/uploads/articles/2019/06/23/python-strings.png"></a></p>

<!-- more -->


<p>可以用如下方式来安全的转换两种字符串：</p>

<pre><code class="python">def to_str(foo):
   if foo instanceof unicode:
      return str(foo)
   else:
      return foo

def to_unicode(bar):
   if bar instanceof str:
      return unicode(bar)
   else:
      return bar
</code></pre>

<p>对于字面字符串，前面加上u来标识是一个unicode，否则会当成str：</p>

<pre><code class="python">a = 'this is a string'
b = u'nah, I am a unicode'
</code></pre>

<h2>Python 3中的字符串分类</h2>

<p>由于Python 2中的混乱，所以到了Python 3里面，有了新的定义，字符串类型是str，支持Unicode，另外多了一个类型bytes，可以理解为byte的列表，也即是0&lt;=且&lt;=256的无符号整数，或者说是ASCII字符，简单来理解意思是一样的。这个就与Java语言类似了，如同Java中一样，String支持unicode，另专门有byte类型。另外，对于字面字符串也无需要再要标识了。</p>

<p>str与bytes之间的关系与区别是，str是给人看的，而bytes是给机器看的，bytes是str的底层实现。所以，bytes处理起来更快，效率更高，一些底层的IO库以及像网络IO，用的数据 一般都是bytes。它们之间是可以互转的：</p>

<ul>
<li>str转为bytes叫encode</li>
<li>bytes转为str叫decode</li>
</ul>


<p>在转换的时候还需要指定编码格式，这个编码格式就是unicode的编码方式，默认是&#8217;utf-8&#8217;，这里就涉及Unicode编码解码的相关知识了，常见的就是&#8217;utf-8&#8217;，&#8217;unicode&#8217;，以及&#8217;gbk&#8217;等。可以用如下方法来安全的转换：</p>

<pre><code class="python">def to_bytes(foo):
   if foo instanceof str:
      return foo.encode()
   else:
      return foo
def to_str(bar):
   if bar intanceof bytes:
      return bar.decode()
   else:
      return bar
</code></pre>

<h2>注意区分两个编码格式</h2>

<p>需要注意区分两个编码格式的设置，一个是指定程序里面字符串的编码，如在encode()和decode()时指定编码格式。</p>

<p>另外，一个就是程序源文件的编码格式，这个容易被忽略，要详细说下：程序的源码，其实就是一个文本文件，对吧，那么这个文本文件也是要指定编码格式的，常规来说，Python程序应该都是ASCII字符，所以默认的呢Python解释器，是按照ASCII文本的方式来处理代码源文件，但我们代码里面是会出现Unicode字符的，比如字面字符串，或者写的注释，如果 不进行特殊的设置解释器会报错的，因为出现了它不认识的字符。这时就需要对源码文件设置一下编码格式，把这句加在代码源文件的最上面，就好了：</p>

<pre><code class="python"># -*- coding: utf-8 -*-
</code></pre>

<h2>如何解决未知编码格式</h2>

<p>关于编码最容易遇到的就是UnicodeDecodeError，后面跟着一坨详细信息，这个错误就是告诉你编码时出问题了，通常有两类错误：</p>

<ul>
<li><p>UnicodeDecodeError: &lsquo;ascii&rsquo; codec can&rsquo;t decode byte 0xe4 in position 0: ordinal not in range(128)</p>

<p>这个通常是在Python 2时会遇到，原因简单的来说就是把unicode当成了string，或者源码文件的编码格式不对。解决的办法就是按照 上面介绍的安全转换方法，另外要设置一下源码文件的编码格式，这个问题自然可解。</p></li>
<li><p>Python3.6 UnicodeDecodeError: &lsquo;utf8&rsquo; codec can&rsquo;t decode byte 0xb2 in position 24137: invalid start byte</p>

<p>这个通常是在Python 3时面遇到的，后面的具体信息会不一样，这个问题会发生在bytes转化为string，decode时会报出，原因就是指定的解码方式与真实的不匹配，无法成功decode，比如，bytes是「gtk」的，但是用&#8217;utf-8&#8217;去decode肯定会失败。这个问题，在写爬虫或者一些文本处理时经常遇到，因为来源的编码方式不固定。</p>

<p>这个问题，如果想要根解，必须预知来源bytes的编码格式，但这通常不可能，所以可行的一条方案是，用一坨编码方式来不停的尝试：</p>

<pre><code class="python">def safe_decode(source):
   encodeings = ['utf-8', 'gbk', 'utf-16']
   for en in encodeings:
      try:
         return source.decode(en)
      except UnicodeDecodeError as e:
         print('Failed: ', e)
   return source
</code></pre></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Python 2升级到Python 3的指导建议]]></title>
    <link href="http://toughcoder.net/blog/2020/03/05/guide-of-upgrade-from-python-2-to-python-3/"/>
    <updated>2020-03-05T23:51:53+08:00</updated>
    <id>http://toughcoder.net/blog/2020/03/05/guide-of-upgrade-from-python-2-to-python-3</id>
    <content type="html"><![CDATA[<p>&ldquo;Life is short, we must upgrade to Python 3&rdquo;</p>

<p>Python是一个非常好用的工具语言，哪怕主业中用不到它，到处可见到一些非常实用的小的工具都是用Python来写的，即使再小的工具，也要做到小而美，这是工匠精神的体现。在社区里面Python 2已经停止开发新功能了，仅维护并修复一些bug，未来也将会停止维护，有些平台已经默认用python3了。除非有些无法替换的依赖必须强制使用Python 2以外，建议要升级到Python 3。本篇记录一些朕在升级到Python 3时遇到的一些问题，也即升级的时候的一些指导提示。</p>

<p><a href=""><img src="https://miro.medium.com/max/2156/1*HacaJfdu7HF8V4gIoA98ww.png"></a></p>

<!-- more -->


<h2>Python 2与Python 3的区别</h2>

<h3>两个版本并不兼容</h3>

<p>就像刚接触Python时，竟然发现它有两个版本，而且它们还不兼容，具体原因可能是因为时代的发展，编程语言也在不断的进步，而Python语言并不年轻，所以可能会导致新的编程语言设计思想在老的版本上面不好去兼容，很多软件都会有这样的问题，当有跨度比较大的升级时，相当于重新设计了，基本上是取代而非升级，因为老版本的设计架构等原因，是无法兼容的。</p>

<p>姑且不管啥原因吧，我们要明白一个事实就是Python 2与Python 3是不兼容的，意思就是，如果按照Python 2写的一段代码，用Python 3的解释器去运行，会报错，无法运行，反之亦然。</p>

<h3>两个版本的主要区别</h3>

<p>关于两方面的区别，可以看一看<a href="https://www.cnblogs.com/aguncn/p/3427531.html">这篇文章</a>，写的比较详细，这里就不重复了，只是罗列一些最常用的，也是最显著的一些需要注意的地方：</p>

<h4>print</h4>

<p>在Python 2里面啊，print是一个语言关键字，就像if when一样，它是一个独立的语句，想输出啥东西时，都是直接在print后面写就行了：</p>

<pre><code class="python">print 1, 2, 3
print 'Security code is ', a, b, c
</code></pre>

<p>而Python 3里面，print是一个内置函数，必须带有()才算函数调用，这里不纠结语句与函数的区别，只需要记得，现在要在print后面加上括号就可以了，下面的代码与上面效果等同：</p>

<pre><code class="python">print(1, 2, 3)
print('Security code is ', a, b, c)
</code></pre>

<h4>字符串编码</h4>

<p>这个可能是最复杂的和令人困惑的，根本的原因在于Python 2中的字符串与编码问题很绕，而Python 3中就清晰多了。</p>

<p>在Python 2里面字符串与字符的类型是不一样的，它与上一代的编程语言（C）有点类似，ASCII的与Unicode是不同的类型：</p>

<pre><code class="python">a = 'abcd'
b = u'早上好'
</code></pre>

<p>这里面a是一个string，而b是一个unicode str，如果 不加u，直接写unicode字符会报错的，可以通过unicode函数转化为unicode str，以及通过str函数转化为ASCII字符串。</p>

<p>而在Python 3中不再这么绕了，它就一种字符串类型str，支持unicode，所以你可以直接写了：</p>

<pre><code class="python">a = 'abcd'
b = '下午好'
</code></pre>

<p>可以简单的来理解，把Python 2里的字串想像为C语言，而Python 3的字串相像为Java就可以了。</p>

<p><strong>注意</strong>： 关于字串与编码比较复杂，后面会单独的文章来介绍。</p>

<h4>重要模块的迁移</h4>

<p>大部分的模块是没有变动的，也即import时没有变化，但是有一些有比较大的变化，原因也是相关的代码在设计上有了重大变更，最明显的就是HTTP相关，原来比较乱有httplib, cookie, urllib2等一坨，现在都集中在了urllib里面。详细的可参见上面推荐的文章。</p>

<h4>遍历字典和列表</h4>

<p>字典遍历有变化 ：</p>

<pre><code class="python"># data is a dictionary
for k, v in data.items(): # not iteritems()
   print('{} -&gt; {}.format(k, v))
</code></pre>

<p>遍历平行列表时有变化 ：</p>

<pre><code class="python"># sections, departments are lists
for s, d in zip(sections, departments):
   print(s, d)
</code></pre>

<p>而在Python 2里面必须 这样写：</p>

<pre><code class="python">import itertools
for s, d in itertools.zip(sections, departments):
   print s, d
</code></pre>

<h2>解释器的选择</h2>

<p>上面是代码层面的区别和要注意的点，代码写好了要执行啊，执行的时候也需要注意，用错了解释器，还是跑不通的。</p>

<p>目前大部分的平台上面（Ubuntu和Mac OSX）的系统默认解释器还是2.7.x版本的：</p>

<pre><code class="bash">[-&gt; ~] which python
/usr/bin/python
[-&gt; ~] ll /usr/bin/python
/usr/bin/python -&gt; python2.7
</code></pre>

<p>但是呢，不建议强行把系统的默认解释器换成Python 3，这可能会导致系统出问题，我们直接让我们的脚本用Python 3来运行就可以了，在shebang中改：</p>

<pre><code class="python">#!/usr/bin/env python3
</code></pre>

<p>或者如果是使用PyCharm的话，在项目配置上直接选择Python 3的解释器就好了。</p>

<h2>用pip3安装依赖</h2>

<p>同时，安装需要的依赖时也使用pip3而非pip：</p>

<pre><code class="bash">sudo apt-get install python3-pip
pip3 install --upgrade pip
pip3 install pandas
</code></pre>

<h2>思维的转变</h2>

<p>这里仅是罗列出一些非常显著 的变化 ，实际上远不止这些，大版本的跳跃哪能就这么一点变化呢，还有想当多的细节问题可能会在日常使用中遇到。</p>

<p>这里想说的是如果遇到问题，比如在Python 3中报错了，或者某个问题不知道怎么搞，在搜索答案时，或者寻求帮助时记得直接搜索『Python 3』，这会比较明确的把范围限定 在Python 3里面。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://medium.com/@rajputankit22/upgrade-python-2-7-to-3-6-and-3-7-in-ubuntu-97d2727bf911">Upgrade python 2.7 to 3.6 and 3.7 in Ubuntu</a></li>
<li><a href="https://www.cnblogs.com/aguncn/p/3427531.html">使用2to3将代码移植到Python 3-转</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
