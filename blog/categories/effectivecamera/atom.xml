<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectivecamera | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/effectivecamera/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2022-03-07T22:17:09+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Camera 2教程之预览与加强]]></title>
    <link href="http://toughcoder.net/blog/2022/03/04/camera-2-preview-and-improvement/"/>
    <updated>2022-03-04T19:27:56+08:00</updated>
    <id>http://toughcoder.net/blog/2022/03/04/camera-2-preview-and-improvement</id>
    <content type="html"><![CDATA[<p><a href="http://toughcoder.net/blog/2022/02/28/camera2-api-made-easy/">前一篇文章</a>讲解了如何使用这套新的API，但仍有很多可以提升的空间，这篇重点来讲讲，如何提升预览画质和做一些加强。</p>

<p><a href=""><img src="https://www.edumobile.org/wp-content/uploads/2015/05/Camera-Preview-Example-in-Android-Programming.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>线程模型</h2>

<p>因为相机是属于硬件，操作起来可能会耗时，这套新的API也特别注意，因此加了很多异步化处理，所有的请求结果全是通过回调来进行的，并且需要调用者来指定一个回调所使用的线程。因此，我们需要一个专门用于camera操作的线程，用HandlerThread就可以，并把它控制在Activity的生命周期之中，比如在onCreate时启动此线程，在onDestroy时关闭。</p>

<pre><code class="java">    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        attachCameraThread();
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
         detachCameraThread();
    }
</code></pre>

<p>所有与camera相关的操作，均要在相机专属的HandlerThread中调用，与其他线程（如主线程）的交互均通过回调处理。</p>

<h2>关键对象</h2>

<p>为了进一步的封装和方便管理，需要两个关键对象的封装。</p>

<h3>CameraContext</h3>

<p>一个是CameraContext，负责管理相机的线程，外部所有的方法调用均应该通过它来进行，我们的目的是要把所有的相机相关操作封装在自己的线程里面，因此，暴露给外面的接口，必须统一，并且在开放的方法中加入线程检查，如果还没有启动HandlerThread，就报错，调用者需要先attachThread：</p>

<pre><code class="java">public class CameraContext {
    private static final String LOG_TAG = CameraContext.class.getSimpleName();

    private final CameraManagerWrapper cameraManager;
    private volatile HandlerThread cameraManageThread;
    private volatile CameraThreadHandler cameraThreadHandler;

    private volatile CameraAgent currentCamera;

    public CameraContext(Context context) {
        cameraManager = new CameraManagerWrapper(context);
    }

    public void attachThread() {
        Log.d(LOG_TAG, "attachThread");
        if (cameraThreadHandler != null) {
            cameraThreadHandler.removeCallbacksAndMessages(null);
        }
        if (cameraManageThread != null &amp;&amp; cameraManageThread.isAlive()) {
            cameraManageThread.quitSafely();
        }
        cameraManageThread = new HandlerThread("Camera Management Thread");
        cameraManageThread.start();
        cameraThreadHandler = new CameraThreadHandler(cameraManageThread.getLooper());
    }

    public void detachThread() {
        Log.d(LOG_TAG, "detachThread");
        if (cameraManageThread != null &amp;&amp; cameraManageThread.isAlive()) {
             cameraManageThread.quitSafely();
        }
    }

    private void checkThread() {
        if (cameraManageThread == null || !cameraManageThread.isAlive()) {
            throw new CameraSetupException("attachThread must be called before any other method invocations.");
        }
    }

    public void openCamera(Consumer&lt;String&gt; consumer) {
        checkThread();
        Runnable actionOpen = () -&gt; {
              // ...
        };
        Message msg = Message.obtain(cameraThreadHandler, actionOpen);
        msg.what = CameraThreadHandler.MSG_OPEN_CAMERA;
        msg.sendToTarget();
    }

    public void closeCamera() {
        checkThread();
        Runnable actionClose = null;
        Message msgClose = Message.obtain(cameraThreadHandler, actionClose);
        msgClose.what = CameraThreadHandler.MSG_CLOSE_CAMERA;
        msgClose.sendToTarget();
    }
}
</code></pre>

<h3>CameraAgent</h3>

<p>还需要对CameraDevice进行封装，把CameraCaptureSession，以及RequestBuilder，封装在内，并且在三大回调Device State Callback，Session State Callback以及Session Capture Callback也都封装在内，因此这些东西的生命周期全都是在CameraDevice内部的。</p>

<p>设计要点：</p>

<ul>
<li>CameraAgent不开放接口给外部，它只能开放给CameraContext使用</li>
<li>对象是对camera device的完整封装，对象本身一直可用，与CameraDevice是否打开无直接关系</li>
<li>随时可以查询静态配置属性，创建对象时就要传入id和CameraCharacteristics</li>
<li>有连接状态，也即打开对应的CameraDevice，动态配置属性查询，以及像启动预览，必须要是连接状态</li>
<li>拍照应该在预览状态内</li>
</ul>


<pre><code class="java">class CameraAgent {
    private static String LOG_TAG = CameraAgent.class.getSimpleName();
    private final String id;
    private final CameraCharacteristics characteristics;
    private final CameraContext.CameraThreadHandler cameraHandler;
    private final Executor executor;

    private Optional&lt;CameraDevice&gt; cameraDevice;
    private Optional&lt;CameraCaptureSession&gt; captureSession;

    private CameraDevice.StateCallback stateCallback = new CameraDevice.StateCallback() {
        @Override
        public void onOpened(@NonNull CameraDevice camera) {
            Log.d(LOG_TAG, "Device Status: onOpened");
            cameraDevice = Optional.of(camera);
        }

        @Override
        public void onDisconnected(@NonNull CameraDevice camera) {
            Log.d(LOG_TAG, "Device Status: onDisconnected");
            cameraDevice = Optional.empty();
        }

        @Override
        public void onError(@NonNull CameraDevice camera, int error) {
            cameraDevice = Optional.empty();
        }
    };

    private CameraCaptureSession.StateCallback regularSessionCallback = new CameraCaptureSession.StateCallback() {
        @Override
        public void onConfigured(@NonNull CameraCaptureSession session) {
            Log.d(LOG_TAG, "Session State: onConfigured");
            captureSession = Optional.of(session);
        }

        @Override
        public void onConfigureFailed(@NonNull CameraCaptureSession session) {
            captureSession = Optional.empty();
        }

        @Override
        public void onClosed(@NonNull CameraCaptureSession session) {
            Log.d(LOG_TAG, "Session State: onClosed");
            super.onClosed(session);
            captureSession = Optional.empty();
        }
    };

    private CameraCaptureSession.CaptureCallback captureCallback = new CameraCaptureSession.CaptureCallback() {
        @Override
        public void onCaptureStarted(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, long timestamp, long frameNumber) {
            super.onCaptureStarted(session, request, timestamp, frameNumber);
        }
    };

    private CaptureRequest.Builder requestBuilder;

    CameraAgent(String id, CameraCharacteristics cameraCharacteristics, CameraContext.CameraThreadHandler handler) {
        this.id = id;
        this.characteristics = cameraCharacteristics;
        this.cameraHandler = handler;
        executor = command -&gt; handler.post(command);

        cameraDevice = Optional.empty();
        captureSession = Optional.empty();
        previewSize = Optional.empty();
        errorCode = 0;
    }

    String getId() {
        return id;
    }

    boolean connected() {
        return cameraDevice.isPresent();
    }

    CameraDevice.StateCallback getDeviceStateCallback() {
        return stateCallback;
    }

    void connect(@NonNull CameraManagerWrapper wrapper) {
        Log.d(LOG_TAG, "connect");
        wrapper.openCamera(this, cameraHandler);
    }

    void disconnect() {
        Log.d(LOG_TAG, "disconnect");
        if (captureSession.isPresent()) {
            captureSession.get().close();
        }
        if (cameraDevice.isPresent()) {
            cameraDevice.get().close();
        }
    }

    void startPreview() {
    }

    void stopPreview() {
    }
}
</code></pre>

<h2>启动预览</h2>

<p>新的这套API并没有直接设置预览大小或者图片大小的地方，camera的输出都是Surface，底层是通过Surface的大小来做具体的尺寸。本质上都是数据在流动，其实都是buffer，Surface也是buffer，设定了Surface的大小，也就确定了输出buffer的大小，camera硬件也就知道了大小。</p>

<h3>用SurfaceView就可以</h3>

<p>预览是camera的输出，是另外一些组件的输入，API设计已做好了衔接，Surface就是中间的桥梁，Surface作为SurfaceView（可理解为屏幕）的输入，它可以作为camera的输出，由此便把camera的预览显示了出来。在布局文件中用SurfaceView来充当Activity的布局，由此便能得到Surface，再把它塞给camera即可。</p>

<p>需要重点说一下尺寸的约束，想让预览的Surface反应camera预览的尺寸，因此SurfaceView要是wrap_content的。</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@color/black"
    tools:context=".CameraActivity"&gt;

    &lt;net.toughcoder.effectivecamera.AutoFitSurfaceView
        android:id="@+id/view_finder"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintLeft_toLeftOf="parent"
        app:layout_constraintLeft_toRightOf="parent"
        app:layout_constraintBottom_toBottomOf="parent" /&gt;
&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;
</code></pre>

<h3>如何选择预览尺寸</h3>

<p>输入的约束条件是一个比例，比如流行的预览比例是4：3，16：9或者全屏，这个比例是长边与短边的比值，这个可以作为用户体验层面的一个约束，或者叫做设置，尺寸的选择应该遵守此约束。</p>

<p>另外一个约束就是屏幕尺寸，预览的大小应该能刚好满足屏幕尺寸即可，超出屏幕其实就浪费了，没有必要。</p>

<p>所以，选择预览尺寸的策略就是保证比例和刚好满足屏幕。</p>

<p>每个camera都有支持的一组预览尺寸，按照 我们的策略从其中选择一个就可以了。预览尺寸从静态配置中就可以读得到，不需要连接状态，因此，可以在创建好CameraAgent对象后就可以进行尺寸选择，屏幕尺寸随时可获利，比例约束是一个设置随时可读取，因此这是可行的。</p>

<p>当选择好了预览尺寸后，要把它设置到SurfaceView中去，以让SurfaceView调整自身的大小。</p>

<pre><code class="java">    /*
     * Strategies:
     *  1) preview size should not be bigger than screen, which is not necessary.
     *  2) ratio should match.
     *  3) pick the largest one.
     *  4) if not found, use screen size.
     */
    private Optional&lt;CameraSize&gt; calculatePreviewSize(Point screenSize, float ratio) {
        int width = Math.min(screenSize.x, screenSize.y);
        int height = Math.min(Math.round(width * ratio), screenSize.y);
        final int limit = screenSize.x * screenSize.y;
        Log.d(LOG_TAG, "screen size " + screenSize.x + " x " + screenSize.y +
                ", ratio " + ratio + ", desired width-&gt;" + width + ", height-&gt;" + height);

        StreamConfigurationMap streamMap = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
        Size[] surfaceSizes = streamMap.getOutputSizes(Surface.class);
        if (surfaceSizes == null) {
            surfaceSizes = streamMap.getOutputSizes(ImageFormat.PRIVATE);
        }
        List&lt;CameraSize&gt; supportedSize = Arrays.asList(surfaceSizes)
                .stream()
                .map(CameraSize::new)
                .filter(size -&gt; size.height * size.width &lt;= limit)
                .sorted(CameraSize::compare)
                .collect(Collectors.toList());
        Log.d(LOG_TAG, "supportedSize " + supportedSize);
        return supportedSize.stream().filter(size -&gt; size.matchRatio(ratio)).findFirst();
</code></pre>

<h2>确保关闭</h2>

<p>相机是一种硬件资源，当退出的时候要能确保它是关闭状态的，也就是说要确保CameraAgent#disconnect能执行，且要执行完成，执行完成的意思是，你需要收到onDisconnected的回调。</p>

<p>这就要求我们在detachThread，即退出相机线程的时候，要小心处理好尚未来得及执行（如有）的操作，因为所有的操作都会转到相机线程中去，是通过消息队列，所以操作可能还在排队中尚未真正执行。</p>

<p>具体做法是，直接移除掉未得到执行的open和其他操作。如果有pending状态的关闭，则要先让其执行，并且把关闭线程的操作放到CameraDevice State Callcback的onDisconnect中，也就是说待CameraDevice完全关闭完成后，才可以终止相机线程：</p>

<pre><code class="java">    public void detachThread() {
        Log.d(LOG_TAG, "detachThread");
        if (cameraThreadHandler != null) {
            // Drop all pending open actions
            cameraThreadHandler.removeMessages(CameraThreadHandler.MSG_OPEN_CAMERA);
            if (cameraThreadHandler.hasMessages(CameraThreadHandler.MSG_CLOSE_CAMERA)) {
                // Ensure close actions are dispatched.
                try {
                    Thread.sleep(50);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            // Drop all other messages.
            cameraThreadHandler.removeCallbacksAndMessages(null);
        }
        // TODO: technically speaking, should do this in handler thread
        // since all connect/disconnect are done inside handler thread
        // status might not be synced with caller's thread.
        if (cameraManageThread != null &amp;&amp; cameraManageThread.isAlive()) {
            if (currentCamera != null &amp;&amp; currentCamera.connected()) {
                currentCamera.addDisconnectedAction(() -&gt; cameraManageThread.quitSafely());
            } else {
                cameraManageThread.quitSafely();
            }
        }
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Camera2 API Made Easy]]></title>
    <link href="http://toughcoder.net/blog/2022/02/28/camera2-api-made-easy/"/>
    <updated>2022-02-28T23:42:34+08:00</updated>
    <id>http://toughcoder.net/blog/2022/02/28/camera2-api-made-easy</id>
    <content type="html"><![CDATA[<p>从Android 5.0 （API 21）开始谷歌废弃了<a href="https://developer.android.com/reference/android/hardware/Camera">Camera</a>，并提供了一套新的API，称之为<a href="https://developer.android.com/reference/android/hardware/camera2/package-summary">Camera 2</a>，不再是大而全的一个类了，也使用了更多的回调以异步化，流程与参数的控制更加的灵活，但也变得更加的复杂了，今天就来学习一下这套新API的使用方法。</p>

<p><a href=""><img src="https://www.upphone.com/wp-content/uploads/2020/07/android-camera-settings.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>基本使用大法</h2>

<p>新的这一套API使用起来略复杂，涉及的较多的对象，可以按照如下步骤来使用。</p>

<h3>Step 1: 申请相机使用权限</h3>

<p>自从Android M（6.0）以后，对权限的限制比以前严格多了，必须要在运行时动态的去申请权限，征得用户同意后，方可正常使用。</p>

<p>需要在AndroidManifest中声明相机权限：</p>

<pre><code class="xml">&lt;uses-permission android:name="android.permission.CAMERA" /&gt;
</code></pre>

<p><strong>注意</strong>：官方还建议在manifest中声明<a href="https://developer.android.com/guide/topics/manifest/uses-feature-element?hl=en">use camera feature</a>，但用处不大，这主要是给Google Play用的，Google Play可以根据这些方便精准投递你的app，如设备无camera硬件，或者硬件配置不支持，就不会安装，但就国内的市场来说基本用不到。</p>

<p>但这还不够，还需要在运行时动态检查，如果未授权，则要去申请，如仍被用户拒绝，则可直接退出，因为相机应用嘛，没有相机权限啥也做不了。一般来说，这个过程放在onCreate中做就可以了：</p>

<pre><code class="java">    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_camera);

        if (ContextCompat.checkSelfPermission(getApplicationContext(), Manifest.permission.CAMERA) ==
                PackageManager.PERMISSION_GRANTED) {
            setupCamera();
        } else {
            requestPermissions(new String[]{Manifest.permission.CAMERA}, REQ_CODE_PERM);
        }
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        if (requestCode == REQ_CODE_PERM) {
            if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                setupCamera();
            } else {
                Toast.makeText(getApplicationContext(),
                        "To use this app you must grant CAMERA permission.",
                        Toast.LENGTH_LONG).show();
                finish();
            }
        }
    }
</code></pre>

<p><strong>注意</strong>：不建议放在onResume中去做，因为可能会造成死循环，比如权限申请，虽然看起来像一个对话框，但其实是一个Activity，也就是说从权限授权那个弹窗页面回来，是会走onResume的，如果用户同意授予了还好，直接就往下走流程了，假如用户拒绝了权限，检查发现权限还未授予，会继续去申请，这就会死循环了。</p>

<p>权限申请是必须要做，且要处理好，在应用的入口做好处理，保证后面的流程权限是有的，这样可以为业务逻辑减轻复担，里面就可以不用管权限了。基于这样的假设：要么权限已授予，要么就不会走进来（无权限时应该直接退出）。</p>

<h3>Step 2: 获取相机的配置情况</h3>

<p>处理好了权限以后，就要真正开始搞了，无论你的use case是什么，第一步肯定 是获取相机的配置信息情况，也就是说要搞清楚有几个硬件camera可以用，它的能力是什么（输出能满足什么样的需求），它的特点是什么（前置还是后置）。这里最主要用到的是就是<a href="https://developer.android.com/reference/android/hardware/camera2/CameraManager">CameraManager</a>对象，它是一个注册在ServiceManager里面的独立service，所以可以通过Context来获取：</p>

<pre><code class="java">cameraManager = (CameraManager) context.getSystemService(Context.CAMERA_SERVICE);
</code></pre>

<p>然后就是获取当前有多少可用的摄像头：</p>

<pre><code class="java">String[] ids = cameraManager.getCameraIdList();
</code></pre>

<p>这个列表就是当前可用的camera，用一个String形式的id来标识，查询具体的摄像头的能力和配置都需要传入对应的id，比如说简单的dump一下信息：</p>

<pre><code class="java">    public void enumerateCameras(Consumer&lt;String&gt; consumer) {
       final List&lt;String&gt; cameraIds = cameraManager.getCameraIdList();
       List&lt;String&gt; status = cameraIds.stream()
                    .map(cameraManager::getCameraCharacteristics)
                    .map(CameraContext::dumpCameraInfo)
                    .collect(Collectors.toList());
    }

    private static String dumpCameraInfo(CameraCharacteristics characteristics) {
        StringBuilder sb = new StringBuilder();
        sb.append("{Physical Id: ");
        sb.append(characteristics.getPhysicalCameraIds());
        sb.append(", Facing: ");
        int facing = characteristics.get(CameraCharacteristics.LENS_FACING);
        sb.append(facing == CameraMetadata.LENS_FACING_FRONT ? "FRONT" : "BACK");
        sb.append("}");
        return sb.toString();
    }
</code></pre>

<p>因为大多数场景都是默认使用后摄，但要先把找出来：</p>

<pre><code class="java">   final List&lt;String&gt; cameraIds = cameraManager.getCameraIdList();
   cameraIds.stream()
            .forEach(id -&gt; {
                        CameraCharacteristics cc = cameraManager.getCameraCharacteristics(id);
                        if (cc.get(CameraCharacteristics.LENS_FACING) == CameraMetadata.LENS_FACING_BACK) {
                            currentCamera = new CameraAgent(id, cc, cameraThreadHandler);
                            return;
                        }
            });
</code></pre>

<p>因为官方的CameraManager封装略差一些，以及它的每一个方法都要检查权限异常，所以做一下进一步的简单封装：</p>

<pre><code class="java">class CameraManagerWrapper {
    private final CameraManager cameraManager;

    public CameraManagerWrapper(Context context) {
        cameraManager = (CameraManager) context.getSystemService(Context.CAMERA_SERVICE);
    }

    public List&lt;String&gt; getCameraIdList() {
        try {
            return Arrays.asList(cameraManager.getCameraIdList());
        } catch (CameraAccessException e) {
            e.printStackTrace();
        }
        return new ArrayList&lt;&gt;();
    }

    public CameraCharacteristics getCameraCharacteristics(String id) {
        try {
            return cameraManager.getCameraCharacteristics(id);
        } catch (CameraAccessException e) {
            e.printStackTrace();
        }
        return null;
    }
}
</code></pre>

<h3>Step 3：打开相机</h3>

<p>找到了摄像头，下一步就可以尝试打开并使用了。通过<a href="https://developer.android.com/reference/android/hardware/camera2/CameraManager#openCamera(java.lang.String,%20android.hardware.camera2.CameraDevice.StateCallback,%20android.os.Handler">CameraManager#openCamera</a>)来获取<a href="https://developer.android.com/reference/android/hardware/camera2/CameraDevice">CameraDevice</a>对象，这里的CameraDevice就是一个摄像头的封装，后面所有的操作都要在它上面进行。还需要提供一个<a href="https://developer.android.com/reference/android/hardware/camera2/CameraDevice.StateCallback">CameraDevice.StateCallback</a>，以及一个Handler，它是用于StateCallback运行的线程，也就是说StateCallback的几个方法都是在Handler所在的线程中运行的。</p>

<p>因为打开摄像头是需要去操作硬件的，所以可能会耗时，因此，在这里引入了异步的回调，用以通知打开的结果CameraManager#openCamera是没有任何返回值的，结果 是通过StateCallback来通知给应用程序，且是运行在指定的<a href="https://developer.android.com/reference/android/os/Handler">Handler</a>中的，如果不传Handler，那么StateCallback就会运行在主线程中。</p>

<pre><code class="java">     private CameraDevice.StateCallback stateCallback = new CameraDevice.StateCallback() {
        @Override
        public void onOpened(@NonNull CameraDevice camera) {
            Log.d(LOG_TAG, "Device Status: onOpened");
            cameraDevice = Optional.of(camera);
        }

        @Override
        public void onDisconnected(@NonNull CameraDevice camera) {
            Log.d(LOG_TAG, "Device Status: onDisconnected");
            cameraDevice = Optional.empty();
            errorCode = 0;
        }

        @Override
        public void onError(@NonNull CameraDevice camera, int error) {
            cameraDevice = Optional.empty();
            errorCode = error;
        }
    };

    cameraManager.openCamera(backId, stateCallback, handler);
</code></pre>

<p>打开操作仅是一个开端，本身也没有特别复杂的，就是需要在StateCallback中做好处理就可以了。</p>

<h3>Step 4： 创建拍照会话</h3>

<p>下一步就是要创建拍照会话，对于每一个CameraDevice，打开了以后，要想使用必须创建一个<a href="https://developer.android.com/reference/android/hardware/camera2/CameraCaptureSession">CameraCaptureSession</a>，所有的use case都需要通过有效的CameraCaptureSeesion对象来实现（如预览和拍照），CameraDevice对象本身提供的功能并不多。与打开类似，也需要提供一个<a href="https://developer.android.com/reference/android/hardware/camera2/CameraCaptureSession.StateCallback">CameraCaptureSession.StateCallback</a>以接收创建session的结果，同时也要提供一个StateCallback使用的线程Handler：</p>

<pre><code class="java">    private CameraCaptureSession.StateCallback regularSessionCallback = new CameraCaptureSession.StateCallback() {
        @Override
        public void onConfigured(@NonNull CameraCaptureSession session) {
            Log.d(LOG_TAG, "Session State: onConfigured");
            captureSession = Optional.of(session);
        }

        @Override
        public void onConfigureFailed(@NonNull CameraCaptureSession session) {
            captureSession = Optional.empty();
        }

        @Override
        public void onClosed(@NonNull CameraCaptureSession session) {
            Log.d(LOG_TAG, "Session State: onClosed");
            super.onClosed(session);
            captureSession = Optional.empty();
        }
    };

    private void createCaptureSession(Surface surface) {
        SessionConfiguration sessionConfig = new SessionConfiguration(
                SessionConfiguration.SESSION_REGULAR,
                Arrays.asList(new OutputConfiguration(surface)),
                executor,
                regularSessionCallback);
        try {
            cameraDevice.get().createCaptureSession(sessionConfig);
        } catch (CameraAccessException ignored) {
        }
    }
</code></pre>

<p>需要注意，同时需要提供一个camera的输出目标，比如预览的Surface。另外就是，创建CaptureSession是有2个API的，以前常用的是<a href="https://developer.android.com/reference/android/hardware/camera2/CameraDevice#createCaptureSession(java.util.List%3Candroid.view.Surface%3E,%20android.hardware.camera2.CameraCaptureSession.StateCallback,%20android.os.Handler">createCaptureSession(List<Surface> outputs, CameraCaptureSession.StateCallback callback, Handler handler)</a>)，但这个方法已被标记为Deprecated的了，推荐使用<a href="https://developer.android.com/reference/android/hardware/camera2/CameraDevice#createCaptureSession(android.hardware.camera2.params.SessionConfiguration">createCaptureSession(SessionConfiguration config)</a>)。这两者基本没区别，所需要传入的参数 都差不多，唯一不同的就是供回调所使用的线程，旧的API是用Handler，新的这个要求是<a href="https://developer.android.com/reference/java/util/concurrent/Executor">Executor</a>，这里有些不太一致，但容易解决，通过Handler可以很容易的创建出来一个Executor：</p>

<pre><code class="java">executor = command -&gt; handler.post(command);
</code></pre>

<h3>Step 5：请求预览</h3>

<p>有了CameraCaptureSession对象以后，就可以启动预览了，这个是相机类应用的最为基础的一个use case。</p>

<p>主要是通过<a href="https://developer.android.com/reference/android/hardware/camera2/CameraCaptureSession#setRepeatingRequest(android.hardware.camera2.CaptureRequest,%20android.hardware.camera2.CameraCaptureSession.CaptureCallback,%20android.os.Handler">setRepeatingRequest</a>)这个方法，需要提供一个<a href="https://developer.android.com/reference/android/hardware/camera2/CaptureRequest">CaptureRequest</a>，一个<a href="https://developer.android.com/reference/android/hardware/camera2/CameraCaptureSession.CaptureCallback">CaptureCallback</a>以及一个供回调使用的Handler，其实，这一步通常与Step 4融合在一起：</p>

<pre><code class="java">        // 省略的代码
        @Override
        public void onConfigured(@NonNull CameraCaptureSession session) {
            Log.d(LOG_TAG, "Session State: onConfigured");
            captureSession = Optional.of(session);
            // In session state callback
            try {
                captureSession.get().setRepeatingRequest(requestBuilder.build(), captureCallback, cameraHandler);
            } catch (CameraAccessException ignored) {
            }
        }
       // 省略的代码

    private CameraCaptureSession.CaptureCallback captureCallback = new CameraCaptureSession.CaptureCallback() {
        @Override
        public void onCaptureStarted(@NonNull CameraCaptureSession session, @NonNull CaptureRequest request, long timestamp, long frameNumber) {
            super.onCaptureStarted(session, request, timestamp, frameNumber);
        }
    };

    private void doStartPreview(Surface surface) {
        SessionConfiguration sessionConfig = new SessionConfiguration(
                SessionConfiguration.SESSION_REGULAR,
                Arrays.asList(new OutputConfiguration(surface)),
                executor,
                regularSessionCallback);
        try {
            requestBuilder = cameraDevice.get().createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);
            requestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CaptureResult.CONTROL_AF_MODE_CONTINUOUS_PICTURE);
            requestBuilder.addTarget(surface);
            sessionConfig.setSessionParameters(requestBuilder.build());

            cameraDevice.get().createCaptureSession(sessionConfig);
        } catch (CameraAccessException ignored) {
        }
    }
</code></pre>

<h2>总结</h2>

<p>前面说了这么多，其实关键的就是三个对象和三个回调，三个对象分别是</p>

<ul>
<li>CameraManager &ndash; 用以获取静态的配置信息</li>
<li>CameraDevice &ndash; 用以创建拍照会话</li>
<li>CameraCaptureSession &ndash; 用以启动预览和进行拍照</li>
</ul>


<p>三大回调分别是：</p>

<ul>
<li>CameraDevice.StateCallback &ndash; 用于获取CameraDevice</li>
<li>CameraCaptureSession.StateCallback &ndash; 用于获取拍照会话</li>
<li>CameraCaptureSession.CaptureCallback &ndash; 用于获取预览和拍照的结果</li>
</ul>


<p>再有就是，提供回调的时候要提供一个回调发生的线程，通过Handler或者Executor来指定。因为硬件操作可能会耗时甚至完全卡死，所以回调和线程是用来实现异步的。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.freecodecamp.org/news/android-camera2-api-take-photos-and-videos/">Android Camera2 – How to Use the Camera2 API to Take Photos and Videos</a></li>
<li><a href="https://juejin.cn/post/6844904062798790663">Android Camera-Camera2使用</a></li>
<li><a href="https://www.jianshu.com/p/9a2e66916fcb">Android Camera2 教程 · 第一章 · 概览</a></li>
<li><a href="https://developer.aliyun.com/article/678342">android Camera2 API使用详解</a></li>
<li><a href="https://blog.csdn.net/afei__/article/details/85342597">Android Camera2 之 CameraDevice 详解</a></li>
<li><a href="https://www.jianshu.com/p/cad777db008e">Camera2开发(2)之CameraDevice类</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Camera App开发学习路线]]></title>
    <link href="http://toughcoder.net/blog/2022/02/11/android-camera-app-ramp-up/"/>
    <updated>2022-02-11T20:59:14+08:00</updated>
    <id>http://toughcoder.net/blog/2022/02/11/android-camera-app-ramp-up</id>
    <content type="html"><![CDATA[<p>对于智能手机来说相机是非常重要的一个功能，它是影像的生产者，是新时代社交（图片，视频）内容的基础。后面我们将重点学习 一下安卓平台的Camera app开发。</p>

<p><a href=""><img src="https://www.xda-developers.com/files/2018/09/best-android-camera.png" title="auto auto" ></a></p>

<!-- more -->


<h2><a href="https://developer.android.com/reference/android/hardware/camera2/package-summary">Camera 2 API</a></h2>

<p>学习如何使用新的API，以实例的方式来学习新一套API如何使用，最终成果将会是一个简单的，具有基础功能的Camera App。</p>

<p>有以下文档可供参考：</p>

<ul>
<li><a href="https://developer.android.com/training/camera2">Official training docs</a></li>
<li><a href="https://developer.android.com/training/camera">Camera</a></li>
</ul>


<p>同时谷歌也有一些官方的样例可供参考：</p>

<ul>
<li><a href="https://github.com/googlearchive/android-Camera2Basic">android-Camera2Basic</a></li>
<li><a href="https://github.com/googlearchive/android-Camera2Video">android-Camera2Video</a></li>
<li><a href="https://github.com/googlearchive/android-Camera2Raw">android-Camera2Raw</a></li>
<li><a href="https://github.com/android/camera-samples">Camera Samples Repository</a></li>
</ul>


<p>AOSP源码中的<a href="https://cs.android.com/android/platform/superproject/+/master:packages/apps/Camera2/">Camera2</a>也是值得学习和参考 的。</p>

<h2>Frameworks</h2>

<p>在学习完API如何使用以后，还需要深入学习一下API下面的框架层。正所谓知其然，更要知其所以然，看了Demo以及文档后谁都会有API，要想加深理解，就必须继续深挖。</p>

<p>这部分没有什么捷径，只能去啃<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/hardware/camera2/">AOSP的源码</a>了。</p>

<h2><a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/av/services/camera/libcameraservice/CameraService.cpp?q=cameraservice">CameraService</a></h2>

<p>这是Frameworks层的最后一环，它连接着Java层和HAL层，主要负责camera device的管理，如权限，打开与关闭的管理，在Android M之前并不是独立的进程，是放在media.server一起的，后来独立成为一个单独的系统级别的进程cameraserver，在ServiceManager中的名字是media.camera，可以通过如下命令查看它的状态：</p>

<pre><code>adb shell dumpsys media.camera
</code></pre>

<h2><a href="https://developer.android.com/jetpack">Jetpack</a>中的<a href="https://developer.android.com/training/camerax">CameraX</a></h2>

<p>这是谷歌封装的库，用以简化API的调用，加快app开发进度。</p>

<h2>深入了解业务架构与技术栈</h2>

<p><a href="https://source.android.google.cn/devices/camera">AOSP中的文档也值得学习</a></p>

<h2><a href="https://source.codeaurora.org/quic/la/platform/packages/apps/SnapdragonCamera/tree/">SnapdragonCamera</a></h2>

<p>相机是技术栈当中最为复杂的一个，SoC平台是至关重要的，所以Qcom的SnapdragonCamera也是值得深入学习的。</p>

<h2>相机业务知识学习</h2>

<h2>封装</h2>

<p>相机是非常受硬件限制的，不同的SoC平台，不同的OEM厂商，以及不同的Android版本，API以及具体细节差异巨大，这给Camera app开发带来非常大的适配工作，那么可以把Camera app核心的业务封装成一个库，这样可以简化开发。</p>

<h2>架构</h2>

<p>如何架构一个Camera app。</p>

<h2>扩展功能</h2>

<p>除基本的拍照录像功能以外，可以扩展一些功能。</p>

<h2>优秀开源项目</h2>

<h3><a href="https://github.com/react-native-camera/react-native-camera">react-native-camera</a></h3>

<h3><a href="https://github.com/CameraKit/camerakit-android">camerakit-android</a></h3>

<h3><a href="https://github.com/google/cameraview">cameraview</a></h3>

<h3><a href="https://github.com/natario1/CameraView">CameraView</a></h3>

<h3><a href="https://github.com/RedApparat/Fotoapparat">Fotoapparat</a></h3>

<h3><a href="https://github.com/Skykai521/StickerCamera">StickerCamera</a></h3>

<h3><a href="https://github.com/CJT2325/CameraView">CameraView</a></h3>

<h3><a href="https://github.com/CainKernel/CainCamera">CainCamera</a></h3>

<h3><a href="https://github.com/aserbao/AndroidCamera">AndroidCamera</a></h3>

<h3><a href="https://github.com/nekocode/CameraFilter">CameraFilter</a></h3>

<h3><a href="https://github.com/florent37/CameraFragment">CameraFragment</a></h3>
]]></content>
  </entry>
  
</feed>
