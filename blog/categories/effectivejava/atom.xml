<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectivejava | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/effectivejava/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2025-02-11T23:19:12+08:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java Annotations Made Easy]]></title>
    <link href="https://alexhilton.github.io/blog/2024/03/24/java-annotations-made-easy/"/>
    <updated>2024-03-24T22:48:07+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/03/24/java-annotations-made-easy</id>
    <content type="html"><![CDATA[<p>在Java编程语言中，注解Annotations是一种元数据，能提供代码以外的信息，是元编程的一种体现形式。注解的引入极大的增强了Java语言的元编程能力，能在编译时生成代码，大大减少了重复代码，让Java具有了相当高的动态特性，让一些高级技术如依赖注入，AOP等成为可能。今天将从基础使用，核心概念理解和创建自定义注解三个角度来彻底学会注解，并学会使用注解来提升开发效率。</p>

<p><a href=""><img src="https://developersjournal.in/wp-content/uploads/2017/06/java-annotations.png" title="auto auto" ></a></p>

<!-- more -->


<h2>基础知识</h2>

<p>注解在代码中使用是非常常见的，相信只要有编程经验的同学都对注解非常的熟悉。</p>

<h3>什么是注解</h3>

<p>Java 注解（Annotation）是JDK5.0及以后版本引入的，它可以用于创建文档，代码分析，编译检查以及编译时生成代码。Java 注解是接口的一种特殊实现，程序可以通过反射来获取指定程序元素的Annotion对象，然后使用该对象来获取注解里面的元数据。</p>

<h3>注解的用法</h3>

<p>注解的使用是非常简洁明了的，Java 注解的基本语法是使用“@”符号来定义一个注解，然后在这个符号后面跟上注解的名字，并在这个名字的后面添加一个括号，括号中是这个注解所需要的参数列表。Java 注解是接口的一种特殊实现，因此注解的定义方式类似于接口的定义方式。Java 注解可以分为三种类型：标记注解、单值注解和完整注解。标记注解没有成员变量，只有一个标记作用；单值注解有一个成员变量；完整注解有多个成员变量。</p>

<h3>内置注解</h3>

<p>Java内置了一些注解，相信写过代码或者看过代码的人都对此非常的了解，因为在代码中是非常非常的常见的。</p>

<ul>
<li>@Override - 用于类的方法上，标记该方法要覆写基类（包括接口）的方法。编译器会对标记的方法作签名检查是否符合覆写规则。</li>
<li>@Deprecated - 可以标记类，成员变量和成员方法为过时的方法，编译器会对调用这些类，成员或者方法给出警告（Compile warnings）。</li>
<li>@SuppressWarnings - 可以用在类和方法上，强制忽略编译警告，即阻止编译器发出编译警告。后面需要加括号，里面传入字符串或者字符串数组代表要忽略的警告类型。</li>
<li>@FunctionalInterface - 这是在Java 8版本中引入的，用在接口上，标记接口是一个函数式接口（即只有一个方法的接口，可以直接用一个lambda来作为接口的实例）。</li>
<li>＠SafeVarargs - 用于方法和构造方法上，断言varargs参数（即可变长参数）会被安全地使用。比如涉及泛型的可变长参数会有『unchecked』警告，加了@SafeVarargs时编译器不会再给出『unchecked』警告。</li>
</ul>


<p>通过这些内置注解可以了解注解的类型和特点，并掌握注解的使用方法，这是学习自定义注解，即注解高级玩法的基础。</p>

<h2>理解注解</h2>

<p>可以发现注解并不直接对其修饰的代码产生影响，它是为代码提供额外的信息，它是代码的元数据，注解与代码一起构成了编译器的完整输入，编译器借助注解可以生成并得到最终完整的代码。</p>

<p>注解本身无论是使用还是定义都相对直观和简洁，非常容易理解，因为注解本身就是一种元数据，提供一种标记或者额外的数据。重点在于注解的处理，这是注解功能发挥作用的地方也就是注解功能逻辑实现的地方。</p>

<h3>元编程</h3>

<p>注解是程序的元数据，所以这属于元编程范畴。<a href="https://en.wikipedia.org/wiki/Metaprogramming">元编程Metaprogramming</a>也即是以代码为操作目标和目标输出的编程范式，元编程是生产力工具，可以减少重复代码，大大的提高代码开发效率。大多数通用编程语言都支持元编程，像C/C++语言中的宏，Java中的注解，反射和动态代理，大Python中的装饰器（Decorators装饰器是高阶函数对函数进行操作）和元类（Metaclasses，对类进行操作可理解为类的模板）等等都是元编程。</p>

<p>优秀的框架（Spring）和领域驱动开发（DDD）都是元编程的典型应用。</p>

<p>关于Java的元编程，推荐这两篇文章：</p>

<ul>
<li><a href="https://jyjsjd.github.io/java/java-meta-programming/">Java元编程和热更新技术总结</a></li>
<li><a href="https://tech.youzan.com/java-metaprograming/">Java元编程及其应用</a></li>
</ul>


<h2>注解的分类</h2>

<p>注解是向编译器提供额外信息的一种元编程机制，那么依据机制的简单到复杂，可以把注解分为5个类型：</p>

<h3>标记注解（Marker Annotations）</h3>

<p>最简单的注解，对于某个<strong>声明进行标记</strong>，编译器会对被标记的声明进行检查和处理。如@Override和@Deprecated。</p>

<h3>单值注解（Single Value Annotations）</h3>

<p>需要给注解传递<strong>一个参数且只有一个参数</strong>，如@SuppressWarnings(&ldquo;unchecked&rdquo;)。</p>

<h3>全值注解（Full Annotations）</h3>

<p>需要给注解传递很多参数（多个键值对），如：</p>

<pre><code class="Java">@Test(owner="Paul", values="Class Greeks")
public void testSomeMethod() {
    // ...
}
</code></pre>

<h3>类型注解（Type Annotations）</h3>

<p>可以用在<strong>类型被声明</strong>的地方，比如方法返回值，方法的参数声明等，如：</p>

<pre><code class="Java">public @NonNull String transform(@Nullable String source) { ... }
</code></pre>

<h3>重复注解（Repeating Annotations）</h3>

<p>常规的注解在同一个地方只能出现一次，但重复注解可以在同一个地方出现多次，如：</p>

<pre><code class="Java">@Words(word="Hello", value=1)
@Words(word="World", value=2)
public void method() {
    // ...
}
</code></pre>

<h2>自定义注解</h2>

<p>注解的使用是非常的直观和简洁的，无论是内置注解还是各种框架定义好了的注解，使用起来那是相当的香。但这远远不够，因为注解最大的威力在于元编程，比如代码操作和代码生成，这是减少重复劳动（重复代码）和提供开发效率的大杀器。所以我们必须学会高级玩法，即自定义注解。</p>

<h3>元注解</h3>

<p>元注解，也即定义注解时所需要的注解。这有点类似于<a href="https://www.geeksforgeeks.org/bootstrapping-in-compiler-design/">编译器自举</a>，语言本身定义了一个最基础的注解，在其基础之上可以扩展出更多的注解，而注解的处理是通过反射，只要知道一些特殊的标记就可以了，其余的都是逻辑。</p>

<h4>@Inherited</h4>

<p>默认情况下，在基类中使用的注解是不会被子类继承的，如果注解本身标记有@Inherited，那么注解就会出现在被使用的继承体系中：</p>

<pre><code class="Java">@Inherited
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Company {
    String name() default "ABC";
    String city() default "xyz";
}

@Company
public class Employee { .. }

public class Manager extends Employee { ... }
</code></pre>

<p>这个&#127792;中，如果把@Inherited从注解Company中去掉，那么给类Employee加的注解在其子类Manager中就不会得到继承。大部分时候定义注解时都要加上@Inherited标记。</p>

<h4>@Documented</h4>

<p>使用了@Documented标记的注解可以出现在文档中（JavaDocs）。</p>

<h4>@Repeatable</h4>

<p>对应着可重复的注解，指定着可以在哪些标识符上面重复注解。</p>

<h4>@Target</h4>

<p>指定注解可以作用于<strong>何种标识符</strong>，如果不指定则可以使用于<strong>任何标识符即任何程序元素</strong>。可选的选项有：</p>

<ul>
<li>ElementType.ANNOTATION&#95;TYPE - 可以用于其他的注解上面</li>
<li>ElementType.CONSTRUCTOR - 可以用于构造方法上面</li>
<li>ElementType.FIELD - 可以用于成员变量上面</li>
<li>ElementType.LOCAL&#95;VARIABLE - 可以用于方法的本地变量（栈内变量）</li>
<li>ElementType.METHOD - 可以用于方法上面</li>
<li>ElementType.PACKAGE - 可以用于包（package）上面。</li>
<li>ElementType.PARAMETER - 可以用于方法的参数上面。</li>
<li>ElementType.TYPE - 可以用于类型声明的地方（即类，接口和枚举的声明）。</li>
</ul>


<p>可以指定一个@Target(ElementType.METHOD)或者多个目标@Target({ElementType.FIELD, ElementType.LOCAL&#95;VARIABLE})。</p>

<h4>@Retention</h4>

<p>元注解@Retention用于指定注解保留的生命周期。注解是一种元数据，目标是代码，而代码是有生命周期的：编辑或者说源码时；编译时；运行时。这是程序代码的典型生命周期。而@Retention的作用就是指明注解保留到哪个生命周期。</p>

<ul>
<li>RetentionPolicy.SOURCE - 在源码时保留，编译时就被丢弃，也就是说在编译时并不使用。一般用于编译前的源码处理工具使用，如javadoc，以及代码生成。</li>
<li>RetentionPolicy.CLASS - 编译后仍会保留在class文件中，但在运行时（就是JVM加载class时）被丢弃。主要是在编译时使用（比如生成代码）。</li>
<li>RetentionPolicy.RUNTIME - 保留到运行时，在运行时可以被使用。</li>
</ul>


<h3>自定义注解</h3>

<p>注解可以视为一个特殊的接口，注解的定义就是定义一个接口，而每个接口就是其实现。注解的处理器利用反射获取注解接口的类型信息，再结合注解提供的数据就生成接口的实现代码。这就是注解的工作机制。</p>

<p>用@interface就可以声明一个自定义注解，通用的格式是：</p>

<pre><code class="Java">[Access Modifier] @interface &lt;Annotation name&gt; {
    &lt;Type&gt; &lt;Method name&gt;() [default value];
}
</code></pre>

<p>可以看到注解本质上是一种接口，但它有一些具体的限制规则：</p>

<ul>
<li>注解的方法不能有参数和异常签名（throws）</li>
<li>方法的返回值不受限制，可以是任意类型</li>
<li>方法的默认返回值是可选的（即可以有，也可以没有）</li>
<li>定义注解时可以使用元注解，这种套娃机制可以实现更为复杂和更为强大的注解</li>
</ul>


<p>看一个完整自定义注解的&#127792;</p>

<pre><code class="Java">@Documented
@Inherited
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MethodInfo {
    String author() default "Kevin";
    String date();
    int revision() dfeault 1;
    String comments();
}
</code></pre>

<h2>运行时注解解析</h2>

<p>定义了注解后，就可以在代码中使用了，但这还没完，还需要对注解进行解析和处理。在运行时需要用到反射来解析注解，反射API中有专门用于处理注解的API：</p>

<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/reflect/AnnotatedElement.html">AnnotatedElement</a> - 这是反射接口处理注解的核心类型，它是反射类型Method，Field和Constructor的基类，通过它的方法来获取注解<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Annotation.html">Annotation</a>实例。</li>
<li>用<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Annotation.html">Annotation</a>来处理具体的注解</li>
</ul>


<p>注意注意，注解的解析和处理用的是反射，所以注解定义时要用RententionPolicy.RUNTIME，否则用反射是拿不到注解信息的，因为反射是在运行时（Runtime）。下面我们会用一个完整的实例来学习如何处理自定义注解。</p>

<h3>完整示&#127792;</h3>

<p>至此注解的概念的原理都清楚了，融会贯通一下，用一个完整的&#127792;来展示自定义注解。</p>

<h4>Step 1：定义注解</h4>

<p>直接复用前面定义的@MethodInfo。</p>

<h4>Step 2：使用注解</h4>

<pre><code class="Java">public class MethodInfoExample {
    @Override
    @MethodInfo(author = "Alex", comments = "Main method", date = "Mar 29 2024", revision = 2)
    public String toString() {
        return "toString method Overridden";
    }

    @Deprecated
    @MethodInfo(comments = "Deprecated method", date = "Mar 30, 2024")
    public static void oldMethod() {
        System.out.println("Old method out!");
    }

    @SuppressWarnings({"unchecked", "deprecation"})
    @MethodInfo(author = "Paul", comments = "Main method", date = "Mar 31 2024")
    public void genericsMethod() throws FileNotFoundException {
        List list = new ArrayList();
        list.add("Xyz");
        oldMethod();
    }
}
</code></pre>

<h4>Step 3：解析注解</h4>

<pre><code class="Java">public class MethodInfoParsing {
    public static void main(String[] args) {
        try {
            Method[] methods = MethodInfoParsing.class
                    .getClassLoader().loadClass("MethodInfoExample").getDeclaredMethods();
            for (Method method : methods) {
                if (!method.isAnnotationPresent(MethodInfo.class)) {
                    continue;
                }
                for (Annotation annotation : method.getDeclaredAnnotations()) {
                    System.out.println("Annotation " + annotation + " on method " + method.getName());
                }
                MethodInfo info = method.getAnnotation(MethodInfo.class);
                if ("Paul".equals(info.author())) {
                    System.out.println("From Pauls: " + method.getName());
                }
            }
        } catch (ClassNotFoundException e) {
        }
    }
}
</code></pre>

<h2>注解处理器</h2>

<p>在运行时解析注解比较简单，较麻烦的是在编译时（Compile time）处理注解，这时的处理又特别的关键，因为像代码生成是在这一阶段做的。编译时处理注解需要用到<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/Processor.html">Annotation Processor</a>。</p>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2020/03/AnnotationProcessor-twitter.png" alt="" /></p>

<p>一个典型的Annotation processor实现过程：</p>

<ul>
<li>实现一个Processor，通常通过继承<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/AbstractProcessor.html">AbstractProcess</a>。</li>
<li>覆写方法process来处理注解，这里面过滤出想要处理的注解，然后用<a href="https://github.com/square/javapoet">JavaWriter</a>来生成Java文件（或者粗暴的用PrintWriter也可以）。</li>
<li>注册实现好的Processor给编译器：可以通过编译命令javac -processor来指定处理器；也可以把处理器打成jar包然后当成库添加到项目中，因为编译器在开始编译前会自动的去搜索注解和注解处理器。</li>
</ul>


<p>可以参考如下文章来详细了解Annotation processor的实现过程：</p>

<ul>
<li><a href="https://www.baeldung.com/java-annotation-processing-builder">Java Annotation Processing and Creating a Builder</a></li>
<li><a href="https://hannesdorfmann.com/annotation-processing/annotationprocessing101/">Annotation Processing 101</a></li>
<li><a href="https://www.race604.com/annotation-processing/">Java注解处理器</a></li>
<li><a href="https://tomgregory.com/gradle/annotation-processors-in-gradle-with-the-annotationprocessor-dependency-configuration/">Annotation Processors in Gradle with the annotationProcessor Dependency Configuration</a></li>
<li><a href="https://kdrozd.pl/custom-annotation-processor/">Custom Annotation Processor</a></li>
</ul>


<p>这里是一系列<a href="https://github.com/gunnarmorling/awesome-annotation-processing">优秀的Annotation processor案例</a>。</p>

<h2>为什么用注解</h2>

<p>注解是非常优雅的元编程方式，可以生成代码（减少重复），降低耦合。比如著名的单元测试框架JUnit，在其4.0时（即JUnit4）就用注解替代了继承。在JUnit3要这样写测试：</p>

<pre><code class="Java">// Using JUnit 3.0
public class MyClassTest extends TestCase {
    private MyClass instance;

    @Override
    protected void setup() throws Exception {
        super.setup();
        instance = new MyClass();
    }

    @Override
    protected void tearDown() throws Exception {
        super.tearDown();
    }

    public void testSomeMethod() {
        assertNotNull(instance);
        assertEquals("Hello, world", instance.say());
    }
}
</code></pre>

<p>这是类MyClass的一个简单的测试用例。在JUnit4使用了注解后，就可以这样写了：</p>

<pre><code class="Java">// Using JUnit 4.0
public class MyClassTest {
    private MyClass instance;

    @Before
    private void setup() {
        instance = new MyClass();
    }

    @After
    private void tearDown() {}

    @Test
    public void testSomeMethod() {
        assertNotNull(instance);
        assertEquals("Hello, world", instance.say());
    }
}
</code></pre>

<p>通过注解@Before标记测试前准备和@After测试后清理，用@Test标记测试用例，也不用继承TestCase了，整体测试代码非常的优雅。这就是注解的作用。</p>

<h2>什么时候用注解</h2>

<p>注解的本质是程序的元数据，为编译器提供的代码以外的额外的数据。注解是优雅的元编程的一种方式，可以减少重复的代码，提升开发效率。所以每当需要减少重复代码，生成代码，提供元数据时就要用注解来实现。特别是特定领域的问题，非常适合大量使用注解，如数据库（Room），网络请求（Retrofit），单元测试（JUnit）等等。并且注解的大部分应用都是在编译时生成代码，也不影响性能，所以可劲造儿，尽可能的使用注解吧。</p>

<h2>总结</h2>

<p>本文从注解的基础用法出发，再到核心概念的阐述，最后用一个自定义注解的例子展示如何用注解来实现元编程，全方位的阐述了注解。相信通过此文对注解的理解会更上一个层次。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/annotations/index.html">Lesson: Annotations</a></li>
<li><a href="https://www.geeksforgeeks.org/annotations-in-java/">Annotations in Java</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/java-annotations">Java Annotations</a></li>
<li><a href="https://www.baeldung.com/java-custom-annotation">Creating a Custom Annotation in Java</a></li>
<li><a href="https://reflectoring.io/java-annotation-processing/">An Introduction to Annotations and Annotation Processing in Java</a></li>
<li><a href="https://www.cnblogs.com/ziph/p/13056092.html">教科书级讲解，秒懂最详细Java的注解</a></li>
<li><a href="https://pdai.tech/md/java/basic/java-basic-x-annotation.html#google_vignette">Java 基础 - 注解机制详解</a></li>
<li><a href="https://blog.csdn.net/qq_20009015/article/details/106038023">java注解的本质以及注解的底层实现原理</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入浅出Java泛型]]></title>
    <link href="https://alexhilton.github.io/blog/2024/03/10/java-generics-made-easy/"/>
    <updated>2024-03-10T20:43:03+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/03/10/java-generics-made-easy</id>
    <content type="html"><![CDATA[<blockquote><p>温故而知新，可以为师矣！</p></blockquote>

<p>在<a href="/blog/2024/03/04/kotlin-generics-made-easy/">前面的一篇文章</a>中学习了Kotlin的泛型知识，但总感觉还不够深入，因为一些深入的话题和高级的特性并未有讲清楚。但在继续深入之前还是有必要重温一下Java的泛型知识，这是因为Kotlin是基于JVM的语言，并且与Java关系暧昧，它可以与Java混合使用，可以相互调用，在某种程度上讲Kotlin可以视为Java的一种『方言』。所以，我们先回顾Java的泛型，夯实基础，并弄清楚Java泛型遗留了哪些问题，然后再看看Kotlin是如何解决这些问题的。</p>

<p><a href=""><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.wupG3f0_pqm_144x4Zw6ZwHaD4?rs=1&amp;pid=ImgDetMain" title="auto auto" ></a></p>

<!-- more -->


<h2>基础使用方法</h2>

<p>还是要从基本的使用方法来谈起。</p>

<p><a href="https://docs.oracle.com/javase/tutorial/java/generics/index.html">泛型（Generics）</a>就是在类或者方法定义的时候并不指定其操作数据的具体类型，而是用一个虚拟的名字<strong>&lt;T&gt;</strong>代替，类的使用者或者方法的调用在使用时提供具体的类型，以达到类和方法能对所有的类型都能使用的目录。可以把泛型理解为参数化，也就是说定义的时候把其操作的数据类型视为一种参数，由使用者在使用时具体指定（创建对象时或者调用方法时），因此泛型也可以称为<strong>参数化类型</strong>。有3个地方可以使用泛型，<strong>类，接口和方法</strong>，接下分别来看一下具体如何使用。</p>

<h3>泛型类</h3>

<p>泛型类，也即参数化类型的类，是最为常见的一种泛型的使用方式。这些类可以视为<a href="https://en.wikipedia.org/wiki/Metaclass">元类</a>，它会操作另一个类型，比如存储或者加工，类本身的实现重点在于如何操作，而对于这个『另一个类型』具体是什么，并不关心。这时就可以用泛型，在定义类的时候并不指定具体的类型，而是用一个虚拟的类型来代替，由类的使用者在使用的时候来指定具体的类型：</p>

<pre><code class="Java">class ArrayList&lt;E&gt; {
    public void add(E e) { ... }
    public E get(int index) { ... }
}
</code></pre>

<p>这里ArrayList是一个容器，可以以线性的方式来存储任意其他类型，具体是啥其实ArrayList并不关心，所以这里用泛型，E就是参数化类型，代指某一个类型。使用时需要提供具体的类型，可以Integer，String，或者定义好了的任何一种类型(Class)：</p>

<pre><code class="Java">ArrayList&lt;String&gt; players = new ArrayList&lt;&gt;();
players.add("James");
players.add("Kevin");
System.out.println("#1 is " + players.get(0));
System.out.println("#2 is " + players.get(1));
// #1 is James
// #2 is Kevin
</code></pre>

<p>小结 一下，泛型是为了增强代码的复用，定义时用<strong>尖括号&lt;&gt;表示的参数化类型Parameterized type</strong>，拼接在类名字的后面，使用时再指定具体的类型。并且，当编译器能推断出参数类型时，可以用<strong>钻石符号(Diamond operator)&lt;&gt;来</strong>省略参数类型名字。</p>

<h3>泛型接口</h3>

<p>泛型可以用于接口的声明，与类一样，把类型参数化即可：</p>

<pre><code class="Java">interface Consumer&lt;T&gt; {
    void consume(T t);
}
</code></pre>

<h3>泛型方法</h3>

<p>除了类和接口，<a href="https://docs.oracle.com/javase/tutorial/extra/generics/methods.html">方法也可以使用泛型</a>，把用<strong>尖括号表示的参数化类型&lt;T&gt;放</strong>在方法的返回类型之前就可以了：</p>

<pre><code class="Java">public &lt;T&gt; ArrayList&lt;T&gt; fromArrayToList(T[] a) { ... }

String[] names = {"James", "Kevin", "Harden"};
ArrayList&lt;String&gt; players = fromArrayToList(names);
</code></pre>

<p>需要注意的是，因为Java的方法必须声明在类里面，但这并不意味着方法的泛型一定要与类的类型参数一致，当然了，方法可以直接使用类的类型参数，也可以自己再定义一个另外的类型参数，注意这是方法自定义的泛型与其所在的类的泛型没啥关系，如：</p>

<pre><code class="Java">class ArrayList&lt;E&gt; {
    public &lt;T&gt; ArrayList&lt;T&gt; transfer(E e) { ... }
}
</code></pre>

<p>注意，为了可读性方法自定义的泛型最好不要与其所在类使用的泛型一样，比如类用T，方法也用T，虽然这是可以的，因为这个替代类型名字随便取为啥非要弄的容易混淆呢？</p>

<h3>多元类型参数</h3>

<p>类型参数可以有多个，用不同的代号名字并用逗号隔开就可以了，就比如哈希表：</p>

<pre><code class="Java">class HashMap&lt;K, V&gt; { ... }
</code></pre>

<p>就是一个使用二元类型参数的类。</p>

<p>以上就是泛型的基础使用方法。</p>

<h2>理解泛型的本质</h2>

<p>通过以上的介绍可以得出泛型的根本目的是加强复用，让类和方法不受类型的限制，可以应用于任何类型，并且是以一种安全的方式，受到编译器的支持。</p>

<h3>泛型的优势</h3>

<p>如果不用泛型，想要让类或者方法通用，即对任何对象都能生效，那只能把其参数的类型声明为顶层基类Object，然后在某些地方做手动类型转换（type casting）。很明显，这非常容易出错，并且非常的不安全， 一旦某些地方忘记了检查，就会有运行时的类型转换异常（ClassCastException）。</p>

<p>使用了泛型后，编译器会帮助我们对类型对待检查和自动转换，在完成代码复用的同时，又能保证运行时的类型安全，减少运行时的类型转换错误，所以我们应该尽可能多的使用泛型。</p>

<h3>命名规范</h3>

<p>虽然说参数化类型可以用任何名字，但为了可读性还是要遵从比较流行的规范：</p>

<ul>
<li>T 类型</li>
<li>E 集合里面元素的类型</li>
<li>K 哈希表，或者其他有键值的键的类型</li>
<li>V 哈希表中值的类型</li>
<li>N 数字类型</li>
<li>S, U, V等多元参数类型时使用</li>
</ul>


<h2>泛型高级特性</h2>

<h3>指定参数类型的界限</h3>

<p>泛型在定义的时候用虚拟的类型表示参数化的类型，使用的时候传入具体的类型，但有些时候需要<strong>对可以传入的具体类型做限制</strong>，这时可以用类似&lt;T extends Number&gt;来<strong>限定可以使用的类型参数的界限（上界）</strong>，这里的Number可以是任意已知的类型。并且与类的多继承规则一样，这里可以指定多个类型上限，但只能有一个类且要放在最前面后面的只能是接口，用&amp;来连接，如&lt;T extends ClassA &amp; IfaceB &amp; IfaceC&gt;，比如：</p>

<pre><code class="Java">class Calculator&lt;T extends Number &amp; Runnable &amp; Closeable&gt; {
    private T operand;

    public static &lt;S extends Number &amp; Runnable &amp; Comparable&gt; S plus(S a, S b) {
        //
    }
}
</code></pre>

<p>指定泛型中参数型的限制在实际项目中是很有用的，它可以加强代码复用，把一些公共的代码从子类中抽出来，比如像一个列表中的Item有不同的数据类型和不同的布局样式，常规的多态是说让每个子类去实现自己的布局样式，但如果共性太多，这时就可以在创建一个泛型的类或者方法来做，而这个类或者方法就可以指定基类作为泛型类型界限。这样可以加强代码的类型安全，避免调用者传入代码不认识和不能处理的参数类型。</p>

<h3>界限通配符来实现协变与逆变</h3>

<p><a href="https://www.howtogeek.com/devops/what-is-covariance-and-contravariance-in-programming/">协变与逆变</a>是用来描述对象的继承关系在使用这些对象为类型参数的泛型中的联系。比如说Dog是Animal的子类，那么使用这两个类型为参数的泛型对象之间的关系应该是会么呢？如List&lt;Dog&gt;是否也是List&lt;Animal&gt;的子类？Java中的泛型是不可变的Invariant，即泛型对象之间的关系与它们的类型参数之间的关系是没有联系的，即List&lt;Dog&gt;与List&lt;Animal&gt;之间没关系。</p>

<p><img src="https://i1.wp.com/techvidvan.com/tutorials/wp-content/uploads/sites/2/2020/05/Types-of-Java-Wildcards.jpg?fit=802%2C420&amp;ssl=1" alt="" /></p>

<p>不可变Invariant是为了类型安全，编译器检查泛型类型参数必须严格匹配，但在有些时候会带来极大的不方便，因为面向对象的两大基本特性继承和多态保证了子类对象可以当作其基类使用，换句话说能用Animal的地方，放一个Dog对象应该完全合法。但因为泛型不可变，一个声明为addAll(List&lt;Animal&gt;)的方法，是没有办法传入List&lt;Dog&gt;的：</p>

<pre><code class="Java">class Animal {}
class Dog extends Animal {}
class List&lt;E&gt; {
    private E[] items;
    private int size;
    public void addAll(List&lt;E&gt; b) {
        for (E x : b) {
            items[size++] = x;
        }
    }

    public void getAll(List&lt;E&gt; b) {
        for (E e : items) {
            b.add(e);
        }
    }
}

List&lt;Animal&gt; animals = new List&lt;&gt;();
List&lt;Dog&gt; dogs = new List&lt;&gt;();
animals.addAll(dogs); // compile error
dogs.getAll(animals); // compile error
</code></pre>

<p>但这其实是很安全的，因为我们把Dog从列表中取出，然后当作Animal使用，这是向上转型(Upcasting)是完全安全的。但因为泛型是不可变的，编译器必须要保证泛型的类型参数必须完全一致，因此会给出编译错误，但这显然不方便，会让泛型的作用大打折扣。再比如Object是所有对象的基类，但是当把Object作为类型参数时，这个泛型并不是其他泛型的父类，如List&lt;String&gt;并不是List&lt;Object&gt;的子类。</p>

<p>实际上这里需要的是协变(Covariance)与逆变(Contravariance)，也就是让使用类型参数的泛型具有其类型参数一致的继承关系，就要用到界限通配符(Bounded Wildcards)。一共有三种：</p>

<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/generics/upperBounded.html">上界进行协变Covariant</a>，参数化类型&lt;? extends T&gt;表示可以是以T为基类的任意子类类型，当然也包括T本身，泛型&lt;S&gt;会变成&lt;? extends T&gt;的子类，如果S是T的子类。</li>
<li><a href="https://docs.oracle.com/javase/tutorial/java/generics/lowerBounded.html">下界进行逆变Contravariant</a>，参数化类型&lt;? super T&gt;表示可以是T或者T的基类类型泛型&lt;B&gt;会变成&lt;? super T&gt;的基类，如果B是T的基类。</li>
<li><a href="https://docs.oracle.com/javase/tutorial/java/generics/unboundedWildcards.html">无界</a>，参数化类型&lt;?&gt;表示可以是任何类型，可以理解为泛型里的顶层基类（就像Object之于其他对象一样）。</li>
</ul>


<p>使用界限通配符来修改上述&#127792;：</p>

<pre><code class="Java">class List&lt;E&gt; {
    public void addAll(List&lt;? extends E&gt; b) { ... }

    public void getAll(List&lt;? super E&gt; b) { ... }
}

List&lt;Animal&gt; animals = new List&lt;&gt;();
List&lt;Dog&gt; dogs = new List&lt;&gt;();
animals.addAll(dogs); // 0 warnings, 0 errors!
dogs.getAll(animals); // 0 warnings, 0 errors!
</code></pre>

<p>需要特别注意的是<strong>界限通配符解决的问题是协变与逆变</strong>，也即<strong>让两个泛型之间的关系与其参数类型保持一致</strong>，但具体的这一对类型参数仍可以是任何类型。这与前一小节讨论的参数类型界限是完全不同的概念，不是同一码事儿，参数类型界限是限制使用泛型时可以传入的类型的限制。</p>

<p>界限通配符解决的是泛型之间的关系，每当<strong>需要进行<a href="https://docs.oracle.com/javase/tutorial/java/generics/wildcardGuidelines.html">协变与逆变的时候</a>就需要用到通配符</strong>，以让代码更通用更合理。还需要特别注意的<strong>界限通配符只能用于方法的参数</strong>，大神Joshua Bloch在《Effective Java》中<a href="https://stackoverflow.com/questions/2723397/what-is-pecs-producer-extends-consumer-super">给出的建议</a>是<strong>通配符要用于方法的输入泛型参数，如果参数是生产者用extends（即从里面读取对象），如果是消费者用super（即往里面写数据）</strong>。</p>

<h2>运行时的<a href="https://docs.oracle.com/javase/tutorial/java/generics/genTypes.html">泛型擦除</a></h2>

<p>泛型是为了以类型安全的方式实现代码复用，但是在Java 1.5版本时引入的，为了保持向后兼容性，编译器会对泛型的类型信息进行擦除(type erasure)，使其变成常规的对象，这样运行时（JVM）就不用处理新增加的类型了，保持了字节码的兼容性。比如List&lt;String&gt;与List&lt;Integer&gt;在运行时都变成了List对象，JVM并不知道它们的参数类型。泛型的类型参数检查，以及类型的转换都是发生在编译时，是编译器做的事情。</p>

<p>泛型擦除带来的一个问题就是泛型不能使用类型判断符(instanceof)，以及不能进行强制类型转换，比如这样写是不合法的：</p>

<pre><code class="Java">// Compile error: Illegal   generic type for instanceof
if (list instanceof List&lt;Dog&gt;) {
    List&lt;Dog&gt; ld = (List&lt;Dog&gt;) list;
}
</code></pre>

<p>很显然，反射(Reflect)是完全没有办法用泛型的，因为反射是在运行时，这时泛型都被擦除了。如果非要使用泛型，必须要把其类型参数的Class传入作为参数（也即把T的具体参数的class对象传入如String.class），以此来区分不同的泛型，可以参考<a href="https://www.baeldung.com/java-factory-pattern-generics">泛型工厂方法的实现</a>。</p>

<h2>Java泛型的问题</h2>

<h3>泛型不支持基础类型</h3>

<p>Java为了效率和兼容性保留了基础数据类型，如int, boolean, float，但它们并不是对象。而泛型的类型参数必须是对象，因此基础类型是不能用在泛型上面的，比如不能用List&lt;int&gt;，而只能用List&lt;Integer&gt;，好在有自动装箱autoboxinng和拆箱unboxing，所以List&lt;Integer&gt;也可以可以直接用于整数类型的。</p>

<h3>泛型不支持数组</h3>

<p>这里的意思是指不能用泛型去声明数组，比如List&lt;String&gt;[]，这是不允许的。（不要搞混混淆了，数组当作泛型的类型参数是完全可以的，如List&lt;int[]&gt;，因为数组是一个类型。）</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.codetab.org/tutorial/java-generics/introduction/">Java Generics Tutorial</a></li>
<li><a href="https://www.baeldung.com/java-generics">The Basics of Java Generics</a></li>
<li><a href="https://blogs.oracle.com/javamagazine/post/understanding-java-generics-part-1-principles-and-fundamentals">Understanding Java generics, Part 1: Principles and fundamentals</a></li>
<li><a href="https://blogs.oracle.com/javamagazine/post/understanding-java-generics-part-2-the-hard-part">Understanding Java generics, Part 2: The hard part</a></li>
<li><a href="https://www.geeksforgeeks.org/generics-in-java/">Generics in Java</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/java-generics-example-method-class-interface">Java Generics Example Tutorial - Generic Method, Class, Interface</a></li>
<li><a href="https://pdai.tech/md/java/basic/java-basic-x-generic.html">Java 基础 - 泛型机制详解</a></li>
<li><a href="https://juejin.cn/post/7249913673215836218">一文搞懂 java 泛型，也有可能搞不懂，毕竟讲得太全面了</a></li>
<li><a href="https://www.cnblogs.com/coprince/p/8603492.html">java 泛型详解-绝对是对泛型方法讲解最详细的，没有之一</a></li>
<li><a href="https://betterprogramming.pub/a-deep-dive-into-java-wildcards-covariance-4d807a65f02">A Deep Dive Into Java Wildcards — Covariance</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java集合操作集锦]]></title>
    <link href="https://alexhilton.github.io/blog/2022/06/14/java-collection-opertions-made-easy/"/>
    <updated>2022-06-14T23:36:34+08:00</updated>
    <id>https://alexhilton.github.io/blog/2022/06/14/java-collection-opertions-made-easy</id>
    <content type="html"><![CDATA[<p>集合是最为常见的容器，在日常工作之中经常用到，一些集合的常规操作以及不同的集合之间的转换，虽然看似是基础中的基础，但实践中会发现并不是那么显而易见的，特别是涉及boxing的时候，这篇就是想总结 出一些最优的方式来进行集合操作和转换。</p>

<p><strong>注意</strong>：这里集合的意思是容器，是一个更为宽泛的概念，包括数组，列表，Map，Set等。</p>

<p><a href=""><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.rLPIzmZk6G7fV6TCQsotWAHaHa?pid=ImgDet&amp;rs=1" title="auto auto" ></a></p>

<!-- more -->


<h2>核心理念</h2>

<p>不造轮子，也就是说尽可能的复用JDK里面的函数库，无论是数组结构，还是针对数组结构的操作。</p>

<p>另外，就是尽可能的用函数化，也即是Stream API来完成，因为这更直观，当然 这里不能为了用而用，还是要保持代码的简洁和易懂。</p>

<p>另外，集合中存放的都是对象，也就是Object的子类，但对于基础数据如int，float等并不是对象，但集合中难免会存放基础数据，这就涉及了<a href="https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html">Autoboxing</a>，通常会有一定的性能开销，但最大的麻烦在于有时候在不同的集合中来回转换时autoboxing不起作用，就需要一些额外的操作。</p>

<p>这里为了简化说明，涉及对象的都用String对象，基础数据类型都用int，这样既简单又具体普适代表性。</p>

<p>本文代码所在<a href="https://github.com/alexhilton/EffectiveAlgorithm/blob/main/datastructure/src/main/java/CollectionTricks.java">位置请看这里</a>。</p>

<h2>一维集合</h2>

<p>包括，数组，列表，Set，以及Queue和Stack。</p>

<h3>列表</h3>

<p>为啥要先说列表呢，因为列表是最为常用的集合，并且它的函数式操作也是最为容易理解的，所以我们就从它开始。</p>

<h4>其他集合转化为列表</h4>

<ul>
<li>Arrays.asList()</li>
<li>List.of()</li>
</ul>


<h4>列表的经典操作</h4>

<ul>
<li>遍历</li>
<li>转化</li>
<li>过滤</li>
<li>折叠</li>
<li>最大值</li>
<li>最小值</li>
<li>求和</li>
<li>求平均值</li>
<li>转化为数组</li>
</ul>


<h4>带有索引来遍历</h4>

<p>很多时候，带有索引来遍历列表或者数组很有用，但很不幸，没有直接方法，要不然就只能用for-loop。</p>

<p>最好的方法，就是借助IntStream</p>

<pre><code class="java">IntStream.range(0, names.length)
       .mapToObj(i -&gt; String.format("#%d: %s %d", i, names[i], names[i].length()))
       .forEach(System.out::println);
</code></pre>

<h3>数组</h3>

<h4>初始化数组</h4>

<ul>
<li>声明数组时，可以直接使用花括号来初始化，数组的尺寸可以省略，因为编译器能从初始化时推断出来</li>
</ul>


<pre><code class="java">int[] a = {1, 2, 3};
int[][] b = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
String[] names = {"James Harden", "Kevin Durant", "Kyrie Irving"};
</code></pre>

<ul>
<li>如果不能在声明时初始化，那就只能用数组的下标来进行单个赋值了</li>
</ul>


<pre><code class="java">int[] a = new int[3];
a = {1, 2, 3}; // compile error
a[0] = 1;
a[1] = 2;
a[3] = 3;
</code></pre>

<h4>数组操作</h4>

<ul>
<li>常用的操作都在<a href="https://docs.oracle.com/javase/8/docs/api/index.html">System.arraycopy</a>和<a href="https://docs.oracle.com/javase/8/docs/api/index.html">Arrays</a></li>
<li>数组通过Arrays.stream()可以直接转为Stream，然后就可以像列表那样直接进行各种操作了</li>
</ul>


<pre><code class="java">// 数组求和
System.out.println(
        Arrays.stream(a)
                .sum()
);

// 二维数组，找行和最大值
System.out.println(
        Arrays.stream(b)
                .map(row -&gt; Arrays.stream(row).sum())
                .max(Integer::compareTo).get()
);

// 二维数组求和
System.out.println(
        Arrays.stream(b)
                .flatMapToInt(row -&gt; Arrays.stream(row))
                .sum()
);

Arrays.stream(names).forEach(System.out::println);

IntStream.range(0, names.length)
        .mapToObj(i -&gt; String.format("#%d: %s %d", i, names[i], names[i].length()))
        .forEach(System.out::println);

// outputs
//6
//24
//45
//James Harden
//Kevin Durant
//Kyrie Irving
//#0: James Harden 12
//#1: Kevin Durant 12
//#2: Kyrie Irving 12
</code></pre>

<h4>数组转为列表</h4>

<ul>
<li>如果数组的元素是Object，可以直接使用Arrays.asList来转换</li>
</ul>


<pre><code class="java">List&lt;String&gt; nameList = Arrays.asList(names);
System.out.println(nameList);

 //output
 //[James Harden, Kevin Durant, Kyrie Irving]
</code></pre>

<ul>
<li>但如果数组元素是基础数据，则不能直接使用Arrays.asList</li>
</ul>


<pre><code class="java">List&lt;Integer&gt; aToList = Arrays.asList(a); // compile error
System.out.println(Arrays.asList(a));
// [[I@38af3868]
</code></pre>

<p>对于基础类型，Arrays.asList会把整个数组当成一个对象，结果的列表会变成List of array，也即是一个数组对象的列表，里面每个元素是数组对象，数组本身也是一个Object。这就与预期结果不一样，预期结果应该是List<Integer>，结果却变成了List&lt;int[]>。</p>

<p>可以用Stream来完成正确的转换。</p>

<pre><code class="java">List&lt;Integer&gt; aToList = Arrays.stream(a)
                            .boxed()
                            .collect(Collectors.toList());
System.out.println(aToList);
// [1, 2, 3]
</code></pre>

<p>如果是Java 16，可以直接写成：
<code>java
List&lt;Integer&gt; aToList = Arrays.stream(a).boxed().toList();
</code></p>

<h4>列表转化为数组</h4>

<p>一般来说应该尽可能用列表，因为列表是可以自己管理长度，很多时候我们并不知道集合的长度。</p>

<p>但有时候吧，因为接口或者各种原因，它需要的又是数组，这就需要从列表转化为数组。</p>

<p>如果列表里的元素是对象的话，可以直接使用List#toArray，如果是基础类型的话，就需要做一下转换：</p>

<pre><code class="java">String[] nameArray = nameList.toArray(new String[0]);
Arrays.stream(nameArray).forEach(System.out::println);
// James Harden
// Kevin Durant
// Kyrie Irving

int[] aArray =
       aToList.stream()
                  .mapToInt(Integer::intValue)
                  .toArray();
Arrays.stream(aArray).forEach(System.out::println);
//1
//2
//3
</code></pre>

<h2>二维集合</h2>

<p>二维数组（矩阵），嵌套列表，Map，图。</p>

<h3>创建和初始化</h3>

<p>二维数组的创建和初始化可以参考 上面数组的一节，就不重复了，主要就是在声明的时候可以直接初始化。</p>

<h4>嵌套列表的创建和初始化</h4>

<ul>
<li>Arrays.asList或者List.of</li>
</ul>


<pre><code class="java">List&lt;List&lt;String&gt;&gt; lists = Arrays.asList(
        Arrays.asList("James", "Harden"),
        Arrays.asList("Kevin", "Durant"),
        Arrays.asList("Kyrie", "Irving")
);

List&lt;List&lt;Integer&gt;&gt; ageHeights = List.of(
        List.of(35, 200),
        List.of(32, 211),
        List.of(30, 192)
);

System.out.println(lists);
// [[James, Harden], [Kevin, Durant], [Kyrie, Irving]]
System.out.println(ageHeights);
// [[35, 200], [32, 211], [30, 192]]
</code></pre>

<h3>转化</h3>

<h4>嵌套列表转化为二维数组</h4>

<pre><code class="java">String[][] nameArrays = lists.stream()
        .map(row -&gt; row.toArray(String[]::new))
        .toArray(String[][]::new);
System.out.println(Arrays.deepToString(nameArrays));
// [[James, Harden], [Kevin, Durant], [Kyrie, Irving]]

int[][] ageArrays = ageHeights.stream()
        .map(row -&gt; row.stream().mapToInt(Integer::intValue).toArray())
        .toArray(int[][]::new);
System.out.println(Arrays.deepToString(ageArrays));
// [[35, 200], [32, 211], [30, 192]]
</code></pre>

<h4>二维数组转化为列表</h4>

<p>这里又分两种情况，一种是把二维数组展平为一维列表，另外，就是转化为嵌套列表</p>

<ul>
<li>二维数组展平为一维列表</li>
</ul>


<pre><code class="java">List&lt;String&gt; nameList = Arrays.stream(nameArrays)
        .flatMap(Arrays::stream)
        .collect(Collectors.toList());
System.out.println(nameList);
// [James, Harden, Kevin, Durant, Kyrie, Irving]

List&lt;Integer&gt; ageList = Arrays.stream(ageArrays)
        .flatMapToInt(Arrays::stream)
        .mapToObj(Integer::valueOf)
        .collect(Collectors.toList());
System.out.println(ageList);
// [35, 200, 32, 211, 30, 192]
</code></pre>

<ul>
<li>二维数组转化为嵌套列表
有了前面一维的方法，这个就好办了，无非就是多一层转换</li>
</ul>


<pre><code class="java">List&lt;List&lt;String&gt;&gt; nameNList = Arrays.stream(nameArrays)
        .map(Arrays::asList)
        .collect(Collectors.toList());
System.out.println(nameNList);
// [[James, Harden], [Kevin, Durant], [Kyrie, Irving]]

List&lt;List&lt;Integer&gt;&gt; ageNList = Arrays.stream(ageArrays)
        .map(row -&gt; Arrays.stream(row).boxed().collect(Collectors.toList()))
        .collect(Collectors.toList());
System.out.println(ageNList);
// [[35, 200], [32, 211], [30, 192]]
</code></pre>

<h4>数组列表转化为二维数组</h4>

<p>有些时候会有一些数组列表，也就是外层 是一个列表，但每个元素都是一个数组，这时如果想转成二维数组，就可以直接用链式来转就行了。</p>

<pre><code class="java">        List&lt;int[]&gt; list = new ArrayList&lt;&gt;();
        list.add(new int[] {1, 2});
        list.add(new int[] {3, 4});
        list.add(new int[] {5, 6});

        int[][] matrix = list.stream().toArray(int[][]::new);
        // 或者直接用toArray，列表有此方法 list.toArray(int[][]::new)
        System.out.println(Arrays.deepToString(matrix));
        // [[1, 2], [3, 4], [5, 6]]
</code></pre>

<h3>Map操作和转化</h3>

<p>Map也是非常常用的数组结构，它的特点是键值的映射关系，优点是快速查询、删除和修改，能达到常数O（1）级别，在日常使用中特别常见。</p>

<h4>Map的遍历</h4>

<p>遍历有很多方法，这里列出四种最常见的遍历方式</p>

<ol>
<li>forEach，里面lambda的参数是key, value键值对</li>
<li>通过entrySet，这里是把entry转化为一个Set</li>
<li>通过keySet，把所有的Key转成一个Set</li>
<li>通过values，把所有的Value，转成一个Collection类型。</li>
</ol>


<pre><code class="java">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
map.put("Guard", "James Harden");
map.put("Forward", "Kevin Durant");
map.put("Point Guard", "Kyrie Irving");

map.forEach(
         (k, v) -&gt; System.out.println(k + " -&gt; " + v)
);

map.entrySet().forEach(entry -&gt; System.out.println(entry.getKey() + " -&gt; " + entry.getValue()));

map.keySet().forEach(System.out::println);

map.values().stream().forEach(System.out::println);
</code></pre>

<p>当然还有基础的遍历方法，如用for-loop或者用Iterator，就不重复了，网上一搜一大把。</p>

<h4>Map转成列表</h4>

<p>Map毕竟是二维数组结构，它里面有key和value，列表是一维数组，在转化的过程，涉及选择key还是选择value，要依实际目的决定。</p>

<p>而且需要注意的是Map并没有直接生成stream的方法，要想使用Stream API只能使用entrySet().stream()。</p>

<pre><code class="java">List&lt;String&gt; guards = map.entrySet().stream()
                .filter(entry -&gt; entry.getKey().contains("Guard"))
                .map(Map.Entry::getValue)
                .collect(Collectors.toList());
System.out.println(guards);
// [James Harden, Kyrie Irving]

List&lt;String&gt; positions = map.keySet().stream().collect(Collectors.toList());
System.out.println(positions);
// [Forward, Guard, Point Guard]

List&lt;String&gt; players = map.values().stream().collect(Collectors.toList());
System.out.println(players);
// [Kevin Durant, James Harden, Kyrie Irving]
</code></pre>

<h4>Map转成数组</h4>

<p>可以把key, value转成数组，也可以把key和value转成数组。</p>

<pre><code class="java">String[] keyArray = map.keySet().toArray(String[]::new);
System.out.println(Arrays.deepToString(keyArray));
// [Forward, Guard, Point Guard]
String[] valueArray = map.values().toArray(String[]::new);
System.out.println(Arrays.deepToString(valueArray));
// [Kevin Durant, James Harden, Kyrie Irving]
</code></pre>

<p>但如果是Stream，比如用了entrySet().stream()或者keySet().stream()之后，就没有办法直接转成数组了，这时只能先转成列表，再转成数组。</p>

<h2>多维集合</h2>

<p>多维数组</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.techiedelight.com/convert-list-of-lists-to-2d-array-java/">Convert a List of Lists to a 2D array in Java</a></li>
<li><a href="https://stackoverflow.com/questions/960431/how-can-i-convert-listinteger-to-int-in-java">How can I convert List<Integer> to int[] in Java?</a></li>
<li><a href="https://stackoverflow.com/questions/1073919/how-to-convert-int-into-listinteger-in-java">How to convert int[] into List<Integer> in Java?</a></li>
<li><a href="https://stackoverflow.com/questions/11447780/convert-two-dimensional-array-to-list-in-java">Convert two dimensional array to List in java?</a></li>
<li><a href="https://stackoverflow.com/questions/18552005/is-there-a-concise-way-to-iterate-over-a-stream-with-indices-in-java-8">Is there a concise way to iterate over a stream with indices in Java 8?</a></li>
<li><a href="https://www.geeksforgeeks.org/how-to-iterate-hashmap-in-java/">How to Iterate HashMap in Java?</a></li>
<li><a href="https://stackhowto.com/convert-hashmap-to-list-in-java/">Convert Hashmap to List in Java</a></li>
<li><a href="https://www.techiedelight.com/convert-map-array-java/">Convert Map to an array in Java</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中整数基础知识]]></title>
    <link href="https://alexhilton.github.io/blog/2022/03/08/java-integer-basics/"/>
    <updated>2022-03-08T20:32:18+08:00</updated>
    <id>https://alexhilton.github.io/blog/2022/03/08/java-integer-basics</id>
    <content type="html"><![CDATA[<p>最近做了一道题，非常有意思，题本身很简单，但涉及到整数的最大值以及最小值，当写测试用例的时候，却犯了一个错误，发现最小整数并不是0xFFFFFFFF，我们来仔细看一下。</p>

<p><a href=""><img src="https://cdn.softwaretestinghelp.com/wp-content/qa/uploads/2020/06/Java-integer.png" title="auto auto" ></a></p>

<!-- more -->


<h2>整数基础</h2>

<p>Java中，整数都是有符号的，最高位是符号位，0表示正数，1表示负数。有四种，byte，short，int和long。</p>

<ul>
<li>byte 8位，-2<sup>7</sup> ~ 2<sup>7</sup> - 1，-128 ~ 127, 0x80 ~ 0x7F</li>
<li>short 16位，-2<sup>15</sup> ~ 2<sup>15</sup> - 1，-32768 ~ 32767, 0x8000 ~ 0x7FFF</li>
<li>int 32位，-2<sup>31</sup> ~ 2<sup>31</sup> -1，-2147483648 ~ 2147483647, 0x8000000 ~ 0x7FFFFFFF</li>
</ul>


<pre><code class="java">System.out.println(String.format("Max byte %d, 0x%X, half 0x%X", Byte.MAX_VALUE, Byte.MAX_VALUE, Byte.MAX_VALUE/2));
System.out.println(String.format("Min byte %d, 0x%X, half 0x%X", Byte.MIN_VALUE, Byte.MIN_VALUE, (byte)(Byte.MIN_VALUE/2)));
System.out.println(String.format("Max short %d, 0x%X, half 0x%X", Short.MAX_VALUE, Short.MAX_VALUE, Short.MAX_VALUE/2));
System.out.println(String.format("Min short %d, 0x%X, half 0x%X", Short.MIN_VALUE, Short.MIN_VALUE, (short) (Short.MIN_VALUE/2)));
System.out.println(String.format("Max Int %d, 0x%X, half 0x%X", Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE/2));
System.out.println(String.format("Min Int %d, 0x%X, half 0x%X", Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE/2));

// Outputs
//Max byte 127, 0x7F, half 0x3F
//Min byte -128, 0x80, half 0xC0
//Max short 32767, 0x7FFF, half 0x3FFF
//Min short -32768, 0x8000, half 0xC000
//Max Int 2147483647, 0x7FFFFFFF, half 0x3FFFFFFF
//Min Int -2147483648, 0x80000000, half 0xC0000000
</code></pre>

<h3>细节和原理</h3>

<p>值得注意的是，16进制的数值与直觉预期并不一样，特别是负数。正数是一致的，比如int，一共是32位，最高位是符号，所以真正数值部分是31位，那么最大的int就是0x7FFFFFF。</p>

<p>但负数，也即是最小的int，却与直觉完全不一样。按照直觉，负数最高位是1，那最小的int应该是0xFFFFFFFF啊，为何确是0x80000000呢？原因就是整数的编码方式并不是直接的二进制形式的，是以<a href="https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613">补码的形式</a>，也就是说在内部实现中，用二进制表示一个整数的时候，是以二进制补码形式（转成二进制后还要求其补码，才是真实的二进制和16进制形式）。</p>

<p>简单来说，补码是一种二进制编码形式，正数的补码就是它的本身，而负数的补码是其取反后加1，可以<a href="https://en.wikipedia.org/wiki/Two%27s_complement">参考百科上的定义</a>。</p>

<p>负数的转换：原码取反加1，即是补码，补码再转补码即得到原码（也可以补码减1再取反即是原码），符号位在转换过程中一直不变。</p>

<p><strong>注意：</strong>补码的严谨说法是2的补码（Twi&rsquo;s Complement），并不称作二进制补码。补码是为了能用加法的方式来计算减法。因此原码转补码时，取反加1，补码求原码时再求补码，避免用减法（虽然减1后再取反也能求得原码，但需要用到减法）。</p>

<h3>非10进制字面常量是补码形式</h3>

<p>在日常代码中，为了方便，通常都用16进制来写一些整数常量，这里就特别要注意了。16进制的字面常量，不会再进行补码转换，会当成补码直接使用。</p>

<pre><code class="java">System.out.println(String.format("Literal %d, 0x%X", 0xffffffff, 0xffffffff));
//Literal -1, 0xFFFFFFFF
</code></pre>

<p>所以，你写的0xFFFFFFFF是补码形式，它的原码是减1再取反，（32个1）减1，最低位变成0，前面31个1，再取反，就只剩下最后一位是1和最高位的符号位，因此是-1，注意符号位是不变的，在转换过程中。</p>

<p>而最小的整数是-2<sup>31</sup>，原码 形式应该是0x80000000，先取反变成了0xFFFFFFFF，再加1，符号位最高位不变的情况下，其余全变成了0，所以是0x80000000。</p>

<h2>最小整数</h2>

<p>开篇时说了，当时错误的认为0xFFFFFFFF是最小的整数，这里犯的第一个严重错误是，误把二进制的补码当成了原码，代码中的16进制（二进制）都是补码形式的，它的原码是0x80000001即-1。这个错误是比较明显的。</p>

<p>但另外的问题就是，假如都是二进制原码的情况下，为啥最小的整数是0x80000000而不是0xFFFFFFFFF。这是理解上的误区，整数的定义是，最高位是符号位，所以常规认知是全是1的情况是最大的数，加上符号不就变成最小的了么？这是以10进制思维，也就是二进制转换成为10进制后的想法。计算机只认识二进制，在最高位是1（负数）的情况下，哪个数最小？当然0x80000000最小啊，它除了符号位全是0，肯定 小于0xFFFFFFFF，因此从二进制的角度来理解，0x80000000是最小的整数。</p>

<p>而0xFFFFFFFF（原码）则是第2小的负整数，最高位是符号位，其余31位全是1，它的补码是0x80000001：</p>

<pre><code class="java">System.out.println(String.format("Literal %d 0x%X", 0x80000001, 0x80000001));
//Literal -2147483647 0x80000001
</code></pre>

<p><strong>计算机中是以二进制补码来存储整数的，所以要从计算机的角度来理解比较，就是要用二进制的补码来比较两个数的大小。</strong></p>

<p>再次强调，<strong>我们写的源码当中的二进制（无论是字面常量，还是打印输出）都是补码形式，计算机看到的也是补码，比较也是补码，只有当转换成为10进制时，才会还原为原码并进行10进制转换</strong>。</p>

<p>由此得出，（注意，程序员眼睛看到的16进制全是补码形式）：</p>

<ul>
<li>0x80000000是最小的负数，原码为0x80000000，-2<sup>31</sup></li>
<li>0x80000001，第2小的负数（最小的0x80000000再加上1），原码为0xFFFFFFFF，-(2<sup>31</sup>-1)</li>
<li>0xFFFFFFFF，是-1，原码为0x80000001。它是最大的负数（-1是最大的负数）。0xFFFFFFFF（全是1）肯定 最大啊，最高位是1，是负数，所以是最大的负数。</li>
</ul>


<h2>一些有意思的值</h2>

<h3>Integer.MAX_VALUE + 1 = Integer.MIN_VALUE</h3>

<p>按理说应该溢出了，但如果以16进制去计算，就是这样的结果：0x7FFFFFFF + 1 = 0x80000000</p>

<pre><code class="java">System.out.println(String.format("Max in %d (0x%X) + 1 = %d (0x%X)", Integer.MAX_VALUE, Integer.MAX_VALUE, (Integer.MAX_VALUE+1), (Integer.MAX_VALUE+1)));
// Max in 2147483647 (0x7FFFFFFF) + 1 = -2147483648 (0x80000000)
</code></pre>

<h3>Integer.MIN_VALUE - 1 = Integer.MAX_VALUE</h3>

<pre><code class="java">System.out.println(String.format("Min in %d (0x%X) - 1 = %d (0x%X)", Integer.MIN_VALUE, Integer.MIN_VALUE, (Integer.MIN_VALUE-1), (Integer.MIN_VALUE-1)));
//Min in -2147483648 (0x80000000) - 1 = 2147483647 (0x7FFFFFFF)
</code></pre>

<h2>参考资料</h2>

<ul>
<li><a href="https://zhuanlan.zhihu.com/p/103239461">为什么0xffffffff是-1？（计算机对整型的存储）</a></li>
<li><a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html">原码, 反码, 补码 详解 </a></li>
<li><a href="https://segmentfault.com/a/1190000021511009">一文读懂原码、反码与补码</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/99082236">二进制的原码、反码、补码</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2009/08/twos_complement.html">关于2的补码</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入学习Java虚拟机知识]]></title>
    <link href="https://alexhilton.github.io/blog/2022/02/08/study-further-the-java-virtual-machine/"/>
    <updated>2022-02-08T20:33:27+08:00</updated>
    <id>https://alexhilton.github.io/blog/2022/02/08/study-further-the-java-virtual-machine</id>
    <content type="html"><![CDATA[<p>Java编程语言的真核心是其<a href="https://www.geeksforgeeks.org/jvm-works-jvm-architecture/">虚拟机（Java Virtual Machine or JVM）</a>，JVM是真正的让Java宣言『Write Once，Run Anywhere』变成现实，JVM封装并隔离了不同的OS，JVM有它自己的标准和规范，从而凡是符合JVM的『代码』都可以在JVM上运行。Java编程语言并不是直接运行在JVM上面的，Java语言只是套在JVM上面的一层语言规则。</p>

<p><a href=""><img src="https://javatutorial.net/wp-content/uploads/2017/10/write-once-run-anywhere-jvm.png" title="auto auto" ></a></p>

<!-- more -->


<p>准确的说JVM接收的是一套叫做<a href="https://www.javatpoint.com/java-bytecode">字节码（Bytecode）</a>的东西，只要是能把一套语法规则『翻译』成为符合JVM规范的字节码，就可以在JVM上面运行，除了正统的Java之外，<a href="https://scala-lang.org/">Scala</a>，<a href="http://www.groovy-lang.org/">Groovy</a>，以及<a href="https://kotlinlang.org/">Kotlin</a>等等都是这样实现的，它们编译之后得到的就是字节码文件，字节码文件可直接运行在JVM之上。</p>

<p>那么字节码才是Java编程语言的真核心，值得深入研究和学习。前面写过<a href="/blog/2022/01/23/android-reverse-engineering-tricks/">一篇介绍安卓高级逆向方法的文章</a>，里面涉及到一些JVM的高级技术，还需要进一步的深入学习一下，以能更好的理解插件化和热修复的核心原理。</p>

<h2><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html">ClassLoader</a></h2>

<p>除了标准Java中的以外，在Android当中的<a href="https://developer.android.com/reference/java/lang/ClassLoader">ClassLoader</a>也要深入学习一下，这个是相当多的逆向技术的基础，基本的原理和流程如委托机制看文章或者文档就可以了。</p>

<ul>
<li><a href="https://www.baeldung.com/java-classloaders">Class Loaders in Java</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/51374915">老大难的 Java ClassLoader 再不理解就老了</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/136083521">深入理解Android ClassLoader</a></li>
<li><a href="http://gityuan.com/2017/03/19/android-classloader/">Android类加载器ClassLoader</a></li>
</ul>


<p>需要重点记住的就是两点核心要点，一是ClassLoader是类的作用域，它是类的沙箱，同一个ClassLoader里面只能有一个类，必须唯一，但不同的ClassLoader对象，可以有同样的类。这里类的意思是全量类名，也即其packageName+ClassName，Fully Qualified Name。第二就是惰性加载机制，也就是说，对于同一个ClassLoader对象，一个类只会加载一次，加载过了，就不会再去loadClass了。</p>

<p>根据这两个核心要点，就理解了各种热修复的原理了，惰性加载机制决定了热生效和冷生效，因为ClassLoader只加载一次，所以Class替换的方式，只能下次启动生效（准确的说是下次需要loadClass时生效）。而替换的方法就是把修复的patch的想办法放在常规的前面，这样就会优先加载要替换的类了。</p>

<p><strong>注意</strong>：Android中并不是官方Java的bytecode，而一种叫做dex的东西，它是在编译时把标准Class文件经过转化再打包到一起形成的，最初安卓的VM叫做Dalvik，所以就把它的字节码命名为dex意即Dalvik Executable，这是dex的由来。虽然目标格式不一样，但是dex与class是可以自由转换的，且dex的生成在编译为标准class之后的，所以字节码的一切工具，对于安卓也都可以用。</p>

<p>Android中的ClassLoader，重点是DexPathList，它里面决定了各个dex的顺序，插件和热修复基本上都是在dex的顺序 上做文章，要么是把新的dex放在最前面，要么是找到原dex，然后替换，这就是核心原理，也是这一套逆向方法的可行之处。</p>

<h2><a href="https://www.oracle.com/technical-resources/articles/java/javareflection.html">反射</a></h2>

<p>也即是运行时修改代码的能力，它是直接去修改JVM中的代码，也即是修改bytecode。纯编译型语言如C/C++是不可能有这种能力的。Java有这种能力是因为JVM的存在，编译只是把源码『翻译』成字节码。</p>

<p><a href="https://www.baeldung.com/java-reflection">Guide to Java Reflection</a></p>

<p>原生东西不好用，还是用三方库来反射<a href="https://github.com/jOOQ/jOOR">jOOR</a>。</p>

<h2><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/intro.html">JNI</a></h2>

<p>一些三方的号称可以热修复的工具如exposed和Andfix这些东西，之所以能够实现，是因为JVM本身就开了口子支持JNI，为了能让方法能让JVM找得到，就需要一个method table，而此method table是可以被修改的。
<a href="https://www.baeldung.com/jni">Guide to JNI (Java Native Interface)</a></p>

<p><a href="https://blog.csdn.net/createchance/article/details/53783490">Java Native Interface(JNI)从零开始详细教程</a></p>

<p><a href="https://www.cnblogs.com/DengGao/p/jni.html">java native方法与JNI实现</a></p>

<p><a href="https://www.zhihu.com/question/38509124">JNI本身会降低效率吗？</a></p>

<p>如果JNI接口较多，较复杂，建议用<a href="http://www.swig.org/">SWIG</a>，参见它的<a href="http://www.swig.org/Doc1.3/Java.html#java_overview">说明文档</a>。</p>

<p>Swig有点重了，这个库也相当的好用<a href="https://github.com/spotify/JniHelpers">JniHelpers</a>。</p>

<h2><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html">动态代理</a></h2>

<p>除了官方JDK支持的以接口为基础的动态代理 方式之外，还有其他几种以子类化方式实现动态代理，但它们都是基于ASM的。</p>

<p><a href="https://www.baeldung.com/java-dynamic-proxies">Dynamic Proxies in Java</a></p>

<p><a href="https://www.cnblogs.com/techyc/p/3455950.html">Java的动态代理(dynamic proxy)</a></p>

<p><a href="https://www.cnblogs.com/bryan31/p/15266725.html">动态代理大揭秘，带你彻底弄清楚动态代理！</a></p>

<ul>
<li><a href="https://github.com/cglib/cglib">cglib</a></li>
<li><a href="https://www.javassist.org/">Javassist</a></li>
<li><a href="https://bytebuddy.net/#/">Byte Buddy</a></li>
</ul>


<h2><a href="https://en.wikipedia.org/wiki/Java_code_coverage_tools">代码覆盖率检测</a></h2>

<p><a href="http://cobertura.github.io/cobertura/">Cobertura</a></p>

<p><a href="https://github.com/jacoco/jacoco">JaCoCo</a></p>

<p><a href="https://www.baeldung.com/jacoco">Intro to JaCoCo</a></p>

<h2>Mock</h2>

<p>这是自动化测试以及单元测试必然会用到的利器。</p>

<p><a href="https://site.mockito.org/">Mockito</a></p>

<p><a href="https://easymock.org/">EasyMock</a></p>

<h2><a href="https://asm.ow2.io/">ASM</a></h2>

<p>这是一个神器，专门用来处理字节码的，所有其他的Java底层工具都是基于它来实现的，足可见它的牛逼之处。</p>

<p><a href="https://www.baeldung.com/java-asm">A Guide to Java Bytecode Manipulation with ASM</a></p>

<h2><a href="https://www.tutorialsteacher.com/ioc/dependency-injection">Dependency Injection</a></h2>

<ul>
<li><a href="https://www.vogella.com/tutorials/DependencyInjection/article.html">Using dependency injection in Java</a></li>
<li><a href="https://www.codejava.net/coding/what-is-dependency-injection-with-java-code-example">What is Dependency Injection with Java Code Example</a></li>
<li><a href="https://www.edureka.co/blog/what-is-dependency-injection/">What Is Dependency Injection? – Know How To Implement Dependency Injection</a></li>
</ul>


<h2><a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming">AOP</a></h2>

<ul>
<li><a href="https://mvolkmann.github.io/JavaUserGroup/AOP.pdf">Aspect-Oriented Programming (AOP)in Java</a></li>
<li><a href="https://o7planning.org/10257/java-aspect-oriented-programming-with-aspectj">Java Aspect Oriented Programming with AspectJ (AOP)</a></li>
<li><a href="https://www.javatpoint.com/spring-aop-example">Spring AOP Example</a></li>
<li><a href="https://www.eclipse.org/aspectj/">AspectJ</a></li>
<li><a href="https://github.com/eclipse/org.aspectj">Aspectj source</a></li>
<li><a href="https://www.baeldung.com/aspectj">Intro to AspectJ</a></li>
</ul>


<h2>研究字节码的意义</h2>

<p>所有这些基于字节码的工具和技术存在的意义，是帮助我们如何更好的写出Java代码，而并不是纯粹去做一些逆向工程的事情。比如，效率工具，测试工具，调试工具和动态生成代码的技术等等。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://zhuanlan.zhihu.com/p/94498015">史上最通俗易懂的ASM教程</a></li>
<li><a href="https://www.jianshu.com/p/26e99d39b3fb">Java字节码处理框架ASM设计思想解析</a></li>
<li><a href="https://blog.51cto.com/lsieun/2924583">Java ASM系列一：Core API</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
