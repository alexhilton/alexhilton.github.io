<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectivejava | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/effectivejava/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2023-09-21T21:39:32+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java集合操作集锦]]></title>
    <link href="http://toughcoder.net/blog/2022/06/14/java-collection-opertions-made-easy/"/>
    <updated>2022-06-14T23:36:34+08:00</updated>
    <id>http://toughcoder.net/blog/2022/06/14/java-collection-opertions-made-easy</id>
    <content type="html"><![CDATA[<p>集合是最为常见的容器，在日常工作之中经常用到，一些集合的常规操作以及不同的集合之间的转换，虽然看似是基础中的基础，但实践中会发现并不是那么显而易见的，特别是涉及boxing的时候，这篇就是想总结 出一些最优的方式来进行集合操作和转换。</p>

<p><strong>注意</strong>：这里集合的意思是容器，是一个更为宽泛的概念，包括数组，列表，Map，Set等。</p>

<p><a href=""><img src="https://tse4-mm.cn.bing.net/th/id/OIP-C.rLPIzmZk6G7fV6TCQsotWAHaHa?pid=ImgDet&amp;rs=1" title="auto auto" ></a></p>

<!-- more -->


<h2>核心理念</h2>

<p>不造轮子，也就是说尽可能的复用JDK里面的函数库，无论是数组结构，还是针对数组结构的操作。</p>

<p>另外，就是尽可能的用函数化，也即是Stream API来完成，因为这更直观，当然 这里不能为了用而用，还是要保持代码的简洁和易懂。</p>

<p>另外，集合中存放的都是对象，也就是Object的子类，但对于基础数据如int，float等并不是对象，但集合中难免会存放基础数据，这就涉及了<a href="https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html">Autoboxing</a>，通常会有一定的性能开销，但最大的麻烦在于有时候在不同的集合中来回转换时autoboxing不起作用，就需要一些额外的操作。</p>

<p>这里为了简化说明，涉及对象的都用String对象，基础数据类型都用int，这样既简单又具体普适代表性。</p>

<p>本文代码所在<a href="https://github.com/alexhilton/EffectiveAlgorithm/blob/main/datastructure/src/main/java/CollectionTricks.java">位置请看这里</a>。</p>

<h2>一维集合</h2>

<p>包括，数组，列表，Set，以及Queue和Stack。</p>

<h3>列表</h3>

<p>为啥要先说列表呢，因为列表是最为常用的集合，并且它的函数式操作也是最为容易理解的，所以我们就从它开始。</p>

<h4>其他集合转化为列表</h4>

<ul>
<li>Arrays.asList()</li>
<li>List.of()</li>
</ul>


<h4>列表的经典操作</h4>

<ul>
<li>遍历</li>
<li>转化</li>
<li>过滤</li>
<li>折叠</li>
<li>最大值</li>
<li>最小值</li>
<li>求和</li>
<li>求平均值</li>
<li>转化为数组</li>
</ul>


<h4>带有索引来遍历</h4>

<p>很多时候，带有索引来遍历列表或者数组很有用，但很不幸，没有直接方法，要不然就只能用for-loop。</p>

<p>最好的方法，就是借助IntStream</p>

<pre><code class="java">IntStream.range(0, names.length)
       .mapToObj(i -&gt; String.format("#%d: %s %d", i, names[i], names[i].length()))
       .forEach(System.out::println);
</code></pre>

<h3>数组</h3>

<h4>初始化数组</h4>

<ul>
<li>声明数组时，可以直接使用花括号来初始化，数组的尺寸可以省略，因为编译器能从初始化时推断出来</li>
</ul>


<pre><code class="java">int[] a = {1, 2, 3};
int[][] b = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};
String[] names = {"James Harden", "Kevin Durant", "Kyrie Irving"};
</code></pre>

<ul>
<li>如果不能在声明时初始化，那就只能用数组的下标来进行单个赋值了</li>
</ul>


<pre><code class="java">int[] a = new int[3];
a = {1, 2, 3}; // compile error
a[0] = 1;
a[1] = 2;
a[3] = 3;
</code></pre>

<h4>数组操作</h4>

<ul>
<li>常用的操作都在<a href="https://docs.oracle.com/javase/8/docs/api/index.html">System.arraycopy</a>和<a href="https://docs.oracle.com/javase/8/docs/api/index.html">Arrays</a></li>
<li>数组通过Arrays.stream()可以直接转为Stream，然后就可以像列表那样直接进行各种操作了</li>
</ul>


<pre><code class="java">// 数组求和
System.out.println(
        Arrays.stream(a)
                .sum()
);

// 二维数组，找行和最大值
System.out.println(
        Arrays.stream(b)
                .map(row -&gt; Arrays.stream(row).sum())
                .max(Integer::compareTo).get()
);

// 二维数组求和
System.out.println(
        Arrays.stream(b)
                .flatMapToInt(row -&gt; Arrays.stream(row))
                .sum()
);

Arrays.stream(names).forEach(System.out::println);

IntStream.range(0, names.length)
        .mapToObj(i -&gt; String.format("#%d: %s %d", i, names[i], names[i].length()))
        .forEach(System.out::println);

// outputs
//6
//24
//45
//James Harden
//Kevin Durant
//Kyrie Irving
//#0: James Harden 12
//#1: Kevin Durant 12
//#2: Kyrie Irving 12
</code></pre>

<h4>数组转为列表</h4>

<ul>
<li>如果数组的元素是Object，可以直接使用Arrays.asList来转换</li>
</ul>


<pre><code class="java">List&lt;String&gt; nameList = Arrays.asList(names);
System.out.println(nameList);

 //output
 //[James Harden, Kevin Durant, Kyrie Irving]
</code></pre>

<ul>
<li>但如果数组元素是基础数据，则不能直接使用Arrays.asList</li>
</ul>


<pre><code class="java">List&lt;Integer&gt; aToList = Arrays.asList(a); // compile error
System.out.println(Arrays.asList(a));
// [[I@38af3868]
</code></pre>

<p>对于基础类型，Arrays.asList会把整个数组当成一个对象，结果的列表会变成List of array，也即是一个数组对象的列表，里面每个元素是数组对象，数组本身也是一个Object。这就与预期结果不一样，预期结果应该是List<Integer>，结果却变成了List&lt;int[]>。</p>

<p>可以用Stream来完成正确的转换。</p>

<pre><code class="java">List&lt;Integer&gt; aToList = Arrays.stream(a)
                            .boxed()
                            .collect(Collectors.toList());
System.out.println(aToList);
// [1, 2, 3]
</code></pre>

<p>如果是Java 16，可以直接写成：
<code>java
List&lt;Integer&gt; aToList = Arrays.stream(a).boxed().toList();
</code></p>

<h4>列表转化为数组</h4>

<p>一般来说应该尽可能用列表，因为列表是可以自己管理长度，很多时候我们并不知道集合的长度。</p>

<p>但有时候吧，因为接口或者各种原因，它需要的又是数组，这就需要从列表转化为数组。</p>

<p>如果列表里的元素是对象的话，可以直接使用List#toArray，如果是基础类型的话，就需要做一下转换：</p>

<pre><code class="java">String[] nameArray = nameList.toArray(new String[0]);
Arrays.stream(nameArray).forEach(System.out::println);
// James Harden
// Kevin Durant
// Kyrie Irving

int[] aArray =
       aToList.stream()
                  .mapToInt(Integer::intValue)
                  .toArray();
Arrays.stream(aArray).forEach(System.out::println);
//1
//2
//3
</code></pre>

<h2>二维集合</h2>

<p>二维数组（矩阵），嵌套列表，Map，图。</p>

<h3>创建和初始化</h3>

<p>二维数组的创建和初始化可以参考 上面数组的一节，就不重复了，主要就是在声明的时候可以直接初始化。</p>

<h4>嵌套列表的创建和初始化</h4>

<ul>
<li>Arrays.asList或者List.of</li>
</ul>


<pre><code class="java">List&lt;List&lt;String&gt;&gt; lists = Arrays.asList(
        Arrays.asList("James", "Harden"),
        Arrays.asList("Kevin", "Durant"),
        Arrays.asList("Kyrie", "Irving")
);

List&lt;List&lt;Integer&gt;&gt; ageHeights = List.of(
        List.of(35, 200),
        List.of(32, 211),
        List.of(30, 192)
);

System.out.println(lists);
// [[James, Harden], [Kevin, Durant], [Kyrie, Irving]]
System.out.println(ageHeights);
// [[35, 200], [32, 211], [30, 192]]
</code></pre>

<h3>转化</h3>

<h4>嵌套列表转化为二维数组</h4>

<pre><code class="java">String[][] nameArrays = lists.stream()
        .map(row -&gt; row.toArray(String[]::new))
        .toArray(String[][]::new);
System.out.println(Arrays.deepToString(nameArrays));
// [[James, Harden], [Kevin, Durant], [Kyrie, Irving]]

int[][] ageArrays = ageHeights.stream()
        .map(row -&gt; row.stream().mapToInt(Integer::intValue).toArray())
        .toArray(int[][]::new);
System.out.println(Arrays.deepToString(ageArrays));
// [[35, 200], [32, 211], [30, 192]]
</code></pre>

<h4>二维数组转化为列表</h4>

<p>这里又分两种情况，一种是把二维数组展平为一维列表，另外，就是转化为嵌套列表</p>

<ul>
<li>二维数组展平为一维列表</li>
</ul>


<pre><code class="java">List&lt;String&gt; nameList = Arrays.stream(nameArrays)
        .flatMap(Arrays::stream)
        .collect(Collectors.toList());
System.out.println(nameList);
// [James, Harden, Kevin, Durant, Kyrie, Irving]

List&lt;Integer&gt; ageList = Arrays.stream(ageArrays)
        .flatMapToInt(Arrays::stream)
        .mapToObj(Integer::valueOf)
        .collect(Collectors.toList());
System.out.println(ageList);
// [35, 200, 32, 211, 30, 192]
</code></pre>

<ul>
<li>二维数组转化为嵌套列表
有了前面一维的方法，这个就好办了，无非就是多一层转换</li>
</ul>


<pre><code class="java">List&lt;List&lt;String&gt;&gt; nameNList = Arrays.stream(nameArrays)
        .map(Arrays::asList)
        .collect(Collectors.toList());
System.out.println(nameNList);
// [[James, Harden], [Kevin, Durant], [Kyrie, Irving]]

List&lt;List&lt;Integer&gt;&gt; ageNList = Arrays.stream(ageArrays)
        .map(row -&gt; Arrays.stream(row).boxed().collect(Collectors.toList()))
        .collect(Collectors.toList());
System.out.println(ageNList);
// [[35, 200], [32, 211], [30, 192]]
</code></pre>

<h4>数组列表转化为二维数组</h4>

<p>有些时候会有一些数组列表，也就是外层 是一个列表，但每个元素都是一个数组，这时如果想转成二维数组，就可以直接用链式来转就行了。</p>

<pre><code class="java">        List&lt;int[]&gt; list = new ArrayList&lt;&gt;();
        list.add(new int[] {1, 2});
        list.add(new int[] {3, 4});
        list.add(new int[] {5, 6});

        int[][] matrix = list.stream().toArray(int[][]::new);
        // 或者直接用toArray，列表有此方法 list.toArray(int[][]::new)
        System.out.println(Arrays.deepToString(matrix));
        // [[1, 2], [3, 4], [5, 6]]
</code></pre>

<h3>Map操作和转化</h3>

<p>Map也是非常常用的数组结构，它的特点是键值的映射关系，优点是快速查询、删除和修改，能达到常数O（1）级别，在日常使用中特别常见。</p>

<h4>Map的遍历</h4>

<p>遍历有很多方法，这里列出四种最常见的遍历方式</p>

<ol>
<li>forEach，里面lambda的参数是key, value键值对</li>
<li>通过entrySet，这里是把entry转化为一个Set</li>
<li>通过keySet，把所有的Key转成一个Set</li>
<li>通过values，把所有的Value，转成一个Collection类型。</li>
</ol>


<pre><code class="java">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
map.put("Guard", "James Harden");
map.put("Forward", "Kevin Durant");
map.put("Point Guard", "Kyrie Irving");

map.forEach(
         (k, v) -&gt; System.out.println(k + " -&gt; " + v)
);

map.entrySet().forEach(entry -&gt; System.out.println(entry.getKey() + " -&gt; " + entry.getValue()));

map.keySet().forEach(System.out::println);

map.values().stream().forEach(System.out::println);
</code></pre>

<p>当然还有基础的遍历方法，如用for-loop或者用Iterator，就不重复了，网上一搜一大把。</p>

<h4>Map转成列表</h4>

<p>Map毕竟是二维数组结构，它里面有key和value，列表是一维数组，在转化的过程，涉及选择key还是选择value，要依实际目的决定。</p>

<p>而且需要注意的是Map并没有直接生成stream的方法，要想使用Stream API只能使用entrySet().stream()。</p>

<pre><code class="java">List&lt;String&gt; guards = map.entrySet().stream()
                .filter(entry -&gt; entry.getKey().contains("Guard"))
                .map(Map.Entry::getValue)
                .collect(Collectors.toList());
System.out.println(guards);
// [James Harden, Kyrie Irving]

List&lt;String&gt; positions = map.keySet().stream().collect(Collectors.toList());
System.out.println(positions);
// [Forward, Guard, Point Guard]

List&lt;String&gt; players = map.values().stream().collect(Collectors.toList());
System.out.println(players);
// [Kevin Durant, James Harden, Kyrie Irving]
</code></pre>

<h4>Map转成数组</h4>

<p>可以把key, value转成数组，也可以把key和value转成数组。</p>

<pre><code class="java">String[] keyArray = map.keySet().toArray(String[]::new);
System.out.println(Arrays.deepToString(keyArray));
// [Forward, Guard, Point Guard]
String[] valueArray = map.values().toArray(String[]::new);
System.out.println(Arrays.deepToString(valueArray));
// [Kevin Durant, James Harden, Kyrie Irving]
</code></pre>

<p>但如果是Stream，比如用了entrySet().stream()或者keySet().stream()之后，就没有办法直接转成数组了，这时只能先转成列表，再转成数组。</p>

<h2>多维集合</h2>

<p>多维数组</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.techiedelight.com/convert-list-of-lists-to-2d-array-java/">Convert a List of Lists to a 2D array in Java</a></li>
<li><a href="https://stackoverflow.com/questions/960431/how-can-i-convert-listinteger-to-int-in-java">How can I convert List<Integer> to int[] in Java?</a></li>
<li><a href="https://stackoverflow.com/questions/1073919/how-to-convert-int-into-listinteger-in-java">How to convert int[] into List<Integer> in Java?</a></li>
<li><a href="https://stackoverflow.com/questions/11447780/convert-two-dimensional-array-to-list-in-java">Convert two dimensional array to List in java?</a></li>
<li><a href="https://stackoverflow.com/questions/18552005/is-there-a-concise-way-to-iterate-over-a-stream-with-indices-in-java-8">Is there a concise way to iterate over a stream with indices in Java 8?</a></li>
<li><a href="https://www.geeksforgeeks.org/how-to-iterate-hashmap-in-java/">How to Iterate HashMap in Java?</a></li>
<li><a href="https://stackhowto.com/convert-hashmap-to-list-in-java/">Convert Hashmap to List in Java</a></li>
<li><a href="https://www.techiedelight.com/convert-map-array-java/">Convert Map to an array in Java</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java中整数基础知识]]></title>
    <link href="http://toughcoder.net/blog/2022/03/08/java-integer-basics/"/>
    <updated>2022-03-08T20:32:18+08:00</updated>
    <id>http://toughcoder.net/blog/2022/03/08/java-integer-basics</id>
    <content type="html"><![CDATA[<p>最近做了一道题，非常有意思，题本身很简单，但涉及到整数的最大值以及最小值，当写测试用例的时候，却犯了一个错误，发现最小整数并不是0xFFFFFFFF，我们来仔细看一下。</p>

<p><a href=""><img src="https://cdn.softwaretestinghelp.com/wp-content/qa/uploads/2020/06/Java-integer.png" title="auto auto" ></a></p>

<!-- more -->


<h2>整数基础</h2>

<p>Java中，整数都是有符号的，最高位是符号位，0表示正数，1表示负数。有四种，byte，short，int和long。</p>

<ul>
<li>byte 8位，-2<sup>7</sup> ~ 2<sup>7</sup> - 1，-128 ~ 127, 0x80 ~ 0x7F</li>
<li>short 16位，-2<sup>15</sup> ~ 2<sup>15</sup> - 1，-32768 ~ 32767, 0x8000 ~ 0x7FFF</li>
<li>int 32位，-2<sup>31</sup> ~ 2<sup>31</sup> -1，-2147483648 ~ 2147483647, 0x8000000 ~ 0x7FFFFFFF</li>
</ul>


<pre><code class="java">System.out.println(String.format("Max byte %d, 0x%X, half 0x%X", Byte.MAX_VALUE, Byte.MAX_VALUE, Byte.MAX_VALUE/2));
System.out.println(String.format("Min byte %d, 0x%X, half 0x%X", Byte.MIN_VALUE, Byte.MIN_VALUE, (byte)(Byte.MIN_VALUE/2)));
System.out.println(String.format("Max short %d, 0x%X, half 0x%X", Short.MAX_VALUE, Short.MAX_VALUE, Short.MAX_VALUE/2));
System.out.println(String.format("Min short %d, 0x%X, half 0x%X", Short.MIN_VALUE, Short.MIN_VALUE, (short) (Short.MIN_VALUE/2)));
System.out.println(String.format("Max Int %d, 0x%X, half 0x%X", Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE/2));
System.out.println(String.format("Min Int %d, 0x%X, half 0x%X", Integer.MIN_VALUE, Integer.MIN_VALUE, Integer.MIN_VALUE/2));

// Outputs
//Max byte 127, 0x7F, half 0x3F
//Min byte -128, 0x80, half 0xC0
//Max short 32767, 0x7FFF, half 0x3FFF
//Min short -32768, 0x8000, half 0xC000
//Max Int 2147483647, 0x7FFFFFFF, half 0x3FFFFFFF
//Min Int -2147483648, 0x80000000, half 0xC0000000
</code></pre>

<h3>细节和原理</h3>

<p>值得注意的是，16进制的数值与直觉预期并不一样，特别是负数。正数是一致的，比如int，一共是32位，最高位是符号，所以真正数值部分是31位，那么最大的int就是0x7FFFFFF。</p>

<p>但负数，也即是最小的int，却与直觉完全不一样。按照直觉，负数最高位是1，那最小的int应该是0xFFFFFFFF啊，为何确是0x80000000呢？原因就是整数的编码方式并不是直接的二进制形式的，是以<a href="https://baike.baidu.com/item/%E8%A1%A5%E7%A0%81/6854613">补码的形式</a>，也就是说在内部实现中，用二进制表示一个整数的时候，是以二进制补码形式（转成二进制后还要求其补码，才是真实的二进制和16进制形式）。</p>

<p>简单来说，补码是一种二进制编码形式，正数的补码就是它的本身，而负数的补码是其取反后加1，可以<a href="https://en.wikipedia.org/wiki/Two%27s_complement">参考百科上的定义</a>。</p>

<p>负数的转换：原码取反加1，即是补码，补码再转补码即得到原码（也可以补码减1再取反即是原码），符号位在转换过程中一直不变。</p>

<p><strong>注意：</strong>补码的严谨说法是2的补码（Twi&rsquo;s Complement），并不称作二进制补码。补码是为了能用加法的方式来计算减法。因此原码转补码时，取反加1，补码求原码时再求补码，避免用减法（虽然减1后再取反也能求得原码，但需要用到减法）。</p>

<h3>非10进制字面常量是补码形式</h3>

<p>在日常代码中，为了方便，通常都用16进制来写一些整数常量，这里就特别要注意了。16进制的字面常量，不会再进行补码转换，会当成补码直接使用。</p>

<pre><code class="java">System.out.println(String.format("Literal %d, 0x%X", 0xffffffff, 0xffffffff));
//Literal -1, 0xFFFFFFFF
</code></pre>

<p>所以，你写的0xFFFFFFFF是补码形式，它的原码是减1再取反，（32个1）减1，最低位变成0，前面31个1，再取反，就只剩下最后一位是1和最高位的符号位，因此是-1，注意符号位是不变的，在转换过程中。</p>

<p>而最小的整数是-2<sup>31</sup>，原码 形式应该是0x80000000，先取反变成了0xFFFFFFFF，再加1，符号位最高位不变的情况下，其余全变成了0，所以是0x80000000。</p>

<h2>最小整数</h2>

<p>开篇时说了，当时错误的认为0xFFFFFFFF是最小的整数，这里犯的第一个严重错误是，误把二进制的补码当成了原码，代码中的16进制（二进制）都是补码形式的，它的原码是0x80000001即-1。这个错误是比较明显的。</p>

<p>但另外的问题就是，假如都是二进制原码的情况下，为啥最小的整数是0x80000000而不是0xFFFFFFFFF。这是理解上的误区，整数的定义是，最高位是符号位，所以常规认知是全是1的情况是最大的数，加上符号不就变成最小的了么？这是以10进制思维，也就是二进制转换成为10进制后的想法。计算机只认识二进制，在最高位是1（负数）的情况下，哪个数最小？当然0x80000000最小啊，它除了符号位全是0，肯定 小于0xFFFFFFFF，因此从二进制的角度来理解，0x80000000是最小的整数。</p>

<p>而0xFFFFFFFF（原码）则是第2小的负整数，最高位是符号位，其余31位全是1，它的补码是0x80000001：</p>

<pre><code class="java">System.out.println(String.format("Literal %d 0x%X", 0x80000001, 0x80000001));
//Literal -2147483647 0x80000001
</code></pre>

<p><strong>计算机中是以二进制补码来存储整数的，所以要从计算机的角度来理解比较，就是要用二进制的补码来比较两个数的大小。</strong></p>

<p>再次强调，<strong>我们写的源码当中的二进制（无论是字面常量，还是打印输出）都是补码形式，计算机看到的也是补码，比较也是补码，只有当转换成为10进制时，才会还原为原码并进行10进制转换</strong>。</p>

<p>由此得出，（注意，程序员眼睛看到的16进制全是补码形式）：</p>

<ul>
<li>0x80000000是最小的负数，原码为0x80000000，-2<sup>31</sup></li>
<li>0x80000001，第2小的负数（最小的0x80000000再加上1），原码为0xFFFFFFFF，-(2<sup>31</sup>-1)</li>
<li>0xFFFFFFFF，是-1，原码为0x80000001。它是最大的负数（-1是最大的负数）。0xFFFFFFFF（全是1）肯定 最大啊，最高位是1，是负数，所以是最大的负数。</li>
</ul>


<h2>一些有意思的值</h2>

<h3>Integer.MAX_VALUE + 1 = Integer.MIN_VALUE</h3>

<p>按理说应该溢出了，但如果以16进制去计算，就是这样的结果：0x7FFFFFFF + 1 = 0x80000000</p>

<pre><code class="java">System.out.println(String.format("Max in %d (0x%X) + 1 = %d (0x%X)", Integer.MAX_VALUE, Integer.MAX_VALUE, (Integer.MAX_VALUE+1), (Integer.MAX_VALUE+1)));
// Max in 2147483647 (0x7FFFFFFF) + 1 = -2147483648 (0x80000000)
</code></pre>

<h3>Integer.MIN_VALUE - 1 = Integer.MAX_VALUE</h3>

<pre><code class="java">System.out.println(String.format("Min in %d (0x%X) - 1 = %d (0x%X)", Integer.MIN_VALUE, Integer.MIN_VALUE, (Integer.MIN_VALUE-1), (Integer.MIN_VALUE-1)));
//Min in -2147483648 (0x80000000) - 1 = 2147483647 (0x7FFFFFFF)
</code></pre>

<h2>参考资料</h2>

<ul>
<li><a href="https://zhuanlan.zhihu.com/p/103239461">为什么0xffffffff是-1？（计算机对整型的存储）</a></li>
<li><a href="https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html">原码, 反码, 补码 详解 </a></li>
<li><a href="https://segmentfault.com/a/1190000021511009">一文读懂原码、反码与补码</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/99082236">二进制的原码、反码、补码</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2009/08/twos_complement.html">关于2的补码</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入学习Java虚拟机知识]]></title>
    <link href="http://toughcoder.net/blog/2022/02/08/study-further-the-java-virtual-machine/"/>
    <updated>2022-02-08T20:33:27+08:00</updated>
    <id>http://toughcoder.net/blog/2022/02/08/study-further-the-java-virtual-machine</id>
    <content type="html"><![CDATA[<p>Java编程语言的真核心是其<a href="https://www.geeksforgeeks.org/jvm-works-jvm-architecture/">虚拟机（Java Virtual Machine or JVM）</a>，JVM是真正的让Java宣言『Write Once，Run Anywhere』变成现实，JVM封装并隔离了不同的OS，JVM有它自己的标准和规范，从而凡是符合JVM的『代码』都可以在JVM上运行。Java编程语言并不是直接运行在JVM上面的，Java语言只是套在JVM上面的一层语言规则。</p>

<p><a href=""><img src="https://javatutorial.net/wp-content/uploads/2017/10/write-once-run-anywhere-jvm.png" title="auto auto" ></a></p>

<!-- more -->


<p>准确的说JVM接收的是一套叫做<a href="https://www.javatpoint.com/java-bytecode">字节码（Bytecode）</a>的东西，只要是能把一套语法规则『翻译』成为符合JVM规范的字节码，就可以在JVM上面运行，除了正统的Java之外，<a href="https://scala-lang.org/">Scala</a>，<a href="http://www.groovy-lang.org/">Groovy</a>，以及<a href="https://kotlinlang.org/">Kotlin</a>等等都是这样实现的，它们编译之后得到的就是字节码文件，字节码文件可直接运行在JVM之上。</p>

<p>那么字节码才是Java编程语言的真核心，值得深入研究和学习。前面写过<a href="http://toughcoder.net/blog/2022/01/23/android-reverse-engineering-tricks/">一篇介绍安卓高级逆向方法的文章</a>，里面涉及到一些JVM的高级技术，还需要进一步的深入学习一下，以能更好的理解插件化和热修复的核心原理。</p>

<h2><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html">ClassLoader</a></h2>

<p>除了标准Java中的以外，在Android当中的<a href="https://developer.android.com/reference/java/lang/ClassLoader">ClassLoader</a>也要深入学习一下，这个是相当多的逆向技术的基础，基本的原理和流程如委托机制看文章或者文档就可以了。</p>

<ul>
<li><a href="https://www.baeldung.com/java-classloaders">Class Loaders in Java</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/51374915">老大难的 Java ClassLoader 再不理解就老了</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/136083521">深入理解Android ClassLoader</a></li>
<li><a href="http://gityuan.com/2017/03/19/android-classloader/">Android类加载器ClassLoader</a></li>
</ul>


<p>需要重点记住的就是两点核心要点，一是ClassLoader是类的作用域，它是类的沙箱，同一个ClassLoader里面只能有一个类，必须唯一，但不同的ClassLoader对象，可以有同样的类。这里类的意思是全量类名，也即其packageName+ClassName，Fully Qualified Name。第二就是惰性加载机制，也就是说，对于同一个ClassLoader对象，一个类只会加载一次，加载过了，就不会再去loadClass了。</p>

<p>根据这两个核心要点，就理解了各种热修复的原理了，惰性加载机制决定了热生效和冷生效，因为ClassLoader只加载一次，所以Class替换的方式，只能下次启动生效（准确的说是下次需要loadClass时生效）。而替换的方法就是把修复的patch的想办法放在常规的前面，这样就会优先加载要替换的类了。</p>

<p><strong>注意</strong>：Android中并不是官方Java的bytecode，而一种叫做dex的东西，它是在编译时把标准Class文件经过转化再打包到一起形成的，最初安卓的VM叫做Dalvik，所以就把它的字节码命名为dex意即Dalvik Executable，这是dex的由来。虽然目标格式不一样，但是dex与class是可以自由转换的，且dex的生成在编译为标准class之后的，所以字节码的一切工具，对于安卓也都可以用。</p>

<p>Android中的ClassLoader，重点是DexPathList，它里面决定了各个dex的顺序，插件和热修复基本上都是在dex的顺序 上做文章，要么是把新的dex放在最前面，要么是找到原dex，然后替换，这就是核心原理，也是这一套逆向方法的可行之处。</p>

<h2><a href="https://www.oracle.com/technical-resources/articles/java/javareflection.html">反射</a></h2>

<p>也即是运行时修改代码的能力，它是直接去修改JVM中的代码，也即是修改bytecode。纯编译型语言如C/C++是不可能有这种能力的。Java有这种能力是因为JVM的存在，编译只是把源码『翻译』成字节码。</p>

<p><a href="https://www.baeldung.com/java-reflection">Guide to Java Reflection</a></p>

<p>原生东西不好用，还是用三方库来反射<a href="https://github.com/jOOQ/jOOR">jOOR</a>。</p>

<h2><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/intro.html">JNI</a></h2>

<p>一些三方的号称可以热修复的工具如exposed和Andfix这些东西，之所以能够实现，是因为JVM本身就开了口子支持JNI，为了能让方法能让JVM找得到，就需要一个method table，而此method table是可以被修改的。
<a href="https://www.baeldung.com/jni">Guide to JNI (Java Native Interface)</a></p>

<p><a href="https://blog.csdn.net/createchance/article/details/53783490">Java Native Interface(JNI)从零开始详细教程</a></p>

<p><a href="https://www.cnblogs.com/DengGao/p/jni.html">java native方法与JNI实现</a></p>

<p><a href="https://www.zhihu.com/question/38509124">JNI本身会降低效率吗？</a></p>

<p>如果JNI接口较多，较复杂，建议用<a href="http://www.swig.org/">SWIG</a>，参见它的<a href="http://www.swig.org/Doc1.3/Java.html#java_overview">说明文档</a>。</p>

<p>Swig有点重了，这个库也相当的好用<a href="https://github.com/spotify/JniHelpers">JniHelpers</a>。</p>

<h2><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/reflection/proxy.html">动态代理</a></h2>

<p>除了官方JDK支持的以接口为基础的动态代理 方式之外，还有其他几种以子类化方式实现动态代理，但它们都是基于ASM的。</p>

<p><a href="https://www.baeldung.com/java-dynamic-proxies">Dynamic Proxies in Java</a></p>

<p><a href="https://www.cnblogs.com/techyc/p/3455950.html">Java的动态代理(dynamic proxy)</a></p>

<p><a href="https://www.cnblogs.com/bryan31/p/15266725.html">动态代理大揭秘，带你彻底弄清楚动态代理！</a></p>

<ul>
<li><a href="https://github.com/cglib/cglib">cglib</a></li>
<li><a href="https://www.javassist.org/">Javassist</a></li>
<li><a href="https://bytebuddy.net/#/">Byte Buddy</a></li>
</ul>


<h2><a href="https://en.wikipedia.org/wiki/Java_code_coverage_tools">代码覆盖率检测</a></h2>

<p><a href="http://cobertura.github.io/cobertura/">Cobertura</a></p>

<p><a href="https://github.com/jacoco/jacoco">JaCoCo</a></p>

<p><a href="https://www.baeldung.com/jacoco">Intro to JaCoCo</a></p>

<h2>Mock</h2>

<p>这是自动化测试以及单元测试必然会用到的利器。</p>

<p><a href="https://site.mockito.org/">Mockito</a></p>

<p><a href="https://easymock.org/">EasyMock</a></p>

<h2><a href="https://asm.ow2.io/">ASM</a></h2>

<p>这是一个神器，专门用来处理字节码的，所有其他的Java底层工具都是基于它来实现的，足可见它的牛逼之处。</p>

<p><a href="https://www.baeldung.com/java-asm">A Guide to Java Bytecode Manipulation with ASM</a></p>

<h2><a href="https://www.tutorialsteacher.com/ioc/dependency-injection">Dependency Injection</a></h2>

<ul>
<li><a href="https://www.vogella.com/tutorials/DependencyInjection/article.html">Using dependency injection in Java</a></li>
<li><a href="https://www.codejava.net/coding/what-is-dependency-injection-with-java-code-example">What is Dependency Injection with Java Code Example</a></li>
<li><a href="https://www.edureka.co/blog/what-is-dependency-injection/">What Is Dependency Injection? – Know How To Implement Dependency Injection</a></li>
</ul>


<h2><a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming">AOP</a></h2>

<ul>
<li><a href="https://mvolkmann.github.io/JavaUserGroup/AOP.pdf">Aspect-Oriented Programming (AOP)in Java</a></li>
<li><a href="https://o7planning.org/10257/java-aspect-oriented-programming-with-aspectj">Java Aspect Oriented Programming with AspectJ (AOP)</a></li>
<li><a href="https://www.javatpoint.com/spring-aop-example">Spring AOP Example</a></li>
<li><a href="https://www.eclipse.org/aspectj/">AspectJ</a></li>
<li><a href="https://github.com/eclipse/org.aspectj">Aspectj source</a></li>
<li><a href="https://www.baeldung.com/aspectj">Intro to AspectJ</a></li>
</ul>


<h2>研究字节码的意义</h2>

<p>所有这些基于字节码的工具和技术存在的意义，是帮助我们如何更好的写出Java代码，而并不是纯粹去做一些逆向工程的事情。比如，效率工具，测试工具，调试工具和动态生成代码的技术等等。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://zhuanlan.zhihu.com/p/94498015">史上最通俗易懂的ASM教程</a></li>
<li><a href="https://www.jianshu.com/p/26e99d39b3fb">Java字节码处理框架ASM设计思想解析</a></li>
<li><a href="https://blog.51cto.com/lsieun/2924583">Java ASM系列一：Core API</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[拥抱新时代的Java]]></title>
    <link href="http://toughcoder.net/blog/2022/01/17/develop-with-java-8/"/>
    <updated>2022-01-17T22:55:19+08:00</updated>
    <id>http://toughcoder.net/blog/2022/01/17/develop-with-java-8</id>
    <content type="html"><![CDATA[<p>Java作为面向对象编程的王牌语言，曾经风靡一时，在Web领域是绝对的老大。随着时间的推移，一些新的编程范式不断的涌现，如函数式编程，响应式编程，以及对函数的全力支持（Lambda函数）变成了大家经常谈论的话题。移动互联网的出现，以及前端的流行，让新一代的编程语言如<a href="https://scala-lang.org/">Scala</a>，<a href="http://www.groovy-lang.org/">Groovy</a>，<a href="https://developer.apple.com/swift/">Swift</a>以及<a href="https://kotlinlang.org/">Kotlin</a>都大受欢迎。以函数式编程为核心的新一代编程范式慢慢变成了主流。曾经的王者Java，一度被人垢病，因为对函数支持不友好，（其实最主要的原因是如何保持好向后兼容），但也与时俱进，终于在Java 8版本迈出了重大的一步，完全支持了函数式编程。本篇将重点讨论Java 8的新特性，以及如何用Java 8来实践函数式编程。</p>

<p><a href=""><img src="https://cdn.educba.com/academy/wp-content/uploads/2020/01/java-8-features.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">Lambda表达式</a></h2>

<p>也即匿名函数，称之为lambda。具体数学上的定义比较复杂就不多说了。为了便于理解，我们先从匿名内部类说起。</p>

<p><img src="https://www.callicoder.com/static/a42462af7361c61f46c6ef49f0a5bb26/c1b63/java-lambda-expressions-tutorial.png" alt="" /></p>

<p>Java早就支持匿名内部类，这是在当年相比较C++一个重要大的提升，它在一些需要提供行为实现的地方还是非常方便的，典型的例子就是UI中的点击事件的处理：</p>

<pre><code class="java">button.addActionListener(new ActionListener() {
    @Override
    void actionPerformed(ActionEvent e) {
        System.out.println("Button is clicked: " + e);
    }
});
</code></pre>

<p>这里的要点就是我们向button传递的是一个行为，也就是说按扭点击了时，要执行什么样的行为。对比其他现代语言，这还是显得有些笨重，没有简单明了的说明意图。用Java 8，这就好办多了，可以这样写：
<code>java
button.addActionListener(e -&gt; System.out.println("Button is clicked: " + e);
</code>
括号里面这一坨就是一个Lambda表达式，它是一个行为（严格来说是一个函数），用以直接向目标对象传递一个行为，对比前面的例子，可以发现，这种场景下使用Lambda更加的简洁高效。</p>

<h3>Lambda表达式的语法</h3>

<p>它的通用语法是：
<code>java
(p1, p2....) -&gt; {
    statements;
}
</code>
括号里面是参数列表，当只有一个参数时，括号可省略，但当参数多于1个时，或者显示声明了参数类型时，括号不能省略，如：
<code>java
names.sort((a, b) -&gt; b.compareTo(a));
button.addActionListener((ActionEvent e) -&gt; System.out.println("Button is clicked: " + e));
</code>
花括号中就是语句块了，这跟常规语句块（如if， while等）是一样的，如果有返回值就return，把它理解为常规方法的实体就可以了，像写常规函数实现那样去写就好了。如果只有一个语句，或者一条表达式，可以省略花括号。</p>

<h3>类型推断</h3>

<p>Lambda表达是匿名函数，主要用以向目标对象传递行为，既然匿名，当然是图简洁和清晰，因此就不要弄的太复杂。所以，参数的类型，以及表达式的返回值（如有）的类型，都是编译器通过上下文来推断出来的，因此，不用给参数写类型，如果因为实现的接口不明确，编译器看不懂的话，会有编译报错的。</p>

<p>关于类型推断可以看《Java 8函数式编程》的第2章第5节有详细的讨论。</p>

<h3><a href="https://www.geeksforgeeks.org/closures-in-java-with-examples/">闭包</a></h3>

<p>也就是closure，严格的数学定义就不说了，有点复杂和难于理解，简单来说就是Lambda表达中使用了一个其定义域外的变量的值（称作捕获外部变量），lambda即变成了一个闭包。还是有点绕，这个其实并不陌生，以前的匿名内部就是可以使用外部变量的，只不过编译器要强加final修饰，如：
<code>java
final int numberOfStudents = countStudents();
button.addActionListener(new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
        System.out.println("Number of students is " + numberOfStudents);
    }
}
</code>
这里其实就是一个闭包了，匿名内部类中捕获了外部的变量numberOfStudents，只不过要强加final修饰，这是因为这里要传值。</p>

<p>Java 8里面呢，外部变量不必用final修饰了，但是，它也必须实际上是final的：
<code>java
int numberOfStudents = countStudents();
button.addActionListener(e -&gt; System.out.println("Number of students is " + numberOfStudents));
</code>
因为，之前啊，假如捕获了一个外部变量，不是final的，会有编译错误，但如果你用IDE的建议时，它就直接再声明一个final变量，用原变量赋值，然后把新的final变量传给匿名内部类，如：
<code>java
int numberOfStudents = countStudents();
final int finalNumberOfStudents = numberOfStudents;
button.addActionListener(new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
        System.out.println("Number of students is " + finalNumberOfStudents);
    }
}
</code>
到此就明白了，Java 8对于闭包的支持，其实较之前没有实质的变化，只不过编译器帮你做了这个final变量的定义而已。</p>

<p>这部分可以参考《Java 8函数式编程》中第2章第3节的内容。</p>

<h2><a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/JavaSE8DefaultMethods/JavaSE8DefaultMethods.html">接口方法默认实现</a></h2>

<p>Java 8中，可以给接口interface，添加一个方法的默认实现，这样在实现此接口时，子类可以选择重新实现，或者不实现，直接调用此方法即可，从语法上来说，是比较简单的，用default关键字来修饰方法即可，如：</p>

<pre><code class="java">interface Formula {
    double calculate(int a);

    default double sqrt(int a) {
        return Math.sqrt(a);
    }
}

class ComplexFormula implements Formula {
    double calculate(int a) {
         return super.sqrt(real) + super.sqrt(imaginary);
    }
}
</code></pre>

<p>这里面，子类ComplexFormula是可以正常编译和运行的。</p>

<p><strong>注意</strong>：接口是支持多重继承的，比如一个类可以实现多个接口，这就有可能存在接口中有相同的默认方法，最好的处理方法就是子类重新实现一下此方法，然后可以用接口的名字+super来具体指定父类中的方法。这一具体的规则比较复杂，可以看《Java 8函数式编程》这本书中的第4章第7节，有比较详细的论述。</p>

<p>另外，需要注意，实际运用中，接口的默认方法并不常用，因为这本身就是比较奇怪的，与最初Java的设计有冲突，接口策重于行为的高级抽象，而抽象类侧重对象的高级抽象（多半涉及状态属性）。这东西的出现主要是为了解决向后兼容，比如说当你一个被广泛使用的接口添加了一个新的方法时，所有实现此接口的类必须全部要改一遍，要实现此接口，这会影响大量的现存代码，而默认方法就是为了解决这个问题的，给新添加的方法标记为default，就不会影响现存代码了。</p>

<p>这个可以仔细读一下《Java 8函数式编程》中的第4章第6节和第7节的内容。</p>

<h2><a href="https://www.geeksforgeeks.org/functional-interfaces-java/">函数接口</a></h2>

<p>支持函数式编程范式的语言一般来说呢，会把函数作为语义上的一级类型，比如像Python或者Kotlin都有专门用于声明函数的关键字。另外，需要澄清一下函数的概念，简单来说函数就是给定一些输入，然后给出输出，输出随输入改变而改变，<strong>不会产生副作用，也就是不会修改全局变量，不会修改环境变量</strong>。且<strong>具有幂等性，即针对 同一组输入，多次调用，结果仍是一样的</strong>，这就是函数。</p>

<p>对于Java，这事儿就有点难办了，因为前面的版本根本就没有把方法独立成为函数，方法必须存在于类中。为了支持函数，函数是函数式编程的基本要素，所以要想支持函数式编程，必须以某种方式来支持函数的定义。Java 8中就提出了函数接口的概念。</p>

<p><strong>函数接口是只有一个抽象方法的接口</strong>，这里有两个关键信息，首先，<strong>语义上的类型必须是一个interface</strong>，其次，<strong>它只能有一个抽象方法</strong>，放在以前的版本，其实意思就是说只有能一个方法，但还要注意的是前面提到的默认方法。那么这里的要求就是<strong>除了默认方法以外，只能有一个方法</strong>。</p>

<p>函数接口必须用<em>@FunctionalInterface</em>注解来标注，编译器会对它做特别的关注，一旦有超过1个抽象接口，就会编译报错。为啥要用注解而不是增加关键字（如function），或者创建一级类型（如function interface），目的仍是向后兼容。注解仅需要在编译阶段做一些额外的事情即可，这即实现了扩展，又保持了兼容性。</p>

<p>前面提到的Lambda表达式必须是一个函数接口的实例，这样说太抽象了，慢慢来解释下。Lambda是一个匿名函数，可以把它理解为一个对象，它所实现的必须是一个函数接口。换句话说，只有声明为函数接口的地方，也就是方法的参数类型或者变量的类型要声明为函数接口，只有这里才可以传入lambda表达式。</p>

<p>接着前面的Formula例子，假如有如下应用场景：
<code>java
class Number {
    int payload;
    public Number transform(Formula formula) {
         return formula.calculate(payload);
    }
}
</code>
现在调用transform方法时如果直接传递lambda，是会报错的：
<code>java
number.transform(a -&gt; a * a); // won't compile
</code>
解决方法，就是要给Formula添加函数接口注解：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@FunctionalInterface</span>
</span><span class='line'><span class="kd">interface</span> <span class="nc">Formula</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">double</span> <span class="nf">calculate</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">);&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">default</span> <span class="kt">double</span> <span class="nf">sqrt</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>关于函数接口，可以参阅《Java 8函数式编程》中第2章第4节和第4章第4节。</p>

<h3>常用的函数接口</h3>

<p>Java 8 定义了一些非常常用的函数接口，这里做一下简单的介绍。</p>

<h4><a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html">Predict<T></a></h4>

<p>断言，给定一个类型为T的输入，给出boolean的输出（true of false）。通常用于过滤操作之中：
<code>java
Predict&lt;String&gt; isEmpty = String::isEmpty;
students.stream()
    .filter(name -&gt; !name.isEmpty());
</code></p>

<h4><a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html">Function&lt;T, R></a></h4>

<p>通用的函数操作，给定类型为T的输入，返回类型为R的输出，通常用于map之中：</p>

<pre><code class="java">Function&lt;String, int&gt; length = name -&gt; name.length();
</code></pre>

<p>其实，Predict可视为一种特殊的Function，它的返回类型是boolean。</p>

<h4><a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html">Consumer<T></a></h4>

<p>消费类型为T的对象，无输出，作为调用链的终点，通常用于生成终值，如前面例子中传给button的lambda就一个Consumer。</p>

<h4><a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html">Supplier<T></a></h4>

<p>返回一个类型为T的对象，也即生产者，通常都是用于工厂方法，用来生成新的对象。</p>

<h4><a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/UnaryOperator.html">UnaryOperator<T></a></h4>

<p>一元操作符，输入类型是T的对象，返回类型是T的对象：
<code>java
UnaryOperator&lt;Integer&gt; square = x -&gt; x * x;
</code></p>

<h4><a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/BinaryOperator.html">BinaryOperator<T></a></h4>

<p>二元操作符，输入参数是类型同为T的a和b两个参数，输出是一个类型为T的结果：
<code>java
BinaryOperator&lt;String&gt; join = (first, second) -&gt; first + ", " + second;
</code>
这里例子不是很多，因为单独写这些函数接口的lambda不太好写，且意义不够实用，会在后面结合Stream API，给出更多示例。</p>

<h2><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">Optional</a></h2>

<p>这个类用于封装可能为空的对象，以更好的处理null的情况，它加强了类型检查（null本身是没有类型的），以及使用时的空值检查，所以可以一定程度上防止NullPointerException的出现。</p>

<p><img src="https://sboychenko.ru/wp-content/uploads/2016/09/java8-optional.jpg" alt="" /></p>

<p>先来看一下它的简单使用方法：
<code>java
Optional&lt;String&gt; a = Optional.of("a");
System.out.println(a.get()); // a
Optional empty = Optional.empty(); // 返回一个为空的对象
System.out.println(empty.isPresent()); // false
System.out.println(empty.orElse("b"); // b
System.out.println(empty.orElseGet(() -&gt; "c")); // c
</code>
前面2行好理解了，第3行创建一个为空的Optional对象，它的isPresent会返回false，orElse是说如果为空时可以返回一个默认值『b』，而最后一行也可以为默认值提供一个Supplier以在为空的时候产生一个值。</p>

<p>通过这几个小例子可以看出Optional的用途，它可以比较好的封装对象，并提前定义值不存在时的应对情况，能够一定程序上减少NPE。</p>

<p>不过，这个东西对于复杂项目来说效用不会太大，假如你到处判断isPresent，其实跟检测== null也没有本质区别。实际项目中大量的NPE来自于多线程环境共享成员变量，这种情况下Optional也救不了你。</p>

<p>要想发挥这东西的最大效用，需要从设计角度尽可能的减少变量共享，尽可能的缩小变量作用域，再配合默认值或者默认值的Suppiier，多管齐下，才能有效的防止NPE。</p>

<h2><a href="https://www.javatpoint.com/java-8-method-reference">方法引用</a></h2>

<p>函数式编程，函数要是语义层面的一级类型，变量或者参数的类型可以是函数，前面提到了在Java 8中代表函数类型就是函数接口。</p>

<p>那么，当传递具体函数体的时候，我们一直在使用lambda表达式，但这并不是适合所有场景，比如说我已经有了一个类的方法，完全符合函数接口的方法签名，难道还非要写一个lambda吗？
<code>java
button.addActionListener(event -&gt; System.out.println(event));
Predict&lt;String&gt; empty = str -&gt; str.isEmpty();
Function&lt;Artist, String&gt; namer = artist -&gt; artist.getName();
</code>
这显然太啰嗦了，这种情况下，可以直接用<strong>方法引用</strong>，来把已有的方法传递过去，形式是<strong>类名::方法名</strong>，用方法引用重写上面的几个小例子：
<code>java
button.addActionListener(System.out::println);
Predict&lt;String&gt; empty = String::isEmpty;
Function&lt;Artist, String&gt; namer = Artist::getName;
</code>
简洁了很多吧，不但可以复用已有的方法，简洁明了，而且也省去创建一个lambda对象。一定要注意的就是要用方法的名字，不能加括号，因为加了括号，在语义上就是对函数的调用了，引用的便是该方法的返回值，除非这个方法的返回值是一个函数接口实例（lambda或者一个方法引用）。</p>

<p>除了常规方法可以用作引用以外，还可以对构造方法进行引用，格式是<strong>类名::new</strong>，如
<code>java
Artist::new; // 相当于  (name, nationality) -&gt; new Artist(name, nationality);
</code></p>

<p>可以参阅《Java 8函数式编程》第5章第1节的内容。</p>

<h2><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Stream API</a></h2>

<p>终于到了最为重要的特性了，为了更进一步的支持函数式编程，Java 8新增了Stream API，它是针对集合类型（List，Map和Set等）函数式操作的支持，以更好的把行为与遍历分离。先来看一下小例子：</p>

<p>比如有这样一个列表：
<code>java
List&lt;String&gt; giants = List.of("Apple", "Google", "Microsoft", "Facebook", "Tesla");
</code>
想简单遍历一下，以前这么写：
<code>java
 for (String item : giants) {
     System.out.println(item);
 }
</code>
但，现在只需要这样写就可以了：
<code>java
giants.forEach(System.out::println);
</code>
是不是很清爽，这就是典型的函数式写法，你可能会说就这？客官别急，这只是前戏，后面还有更刺激的。</p>

<p><img src="https://www.north-47.com/wp-content/uploads/2019/06/java8streams.png" alt="" /></p>

<p><strong>注意</strong>：这里一定要与I/O stream区分开来，完全是两个东西。Stream API是针对 集合操作的函数式支持。</p>

<p>函数式编程核心元素是函数，它通过对函数的各种组合得到最终的结果，最为典型的就是流式调用，把函数串连起来，或者叫做链式调用，让数据在函数链中流动，最终得到期望的结果。最为经典的函数式『三板斧』就是过滤（filter），转换（map）和折叠（也称化约，英文是reduce），这是所有函数式程序的基本构造单元。可以参阅《函数式编程思维》这本书的第2章，有比较详细的讨论。</p>

<p><img src="https://files.realpython.com/media/TUT19---Functional-Programming_Watermarked.3bb16c6198a2.jpg" alt="" /></p>

<h3>复杂的实例</h3>

<p>为了更好的演示Java 8的Stream API，以及综合运用函数式方法，本文剩余部分，将基于<a href="https://www.nba.com/nets/">Brooklyn</a>的球员技术统计信息操作为基础的实例。球队中有多名球员，每个球员有一些基本信息和一组比赛技术统计，现在教练需要对信息做一些统计。基础的类型是球员包含其基本信息和技术统计，如下：</p>

<pre><code class="java">public class Player {
    private final String firstName;
    private final String lastName;
    private final String community;

    private final int points;
    private final int rebounds;
    private final float fieldGoal;

    @Override
    public String toString() {
        return "'" + firstName +
                ", " + lastName + '\'' +
                ", from '" + community + '\'' +
                ", scores=" + points +
                ", rebounds=" + rebounds +
                String.format(", fieldGoal=%.2f%%", fieldGoal * 100.f);
    }

    private Player(String firstName, String lastName, String community, int scores, int rebounds, float fieldGoal) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.community = community;
        this.points = scores;
        this.rebounds = rebounds;
        this.fieldGoal = fieldGoal;
    }

    public static class Builder {
        private String firstName;
        private String lastName;
        private String community;
        private int scores;
        private int  rebounds;
        private float fieldGoal;

        public Builder firstName(String firstName) {
            this.firstName = firstName;
            return this;
        }

        public Builder lastName(String lastName) {
            this.lastName = lastName;
            return this;
        }

        public Builder community(Supplier&lt;String&gt; communitySupplier) {
            community = communitySupplier.get();
            return this;
        }

        public Builder points(Supplier&lt;Integer&gt; pointsSupplier) {
            scores = pointsSupplier.get();
            return this;
        }

        public Builder rebounds(Supplier&lt;Integer&gt; reboundsSupplier) {
            rebounds = reboundsSupplier.get();
            return this;
        }

        public Builder fieldGoal(Supplier&lt;Float&gt; fgSupplier) {
            fieldGoal = fgSupplier.get();
            return this;
        }

        public Player build() {
            return new Player(firstName, lastName, community, scores, rebounds, fieldGoal);
        }
    }
}
</code></pre>

<p>再有就是球队了，就是针对球员们的操作的地方，首先，需要生成数据：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Brooklyn</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">List</span><span class="o">&lt;</span><span class="n">Player</span><span class="o">&gt;</span> <span class="n">players</span> <span class="o">=</span> <span class="n">generatePlayers</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kd">private</span> <span class="kd">static</span> <span class="n">List</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Player</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">generatePlayers</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">List</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">String</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">names</span> <span class="o">=</span> <span class="n">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span>
</span><span class='line'>            <span class="s">&quot;James Harden&quot;</span><span class="o">,</span> <span class="s">&quot;Kevin Durant&quot;</span><span class="o">,</span> <span class="s">&quot;Kyrie Irving&quot;</span><span class="o">,</span> <span class="s">&quot;Nic Clyxton&quot;</span><span class="o">,</span>
</span><span class='line'>            <span class="s">&quot;Kessler Edwards&quot;</span><span class="o">,</span> <span class="s">&quot;Bruce Brown&quot;</span><span class="o">,</span> <span class="s">&quot;LaMarcus Aldridge&quot;</span><span class="o">,</span> <span class="s">&quot;Blake Griffin&quot;</span>
</span><span class='line'>    <span class="o">);</span>
</span><span class='line'>    <span class="n">List</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">String</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">communities</span> <span class="o">=</span> <span class="n">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&quot;The Bronx&quot;</span><span class="o">,</span> <span class="s">&quot;Brooklyn&quot;</span><span class="o">,</span> <span class="s">&quot;Manhattan&quot;</span><span class="o">,</span> <span class="s">&quot;Queens&quot;</span><span class="o">,</span> <span class="s">&quot;Staten Island&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="n">Random</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Random</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">());</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">names</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>            <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">name</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">String</span><span class="o">[]</span> <span class="n">parts</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">);</span>
</span><span class='line'>                <span class="k">return</span> <span class="k">new</span> <span class="n">Player</span><span class="o">.</span><span class="na">Builder</span><span class="o">().</span><span class="na">firstName</span><span class="o">(</span><span class="n">parts</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span>
</span><span class='line'>                        <span class="o">.</span><span class="na">lastName</span><span class="o">(</span><span class="n">parts</span><span class="o">[</span><span class="mi">1</span><span class="o">])</span>
</span><span class='line'>                        <span class="o">.</span><span class="na">community</span><span class="o">(()</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="o">{</span>
</span><span class='line'>                            <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">communities</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
</span><span class='line'>                            <span class="k">return</span> <span class="n">communities</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
</span><span class='line'>                        <span class="o">})</span>
</span><span class='line'>                        <span class="o">.</span><span class="na">points</span><span class="o">(()</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">61</span><span class="o">))</span>
</span><span class='line'>                        <span class="o">.</span><span class="na">rebounds</span><span class="o">(()</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">31</span><span class="o">))</span>
</span><span class='line'>                        <span class="o">.</span><span class="na">fieldGoal</span><span class="o">(()</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">random</span><span class="o">.</span><span class="na">nextFloat</span><span class="o">())</span>
</span><span class='line'>                        <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</span><span class='line'>            <span class="o">})</span>
</span><span class='line'>            <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>这里为了方便使用了一个<a href="https://refactoring.guru/design-patterns/builder">Builder Pattern</a>。另外，创建数据的过程中，其实用到上面提到的大量知识点，如Supplier的使用，以及闭包和方法引用。整体并不难，可以仔细读一读例子中的代码。</p>

<h3>Stream基础操作</h3>

<p>先来看一下Stream的基础操作，包括filter，map和reduce，以及sort和match，不准备说太多的废话，将以实例操作为主线来讲解。</p>

<h4>forEach</h4>

<p>也即遍历，非常方便：
<code>java
players.forEach(System.out::println);
</code>
输出会是：</p>

<blockquote><p>&lsquo;James, Harden&rsquo;, from &lsquo;Brooklyn&rsquo;, scores=11, rebounds=24, fieldGoal=10.62% <br/>
&lsquo;Kevin, Durant&rsquo;, from &lsquo;Queens&rsquo;, scores=48, rebounds=4, fieldGoal=47.16% <br/>
&lsquo;Kyrie, Irving&rsquo;, from &lsquo;Staten Island&rsquo;, scores=17, rebounds=21, fieldGoal=86.05% <br/>
&lsquo;Nic, Clyxton&rsquo;, from &lsquo;Queens&rsquo;, scores=43, rebounds=11, fieldGoal=99.66% <br/>
&lsquo;Kessler, Edwards&rsquo;, from &lsquo;The Bronx&rsquo;, scores=55, rebounds=12, fieldGoal=46.78% <br/>
&lsquo;Bruce, Brown&rsquo;, from &lsquo;Queens&rsquo;, scores=10, rebounds=20, fieldGoal=77.51% <br/>
&lsquo;LaMarcus, Aldridge&rsquo;, from &lsquo;Manhattan&rsquo;, scores=35, rebounds=22, fieldGoal=98.18% <br/>
&lsquo;Blake, Griffin&rsquo;, from &lsquo;Brooklyn&rsquo;, scores=3, rebounds=4, fieldGoal=38.06% <br/></p></blockquote>

<p>这个使用起来相当简单，forEach接收一个Consumer，另外需要注意的是forEach不会返回一个Stream对象，所以不能在其后再继续添加链了。它通常作为整个链路的终端，消费最终结果。</p>

<p><strong>注意</strong>：因为数据生成过程中使用了一些随机数，所以运行结果可能会不同。</p>

<h4>filter</h4>

<p>想看看哪些球员，命中率超过五成：
<code>java
       players.stream()
                .filter(player -&gt; player.getFieldGoal() &gt;= 0.5f)
                .forEach(System.out::println);
</code>
输出：</p>

<blockquote><p>&lsquo;James, Harden&rsquo;, from &lsquo;Brooklyn&rsquo;, scores=6, rebounds=22, fieldGoal=95.02% <br/>
&lsquo;Kevin, Durant&rsquo;, from &lsquo;The Bronx&rsquo;, scores=37, rebounds=17, fieldGoal=78.81% <br/>
&lsquo;Bruce, Brown&rsquo;, from &lsquo;Queens&rsquo;, scores=26, rebounds=23, fieldGoal=57.35% <br/>
&lsquo;LaMarcus, Aldridge&rsquo;, from &lsquo;The Bronx&rsquo;, scores=35, rebounds=4, fieldGoal=59.75% <br/></p></blockquote>

<p>filter还是很容易理解的，它接收一个Predict，然后返回Stream中符合条件的元素，也即Predict中是true的。</p>

<h4>map</h4>

<p>转换，把一种数据类型转换为另外一种类型，其实从创建数据的方法generatePlayers中就可以看到了，是把String转换为Player，根据名字生成数据对象。</p>

<h4>sort</h4>

<p>接着前面的例子，把输出按命中率从高到低排个序吧：
<code>java
    players.stream()
                .filter(player -&gt; player.getFieldGoal() &gt;= 0.5f)
                .sorted((a, b) -&gt; (int) (b.getFieldGoal()*100 - a.getFieldGoal()*100))
                .forEach(System.out::println);
</code>
输出：</p>

<blockquote><p>&lsquo;Nic, Clyxton&rsquo;, from &lsquo;Queens&rsquo;, scores=34, rebounds=17, fieldGoal=93.82% <br/>
&lsquo;Kyrie, Irving&rsquo;, from &lsquo;Brooklyn&rsquo;, scores=37, rebounds=16, fieldGoal=82.95% <br/>
&lsquo;LaMarcus, Aldridge&rsquo;, from &lsquo;Staten Island&rsquo;, scores=43, rebounds=10, fieldGoal=52.94% <br/></p></blockquote>

<h4>flatMap</h4>

<p>map是把一种数据类型转换为另外一各类型，然后让其在链式中流动，flatMap是更为复杂的操作，它是先做map再做flat，想当于把二维的Stream展平成为一维的Stream，传给flatMap的lambda必须返回一个Stream，来看个例子：
&#8220;`java
     public static Stream<String> queryEmail(String name) {
         return Stream.of(name + &ldquo;@brooklyn.nets&rdquo;);
     }</p>

<pre><code> players.stream()
        .flatMap(player -&gt; queryEmail(player.getLastName()))
        .forEach(System.out::println);
</code></pre>

<pre><code>输出：
&gt;Harden@brooklyn.nets &lt;br /&gt;
&gt;Durant@brooklyn.nets &lt;br /&gt;
&gt;Irving@brooklyn.nets &lt;br /&gt;
&gt;Clyxton@brooklyn.nets &lt;br /&gt;
&gt;Edwards@brooklyn.nets &lt;br /&gt;
&gt;Brown@brooklyn.nets &lt;br /&gt;
&gt;Aldridge@brooklyn.nets &lt;br /&gt;
&gt;Griffin@brooklyn.nets &lt;br /&gt;

这里的获取到的Email是另外一个Stream，所以这里必须用flatMap，也即当把player转换为Email后，必须要再flat，变成最初的链中的对象。

### 及时求值
前面讲的操作都是[惰性求值](https://www.geeksforgeeks.org/scala-lazy-evaluation/)的，它们都是返回一个Stream，而Stream本身仅是封装操作，其实并没有生成最终值。但有些操作是可以生成最终值的，就是把整个链路的值进行运算，然后生成最终的值，但这个值不再是Stream了，也就是说及时求值操作只能作为链式的终点。

**注意**：惰性求值是函数式编程的一个概念，它的主要目的是将行为与结果分离开来，以方便并行化处理。具体可以参阅《函数式编程思维》书中的第4章，有详细的论述。

#### count
计算一下来自『Queens』的球员数量：
</code></pre>

<pre><code>    long fromQueens = players.stream()
            .filter(player -&gt; player.getCommunity().equals("Queens"))
            .count();
    System.out.println(fromQueens);
    // Output is: 2
</code></pre>

<pre><code>
#### match
查看Stream的元素中是否有匹配的条件的，有any意即任意元素有了匹配，all所有，none没有（相当于not all）：
</code></pre>

<pre><code>    boolean fromQueens = players.stream()
            .anyMatch(player -&gt; player.getCommunity().equals("Queens"));
    System.out.println(fromQueens);
    // 是否有人来自于Queens，true
    boolean fromQueens = players.stream()
            .allMatch(player -&gt; player.getCommunity().equals("Queens"));
    System.out.println(fromQueens);
    // 所有人都来自Queens，false
    boolean fromQueens = players.stream()
            .noneMatch(player -&gt; player.getCommunity().equals("Queens"));
    System.out.println(fromQueens);
    // 所有人都来自非Queens，false
</code></pre>

<pre><code>
#### reduce
折叠或者叫作化约，有些语言也称之为fold，它接收两个参数，第一个是初始值，然后是一个二元操作符BinaryOperator，二元操作的第一个参数是截止目前的结果，第二个参数是当前的元素，然后针对每个元素进行滚动执行这个二元操作符。这么说有点难于理解，我们来个，计算球员们的总得分吧：
</code></pre>

<pre><code>    int totalPoints = players.stream()
            .map(Player::getPoints)
            .reduce(0, (a, b) -&gt; a + b);
    System.out.println(totalPoints);
    // output is 247
</code></pre>

<pre><code>再来计算平均命中率：
</code></pre>

<pre><code>    Optional&lt;Float&gt; averageFieldGoal = players.stream()
            .map(Player::getFieldGoal)
            .reduce((a, b) -&gt; (a + b) / 2.f);
    System.out.println(averageFieldGoal.get());
    // Output is 0.40
</code></pre>

<pre><code>如果没有初始值，或者初始值是0（针对数值时），为空时（针对对象），那么可以省略reduce的第1个参数，这时它会用第1个元素用作初始值。
#### max和min
寻找最少的篮板数的球员：
</code></pre>

<pre><code>    Optional&lt;Player&gt; minRebound = players.stream()
                    .min((a, b) -&gt; a.getRebounds() - b.getRebounds());
    System.out.println(minRebound.get());
</code></pre>

<pre><code>输出：
&gt;'Kessler, Edwards', from 'Staten Island', scores=8, rebounds=2, fieldGoal=97.53% &lt;br/&gt;

寻找命中率最高的球员：
</code></pre>

<pre><code>    Optional&lt;Player&gt; bestShooter = players.stream()
                    .max((a, b) -&gt; (int) (a.getFieldGoal()*100f - b.getFieldGoal()*100f));
    System.out.println(bestShooter.get());
</code></pre>

<p>&#8220;`
输出：</p>

<blockquote><p>&lsquo;Bruce, Brown&rsquo;, from &lsquo;The Bronx&rsquo;, scores=25, rebounds=15, fieldGoal=88.19% <br/></p></blockquote>

<p><strong>注意</strong>：reduce无初始值时，max和min返回的都是Optional，因为可能会取不到具体的值。</p>

<h2>This is just the beginning</h2>

<p>学无止境，Stream API还有很多高级的工具，以及Java 8的新特性也还有很多，还有待后面继续深入学习。</p>

<h2>Android SDK的支持情况</h2>

<p>进入智能手机时代和移动互联网时代，Java曾一度没落，好在安卓的官方开发语言是Java，这也让Java没有被丢弃，虽然现在谷歌力推Kotlin，不过Java仍是安卓 开发的首选语言，且仍在被广泛使用。不过，安卓的Java，并不是Oracle的Java SE，而是基于Apache开源的OpenJDK，这货自Java 1.6版本以后就没怎么更新，而作为downstream的安卓，更是一直停留在1.6的版本上面，这也导致了安卓开发人猿一直未能跟紧Java的发展，当然 这也是Kotlin自推出以来大受安卓开发人猿欢迎的原因。好在谷歌也在推进，它是以打包插件的方式来支持Java 7和Java 8的部分子集。现在AGP（Android Gradle Plugin）4.0以上的版本，是可以使用大部分Java 8的特性的，前面讲述的lambda，Optional，函数接口和Stream等都是可以直接使用的，只要把AGP的版本升级到4.0以上，sourceCompatibility选择VERSION_1_8，就可以了。</p>

<p>可以参阅<a href="https://developer.android.com/studio/write/java8-support">官方文档</a>。而<a href="https://tech.meituan.com/2019/10/17/android-java-8.html">这篇文章</a>相当不错的阐述一些详细的原因，可以仔细读一下。</p>

<h2>优质书籍</h2>

<p>编程范式的学习曲线都是非常陡峭的，函数式编程注重的是行为的抽象，以行为（函数）为第一要素来构建解决方案，这需要思维的转变。并不是说你用了一个lambda就是函数式编程了。因此需要系统化的学习。而系统化的学习，最好的方式就是去啃书（没说看，是要啃书）。</p>

<p>下面列出关于函数式编程，特别是用Java 8进行实践函数式编程的几本非优质的书籍：</p>

<h3><a href="https://www.oreilly.com/library/view/functional-thinking/9781449365509/">Functional Thinking</a></h3>

<p>中译名是《函数式编程思维》，是由Neal Ford出品的佳作，专门讲述如何Thinking in Functional Programming。这本书也不是很厚，非常值得看。因为是重点讲解函数式编程思维 的，所以它用了Java/Scala和Groovy，并且Java的版本还不是Java 8的。</p>

<p>这里也要说一下，编程范式跟语言是否直接支持没有关系，它更是一种思维抽象方法，比如用C也能写出完全符合面向对象的代码；用Java 7以前的版本也能写出函数式程序。</p>

<h3><a href="https://www.amazon.com/Java-Lambdas-Functional-Programming-Masses/dp/1449370772">Java 8 Lambdas: Functional Programming For The Masses</a></h3>

<p>中译名是《Java 8函数式编程》，由Richard Warburton写的。里面有丰富的实例和练习题，也不厚，专注于讲解如何用Java 8来实践函数式编程。</p>

<h3><a href="https://www.manning.com/books/java-8-in-action">Java 8 in Action</a></h3>

<p>中译名《Java 8实战》，由三位作者Raoul-Gabriel Urma, Mario Fusco, and Alan Mycroft合著。内容其实与前面那个差不多，但略有不同，这本书是重点讲解Java 8的新特性的，当然大量篇幅也是讲用Java 8实践函数式编程的（因为Java 8最重要的改进就是对函数式编程的支持），但还有其他的内容。并且这本书较厚，里面各种知识点讲解比较详细。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://stackify.com/streams-guide-java-8/">A Guide to Java Streams in Java 8: In-Depth Tutorial With Examples</a></li>
<li><a href="https://www.exception.site/java8/java8-new-features">Java8 新特性教程</a></li>
<li><a href="https://juejin.cn/post/6844903830254010381">[译] 一文带你玩转 Java8 Stream 流，从此操作集合 So Easy</a></li>
<li><a href="https://segmentfault.com/a/1190000022791696">Java8 Stream完全使用指南</a></li>
<li><a href="https://www.baeldung.com/java-8-streams">The Java 8 Stream API Tutorial</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解Java ThreadLocal]]></title>
    <link href="http://toughcoder.net/blog/2016/11/14/understanding-java-threadlocal/"/>
    <updated>2016-11-14T22:05:18+08:00</updated>
    <id>http://toughcoder.net/blog/2016/11/14/understanding-java-threadlocal</id>
    <content type="html"><![CDATA[<p>ThreadLocal是Java提供的为每个线程存储线程独立的数据的存储方式，也就是说用ThreadLocal来保存的数据，只能被当前线程所访问，其他线程无法访问，因为只有（一个线程）当前线程能够访问，所以它是线程安全的，可以用来存储一些不能被共享的数据。</p>

<p><a href=""><img src="https://img.alicdn.com/imgextra/i1/715978679/TB2htRYbKNOdeFjSZFBXXctzXXa_!!715978679.jpg"></a></p>

<!-- more -->


<h3>基本使用方法</h3>

<p>ThreadLocal使用起来非常的简单，它支持泛型，可以把任意类型的数据放进ThreadLocal，一个ThreadLocal对象只能放一个对象：</p>

<pre><code class="java">ThreadLocal&lt;String&gt; mLocalCEOHolder = new ThreadLocal&lt;&gt;();
ThreadLocal&lt;Integer&gt; mOrdersCountHolder = new ThreadLocal&lt;&gt;();

mLocalCEOHolder.set("Alex Hilton");

String ceo = mLocalCEOHolder.get();

mOrdersCountHolder.set(30249);

int order = mOrdersCountHolder.get();
</code></pre>

<h3>实现原理解析</h3>

<p>就按上面的例子来解析它的实现原理：</p>

<ul>
<li><p>创建ThreadLocal对象</p>

<p> 先来看看它的构造方法：</p></li>
</ul>


<pre><code class="java">/**
 * Creates a thread local variable.
 * @see #withInitial(java.util.function.Supplier)
 */
public ThreadLocal() {
}
</code></pre>

<p>   很不幸，它的构造方法是空的，啥也没干。</p>

<ul>
<li>set方法
再来看下它的set方法:</li>
</ul>


<pre><code class="java">/**
 * Sets the current thread's copy of this thread-local variable
 * to the specified value.  Most subclasses will have no need to
 * override this method, relying solely on the {@link #initialValue}
 * method to set the values of thread-locals.
 *
 * @param value the value to be stored in the current thread's copy of
 *        this thread-local.
 */
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
</code></pre>

<p>这里先获取当前的调用线程，从其中获取一个叫做ThreadLocalMap的东西，如果它不为空就把当前对象this（ThreadLocal对象）作为key，把要存放的值作为value，放到这个ThreadLocalMap里面，如果map为空就先创建再存放。由此可以猜出ThreadLocalMap是一个Map型的数据结构，接着研究getMap和createMap，后面再详细说ThreadLocalMap。</p>

<pre><code class="java">/**
 * Get the map associated with a ThreadLocal. Overridden in
 * InheritableThreadLocal.
 *
 * @param  t the current thread
 * @return the map
 */
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}


/**
 * Create the map associated with a ThreadLocal. Overridden in
 * InheritableThreadLocal.
 *
 * @param t the current thread
 * @param firstValue value for the initial entry of the map
 */
void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}
</code></pre>

<p>getMap比较简单，它返回Thread对象的域对象threadLocal。createMap也很简单创建一个ThreadLocalMap对象，然后把它赋值给Thread对象的域变量。</p>

<ul>
<li>get方法
再来看看get方法：</li>
</ul>


<pre><code class="java">/**
 * Returns the value in the current thread's copy of this
 * thread-local variable.  If the variable has no value for the
 * current thread, it is first initialized to the value returned
 * by an invocation of the {@link #initialValue} method.
 *
 * @return the current thread's value of this thread-local
 */
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
         }
    }
    return setInitialValue();
}

/**
 * Variant of set() to establish initialValue. Used instead
 * of set() in case user has overridden the set() method.
 *
 * @return the initial value
 */
private T setInitialValue() {
    T value = initialValue();
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
    return value;
}
</code></pre>

<p>get方法与set方法类似，同样是从当前线程取其map，从其中以当前TheadLocal对象为key来查找值，如果找到了，就返回。如果map为空，或者没找到怎么办。就用setInitialValue来初始化线程的map对象，这个与set方法是一样的，只不过用空值(null)。</p>

<ul>
<li>ThreadLocalMap对象</li>
</ul>


<pre><code class="java">/**
 * ThreadLocalMap is a customized hash map suitable only for
 * maintaining thread local values. No operations are exported
 * outside of the ThreadLocal class. The class is package private to
 * allow declaration of fields in class Thread.  To help deal with
 * very large and long-lived usages, the hash table entries use
 * WeakReferences for keys. However, since reference queues are not
 * used, stale entries are guaranteed to be removed only when
 * the table starts running out of space.
 */
static class ThreadLocalMap {

    /**
     * The entries in this hash map extend WeakReference, using
     * its main ref field as the key (which is always a
     * ThreadLocal object).  Note that null keys (i.e. entry.get()
     * == null) mean that the key is no longer referenced, so the
     * entry can be expunged from table.  Such entries are referred to
     * as "stale entries" in the code that follows.
     */
    static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {
        /** The value associated with this ThreadLocal. */
        Object value;

        Entry(ThreadLocal&lt;?&gt; k, Object v) {
            super(k);
            value = v;
        }
    }

    /**
     * The initial capacity -- MUST be a power of two.
     */
    private static final int INITIAL_CAPACITY = 16;

    /**
     * The table, resized as necessary.
     * table.length MUST always be a power of two.
     */
    private Entry[] table;

    /* other codes ... */
}
</code></pre>

<p>完整的就不贴了，大家可以自己去查看。简单来理解，其实它就是一个HashMap，key是对ThreadLocal对象的WeakReference，value是我们放入ThreadLocal的对象。</p>

<p>到这里可以总结一下ThreadLocal的原理了：数据结构是存储在线程对象里的一个Map对象中，key是ThreadLocal对象的WeakReference，值就是我们想要存放的对象。</p>

<p><strong>注意</strong>：下面提到的Map的意思是Thread#threadLocals，也就是ThreadLocalMap对象</p>

<h3>核心所在</h3>

<p>网上面很多关于ThreadLocal的文章（如<a href="http://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/">这个</a>和<a href="http://www.cnblogs.com/dolphin0520/p/3920407.html">这个</a>）都没有讲清楚，到底它是用什么方法来保证只有当前线程才能访问，它们说的是都是它的数据结构，这个上面已经说了。但是光有一个Map，就够了吗？Thread对象有一个Map用来存储ThreadLocal数据，但是假如Thread有公开获取此Map的方法，那跟我们使用的共享变量有什么区别？</p>

<p>ThreadLocal的真正核心在于它取的<strong>当前线程</strong>的Map：</p>

<ul>
<li>每次从ThreadLocal取数据也好，放数据也好，目标的Map都是当前的线程的Map</li>
<li>线程的Map是包访问权限</li>
<li>放数据也好，取数据也好都是从当前线程的Map里存和取</li>
</ul>


<p>所以，ThreadLocal最关键的就是由Thread.currentThread()来保证当前线程的。线程到底是什么?线程简单来理解就是一个run方法，或者说一堆方法调用，它是一个时序的概念，是一堆按某种顺序运行的指令的集合。所以，当你调用ThreadLocal#set或者ThreadLocal#get时，在set和get方法实现里面会调用Thread.currentThread来取得调用栈所在的线程&mdash;也就是当前线程，这也就保证了，一个线程只能获取自己的Map。</p>

<p>另外，Map必须得与每个线程对象绑定，但又由于这个域是package作用域，只有同一个package的才能访问，所以只能从ThreadLocal里操作此Map也是相对安全的，也就是说想操作此Map只能通过ThreadLocal。当然了，如果能Hack一下，生成一个与Thread在同一个package的对象，就能够直接操作Map，也就能打破ThreadLocal的封装了，这时Map就变成可共享的了，也就失去了线程独有的特性。</p>

<h3>典型应用</h3>

<p>最典型的应用要数<a href="https://developer.android.com/reference/android/os/Looper.html">Looper</a>类的实现。</p>

<p>Looper的作用是帮助线程创建并运行一个消息循环（MessageQueue），很显然，一个线程有且只能有一个，那么ThreadLocal是最佳的方案。</p>

<h3>Android当中的实现</h3>

<p>与标准的Java的实现原理是一样的，都是把Map当作Thread的一个域，package作用域，ThreadLocal作为key, 里面的值作value。</p>

<p>只不过Map的具体实现略有不同。</p>
]]></content>
  </entry>
  
</feed>
