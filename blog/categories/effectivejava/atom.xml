<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectivejava | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/effectivejava/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2022-02-08T21:05:21+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深入学习Java虚拟机知识]]></title>
    <link href="http://toughcoder.net/blog/2022/02/08/study-further-the-java-virtual-machine/"/>
    <updated>2022-02-08T20:33:27+08:00</updated>
    <id>http://toughcoder.net/blog/2022/02/08/study-further-the-java-virtual-machine</id>
    <content type="html"><![CDATA[<p>Java编程语言的真核心是其虚拟机（Java Virtual Machine or JVM），JVM是真正的让Java宣言『Write Once，Run Anywhere』变成现实，JVM封装并隔离了不同的OS，JVM有它自己的标准和规范，从而凡是符合JVM的『代码』都可以在JVM上运行。Java编程语言并不是直接运行在JVM上面的，Java语言只是套在JVM上面的一层语言规则。</p>

<p><a href=""><img src="https://javatutorial.net/wp-content/uploads/2017/10/write-once-run-anywhere-jvm.png" title="auto auto" ></a></p>

<!-- more -->


<p>准确的说JVM接收的是一套叫做字节码（Bytecode）的东西，只要是能把一套语法规则『翻译』成为符合JVM规范的字节码，就可以在JVM上面运行，除了正统的Java之外，Scala，Groovy，以及Kotlin等等都是这样实现的，它们编译之后得到的就是字节码文件，字节码文件可直接运行在JVM之上。</p>

<p>那么字节码才是Java编程语言的真核心，值得深入研究和学习。</p>

<h2><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html">ClassLoader</a></h2>

<p>除了标准Java中的以外，在Android当中的<a href="https://developer.android.com/reference/java/lang/ClassLoader">ClassLoader</a>也要深入学习一下，这个是相当多的逆向技术的基础。</p>

<ul>
<li><a href="https://www.baeldung.com/java-classloaders">Class Loaders in Java</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/51374915">老大难的 Java ClassLoader 再不理解就老了</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/136083521">深入理解Android ClassLoader</a></li>
<li><a href="http://gityuan.com/2017/03/19/android-classloader/">Android类加载器ClassLoader</a></li>
</ul>


<h2>反射</h2>

<p>也即是运行时修改代码的能力，它是直接去修改JVM中的代码，也即是修改bytecode。纯编译型语言如C/C++是不可能有这种能力的。Java有这种能力是因为JVM的存在，编译只是把源码『翻译』成字节码。</p>

<p><a href="https://github.com/jOOQ/jOOR">jOOR</a></p>

<h2>JNI</h2>

<p>一些三方的号称可以热修复的工具如exposed和Andfix这些东西，之所以能够实现，是因为JVM本身就开了口子支持JNI，为了能让方法能让JVM找得到，就需要一个method table，而此method table是可以被修改的。</p>

<h2>动态代理</h2>

<p>除了官方JDK支持的以接口为基础的动态代理 方式之外，还有其他几种以子类化方式实现动态代理，但它们都是基于ASM的。</p>

<p><a href="https://github.com/cglib/cglib">cglib</a></p>

<p><a href="https://www.javassist.org/">Javassist</a></p>

<p><a href="https://bytebuddy.net/#/">Byte Buddy</a></p>

<h2>代码覆盖率检测</h2>

<p><a href="http://cobertura.github.io/cobertura/">Cobertura</a></p>

<p><a href="https://www.eclemma.org/jacoco/">JaCoCo</a></p>

<h2>Mock</h2>

<p>这是自动化测试以及单元测试必然会用到的利器。</p>

<p><a href="https://site.mockito.org/">Mockito</a></p>

<p><a href="https://easymock.org/">EasyMock</a></p>

<h2><a href="https://asm.ow2.io/">ASM</a></h2>

<p>这是一个神器，专门用来处理字节码的，所有其他的Java底层工具都是基于它来实现的，足可见它的牛逼之处。</p>

<h2>研究字节码的意义</h2>

<p>所有这些基于字节码的工具和技术存在的意义，是帮助我们如何更好的写出Java代码，而并不是纯粹去做一些逆向工程的事情。比如，效率工具，测试工具，调试工具和动态生成代码的技术等等。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://zhuanlan.zhihu.com/p/94498015">史上最通俗易懂的ASM教程</a></li>
<li><a href="https://www.jianshu.com/p/26e99d39b3fb">Java字节码处理框架ASM设计思想解析</a></li>
<li><a href="https://blog.51cto.com/lsieun/2924583">Java ASM系列一：Core API</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[拥抱新时代的Java]]></title>
    <link href="http://toughcoder.net/blog/2022/01/17/develop-with-java-8/"/>
    <updated>2022-01-17T22:55:19+08:00</updated>
    <id>http://toughcoder.net/blog/2022/01/17/develop-with-java-8</id>
    <content type="html"><![CDATA[<p>Java作为面向对象编程的王牌语言，曾经风靡一时，在Web领域是绝对的老大。随着时间的推移，一些新的编程范式不断的涌现，如函数式编程，响应式编程，以及对函数的全力支持（Lambda函数）变成了大家经常谈论的话题。移动互联网的出现，以及前端的流行，让新一代的编程语言如<a href="https://scala-lang.org/">Scala</a>，<a href="http://www.groovy-lang.org/">Groovy</a>，<a href="https://developer.apple.com/swift/">Swift</a>以及<a href="https://kotlinlang.org/">Kotlin</a>都大受欢迎。以函数式编程为核心的新一代编程范式慢慢变成了主流。曾经的王者Java，一度被人垢病，因为对函数支持不友好，（其实最主要的原因是如何保持好向后兼容），但也与时俱进，终于在Java 8版本迈出了重大的一步，完全支持了函数式编程。本篇将重点讨论Java 8的新特性，以及如何用Java 8来实践函数式编程。</p>

<p><a href=""><img src="https://cdn.educba.com/academy/wp-content/uploads/2020/01/java-8-features.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">Lambda表达式</a></h2>

<p>也即匿名函数，称之为lambda。具体数学上的定义比较复杂就不多说了。为了便于理解，我们先从匿名内部类说起。</p>

<p><img src="https://www.callicoder.com/static/a42462af7361c61f46c6ef49f0a5bb26/c1b63/java-lambda-expressions-tutorial.png" alt="" /></p>

<p>Java早就支持匿名内部类，这是在当年相比较C++一个重要大的提升，它在一些需要提供行为实现的地方还是非常方便的，典型的例子就是UI中的点击事件的处理：</p>

<pre><code class="java">button.addActionListener(new ActionListener() {
    @Override
    void actionPerformed(ActionEvent e) {
        System.out.println("Button is clicked: " + e);
    }
});
</code></pre>

<p>这里的要点就是我们向button传递的是一个行为，也就是说按扭点击了时，要执行什么样的行为。对比其他现代语言，这还是显得有些笨重，没有简单明了的说明意图。用Java 8，这就好办多了，可以这样写：
<code>java
button.addActionListener(e -&gt; System.out.println("Button is clicked: " + e);
</code>
括号里面这一坨就是一个Lambda表达式，它是一个行为（严格来说是一个函数），用以直接向目标对象传递一个行为，对比前面的例子，可以发现，这种场景下使用Lambda更加的简洁高效。</p>

<h3>Lambda表达式的语法</h3>

<p>它的通用语法是：
<code>java
(p1, p2....) -&gt; {
    statements;
}
</code>
括号里面是参数列表，当只有一个参数时，括号可省略，但当参数多于1个时，或者显示声明了参数类型时，括号不能省略，如：
<code>java
names.sort((a, b) -&gt; b.compareTo(a));
button.addActionListener((ActionEvent e) -&gt; System.out.println("Button is clicked: " + e));
</code>
花括号中就是语句块了，这跟常规语句块（如if， while等）是一样的，如果有返回值就return，把它理解为常规方法的实体就可以了，像写常规函数实现那样去写就好了。如果只有一个语句，或者一条表达式，可以省略花括号。</p>

<h3>类型推断</h3>

<p>Lambda表达是匿名函数，主要用以向目标对象传递行为，既然匿名，当然是图简洁和清晰，因此就不要弄的太复杂。所以，参数的类型，以及表达式的返回值（如有）的类型，都是编译器通过上下文来推断出来的，因此，不用给参数写类型，如果因为实现的接口不明确，编译器看不懂的话，会有编译报错的。</p>

<p>关于类型推断可以看《Java 8函数式编程》的第2章第5节有详细的讨论。</p>

<h3><a href="https://www.geeksforgeeks.org/closures-in-java-with-examples/">闭包</a></h3>

<p>也就是closure，严格的数学定义就不说了，有点复杂和难于理解，简单来说就是Lambda表达中使用了一个其定义域外的变量的值（称作捕获外部变量），lambda即变成了一个闭包。还是有点绕，这个其实并不陌生，以前的匿名内部就是可以使用外部变量的，只不过编译器要强加final修饰，如：
<code>java
final int numberOfStudents = countStudents();
button.addActionListener(new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
        System.out.println("Number of students is " + numberOfStudents);
    }
}
</code>
这里其实就是一个闭包了，匿名内部类中捕获了外部的变量numberOfStudents，只不过要强加final修饰，这是因为这里要传值。</p>

<p>Java 8里面呢，外部变量不必用final修饰了，但是，它也必须实际上是final的：
<code>java
int numberOfStudents = countStudents();
button.addActionListener(e -&gt; System.out.println("Number of students is " + numberOfStudents));
</code>
因为，之前啊，假如捕获了一个外部变量，不是final的，会有编译错误，但如果你用IDE的建议时，它就直接再声明一个final变量，用原变量赋值，然后把新的final变量传给匿名内部类，如：
<code>java
int numberOfStudents = countStudents();
final int finalNumberOfStudents = numberOfStudents;
button.addActionListener(new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
        System.out.println("Number of students is " + finalNumberOfStudents);
    }
}
</code>
到此就明白了，Java 8对于闭包的支持，其实较之前没有实质的变化，只不过编译器帮你做了这个final变量的定义而已。</p>

<p>这部分可以参考《Java 8函数式编程》中第2章第3节的内容。</p>

<h2><a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/JavaSE8DefaultMethods/JavaSE8DefaultMethods.html">接口方法默认实现</a></h2>

<p>Java 8中，可以给接口interface，添加一个方法的默认实现，这样在实现此接口时，子类可以选择重新实现，或者不实现，直接调用此方法即可，从语法上来说，是比较简单的，用default关键字来修饰方法即可，如：</p>

<pre><code class="java">interface Formula {
    double calculate(int a);

    default double sqrt(int a) {
        return Math.sqrt(a);
    }
}

class ComplexFormula implements Formula {
    double calculate(int a) {
         return super.sqrt(real) + super.sqrt(imaginary);
    }
}
</code></pre>

<p>这里面，子类ComplexFormula是可以正常编译和运行的。</p>

<p><strong>注意</strong>：接口是支持多重继承的，比如一个类可以实现多个接口，这就有可能存在接口中有相同的默认方法，最好的处理方法就是子类重新实现一下此方法，然后可以用接口的名字+super来具体指定父类中的方法。这一具体的规则比较复杂，可以看《Java 8函数式编程》这本书中的第4章第7节，有比较详细的论述。</p>

<p>另外，需要注意，实际运用中，接口的默认方法并不常用，因为这本身就是比较奇怪的，与最初Java的设计有冲突，接口策重于行为的高级抽象，而抽象类侧重对象的高级抽象（多半涉及状态属性）。这东西的出现主要是为了解决向后兼容，比如说当你一个被广泛使用的接口添加了一个新的方法时，所有实现此接口的类必须全部要改一遍，要实现此接口，这会影响大量的现存代码，而默认方法就是为了解决这个问题的，给新添加的方法标记为default，就不会影响现存代码了。</p>

<p>这个可以仔细读一下《Java 8函数式编程》中的第4章第6节和第7节的内容。</p>

<h2><a href="https://www.geeksforgeeks.org/functional-interfaces-java/">函数接口</a></h2>

<p>支持函数式编程范式的语言一般来说呢，会把函数作为语义上的一级类型，比如像Python或者Kotlin都有专门用于声明函数的关键字。另外，需要澄清一下函数的概念，简单来说函数就是给定一些输入，然后给出输出，输出随输入改变而改变，<strong>不会产生副作用，也就是不会修改全局变量，不会修改环境变量</strong>。且<strong>具有幂等性，即针对 同一组输入，多次调用，结果仍是一样的</strong>，这就是函数。</p>

<p>对于Java，这事儿就有点难办了，因为前面的版本根本就没有把方法独立成为函数，方法必须存在于类中。为了支持函数，函数是函数式编程的基本要素，所以要想支持函数式编程，必须以某种方式来支持函数的定义。Java 8中就提出了函数接口的概念。</p>

<p><strong>函数接口是只有一个抽象方法的接口</strong>，这里有两个关键信息，首先，<strong>语义上的类型必须是一个interface</strong>，其次，<strong>它只能有一个抽象方法</strong>，放在以前的版本，其实意思就是说只有能一个方法，但还要注意的是前面提到的默认方法。那么这里的要求就是<strong>除了默认方法以外，只能有一个方法</strong>。</p>

<p>函数接口必须用<em>@FunctionalInterface</em>注解来标注，编译器会对它做特别的关注，一旦有超过1个抽象接口，就会编译报错。为啥要用注解而不是增加关键字（如function），或者创建一级类型（如function interface），目的仍是向后兼容。注解仅需要在编译阶段做一些额外的事情即可，这即实现了扩展，又保持了兼容性。</p>

<p>前面提到的Lambda表达式必须是一个函数接口的实例，这样说太抽象了，慢慢来解释下。Lambda是一个匿名函数，可以把它理解为一个对象，它所实现的必须是一个函数接口。换句话说，只有声明为函数接口的地方，也就是方法的参数类型或者变量的类型要声明为函数接口，只有这里才可以传入lambda表达式。</p>

<p>接着前面的Formula例子，假如有如下应用场景：
<code>java
class Number {
    int payload;
    public Number transform(Formula formula) {
         return formula.calculate(payload);
    }
}
</code>
现在调用transform方法时如果直接传递lambda，是会报错的：
<code>java
number.transform(a -&gt; a * a); // won't compile
</code>
解决方法，就是要给Formula添加函数接口注解：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@FunctionalInterface</span>
</span><span class='line'><span class="kd">interface</span> <span class="nc">Formula</span> <span class="o">{</span>
</span><span class='line'>    <span class="kt">double</span> <span class="nf">calculate</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">);&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">default</span> <span class="kt">double</span> <span class="nf">sqrt</span><span class="o">(</span><span class="kt">int</span> <span class="n">a</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">Math</span><span class="o">.</span><span class="na">sqrt</span><span class="o">(</span><span class="n">a</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>关于函数接口，可以参阅《Java 8函数式编程》中第2章第4节和第4章第4节。</p>

<h3>常用的函数接口</h3>

<p>Java 8 定义了一些非常常用的函数接口，这里做一下简单的介绍。</p>

<h4><a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html">Predict<T></a></h4>

<p>断言，给定一个类型为T的输入，给出boolean的输出（true of false）。通常用于过滤操作之中：
<code>java
Predict&lt;String&gt; isEmpty = String::isEmpty;
students.stream()
    .filter(name -&gt; !name.isEmpty());
</code></p>

<h4><a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Function.html">Function&lt;T, R></a></h4>

<p>通用的函数操作，给定类型为T的输入，返回类型为R的输出，通常用于map之中：</p>

<pre><code class="java">Function&lt;String, int&gt; length = name -&gt; name.length();
</code></pre>

<p>其实，Predict可视为一种特殊的Function，它的返回类型是boolean。</p>

<h4><a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html">Consumer<T></a></h4>

<p>消费类型为T的对象，无输出，作为调用链的终点，通常用于生成终值，如前面例子中传给button的lambda就一个Consumer。</p>

<h4><a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Supplier.html">Supplier<T></a></h4>

<p>返回一个类型为T的对象，也即生产者，通常都是用于工厂方法，用来生成新的对象。</p>

<h4><a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/UnaryOperator.html">UnaryOperator<T></a></h4>

<p>一元操作符，输入类型是T的对象，返回类型是T的对象：
<code>java
UnaryOperator&lt;Integer&gt; square = x -&gt; x * x;
</code></p>

<h4><a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/BinaryOperator.html">BinaryOperator<T></a></h4>

<p>二元操作符，输入参数是类型同为T的a和b两个参数，输出是一个类型为T的结果：
<code>java
BinaryOperator&lt;String&gt; join = (first, second) -&gt; first + ", " + second;
</code>
这里例子不是很多，因为单独写这些函数接口的lambda不太好写，且意义不够实用，会在后面结合Stream API，给出更多示例。</p>

<h2><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">Optional</a></h2>

<p>这个类用于封装可能为空的对象，以更好的处理null的情况，它加强了类型检查（null本身是没有类型的），以及使用时的空值检查，所以可以一定程度上防止NullPointerException的出现。</p>

<p><img src="https://sboychenko.ru/wp-content/uploads/2016/09/java8-optional.jpg" alt="" /></p>

<p>先来看一下它的简单使用方法：
<code>java
Optional&lt;String&gt; a = Optional.of("a");
System.out.println(a.get()); // a
Optional empty = Optional.empty(); // 返回一个为空的对象
System.out.println(empty.isPresent()); // false
System.out.println(empty.orElse("b"); // b
System.out.println(empty.orElseGet(() -&gt; "c")); // c
</code>
前面2行好理解了，第3行创建一个为空的Optional对象，它的isPresent会返回false，orElse是说如果为空时可以返回一个默认值『b』，而最后一行也可以为默认值提供一个Supplier以在为空的时候产生一个值。</p>

<p>通过这几个小例子可以看出Optional的用途，它可以比较好的封装对象，并提前定义值不存在时的应对情况，能够一定程序上减少NPE。</p>

<p>不过，这个东西对于复杂项目来说效用不会太大，假如你到处判断isPresent，其实跟检测== null也没有本质区别。实际项目中大量的NPE来自于多线程环境共享成员变量，这种情况下Optional也救不了你。</p>

<p>要想发挥这东西的最大效用，需要从设计角度尽可能的减少变量共享，尽可能的缩小变量作用域，再配合默认值或者默认值的Suppiier，多管齐下，才能有效的防止NPE。</p>

<h2><a href="https://www.javatpoint.com/java-8-method-reference">方法引用</a></h2>

<p>函数式编程，函数要是语义层面的一级类型，变量或者参数的类型可以是函数，前面提到了在Java 8中代表函数类型就是函数接口。</p>

<p>那么，当传递具体函数体的时候，我们一直在使用lambda表达式，但这并不是适合所有场景，比如说我已经有了一个类的方法，完全符合函数接口的方法签名，难道还非要写一个lambda吗？
<code>java
button.addActionListener(event -&gt; System.out.println(event));
Predict&lt;String&gt; empty = str -&gt; str.isEmpty();
Function&lt;Artist, String&gt; namer = artist -&gt; artist.getName();
</code>
这显然太啰嗦了，这种情况下，可以直接用<strong>方法引用</strong>，来把已有的方法传递过去，形式是<strong>类名::方法名</strong>，用方法引用重写上面的几个小例子：
<code>java
button.addActionListener(System.out::println);
Predict&lt;String&gt; empty = String::isEmpty;
Function&lt;Artist, String&gt; namer = Artist::getName;
</code>
简洁了很多吧，不但可以复用已有的方法，简洁明了，而且也省去创建一个lambda对象。一定要注意的就是要用方法的名字，不能加括号，因为加了括号，在语义上就是对函数的调用了，引用的便是该方法的返回值，除非这个方法的返回值是一个函数接口实例（lambda或者一个方法引用）。</p>

<p>除了常规方法可以用作引用以外，还可以对构造方法进行引用，格式是<strong>类名::new</strong>，如
<code>java
Artist::new; // 相当于  (name, nationality) -&gt; new Artist(name, nationality);
</code></p>

<p>可以参阅《Java 8函数式编程》第5章第1节的内容。</p>

<h2><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html">Stream API</a></h2>

<p>终于到了最为重要的特性了，为了更进一步的支持函数式编程，Java 8新增了Stream API，它是针对集合类型（List，Map和Set等）函数式操作的支持，以更好的把行为与遍历分离。先来看一下小例子：</p>

<p>比如有这样一个列表：
<code>java
List&lt;String&gt; giants = List.of("Apple", "Google", "Microsoft", "Facebook", "Tesla");
</code>
想简单遍历一下，以前这么写：
<code>java
 for (String item : giants) {
     System.out.println(item);
 }
</code>
但，现在只需要这样写就可以了：
<code>java
giants.forEach(System.out::println);
</code>
是不是很清爽，这就是典型的函数式写法，你可能会说就这？客官别急，这只是前戏，后面还有更刺激的。</p>

<p><img src="https://miro.medium.com/max/1400/0*QCmZZpGs_rcF5y2-.png" alt="" /></p>

<p><strong>注意</strong>：这里一定要与I/O stream区分开来，完全是两个东西。Stream API是针对 集合操作的函数式支持。</p>

<p>函数式编程核心元素是函数，它通过对函数的各种组合得到最终的结果，最为典型的就是流式调用，把函数串连起来，或者叫做链式调用，让数据在函数链中流动，最终得到期望的结果。最为经典的函数式『三板斧』就是过滤（filter），转换（map）和折叠（也称化约，英文是reduce），这是所有函数式程序的基本构造单元。可以参阅《函数式编程思维》这本书的第2章，有比较详细的讨论。</p>

<p><img src="https://files.realpython.com/media/TUT19---Functional-Programming_Watermarked.3bb16c6198a2.jpg" alt="" /></p>

<h3>复杂的实例</h3>

<p>为了更好的演示Java 8的Stream API，以及综合运用函数式方法，本文剩余部分，将基于<a href="https://www.nba.com/nets/">Brooklyn</a>的球员技术统计信息操作为基础的实例。球队中有多名球员，每个球员有一些基本信息和一组比赛技术统计，现在教练需要对信息做一些统计。基础的类型是球员包含其基本信息和技术统计，如下：</p>

<pre><code class="java">public class Player {
    private final String firstName;
    private final String lastName;
    private final String community;

    private final int points;
    private final int rebounds;
    private final float fieldGoal;

    @Override
    public String toString() {
        return "'" + firstName +
                ", " + lastName + '\'' +
                ", from '" + community + '\'' +
                ", scores=" + points +
                ", rebounds=" + rebounds +
                String.format(", fieldGoal=%.2f%%", fieldGoal * 100.f);
    }

    private Player(String firstName, String lastName, String community, int scores, int rebounds, float fieldGoal) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.community = community;
        this.points = scores;
        this.rebounds = rebounds;
        this.fieldGoal = fieldGoal;
    }

    public static class Builder {
        private String firstName;
        private String lastName;
        private String community;
        private int scores;
        private int  rebounds;
        private float fieldGoal;

        public Builder firstName(String firstName) {
            this.firstName = firstName;
            return this;
        }

        public Builder lastName(String lastName) {
            this.lastName = lastName;
            return this;
        }

        public Builder community(Supplier&lt;String&gt; communitySupplier) {
            community = communitySupplier.get();
            return this;
        }

        public Builder points(Supplier&lt;Integer&gt; pointsSupplier) {
            scores = pointsSupplier.get();
            return this;
        }

        public Builder rebounds(Supplier&lt;Integer&gt; reboundsSupplier) {
            rebounds = reboundsSupplier.get();
            return this;
        }

        public Builder fieldGoal(Supplier&lt;Float&gt; fgSupplier) {
            fieldGoal = fgSupplier.get();
            return this;
        }

        public Player build() {
            return new Player(firstName, lastName, community, scores, rebounds, fieldGoal);
        }
    }
}
</code></pre>

<p>再有就是球队了，就是针对球员们的操作的地方，首先，需要生成数据：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Brooklyn</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">List</span><span class="o">&lt;</span><span class="n">Player</span><span class="o">&gt;</span> <span class="n">players</span> <span class="o">=</span> <span class="n">generatePlayers</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kd">private</span> <span class="kd">static</span> <span class="n">List</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Player</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">generatePlayers</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">List</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">String</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">names</span> <span class="o">=</span> <span class="n">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span>
</span><span class='line'>            <span class="s">&quot;James Harden&quot;</span><span class="o">,</span> <span class="s">&quot;Kevin Durant&quot;</span><span class="o">,</span> <span class="s">&quot;Kyrie Irving&quot;</span><span class="o">,</span> <span class="s">&quot;Nic Clyxton&quot;</span><span class="o">,</span>
</span><span class='line'>            <span class="s">&quot;Kessler Edwards&quot;</span><span class="o">,</span> <span class="s">&quot;Bruce Brown&quot;</span><span class="o">,</span> <span class="s">&quot;LaMarcus Aldridge&quot;</span><span class="o">,</span> <span class="s">&quot;Blake Griffin&quot;</span>
</span><span class='line'>    <span class="o">);</span>
</span><span class='line'>    <span class="n">List</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">String</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">communities</span> <span class="o">=</span> <span class="n">List</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="s">&quot;The Bronx&quot;</span><span class="o">,</span> <span class="s">&quot;Brooklyn&quot;</span><span class="o">,</span> <span class="s">&quot;Manhattan&quot;</span><span class="o">,</span> <span class="s">&quot;Queens&quot;</span><span class="o">,</span> <span class="s">&quot;Staten Island&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="n">Random</span> <span class="n">random</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Random</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">());</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">names</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
</span><span class='line'>            <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">name</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">String</span><span class="o">[]</span> <span class="n">parts</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">);</span>
</span><span class='line'>                <span class="k">return</span> <span class="k">new</span> <span class="n">Player</span><span class="o">.</span><span class="na">Builder</span><span class="o">().</span><span class="na">firstName</span><span class="o">(</span><span class="n">parts</span><span class="o">[</span><span class="mi">0</span><span class="o">])</span>
</span><span class='line'>                        <span class="o">.</span><span class="na">lastName</span><span class="o">(</span><span class="n">parts</span><span class="o">[</span><span class="mi">1</span><span class="o">])</span>
</span><span class='line'>                        <span class="o">.</span><span class="na">community</span><span class="o">(()</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="o">{</span>
</span><span class='line'>                            <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="n">communities</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
</span><span class='line'>                            <span class="k">return</span> <span class="n">communities</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">index</span><span class="o">);</span>
</span><span class='line'>                        <span class="o">})</span>
</span><span class='line'>                        <span class="o">.</span><span class="na">points</span><span class="o">(()</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">61</span><span class="o">))</span>
</span><span class='line'>                        <span class="o">.</span><span class="na">rebounds</span><span class="o">(()</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">random</span><span class="o">.</span><span class="na">nextInt</span><span class="o">(</span><span class="mi">31</span><span class="o">))</span>
</span><span class='line'>                        <span class="o">.</span><span class="na">fieldGoal</span><span class="o">(()</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">random</span><span class="o">.</span><span class="na">nextFloat</span><span class="o">())</span>
</span><span class='line'>                        <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</span><span class='line'>            <span class="o">})</span>
</span><span class='line'>            <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">Collectors</span><span class="o">.</span><span class="na">toList</span><span class="o">());</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>这里为了方便使用了一个<a href="https://refactoring.guru/design-patterns/builder">Builder Pattern</a>。另外，创建数据的过程中，其实用到上面提到的大量知识点，如Supplier的使用，以及闭包和方法引用。整体并不难，可以仔细读一读例子中的代码。</p>

<h3>Stream基础操作</h3>

<p>先来看一下Stream的基础操作，包括filter，map和reduce，以及sort和match，不准备说太多的废话，将以实例操作为主线来讲解。</p>

<h4>forEach</h4>

<p>也即遍历，非常方便：
<code>java
players.forEach(System.out::println);
</code>
输出会是：</p>

<blockquote><p>&lsquo;James, Harden&rsquo;, from &lsquo;Brooklyn&rsquo;, scores=11, rebounds=24, fieldGoal=10.62% <br/>
&lsquo;Kevin, Durant&rsquo;, from &lsquo;Queens&rsquo;, scores=48, rebounds=4, fieldGoal=47.16% <br/>
&lsquo;Kyrie, Irving&rsquo;, from &lsquo;Staten Island&rsquo;, scores=17, rebounds=21, fieldGoal=86.05% <br/>
&lsquo;Nic, Clyxton&rsquo;, from &lsquo;Queens&rsquo;, scores=43, rebounds=11, fieldGoal=99.66% <br/>
&lsquo;Kessler, Edwards&rsquo;, from &lsquo;The Bronx&rsquo;, scores=55, rebounds=12, fieldGoal=46.78% <br/>
&lsquo;Bruce, Brown&rsquo;, from &lsquo;Queens&rsquo;, scores=10, rebounds=20, fieldGoal=77.51% <br/>
&lsquo;LaMarcus, Aldridge&rsquo;, from &lsquo;Manhattan&rsquo;, scores=35, rebounds=22, fieldGoal=98.18% <br/>
&lsquo;Blake, Griffin&rsquo;, from &lsquo;Brooklyn&rsquo;, scores=3, rebounds=4, fieldGoal=38.06% <br/></p></blockquote>

<p>这个使用起来相当简单，forEach接收一个Consumer，另外需要注意的是forEach不会返回一个Stream对象，所以不能在其后再继续添加链了。它通常作为整个链路的终端，消费最终结果。</p>

<p><strong>注意</strong>：因为数据生成过程中使用了一些随机数，所以运行结果可能会不同。</p>

<h4>filter</h4>

<p>想看看哪些球员，命中率超过五成：
<code>java
       players.stream()
                .filter(player -&gt; player.getFieldGoal() &gt;= 0.5f)
                .forEach(System.out::println);
</code>
输出：</p>

<blockquote><p>&lsquo;James, Harden&rsquo;, from &lsquo;Brooklyn&rsquo;, scores=6, rebounds=22, fieldGoal=95.02% <br/>
&lsquo;Kevin, Durant&rsquo;, from &lsquo;The Bronx&rsquo;, scores=37, rebounds=17, fieldGoal=78.81% <br/>
&lsquo;Bruce, Brown&rsquo;, from &lsquo;Queens&rsquo;, scores=26, rebounds=23, fieldGoal=57.35% <br/>
&lsquo;LaMarcus, Aldridge&rsquo;, from &lsquo;The Bronx&rsquo;, scores=35, rebounds=4, fieldGoal=59.75% <br/></p></blockquote>

<p>filter还是很容易理解的，它接收一个Predict，然后返回Stream中符合条件的元素，也即Predict中是true的。</p>

<h4>map</h4>

<p>转换，把一种数据类型转换为另外一种类型，其实从创建数据的方法generatePlayers中就可以看到了，是把String转换为Player，根据名字生成数据对象。</p>

<h4>sort</h4>

<p>接着前面的例子，把输出按命中率从高到低排个序吧：
<code>java
    players.stream()
                .filter(player -&gt; player.getFieldGoal() &gt;= 0.5f)
                .sorted((a, b) -&gt; (int) (b.getFieldGoal()*100 - a.getFieldGoal()*100))
                .forEach(System.out::println);
</code>
输出：</p>

<blockquote><p>&lsquo;Nic, Clyxton&rsquo;, from &lsquo;Queens&rsquo;, scores=34, rebounds=17, fieldGoal=93.82% <br/>
&lsquo;Kyrie, Irving&rsquo;, from &lsquo;Brooklyn&rsquo;, scores=37, rebounds=16, fieldGoal=82.95% <br/>
&lsquo;LaMarcus, Aldridge&rsquo;, from &lsquo;Staten Island&rsquo;, scores=43, rebounds=10, fieldGoal=52.94% <br/></p></blockquote>

<h4>flatMap</h4>

<p>map是把一种数据类型转换为另外一各类型，然后让其在链式中流动，flatMap是更为复杂的操作，它是先做map再做flat，想当于把二维的Stream展平成为一维的Stream，传给flatMap的lambda必须返回一个Stream，来看个例子：
&#8220;`java
     public static Stream<String> queryEmail(String name) {
         return Stream.of(name + &ldquo;@brooklyn.nets&rdquo;);
     }</p>

<pre><code> players.stream()
        .flatMap(player -&gt; queryEmail(player.getLastName()))
        .forEach(System.out::println);
</code></pre>

<pre><code>输出：
&gt;Harden@brooklyn.nets &lt;br /&gt;
&gt;Durant@brooklyn.nets &lt;br /&gt;
&gt;Irving@brooklyn.nets &lt;br /&gt;
&gt;Clyxton@brooklyn.nets &lt;br /&gt;
&gt;Edwards@brooklyn.nets &lt;br /&gt;
&gt;Brown@brooklyn.nets &lt;br /&gt;
&gt;Aldridge@brooklyn.nets &lt;br /&gt;
&gt;Griffin@brooklyn.nets &lt;br /&gt;

这里的获取到的Email是另外一个Stream，所以这里必须用flatMap，也即当把player转换为Email后，必须要再flat，变成最初的链中的对象。

### 及时求值
前面讲的操作都是[惰性求值](https://www.geeksforgeeks.org/scala-lazy-evaluation/)的，它们都是返回一个Stream，而Stream本身仅是封装操作，其实并没有生成最终值。但有些操作是可以生成最终值的，就是把整个链路的值进行运算，然后生成最终的值，但这个值不再是Stream了，也就是说及时求值操作只能作为链式的终点。

**注意**：惰性求值是函数式编程的一个概念，它的主要目的是将行为与结果分离开来，以方便并行化处理。具体可以参阅《函数式编程思维》书中的第4章，有详细的论述。

#### count
计算一下来自『Queens』的球员数量：
</code></pre>

<pre><code>    long fromQueens = players.stream()
            .filter(player -&gt; player.getCommunity().equals("Queens"))
            .count();
    System.out.println(fromQueens);
    // Output is: 2
</code></pre>

<pre><code>
#### match
查看Stream的元素中是否有匹配的条件的，有any意即任意元素有了匹配，all所有，none没有（相当于not all）：
</code></pre>

<pre><code>    boolean fromQueens = players.stream()
            .anyMatch(player -&gt; player.getCommunity().equals("Queens"));
    System.out.println(fromQueens);
    // 是否有人来自于Queens，true
    boolean fromQueens = players.stream()
            .allMatch(player -&gt; player.getCommunity().equals("Queens"));
    System.out.println(fromQueens);
    // 所有人都来自Queens，false
    boolean fromQueens = players.stream()
            .noneMatch(player -&gt; player.getCommunity().equals("Queens"));
    System.out.println(fromQueens);
    // 所有人都来自非Queens，false
</code></pre>

<pre><code>
#### reduce
折叠或者叫作化约，有些语言也称之为fold，它接收两个参数，第一个是初始值，然后是一个二元操作符BinaryOperator，二元操作的第一个参数是截止目前的结果，第二个参数是当前的元素，然后针对每个元素进行滚动执行这个二元操作符。这么说有点难于理解，我们来个，计算球员们的总得分吧：
</code></pre>

<pre><code>    int totalPoints = players.stream()
            .map(Player::getPoints)
            .reduce(0, (a, b) -&gt; a + b);
    System.out.println(totalPoints);
    // output is 247
</code></pre>

<pre><code>再来计算平均命中率：
</code></pre>

<pre><code>    Optional&lt;Float&gt; averageFieldGoal = players.stream()
            .map(Player::getFieldGoal)
            .reduce((a, b) -&gt; (a + b) / 2.f);
    System.out.println(averageFieldGoal.get());
    // Output is 0.40
</code></pre>

<pre><code>如果没有初始值，或者初始值是0（针对数值时），为空时（针对对象），那么可以省略reduce的第1个参数，这时它会用第1个元素用作初始值。
#### max和min
寻找最少的篮板数的球员：
</code></pre>

<pre><code>    Optional&lt;Player&gt; minRebound = players.stream()
                    .min((a, b) -&gt; a.getRebounds() - b.getRebounds());
    System.out.println(minRebound.get());
</code></pre>

<pre><code>输出：
&gt;'Kessler, Edwards', from 'Staten Island', scores=8, rebounds=2, fieldGoal=97.53% &lt;br/&gt;

寻找命中率最高的球员：
</code></pre>

<pre><code>    Optional&lt;Player&gt; bestShooter = players.stream()
                    .max((a, b) -&gt; (int) (a.getFieldGoal()*100f - b.getFieldGoal()*100f));
    System.out.println(bestShooter.get());
</code></pre>

<p>&#8220;`
输出：</p>

<blockquote><p>&lsquo;Bruce, Brown&rsquo;, from &lsquo;The Bronx&rsquo;, scores=25, rebounds=15, fieldGoal=88.19% <br/></p></blockquote>

<p><strong>注意</strong>：reduce无初始值时，max和min返回的都是Optional，因为可能会取不到具体的值。</p>

<h2>This is just the beginning</h2>

<p>学无止境，Stream API还有很多高级的工具，以及Java 8的新特性也还有很多，还有待后面继续深入学习。</p>

<h2>Android SDK的支持情况</h2>

<p>进入智能手机时代和移动互联网时代，Java曾一度没落，好在安卓的官方开发语言是Java，这也让Java没有被丢弃，虽然现在谷歌力推Kotlin，不过Java仍是安卓 开发的首选语言，且仍在被广泛使用。不过，安卓的Java，并不是Oracle的Java SE，而是基于Apache开源的OpenJDK，这货自Java 1.6版本以后就没怎么更新，而作为downstream的安卓，更是一直停留在1.6的版本上面，这也导致了安卓开发人猿一直未能跟紧Java的发展，当然 这也是Kotlin自推出以来大受安卓开发人猿欢迎的原因。好在谷歌也在推进，它是以打包插件的方式来支持Java 7和Java 8的部分子集。现在AGP（Android Gradle Plugin）4.0以上的版本，是可以使用大部分Java 8的特性的，前面讲述的lambda，Optional，函数接口和Stream等都是可以直接使用的，只要把AGP的版本升级到4.0以上，sourceCompatibility选择VERSION_1_8，就可以了。</p>

<p>可以参阅<a href="https://developer.android.com/studio/write/java8-support">官方文档</a>。而<a href="https://tech.meituan.com/2019/10/17/android-java-8.html">这篇文章</a>相当不错的阐述一些详细的原因，可以仔细读一下。</p>

<h2>优质书籍</h2>

<p>编程范式的学习曲线都是非常陡峭的，函数式编程注重的是行为的抽象，以行为（函数）为第一要素来构建解决方案，这需要思维的转变。并不是说你用了一个lambda就是函数式编程了。因此需要系统化的学习。而系统化的学习，最好的方式就是去啃书（没说看，是要啃书）。</p>

<p>下面列出关于函数式编程，特别是用Java 8进行实践函数式编程的几本非优质的书籍：</p>

<h3><a href="https://www.oreilly.com/library/view/functional-thinking/9781449365509/">Functional Thinking</a></h3>

<p>中译名是《函数式编程思维》，是由Neal Ford出品的佳作，专门讲述如何Thinking in Functional Programming。这本书也不是很厚，非常值得看。因为是重点讲解函数式编程思维 的，所以它用了Java/Scala和Groovy，并且Java的版本还不是Java 8的。</p>

<p>这里也要说一下，编程范式跟语言是否直接支持没有关系，它更是一种思维抽象方法，比如用C也能写出完全符合面向对象的代码；用Java 7以前的版本也能写出函数式程序。</p>

<h3><a href="https://www.amazon.com/Java-Lambdas-Functional-Programming-Masses/dp/1449370772">Java 8 Lambdas: Functional Programming For The Masses</a></h3>

<p>中译名是《Java 8函数式编程》，由Richard Warburton写的。里面有丰富的实例和练习题，也不厚，专注于讲解如何用Java 8来实践函数式编程。</p>

<h3><a href="https://www.manning.com/books/java-8-in-action">Java 8 in Action</a></h3>

<p>中译名《Java 8实战》，由三位作者Raoul-Gabriel Urma, Mario Fusco, and Alan Mycroft合著。内容其实与前面那个差不多，但略有不同，这本书是重点讲解Java 8的新特性的，当然大量篇幅也是讲用Java 8实践函数式编程的（因为Java 8最重要的改进就是对函数式编程的支持），但还有其他的内容。并且这本书较厚，里面各种知识点讲解比较详细。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://stackify.com/streams-guide-java-8/">A Guide to Java Streams in Java 8: In-Depth Tutorial With Examples</a></li>
<li><a href="https://www.exception.site/java8/java8-new-features">Java8 新特性教程</a></li>
<li><a href="https://juejin.cn/post/6844903830254010381">[译] 一文带你玩转 Java8 Stream 流，从此操作集合 So Easy</a></li>
<li><a href="https://segmentfault.com/a/1190000022791696">Java8 Stream完全使用指南</a></li>
<li><a href="https://www.baeldung.com/java-8-streams">The Java 8 Stream API Tutorial</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解Java ThreadLocal]]></title>
    <link href="http://toughcoder.net/blog/2016/11/14/understanding-java-threadlocal/"/>
    <updated>2016-11-14T22:05:18+08:00</updated>
    <id>http://toughcoder.net/blog/2016/11/14/understanding-java-threadlocal</id>
    <content type="html"><![CDATA[<p>ThreadLocal是Java提供的为每个线程存储线程独立的数据的存储方式，也就是说用ThreadLocal来保存的数据，只能被当前线程所访问，其他线程无法访问，因为只有（一个线程）当前线程能够访问，所以它是线程安全的，可以用来存储一些不能被共享的数据。</p>

<p><a href=""><img src="https://img.alicdn.com/imgextra/i1/715978679/TB2htRYbKNOdeFjSZFBXXctzXXa_!!715978679.jpg"></a></p>

<!-- more -->


<h3>基本使用方法</h3>

<p>ThreadLocal使用起来非常的简单，它支持泛型，可以把任意类型的数据放进ThreadLocal，一个ThreadLocal对象只能放一个对象：</p>

<pre><code class="java">ThreadLocal&lt;String&gt; mLocalCEOHolder = new ThreadLocal&lt;&gt;();
ThreadLocal&lt;Integer&gt; mOrdersCountHolder = new ThreadLocal&lt;&gt;();

mLocalCEOHolder.set("Alex Hilton");

String ceo = mLocalCEOHolder.get();

mOrdersCountHolder.set(30249);

int order = mOrdersCountHolder.get();
</code></pre>

<h3>实现原理解析</h3>

<p>就按上面的例子来解析它的实现原理：</p>

<ul>
<li><p>创建ThreadLocal对象</p>

<p> 先来看看它的构造方法：</p></li>
</ul>


<pre><code class="java">/**
 * Creates a thread local variable.
 * @see #withInitial(java.util.function.Supplier)
 */
public ThreadLocal() {
}
</code></pre>

<p>   很不幸，它的构造方法是空的，啥也没干。</p>

<ul>
<li>set方法
再来看下它的set方法:</li>
</ul>


<pre><code class="java">/**
 * Sets the current thread's copy of this thread-local variable
 * to the specified value.  Most subclasses will have no need to
 * override this method, relying solely on the {@link #initialValue}
 * method to set the values of thread-locals.
 *
 * @param value the value to be stored in the current thread's copy of
 *        this thread-local.
 */
public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}
</code></pre>

<p>这里先获取当前的调用线程，从其中获取一个叫做ThreadLocalMap的东西，如果它不为空就把当前对象this（ThreadLocal对象）作为key，把要存放的值作为value，放到这个ThreadLocalMap里面，如果map为空就先创建再存放。由此可以猜出ThreadLocalMap是一个Map型的数据结构，接着研究getMap和createMap，后面再详细说ThreadLocalMap。</p>

<pre><code class="java">/**
 * Get the map associated with a ThreadLocal. Overridden in
 * InheritableThreadLocal.
 *
 * @param  t the current thread
 * @return the map
 */
ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}


/**
 * Create the map associated with a ThreadLocal. Overridden in
 * InheritableThreadLocal.
 *
 * @param t the current thread
 * @param firstValue value for the initial entry of the map
 */
void createMap(Thread t, T firstValue) {
    t.threadLocals = new ThreadLocalMap(this, firstValue);
}
</code></pre>

<p>getMap比较简单，它返回Thread对象的域对象threadLocal。createMap也很简单创建一个ThreadLocalMap对象，然后把它赋值给Thread对象的域变量。</p>

<ul>
<li>get方法
再来看看get方法：</li>
</ul>


<pre><code class="java">/**
 * Returns the value in the current thread's copy of this
 * thread-local variable.  If the variable has no value for the
 * current thread, it is first initialized to the value returned
 * by an invocation of the {@link #initialValue} method.
 *
 * @return the current thread's value of this thread-local
 */
public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
         }
    }
    return setInitialValue();
}

/**
 * Variant of set() to establish initialValue. Used instead
 * of set() in case user has overridden the set() method.
 *
 * @return the initial value
 */
private T setInitialValue() {
    T value = initialValue();
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
    return value;
}
</code></pre>

<p>get方法与set方法类似，同样是从当前线程取其map，从其中以当前TheadLocal对象为key来查找值，如果找到了，就返回。如果map为空，或者没找到怎么办。就用setInitialValue来初始化线程的map对象，这个与set方法是一样的，只不过用空值(null)。</p>

<ul>
<li>ThreadLocalMap对象</li>
</ul>


<pre><code class="java">/**
 * ThreadLocalMap is a customized hash map suitable only for
 * maintaining thread local values. No operations are exported
 * outside of the ThreadLocal class. The class is package private to
 * allow declaration of fields in class Thread.  To help deal with
 * very large and long-lived usages, the hash table entries use
 * WeakReferences for keys. However, since reference queues are not
 * used, stale entries are guaranteed to be removed only when
 * the table starts running out of space.
 */
static class ThreadLocalMap {

    /**
     * The entries in this hash map extend WeakReference, using
     * its main ref field as the key (which is always a
     * ThreadLocal object).  Note that null keys (i.e. entry.get()
     * == null) mean that the key is no longer referenced, so the
     * entry can be expunged from table.  Such entries are referred to
     * as "stale entries" in the code that follows.
     */
    static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {
        /** The value associated with this ThreadLocal. */
        Object value;

        Entry(ThreadLocal&lt;?&gt; k, Object v) {
            super(k);
            value = v;
        }
    }

    /**
     * The initial capacity -- MUST be a power of two.
     */
    private static final int INITIAL_CAPACITY = 16;

    /**
     * The table, resized as necessary.
     * table.length MUST always be a power of two.
     */
    private Entry[] table;

    /* other codes ... */
}
</code></pre>

<p>完整的就不贴了，大家可以自己去查看。简单来理解，其实它就是一个HashMap，key是对ThreadLocal对象的WeakReference，value是我们放入ThreadLocal的对象。</p>

<p>到这里可以总结一下ThreadLocal的原理了：数据结构是存储在线程对象里的一个Map对象中，key是ThreadLocal对象的WeakReference，值就是我们想要存放的对象。</p>

<p><strong>注意</strong>：下面提到的Map的意思是Thread#threadLocals，也就是ThreadLocalMap对象</p>

<h3>核心所在</h3>

<p>网上面很多关于ThreadLocal的文章（如<a href="http://droidyue.com/blog/2016/03/13/learning-threadlocal-in-java/">这个</a>和<a href="http://www.cnblogs.com/dolphin0520/p/3920407.html">这个</a>）都没有讲清楚，到底它是用什么方法来保证只有当前线程才能访问，它们说的是都是它的数据结构，这个上面已经说了。但是光有一个Map，就够了吗？Thread对象有一个Map用来存储ThreadLocal数据，但是假如Thread有公开获取此Map的方法，那跟我们使用的共享变量有什么区别？</p>

<p>ThreadLocal的真正核心在于它取的<strong>当前线程</strong>的Map：</p>

<ul>
<li>每次从ThreadLocal取数据也好，放数据也好，目标的Map都是当前的线程的Map</li>
<li>线程的Map是包访问权限</li>
<li>放数据也好，取数据也好都是从当前线程的Map里存和取</li>
</ul>


<p>所以，ThreadLocal最关键的就是由Thread.currentThread()来保证当前线程的。线程到底是什么?线程简单来理解就是一个run方法，或者说一堆方法调用，它是一个时序的概念，是一堆按某种顺序运行的指令的集合。所以，当你调用ThreadLocal#set或者ThreadLocal#get时，在set和get方法实现里面会调用Thread.currentThread来取得调用栈所在的线程&mdash;也就是当前线程，这也就保证了，一个线程只能获取自己的Map。</p>

<p>另外，Map必须得与每个线程对象绑定，但又由于这个域是package作用域，只有同一个package的才能访问，所以只能从ThreadLocal里操作此Map也是相对安全的，也就是说想操作此Map只能通过ThreadLocal。当然了，如果能Hack一下，生成一个与Thread在同一个package的对象，就能够直接操作Map，也就能打破ThreadLocal的封装了，这时Map就变成可共享的了，也就失去了线程独有的特性。</p>

<h3>典型应用</h3>

<p>最典型的应用要数<a href="https://developer.android.com/reference/android/os/Looper.html">Looper</a>类的实现。</p>

<p>Looper的作用是帮助线程创建并运行一个消息循环（MessageQueue），很显然，一个线程有且只能有一个，那么ThreadLocal是最佳的方案。</p>

<h3>Android当中的实现</h3>

<p>与标准的Java的实现原理是一样的，都是把Map当作Thread的一个域，package作用域，ThreadLocal作为key, 里面的值作value。</p>

<p>只不过Map的具体实现略有不同。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解 Java 关键字 Final]]></title>
    <link href="http://toughcoder.net/blog/2016/11/12/understanding-java-keyword-final/"/>
    <updated>2016-11-12T14:40:51+08:00</updated>
    <id>http://toughcoder.net/blog/2016/11/12/understanding-java-keyword-final</id>
    <content type="html"><![CDATA[<h2>final可以用来干什么</h2>

<p>final是Java中非常常见的一个关键字，可以说每天都在使用它，虽然常见，但却也不见得都那么显而易见，今天就来研究一下final，以加深对它的理解和更合理的运用。</p>

<p><a href=""><img src="https://img.alicdn.com/imgextra/i1/715978679/TB2FJBGdyGO.eBjSZFEXXcy9VXa_!!715978679.jpeg"></a></p>

<!-- more -->


<h3>修饰类</h3>

<p>当一个类不想被继承时，就可以用final来修饰。</p>

<h3>修饰方法</h3>

<p>当一个方法不想被子类覆写(Override)时，可以用final来修饰。另外一方面，把方法用final来修饰也有一定的性能提升上的帮助，因为虚拟机知道它不会被覆写，所以可以以更简单的方式来处理。</p>

<p>private的方法，默认都会被编译器加上final.</p>

<h3>修饰变量</h3>

<p>被final修饰的变量只能赋值一次，之后不能再被修改。如：</p>

<pre><code class="java">final int a = 10;
a = 4; // compilation error
</code></pre>

<p>需要注意的是，这里说的是只能赋值一次，并不意味着，非要在声明变量时直接初始化，比如，下面的代码也是完全合法的：</p>

<pre><code class="java">final int a;
if (foo()) {
    a = 3;
} else {
    a = 4;
}
</code></pre>

<h3>修饰域变量</h3>

<p>域变量也是变量，所以用final来修饰的第一个作用就是赋值后，不能再修改变量的值，比如:</p>

<pre><code class="java">final int a = 10;
final Object b = new Object();
</code></pre>

<p>对于基本类型来说，就是变量值不能再被修改；对于引用来说，就是不能再让其指向其他对象或者null。</p>

<p>但对于域变量，声明为final的域变量必须在声明时初始化，或者在构造方法中初始化，否则会有编译错误。</p>

<p>此外，声明为final的域变量还有内存模型上的语义，下面详细说</p>

<h3>内存模型的作用&ndash;防止<a href="https://shipilev.net/blog/2014/safe-public-construction/">变量从构造方法中逸出</a></h3>

<p>这个主要是针对被final修饰的域变量，虚拟机会有禁止指令重排的保证：</p>

<ul>
<li>在构造方法内对一个final变量的写入，与随后这个被构造对象的引用赋值给一个引用变量，这二个顺序不改变，final变量的写入一定要早于对象引用的赋值。</li>
</ul>


<p>什么意思呢？在多线程环境下，域变量是有可能从构造方法中逸出的，也就是说线程有可能读到还没有被构造方法初始化的域变量的值。比如：</p>

<pre><code class="java">class Foo {
    int a;

    Foo(int v) {
        a = v;
    }
}
</code></pre>

<p>如果是在多线程环境下，一个线程A在创建Foo的对象，另一个线程B在读对象的a的值，则B是有可能读到未正确初始化a的值（默认初始值0）。这就是域变量从构造方法中逸出。</p>

<p>关键字final可以禁止虚拟机指令重排，从而保证了构造方法执行完毕前final修饰的变量一定是初始化过了的。</p>

<p>这部分可以参考<a href="http://www.infoq.com/cn/articles/java-memory-model-6">深入理解Java内存模型（六）——final</a>，讲解的非常详细。</p>

<h3>匿名内部类使用外部变量时为何要强制使用final修饰</h3>

<p>这个大家肯定都习以为常了，比如：</p>

<pre><code class="java">private void initViews() {
    final int a = 3; // Compilation error if remove final
    btn.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            if (a &gt; 1) {
                // volala
            }
        }
    }
}
</code></pre>

<p>那么，有没有想过为什么？而像其他支持完整闭包的语言如JavaScript，Python等，是没有这等限制的。究其原因，是Java对闭包支持不够完整，或者说它并不是像动态语言那样的完整闭包。对于匿名内部类来说，编译器会创建一个命名类(OutClass$1之类的)，然后把匿名类所在的<a href="https://en.wikipedia.org/wiki/Closure_(computer_programming">能捕获的变量</a>)，以构造参数的形式传递给内部类使用，这样一样，外部的变量与内部类看到的变量是不同的，虽然它们的值是相同的，因此，如果再允许外部修改这些变量，或者内部类里面修改这些变量，都会造成数据的不一致性（因为它们是不同的变量），所以Java强制要求匿名内部类访问的外部变量要加上final来修饰。</p>

<p>对于其他语言，匿名内部类，持有的是外部变量的一个包装的引用(wrapper reference)，这可以能看不懂，但是理解起来就是内部类能直接访问外部变量，外部与闭包内部访问的是同一个变量，因此外部修改了，内部能看到变化，内部修改了，外部也能看到变化。</p>

<p>一句话总结就是，Java内部类与外部持有的是值相同的不同的变量；其他支持闭包的语言则持有的是相同的变量。</p>

<h3>建议能使用final的地方就加上final修饰</h3>

<p>最后来聊聊，啥时候应该用final呢？孤的建议(以及众多大师的建议)就是能多用就多用，除非不能用final，否则就用。原因，有这么几条：</p>

<ul>
<li><p>域变量尽可能加上final</p>

<p>这个原因比较明确，前面也提到了，在多线程条件下，会有很大的优势。尽可能加上final来修饰域变量，甚至用<a href="https://en.wikipedia.org/wiki/Immutable_object">Immutable Object</a>，可以省去构造时的多线程同步。</p>

<p>多线程最大的麻烦是状态同步，啥是状态？其实就是共享数据，域变量就是共享数据，所以，如果共享数据都是不可变的(Immutable)，那么自然就没有了同步上的麻烦。</p></li>
<li><p>final类和方法能提升性能</p>

<p>正常的类和方法，虚拟机需要为了继承和方法覆写而做一次准备，如果加上了final，虚拟机知道它不会被继承或者覆写，那么就可以做一些优化。虽然，这并不显著，但是还是可以提升一些性能的。</p></li>
<li><p>final变量能提升可读性</p>

<p>无论是域变量还是本地变量，加上了final修饰，程序的维护者就知道了，这个变量的值不会再改变，这无疑会大大增加可读性。</p></li>
</ul>


<h3>参考资料</h3>

<ul>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3736238.html">浅析Java中的final关键字</a></li>
<li><a href="http://www.infoq.com/cn/articles/java-memory-model-6">深入理解Java内存模型（六）——final</a></li>
<li><a href="http://cuipengfei.me/blog/2013/06/22/why-does-it-have-to-be-final/">为什么必须是final的呢？</a></li>
<li><a href="https://www.zhihu.com/question/21395848">java为什么匿名内部类的参数引用时final？</a></li>
<li><a href="http://www.javamex.com/tutorials/synchronization_final.shtml">Thread-safety with the Java final keyword</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解Java关键字volatile]]></title>
    <link href="http://toughcoder.net/blog/2016/10/15/understanding-java-keyword-volatile/"/>
    <updated>2016-10-15T17:40:40+08:00</updated>
    <id>http://toughcoder.net/blog/2016/10/15/understanding-java-keyword-volatile</id>
    <content type="html"><![CDATA[<p>在Java中，关键字<a href="https://en.wikipedia.org/wiki/Volatile_(computer_programming)">volatile</a>是除同步锁以外，另一个同步机制，它使用起来比锁要简单方便，但是却很容易被忽略，或者被误用。这篇文章就来详细讲解一下volatile它的作用，它的原理以及如何正确的使用它。</p>

<p><a href=""><img src="https://img.alicdn.com/imgextra/i4/715978679/TB2lcgxdhaK.eBjSZFAXXczFXXa_!!715978679.jpg"></a></p>

<!-- more -->


<h2>volatile的定义</h2>

<p>这个引用<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.3.1.4">JSR</a>中的定义：</p>

<blockquote><p>The Java programming language allows threads to access shared variables (§17.1). As a rule, to ensure that shared variables are consistently and reliably updated, a thread should ensure that it has exclusive use of such variables by obtaining a lock that, conventionally, enforces mutual exclusion for those shared variables.</p>

<p>The Java programming language provides a second mechanism, volatile fields, that is more convenient than locking for some purposes.</p>

<p>A field may be declared volatile, in which case the Java Memory Model ensures that all threads see a consistent value for the variable (§17.4).</p></blockquote>

<p>简单的翻译一下：</p>

<blockquote><p>Java编程语言中允许线程访问共享变量。为了确保共享变量能被一致地和可靠的更新，线程必须确保它是排他性的使用此共享变量，通常都是获得对这些共享变量强制排他性的同步锁。</p>

<p>Java编程语言提供了另一种机制，volatile域变量，对于某些场景的使用这要更加的方便。</p>

<p>可以把变量声明为volatile，以让Java内存模型来保证所有线程都能看到这个变量的同一个值。</p></blockquote>

<h2>volatile的作用</h2>

<ul>
<li><p>保证变量的可见性</p>

<p>  volatile关键字的作用就是保证共享变量的<strong>可见性</strong>。什么是可见性呢，就是一个线程读变量，总是能读到它在内存中的最新的值，也就是说不同的线程看到的一个变量的值是相同的。CPU都是有行缓存的，volatile能让行缓存无效，因此能读到内存中最新的值。</p></li>
<li><p>保证赋值操作的原子性</p>

<p>原子性就是不能被线程调度打断的操作，是线程安全的操作，对于原子性操作，即使在多线程环境下，也不用担心线程安全问题或者数据不一致的问题。有些变量的赋值本身就是原子性的，比如对boolean，对int的赋值，但是像对于long或者double则不一定，如果是32位的处理器，对于64位的变量的操作可能会被分解成为二个步骤：高32位和低32位，由此可能会发生线程切换，从而导致线程不安全。如果变量声明为volatile，那么虚拟机会保证赋值是原子的，是不可被打断的。</p></li>
<li><p>禁止指令重排</p>

<p>  正常情况下，虚拟机会对指令进行重排，当然是在不影响程序结果的正确性的前提下。volatile能够在一定程度上禁止虚拟机进行指令重排。还有就是对于volatile变量的写操作，保证是在读操作之前完成，假设线程A来读变量，刚好线程B正在写变量，那么虚拟机会保证写在读之前完成。
  比如：</p></li>
</ul>


<pre><code class="java">private volatile boolean flag;

public void setFlag(boolean flag) {
    this.flag = flag;
}

public void getFlag() {
    return flag;
}
</code></pre>

<p>假设线程A来调用setFlag(true)，线程B同时来调用getFlag，对于一般的变量，是无法保证B能读到A设置的值的，因为它们执行的顺序是未知的。但是像上面，加上volatile修饰以后，虚拟机会保证，线程A的写操作在线程B的读操作之前完成，换句话，B能读到最新的值。当然了，用锁机制也能达到同样的效果，比如在方法前面都加上synchronized关键字，但是性能会远不如使用volatile。</p>

<h2>volatile的典型使用场景</h2>

<h3>多线程情况下的标志位</h3>

<p>基于它的作用，不难找到使用它的理想场景：</p>

<ul>
<li>读操作，多于写操作</li>
<li>写操作，不依赖于变量的当前值，也就是说要是纯赋值操作</li>
<li>只需要读取的值，不需要等待某一特定的值</li>
</ul>


<p>比如，有一个检查新版本的按扭，点击时会发起去检查新版本，因为检查新版本涉及网络请求，可能会比较耗时，所以需要放在单独的线程中去做。为了避免多次同时触发检查请求，做一个限制：上一个请求没有完成时，再次点击无效。这时就可以用volatile来做个标志位，伪代码如下：</p>

<pre><code class="java">private volatile boolean checkUpdateFinished = true;

public void onCheckUpdate(View view) {
    if (!checkUpdateFinished) {
        return;
    }
    checkUpdate();
}

private void checkUpdate() {
    checkUpdateFinished = false;
    new Thread(new Runnable() {
        @Override
        public void run() {
            doCheckUpdate();
            checkUpdateFinished = true;
        }
    }).start();
}
</code></pre>

<h3>CAS无锁同步的变量声明</h3>

<p><a href="https://en.wikipedia.org/wiki/Compare-and-swap">CAS（Compare And Swap）</a>是一种无锁同步的算法，它涉及变量的3个值，当前值，旧的期望值以及新的期望值，它的原理是当且仅当当前值与旧的期望值一致时，才把新值赋给变量，否则什么都不做：</p>

<pre><code class="java">private volatile int a;

do {
   old = 3;
   expected = 5;
} while (compareAndSwap(a, 3, 5);

boolean compareAndSwap(int a, int old, int expected) {
    if (a == old) {
        a = expected;
        return true;
    }
    return false;
}
</code></pre>

<p>当然，具体的compare and swap不是这么实现的，实际是要直接使用处理的指令CMPXCHG(Compare and Exchange)来做具体的CAS。
为了保证可见性，CAS中的变量必须都用volatile来修饰。</p>

<h2>volatile的内存原理</h2>

<p>知道了volatile有什么用，怎么用以后，可以了解的更深一点，以加深理解。但要搞懂，就必须先要搞懂它的背景以及背景的背景：</p>

<h3>并发的基本概念</h3>

<ul>
<li><p>原子性</p>

<p>一个或者多个操作（赋值也好，运算也好）不能被线程调度打断，要么一次性执行完，要么就不执行。</p></li>
<li><p>可见性</p>

<p>现代处理器是多核心的，或者多CPU的，但是主存（通常意义上的操作系统内存，或者物理内存）却是在CPU之间共享的。多核心处理的优势在于，从机器级别支持多线程并发，而且为了弥补主存与CPU核心之间的速度差异，便有了CPU核心缓存，因此，每个CPU核心（或者说每个线程）是有独立的内存的。这样就带来了可见性的问题，同一个变量c，A线程操作的是c在A线程的缓存中的值，B操作的是c在B的缓存中值，也就是说最新的变量的值对于其他线程是不可见的，这就有了可见性的问题。</p></li>
<li><p>有序性</p>

<p>对于单线程来说，程序的执行顺序就是按照代码的书写顺序，从上到下，从左到右(分号分隔写在同一行时)。但是多线程情况就不一定了，线程调度器随时可能打断某一程，执行其他线程。这就导致了，程序并不是按照预期的顺序执行的，导致结果跟预期不一致。
<strong>注意</strong>：这里的顺序，并不是严格的指令执行的顺序，而且从结果正确性的角度来看的，比如：</p></li>
</ul>


<pre><code class="java">  int a = 10;
  int b = a + 1;
</code></pre>

<p>  这段代码的有序性的意思是：当执行到第二条语句，只要a的值是10就可以了，至于a = 10它究竟是否是在下面语句前执行，并不关心。但是，除了a = 10语句外，没有其他的方式能让a变成10，所以，肯定是执行了语句了才能把a变成10。说起来比较绕，这个例子也过于简单。但是可以这么简单的理解为：单线程情况下，程序是按书写的顺序来执行的，更准确的说法是程序员预期的顺序来执行的。但多线程会打破这种有序性。</p>

<p>  <strong>注意</strong>：这里我们不考虑<a href="https://en.wikipedia.org/wiki/ABA_problem">ABA问题</a>。</p>

<h3>内存模型的基本概念</h3>

<h4>对内存模型的理解</h4>

<p>什么是<a href="https://en.wikipedia.org/wiki/Java_memory_model">内存模型</a>呢？就是程序运行起来时，内存里面的样子。程序包括变量，对象，数据，指令等，程序动起来后又包括变量如何赋值，数据如何读取，指令按什么顺序执行等。其实，程序运行时，内存是什么样子，通常取决于操作系统，也就是说是由操作系统决定的。Java是跨平台的语言，其靠着“Compile once, run anywhere&#8221;的大旗，拮杆而起，打下一片天下，如今稳坐头把交椅。那么，想要跨平台，它就要屏蔽各个操作系统平台和硬件平台的差异，因此它有虚拟机，虚拟机实质是一对操作系统的一个抽象，把差异进行屏蔽，从而对语言本身来说，所有操作系统就都是一样的了。内存模型，也就是虚拟机对运行时的一些约定，或者叫做强制规定，比如变量的操作，数据的读取，指令执行顺序等。都做了哪些规定呢？我们分别来说：</p>

<ul>
<li><p>线程模型</p>

<p>  <img class="<a" src="href="https://img.alicdn.com/imgextra/i3/715978679/TB2_LEObhRzc1FjSZFPXXcGAFXa_!!715978679.png">https://img.alicdn.com/imgextra/i3/715978679/TB2_LEObhRzc1FjSZFPXXcGAFXa_!!715978679.png</a>&#8221;></p>

<p>  因为Java天生支持多线程，所以，虚拟机也必须要有线程模型，否则就无法屏蔽操作系统的差异。虚拟机规定，所有的变量都存储在主存中，也就是通常所指的内存，每个线程可以有自己的独立的工作内存，可以理解为每个CPU核心的缓存，线程对变量的操作都只能在自己的工作内存中，不能直接对主存操作，也不能访问其他线程的工作内存。</p></li>
<li><p>原子性操作</p>

<p>  虚拟机保证对基本的基本数据类型的赋值是原子的，比如int，boolean和float。但是像long和double不一定，这取决于CPU的字长，32位下，long和double的赋值不是原子的，因为需要二个指令；而64位CPU则一个指令搞定。</p>

<p>  如何保证原子性呢？方式一是上面提过的用volatile，另外就是用同步锁机制。</p></li>
<li><p>可见性</p>

<p>  前面说到每个CPU可以有自己的工作内存，因此，当一个线程对某一变量操作后，其他线程是没有办法直接拿到最新变化的。</p>

<p>  如何保证可见性呢？方法一就是把变量用volatile修饰，另外就是用同步锁机制。</p></li>
<li><p>指令重排与happens-before原则</p>

<p>  指令重排与happens-before原因，是不同的，也是不冲突的。正常情况下，也就是说单线程情况下，指令的执行顺序是按书写顺序从上到下，但不是严格的，虚拟机会在不影响程序结果正确性的前提下对指令进行重排，比如：</p></li>
</ul>


<pre><code class="java">int a = 1;
int b = 2;
int c = 3;
</code></pre>

<p>这三个指令，哪个先执行，是不会影响程序结果的，这时指令可能重排；而再如：</p>

<pre><code class="java">int a = 1;
int b = a + 1;
int c = a + b;
</code></pre>

<p>这种情况下，是无法重排，不可能把第3句放到前面，那样会得不到正确的结果。</p>

<p>而happens-before是指在多线程情况下，虚拟机来保证某些操作的先后性，或者说前面的操作结果，对后面是可见的。比如上面的第二个例子，在多线程情况下，c = a + b是有可能在a, b赋值前执行的，这也恰 恰是我们需要小心解决的由多线程机制带来的问题。</p>

<p>虚拟机的默认支持的happens-before(先行发生)原则：</p>

<ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li>
</ul>


<p>很多规则显而易见的，或者想一下还是很容易想通的，重点解析一下第2, 3, 4条：</p>

<ul>
<li><p>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</p>

<p>  这里的意思是，同一个锁(lock)，如果处于锁定状态，那么只能先释放锁，然后才能被再次锁定。这么一说就明白了，这是显而易见的，要不然锁不就失去它本身的作用了么。</p>

<p>  <strong>注意</strong>：这里有必要进一步说明一下，对于可重入锁，这里应该指的就是其他线程再次获得锁之前，锁必须被释放。因为对于可重入锁，锁的持有线程，是可以在不释放的前提下，继续获得锁的。</p></li>
<li><p>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</p>

<p>  这里其实有二层，一个是前面提过的，读volatile总是能读到最新的值，即使是写线程和读线程同时进行。因为，写操作会被更新到主存，读线程的工作内存会被置为无效，需要重新到主存去读，而读主存的地址，是要等待该地址更新后才能成功读取。</p>

<p>  另外，一个就是对于volatile上下文的变量的读写的影响，也就是说它为什么能禁止指令重排：volatile的准确可见性作用是，当一个线程写一个volatile变量时，写完成后会刷新工作内存到主存，这会把目前这个线程所做过修改的所有变量都刷新到主存。举个例子来说明：</p></li>
</ul>


<pre><code class="java">int a;
int b;
volatile boolean flag;

void write() {
    a = 3;
    b = 4;
    flag = true;
}

void read() {
    print(a);
    print(b);
    print(flag);
}
</code></pre>

<p>如果线程A调用write()，线程B调用read()，那么B能读到a, b和flag的最新值（A所写的值）。</p>

<p>由此，可以引申出一个volatile的高级应用，可以当作同步锁：</p>

<pre><code class="java">private Object object = null;
private volatile hasNewObject = false;

public void put(Object newObject) {
    while (hasNewObject) {
         //wait - do not overwrite existing new object
    }
    object = newObject;
    hasNewObject = true; //volatile write
}

public Object take() {
    while (!hasNewObject) { //volatile read
        //wait - don't take old object (or null)
    }
    Object obj = object;
    hasNewObject = false; //volatile write
    return obj;
}
</code></pre>

<p>因为写hasNewObject时会把object也刷新了，所以取对象的线程，可以在只要hasNewObject为true时就可以读到正确的值。
* 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生</p>

<p>这个就像某些运行符的传递性一样，具体传递性，从而使整个happens-before规则产生实际作用。</p>

<h3>volatile的实现机制</h3>

<p>计算机科学里面，为了解决复杂性，都会分层。正如一个名人所说：&#8221;计算机的任何问题都可以通过增加一个虚拟层来解决&#8221;(&ldquo;All problems in computer science can be solved by another level of indirection&rdquo;)。volatile虚拟机层引入的，解决语言层面的问题，那么它的实现，必然是靠下一层的支持，也就是需要汇编或者说处理器指令的支持来实现，volatile是靠内存屏障和<a href="https://en.wikipedia.org/wiki/MESI_protocol">MESI</a>（缓存一致性协议）来达成的它的作用的。</p>

<p><a href="https://en.wikipedia.org/wiki/Memory_barrier">内存屏障</a>(Memory Barriers)是处理器提供的一组内存操作指令，它的作用是限制内存操作的顺序，也就是说内存屏障像一个栅栏一样，它前面的指令要在它后面的指令之前完成；还能强制把缓存写入到主存；再有的就是触发缓存一致性，就是当有写变量时，会把其他CPU核心的缓存变为无效。</p>

<h3>总结</h3>

<p>volatile是一个比较复杂的修饰符，想要使用它，就要完全理解它的作用，它能用来做什么，以及不能干什么。如果，不是很确定，要么弄懂，要么就不要使用。事实上，大多数情况下，标志变量，还是非常适合volatile的。</p>

<p>java.util.concurrent.*里面的高级线程安全数据结构像ConcurrentHashMap以及java.util.concurrent.atomic.*等的实现都用到了volatile。可以多看看这些类的实现，以加深对volatile的理解和运用。</p>

<h2>参考资料</h2>

<ul>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-jtp06197.html">Java 理论与实践: 正确使用 Volatile 变量</a></li>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3920373.html">Java并发编程：volatile关键字解析</a></li>
<li><a href="http://www.infoq.com/cn/articles/java-memory-model-4#">深入理解Java内存模型（四）——volatile</a></li>
<li><a href="http://www.infoq.com/cn/articles/ftf-java-volatile">聊聊并发（一）——深入分析Volatile的实现原理</a></li>
<li><a href="http://tutorials.jenkov.com/java-concurrency/volatile.html">Java Volatile Keyword</a></li>
<li><a href="https://en.wikipedia.org/wiki/Volatile_(computer_programming">volatile (computer programming)</a>)</li>
<li><a href="https://en.wikipedia.org/wiki/Java_memory_model">Java Memory Model</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
