<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2021-08-12T23:54:31+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android ConstraintLayout使用攻略]]></title>
    <link href="http://toughcoder.net/blog/2021/08/10/android-constraintlayout-made-easy/"/>
    <updated>2021-08-10T22:49:20+08:00</updated>
    <id>http://toughcoder.net/blog/2021/08/10/android-constraintlayout-made-easy</id>
    <content type="html"><![CDATA[<p>ConstraintLayout是新一代的布局，它汲取了众家之长，把布局的概念进行了大统一，灵活且强大，基本上可以干掉以前所有的常用布局（LinearLayout, RelativeLayout和FrameLayout）。自从Android Studio 2.3（大约在2017年）后，它就变成了Android Studio的默认模板的布局控件，可以看出谷歌对它的钟爱程度。今天就来学习一下如何使用这个新布局神器。</p>

<p><a href=""><img src="https://abhiandroid.com/ui/wp-content/uploads/2018/07/Constraint-Layout-Example-In-Android-Studio-1.png"></a></p>

<!-- more -->


<h2>简述</h2>

<p><a href="(https://developer.android.com/reference/androidx/constraintlayout/widget/ConstraintLayout">ConstraintLayout</a>)与RelativeLayout有些类似，是一个布局管理器（ViewGroup），但要强大许多，它可以以各种方式排列子View，以及按比例伸缩。最重要的改变就是它对于『Drag and drop』拖拽式制作GUI页面支持的相当的好。当然了这个取决于个人喜好，很多人仍然喜欢用写代码的方式直接去写xml文件，包括我在内。拖拽式虽然直观，但是不方便精准控制，对于一般性的布局来说尚可，但稍复杂了后，以及有了一些可滑动的view时，就不是那么的方便了。对于喜欢拖拽的同学可以查看<a href="https://developer.android.google.cn/training/constraint-layout">官方的一个教程</a>，以及<a href="https://blog.csdn.net/guolin_blog/article/details/53122387">郭大婶的一篇文章</a>，这两篇专注于拖拽式，且讲的都比较详细。</p>

<h3>添加依赖</h3>

<p>因为ConstraintLayout并不是在标准的SDK中，而是被放在了support SDK中，现在统一叫androidx了，所以要单独添加依赖：</p>

<pre><code class="groovy">     dependencies {
          implementation 'com.android.support.constraint:constraint-layout:2.1.0'
     }
</code></pre>

<h3>概念与术语</h3>

<p>ContraintLayout中把一切有关布局的参数都称之为Constraint（约束），长和宽，对齐，居中，margin和padding都是constraint。布局中的属性均以&#8221;layout_constraint&#8221;为前缀。
约束（Constrain）的意思是指用另外一个View（包括父布局即ContraintLayout）对当前View的某一布局参数施加影响。具体的影响叫做Constraint，另外一个View称作约束对象（Constraining Object)，当前View称作被约束对象（Constrainted Object）。</p>

<p><img src="https://developer.android.com/reference/androidx/constraintlayout/widget/resources/images/relative-positioning.png" alt="" /></p>

<pre><code class="xml">         &lt;Button android:id="@+id/buttonA" ... /&gt;         &lt;Button android:id="@+id/buttonB" ...                 app:layout_constraintLeft_toRightOf="@id/buttonA" /&gt;
</code></pre>

<h3>排列方式</h3>

<p>对子View的排列方式是一个ViewGroup的最基础的功能，它也体现了不同的布局管理器的作用，如线性布局（LinearLayout）是以水平或者垂直方向平铺方式来排列子View的。ConstraintLayout是以类似RelativeLayout的方式，需要针对每个子View指定如何排列。</p>

<p><img src="https://developer.android.com/reference/androidx/constraintlayout/widget/resources/images/relative-positioning-constraints.png" alt="" /></p>

<h4>基础排列方式</h4>

<p>最为基础的排列方式就是针对每个子View，指定它相对于另外一个View或者父布局（也就是ConstraintLayout本身）的相对位置，从而确定该View的具体方位。具体就是[left, top, right, bottom]四个关键的排列元素相对于另外一个View或者父布局的位置关系。</p>

<p>如，layout_constraintLeft_toLeftOf=&ldquo;parent&#8221;，这就是左边与父布局左边对齐；layout_constraintTop_toBottomOf=&#8221;id/header&#8221;，这是把这个View放在id为header的下面。以此类推，因为与RelativeLayout的布局参数比较类似，就不细说了，详情可参阅文档。</p>

<p>还有一个非常实用的Constraint叫做baseline，它是专门针对TextView的，baseline也即文本的基线，可以简单理解为文字的底部，当有两个TextiView不一样大，文字大小也不一样时，却需要对齐文本，这个属于就相当的有用。</p>

<p><img src="https://upload-images.jianshu.io/upload_images/2787721-aebcad66710f4d48.png?imageMogr2/auto-orient/strip|imageView2/2/w/213/format/webp" alt="" /></p>

<pre><code class="xml">    &lt;TextView android:id="@+id/TextView1"/&gt;

    &lt;TextView
        android:id="@+id/TextView2"
        app:layout_constraintLeft_toRightOf="@+id/TextView1"
        app:layout_constraintBaseline_toBaselineOf="@+id/TextView1"/&gt;
</code></pre>

<h3>margin</h3>

<p>常规使用与其他布局是一样的，通过layout_margin[Start,End,Left,Right,Bottom,Top]来指定与约束对象之间的margin，这个不细说了。</p>

<p>需要说一下，ConstraintLayout有一个goneMargin，可以用于当一个约束对象的Visibility被设置为GONE时，使用。用layout_goneMargin[Start,End,Left,Top,Right,Bottom]来设置。</p>

<p>比如A约束B，B在A的右边，它俩挨着，但如果A的Visibility设置为GONE时，正常情况下B就会挨到原来A的左边了，跑到了左边界上，这时可能就会变得比较丑了，如果使用margin，比如在A和B中间加一个margin，可以解决问题，但是也会影响当A可见的时候。而用goneMargin就可以完美的解决此种场景。layout_goneMarginStart=&ldquo;10dip&#8221;，那么这个margin只有当约束对象A的Visibility被置为GONE时，才会生效，这时B虽然跑到了左边界上，但是还有margin，就不会那么丑了。（其实goneMargin应用的场景也比较有限，前面说的case，也可以用A和B的父布局的leftPadding来解决）</p>

<p><img src="https://developer.android.com/reference/androidx/constraintlayout/widget/resources/images/visibility-behavior.png" alt="" /></p>

<h4>相当骚气的环状排列方式</h4>

<p>除了常规的行列式排列以外，这货还非常骚气的可以环状排列，以约束对象为圆心，通过角度和半径来约束位置：</p>

<ul>
<li>layout_constraintCircle 用以指定作为圆心的约束对象（其他view的id）</li>
<li>layout_constraintCircleRadius 被约束对象与圆心的距离</li>
<li>layout_constraintCircleAngle 被约束对象与横轴的角度（0~360度之间）</li>
</ul>


<p><img src="https://developer.android.com/reference/androidx/constraintlayout/widget/resources/images/circle1.png" alt="" />
<img src="https://developer.android.com/reference/androidx/constraintlayout/widget/resources/images/circle2.png" alt="" /></p>

<pre><code class="xml">  &lt;Button android:id="@+id/buttonA" ... /&gt;  &lt;Button android:id="@+id/buttonB" ...      app:layout_constraintCircle="@+id/buttonA"      app:layout_constraintCircleRadius="100dp"      app:layout_constraintCircleAngle="45" /&gt;
</code></pre>

<h4>环状排列实例</h4>

<p>环状排列虽然骚气，但是现实中似乎应用场景不多。</p>

<h3>居中与对齐</h3>

<p>对齐不是大问题，前面讲的如何排列其实就是对齐，选定一个约束对象后，其他对象都受其约束，就自然对齐了。</p>

<p>比较常见的问题，以及大部分时候比较麻烦的是居中，平衡与中庸中符合绝大多数审美的，因此布局时，绝大多数情况下都是需要居中的。居中的实现的方式就是两边都约束于父布局（也即ConstraintLayout），如：</p>

<p><img src="https://developer.android.com/reference/androidx/constraintlayout/widget/resources/images/centering-positioning.png" alt="" /></p>

<pre><code class="xml">         &lt;androidx.constraintlayout.widget.ConstraintLayout ...&gt;
             &lt;Button android:id="@+id/button" ...
                 app:layout_constraintLeft_toLeftOf="parent"
                 app:layout_constraintRight_toRightOf="parent"/&gt;
         &lt;/&gt;
</code></pre>

<p>居中，其实就是两边的约束边距各占空余空间的50%，扩展开来，想要实现不完全居中，两边边距呈一定比例关系，也是可以办到的。比如说黄金比例0.618就比居中好看，这也好办：
<img src="https://developer.android.com/reference/androidx/constraintlayout/widget/resources/images/centering-positioning-bias.png" alt="" /></p>

<pre><code class="xml">       &lt;androidx.constraintlayout.widget.ConstraintLayout ...&gt;
             &lt;Button android:id="@+id/button" ...
                 app:layout_constraintHorizontal_bias="0.382"
                 app:layout_constraintLeft_toLeftOf="parent"
                 app:layout_constraintRight_toRightOf="parent"/&gt;
      &lt;/&gt;
</code></pre>

<p>这个比例控制叫bias，可以有Horizontal和Vertical两个方向。</p>

<h3>尺寸</h3>

<p>尺寸也就是针对子View的宽与高的约束，其实大部分时候一些具体的子View的宽与高要么指定大小，要么是WRAP_CONTENT的，但有些时候可能就是需要更加的灵活一些，这时就可以考虑用ConstraintLayout里面的一些特性。宽与高设置为固定大小或者WRAP_CONTENT时与其他ViewGroup是一样的，不用多说，要想特别一点的就是设置为『0dip』或者MATCH_CONSTRAINT时，就会用其他约束来决定该View的宽或者高。后面重点讨论有约束的情况。</p>

<h4>默认行为</h4>

<p>如果子View的宽或者高设置为了MATCH_CONSTRAINT（或者『0dip』）时，默认的行为是它会占满剩余的可用空间。</p>

<h4>Max与Min</h4>

<p>还可以加上最大最小的限制：</p>

<ul>
<li>layout_constraintWidth_min and layout_constraintHeight_min : will set the minimum size for this dimension</li>
<li>layout_constraintWidth_max and layout_constraintHeight_max : will set the maximum size for this dimension</li>
<li>layout_constraintWidth_percent and layout_constraintHeight_percent : will set the size of this dimension as a percentage of the parent</li>
</ul>


<h4>按约束对象的比例来设置（Percent）</h4>

<p>前面的默认行为或者最大最小还算不上啥，其他ViewGroup也有类似参数。最为变态与强大的是可以按约束对象的比例来作为此View的宽或者高：</p>

<ul>
<li>The dimension should be set to MATCH_CONSTRAINT (0dp)</li>
<li>The default should be set to percent app:layout_constraintWidth_default=&ldquo;percent&rdquo; or app:layout_constraintHeight_default=&ldquo;percent&rdquo;</li>
<li>Then set the layout_constraintWidth_percent or layout_constraintHeight_percent attributes to a value between 0 and 1</li>
</ul>


<h4>自身宽高比（Ratio）</h4>

<p>这个是最变态的约束方式，可以设置一个自身的宽高比，以确定子View的尺寸，当然了具体的宽或者高还要以其他约束方式确定具体尺寸，然后再按照设置的宽高比对另外一个进行约束。比如，实现一个方形的按扭，宽是其自身要求的宽度值（WRAP_CONTENT），设置的宽高比是1：1，所以高度也会跟宽度一样，就是一个方形的按扭了：</p>

<pre><code class="xml">        &lt;Button android:layout_width="wrap_content"
                   android:layout_height="0dp"
                   app:layout_constraintDimensionRatio="1:1" /&gt;
</code></pre>

<h2>高级特性</h2>

<p>前面讲的是一些基础使用方式，但是这货远不止这些，还有一些非常强大的功能，下面简单介绍两个。</p>

<h3>链（Chains）</h3>

<p>在某一个方向上（横着或者竖着）有着相互约束的一组子View，会被视为一个链，第一个称作头部（Head），可以应用一些样式以对整个链内的子View都产生影响。
<img src="https://developer.android.com/reference/androidx/constraintlayout/widget/resources/images/chains.png" alt="" />
<img src="https://developer.android.com/reference/androidx/constraintlayout/widget/resources/images/chains-head.png" alt="" /></p>

<p>这里的相互约束的意思是，比如有上面A，B，C三个子View，那么它们要相互约束，也即：</p>

<pre><code class="xml">  &lt;ConstraintLayout&gt;
      &lt;A layout_constraintLeft_toLeftOf="parent"
           layout_constraintRight_toRightOf="B" /&gt;
      &lt;B layout_constraintLeft_toLeftOf="A"
           layout_constraintRight_toRightOf="C" /&gt;
      &lt;C layout_constraintLeft_toLeftOf="B"
           layout_constraintRight_toRightOf="parent" /&gt;
  &lt;/ConstraintLayout&gt;
</code></pre>

<p>就可以，对头部子View  A进行样式（Chain style），通过layout_constraintHorizontal_chainStyle来设置：</p>

<ul>
<li>CHAIN_SPREAD &ndash; the elements will be spread out (default style)<em> Weighted chain &ndash; in CHAIN_SPREAD mode, if some widgets are set to MATCH_CONSTRAINT, they will split the available space</em> CHAIN_SPREAD_INSIDE &ndash; similar, but the endpoints of the chain will not be spread out* CHAIN_PACKED &ndash; the elements of the chain will be packed together. The horizontal or vertical bias attribute of the child will then affect the positioning of the packed elements</li>
</ul>


<p><img src="https://developer.android.com/reference/androidx/constraintlayout/widget/resources/images/chains-styles.png" alt="" /></p>

<p>链中的权重（Weighted chains）</p>

<p>默认情况下，子View会均分并占满可用的空间。可以用权重来按比例分配，给子View加上layout_constraintHorizontal_weight后，就会按比例分配，这个与LinearLayout的layoutWeight用法是一样的。</p>

<h3>组（Groups）</h3>

<p>为了View的渲染性能，各路大神告诉我们要尽可能的让布局扁平化，但是，如果太扁平了，全都放在一个ViewGroup下面，就会混乱，特别是像RelativeLayout和ConstraintLayout，子View的排列方式会产生相互依赖，会有牵一发动全身的情况出现。为了避免这种情况，就需要对子View进行分组，对页面进行区域划分，把紧密相关的视为一个组。以往，会用一个子ViewGroup把一个组包起来，虽然会加深View的层次，但这样能避免牵一发动全身。</p>

<p>而对于ConstraintLayout来说，有更先进的方式了，它有一个类叫Group，就是专门用来干这件事儿的，但Group对象并不是一个真的子View，这里的意思是它并不会在View tree中进行渲染，它是专门用于管理属于它的子View的，比如方便对整个组进行Visibility的设置。</p>

<h2>神器要如何使用</h2>

<p>前面的介绍就差不多了，ConstraintLayout还是相当的强大的，如有可能还是尽可能的多用它吧。它的实现上面确实挺复杂的，毕竟功能比较强大，但它的效率并不差。对于常用的几大布局都可以直接用它来替代。</p>

<h3>当线性布局使用（as LinearLayout）</h3>

<p>线性布局最大的优势就在于可以用weight的方式来按比例排放，而这个用前面提到的Chain就可以完美的解决。所以，LinearLayout可以完全放弃。</p>

<h3>当层叠布局使用（as FrameLayout）</h3>

<p>FrameLayout的全用场景一般是作为整个应用的根布局，特别是HomeActivity+Fragment这种架构。从纯的功能角度来讲，ConstraintLayout可以完全实现FrameLayout的所有功能，所以，FrameLayout也可以放弃。</p>

<p>但从简单方便角度来讲，假如是HomeActivity的根布局，子View都是MATCH_PARENT的Fragement的话，也没有必要换成ConstraintLayout，这种场景FrameLayout完全够用，而且非常适合它。换成ConstraintLayout反倒有些浪费，有些杀鸡用牛刀。</p>

<h3>当相对布局使用（as RelativeLayout）</h3>

<p>从前面的讲述可以看出，ConstraintLayout几乎就是RelativeLayout的加强版。所以，凡是用到RelativeLayout的地方都<strong>应该换成ConstaintLayout</strong>。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.google.cn/training/constraint-layout">Build a Responsive UI with ConstraintLayout</a></li>
<li><a href="https://developer.android.com/reference/androidx/constraintlayout/widget/ConstraintLayout">ConstraintLayout</a></li>
<li><a href="https://www.jianshu.com/p/17ec9bd6ca8a">约束布局ConstraintLayout看这一篇就够了</a></li>
<li><a href="https://developer.android.com/codelabs/constraint-layout#0">Use ConstraintLayout to design your Android views</a></li>
<li><a href="https://www.raywenderlich.com/9475-constraintlayout-tutorial-for-android-complex-layouts">ConstraintLayout Tutorial for Android: Complex Layouts</a></li>
<li><a href="https://abhiandroid.com/ui/constraintlayout">Constraint Layout Tutorial With Example In Android Studio</a></li>
<li><a href="https://blog.csdn.net/guolin_blog/article/details/53122387">Android新特性介绍，ConstraintLayout完全解析</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android事件高级手势处理]]></title>
    <link href="http://toughcoder.net/blog/2021/08/03/advanced-event-gesture-tricks/"/>
    <updated>2021-08-03T21:26:02+08:00</updated>
    <id>http://toughcoder.net/blog/2021/08/03/advanced-event-gesture-tricks</id>
    <content type="html"><![CDATA[<p>GestureDetector只能帮我们处理并识别一些常用的简单的手势，如点击，双击，长按，滑动（Scroll）和快速滑动（Fling）等，一般情况下，这些足够我们使用了，但有些时候需要一些更为复杂的手势操作，如Translate，Zoom，Scale和Rotate，以及像处理一些多点触控（MultiTouch），这就需要开发人猿自己处理了，本文将讨论一下这些内容。</p>

<p><a href=""><img src="http://en.proft.me/media/android/android_gestures.jpg"></a></p>

<!-- more -->


<h2>高级手势识别</h2>

<h3>移动（Translate/Drag）</h3>

<p>这里的移动的意思是让物体随着手指在屏幕上移动，或者叫作拖拽。而且这个只需要一个手指就可以办到，不涉及多点触控。</p>

<p>其实，这个实现起来并不复杂，从onTouchEvent处获得事件后，不断的用MotionEvent的坐标来刷新目标View即可，甚至都不用管具体的事件类型，因为无论是ACTION_DOWN，ACTION_UP或者ACTION_MOVE，都可以提供新的坐标，只管从事件处取坐标然后刷新就可以了。</p>

<pre><code class="java">   draw at (x0, y0);

   onTouchEvent(event) {
      x = event.getRawX();
      y = event.getRawY();
      invalidate with (x, y); // will draw at (x, y);
   }
</code></pre>

<h3>旋转（Rotate）</h3>

<p>同样，对于旋转用单个手指也可以办到，以目标View当前的位置为圆心，以手指划过的曲线作为圆弧，由此便可让目标View旋转起来，而且这个手势由单个手指也可以实现，不用管多点触控。</p>

<p>其实可以进一步的做简化，认定屏幕中央为圆心，来计算手势划过的角度，并且为了连惯性，要以事件ACTION_MOVE过程中的增量角度来对View进行旋转，这样会让旋转看起来更顺滑一些，额外的工作是要把事件的坐标进行一下转化，转化为以屏幕中心为原点的坐标。</p>

<p>具体的流程是：</p>

<pre><code class="java">   lastTheta = -1;

   onTouchEvent(event) {
   switch (action) {
   case ACTION_DOWN:
      lastX = normalize(event.getX());
      lastY = normalize(event.getY());
      lastTheta = angle(lastX, lastY);
      break;
   case ACTION_MOVE:
     newX = normalize(event.getX());
     newY = normalize(event.getY());
     theta = angle(newX, newY);
     deltaTheta = alpha - beta;
     invalidate to rotate with deltaTheta;
     lastTheta = theta;
     break;
   case ACTION_CANCEL:
   case ACTION_UP:
      we are done.
   }

   normalizeX(x) {
      return 2 * x / screenWidth;
   }

   normalizeY(y) {
     return 2 * y / screenHeight;
   }

   angle(x, y) {
      return atan(y / x);
   }
</code></pre>

<p>至于缩放，单个手指无法完成，必须要用两个手指才可以，就涉及到多点触控，所以需要先介绍一下多点触控。</p>

<h2>多点触控（MultiTouch）</h2>

<p>这个并不复杂，虽然听起来像个神秘高科技，但其实，处理流程并不复杂，主体流程仍然是在onTouchEvent方法中，并且主要的对象仍是<a href="https://developer.android.com/reference/android/view/MotionEvent?hl=en">MotionEvent</a>，文档里面基本上都说清楚了，要点就是：</p>

<ol>
<li>MotionEvent对象，会用pointerId和pointerIndex来区分不同的触控点（术语是Pointer）</li>
<li>事件流是：ACTION_DOWN 称为主触控点(Primary Pointer），然后是ACTION_POINTER_DOWN 另外一个触控点来了（非Primary Pointer），然后是ACTION_MOVE 这里没有显示 区分不同的pointer，需要开发人猿自己去区分，然后是ACTION_POINTER_UP 非主触控点 离开了，最后是ACTION_UP 主触控点离开了。需要注意的是，这是处理事件的逻辑上的顺序 ，真实的事件流，不一定是这样的（ACTION_DOWN肯定是第一个，ACTION_UP肯定 肯定最后一个，但中间的几个有顺序 不定）。</li>
<li>注意的要点，每次事件来了后，不同的触控点（Pointer）的index并不是固定的，比如上一次MOVE时它在index 0，但下次可能就在index 1，而其Pointer Id是固定的。所以在处理的整个流程中要记录不同Pointer的id，然后获得其index，再用index去取坐标啊之类的数据。</li>
<li>多点触控，天生就支持，所以即使你不识别多点触控手势（如scale），只关心单个手指手势，在处理的时候，仍要考虑到多点的逻辑。比如说translate时，如果不考虑多点，那么当另外一个手指触摸了屏幕，产生了ACTION_MOVE事件，但它的坐标跟最初产生事件的Pointer差距很远，那么如果不做排除，就可能产生瞬间漂移。</li>
</ol>


<h3>加强版的单触控点手势</h3>

<p>对于前面提到的单触控点手势（单手指就能识别的手势）如Translate和Rotate，其实都需要加强一下逻辑，以防止多触控点产生的干扰。</p>

<p>加强版本的单触控点手势处理：</p>

<pre><code class="java">   primaryPointerId = INVALIDE_POINTER_ID;

   onTouchEvent(event) {
      switch (event.getActionMasked()) {
         case ACTION_DOWN:
              primaryPointer = event.getPointerId(event.getActionIndex());
              break;
         case ACTION_MOVE:
              pointerIndex = event.findPointerIndex(primaryPointerId);
              x = event.getX(pointerIndex);
              y = event.getY(pointerIndex);
              be happy with x and y;
              break;
          case ACTION_UP:
          case ACTION_CANCEL:
            primaryIndex = INVALIDE_POINTER_ID;
            break;
      }
   }
</code></pre>

<p>当然，这里也取决于具体的使用场景，假如允许切换触控点，比如先一个手指拖动，然后另外一个手指点进来，这时第一个手指离开了，如果想继续 拖动的话，就需要更换已保存的primaryPointer。这时会收到ACTION_POINTER_UP，需要在此做切换处理，继续 上面的代码片段，</p>

<pre><code class="java">      secondPointer = INVALIDE_POINTER_ID;
      case ACTION_POINTER_DOWN:
         secondPointer = event.getPointerId(event.getActionIndex());
         break;
      case ACTION_POINTER_UP:
         thisPointer = event.getPointerId(event.getActionIndex());
         if (thisPointer == primaryPointer) {
              primaryPointer = secondPointer;
         }
         secondPointer = INVALIDE_POINTER_ID;
         break;
</code></pre>

<p>还有一点需要注意的是，不能简单的只用<a href="https://developer.android.com/reference/android/view/MotionEvent#getPointerCount()">getPointerCount</a>来作判断，就比如pointer 1先来，然后pointer 2来了，pointer 1又离开了，这时pointerCount仍是1，但是pointer已变化 了，事件的位置就变了，如果不按上述方法处理，将会发生跳变。</p>

<h3>缩放（Zoom/Scale）</h3>

<p>缩放手势是多点触控的一个非常典型的应用，因为单手无法做出比较合理的手势判断。SDK当中提供了一个用于识别缩放的手势识别器<a href="https://developer.android.com/reference/android/view/ScaleGestureDetector">ScaleGestureDetector</a>，它的使用方法与GestureDetector一样，创建对象，塞MotionEvent进去，然后注册listener即可。</p>

<p>但如果，用单独的detector不是很方便，比如已经自己实现了一套手势识别逻辑，现在只想加上Scale，或者其他原因不方便引入ScaleGestureDetector，那么就得自己去做了，也并不是很复杂。</p>

<p>主要思路就是，收集齐两个触控点，记录它们初始的位置，计算它们之间初始的距离，在ACTION_MOVE时，再计算新的距离，新旧距离之比既可当作缩放的比例：</p>

<pre><code class="java">   primaryPointer = INVALIDE_POINTER_ID;
   secondPointer = INVALIDE_POINTER_ID;
   initialSpan = -1;
   startPoint = null;
   onTouchEvent(event) {
         case ACTION_DOWN:
              index = event.getActionIndex();
              primaryPointer = event.getPointerId(index);
              startPoint = Point(event.getX(index), event.getY(index));
              break;
         case ACTION_POINTER_DOWN:
              index = event.getActionIndex();
              secondPointer = event.getPointerId(index);
              sp = Point(event.getX(index), event.getY(index));
              initialSpan = distance(startPoint, sp);
             break;
         case ACTION_MOVE:
              if (event.getPointerCount() &gt; 1) {
                  primaryIndex = event.findPointerIndex(primaryPointer);
                  pp = Point(event.getX(primaryIndex), event.getY(primaryIndex));
                  secondIndex = event.findPointerIndex(secondPointer);
                  sp = Point(event.getX(secondIndex), event.getY(secondIndex));
                  thisDistance = distance(pp, sp);
                  if (thisDistance &gt; ScaledSpan) {
                    scale = thisDistance / initialSpan;
                    be happy with scale;
                  }
              }
              break;
         case ACTION_UP:
         case ACTION_CANCEL:
         case ACTION_POINTER_UP:
             thisPointer = event.getPointerId(event.getActionIndex());
             if (thisPointer == primaryPointer) {
                primaryPointer = INVALIDE_POINTER_ID;
             } else if (thisPointer == seocndPointer) {
                secondPointer = INVALIDE_POINTER_ID;
             }
            break;
   }
</code></pre>

<p>当然 ，还可以加一些阈值判断，比如当distance大于<a href="https://developer.android.com/reference/android/view/ViewConfiguration?hl=en#getScaledTouchSlop()">getScaledTouchSlop</a>，才触发使用scale的逻辑。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://en.proft.me/2017/06/25/detecting-gestures-android-gesturedetector/">Detecting gestures on Android via GestureDetector</a></li>
<li><a href="https://developer.android.com/training/gestures/multi">Handle multi-touch gestures</a></li>
<li><a href="https://developer.android.com/training/gestures/scale">Drag and scale</a></li>
<li><a href="https://developer.android.com/guide/topics/ui/drag-drop">Drag and drop</a></li>
<li><a href="https://developer.android.com/reference/android/view/MotionEvent?hl=en">MotionEvent</a></li>
<li><a href="https://guides.codepath.com/android/gestures-and-touch-events">Gestures and Touch Events</a></li>
<li><a href="https://github.com/Almeros/android-gesture-detectors">android-gesture-detectors</a></li>
<li><a href="https://github.com/ikew0ng/SwipeBackLayout">SwipeBackLayout</a></li>
<li><a href="https://github.com/alexvasilkov/GestureViews">GestureViews</a></li>
<li><a href="https://github.com/nisrulz/Sensey">Sensey</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android View滑动处理大法]]></title>
    <link href="http://toughcoder.net/blog/2021/07/26/android-view-scrolling-made-easy/"/>
    <updated>2021-07-26T22:27:14+08:00</updated>
    <id>http://toughcoder.net/blog/2021/07/26/android-view-scrolling-made-easy</id>
    <content type="html"><![CDATA[<p>对于触控式操作来说，滑动是一个特别重要的手势操作，如何做到让应用程序的页面滑动起来如丝般顺滑，让用户感觉到手起刀落的流畅感，是开发人猿需要重点解决的问题，这对提升用户体验是最为重要的事情。本文就将探讨一下，Android中View的滑动相关知识，以及如何做到丝般顺滑。</p>

<p><a href=""><img src="https://i.stack.imgur.com/tGa5g.png"></a></p>

<!-- more -->


<h2>如何让View滑动起来</h2>

<p>View的滑动是GUI支持的一项基本特性，就像触摸事件一件，这是废话，平台如果不支持，你还搞个毛线。</p>

<h3>View滑动的基本原理</h3>

<p>我们先来看一下Android中实现View的滑动的基本原理。其实屏幕并没有动啊，一个View的可绘制区域，对于屏幕来说，对于view tree来说都是没有变化 的。父布局给某一个View的绘制区域是在layout之后就确定好了的，当View的真实高度或者宽度超过了这块可绘制区域，那么就需要滑动才可以把整个View做到用户可见。View内部通过两个关键成员变量mScrollX和mScrollY来记录滑动之后的坐标，View本身有mLeft和mTop来标识自己相对于父布局的坐标位置，那么当有滑动的时候，在此View当中具体要绘制的区域就变成了以mLeft+mScrollX和mTop+mScrollY为起点的区域了。由此View便滚动起来了。</p>

<h3>如何实现View的滑动</h3>

<p>对于开发人猿来说，实现View的滑动，需要关注三个重要的方法，也即是<a href="https://developer.android.com/reference/android/view/View#scrollBy(int,%20int">View#scrollBy</a>)，<a href="https://developer.android.com/reference/android/view/View#scrollTo(int,%20int">View#scrollTo</a>)以及<a href="https://developer.android.com/reference/android/view/View#onScrollChanged(int,%20int,%20int,%20int">View#onScrollChanged</a>)，这是实现滑动的三个最为核心的方法。</p>

<p>scrollBy提供的参数是需要滑动的距离，而scrollTo则是需要传入要滑动到的目标坐标值，这两个方法都是要修改mScrollX和mScrollY的值，本质上是一样的。而onScrollChanged则是一个回调，用以通知更新了的滑动位置。</p>

<h2>Scroll手势</h2>

<p>要想让View滑动起来，离不开事件手势的支持。最简单也是最直接的手势就是onScroll手势，这个在GestureDetecor中可以识别出此手势，或者自己去直接处理touch event也可以得出此手势。这个并不复杂，就是直接通过touch 事件来计算滑动多少距离就好了，按照View预设计的可以滑动的方向，比如横向就计算不同时间点MotionEvent的坐标值，得到一个水平距离deltaX，然后调用scrollBy即可。垂直方向依此类推。</p>

<p>Scroll手势简单是因为它是直接来源于事件，且速度较慢，并不需要额外处理，所以整体逻辑处理流程并不复杂。</p>

<p>在<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/GestureDetector.java?q=gesturedetector">GestureDetector</a>中的识别就是在ACTION_MOVE时，查看滑动过的距离，这个距离（由sqrt(dx x dx, dy x dy）如果大于touch slop，就会触发onScroll手势回调。</p>

<h2>Fling手势</h2>

<p>Fling也即是快速滑动，就是手指在屏幕上使劲的『挠』一下，手势的要点是手指在屏幕快速滑过一小段短距离，就像把一个小球弹出去的感觉一样。对于Fling手势来说，最重要的是速度，水平方向的速度和垂直方向的速度，可以理解为高中物理常讲到的平抛运动一样。</p>

<p>GestureDetector识别Fling的逻辑是，在ACTION_UP时，检查此次事件的速度，如果水平方向速度或者垂直方向速度超过了阈值，便会触发Fling手势回调。</p>

<p><strong>注意</strong>：留意Scroll与Fling的区别，Scroll是慢的，不关心时间与速度，只关心滑动的距离，是在ACTION_MOVE时，手指并未有离开屏幕时就触发了，只要是ACTION_MOVE还在继续，就会继续触发onScroll，并且ACTION_UP时终止整个Scroll，而Fling只关心速度，不关心距离，是在ACTION_UP时，手指离开了屏幕了（此次事件流处理结了）才会触发。</p>

<h2>VelocityTracker</h2>

<p>Fling事件速度是决定性的，仔细看GestureDetector的处理过程会发现它使用了一个叫做VelocityTracker的对象，来帮忙处理一些关于速度的具体逻辑，那么有必要深入了解一下这个对象。</p>

<p><a href="https://developer.android.com/reference/android/view/VelocityTracker?hl=en">VelocityTracker</a>使用起来并不复杂，获取它的一个对象后，只需要不断的把MotionEvent塞给它就可以了，然后在需要的时候让其计算两个方向上的速度，然后就没有然后了：</p>

<pre><code class="java">    velocityTracker = VelocityTracker.obtain();

    onTouchEvent(MotionEvent ev) {
        velocityTracker.addMovement(ev);

        if (want to know velocities) {
           velocityTracker.computeCurrentVelocity(100);
           vx = velocityTracker.getXVelocity();
           vy = veolocityTracker.getYVelocity();
           be happy with vx and vy.
        }
     }
</code></pre>

<p>这个类的实现，值得仔细看一下，它主要的实现都是用JNI去实现，可能是因为计算方式较复杂，所以<a href="https://developer.android.com/reference/android/view/VelocityTracker?hl=en#computeCurrentVelocity(int">computeCurrentVelocity</a>)方法也说明了，让你真用的时候再调，这个不用去管细节实现。重点看一下这个类，里面有一个对象池，用以缓存对象，并且创建对象的方式并不是直接new，而是用其<a href="https://developer.android.com/reference/android/view/VelocityTracker?hl=en#obtain(">obtain</a>)方法。这里用的是叫<a href="https://refactoring.guru/design-patterns/flyweight">享元</a>（Flyweight Pattern)的设计模式，也就是说VelocityTracker对象其实是共享的。</p>

<h2>顺滑如丝</h2>

<p>前面提到了，让View滑动，只需要调用scrollBy或者scrollTo即可，但这个吧，是直接修改了mScrollX，mScrollY，然后invalidate，View下次draw时就直接在把目标区域内容绘制出来了，换句话说这两个方法滑动是瞬间跳格式的。</p>

<p>一般来说，这也没有问题，就像onScroll手势，ACTION_MOVE时，不断的scrollBy刚刚滑过的距离，都还okay，没有什么问题。</p>

<p>但是对于Fling事件就不行了，Fling事件，也即快速滑动，要求短时间内进行大距离滑动，或者像有跳转的需求时，也是短时间内要滑动大距离。如果直接scrollBy或者scrollTo一步到位了，会显得 相当的突兀，体验相当不好，卡顿感特别强。如果能像做动画那样，在一定时间内，让其平滑的滑动，就会如丝般顺滑，体验好很多。Scroller就是专门用来解决此问题的。</p>

<h3>Scroller</h3>

<p><a href="">Scroller</a>是对滑动的封装，并不是View的子类，其实它跟View一点关系也没有，也不能操作View，实际上它与属性动画类似，它仅是一个滚动位置的计算器，告诉它起始位置和要滚动的距离，然后它就会告诉你位置随时间变化的值。其实这是一个中学物理题，也即给定初始位置，给定要滚动的距离，以一定的方式来计算每个时间点的位置。具体的计算方式由mInterpolater成员来控制，默认是ViscousFluid，是按自然指数为减速度来计算的，具体的可以查看Scroller的源码。如果不喜欢默认的计算方式，可以自己实现个Interpolator，然后在构造时传进去。</p>

<p>Scroller的作用在于实现平稳滑动，不让View的滚动出现跳跃，比如滑动一下ListView，开始滑动时的位置是x0，y0（ActionDown的位置），要向下滑动比如500个像素，不平稳的意思是，从x0，一下跳到x0+500的位置。要平稳，就要不断的一点点的改变x的值然后invalidate，这也就是Scroller的典型使用场景：</p>

<pre><code class="java">Scroller scroller = new Scroller(getContext());
scroller.startScroll(x0, y0, 500, 0);
</code></pre>

<p>然后在computeScroll时：</p>

<pre><code class="java">if (scroller.computeScrollOffset()) {
   int currX = scroller.getCurrX();
   int currY = scroller.getCurrY();
   invalidate(); // with currX and currY
}
</code></pre>

<p>computeScrollOffset在滚动没结束时返回true，也就是说你需要继续刷新view。返回false时表明滚动结束了，当然也就没有必要再刷新view（当然如果你乐意也可以继续刷，但是位置啥的都不变了，所以刷了也白刷）。</p>

<h2>滑动冲突处理</h2>

<p>关于View的滑动，最难搞的问题便是手势冲突处理，特别是当页面的结构变得复杂了以后。一般来讲，滑动手势，是让某一个View沿着某一个方向『平移』一段距离，如果某一个页面中只有一个View是可以滑动的，或者页面中不同的View的可滑动方向是垂直正交的，那么就不会有冲突的问题。</p>

<p>所谓滑动冲突，是指父View和子View都接受滑动手势，并且方向又是一样的，这时就产生了滑动冲突，常见就是ScrollView中套着ListView（这个通常是垂直Y方向上面有滑动冲突），或者ViewPager中套着ScrollView（这个是水平X方向上有滑动冲突）。</p>

<p>要想解决好滑动冲突问题，需要先确实好整体的设计方案，有了大的原则后，就容易用技术方案找到解法。最理想的方案，也是目前用的最多的方案就是在子View的边界设定一个margin区域，当ACTION_DOWN在margin区域以外，认定滑动手势归父View处理，否则交由子View处理。像一些全局手势也是要用如此的方案，当点击距离屏幕一定范围内(margin区域)认定此事件归当前页面处理，否则就认定为全局手势，就好比从屏幕左边向右滑动，很多应该将此识别为BACK到上一页，但如果离左边较远时滑动，就会是页面内部的滑动事件（假如它有可滑动的组件的话，事件手势会被其滑消耗掉）。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/training/gestures/detector">Detect common gestures</a></li>
<li><a href="https://en.wikipedia.org/wiki/Flyweight_pattern">Flyweight pattern</a></li>
<li><a href="https://www.tutorialspoint.com/design_pattern/flyweight_pattern.htm">Design Patterns - Flyweight Pattern</a></li>
<li><a href="https://developer.android.com/training/gestures/scroll">Animate a scroll gesture</a></li>
<li><a href="https://stackoverflow.com/questions/11030639/android-scroller-simple-example">Android Scroller simple example</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android View 事件派发流程]]></title>
    <link href="http://toughcoder.net/blog/2021/07/21/android-view-event-dispatching/"/>
    <updated>2021-07-21T19:14:58+08:00</updated>
    <id>http://toughcoder.net/blog/2021/07/21/android-view-event-dispatching</id>
    <content type="html"><![CDATA[<p>自从乔帮主横空出世推出了iPhone以来，触控式的操作便成了21世纪智能设备的标准输入方式。对于同是智能操作系统的Android来说，也不例外。事件，特别是触控事件对于移动应用程序开发来说是一个非常重要的，也是开发人猿必须掌握的事情。这里就要讨论一下Android View中的Event系统，重点探讨一下事件的派发流程。</p>

<p><a href=""><img src="https://i.stack.imgur.com/PgRvm.png"></a></p>

<!-- more -->


<h2>输入事件综述</h2>

<h3>事件的分类</h3>

<p>对于Android系统来说用户输入事件分为两类，一个是<a href="https://developer.android.com/reference/android/view/KeyEvent?hl=en">KeyEvent</a>，这个是硬件产生的事件，或者更准确的说是非触控手势产生的事件，通常包括硬件按扭如音量键，电源键，系统导航（HOME，BACK和MENU）以及外设（如外接设备，键盘，自拍杆等）系统层也都会统一的做成映射转成KeyEvent传给当前Window窗口（当前进程）。</p>

<p>还有一类就是专指解控屏幕产生的触摸式的手势事件，是<a href="https://developer.android.com/reference/android/view/MotionEvent">MotionEvent</a>，为啥不叫TouchEvent呢，因为啊最初的Android版本是支持滑动球的，现在已经没有这种设备，但是名字就这么流传下来了。这个事件专门由视图系统view tree来处理，本文也将重点讨论此类事件。</p>

<h3>事件从哪里来</h3>

<p>简单来说事件是源自于硬件，比如屏幕或者按键，这是废话，知道了这个意义也不大，硬件产生电子信号后会经由驱动传给内核，内核再报给输入系统，再传给wms（Windows Manager Server），最终会到Window这里。对于应用层来说，可以理解 为事件都是从Window对象这里来的就行了。</p>

<h3>谁先收到事件</h3>

<p>对于GUI应用程序层来说，wms就是事件来源，那么ViewRootImpl对象是第一个接收到事件，ViewRootImpl并没有直接把事件派发给view tree，而是先给到DecorView，宿主组件在DecorView处有一个专门接收事件的回调，由此事件便到了当前的宿主组件如Activity或者Dialog，看它是否愿意做处理，如果它不处理，那么就会把事件再派发给GUI视图系统，也即view tree，这一次没有再经过ViewRootImpl对象，而是由Window对象直接调用根节点的dispatchTouchEvent或者dispatchKeyEvent。</p>

<pre><code>   15:57:02.254   W/System.err: java.lang.Exception: Stack trace
   15:57:02.255   W/System.err:     at java.lang.Thread.dumpStack(Thread.java:1348)
   15:57:02.256   W/System.err:     at net.toughcoder.view.ViewWindowExampleActivity.dispatchKeyEvent(ViewWindowExampleActivity.java:107)
   15:57:02.256   W/System.err:     at com.android.internal.policy.DecorView.dispatchKeyEvent(DecorView.java:342)
   15:57:02.256   W/System.err:     at android.view.ViewRootImpl$ViewPostImeInputStage.processKeyEvent(ViewRootImpl.java:5053)
   15:57:02.257   W/System.err:     at android.view.ViewRootImpl$ViewPostImeInputStage.onProcess(ViewRootImpl.java:4921)
   15:57:02.257   W/System.err:     at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:4442)
   15:57:02.258   W/System.err:     at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:4495)
   15:57:02.258   W/System.err:     at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:4461)
   15:57:02.259   W/System.err:     at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:4601)
   15:57:02.259   W/System.err:     at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:4469)
   15:57:02.259   W/System.err:     at android.view.ViewRootImpl$AsyncInputStage.apply(ViewRootImpl.java:4658)
   15:57:02.260   W/System.err:     at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:4442)
   15:57:02.260   W/System.err:     at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:4495)
   15:57:02.260   W/System.err:     at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:4461)
   15:57:02.261   W/System.err:     at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:4469)
   15:57:02.261   W/System.err:     at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:4442)
   15:57:02.261   W/System.err:     at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:4495)
   15:57:02.262   W/System.err:     at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:4461)
   15:57:02.262   W/System.err:     at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:4634)
   15:57:02.263   W/System.err:     at android.view.ViewRootImpl$ImeInputStage.onFinishedInputEvent(ViewRootImpl.java:4795)
   15:57:02.263   W/System.err:     at android.view.inputmethod.InputMethodManager$PendingEvent.run(InputMethodManager.java:2571)
   15:57:02.263   W/System.err:     at android.view.inputmethod.InputMethodManager.invokeFinishedInputEventCallback(InputMethodManager.java:2081)
   15:57:02.264   W/System.err:     at android.view.inputmethod.InputMethodManager.finishedInputEvent(InputMethodManager.java:2072)
   15:57:02.264   W/System.err:     at android.view.inputmethod.InputMethodManager$ImeInputEventSender.onInputEventFinished(InputMethodManager.java:2548)
   15:57:02.265   W/System.err:     at android.view.InputEventSender.dispatchInputEventFinished(InputEventSender.java:141)
   15:57:02.265   W/System.err:     at android.os.MessageQueue.nativePollOnce(Native Method)
   15:57:02.265   W/System.err:     at android.os.MessageQueue.next(MessageQueue.java:326)
   15:57:02.265   W/System.err:     at android.os.Looper.loop(Looper.java:160)
   15:57:02.266   W/System.err:     at android.app.ActivityThread.main(ActivityThread.java:6692)
   15:57:02.266   W/System.err:     at java.lang.reflect.Method.invoke(Native Method)
   15:57:02.266   W/System.err:     at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:493)
   15:57:02.266   W/System.err:     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858)
</code></pre>

<pre><code>   15:57:14.582   W/System.err: java.lang.Exception: Stack trace
   15:57:14.586   W/System.err:     at java.lang.Thread.dumpStack(Thread.java:1348)
   15:57:14.586   W/System.err:     at net.toughcoder.view.DemoEventView.dispatchTouchEvent(DemoEventView.java:24)
   15:57:14.586   W/System.err:     at android.view.ViewGroup.dispatchTransformedTouchEvent(ViewGroup.java:3030)
   15:57:14.586   W/System.err:     at android.view.ViewGroup.dispatchTouchEvent(ViewGroup.java:2662)
   15:57:14.586   W/System.err:     at android.view.ViewGroup.dispatchTransformedTouchEvent(ViewGroup.java:3030)
   15:57:14.587   W/System.err:     at android.view.ViewGroup.dispatchTouchEvent(ViewGroup.java:2662)
   15:57:14.587   W/System.err:     at android.view.ViewGroup.dispatchTransformedTouchEvent(ViewGroup.java:3030)
   15:57:14.587   W/System.err:     at android.view.ViewGroup.dispatchTouchEvent(ViewGroup.java:2662)
   15:57:14.587   W/System.err:     at android.view.ViewGroup.dispatchTransformedTouchEvent(ViewGroup.java:3030)
   15:57:14.587   W/System.err:     at android.view.ViewGroup.dispatchTouchEvent(ViewGroup.java:2662)
   15:57:14.587   W/System.err:     at com.android.internal.policy.DecorView.superDispatchTouchEvent(DecorView.java:440)
   15:57:14.588   W/System.err:     at com.android.internal.policy.PhoneWindow.superDispatchTouchEvent(PhoneWindow.java:1830)
   15:57:14.588   W/System.err:     at android.app.Activity.dispatchTouchEvent(Activity.java:3400)
   15:57:14.588   W/System.err:     at com.android.internal.policy.DecorView.dispatchTouchEvent(DecorView.java:398)
   15:57:14.588   W/System.err:     at android.view.View.dispatchPointerEvent(View.java:12753)
   15:57:14.588   W/System.err:     at android.view.ViewRootImpl$ViewPostImeInputStage.processPointerEvent(ViewRootImpl.java:5122)
   15:57:14.588   W/System.err:     at android.view.ViewRootImpl$ViewPostImeInputStage.onProcess(ViewRootImpl.java:4925)
   15:57:14.588   W/System.err:     at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:4442)
   15:57:14.588   W/System.err:     at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:4495)
   15:57:14.589   W/System.err:     at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:4461)
   15:57:14.589   W/System.err:     at android.view.ViewRootImpl$AsyncInputStage.forward(ViewRootImpl.java:4601)
   15:57:14.589   W/System.err:     at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:4469)
   15:57:14.589   W/System.err:     at android.view.ViewRootImpl$AsyncInputStage.apply(ViewRootImpl.java:4658)
   15:57:14.589   W/System.err:     at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:4442)
   15:57:14.589   W/System.err:     at android.view.ViewRootImpl$InputStage.onDeliverToNext(ViewRootImpl.java:4495)
   15:57:14.589   W/System.err:     at android.view.ViewRootImpl$InputStage.forward(ViewRootImpl.java:4461)
   15:57:14.589   W/System.err:     at android.view.ViewRootImpl$InputStage.apply(ViewRootImpl.java:4469)
   15:57:14.590   W/System.err:     at android.view.ViewRootImpl$InputStage.deliver(ViewRootImpl.java:4442)
   15:57:14.590   W/System.err:     at android.view.ViewRootImpl.deliverInputEvent(ViewRootImpl.java:7117)
   15:57:14.590   W/System.err:     at android.view.ViewRootImpl.doProcessInputEvents(ViewRootImpl.java:7086)
   15:57:14.590   W/System.err:     at android.view.ViewRootImpl.enqueueInputEvent(ViewRootImpl.java:7047)
   15:57:14.590   W/System.err:     at android.view.ViewRootImpl$WindowInputEventReceiver.onInputEvent(ViewRootImpl.java:7220)
   15:57:14.590   W/System.err:     at android.view.InputEventReceiver.dispatchInputEvent(InputEventReceiver.java:187)
   15:57:14.590   W/System.err:     at android.os.MessageQueue.nativePollOnce(Native Method)
   15:57:14.590   W/System.err:     at android.os.MessageQueue.next(MessageQueue.java:326)
   15:57:14.591   W/System.err:     at android.os.Looper.loop(Looper.java:160)
   15:57:14.591   W/System.err:     at android.app.ActivityThread.main(ActivityThread.java:6692)
   15:57:14.591   W/System.err:     at java.lang.reflect.Method.invoke(Native Method)
   15:57:14.591   W/System.err:     at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:493)
   15:57:14.591   W/System.err:     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:858)
</code></pre>

<p>因此，从应用程序的角度来说，第一个收到事件的是Activity或者Dialog这种持有Window的顶级组件，所以如果想要从窗口级别来拦截掉所有的事件，那么Activity会是最好的选择，代码示例：</p>

<pre><code class="java">   @Override
   public boolean dispatchKeyEvent(KeyEvent event) {
        if (want to intercept all key events) {
              return true;
        }
        return super.dispatchKeyEvent(event);
    }

     @Override
   public boolean dispatchTouchEvent(MotionEvent event) {
        if (want to intercept all touch events) {
              return true;
        }
        return super.dispatchTouchEvent(event);
    }
</code></pre>

<p>上面两个方法是在view tree之前最先收到事件的方法，是组件里面想拦截的最佳地点，这是从前面打先锋。而要想处理掉view tree未处理的事件，则需要在<a href="https://developer.android.com/reference/android/app/Activity?hl=en#onKeyUp(int,%20android.view.KeyEvent">onKeyUp(int keyCode, KeyEvent event)</a>)和<a href="https://developer.android.com/reference/android/app/Activity?hl=en#onKeyDown(int,%20android.view.KeyEvent">onKeyDown(int keyCode, KeyEvent event)</a>)以及<a href="https://developer.android.com/reference/android/app/Activity?hl=en#onTouchEvent(android.view.MotionEvent">onTouchEvent(MotionEvent event）</a>)这几个方法里面处理，这个相当于是断后。</p>

<h3>事件的散发过程（Event Propagation)</h3>

<p>事件到达应用程序这一端后，从Activity开始了散发过程，它的机制 和过程好比一个各处流动的小球，每个节点都接收一个事件对象，返回一个boolean，如果返回true则表示事件在此被消耗，当前事件散发终止，而如果返回false，表示当前节点对此事件不感兴趣，事件继续散发。</p>

<p>而具体的流程，则是先到Activity（Dialog等第一级组件），再到view tree，在view tree里面也是如此从父view到子view如此一个一个的传递，这个先后顺序流程则是由整个系统构架决定的。</p>

<h3>事件是一个数据流</h3>

<p>前面讲的事件的散发过程，就可以看作是一个球在在流动，这是从单个事件的处理角度看，是这样。但从整个的事件来看更如此，因为事件通常像电子信号一样，是从来源出发（如触摸屏，硬件等），有一定时间间隔的一连串的事件对象的派发的整个过程，简单来比喻就是几个球，每隔1秒就发出一个球，这样一个数据流。</p>

<p>说了这么多，其实真实要做起来还是比较简单的，虽然是一个数据流，但是每 一个流都有开始和结束的标志，处理起来并不难。比如KeyEvent，开始是onKeyDown，然后是onKeyUp，在这两个里面处理，就完成了对KeyEvent流的处理。</p>

<p>而MotionEvent则稍复杂一些，一个MotionEvent流，系统会不断的回调onTouchEvent，直到结束，通过<a href="https://developer.android.com/reference/android/view/MotionEvent?hl=en#getAction(">MotionEvent#getAction()</a>)来判断，从<a href="https://developer.android.com/reference/android/view/MotionEvent?hl=en#ACTION_DOWN">ACTION_DOWN</a>到ACTION_MOVE到ACTION_UP或者ACTION_CANCEL结束。</p>

<p><strong>注意</strong>：因为KeyEvent的处理相对较简单，所以剩下的部分将重点讨论MotionEevnt。</p>

<h2>Touch Event的派发流程</h2>

<p>事件产生以后，会传递给Activity#dispatchTouchEvent，如果没有被拦截，那么就会传给Window，而Window则会传给ViewRootImpl来处理，view tree处理完后，会再交给Activity#onTouchEvent：</p>

<pre><code class="java">     public boolean dispatchTouchEvent(MotionEvent ev) {
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            onUserInteraction();
        }
        if (getWindow().superDispatchTouchEvent(ev)) {
            return true;
        }
        return onTouchEvent(ev);
    }
</code></pre>

<p>这个方法可以清楚地看到，先锋和断后和view tree在事件派发流动中的顺序。</p>

<p>下面重点看看在Window中（view tree）里面事件的派发流动过程。其实重点看<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/View.java;bpv=0;bpt=1">View#dispatchTouchEvent</a>和<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/ViewGroup.java;bpv=0;bpt=1">ViewGroup#dispatchTouchEvent</a>就可以了，需要注意的是，事件的派发流程与处理流程是不一样的，派发在先，处理在后，所以如果看事件的派发需要看dispatch打头的方法，而处理则是看on打头的。</p>

<p>View的dispatch较为简单一些，因为它提供的是一个默认的实现，并且View是作为view tree中的一个叶子的，因此它的dispatch实际上就是一个终点，所以它做的事情就是，看是否有OnTouchListener，有就调用其onTouch，然后再调用onTouchEvent把事件处理一下，就完了。从这里也可以看出来OnTouchListener是走在onTouchEvent方法的前面的。</p>

<p>至于ViewGroup则相对复杂，因为它要管理子View，向子View派发事件，并且还要处理拦截。它的逻辑大概是：先看自己是否要拦截<a href="https://developer.android.com/reference/android/view/ViewGroup?hl=en#onInterceptTouchEvent(android.view.MotionEvent">onInterceptTouchEvent</a>)返回true表示要拦截，false不会拦截，如果要拦截，则调用自己的onTouchEvent处理掉事件，然后终止派发(真实的逻辑要略微复杂一些，不同的ACTION处理逻辑不一样)。</p>

<p>重点讲一下ViewGroup是如何向子View派发事件的，当不拦截的时候，这是比较常规的时候，会把事件向子View派发，来捋一捋这一流程：首先，会通过buildTouchDispatchChildList这个方法来选择子View的顺序，这个方法是把子View按事件派发的流程来排序，这个顺序是就是用户看到的顺序，会以Z轴（屏幕从里到外）来排序，以及渲染（draw）的顺序，毕竟从用户角度看最先点击到的，肯定 是Z轴最大（离用户最近），最先draw完的（没有被遮挡）。然后按这个顺序，按个子View调用其上面的dispatchTouchEvent，就把事件向子View传递了过去，当然 这个也是事件在流动，一旦事件被消耗，就会停止派发。</p>

<p>从这个过程来看view tree事件派发是个深度优先的过程，所以view tree的深度不单单影响渲染的性能，连事件处理也比扁平的要慢一些。</p>

<h2>Touch Event事件处理方法</h2>

<p>事件的处理也即是各种on开头的方法如onTouchEvent，或者各种listener（OnClickListener，OnTouchListener）。一般常规来说设置各种listener就够了，但如果想要自定义一些就直接override onTouchEvent方法，这里就不细说了，各种教程太多了。</p>

<h3>listener与直接Override父类方法的区别</h3>

<p>需要注意的是如果要override，那么肯定 要自定义View才可以，所以这个是更『黑客式』的方法，只有有必要自定义View，且常规各种listener不能满足需求才有必要如此做，如实现各种自定义的手势等。</p>

<p>listener最大的好处是，很简单方便，隔离性好，事件的触发与结果是隔离的，想针对 事件做处理，实现一个接口就好了，至于事件条件的触发则不用关心，任何对象都可以实现接口以处理事件，而不必非去子类化（继承）View对象。</p>

<p>还需要注意的是OnTouchListener发生的时间要早于onTouchEvent，而常规的手势回调接口（如OnClickListener和onLongClickListner）是在onTouchEvent中触发的。因此，OnTouchListener其实也是一个更为低级的『黑客式』的接口，一般当需要自定义识别手势时才需要实现此接口。</p>

<h3>防止点击穿透</h3>

<p>有些时候会有一些点击穿透的问题出现，比如写了一个布局，里面有几个Button和TextView，但是当点击这些主要内容之外的空白区域时，此页面下一层的Button却收到事件，比如触发了其onClick事件。当使用层叠 式的Fragment时，此问题较常见。其实从View#onTouchEvent中就可以看到解决方案，如此某个View是clickable的，那么它会把事件消耗掉，而如果clickable为false就会继续传递。</p>

<p>出现穿透的原因就是空白区域，只有这个层页面的一个根布局，通常会是一个ViewGroup，而大部分的ViewGroup默认clickable都是false，因而事件会继续向view tree里面传递，直到其被消耗。</p>

<p>此类问题最简单的解决就是把View设置为clickable=&ldquo;true&#8221;，这个在布局文件中就可以设置。</p>

<h3>基础手势识别</h3>

<p>基础的手势识别，是说对于触控式操作的一些简单的操作的分类，比如轻触屏幕马上拿开，这视为点击（click或者叫press，或者叫tap），长按屏幕视为long click或者叫long press，还有滑动，双击等等。手势识别，即是一套逻辑算法，用以判断用户当前是哪一种操作，然后触发相当的处理逻辑，给与用户操作上的反馈。废话就这么多，接下来来看具体如何做吧。</p>

<p>在Android的GUI系统中基础的手势有点击(click)和长按(long click)。要识别这些基础手势有两种方法，一是设置接口回调给View，也即实现一个<a href="https://developer.android.com/reference/android/view/View.OnClickListener">OnClickListener</a>，然后把此对象设置给<a href="https://developer.android.com/reference/android/view/View#setOnClickListener(android.view.View.OnClickListener">View#setOnClickListener</a>)（长按就是<a href="https://developer.android.com/reference/android/view/View.OnLongClickListener">OnLongClickListener</a>和<a href="https://developer.android.com/reference/android/view/View#setOnLongClickListener(android.view.View.OnLongClickListener">View#setOnLongClickListener</a>)）；另外一种方法，就是针对view tree内部，比如子类化（继承）某个View对象，然后override相应的方法。</p>

<p><strong>注意</strong>: 在写布局xml文件中也可以方便的用onclick属于来指定   手势回调方法，但它的本质与设置一个OnClickListener是一样的。</p>

<p>假如，点击和长按不能满足操作需求时，就需要稍复复杂的基础手势识别对象来帮助，也即是<a href="https://developer.android.com/reference/android/view/GestureDetector?hl=en">GestureDetector</a>，它与View的连接方式是接口分离，其实不见得可以用于View，只要有MotionEvent事件 来源即可。使用的方法并不复杂，只需要设置一个<a href="https://developer.android.com/reference/android/view/View.OnTouchListener">OnTouchListener</a>或者子类化View并override onTouch方法，从中拿到MotionEvent对象，然后把MotionEvent塞给一个GestureDetecotor对象，就完了，GestureDetector会回调你感兴趣的对应手势处理回调方法，通过<a href="https://developer.android.com/reference/android/view/GestureDetector.OnGestureListener?hl=en">OnGestureListener</a>对象。因为OnGestureListener是一个接口，但如果你仅对某几个手势回调方法感兴趣，不想把所有方法都 写一遍（哪怕是空实现），那么可以子类化<a href="https://developer.android.com/reference/android/view/GestureDetector.SimpleOnGestureListener?hl=en">SimpleOnGestureListener</a>，这是一个类，它实现了OnGestureListener的所有方法，我们仅需要override感兴趣的方法即可。</p>

<p>有一个需要特别注意的事情就是，当你用GestureDetector时，它与常规的onClick或者onLongClick的先后顺序，或者 叫冲突处理。基于一致性的原则，如果使用了GestureDetector时，意味着你想要自己控制事件处理，那么就不应该再 设置onClick或者 onLongClick了。但如果真不小心这么做了，结果又会怎么样呢？这就需要从View的事件处理流程找答案。OnTouchListener的调用是在View#dispatchTouchEvent，这个是在View#onTouchEvent之前，而OnClickListener和OnLongClickListener是在View#onTouchEvent中调用的。所以，顺序是这样的：</p>

<ol>
<li>如果你用OnTouchListener获取的MotionEvent，那么你的OnGestureListener的回调方法是最先被调用到的，在所有的其他回调之前。</li>
<li>如果是override View#onTouchEvent方法获取的event，那么取决于你调用super#onTouchEvent的顺序，如果你是在调用super之前，那么还是你的gesture listener先执行。其实吧，正常人override的写法肯定都先写自己的逻辑最后再调用super，或者干脆不调用super，这是最正统子类override父类的姿式。</li>
</ol>


<p>由此，可以得出的结论就是如果使用了GestureDetector，那么你的gesture listener肯定是优先被执行的。</p>

<h3>onClick与onLongClick的触发时机</h3>

<p>再 来看另外 一个比较 有意思的两个问题，onClick的触发时机是啥时候？从View#onTouchEvent方法中可看出来，是在ACTION_UP时触发的，如果它还没有触发long click，而long click则是在事件开始以后ACTION_DOWN以后开始计时，到达一定时间间隔后便触发，不算后续的事件类型。</p>

<p>整体的流程是这样，在View#onTouchEvent里面，分事件类型来处理，ACTION_DOWN中开始计时，后面ACTION_MOVE中继续计时，如果达到长按标准，则触发long click，在正常结束的ACTION_UP中，看有没有达到长按标准，有就触发long click，没有则触发on click。</p>

<h3>系统阈值定义</h3>

<p>像长按的时长，滑动的最小距离，拉伸的最小距离等 等 这些关键的阈值都 是有系统建议的定义的，这些值都 在<a href="https://developer.android.com/reference/android/view/ViewConfiguration">ViewConfiguration</a>里面，通常建议直接使用系统定义的要好一些，除非真有特殊需要。</p>

<p>可以查看<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/GestureDetector.java?q=gesturedetector">GestureDetector</a>中对这些常量的使用。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://betterprogramming.pub/mastering-the-android-touch-system-41234cf3c3b3">Mastering the Android Touch System</a></li>
<li><a href="https://stackoverflow.com/questions/7449799/how-are-android-touch-events-delivered">How are Android touch events delivered?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android View的渲染过程]]></title>
    <link href="http://toughcoder.net/blog/2020/07/26/android-view-render-flow/"/>
    <updated>2020-07-26T22:53:03+08:00</updated>
    <id>http://toughcoder.net/blog/2020/07/26/android-view-render-flow</id>
    <content type="html"><![CDATA[<p>对于安卓开发猿来说，每天都会跟布局打交道，那么从我们写的一个布局文件，到运行后可视化的视图页面，这么长的时间内到底 发生了啥呢？今天我们就一起来探询这一旅程。</p>

<p><img src="https://miro.medium.com/max/1400/1*6jNYifMX0MvMHxg2cxrzkg.png" alt="" /></p>

<!-- more -->


<h2>View tree的创建过程</h2>

<h3>布局文件的生成过程</h3>

<p>一般情况下，一个布局写好了，如果不是特别复杂的布局，那么当把布局文件塞给Activity#setContentView或者一个Dialog或者一个Fragment，之后这个View tree就创建好了。那么setContentView，其实是通过<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/LayoutInflater.java;bpv=0;bpt=0">LayoutInflater</a>这个对象来具体的把一个布局文件转化为一个内存中的View tree的。这个对象不算太复杂，主要的逻辑就是解析XML文件，把每个TAG，用反射的方式来生成一个View对象，当XML文件解析完成后，一颗View tree就生成完了。</p>

<p>但是需要注意，inflate之后虽然View tree是创建好了，但是这仅仅是以单纯对象数据的形式存在，这时去获取View的一些GUI的相关属性，如大小，位置和渲染状态，是不存在的，或者是不对的。</p>

<h3>手动创建</h3>

<p>除了用布局文件来生成布局，当然也可以直接用代码来撸，这个就比较直观了，view tree就是你创建的，然后再把根节点塞给某个窗口，如Activity或者Dialog，那么view tree就创建完事了。</p>

<h2>渲染前的准备工作</h2>

<p>View tree生成的最后一步就是把根结点送到ViewRootImpl#setView里面，这里会把view添加到wms之中，并着手开始渲染，接下来就主要看ViewRootImpl这个类了，主要入口方法就是<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/ViewRootImpl.java;l=1604;drc=master;bpv=1;bpt=1?q=viewrootimpl">ViewRootImpl#requestLayout</a>，然后是scheduleTraversals()，这里会把请求放入到队列之中，最终执行渲染的是doTraversal，它里面调用的是performTraversals()，所以，我们需要重点查看<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/ViewRootImpl.java;l=2332;drc=master;bpv=1;bpt=1?q=viewrootimpl">ViewRootImpl#performTraversals</a>这个方法，view tree渲染的流程全在这里面。这个方法相当之长，接近1000行，主要就是三个方法performMeasure，performLayout和performDraw，就是常说的三大步：measure，layout和draw。</p>

<h2>渲染之measure</h2>

<p>就看<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/ViewRootImpl.java;drc=master;l=3391?q=viewrootimpl">performMeasure</a>方法，这个方法很简单，就是调用了根view的measure方法，然后传入widthSpec和heightSpec。measure的目的就是测量view tree的大小，就是说view tree在用户可视化角度所占屏幕大小。要想理解透彻measure，需要理解三个事情，MeasureSpec，View#measure方法和View#onMeasure方法：</p>

<h3>理解MeasureSpec</h3>

<p>从<a href="https://developer.android.com/reference/android/view/View.MeasureSpec">文档</a>中可以了解到，MeasureSpec是从父布局传给子布局，用以代表父布局对子布局在宽度和高度上的约束，它有两部分一个是mode，一个是对应的size，打包成一个integer。</p>

<ul>
<li><p>UNSPECIFIED</p>

<p> 父布局对子布局没有要求，子布局可以设置任意大小，这个 基本上 不常见。</p></li>
<li><p>EXACTLY</p>

<p> 父布局已经计算好了一个精确的大小，子布局要严格按照 这个来。</p></li>
<li><p>AT_MOST</p>

<p> 子布局最大可以达到传过来的这个尺寸。</p></li>
</ul>


<p>光看这几个mode，还是不太好理解。因为我们平日里写布局，在大小（或者说宽和高）这块就三种写法：一个是<a href="https://developer.android.com/reference/android/view/ViewGroup.LayoutParams#MATCH_PARENT">MATCH_PARENT</a>，也就是要跟父布局一样大；要么是<a href="https://developer.android.com/reference/android/view/ViewGroup.LayoutParams#WRAP_CONTENT">WRAP_CONTENT</a>，也就是说子布局想要刚好合适够显示自己就行了；再者就是写死的如100dp等。需要把measure时的mode与LayoutParams结合联系起来，才能更好的理解measure的过程。</p>

<p>还是得从performMeasure这时入手，这个MeasureSpec是由父节点传给子节点，追根溯源，最原始的肯定是传给整个view tree根节点的，也就是调用performMeasure时传入的参数值。</p>

<h4>根节点的MeasureSpec</h4>

<p>根节点的MeasureSpec是由<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/ViewRootImpl.java;l=3624;drc=master;bpv=1;bpt=1?q=viewrootimpl">getRootMeasureSpec</a>得来的，这个方法传入的是窗口的大小，这是由窗口来给出的，当前的窗口肯定 是知道自己的大小的，以及根节点布局中写的大小。从这个方法就能看出前面说的布局中的三种写法对MeasureSpec的影响了：</p>

<ul>
<li>如果 根节点布局是MATCH_PARENT的，那么 mode就是EXACTLY，大小就是父布局的尺寸，因为根节点的父亲就是窗口，所以就是窗口的大小</li>
<li>如果 根节点布局是WRAP_CONTENT的，那么 mode是AT_MOST，大小依然会是父布局的尺寸。这个要这样理解，WRAP_CONTENT是想让子布局自己决定自己多大，但是，你的极限 就是父布局的大小了。</li>
<li>其他，其实就是根节点写死了大小的（写布局时是必须 要指定layout_width和layout_height的，即使某些view可以省略一个，也是因为缺省值，而并非不用指定），那么mode会是EXACTLY，大小用根节点指定的值。</li>
</ul>


<pre><code class="java">    private static int getRootMeasureSpec(int windowSize, int rootDimension) {
        int measureSpec;
        switch (rootDimension) {

        case ViewGroup.LayoutParams.MATCH_PARENT:
            // Window can't resize. Force root view to be windowSize.
            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);
            break;
        case ViewGroup.LayoutParams.WRAP_CONTENT:
            // Window can resize. Set max size for root view.
            measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);
            break;
        default:
            // Window wants to be an exact size. Force root view to be that size.
            measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);
            break;
        }
        return measureSpec;
    }
</code></pre>

<h4>子View的MeasureSpec</h4>

<p>MeasureSpec这个东西是自上而下的，从根节点向子View传递。前面看过了根节点的spec生成方式，还有必要再看一下子View在measure过程中是如何生成spec的，以更好的理解整体过程。主要看<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/ViewGroup.java;l=6979;bpv=0;bpt=1">ViewGroup#getChildMeasureSpec</a>方法就可以了：</p>

<pre><code class="java">    public static int getChildMeasureSpec(int spec, int padding, int childDimension) {
        int specMode = MeasureSpec.getMode(spec);
        int specSize = MeasureSpec.getSize(spec);

        int size = Math.max(0, specSize - padding);

        int resultSize = 0;
        int resultMode = 0;

        switch (specMode) {
        // Parent has imposed an exact size on us
        case MeasureSpec.EXACTLY:
            if (childDimension &gt;= 0) {
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size. So be it.
                resultSize = size;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;

        // Parent has imposed a maximum size on us
        case MeasureSpec.AT_MOST:
            if (childDimension &gt;= 0) {
                // Child wants a specific size... so be it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size, but our size is not fixed.
                // Constrain child to not be bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size. It can't be
                // bigger than us.
                resultSize = size;
                resultMode = MeasureSpec.AT_MOST;
            }
            break;

        // Parent asked to see how big we want to be
        case MeasureSpec.UNSPECIFIED:
            if (childDimension &gt;= 0) {
                // Child wants a specific size... let them have it
                resultSize = childDimension;
                resultMode = MeasureSpec.EXACTLY;
            } else if (childDimension == LayoutParams.MATCH_PARENT) {
                // Child wants to be our size... find out how big it should
                // be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                // Child wants to determine its own size.... find out how
                // big it should be
                resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size;
                resultMode = MeasureSpec.UNSPECIFIED;
            }
            break;
        }
        //noinspection ResourceType
        return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
    }
</code></pre>

<p>单纯从spec角度来理解，与上面的是一样的，基本上WRAP_CONTENT会是AT_MOST，而其他都是EXACTLY。</p>

<p>后面会再详细讨论一下，父布局与子View的相互影响。</p>

<h3>View#measure和View#onMeasure</h3>

<p>performMeasure比较简单，只是调用根节点的measure方法，然后把计算出来的根节点的MeasureSpec传进去，就完事了，所以 重点要<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/View.java;l=25428;drc=master;bpv=0;bpt=1">View#measure</a>方法。这里需要注意的是整个View的设计体系里面一些主要的逻辑流程是不允许子类override的，可定制的部分作被动式的方法嵌入在主要逻辑流程中，如measure是不能被override的，它会调用可以被子类override的<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/View.java;l=25539;drc=master;bpv=1;bpt=1">onMeasure</a>。onMeasure是每个View必须实现的方法，用传入的父布局的约束来计算出自已的大小。</p>

<p>为了优化measure流程，还有一个cache机制，用从父布局传入的MeasureSpec作为key，从onMeasure得出的结果 作为value，保存在cache中，当后面再次调用measure时，如果MeasureSpec未发生变化，那么就直接从cache中取出结果，如果 有变化 那么再调用onMeasure去计算一次。光看View#measure和onMeasure这两个方法也没啥啊，或者说常见的view或者我们自己定义的view的onMeasure方法也没啥啊，都不算太复杂，有同学就会问，这里为啥这么费劲 非要搞出一个cache呢？这个也好理解，要明白任何一个view不光是你自己，还涉及到所有你的子view啊，如果你只是一个未端的view（叶子），那当然 无所谓了，但如果是一个ViewGroup，下面有很多个子view，那么 如果能少调用一次onMeasure，还是能节省不少CPU资源的。</p>

<h3>ViewGroup的onMeasure</h3>

<p>每个View的本身的onMeasure并不复杂，只需要关注好本身的尺寸就好了。</p>

<p>复杂的在于ViewGroup的onMeasure，简单来理解也并不复杂，它除了需要测量自己的宽与高之外，还需要逐个遍历子view以measure子view。如果ViewGroup自身是EACTLY的，那么onMeasure过程就会简单不少，因为它自身的宽与高是确定的，只需要挨个measure子View就可了，而且子View并不影响它本身。当然，要把padding和margin考虑进来。</p>

<p>最为复杂的就是AT_MOST，ViewGroup自身的宽与高是由其所有子View决定的，这才是最复杂的，也是各个ViewGroup子类布局器需要重点解决的，而且过程各不相同，因为每个布局器的特点不一样，所以过程并不相同，下面来各自讨论一下。</p>

<h3>几种常见的ViewGroup的measure逻辑</h3>

<p>下来来看一下一些非常常见的ViewGroup是如何measure的：</p>

<h4>LinearLayout</h4>

<p>它的方向只有两个，可以只分析一个方向，另外一个方向是差不多的，我们就看看measureVertical。</p>

<p>第1种情况，也就是height mode是EXACTLY的时候，这个时候LinearLayout布局本身的高度是已知的，挨个遍历子view然后measure一下就可以。</p>

<p>第2种情况，比较复杂的情况，是AT_MOST时，这其实也还好，理论上高度就是所有子view的高度之和。</p>

<p>对于LinearLayout，最为复杂的情况是处理weight，这需要很多复杂处理，要把剩余所有的空间按weight来分配，具体比较复杂，有兴趣的可以具体去看源码。这也说明了，为何在线性布局中使用weight会影响性能，代码中就可以看出当有weight要处理的时候，至少多遍历一遍子view以进行相关的计算。</p>

<p>虽然方向是VERTICAL时，重点只处理垂直方向，但是width也是需要计算的，但width的处理就要简单得多，如果其是EXACTLY的，那么就已知了；如果是AT_MOST的，就要找子view中width的最大值。</p>

<h4>FrameLayout</h4>

<p>FrameLayout其实是最简单的一个布局管理器，因为它对子view是没有约束的，无论水平方向还是垂直方向，对子view都是没有约束，所以它的measure过程最简单。</p>

<p>如果是EXACTLY的，它本身的高度与宽度是确定的，那么就遍历子view，measure一下就可以了，最后再把margin和padding加一下就完事了。</p>

<p>如果是AT_MOST的，那么也不难，遍历子View并measure，然后取子view中最大宽为它的宽度，取最大的高为其高度，再加上margin和padding，基本上就做完了。</p>

<p>因为，FrameLayout的measure过程最为简单，因此系统里很多地方默认用的就是FrameLayout，比如窗口里的root view。</p>

<h4>RelativeLayout</h4>

<p>这个是最为复杂的，从设计的目的来看，RelativeLayout要解决的问题也是提供了长与宽两个维度来约束子view。</p>

<p>总体过的过程就是要分别从vertical方向和horizontal方向，来进行两遍的measure，同时还要计算具体的坐标，实际上RelativeLayout的measure过程是把measure和layout一起做了。</p>

<h3>自定义View如何实现onMeasure</h3>

<p>如果是一个具体的View，那就相当简单了，默认的实现就可以了。</p>

<p>如果是ViewGroup会相对复杂一些，取决于如何从水平和垂直方向上约束子view，然后进行遍历，并把约束考虑进去。可以参考LinearLayout和RelativeLayout的onMeasure实现。</p>

<h2>渲染之layout</h2>

<p>measure是确定控件的尺寸，下一步就是layout，也就是对控件进行排列。</p>

<p>首先，需要理解现代GUI窗口的坐标系统，假设屏幕高为height，宽为width，那么屏幕左上角为坐标原点（0，0），右下角为（width, height），屏幕从上向下为Y轴方向，从左向右则是X轴方向。安卓当中，也是如此。每一个控件都是一个矩形区域，为了能知道如何渲染每一块矩形（每 一个控件）就需要知道它的坐标，在前一步measure中，能知道它的宽与高，如果再能确定它的起始坐标左上角，那么它在整个屏幕中的位置就可以确定了。</p>

<p>对于Android来说，view的渲染的第二步骤就是layout，其目的就是要确定好它的坐标，每一个View都有四个变量mLeft, mTop，mRight和mBottom，(mLeft, mTop)是它的左上角，(mRight, mBottom）是它的右下角，很明显width=mRight-mLeft，而height=mBottom-mTop。这些数值是相对于父布局来说的，每个View都是存在于view tree之中，知道相对于父布局的数值就足够在渲染时使用了，没必要用相对屏幕的绝对数值，而且用相对父布局的坐标数值再加上父布局的坐标，就可以得到在屏幕上的绝对数值，如果需要这样做的话。</p>

<p><img src="https://developervisits.files.wordpress.com/2017/11/androidscreencoordinates.jpg" alt="" /></p>

<p>layout过程依然是从根节点开始的，所以仍要从ViewRootImpl#performLayout作为起点来理顺layout的逻辑。performLayout的参数是一个LayoutParam，以及一个windowWidth和desiredWindowHeight，调用performLayout是在performTraversal当中，在做完performMeasure时，传入的参数其实就是窗口window的宽与高（因为毕竟是根节点嘛）。performLayout中会从根节点mView开开对整个view tree进行layout，其实就是调用mView.layout，传入的是0, 0和view的经过measure后宽与高。</p>

<p>单个View的layout方法实现较简单，把传入的参数保存到mLeft,mTop,mRight和mBottom变量，再调用onLayout就完事了，这个很好理解，因为子view是由父布局确定好的位置，只要在measure过程把自己需要的大小告诉父布局后，父布局会根据LayoutParam做安排，传给子view的就是计算过后的结果，每个子view记录一下结果就可以了，不需要做啥额外的事情。</p>

<p>ViewGroup稍复杂，因为它要处理其子view，并且要根据其设计的特点对子view进行约束排列。还是可以看看常见的三个ViewGroup是如何做layout的。</p>

<h4>LinearLayout</h4>

<p>依然是两个方向，因为LinearLayout的目的就是在某一个方向上对子view进行约束。看layoutVertical就可以了，水平方向上逻辑是一样的。</p>

<p>遍历一次子View即可，从父布局的left, top起始，考虑子view的height 以及上下的padding和margin，依次排列就可以了。需要注意的是，对于left的处理，理论上子view的left就应该等于父布局，因为这毕竟是vertical的，水平上是没有约束的，但是也要考虑Gravity，当然也要把padding和margin考虑进来。最后通过setChildFrame把排列好的坐标设置给子view。</p>

<p>总体来看，线性布局的layout过程比其measure过程要简单不少。</p>

<h4>FrameLayout</h4>

<p>FrameLayout对子view的排列其实是没有约束的，所以layout过程也不复杂，遍历子view，子view的left和top初始均为父布局，依据其Gravity来做一下排布即可，比如如果Gravity是right，那么子view就要从父布局的右侧开始计算，childRight=parentRight-margin-padding，childLeft=childRight-childWidth，以次类推，还是比较好理解的。</p>

<h4>RelativeLayout</h4>

<p>前面提到过RelativeLayout是在measure的时候就把坐标都计算好了，它的layout就是把坐标设置给子view，其余啥也没有。</p>

<h4>自定义View如何实现onLayout</h4>

<p>如果是自定义View的话，不需要做什么。</p>

<p>如果是自定义的ViewGroup的话，要看设计的目的，是如何排列子view的。</p>

<p>总之，layout过程相较measure过程还是比较好理解的，约束规则越复杂的view，其measure过程越复杂，但layout过程却不复杂。</p>

<h2>渲染之draw</h2>

<p>draw是整个渲染过程的核心也是最复杂的一步，前面的measure和layout只能算作准备，draw才会真正进行绘制。</p>

<h3>draw的整个逻辑流程</h3>

<p>与measure和layout的过程非常不一样，虽然在performTraversals中也会调用performDraw，也就是说看似draw流程的起点仍是ViewRootImpl#performDraw，但查看一下这个方法的实现就可以发现，这里面其实并没有调用到View#draw，就是说它其实也是做一些准备工作，整个View tree的draw触发，并不在这里。</p>

<p>从performDraw中并没有做直接与draw相关的事情，它会调用另外一个方法draw()来做此事情，在draw方法中，它会先计算需要渲染的区域（dirty区域），然后再针对 此区域做渲染，正常情况下会走硬件加速方式去渲染，这部分比较复杂，它直接与一个叫做ThreadedRenderer打交道，稍后再作分析。</p>

<p>由于各种原因，假如硬件加速未没有成功，那么会走到软件渲染，这部分逻辑相对清晰一些，可以先从这里看起，会直接调用到drawSoftware()，这个方法有助于我们看清楚渲染的流程。这个方法里面会创建一个Canvas对象，是由ViewRootImpl持有的一个Surface对象中创建出来的，并调用view tree根节点的mView.draw(canvas)，由此便把流程转移到了view tree上面。</p>

<h3>view tree的draw的过程</h3>

<p>ViewRootImpl是直接调用根节点的draw方法，那么这里便是整个view tree的入口。可先从View#draw(canvas）方法看起。主要分为四步：1）画背景drawBackground；2）画自己的内容通过onDraw来委派，具体的内容是在onDraw里面做的；3）画子view，通过dispatchDraw方法；4）画其他的东西，如scroll bar或者focus highlight等。可以重点关注一下这些操作的顺序，先画背景，然后画自己，然后画子view，最后画scroll bar和focus之类的东西。</p>

<p>重点来看看dispatchDraw方法，因为其他几个都相对非常好理解，这个方法主要要靠ViewGroup来实现，因为在View里面它是空的，节点自己只需要管自己就可以了，只有父节点才需要关注如何画子View。<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/ViewGroup.java;bpv=0;bpt=1">ViewGroup#dispatchDraw</a>这个方法做一些准备工作，如把padding考虑进来并进行clip，后会遍历子View，针对 每个子view调用drawChild方法，这实际上就 是调用回了View#draw(canvas，parent，drawingTime)方法，注意这个方法是package scope的，也就是说只能供view框架内部调用。这个方法并没有做具体的渲染工作（因为每个View的具体渲染都是在onDraw里面做的），这个方法里面做了大量与动画相关的各种变换。</p>

<h3>Canvas对象是从哪里来的</h3>

<p>View的渲染过程其实大都是GUI框架内部的逻辑流程控制，真正涉及graphics方面的具体的图形如何画出来，其实都是由Canvas对象来做的，比如如何画点，如何画线，如何画文字，如何画图片等等。一个Canvas对象从ViewRootImpl传给View tree，就在view tree中一层一层的传递，每个view都把其想要展示的内容渲染到Canvas对象中去。</p>

<p>那么，这个Canvas对象又是从何而来的呢？从view tree的一些方法中可以看到，都是从外面传进来的，view tree的各个方法（draw, dipsatchDraw和drawChild）都只接收Canvas对象，但并不创建它。</p>

<p>从上面的逻辑可以看到Canvas对象有二个来源：一是在ViewRootImpl中创建的，当走软件渲染时，会用Surface创建出一个Canvas对象，然后传给view tree。从ViewRootImpl的代码来看，它本身就会持有一个Surface对象，大概的逻辑就是每一个Window对象内，都会有一个用来渲染的Surface；</p>

<p>另外一个来源就是走硬件加速时，会由hwui创建出Canvas对象。</p>

<h3>draw过程的触发逻辑</h3>

<p>从上面的讨论中可以看出draw的触发逻辑有两条路：</p>

<p>一是，没有启用硬件加速时，走的软件draw流程，也是一条比较好理解的简单流程：performTraversal->performDraw->draw->drawSoftware->View#draw。</p>

<p>二是，启用了硬件加速时，走的是performTraversal->performDraw->draw->ThreadedRenderer#draw，到这里就走进了硬件加速相关的逻辑了。</p>

<h2>硬件加速</h2>

<p>硬件加速是从Android 4.0开始支持的，在此之前都是走的软件渲染，也就是从ViewRoot（4.0版本以前是叫ViewRoot，后来才是ViewRootImpl）中持有的Surface直接创建Canvas，然后传给view tree去做具体的渲染，与前面提到的drawSoftware过程类似。</p>

<p>硬件加速则要复杂得多，多了好多东西，它又搞出了一套渲染架构，但这套东西是直接与GPU联系，有点类似于OpenGL，把view tree的渲染转换成为一系列命令，直接传给GPU，软件渲染则是需要CPU把所有的运算都做了，最终生成graphic buffer送给屏幕（当然也是GPU）。</p>

<p>这一坨东西中最为核心就是RenderNode和RecordingCanvas。其中<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/graphics/java/android/graphics/RenderNode.java">RenderNode</a>是纯新的东西，它是为了构建 一个render tree（类似于view tree），用以构建复杂的渲染逻辑关系。<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/graphics/java/android/graphics/RecordingCanvas.java?q=recordingcanvas">RecordingCanvas</a>是Canvas的一个子类，它是专门用于硬件加速渲染的，但又为了兼容老的Canvas（软件渲染），为啥叫recording呢？因为硬件加速方式渲染，对于view tree的draw过程来说就是记录一系列的操作，这其实就是给GPU的指令，渲染的最后一步就是把整个render tree丢给GPU，就完了。</p>

<p>前面说的两个是数据结构，还不够，还有<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/graphics/java/android/graphics/HardwareRenderer.java">HardwareRenderer</a>和<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/ThreadedRenderer.java?q=threadedrenderer&amp;ss=android%2Fplatform%2Fsuperproject">ThreadedRenderer</a>，这两个用来建立和管理render tree的，也就是说它们内部管理着一组由RenderNode组成的render tree，并且做一些上下文环境的初始化与清理资源的工作。类似于OpenGL中GLSurfaceView的RenderThread做的事情。</p>

<p>硬件加速与原框架的切入点都是RenderNode和RecordingCanvas，View类中多了一个RenderNode成员，当draw的时候，从RenderNode中得到RecordingCanvas，其余操作都与原来一致，都是调用Canvas的方法进行graphics的绘制，这样整体渲染流程就走入到了硬件加速里面。</p>

<h2>Choreographer与vsync</h2>

<p>虽然在Android 4.0版本加入了硬件加速的支持，但这还是不够，因为它只是相当于具体的渲染时间可能快了一些，举例来说，可能是普通火车与高铁之间的差异，虽然确实行程所花时间变短了，但是对于整体的效率来说提升并不大。对于整体GUI的流畅度，响应度，特别是动画这一块的流程程度与其他平台（如水果）差距仍是巨大的。一个最重要的原因就在于，GUI整体的渲染流程是缺少协同的，仍是按需式渲染：应用层布局加载完了要渲染了，或者ViewRootImpl发现dirty了，需要重绘了，或者有用户事件了需要响应了，触发整体渲染流程，更新graphic buffer，屏幕刷新了。</p>

<p>这一过程其实也没有啥大问题，对于常规的UI显示，没有问题，我没有更新，没有变化 ，当然 不需要重绘了，如果有更新有变化时再按需重新渲染，这显然 没有什么问题。最大的问题在于动画，动画是要求连续不停的重绘，如果仅靠客户这一端（相较于graphic buffer和屏幕这一端来说）来触发，显然FPS（帧率）是不够的，由此造成流畅度肯定不够好。</p>

<p>于是在Android 4.1 （Jelly Bean）中就引入了<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/Choreographer.java?q=choreographer">Choreographer</a>以及vsync机制，来解决此问题，它们两个并不全完是一回事，Choreographer是纯软件的，vsync则是更为复杂的更底层的机制，有没有vsync，Choreographer都能很好的工作，只不过有了vsync会更好，就好比硬件加速之于View的渲染，没有硬件加速也可以渲染啊，有了硬件加速渲染会更加的快一些。</p>

<h4>Choreographer</h4>

<p>它的英文本意是歌舞的编舞者，有点类似于导演，但歌舞一般时间更短，所以对编舞者要求更高，需要在短时间内把精华全部展现出来。它的目的就是要协调整个View的渲染过程，对输入事件响应，动画和渲染进行时间上的把控。文档原文是说：Coordinates the timing of animations, input and drawing.，精华就在于timing这个词上。</p>

<p>但其实，这个类本身并不是很复杂，相较于其他frameworks层的东西来说它算简单的了，它就是负责定时回调，按照一定的FPS来给你回调，简单来说它就是做了这么一件事情。它公开的接口也特别少，就是postFrameCallback和removeFrameCallback，而<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/Choreographer.java;bpv=1;bpt=1?q=choreographer">FrameCallback</a>也是一个非常简单的接口doFrame(long frameTimeNanos)，里面的参数是当前帧开始渲染的时间序列。</p>

<p>所以，它的工作就是在计时，或者叫把控时间，到了每一帧该渲染的时候了，它会告诉你。有了它，那么GUI的渲染将不再是按需重绘了，而是有节奏的，可以以固定FPS定时刷新。ViewRootImpl那头也需要做调整，每当有主动重绘时（view tree有变化，用户有输入事件等），也并不是说立马就去做draw，而是往Choreographer里post一个FrameCallback，在里面做具体的draw。</p>

<h4>vsync（Vertical Synchronization）</h4>

<p>垂直同步，是另外一套更为底层的机制，简单来理解就是由屏幕显示系统直接向软件层派发定时的脉冲信号，用以提高整体的渲染流畅程度，屏幕刷新，graphic buffer和window GUI（view tree）三者在这个脉冲信号下，做到同步。</p>

<p><a href="https://source.android.com/devices/graphics/implement-vsync">vsync</a>是通过对Choreographer来发挥作用的。Choreographer有两套timing机制，一是靠它自己实现的一套，另外就是直接传导vsync的信号。通过<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/DisplayEventReceiver.java;bpv=1;bpt=1">DisplayEventReceiver</a>（这个类对于App层是完全不可见的被hide了）就可以接收到vsync的信号了，调用其sheduleVsync来告诉vsync说我想接收下一次同步的信号，然后在重载onVsync方法以接收信号，就能够与vsync系统连接起来了。</p>

<h2>渲染性能优化</h2>

<p>这是一个很大的话题</p>

<h4>保持简单</h4>

<p>最最重要的原则就是要保持简单，比如，UI页面尽可能的简洁，view tree的层级要尽可能的少，能用颜色就别用背景图片，能merge就merge。</p>

<p>动画也要尽可能的简单，并且使用标准的ValueAnimator接口，而不要简单粗暴的去修改LayoutParams（如height和width）。</p>

<h4>减少重绘</h4>

<p>这个要多用系统中开发者模式里面的重绘调试工具来做优化，尽可能的减少重绘。</p>

<h4>专项定制</h4>

<p>有些时候，对于一些特殊需求的view要进行定制优化。举个例子，比如一个巨复杂的页面（如某宝的首页），中有一个用于显示倒计时的view，实现起来并不复杂，一个TextView就搞定了，一个Timer来倒计时，不断的刷新数字 就可以了。但是，这通常会导致整个页面都跟着在重绘。因为数字在变化，会导致TextView的大小在变化，进而导致整个View tree都在不断的跟着重绘。</p>

<p>像这种case，如果遇到了，就需要自定义一个专门用于此的View，并针对数字不断刷新做专门的优化，以不让其影响整个view tree。</p>

<p>不要在意这个例子的真实性，要知道，当某个View演变成了整个页面的瓶颈的时候，就需要专门针对 其进行特殊定制以优化整体页面的渲染性能。</p>

<p>更多的技巧可以参考<a href="http://toughcoder.net/blog/2015/09/11/android-performance-profiling-made-easy/">这篇文章</a>和后面的参考资料。</p>

<h2>参考资料</h2>

<p>列举一下关于此话题的比较好的其他资源</p>

<ul>
<li><a href="https://blog.csdn.net/guolin_blog/article/details/16330267">Android视图绘制流程完全解析，带你一步步深入了解View</a></li>
<li><a href="https://www.jianshu.com/p/9ac245657127">Android性能优化第（四）篇&mdash;Android渲染机制
</a></li>
<li><a href="https://www.jianshu.com/p/1ef2a9e5aa91">深入Android渲染机制</a></li>
<li><a href="https://blog.csdn.net/CrazyMo_/article/details/80038948">Android进阶——性能优化之布局渲染原理和底层机制机详解及卡顿根源探究（四）</a></li>
<li><a href="https://blog.csdn.net/say_from_wen/article/details/79093883">View渲染机制</a></li>
<li><a href="https://blog.csdn.net/hfy8971613/article/details/108041504">Android屏幕刷新机制</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
