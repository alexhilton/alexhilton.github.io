<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2024-08-30T22:44:08+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『履霜冰至』| Phases]]></title>
    <link href="http://toughcoder.net/blog/2024/08/30/jetpack-compose-phases/"/>
    <updated>2024-08-30T08:02:41+08:00</updated>
    <id>http://toughcoder.net/blog/2024/08/30/jetpack-compose-phases</id>
    <content type="html"><![CDATA[<blockquote><p>这篇文章译自<a href="https://developer.android.com/develop/ui/compose/phases">Jetpack Compose phases</a></p></blockquote>

<p>就像大多数其他的UI工具集一样，Compose渲染一帧也要经过几个不同的阶段。就比如说Android view系统，主要有三个阶段：测量（measure），版面编排（layout）和绘制（drawing）。Compose也非常的类似，但有一个特别重要的额外的阶段起始时的组合（composition）阶段。</p>

<p><a href=""><img src="https://pbs.twimg.com/media/F3l9aWwWUAEDYxS.jpg:large" title="auto auto" ></a></p>

<!-- more -->


<p>组合在我们前面的文章中有详细的描述，包括<a href="https://juejin.cn/post/7379437165486112805">降Compose十八掌之『潜龙勿用』| Thinking in Compose</a>和<a href="https://juejin.cn/post/7376094685495001139">降Compose十八掌之『鸿渐于陆』| State</a>。</p>

<h2>每一帧的三个阶段</h2>

<p>Compose有三个主要的阶段：</p>

<ol>
<li>组合（Composition）：要显示什么。Compose运行composable函数并创建UI的一个描述。</li>
<li>版面编排（Layout）：在哪里显示。这个阶段包含两个步骤：测量（measurement）和放置（placement）。给布局树中的每个节点，在二维坐标中，布置元素的测量然后放置它们和它们的子元素。</li>
<li>绘制（Drawing）：如何渲染。把UI元素绘制进一个Canvas，也就是设备的屏幕上。</li>
</ol>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/compose-phases.png" alt="three_phases" /></p>

<blockquote><p>图1. Compose把数据转化为UI的三个阶段</p></blockquote>

<p>这三个阶段的执行顺序是相同的，能够让数据从组合到版面编排再到绘制沿着一个方向流动，以生成一帧（也就是<a href="https://developer.android.com/develop/ui/compose/architecture#udf">「单向数据流」</a>）。需要特别注意的例外是<a href="https://developer.android.com/develop/ui/compose/layouts/basics#constraints">BoxWithConstraints</a>，<a href="https://developer.android.com/develop/ui/compose/lists#lazy">LazyColumn</a>和<a href="https://developer.android.com/develop/ui/compose/lists#lazy">LazyRow</a>，它们子节点的组合依赖于父节点的排版阶段。</p>

<p>可以假定每一帧都会这三个阶段，但是基于性能的考量，在所有的阶段里，Compose会避免相同输入时计算结果相同的重复工作。如果一个composable函数能复用前一次的结果，Compose会跳过它的执行，并且如果没有必要，Compose UI并不会重新排版或者重新绘制整个UI树。Compose仅会做更新UI所必要的最少工作。因为Compose会在不同的阶段追踪状态读取，所以这种优化是可行的。</p>

<h3>理解不同的阶段</h3>

<p>这部分将详细的描述composables的三个渲染阶段是如何进行的。</p>

<h4>组合（Composition）</h4>

<p>在组合阶段，Compose运行时会执行composable函数然后输出一个能代表UI的树形结构。这个树形结构由包含着下一阶段所需要的信息的布局节点组成，如下面这个视频所示：</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/composition-ezgif.gif" alt="" /></p>

<blockquote><p>图2. 在组合阶段创建的代表着你的UI的树形结构。</p></blockquote>

<p>一小段代码和其树形会如下所示：</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/code-subsection.png" alt="ui_tree_vs_code" /></p>

<blockquote><p>图3. UI树的一部分与其对应的代码。</p></blockquote>

<p>在这些例子中，代码中的每个composable函数映射为一UI树中的一个布局节点。在更复杂的例子中，composables可包含逻辑和控制流程，在不同的状态下生成不同的树。</p>

<h4>排版（Layout）</h4>

<p>在排版阶段，Compose使用组合阶段生成的UI树作为输入。布局节点的集合包含了需要确定2D空间下每个节点大小和位置的所有需要的信息。</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/layout-ezgif.gif" alt="" /></p>

<blockquote><p>图4. 在排版阶段UI树中每个布局节点的测量和放置。</p></blockquote>

<p>在排版阶段，树用下面三步算法进行遍历：</p>

<ol>
<li>测量子节点：节点会测量其存在的子节点。</li>
<li>决定自身大小：基于前面的测量，一个节点能决定它自身的大小。</li>
<li>放置子节点：每个子节点以节点为参考进行放置。</li>
</ol>


<p>在这个阶段的最后，每个布局节点都有：</p>

<ul>
<li>一个确定的宽度（width）和高度（height）</li>
<li>一个绘制的位置坐标x，y</li>
</ul>


<p>对于前一部分提到的UI树：</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/code-subsection.png" alt="" /></p>

<p>对于这颗树，算法是这样工作的：</p>

<ol>
<li>Row测量它的子节点：Image和Column。</li>
<li>Image测量过后。因为它没有子节点，所它决定自己的大小并把其大小报告给Row。</li>
<li>接下来测量Column。它先测量它的两个子节点（两个Text函数）。</li>
<li>第一个Text被测量。它没有子节点，所以决定自己大小并告诉给Column

<ol type="a">
<li>第二个Text被测量。它也没有子节点，所以决定自己大小后告诉给Column。</li>
</ol>
</li>
<li>Column使用子节点的测量结果决定自己的大小。它用子节点的最大宽度（作为宽度）和高度之和（作为高度）。</li>
<li>Column相对于自己来放置子节点，把它们垂直地放在下面。</li>
<li>Row使用子节点的测量结果来决定自身大小。它使用子节点的最大高度作为高度，子节点宽度之和作为宽度。然后旋转子节点。</li>
</ol>


<p>注意每个节点仅访问一次。测量和放置所有节点时，Compose运行时仅需要访问一次UI树，这样做能提升性能。当树中的节点数量增加时，遍历所需要的时间仅线性增长。相反，如果每个节点访问多次，遍历时间将呈指数增长。</p>

<h4>绘制（Drawing）</h4>

<p>在绘制阶段，将从上到下的再次遍历树，每个节点依次的在屏幕上绘制其自身。</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/drawing-ezgif.gif" alt="" /></p>

<blockquote><p>图5. 绘制阶段在屏幕上绘制像素点。</p></blockquote>

<p>继续前面的例子，以如下方式绘制出树的内容：</p>

<ol>
<li>Row绘制它有的所有内容，如背景。</li>
<li>Image绘制它自己。</li>
<li>Column绘制它自己。</li>
<li>第一个和第二个Text各自绘制它们自己。</li>
</ol>


<p><img src="file:///Users/alexhilton/Downloads/compose_libs/drawing-ui-tree-ezgif.gif" alt="" /></p>

<blockquote><p>图6. UI树和它的渲染展示。</p></blockquote>

<h2>状态读取</h2>

<p>当你在上面列出的一个阶段中读取状态的值时，Compose会自动追踪值被读取时它在做的事情。这种追踪允许Compose在状态发生变化时重新执行读取者，这是Compose中状态的可观测性的基础。</p>

<p>状态通常都是由mutableStateOf来创建的然后通过两种方式访问：直接读取其属性value或者通过Kotlin的属性委托。可以在文章<a href="https://juejin.cn/post/7376094685495001139">降Compose十八掌之『鸿渐于陆』| State</a>中了解更多的细节。在本文中，「状态读取」通指两种方法中的任意一种。</p>

<pre><code class="Kotlin">// 直接读取状态的value
val paddingState: MutableState&lt;Dp&gt; = remember { mutableStateOf(8.dp) }
Text(
    text = "Hello",
    modifier = Modifier.padding(paddingState.value)
)
</code></pre>

<pre><code class="Kotlin">// 通过属性委托来读取
var padding: Dp by remember { mutableStateOf(8.dp) }
Text(
    text = "Hello",
    modifier = Modifier.padding(padding)
)
</code></pre>

<p>属性委托的背后，「getter」和「setter」函数用来访问和更新状态的value。这些getter和setter函数仅当你把属性当作一个值来引用时才会被调用，而不是委托被创建时，所以这就是上面两种方式是等价的原因。</p>

<p>当一个被读取状态发生变化时都会被重新执行的每一个代码块都是一个重启作用域（restart scope）。在不同的阶段，Compose会追踪状态值的变化然后重启作用域。</p>

<h2>分阶段的状态读取</h2>

<p>如上面所提及，Compose中有三个主要的阶段，在每个阶段中，Compose会追踪哪些状态被读取了。这让Compose能够仅通知针对UI中受影响的元素需要采取措施的特定阶段。</p>

<blockquote><p>注意：状态实例被创建和存储的地方对阶段几乎无影响，只有状态被读取的时间和地点才有重要影响。</p></blockquote>

<p>我们来仔细检查每一个阶段，然后描述一下在其中当状态被读取时所发生的事情。</p>

<h3>阶段一：组合</h3>

<p>在一个&#64;Composable标注的函数里或者lambda代码块里读取状态会影响组合和后续阶段。当状态值发生变化，重组器（recomposer）会安排所有读取状态的composable函数的重新运行。注意如果函数的输入没有变化，运行时可能会跳过一些甚至所有的composable函数。想了解更多可以看文章<a href="https://juejin.cn/post/7401358349877346338">降Compose十八掌之『损则有孚』| Lifecycle</a>。</p>

<p>取决于组合的结果，Compose UI在执行排版和绘制阶段，如果内容始终相同和大小以及布局未发生变化，它也许会跳过这些阶段。</p>

<pre><code class="Kotlin">var padding by remember { mutableStateOf(8.dp) }
Text(
    text = "Hello",
    // 当对象Modifier被构建时，状态`paddin`在组合阶段读取。
    // 状态`padding`的变化会触发重组
    modifier = Modifier.padding(padding)
)
</code></pre>

<h3>阶段二：排版</h3>

<p>排版阶段由两个步骤组成：测量和放置。测量步骤运行传递给composable函数的测量lambda，也即诸如接口LayoutModifier的MeasureScope.measure方法等的代码。放置步骤运行layout函数的放置代码块，也即诸如Modifier.offset {&hellip;}的代码块。</p>

<p>这些步骤中的状态读取影响排版编排和后续的绘制阶段。当状态值发生变化，Compose UI会安排排版阶段。如果大小和位置发生变化，它也会执行绘制阶段。</p>

<p>更准确的说，测量步骤和放置步骤有不同的重启作用域（restart scope），也就是说放置步骤中的状态读取不会重新触发它前面测量步骤。然而，这些步骤经常绞在一起，所以放置步骤中的状态读取可能会影响属于测量步骤中的其他重启作用域。</p>

<pre><code class="Kotlin">var offsetX by remember { mutableStateOf(8.dp) }
Text(
    text = "Hello",
    modifier = Modifier.offset {
        // 当offset被计算时，状态`offsetX`在排版阶段中的放置步骤读取
        // `offsetX`的变化会重启排版
        IntOffset(offsetX.roundToPx(), 0)
    }
)
</code></pre>

<h3>阶段三：绘制</h3>

<p>绘制过程中的状态读取影响绘制阶段。常见的例子包括Canvas()，Modifier.drawBehind和Modifer.drawWithContent函数。当状态值发生变化，Compose UI仅执行绘制阶段。</p>

<pre><code class="Kotlin">var color by remember { mutableStateOf(Color.Red) }
Canvas(modifier = modifier) {
    // 当canvas被渲染时，状态`color`在绘制阶段读取
    // 状态`color`变化重启绘制
    drawRect(color)
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/phases-state-read-draw.svg" alt="phase_state_read_draw" /></p>

<h2>优化状态读取</h2>

<p>因为Compose进行本地化的状态读取追踪，我们可以通过在合适的阶段读取状态以最小化渲染工作量。</p>

<p>我们来看一下下面的例子。这里有一个Image，使用了offset modifier来作为最终布局位置的偏移，实现一个用户滑动时的平行视觉差的效果：</p>

<pre><code class="Kotlin">Box {
    val listState = rememberLazyListState()

    Image(
        // ...
        // 这不是一个最优的实现方式
        Modifier.offset(
            with(LocalDensity.current) {
                // 在组合中读取状态firstVisibleItemScrollOffset
                (listState.firstVisibleItemScrollOffset / 2).toDp()
            }
        )
    )

    LazyColumn(state = listState) {
        // ...
    }
}
</code></pre>

<p>这个代码能行，但性能并不是最优的。上面的代码读取状态firstVisibleItemScrollOffset然后把它传给函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary#(androidx.compose.ui.Modifier">Modifier.offset</a>.offset(androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp))。当用户滑动时firstVisibleItemScrollOffset的值会变化。我们知道，Compose会追踪任何状态读取以便它能重新执行进行读取的代码，也即例子中函数Box中的内容。</p>

<p>这是一个在组合阶段读取状态的例子。这也并不是一无事处，因为这是重组的基础，让数据变化刷新UI。</p>

<p>但这个例子不是最优做法，因为每次滚动都会导致整个composable函数被重新运行，也会重新测量，重新排版，然后最终重新绘制。尽管要显示的内容并没有真正变化，仅是要显示的位置在变化，但我们每个滚动都会触发Compose的所有阶段。我们可以优化状态读取以仅触发排版阶段。</p>

<p>有offset modifier另外一个版本：<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary#(androidx.compose.ui.Modifier">Modifier.offset(offset: Density.()-> IntOffset)</a>.offset(kotlin.Function1))。这个函数接收一个lambda作为参数，lambda代码块的返回结果作为最终的偏移量。我们来改一下前面的例子：</p>

<pre><code class="Kotlin">Box {
    val listState = rememberLazyListState()

    Image(
        // ...
        Modifier.offset {
            // 在排版阶段读取状态firstVisibleItemScrollOffset
            IntOffset(x = 0, y = listState.firstVisibleItemScrollOffset / 2)
        }
    )

    LazyColumn(state = listState) {
        // ...
    }
}
</code></pre>

<p>为何这样就性能更优呢？我们提供给modifier的lambda代码块仅在排版阶段调用（具体来说是在排版阶段中的放置步骤），也就是说在组合阶段状态firstVisibleItemScrollOffset不用再被读取了。因为Compose追踪状态什么时候被读取，这次改动意味着如果状态firstVisibleItemScrollOffset值发生变化，Compose仅会重启排版和绘制阶段。</p>

<blockquote><p><strong>注意：</strong> 你也许很好奇接收一个lambda作为参数与接收一个普通值参数相比是否有额外的开销。确实有。然而，在这个场景中，限制状态读取到排版阶段带来的收益要超过参数的开销。在滑动中firstVisibleItemScrollOffset的值每一帧都会发生变化，把状态读取延迟到排版阶段，能避免很多次重组。</p></blockquote>

<p>虽然这个例子靠有不同的offset modifiers可以用来优化最终代码，但思路是通用的：尽可能把状态读取限制到最少的阶段中，让Compose做最少量的渲染工作。</p>

<p>当然了，在组合阶段也常常绝对有必要读取状态。尽管如此，通过过滤状态变化，还是有可以最小化重组发生的场景。想要了解更多的这方面信息，可以读文章<a href="https://juejin.cn/post/7405158681078104127">降Compose十八掌之『龙战于野』| Side Effects</a>。</p>

<h2>重组循环（循环阶段依赖）</h2>

<p>早些时候我们提到过Compose的阶段总会以相同的顺序被调用，并且在一帧中是没有办法往回走的。然而，不同帧之间组合循环依然会发生。看这个例子：</p>

<pre><code class="Kotlin">Box {
    var imageHeightPx by remember { mutableStateOf(0) }

    Image(
        painter = painterResource(R.drawable.rectangle),
        contentDescription = "I'm above the text",
        modifier = Modifier
            .fillMaxWidth()
            .onSizeChanged { size -&gt;
                // 不要这样做
                imageHeightPx = size.height
            }
    )

    Text(
        text = "I'm below the image",
        modifier = Modifier.padding(
            top = with(LocalDensity.current) { imageHeightPx.toDp() }
        )
    )
}
</code></pre>

<p>这里我们（以不好的方式）实现了一个垂直的列，图片在上面文字在其下面。使用Modifier.onSizeChanged感知图片的实际尺寸，然后通过Modifier.padding作用于文字以让其向下偏移。从Px到Dp的不自然转换已经表明了这段代码有问题。</p>

<p>这个例子的问题在于无法通过一帧就达到最终的排列布局。代码依赖于多帧的绘制，进行了不必要的工作，导致UI会在屏幕上跳跃。</p>

<p>让我们一帧帧的检查来看发生了什么：</p>

<p>在第1帧的组合阶段，imageHeightPx值为0，文字拿到的是Modifier.padding(top = 0)。然后，到了排版阶段，modifier的onSizeChanged回调会被调用。这时imageHeightPx会被更新成为图片的实际高度。Compose为下一帧安排重组。在绘制阶段，文字使用padding 0来渲染，因为这时状态的值还没有被更新。</p>

<p>然后Compose会启动因imageHeightPx的值变化而安排的第2帧渲染。状态是在Box内容代码块中读取，并且是在组合阶段调用的。这回，给到Text的padding是真实的图片的高度。在排版阶段，代码再次修改了imageHeightPx的值，但因为值没有发生变化，所以不会安排重组。</p>

<p>最终，我们得到的text的期望的padding，但是耗费额外的一帧来传递padding值到不同的阶段并不是最优的做法，这会导致带有重叠内容的一帧。</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/phases-recomp-loop.svg" alt="" /></p>

<p>这个例子也许显得有点做作，但要小心这种通用的模式：</p>

<ul>
<li>Modifier.onSizeChanged，onGloballyPositioned，或者一些其他的排版操作</li>
<li>更新一些状态</li>
<li>把状态当作排版modifier（padding(), height()或者类似的）的输入</li>
<li>潜在的重复</li>
</ul>


<p>上面示例的修复办法是使用合适的排版原语。上面例子可以用一个普通的Column()来实现，但你也许会有需要一些定制的更复杂的场景，这些场景可能需要写一些定制化的布局。可以看<a href="https://developer.android.com/develop/ui/compose/layouts/custom">定制布局</a>文档以了解更多。</p>

<p>这里通用的原则是对于需要相互之间测量和旋转的多个UI元素要保持单一数据来源。使用合适的排版原语或者创建一个定制化的布局就意味着最少化的共享父节点可以当作可以协调多个元素之间关联的单一数据源。而引入动态的状态会打破这一原则。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『龙战于野』| Side Effects]]></title>
    <link href="http://toughcoder.net/blog/2024/08/23/jetpack-compose-side-effects/"/>
    <updated>2024-08-23T07:56:53+08:00</updated>
    <id>http://toughcoder.net/blog/2024/08/23/jetpack-compose-side-effects</id>
    <content type="html"><![CDATA[<blockquote><p>主要翻译自官方文档<a href="https://developer.android.com/develop/ui/compose/side-effects">Side-effects in Compose</a>，并不是直译，有些细微调整。</p></blockquote>

<p>一个<strong>副作用</strong>是指发生在composable函数范围之外的应用状态的一个变化。由于composable函数的生命周期和诸如不可预测的重组，以不同的顺序执行composable的重组，或者重组可能会被跳过等性质，理论上composable应该<a href="https://juejin.cn/post/7379437165486112805">要是无副作用</a>的。</p>

<p><a href=""><img src="https://ac.appcircle.io/wp-content/uploads/2022/10/compose-side-effects-state.png" title="auto auto" ></a></p>

<!-- more -->


<p>然而，有些时候副作用是必要的，例如，触发一些诸如显示一个非干扰性提示（snackbar）或者在一定状态条件下跳转到另一个页面，等的一次性的事件时。这些行为应该在一个能够感知composable生命周期的可控的环境中调用。在本文中，你将学习Jetpack Compose提供的几种不同的副作用函数（side effect APIs）。</p>

<h2>副作用的具体使用场景</h2>

<p>如在文章<a href="https://juejin.cn/post/7379437165486112805">降Compose十八掌之『潜龙勿用』| Thinking in Compose</a>中提到的，composables应该尽可能的做到无副作用。当需要对应用状态进行修改时，应该使用副作用API，以便副作用函数以可预测的方式运行。</p>

<blockquote><p><strong>关键点：</strong> 一个作用（effect）是指一个composable函数不会生成UI元素，而是当组合完成时生成副作用。</p></blockquote>

<p>由于Compose中有多种作用，很容易被滥用。要确保在副作用中做的事情是UI相关的并且没有违反『单一数据流原则』。</p>

<blockquote><p><strong>注意：</strong> 一个可响应的UI应该是异步的，Jetpack Compose解决异步的办法是在API级别结合协程而不是使用回调。想要了解更多的协程知识，可以参看<a href="https://juejin.cn/post/7329767824200826918">之前的文章</a>。</p></blockquote>

<h3>LaunchedEffect：在composable的作用域内运行挂起函数</h3>

<p>想要在一个composable的生命周期中执行操作并且需要调用挂起函数，就可以使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#LaunchedEffect(kotlin.Any,kotlin.coroutines.SuspendFunction1">LaunchedEffect</a>)。当LaunchedEffect进入组合时，它会使用作为参数传入的代码块来启动一个协程。如果LaucnhedEffect离开了组合协程会被取消。如果因不同的key LaunchedEffect被重组了（副作用的重启机制会在后面进行讲解），运行中的协程会被取消掉，一个新的协程会被启动以运行新的挂起函数。</p>

<p>例如，一个可调节延迟的脉冲式透明度的动画：</p>

<pre><code class="Kotlin">// 变化的速率可以调节，可以加快动画（减少间隔）
var pulseRateMs by remember { mutableStateOf(3000L) }
val alpha = remember { Animatable(1f) }
LaunchedEffect(pulseRateMs) { // 速度作为key，这样速度变化时，会重启副作用，动画也会重启
    while (isActive) {
        delay(pulseRateMs) // 一定间隔之后显示脉冲动画
        alpha.animateTo(0f)
        alpha.animateTo(1f)
    }
}
</code></pre>

<p>在上面的代码中，动画使用了挂起函数<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html">delay</a>来等待一定的时间。然后，它依次使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Animatable#animateTo(kotlin.Any,androidx.compose.animation.core.AnimationSpec,kotlin.Any,kotlin.Function1">animateTo</a>)展现动画到不可见，再到可见。并在composable的生命周期中不断重复。</p>

<h3>rememberCoroutineScope：获取一个可以在composable之外启动协程的可感知组合的协程作用域</h3>

<p>因为LaunchedEffect是一个composable函数，所以它只能在其他composable函数中调用。如果想要在composable作用域之外启动协程，但又希望限制协程在一定的范围内，以便能在离开组合时协程自动被取消，可以使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#rememberCoroutineScope(kotlin.Function0">rememberCoroutineScope</a>)。在任何需要手动操控一个或者多个协程的生命周期的时候都应该使用rememberCorountineScope，比如说当用户事件发生时需要取消动画。</p>

<p>rememberCoroutineScope是一个composable函数，返回一个协程作用域（CoroutineScope），这个作用域会被绑定到经组合中它被调用的地点。当离开组合时，这个协程作用域会被取消。</p>

<blockquote><p><strong>译注：</strong> 如果对协程作用域不太熟悉的同学，可以参看<a href="https://juejin.cn/post/7324351711660048411">之前的文章</a>。</p></blockquote>

<p>例如，可以用下面的代码，当点击按扭时显示一个Snackbar（译注：非干扰式提示，类似于Toast）：</p>

<pre><code class="Kotlin">@Composable
fun MoviesScreen(snackbarHostState: SnackbarHostState) {

    // 创建一个绑定到MoviesScreen生命周期的协程作用域
    val scope = rememberCoroutineScope()

    Scaffold(
        snackbarHost = {
            SnackbarHost(hostState = snackbarHostState)
        }
    ) { contentPadding -&gt;
        Column(Modifier.padding(contentPadding)) {
            Button(
                onClick = {
                    // 在作用域中创建一个协程来显示提示。
                    scope.launch {
                        snackbarHostState.showSnackbar("Something happened!")
                    }
                }
            ) {
                Text("Press me")
            }
        }
    }
}
</code></pre>

<h3>rememberUpdateState：指向即使值发生变化也不会重启的作用中的一个值</h3>

<p>当参数key中的任何一个发生变化时LaunchedEffect就会重启。然而，在有些情况下我们希望捕获这样作用中的一个值，这个作用不会随着值变化而重启。为了达到这样的效果，需要使用rememberUpdatedState创建一个能被捕获和更新的值的引用。这个方式对于那些含有长时间运行，且重新创建或者重启都非常昂贵之类的操作的副作用是很有用的。</p>

<p>例如，假设你的应用有一个一段时间内消失的加载页面（LandingScreen）。即使这个加载页面被重组了，等待时间副作用和通知已过去了多少时间副作用都不应该被重新启动：</p>

<pre><code class="Kotlin">@Composable
fun LandingScreen(onTimeout: () -&gt; Unit) {

    // 这个状态永远指向LandingScreen重组后最新的onTimeout函数
    val currentOnTimeout by rememberUpdatedState(onTimeout)

    // 创建一个与LandingScreen生命周期一致的副作用。即使LandingScreen被重组了，这里的延迟不应该重新开始.
    LaunchedEffect(true) {
        delay(SplashWaitTimeMillis)
        currentOnTimeout()
    }

    /* 加载页面的内容 */
}
</code></pre>

<p>想要创建一个与调用点生命周期一至的副作用，可以把像Unit或者true等永不会改变的常量当作参数。在上面的例子中，使用了LaunchedEffect(true)。为了保证lambda onTimeout中总是包含LandingScreen被重组后的最新值，onTimeout需要使用rememberUpdatedState来包装。返回值，就是代码中的currentOnTimeout应该在副作用中使用。</p>

<blockquote><p><strong>注意：</strong> LaunchedEffect(true)就像while(true)一样诡异。即使有具体的使用场景，也要三思后行，确保确实需要这样做。</p></blockquote>

<h3>DisposableEffect：需要清理工作的副作用</h3>

<p>对于当离开组合或者key发生变化时需要清朝工作的副作用，使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#DisposableEffect(kotlin.Any,kotlin.Function1">DisposableEffect</a>)。如果DisposableEffect的key发生变化，调用的composable需要进行清理副作用，并且重新调用。</p>

<p>作为一个示例，通过使用<a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleObserver">LifecycleObserver</a>，你也许想要发送基于平台生命周期事件（Lifecycle events）统计事件数据（译注：这里的生命周期是指Android平台组件的生命周期）。想要在Compose中监听这些事件，使用一个DisposableEffect来在需要时注册和反注册观察者：</p>

<pre><code class="Kotlin">@Composable
fun HomeScreen(
    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,
    onStart: () -&gt; Unit, // 发送'started' 事件
    onStop: () -&gt; Unit // 发磅 'stopped' 事件
) {
    // 保证当前的lambda是最新的
    val currentOnStart by rememberUpdatedState(onStart)
    val currentOnStop by rememberUpdatedState(onStop)

    // 如果 `lifecycleOwner` 发生变化，清理并重置副作用函数
    DisposableEffect(lifecycleOwner) {
        // 创建一个观察者以触发我们的事件发送回调lambda
        val observer = LifecycleEventObserver { _, event -&gt;
            if (event == Lifecycle.Event.ON_START) {
                currentOnStart()
            } else if (event == Lifecycle.Event.ON_STOP) {
                currentOnStop()
            }
        }

        // 把观察者添加到生命周期观察者列表里
        lifecycleOwner.lifecycle.addObserver(observer)

        // 当离开组合时，进行清理工作，即把观察者从其列表中移除
        onDispose {
            lifecycleOwner.lifecycle.removeObserver(observer)
        }
    }

    /* Home screen content */
}
</code></pre>

<p>在上面的代码中，副作用会添加一个观察者observer到lifecycleOwner上。如果lifecycleOwner有变动，副作用函数会被清理并且使用新的lifecycleOwner重启。</p>

<p>一个DispoableEffect必须要包含一个onDispose语句作为其代码块的最后一个语句。否则会有编译错误。</p>

<blockquote><p><strong>注意：</strong> 使用一个空的onDispose并不是一个好的做法。要多思考一下是否有更加符合使用场景的副作用函数。</p></blockquote>

<h3>SideEffect：向非Comopse代码发布Compose的状态</h3>

<p>要与非Compose管理的对象共享Compose状态时，使用composable <a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#SideEffect(kotlin.Function0">SideEffect</a>)。使用SideEffect能够保证副作用在每次成功重组后都能得到执行。另一方面，在一个重组保证成功之前执行一个副作用是不正确的，这种场景就会直接在composable中写入副作用。</p>

<p>例如，你的分析库也许允许你通过给后面的统计数据添加自定义的meta data（在此例中是『user properties』）的方式来给用户数据分段。为了建立当前用户的用户类型与统计库之间的联系，可以使用SideEffect来更新此值：</p>

<pre><code class="Kotlin">@Composable
fun rememberFirebaseAnalytics(user: User): FirebaseAnalytics {
    val analytics: FirebaseAnalytics = remember {
        FirebaseAnalytics()
    }

    // 每次成功组合，用当前用户的用户类型来更新 FirebaseAnalytics，保证
    // 后面的统计事件能带上userType
    SideEffect {
        analytics.setUserProperty("userType", user.userType)
    }
    return analytics
}
</code></pre>

<h3>produceState：把非Compose状态转化为Compose状态</h3>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#produceState(kotlin.Any,kotlin.coroutines.SuspendFunction1">produceState</a>)启动一个受组合管控的协程作用域，其中可以把值转化为状态。用它可以把非Compose状态转化为Compose状态，例如把外部由订阅驱动 的值如Flow，LiveData或者RxJava转化到组合中。</p>

<p>当produceState进入组合时生产者就会被启动，然后当离开组合时被取消。返回的状态会合并：就是说相同的值不会再次触发重组。</p>

<p>尽管produceState会创建协程，它也能用来监听非挂起数据。想要移除对数据的订阅，使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/ProduceStateScope#awaitDispose(kotlin.Function0">awaitDispose</a>)函数。</p>

<p>下面的例子展示如何使用produceState来从网络加载图片。Composable函数loadNextworkImage返回一个可以用在其他composables中的状态：</p>

<pre><code class="Kotlin">@Composable
fun loadNetworkImage(
    url: String,
    imageRepository: ImageRepository = ImageRepository()
): State&lt;Result&lt;Image&gt;&gt; {

    // 用 Result.Loading 作为初值，创建一个状态 State&lt;T&gt;
    // 如果 「url」或者「imageRepository」任何一个发生变化，运行中的生产者会被取消
    // 使用新的输入被重启。
    return produceState&lt;Result&lt;Image&gt;&gt;(initialValue = Result.Loading, url, imageRepository) {

        // 在协程里，可以调用挂起函数
        val image = imageRepository.load(url)

        // 使用成功或者失败作为结果 来更新状态
        // 这会触发读取此状态的composable的重组
        value = if (image == null) {
            Result.Error
        } else {
            Result.Success(image)
        }
    }
}
</code></pre>

<blockquote><p><strong>注意：</strong> 带有返回值的composable函数应该以常规的Kotlin函数命名规范进行命名，以小写字符开头的驼峰式。</p></blockquote>

<p><br/></p>

<blockquote><p><strong>关键点：</strong> 进一步的了解，produceState使用了其他的副作用函数！它使用remember { mutableStateOf(initialValue) }来持有返回结果，然后在一个LaunchedEffect中触发生产者代码块。每当生产者代码块中更新了value的值，相应的状态也会被更新。
开发者也可以基于现有的API来创造想要的副作用函数</p></blockquote>

<h3>derivedStateOf：把一个或者多个状态对象转化为另一个状态</h3>

<p>在Compose中，每次当被观察的状态对象发生变化或者composable的输入有变化时重组就会发生。状态对象或者输入可能变化次数的超过了UI实际的需要，导致了不必要的重组。</p>

<p>当一个composable的输入变化超过了重组所需要时就应该使用函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#derivedStateOf(kotlin.Function0">deriveStateOf</a>)。比较觉的场景是当有些变量频繁的变动，比如滚动位置，但composable仅需要变动超过一定阈值时才需要对其响应。derivedStateOf创建一个新的仅在需要时更新的可观察Compose状态。这样，它就类似于Kotlin Flow中的操作符<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/distinct-until-changed.html">distinctUntilChanged</a>。</p>

<blockquote><p><strong>注意：</strong> derivedStateOf是比较昂贵的（也即性能开销比较大），应该仅用来减少结果未变化时的不必要的重组。</p></blockquote>

<h4>正确的使用</h4>

<p>下面的代码片段展示一个恰当的使用derivedStateOf的场景：</p>

<pre><code class="Kotlin">@Composable
// 当参数 messages 变化时, MessageList会被重组. derivedStateOf不会影响这个重组
fun MessageList(messages: List&lt;Message&gt;) {
    Box {
        val listState = rememberLazyListState()

        LazyColumn(state = listState) {
            // ...
        }

        // 当第一个可见的元素不是第一个元素时显示按扭。用一个被记忆的衍生状态来最小化不必要的重组
        val showButton by remember {
            derivedStateOf {
                listState.firstVisibleItemIndex &gt; 0
            }
        }

        AnimatedVisibility(visible = showButton) {
            ScrollToTopButton()
        }
    }
}
</code></pre>

<p>在这个代码片段中，每次第一个可见的元素变化时firstVisibleItemIndex都会变化。当滚动时，它的值会变成0，1，2，3，4，5等等。然而，仅当值大于0时才需要重组。这个更新频次的不匹配意味着是一个使用derivedStateOf的好的场景。</p>

<h4>错误的使用</h4>

<p>一个常见的错误是想当然的认为当需要合并两个状态时，就需要使用derivedStateOf，因为在创建衍生状态。然而这完全是凭空想像的也不是必须的，如下面代码所展示：</p>

<blockquote><p><strong>注意：</strong> 下面的代码展示derivedStateOf不正确的用例。不要这样使用。</p></blockquote>

<pre><code class="Kotlin">// 不要这样用，不正确的derivedStateOf的用法
var firstName by remember { mutableStateOf("") }
var lastName by remember { mutableStateOf("") }

val fullNameBad by remember { derivedStateOf { "$firstName $lastName" } } // 很糟糕
val fullNameCorrect = "$firstName $lastName" // 不正确
</code></pre>

<p>这段代码中，fullName的更新频次与firstName和lastName是一样的。因此，不会有不必要的重组发生，使用derivedStateOf是多余的。</p>

<h3>snapshotFlow</h3>

<p>使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#snapshotFlow(kotlin.Function0">snapshotFlow</a>)能把状态对象（<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/State">State<T></a> objects）转化为一个冷流（cold Flow）。当被订阅（collected）时snapshotFlow会运行代码块在其中发送它读取到的状态对象。当在snapshotFlow代码块中读取的状态对象发生变化时，Flow会发送新的数据给它的订阅者，如果这个新的数据没有被发送过（这个行为与<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/distinct-until-changed.html">Flow.distinctUntilChanged</a>是类似的）。</p>

<blockquote><p><strong>译注：</strong> 对Flow不熟悉的同学可以参看<a href="https://juejin.cn/post/7336751931375648820">之前的文章</a>。</p></blockquote>

<p>下面的例子展示一个副作用，用以记录当用户滑动超过列表中首个元素时的统计信息：</p>

<pre><code class="Kotlin">val listState = rememberLazyListState()

LazyColumn(state = listState) {
    // ...
}

LaunchedEffect(listState) {
    snapshotFlow { listState.firstVisibleItemIndex }
        .map { index -&gt; index &gt; 0 }
        .distinctUntilChanged()
        .filter { it == true }
        .collect {
            MyAnalyticsService.sendScrolledPastFirstItemEvent()
        }
}
</code></pre>

<p>在上面的代码中，listState.firstVisibleItemIndex会被转化为一个Flow，方便使用Flow操作符带来的便利。</p>

<h2>副作用的重启</h2>

<p>Compose中的一些副作用，像LaunchedEffect，produceState，DispoableEffect，接收不定数量的参数keys，这些参数用于取消正在进行中的副作用和使用新的参数启动新的副作用。</p>

<p>这些API的典型形式是：</p>

<pre><code class="Kotlin">EffectName(restartIfThisKeyChanges, orThisKey, orThisKey, ...) { block }
</code></pre>

<p>由于这个行为的细微性质，如果用于重启副作用的参数并不是正确的参数时，就会产生问题：</p>

<ul>
<li>副作用重启次数少于预期可能会产生bug</li>
<li>重启次数多于预期是冗余的，影响性能</li>
</ul>


<p>首要的原则是，在副作用代码块中使用的可变的和不可变的变量都应该当成composable函数的参数。此外，也可以添加更多的参数以强制重启副作用。如果一个变量的变化不应该导致重启副作用，那这个变量应该用rememberUpdateState包裹起来。如果一个变量因为包裹在remember时没有key而永远不会变化，那么这个变量就应该作为key传给副作用函数。</p>

<blockquote><p><strong>关键点：</strong> 在副作用函数中使用的变量应该添加为函数的参数，或者使用rememberUpdateState包裹起来。</p></blockquote>

<p>在上面展示的DisposbaleEffect代码中，在代码块中使用的变量lifecycleOwner作为副作用函数的一个参数，因为它们的任何变化都会引发重启副作用。</p>

<pre><code class="Kotlin">@Composable
fun HomeScreen(
    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,
    onStart: () -&gt; Unit, // Send the 'started' analytics event
    onStop: () -&gt; Unit // Send the 'stopped' analytics event
) {
    // 这些值在组合中永不会变化，因此用remember包裹起来，以免引发冗余重启
    val currentOnStart by rememberUpdatedState(onStart)
    val currentOnStop by rememberUpdatedState(onStop)

    DisposableEffect(lifecycleOwner) {
        val observer = LifecycleEventObserver { _, event -&gt;
            /* ... */
        }

        lifecycleOwner.lifecycle.addObserver(observer)
        onDispose {
            lifecycleOwner.lifecycle.removeObserver(observer)
        }
    }
}
</code></pre>

<p>currentOnState和currentOnStop不需要作为DisposableEffect的参数key，因为使用了rememberUpdateState它们在组合中始终不会变化。如果不把lifecycleOwner作为参数传递，然后它又发生了变化，HomeScreen会重组，但DisposableEffect不会被清理和重启。这会导致之后使用的都是错误的lifecyleOwner（译注：因为lifecycleOwner可能会发生变化）。</p>

<h3>常量作为key</h3>

<p>可以使用像true这样的常量当作副作用的key，以让它跟它所在的调用点有一样的生命周期。有一些场景适合这样用：比如前面例子中的LaunchedEffect。但是，在这样做之前还是要三思是否真的要这样。</p>

<h2>总结</h2>

<p>函数式编程的理想情况是每个函数都没有副作用，但实际情况副作用却是必须的。通过本文我们学习了如何使用Jetpack Compose提供的副作用函数以解决修改composable范围以外的状态的问题。副作用问题比较难以实现且容易产生难以debug的问题，要仔细分析问题的场景，根据场景选择合适的副作用函数。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『损则有孚』| Lifecycle]]></title>
    <link href="http://toughcoder.net/blog/2024/08/18/jetpack-compose-lifecycle/"/>
    <updated>2024-08-18T12:14:35+08:00</updated>
    <id>http://toughcoder.net/blog/2024/08/18/jetpack-compose-lifecycle</id>
    <content type="html"><![CDATA[<blockquote><p>这篇文章大部分是<a href="https://developer.android.com/develop/ui/compose/lifecycle">官方文档</a>的翻译，但并不是严格的翻译，同时也加入了笔者自己的理解。</p></blockquote>

<p>通过前面的一系列文章我们已经基本掌握了使用Jetpack Compose来构建UI的方法，在接下来的几篇文章中将重点转移到Compose本身，理解一下Compose是如何把一坨坨的函数（Composables）转化成为目标平台UI的。先从composable的生命周期开始。</p>

<p><a href=""><img src="https://koenig-media.raywenderlich.com/uploads/2022/05/LifecycleOfComposablesInJetpackCompose-twitter.png" title="auto auto" ></a></p>

<!-- more -->


<p><strong>注意：</strong> 这里的生命周期是指Compose中的基本单元composable函数的生命周期，与目标平台（如Android）的生命周期不是一个概念，没有关系。</p>

<h2>概述</h2>

<p>在前面<a href="https://juejin.cn/post/7376094685495001139">讲解状态（State）的文章</a>中提到过，composable函数是Jetpack Compose的基本单元，运行composables就是组合（Composition），组合将会变成应用的UI。</p>

<p>当Jetpack Compose首次运行composables时，也即首次组合（Initial composition），它会追踪在组合中用来描述UI的composables。之后，当有状态变化时，Jetpack Compose会安排重组。重组就是重新执行状态发生变化的composables以作为对状态变化的响应，然后再更新组合体现变更。</p>

<p>组合仅能在首次组合过程中生成然后在重组中更新。修改组合的唯一方式就是通过重组。</p>

<h2>生命周期定义</h2>

<p>一个composable的生命周期可以用三个事件来定义：进入组合，重组，离开组合。</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-composition.png" alt="lifecycle" /></p>

<blockquote><p>图1. 组合中的一个composable的生命周期：进入组合，没有重组或者重组多次，最后离开组合。</p></blockquote>

<p>重组通常都是由状态对象发生变化触发的。Compose会追踪这些状态然后执行在组合中读取这些状态的所有composables，以及被这些composables调用的且无法被跳过的composables。</p>

<p><strong>注意：</strong> Composable的生命周期较View系统和Android平台的Activity以及Fragment要相对简单一些。如果一个composable需要处理外部的资源或者管理更为复杂的生命周期，可以使用副作用（Side Effects）。</p>

<p>如果一个composable被调用了多次，就会有多个实例被放入到组合之中。每一次调用都有独立的属于它自己的生命周期。来看一个例子：</p>

<pre><code class="Kotlin">@Composable
fun MyComposable() {
    Column {
        Text("Hello")
        Text("World")
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-hierarchy.png" alt="composition" /></p>

<blockquote><p>图2. 在组合中MyComposable的可视化表示。如果一个composable被调用了多次，会在组合中生成多个实例。图中不同颜色的元素代表不同的实例。</p></blockquote>

<h2>剖析组合中的composables</h2>

<p>组合中一个composable实例是用其调用点来标识的。Compose编译器认为每个调用点都是不一样的。从多个调用点调用composables会在组合中创建多个实例。</p>

<p><strong>关键术语：</strong> 调用点指的是composable被调用的代码位置。调用点会影响组合，进而影响最终UI。</p>

<p>在重组过程中，如果一个composable调用了与其上一次重组中调用的不同的composables，Compose会标识出哪些composables已调用过，哪些还未被调用过，对于两次组合中都调用了的composables，如果它们的输入没有变化则Compose不会予以执行。</p>

<p>因此，给关联到composable的副作用（各种Side Effects）指定标识就显得龙为重要，这样它们能成功的执行完成，而不是每次重组时都重新启动。</p>

<p>对于下面这个例子：</p>

<pre><code class="Kotlin">@Composable
fun LoginScreen(showError: Boolean) {
    if (showError) {
        LoginError()
    }
    LoginInput() // This call site affects where LoginInput is placed in Composition
}

@Composable
fun LoginInput() { /* ... */ }

@Composable
fun LoginError() { /* ... */ }
</code></pre>

<p>上面的代码中，函数LoginScreen会在一定条件下调用函数LogginError，并且总是会调用函数LoginInput。每个调用都有一个独一无二的调用点和代码位置，编译器正是用这些信息来独一无二的标识每个composable。
<img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-showerror.png" alt="recomposition" /></p>

<blockquote><p>图3. 在组合中，当有状态变化和重组发生时，LoginScreen的可视化展示。相同的颜色元素代表没有被重组。</p></blockquote>

<p>尽管LoginInput从第一个被调用的函数变成了第二个被调用的函数，它的实例在重组中得以留存。并且，因为LoginInput并没有在重组之间发生变化的参数，Compose会跳过对LoginInput的再次调用。</p>

<h2>提供额外的信息以优化重组</h2>

<p>多次调用一个composable会在组合中添加多个实例。当在同一个调用点多次调用同一个composable时，因为Compose没有可用的信息来独一无二的标识每个调用，所以composable的执行顺序被用以区别这些composable实例。有些时候这也够用了，但有些时候这会导致一些非预期的行为。</p>

<pre><code class="Kotlin">@Composable
fun MoviesScreen(movies: List&lt;Movie&gt;) {
    Column {
        for (movie in movies) {
            // MovieOverview composables are placed in Composition given its
            // index position in the for loop
            MovieOverview(movie)
        }
    }
}
</code></pre>

<p>在上面的代码中，Compose会用执行顺序来区别调用的composable实例。如果一个新的数据元素movie被添加到了列表的底部（最后面），Compose可以复用已经在组合中的实例，因为它们的位次没有变化，故而这些composable的输入数据元素movie并不会变化，也就是说因为只在最后添加，先前存在的实例与其数据还是能够对应得上的。</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-newelement-bottom.png" alt="no_key" /></p>

<blockquote><p>图4. 当一个新数据元素moviei添加到列表底部后时，组合中MovieScreen的可视化表示。组合中函数MovieOverview的实例会被复用。相同颜色的元素表示未被重组。</p></blockquote>

<p>然而，如果输入列表的变化是在其顶部添加新元素，或者在中间添加新元素，或者有移除，或者变化元素顺序时，就会对列表中位置发生变化的所有MovieOverview进行重组。如果有储如在MovieOverview中获取电影图片的副作用函数的话，这些仅因位置改变而发生的重组就特别重要了。因为重组会影响副作用函数，如果副作用正在进行中，会被取消然后重新启动。</p>

<pre><code class="Kotlin">@Composable
fun MovieOverview(movie: Movie) {
    Column {
        // Side effect explained later in the docs. If MovieOverview
        // recomposes, while fetching the image is in progress,
        // it is cancelled and restarted.
        val image = loadNetworkImage(movie.url)
        MovieHeader(image)

        /* ... */
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-newelement-top-all-recompose.png" alt="side_effect" /></p>

<blockquote><p>图5. 新元素添加到列表中时组合中MovieScreen的可视化表示。MovieScreen实例无法复用，所有的副作用会重启。不同的颜色代表发生了重组。</p></blockquote>

<p>理想情况下，应该让函数MovieScreen的实例标识与其数据项的标识联系起来。如果列表数据项顺序有变化，最为想理的办法是也把组合树中的对应的函数实例进行次序调整，而不是进行重组（前面说了次序作为函数实例的标识，次序变了，就要使用新位置的数据项调用composable进行重组）。Compose给我们提供了一个方法用以标识组会树中的函数实例：即<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#key(kotlin.Array,kotlin.Function0">函数key</a>)。</p>

<p>把代码块放入函数key里面，再传给函数key一些数据，这些数据会被组合起来以标识组合中的函数实例。传给函数key的数据不必是全局唯一的，它只需要在key所在的调用点是唯一的就行。比如在前面例子中，每个数据项movie需要有一个唯一的标识，它能在这个列表中唯一标识一部电影就可以了：</p>

<pre><code class="Kotlin">@Composable
fun MoviesScreenWithKey(movies: List&lt;Movie&gt;) {
    Column {
        for (movie in movies) {
            key(movie.id) { // Unique ID for this movie
                MovieOverview(movie)
            }
        }
    }
}
</code></pre>

<p>像上面用了key以后，无论列表怎么变化，Compose都能辩识出具体composable实例，然后加以复用：
<img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-newelement-top-keys.png" alt="key" /></p>

<blockquote><p>图6. 当新数据元素添加到列表时组合中MovieScreen的可视化展示。因为有了唯一标识，Compose能识别出哪些实例未发生变化，加以复用，它们附带的副作用会继续执行。</p></blockquote>

<p><strong>关键点：</strong> 适度的使用函数key来帮助Compose唯一标识函数实例。特别是针对在同一个调用点大量调用同一个composable时，比如在各种集合性布局中。</p>

<p>有些composable有更为友好的key支持方法。比如像LazyColumn它可以直接在其items DSL中传入一个lambda作为key：</p>

<pre><code class="Kotlin">@Composable
fun MoviesScreenLazy(movies: List&lt;Movie&gt;) {
    LazyColumn {
        items(movies, key = { movie -&gt; movie.id }) { movie -&gt;
            MovieOverview(movie)
        }
    }
}
</code></pre>

<h2>重组时跳过composable的策略</h2>

<p>在重组过程中，一些具备条件的composable函数可以让Compose跳过他们的执行，如果它们的输入参数较前一次组合时没有任何变化。
除了以下情况外，就可以说一个composable函数具备跳过条件：</p>

<ul>
<li>函数有返回值（non-Unit return type）</li>
<li>函数使用了注解&#64;NonRestartableComposable或者&#64;NonSkippableComposable修饰</li>
<li>必需的参数是一个非稳定类型（non-stable type）</li>
</ul>


<p>前两个都好理解，接下来重点看第三个情况。一个类型要想成为稳定的（stable），必须符合以下约定：</p>

<ul>
<li>对于两个相内实例来说，对其们使用equals方法的返回值必须永远相同</li>
<li>如果一个类型的公开属性发生变化，组合会得到通知</li>
<li>所有公开属性类型也必须是稳定的</li>
</ul>


<p>有一些重要的常见类型符合这个约定，Compose编译器会把它们当成稳定的类型，尽管他们并没有使用注解&#64;Stable显式地标注为稳定的：</p>

<ul>
<li>所有的基础数据类型：布尔（Boolean），整数（Int），长整数（Long），浮点（Float），字符（Char）等</li>
<li>字符串（String）</li>
<li>所有的函数类型（lambdas）</li>
</ul>


<p>所有这些类型都能符合稳定约定，因为他们都是不可变类型。因为不可变类型实例不会改变，它们不会通知组合说值有所改变，因此就能符合上述约定。</p>

<p><strong>注意：</strong> 所有的整体不可变类型都可以安全地当成稳定的类型。</p>

<p>一个值得注意的类型是可变状态类型（MutableState），虽然是稳定的但却可变可修改。如果MutableState中持有一个值，这个状态对象被认为是稳定的，因为State属性.value发生的任何变化都会通知给Compose。</p>

<p>当作为传递给一个composable函数参数的所有类型都是稳定的（stable）时，这些参数的值会基于它们在UI树中的函数位置进行等值比较（equality）。从前一次组合起如果值未变化就会跳过其重组。换句话说输入参数的类型是稳定的（stable）是一个大前提，只有稳定的类型比较等值才有意义。</p>

<p><strong>关键点：</strong> 如果一个composable的输入是稳定的且未有变化，Compose就会跳过它的重组。等值比较使用的是方法equals。</p>

<p>仅当Compose能够证明一个类型是稳定的时，才会把一个类型当作稳定的。例如，接口（interface）通常认为是不稳定的，拥有可变公开属性的类型，虽然这些属性的实现可以是不可变的，但这种类型也认为是不稳定的。</p>

<p>如果Compose无法推断出一个类型是不是稳定的，但是想强制它被当作稳定的类型，可以使用注解&#64;Stable来标注。</p>

<pre><code class="Kotlin">// Marking the type as stable to favor skipping and smart recompositions.
@Stable
interface UiState&lt;T : Result&lt;T&gt;&gt; {
    val value: T?
    val exception: Throwable?

    val hasError: Boolean
        get() = exception != null
}
</code></pre>

<p>上面的代码片段中，因为UiState是一个接口，会被当成不稳定的类型。通过添加注解&#64;Stable，告诉Compose它是稳定的，让Compose进行智能重组。这也意味着，当接口类型用于参数类型时，Compose会把接口的所有具体实现当成稳定的类型。</p>

<p><strong>关键点：</strong> 如果Compose无法推断出类型的稳定性，使用注解&#64;Stable来标注以让Compose进行智能重组。</p>

<h2>总结</h2>

<p>Composable函数是Compose的基本单元，通过此文我们理解了一个composable的生命周期，并对Compose的重组机制做了介绍，以及如何更好的让Compose做智能重组。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/lifecycle">Lifecycle of composables</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『密云不雨』| Navigation]]></title>
    <link href="http://toughcoder.net/blog/2024/08/12/navigation-with-compose/"/>
    <updated>2024-08-12T07:46:31+08:00</updated>
    <id>http://toughcoder.net/blog/2024/08/12/navigation-with-compose</id>
    <content type="html"><![CDATA[<p>除了一些玩具性的Demo以外，相信任何一个应用程序不可能只有一个页面，最为极简的应用也至少会有两个页面，一个主页和一个设置页。对于传统的View系统来说对于导航这块没有专门的API，一般都是自己写逻辑跳Activity，或者跳到Fragment，然后再反向的Back，所以有了很多三方的各种Router类库（如大阿里的ARouter，货拉拉的TheRouter）。其实谷歌已经提供了解决方案，在Jetpack中提供了<a href="https://developer.android.com/guide/navigation">Navigation组件</a>，专门用于解决应用内部各种页面之间跳转的问题。</p>

<p><a href=""><img src="https://blog.mindorks.com/images/banner-jetpack-compose-navigation-657edc7b323cafdf.png" title="auto auto" ></a></p>

<!-- more -->


<p>对于Jetpack Compose来说，因为是全新的框架，在设计之初就考虑到了导航的问题，但也不是重新开发了一套新库，而是把Jetpack中的组件Navigation深度的结合了进来。换句话说，在Jetpack Compose中可以直接使用Navigation组件来进行页面之间的跳转，并且有非常符合Compose的粘合API，使用起来非常的丝滑顺手。</p>

<h2>基本概念</h2>

<p>在深入之前有必要先澄清Navigation中的一些概念，了解了一些基本的概念和术语之后，会有助于理解组件的设计理念，也会更容易上手使用。</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 术语 </th>
<th style="text-align:left;"> 用途 </th>
<th style="text-align:left;"> 具体的Composable </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> Host </td>
<td style="text-align:left;"> 包含了当前导航页面的容器。应该把它理解成为导航的容器，包含着当前的页面， 以及一个NavController。 </td>
<td style="text-align:left;"> <a href="https://developer.android.com/reference/kotlin/androidx/navigation/compose/package-summary#NavHost(androidx.navigation.NavHostController,androidx.navigation.NavGraph,androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1">NavHost</a>) </td>
</tr>
<tr>
<td style="text-align:center;"> Graph </td>
<td style="text-align:left;"> 静态的数组结构，定义着一个应用中的所有页面，以及它们之间应该如何跳转。 </td>
<td style="text-align:left;"> <a href="https://developer.android.com/reference/androidx/navigation/NavGraph">NavGraph</a> </td>
</tr>
<tr>
<td style="text-align:center;"> Controller </td>
<td style="text-align:left;"> 页面之间导航的核心管理者。它封装着如何在页面之间跳转的方法，处理链接的方法，以及返回堆栈的方法。 </td>
<td style="text-align:left;"> <a href="https://developer.android.com/reference/androidx/navigation/NavController">NavController</a> </td>
</tr>
<tr>
<td style="text-align:center;"> Destination </td>
<td style="text-align:left;"> 在Graph中的一个节点。当跳转到这个节点时，Host中就包含并展示它的页面。在实际项目中，往往是一个Fragment或者一个Composable，也就是一个页面。 </td>
<td style="text-align:left;"> <a href="https://developer.android.com/reference/androidx/navigation/NavDestination">NavDestination</a> </td>
</tr>
<tr>
<td style="text-align:center;"> Route </td>
<td style="text-align:left;"> Destination的全局唯一标识，包括其所需要的参数。大部分时候，特别是在Compose中，这就是一坨类似于Uri一样的String </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p>还需要说明一下的就是导航的基本的操作对象是一个页面，一个页面可以理解为一个全屏的，逻辑上内聚，内容上互相关联，自成一家的一个UI页面，比如说一个应用的主页是一个页面，文章列表是一个页面，文章详情是一个页面，设置是一个页面，用户页又是一个页面。当然，这里全屏并不是直观的全屏，意思是说（特别是对于Compose）一个页面的大小是受系统控制的，并不能像普通的Composable那样随意设置大小，对于手机就是全屏的，对于平板可能会一个占据三分之一（列表页），一个占据三分之二（详情页）。</p>

<h2>使用Navigation</h2>

<p>Jetpack Compose是声明式UI，是函数式编程，每一个Composable都是一个函数，所以在Compose中使用Navigation略微的有点不一样。核心原理和核心的规则肯定与Navigation是一样一样的，只是使用上的API略不一样，其实是更简单更方便了（这是声明式UI带来的收益）。</p>

<h3>添加依赖</h3>

<p>在使用之前先要添加Navigation库作为项目的依赖：</p>

<pre><code class="Kotlin">dependencies {
    val navVersion = "2.7.7"
    implementation("androidx.navigation:navigation-runtime-ktx:$navVersion")
    implementation("androidx.navigation:navigation-compose:$navVersion")
}
</code></pre>

<h3>使用Navigation的方法</h3>

<p>可以通过以下步骤来使用Navigation：</p>

<ul>
<li>创建NavHost，并设置为应用的入口，通过Composable函数<a href="https://developer.android.com/reference/kotlin/androidx/navigation/compose/package-summary#NavHost(androidx.navigation.NavHostController,androidx.navigation.NavGraph,androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1">NavHost</a>)。</li>
<li>创建NavController，可以直接创建，但推荐的方式是使用Compose提供的状态构造函数<a href="https://developer.android.com/reference/kotlin/androidx/navigation/compose/package-summary#rememberNavController(kotlin.Array">rememberNavController</a>)，它的好处在于当前导航会提升为一个状态。</li>
<li>定义Destination和Route，其实对于Compose来说都是用类似于Uri的String来作为Destination，每一个Destition唯一对应着一个页面。</li>
<li>添加页面，通过函数NavHost的尾部lambda，它实际上是一个<a href="https://developer.android.com/reference/kotlin/androidx/navigation/NavGraphBuilder">NavGraphBuilder</a>的扩展函数，这里调用函数<a href="https://developer.android.com/reference/kotlin/androidx/navigation/compose/package-summary#(androidx.navigation.NavGraphBuilder">composable</a>.composable(kotlin.collections.Map,kotlin.collections.List,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function2))来添加页面。</li>
<li>配置跳转，通过前面创建的navController来实现跳转，用<a href="https://developer.android.com/reference/kotlin/androidx/navigation/NavController#navigate(android.net.Uri">navController.navigate</a>)来跳转到指定的Destination，用<a href="https://developer.android.com/reference/androidx/navigation/NavController#popBackStack(">navController.popBackStack</a>)来返回到前一个页面。而触发的入口肯定是在具体的页面之中，所以页面要把其跳转函数作为参数，在NavGraphBuilder时，再用NavController去实现，这样所有的跳转逻辑就都在NavGraph中，便于管理。</li>
</ul>


<h3>具体实例</h3>

<p>说了那么多貌似挺烦杂的，让我们看一个实例就会瞬间明白。</p>

<p>一个简单的应用有4个页面，先定义Destinations：</p>

<pre><code class="Kotlin">object Destinations {
    const val APP_URI = "http://toughcoder.net/chronos"
    const val HOME_ROUTE = "home" // 主页
    const val HISTORY_ROUTE = "history" // 历史记录页面
    const val SETTINGS = "settings" // 设置页
    const val ARTICLES = "articles" // 文章页
}
</code></pre>

<p>那么就可以如此配置Navigation：</p>

<pre><code class="Kotlin">@Composable
fun ChronosNavGraph(
    modifier: Modifier = Modifier,
    navController: NavHostController = rememberNavController(),
    start: String = Destinations.HOME_ROUTE // 默认的初始页面为主页
) {
    NavHost(
        modifier = modifier,
        navController = navController,
        startDestination = start
    ) {
        composable(
            route = Destinations.HOME_ROUTE,
            deepLinks = listOf(
                navDeepLink { uriPattern = "${Destinations.APP_URI}/${Destinations.HOME_ROUTE}" }
            )
        ) {
            ChronosScreen(
                gotoSettings = { navController.navigate(Destinations.SETTINGS) },
                gotoHistory = { navController.navigate(Destinations.HISTORY_ROUTE) },
                gotoArticles = { navController.navigate(Destinations.ARTICLES) }
            )
        }

        composable(
            route = Destinations.HISTORY_ROUTE,
            deepLinks = listOf(
                navDeepLink { uriPattern = "${Destinations.APP_URI}/${Destinations.HISTORY_ROUTE}" }
            )
        ) {
            HistoryScreen(
                viewModel = viewModel()
            ) {
                navController.popBackStack()
            }
        }

        composable(
            route = Destinations.SETTINGS,
            deepLinks = listOf(
                navDeepLink { uriPattern = "${Destinations.APP_URI}/${Destinations.SETTINGS}" }
            )
        ) {
            SettingsScreen(
                viewModel = viewModel()
            ) {
                navController.popBackStack()
            }
        }

        composable(
            route = Destinations.ARTICLES,
            deepLinks = listOf(
                navDeepLink { uriPattern = "${Destinations.APP_URI}/${Destinations.ARTICLES}" }
            )
        ) {
            ArticlesScreen(
                viewModel = viewModel()
            ) {
                navController.popBackStack()
            }
        }
    }
}
</code></pre>

<p>可以看到每一个composable函数用以创建一个导航页面，里面有其Route，具体的页面，以及跳转的入口函数。deepLinks是每个页面的Uri式的链接，后面会详细的讲解。</p>

<p>最后就是把这个NavGraph作为应用的入口页面：</p>

<pre><code class="Kotlin">override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            ChronosTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    ChronosNavGraph()
                }
            }
        }
    }
</code></pre>

<h2>在页面之间传递参数</h2>

<p>页面跳转还必然会涉及参数的传递，比如具有递进关系的两个页面，核心参数肯定要由前一个页传递过去，最为典型的场景就是列表类页面到详情页面的跳转，比如文章列表要把文章的Id传给详情页，这样详情页才知道去展示哪个文章，用户列表要把用户Id传给详情页，详情页才知道展示哪个用户。</p>

<p>Navigation提供了传递参数的方法，在创建导航页面时传入的Route可以加入占位符形参，然后在跳转navController.navigate时可以传入实参，只不过参数的类型有限制，只能是基础数据类型如字串或者数字。目标页面使用时通过backStackEntry.arguments来获得参数。来具体看一下，比如说传递用户Id的场景：</p>

<pre><code class="Kotlin">NavHost() {
    composable(
          "profile/{userId}",
          arguments = listOf(navArgument("userId") { type = NavType.StringType } // 这句可以省略，因为默认类型都当成是字符串
    ) { backStackEntry -&gt;
          Profile(navController, backStackEntry.arguments?.getString("userId"))
    }
}
</code></pre>

<p>上面参数类型的声明，其实可以省略，因为默认的类型都当成String来解析和处理，如果是其他类型则需要显式地声明。这样目标页面的参数就声明好了，我们在跳转的时候传入实参就可以了：</p>

<pre><code class="Kotlin">navController.navigate("profile/user1234")
</code></pre>

<p>大部分时候参数都是<strong>必填参数</strong>，像上面这样写userId是必填的参数。但有些时候一些非核心的参数，可能不是每次跳转都会传，这就需要页面把参数声明为<strong>可选参数</strong>。可选参数在声明的时候Uri中必须使用查询式语句，如（&#8221;?argName={argName}&ldquo;），另外必须 设置默认值，或者类型是nullable的。这也意味着我们不能省略导航页面构建composable函数中的arguments参数：</p>

<pre><code class="Kotlin">composable(
    "profile?userId={userId}",
    arguments = listOf(navArgument("userId") { defaultValue = "user1234" }) // 注意这里的默认值，当调用navigate时如果不传userId就用这个默认值
) { backStackEntry -&gt;
    Profile(navController, backStackEntry.arguments?.getString("userId"))
}
</code></pre>

<p><strong>注意：</strong> 要尽可能的使用基本的数据类型，如String，Int或者Long，而不传递复杂的数据。复杂的数据通常都是业务逻辑数据，而业务逻辑数据应该使用基本的参数，再从数据源处（通常是通过ViewModel从Repo处）去主动获取，这样才能保证数据的真实有效。这是设计原则中的『单一数据源原则Single Source of Truth』。复杂数据从Repo处获取后，可能会变得过时或者失真，而且在页面之间传递会有拷贝，效率也不高，因此要避免在页面之间传递复杂数据。</p>

<h2>处理DeepLinks</h2>

<p>DeepLinks是Uri式的链接跳转范式，能够以字符串形式的Uri精准的定位到某个应用的具体某个页面，就犹如互联网中的Uri一样。它的好处在于形成了一个统一的标准，形式简单方便，一个字符串就能定位到一个页面。</p>

<p>使用导航页面构建函数composable在构建页面的时候可以传入<a href="https://developer.android.com/reference/androidx/navigation/NavDeepLink">NavDeepLink</a>对象，更为方便的是使用其构建函数<a href="https://developer.android.com/reference/kotlin/androidx/navigation/package-summary#navDeepLink(kotlin.Function1">navDeepLink</a>)：</p>

<pre><code class="Kotlin">val uri = "https://www.example.com"

composable(
    "profile?id={id}",
    deepLinks = listOf(navDeepLink { uriPattern = "$uri/{id}" })
) { backStackEntry -&gt;
    Profile(navController, backStackEntry.arguments?.getString("id"))
}
</code></pre>

<p>从示例中可以看出Uri中还可以带有参数，形参的声明，以及参数的获取与前面提到的页面参数是一样一样的，如果实际传过来的Uri是&#8221;<a href="https://www.example.com/user123">https://www.example.com/user123</a>&#8220;，到此页面后，就能解析出参数id为user123。</p>

<p>正常情况下这些DeepLinks只能在应用内部使用，如果要对应用外开放，则需要在应用的AndroidManifest文件中进行声明，声明为intent filter：</p>

<pre><code class="xml">&lt;activity …&gt;
  &lt;intent-filter&gt;
    ...
    &lt;data android:scheme="https" android:host="www.example.com" /&gt;
  &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>

<h2>页面跳转过渡动画</h2>

<p>页面跳转可以指定具体的过渡动画，具体的可以参考<a href="https://juejin.cn/post/7385758285960609831#heading-10">前面专门讲动画的那篇文章</a>，这里就不再重复了。</p>

<h2>Route的类型安全</h2>

<p>通常情况下Route都是使用Uri式的String，但这明显不够安全，因为调用navController#navigate的时候，可能会传一个不认识的页面Route，或者参数传错了（比如数字参数传了String），等等。轻则跳转失败，因为找不到Destination页面，重则会Crash。要想类型安全，就不能使用String式的Uri，需要把Ruote定义为类型（也即class），但要使用注解&#64;Serializeable标记一下：</p>

<pre><code class="Kotlin">// 主页面，不带任何参数
@Serializable
object Home

// 用户页面，参数是用户Id，其类型是一个String
@Serializable
data class Profile(val id: String)
</code></pre>

<p>然后在构建导航页面的时候，函数composable其实是一个泛型函数，它可以指定Route的参数类型：</p>

<pre><code class="Kotlin">NavHost(navController, startDestination = Home) {
     composable&lt;Home&gt; { // 泛型函数，可以指定参数类型
         HomeScreen(onNavigateToProfile = { id -&gt;
             navController.navigate(Profile(id)) // 跳转的时候传入的实参是一个对象，类型就是上面定义的Route
         })
     }
     composable&lt;Profile&gt; { backStackEntry -&gt;
         val profile: Profile = backStackEntry.toRoute()  // 获取参数的时候，用toRoute来获得Route对象，类型就是我们定义的那个
         ProfileScreen(profile.id)
     }
}
</code></pre>

<p>然后在跳转的时候就可以把Route对象作为实参传进去：</p>

<pre><code class="Kotlin">navController.navigate(Profile(id = 123))
</code></pre>

<p>这样因为都是定义的类型，所以编译器会做编译时检查，虚拟机也会做运行时的类型检查，保证类型安全。</p>

<p><strong>注意：</strong> 不要混淆，这里Route虽然是自定义类型，但并不算是在页面之间传递复杂的业务数据，因为具体的参数仍是诸如String和Int之类的基础数值。把Route定义为类型（class），而不是直接使用String，是为了让编译器帮忙我们保证类型安全，减少出错。</p>

<h2>总结</h2>

<p>使用Navigation可以非常轻松的把应用的各个页面组织连接起来，形成一个完整的交互闭环。谷歌也提供了相应的<a href="https://developer.android.com/codelabs/jetpack-compose-navigation#0">CodeLab</a>可以学习一下。此外，谷歌的一些Sample app，像<a href="https://github.com/android/sunflower/tree/main">Sunflower</a>和<a href="https://github.com/android/compose-samples/tree/main/JetNews">JetNews</a>也是使用Navigation来实现导航的，是非常好的学习案例。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/navigation">Navigation with Compose</a></li>
<li><a href="https://developer.android.com/guide/navigation">Navigation</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『时乘六龙』| Advanced Gestures]]></title>
    <link href="http://toughcoder.net/blog/2024/08/02/advanced-gesture-in-compose/"/>
    <updated>2024-08-02T07:46:30+08:00</updated>
    <id>http://toughcoder.net/blog/2024/08/02/advanced-gesture-in-compose</id>
    <content type="html"><![CDATA[<p>通过<a href="https://juejin.cn/post/7395020728623480841">前面的一篇文章</a>我们学会了如何用各种高级别抽象的扩展函数来进行手势处理。像clickable，draggable，scrollable和anchoredDraggable都是类似于View系统中的各种回调（如onClick或者onScroll）是高级别的抽象，这里我们只能处理手势，大部分情况下这也够用了。</p>

<p><a href=""><img src="file:///Users/alexhilton/Downloads/compose_libs/gesture/advanced_gesture.jpeg" title="auto auto" ></a></p>

<!-- more -->


<p>但是，对于一些复杂的交互 场景需要我们先识别手势，然后再处理手势，这时就不能再用封装好的扩展函数了，而必须要用到像View系统中的onTouchEvent那样的低级别的回调，直接拿到触点事件，然后再识别手势，最后再处理手势。这篇文章就学习一下如何使用Jetpack Compose中的低级别函数来识别和处理手势。</p>

<h2>处理原始触点事件</h2>

<p>除了使用一些封装好了的扩展函数来直接处理某个手势以外，还可以直接接收原始的事件输入。</p>

<p>Jetpack Compose在Modifier中提供了扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/package-summary#(androidx.compose.ui.Modifier">pointerInput</a>.pointerInput(kotlin.Any,kotlin.Any,kotlin.coroutines.SuspendFunction1))来接收原始的触点事件，与View系统中的<a href="https://developer.android.com/reference/android/view/View.OnTouchListener">onTouch</a>是类似的，这是触点事件的低级别的API。通过此API能获得触点事件，之后可以进行手势识别和手势处理，因为拿到的是原始的触点事件，所以很多逻辑要自己写，有些麻烦，但因为完全可控，所以可以实现一些更为复杂的手势识别和手势处理，比如任意方向的拖拽和滑动，长按后的拖拽，多点触控等等。</p>

<h3>接收触点事件</h3>

<p>扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/package-summary#(androidx.compose.ui.Modifier">pointerInput</a>.pointerInput(kotlin.Any,kotlin.Any,kotlin.coroutines.SuspendFunction1))接收三个参数，前两个都是作为<strong>事件处理回调的标识（keys）</strong>，第三个参数是<strong>事件处理回调</strong>，是一个尾部lambda，当某个key发生变化，这个lambda会重新执行，否则即使发生重组（Recomposition），这个lambda也会不会重新执行。</p>

<pre><code class="Kotlin">fun Modifier.pointerInput(key1: Any?, key2: Any?, block: suspend PointerInputScope.() -&gt; Unit): Modifier
</code></pre>

<p>第三参数就是我们要提供的事件处理回调，它是运行在<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/PointerInputScope">PointerInputScope</a>上下文中的lambda，这个上下文作用域里面有很多扩展函数可以直接使用。仔细看这个lambda是suspend的，这是因为输入事件可能不是即时的，可能会有等待的情况，也就是说lambda是在有事件的时候才会执行。PointerInputScope中的函数也都定义为suspend的，这些函数在lambda中可以直接调用，所以lambda本身也必须 是suspend的。</p>

<p>比如说想要打印触点事件，就可以这样写：</p>

<pre><code class="Kotlin">@Composable
private fun LogPointerEvents(filter: PointerEventType? = null) {
    var log by remember { mutableStateOf("") }
    Column {
        Text(log)
        Box(
            Modifier
                .size(100.dp)
                .background(Color.Red)
                .pointerInput(filter) {
                    awaitPointerEventScope {
                        while (true) {
                            val event = awaitPointerEvent()
                            // handle pointer event
                            if (filter == null || event.type == filter) {
                                log = "${event.type}, ${event.changes.first().position}"
                            }
                        }
                    }
                }
        )
    }
}
</code></pre>

<p>filter是一个事件的类型参数当作key，也当作过滤条件。在事件处理回调lambda中，用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/AwaitPointerEventScope#awaitPointerEvent(androidx.compose.ui.input.pointer.PointerEventPass">awaitPointerEvent</a>)获得每一个触点事件，然后打印出来，<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/AwaitPointerEventScope">awaitPoniterEventScope</a>函数是创建一个协程上下文作用域用以等待事件输入，在其内调用awaitPointerEvent来获得事件。</p>

<h3>识别手势</h3>

<p>虽然pointerInput是一个低级别的接口，但也并不意味着所有的逻辑都必须从头写，在<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/PointerInputScope">PointerInputScope</a>中已经定义了大量的函数可以识别大部分手势：</p>

<ul>
<li>非连续性手势如单击（tap），双击（double tap）和长按（long press）：<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.input.pointer.PointerInputScope">detectTapGestures</a>.detectTapGestures(kotlin.Function1,kotlin.Function1,kotlin.coroutines.SuspendFunction2,kotlin.Function1))</li>
<li>拖拽（drag）：<a href="">detectDragGestures</a>，<a href="">detectDragGesturesAfterLongPress</a>，以及固定方向拖拽<a href="">detectHorizontalDragGestures</a>和<a href="">detectVerticalDragGestures</a></li>
<li>多点触控变幻的手势识别（旋转，平移和缩放）：<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.input.pointer.PointerInputScope">detectTransformGestures</a>.detectTransformGestures(kotlin.Boolean,kotlin.Function4))</li>
</ul>


<p>比如像<a href="https://juejin.cn/post/7395020728623480841">前面文章中</a>提到的拖拽也可以用pointerInput实现：</p>

<pre><code class="Kotlin">@Composable
private fun DraggableTextLowLevel() {
    Box(modifier = Modifier.fillMaxSize()) {
        var offsetX by remember { mutableStateOf(0f) }
        var offsetY by remember { mutableStateOf(0f) }

        Box(
            Modifier
                .offset { IntOffset(offsetX.roundToInt(), offsetY.roundToInt()) }
                .background(Color.Blue)
                .size(50.dp)
                .pointerInput(Unit) {
                    detectDragGestures { change, dragAmount -&gt;
                        change.consume()
                        offsetX += dragAmount.x
                        offsetY += dragAmount.y
                    }
                }
        )
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/gestures-drag.gif" alt="detect_drag_demo" /></p>

<p>前面提到了像detectTapGestures和detectDragGestures都是suspend的函数，所以在一个pointerInter的lambda中只能有一个，比如像下面这样写detectDragGestures不会得到执行：</p>

<pre><code class="Kotlin">var log by remember { mutableStateOf("") }
Column {
    Text(log)
    Box(
        Modifier
            .size(100.dp)
            .background(Color.Red)
            .pointerInput(Unit) {
                detectTapGestures { log = "Tap!" }
                // 不会得到执行，走不到这里，前面一个是suspend的
                detectDragGestures { _, _ -&gt; log = "Dragging" }
            }
    )
}
</code></pre>

<p>一个可行的解决办法就是可以写多个pointerInput，每个ponterInput处理一种手势：</p>

<pre><code class="Kotlin">var log by remember { mutableStateOf("") }
Column {
    Text(log)
    Box(
        Modifier
            .size(100.dp)
            .background(Color.Red)
            .pointerInput(Unit) {
                detectTapGestures { log = "Tap!" }
            }
            .pointerInput(Unit) {
                // These drag events will correctly be triggered
                detectDragGestures { _, _ -&gt; log = "Dragging" }
            }
    )
}
</code></pre>

<h3>直接处理事件</h3>

<p>遇到交互比较复杂的场景，或者当PointerInputScope中提供的识别函数不能解决问题时，或者需要把几种不同的手势组合在一起时，就需要直接处理事件。像View系统中的onTouch一样，我们需要知道不同的事件类型，比如pointer down，pointer move和pointer up等。PointerInputScope中提供了一个函数awaitEachGesture可以取代while (true)来获得每个事件；awaitFirstDown，是手势的开始相当于ACTION&#95;DOWN；waitForUpOrCancellation是事件结束，相当于ACTION&#95;UP和ACTION&#95;CANCEL；drag相当于ACTION&#95;MOVE。我们来看一个例子：</p>

<pre><code class="Kotlin">@Composable
private fun LogPointerEvents() {
    var log by remember { mutableStateOf("") }
    Column(
        modifier = Modifier.fillMaxSize(),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        Text(log)
        Box(
            Modifier
                .size(240.dp)
                .background(Color.DarkGray)
                .pointerInput(Unit) {
                    awaitEachGesture {
                        val down = awaitFirstDown().also {
                            log = "Action Down"
                        }
                        var change = awaitTouchSlopOrCancellation(down.id) { ch, _ -&gt;
                            ch.consume()
                        }
                        while (change != null &amp;&amp; change.pressed) {
                            change = awaitDragOrCancellation(change.id)
                            if (change != null &amp;&amp; change.pressed) {
                                log = "Action Move ${change.type} ${change.position}"
                            }
                        }
                        log = "Action Up"
                    }
                }
        )
    }
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/gesture/event.gif" alt="event_demo" /></p>

<p>需要注意的是这些函数都是suspend的，也就是说当预期的行为发生时才会带着结果返回，比如awaitFirstDown()当有第一个触点事件发生时结束suspend然后返回；awaitTouchSlopOrCancellation当有超过拖拽阈值时结束suspend然后返回；awaitDragOrCancellation当有拖拽发生时结束suspend返回。</p>

<h2>触点事件的派发流程</h2>

<p>为了更好的处理事件，需要了解一下Jetpack Compose的事件派发流程，与View系统是类似的，事件派发的过程也是沿着Composable的树形结构，从父Composable到子Composable，同一层级的顺序则是从上到下，从前到后（Z轴方向），依次做『Hit test』，直到事件被消费，就停止派发。</p>

<p>事件的消费过程则是反过来，子Composable如果未消费就返回给父Composable，前面的Composable未消费，就继续向下传递，直到事件被消费。</p>

<p>如果是自己在pointerInput中直接处理事件，就要特别注意手动的把事件给消费掉，否则可能会继续传递。像awaitPointerEvent，awaitFirstDown，awaitDragOrCancellation等返回的都是<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/PointerInputChange">PointerInputChange</a>对象，调用它的<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/PointerInputChange#consume(">consume()</a>)方法即可把事件消费掉。再比如像上面的例子awaitTouchSlopOrCancellation中，也需要手动的把事件给消费掉，如果把ch.consume()这句删除，就会发现awaitDragOrCancellation不会得到执行，这是因为awaitTouchSlopOrCancellation这个方法还在执行中，调用ch.consume()把事件消费掉，这个函数才会返回。</p>

<p>这也说明了，还是要尽量用系统封装好的手势识别和手势处理函数，不到万不得已不要直接处理原始事件，因为逻辑写起来肯定相当复杂。</p>

<h2>多点触控</h2>

<p>多点触控是超过一个触点同时在屏幕上操作，最为常见的手势就是旋转和缩放，可以使用扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">transformable</a>.transformable(androidx.compose.foundation.gestures.TransformableState,kotlin.Boolean,kotlin.Boolean))监听旋转，平移和缩放手势，其中平移单个触点也能触发，缩放和旋转则需要两个触点，当超过3个触点时这个函数不会回调，也即不会触发任何手势：</p>

<pre><code class="Kotlin">@Composable
private fun TransformableSample() {
    // set up all transformation states
    var scale by remember { mutableStateOf(1f) }
    var rotation by remember { mutableStateOf(0f) }
    var offset by remember { mutableStateOf(Offset.Zero) }
    val state = rememberTransformableState { zoomChange, offsetChange, rotationChange -&gt;
        scale *= zoomChange
        rotation += rotationChange
        offset += offsetChange
    }
    Box(
        Modifier
            // 把参数应用到图层去做变幻
            .graphicsLayer(
                scaleX = scale,
                scaleY = scale,
                rotationZ = rotation,
                translationX = offset.x,
                translationY = offset.y
            )
            // 接收变幻手势
            .transformable(state = state)
            .background(Color.Blue)
            .fillMaxSize()
    )
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/gestures-multitouch.gif" alt="multi_touch_demo" /></p>

<p>除了直接使用Modifier.transformable以外，还可以用前面提到过的pointerInput中的<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.input.pointer.PointerInputScope">detectTransformGestures</a>.detectTransformGestures(kotlin.Boolean,kotlin.Function4))这个函数也能得到平移，旋转和缩放的变化数值，把这些数值应用到graphicsLayer去做变幻就可以了，使用detectTransformGestures的另一个好处是可以与其他的手势结合起来。</p>

<h2>总结</h2>

<p>通过本文我们学习如何得到原始的触点事件，以及如何识别手势，相信对触点事件以及手势识别有了更深入的理解，并且借助这些扩展函数就可以写出交互性更好的应用程序界面。即使遇到一些复杂的交互 场景，或者需要组合多种手势时，也都能从容应对。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/understand-gestures">Understand gestures</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/multi-touch">Multitouch: Panning, zooming, rotating</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/user-interactions/handling-interactions">Handling user interactions</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
