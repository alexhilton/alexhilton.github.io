<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2025-07-01T22:55:55+08:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[长驻UI元素的UI层体系结构]]></title>
    <link href="https://alexhilton.github.io/blog/2025/06/07/ui-layer-architecture/"/>
    <updated>2025-06-07T22:47:48+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/06/07/ui-layer-architecture</id>
    <content type="html"><![CDATA[<p>本文译自「UI layer architecture for persistent UI elements」，原文链接<a href="https://www.tunjid.com/articles/ui-layer-architecture-for-persistent-ui-elements-68248e8ecc8e85f53ce1aa46">https://www.tunjid.com/articles/ui-layer-architecture-for-persistent-ui-elements-68248e8ecc8e85f53ce1aa46</a>，由TJ Dahunsi</p>

<p>发布于2025年5月14日。</p>

<p><a href=""><img src="file:///Users/alexhilton/Downloads/navi.png" title="auto auto" ></a></p>

<!-- more -->


<p>在移动应用中，某些 UI 元素会在多种上下文中贯穿整个用户界面。对于用于导航的 UI 元素尤其如此，例如：</p>

<ol>
<li>导航栏和导航栏。</li>
<li>顶部和底部应用栏。</li>
<li>浮动操作按钮。</li>
</ol>


<p>在为这些屏幕构建 UI 时，通常有两种布局方式：</p>

<ol>
<li>根级 UI 元素：整个应用在根级脚手架布局中共享这些元素的单个实例。在 Android 上，这通常处于 Activity 或 NavHostFragment 级别。</li>
<li>每个屏幕的 UI 元素：每个导航目标负责绘制自己的 UI 元素。</li>
</ol>


<p>因此，问题是，一种方法通常比另一种更好吗？它们可以共存吗？令人满意的是，我认为这是经典的软件工程“视情况而定”答案不适用的少数情况之一。我坚信，对于 Jetpack Compose 应用，应该始终优先采用每个屏幕的 UI 元素方法。让我们简要回顾一下过去。</p>

<h2>根级 UI 元素</h2>

<p>在 Android 上，根级 UI 元素的起源可以追溯到最初的 Activity ActionBar API 以及随后引入的 Fragment API。Fragment 可以调用：</p>

<ol>
<li>getSupportActionBar() 在其父 Activity 中设置标题和其他 ActionBar 属性。</li>
<li>setHasOptionsMenu() 在其父 Activity 中更新菜单项。</li>
</ol>


<p><img src="https://storage.googleapis.com/tunji-web-public/articles/68248e8ecc8e85f53ce1aa46/action-bar.png" alt="经典的ActionBar" /></p>

<p>由于 Activity 拥有 ActionBar，这隐式地建立了层级关系。这与转向单 Activity 架构相结合，为在某个根级别管理顶级装饰（例如浮动操作按钮、AppBar 和导航栏）奠定了基调。当然，这有利有弊：</p>

<h3>优点</h3>

<ul>
<li>真正的持久性：UI 元素是同一个实例，保证了视觉一致性，无需在实例之间进行复杂的过渡。这对于使用浮动操作按钮的应用尤其有利，因为屏幕过渡不会因为每个屏幕使用不同的 FAB 实例而引入 UI/UX 噪音。</li>
</ul>


<h3>缺点</h3>

<ul>
<li>紧密耦合：屏幕与宿主 Activity 的实现细节和框架 API 紧密耦合。</li>
<li>复杂的状态管理：宿主 Activity 成为瓶颈，需要复杂的逻辑来更新每个特定屏幕的标题、菜单选项、FAB 可见性/图标/操作，尤其是在屏幕进行动画处理时。这会导致扩展性不佳。</li>
<li>灵活性受限：更改工具栏样式、在特定屏幕上彻底移除工具栏或处理边缘情况（如果不给主机增加更多条件复杂性）变得困难。</li>
<li>测试挑战：由于屏幕依赖于主机 Activity 提供必要的 UI 组件和配置钩子，因此单独测试屏幕变得更加困难。</li>
</ul>


<h2>每个屏幕的 UI 元素</h2>

<p>根级 UI 元素的弊端非常严重，以至于 fragment 的 setHasOptionsMenu() 方法在 2022 年被弃用。尽管 MenuHost 和 MenuProvider API 中提供了替代方案，但这主要是为了保持向后兼容性。</p>

<p>至关重要的是，Jetpack Compose 已经发布了 1.1.1 版本，值得注意的是，它没有提供 ActionBar 或类似 MenuHost 的 API。事实上，最接近于提供如何管理导航目的地通用框架功能的 API 是 Scaffold 可组合组件。有趣的是，它：</p>

<ul>
<li>material3 Compose 库中的一个自成体系的实现。</li>
<li>是一个基于每个屏幕的 UI 元素实现，为应用栏、浮动操作按钮等提供插槽。</li>
<li>隐式地鼓励应用中的导航目的地替换整个屏幕内容，包括其特定的应用栏、浮动操作按钮等。</li>
</ul>


<p><img src="https://storage.googleapis.com/tunji-web-public/articles/68248e8ecc8e85f53ce1aa46/scaffold_resized.png" alt="Now In Android 应用中脚手架" /></p>

<p>同样，我们可以列出优缺点：</p>

<h3>优点</h3>

<ul>
<li>封装和模块化：每个导航目的地都是独立的，并管理其自身的UI元素及其状态。这符合单一职责原则。</li>
<li>高度灵活性：导航目的地可以轻松自定义持久UI元素，而不会影响其他元素。需要完全自定义的应用栏？没问题。不需要浮动操作按钮？那就不要添加它。</li>
<li>简化状态管理：UI状态（标题、菜单项、导航栏状态）在屏幕的ViewModel或可组合状态中进行本地管理，使其更易于推理。</li>
<li>提高可测试性：导航目的地可以更轻松地进行独立测试。</li>
<li>解耦：导航目的地与宿主Activity在这些特定的UI元素方面解耦。</li>
</ul>


<h3>缺点</h3>

<ul>
<li>代码重复：如果没有适当的结构化，导航目的地之间可能会重复使用常用的UI元素。</li>
<li>沉浸感受损：要使相同的应用栏或浮动操作按钮在屏幕之间顺利保持/转换，需要明确的过渡处理。</li>
</ul>


<h2>持久 UI 的 UI 层架构</h2>

<p>通过比较这两种实现方式的优缺点，我们可以得出这样的印象：无论我们在 Compose 中使用每个屏幕的 UI 来降低复杂性方面获得了什么好处，我们都需要付出代价才能在 UX 中真正传达出 UI 元素是持久的，如下面的屏幕记录所示。</p>

<p><img src="https://storage.googleapis.com/tunji-web-public/articles/68248e8ecc8e85f53ce1aa46/noise_cropped.gif" alt="Bluesky 应用程序中的多个 FAB" /></p>

<p>不过，有一个简单的解决方案：Compose 共享元素过渡和动画修改器 API，以及精心设计的 UI 层架构。</p>

<h3>持久化 UI 和 UI 逻辑</h3>

<p>上述动画 API 的入口点位于它们提供的作用域中：SharedTransitionScope 和 AnimatedVisibilityScope。对于导航目的地过渡，两者几乎总是串联使用，因此创建一个继承自两者的 UI 逻辑状态持有者非常有用。我个人喜欢将其称为 ScaffoldState。此 ScaffoldState 应该位于一个公共模块中，应用中所有显示导航目的地的模块都可以访问。我通常将此模块称为脚手架。</p>

<p><strong>注意：</strong> 请勿将此处提到的 ScaffoldState 与原始 Material Compose 库中的 ScaffoldState 混淆。它是一个遗留实现，在 Compose Material3 中没有等效实现。</p>

<p>ScaffoldState 的定义可以简单如下：</p>

<pre><code class="Kotlin">class ScaffoldState internal constructor(
    animatedVisibilityScope: AnimatedVisibilityScope,
    sharedTransitionScope: SharedTransitionScope,
    internal val isMediumScreenWidthOrWider: State&lt;Boolean&gt;,
) : AnimatedVisibilityScope by animatedVisibilityScope,
    SharedTransitionScope by sharedTransitionScope {

    internal val canShowBottomNavigation get() = !isMediumScreenWidthOrWider.value

    internal val canShowNavRail get() = isMediumScreenWidthOrWider.value
                                            // implementation omitted
                                            &amp;&amp; isAtDeviceEdge
}
</code></pre>

<p><strong>注意：</strong> canShowBottomNavigation 和 canShowNavRail 并不一定意味着它们各自的界面元素一定会显示；这取决于在脚手架内实际调用 Composable 的情况（如下所述）。相反，它们定义了界面元素在被调用时能够显示的界面逻辑。</p>

<p>ScaffoldState 有一个内部构造函数，其他模块可能无法创建它。相反，它们会使用同样在 scaffold 模块中定义的实用方法来记住它在组合中的实例：</p>

<pre><code class="Kotlin">@Composable
fun rememberScaffoldState(
    animatedVisibilityScope: AnimatedVisibilityScope,
    sharedTransitionScope: SharedTransitionScope,
) : ScaffoldState {
    val isMediumScreenWidthOrWider = isMediumScreenWidthOrWider()
    return remember {
        ScaffoldState(
            animatedVisibilityScope = animatedVisibilityScope,
            sharedTransitionScope = sharedTransitionScope,
            isMediumScreenWidthOrWider = isMediumScreenWidthOrWider,
        )
    }
}

@Composable
private fun isMediumScreenWidthOrWider(): State&lt;Boolean&gt; { 
    val isMediumScreenWidthOrWider = currentWindowAdaptiveInfo()
        .windowSizeClass
        .isWidthAtLeastBreakpoint(WindowSizeClass.WIDTH_DP_MEDIUM_LOWER_BOUND)

    return rememberUpdatedState(isMediumScreenWidthOrWider)
}
</code></pre>

<p>上文中，定义显示哪个导航 UI 元素的 UI 逻辑是通过 ScaffoldState 中的 WindowSizeClass 实现的。AnimatedVisibilityScope 和 SharedTransitionScope 参数被显式传入。前者通常由导航库在定义目的地时提供，后者则由 CompositionLocal 或 prop drilling 提供。后面会介绍 CompositionLocal 的使用示例。</p>

<h3>持久化 UI 脚手架</h3>

<p>通过定义记住组合中 ScaffoldState 的方法，实际的 PersistentScaffold Composable 如下：</p>

<pre><code class="Kotlin">@Composable
fun ScaffoldState.PersistentScaffold(
    modifier: Modifier = Modifier,
    topBar: @Composable ScaffoldState.() -&gt; Unit = {},
    floatingActionButton: @Composable ScaffoldState.() -&gt; Unit = {},
    navigationBar: @Composable ScaffoldState.() -&gt; Unit = {},
    navigationRail: @Composable ScaffoldState.() -&gt; Unit,
    content: @Composable ScaffoldState.(PaddingValues) -&gt; Unit,
) {
    NavigationRailScaffold(
        modifier = modifier,
        navigationRail = navigationRail,
        content = {
            Scaffold(
                modifier = modifier
                    .animateBounds(lookaheadScope = this),
                topBar = {
                    topBar()
                },
                floatingActionButton = {
                    floatingActionButton()
                },
                bottomBar = {
                    navigationBar()
                },
                content = { paddingValues -&gt;
                    content(paddingValues)
                },
            )
        }
    )
}
</code></pre>

<p><strong>注意：</strong> 在上面的定义中，持久 UI 元素的每个可组合插槽都以 ScaffoldState 作为接收器，并且当 navigationRail 或 navigationBar 隐藏或显示时，使用 Modifier.animateBounds() 对 Scaffold 进行动画处理。</p>

<p>上面使用了一个中间可组合项：NavigationRailScaffold。这只是一个简单的 Row，包含两个项目：navigationRail 和 content：</p>

<pre><code class="Kotlin">@Composable
private inline fun NavigationRailScaffold(
    modifier: Modifier = Modifier,
    navigationRail: @Composable () -&gt; Unit,
    content: @Composable () -&gt; Unit,
) {
   Row(
        modifier = modifier,
        content = {
            Box(
                modifier = Modifier
                    .widthIn(max = 80.dp)
                    .zIndex(2f),
            ) {
                navigationRail()
            }
            Box(
                modifier = Modifier
                    .fillMaxSize()
                    .zIndex(1f),
            ) {
                content()
            }
        },
    )
}
</code></pre>

<p><strong>注意：</strong> 导航轨道的 z 索引比内容更高。</p>

<p>遗憾的是，NavigationSuiteScaffold 的 API 集无法在此处使用，因为与普通的 Scaffold 可组合函数不同，它们不允许通过插槽访问构成脚手架的持久化 UI 元素，因此无法将 Modifier 实例传递给它们。这使得本文的其余部分不适用于 NavigationSuiteScaffold。</p>

<h3>持久化 UI 元素作为 UI 逻辑的扩展</h3>

<p>为了营造这些 UI 元素在导航目标之间持久化的视觉效果，可以将这些 UI 元素的可组合函数编写为 ScaffoldState 的扩展，从而提供对 SharedTransitionScope 的访问权限，以便为元素提供共享元素修饰符。这些定义也应位于脚手架模块中。例如，PersistentNavigationAppBar 可以是：</p>

<pre><code class="Kotlin">@Composable
fun ScaffoldState.PersistentNavigationBar(
    modifier: Modifier = Modifier,
    enterTransition: EnterTransition = slideInVertically(initialOffsetY = { it }),
    exitTransition: ExitTransition = slideOutVertically(targetOffsetY = { it }),
    content: @Composable RowScope.() -&gt; Unit
) {
   AnimatedVisibility(
       modifier = modifier
            .sharedElement(
                sharedContentState = rememberSharedContentState(
                    BottomNavSharedElementKey
                ),
                animatedVisibilityScope = this,
                zIndexInOverlay = BottomNavSharedElementZIndex,
            ),
        visible = canShowBottomNavigation,
        enter = enterTransition,
        exit = exitTransition,
        content = {
            NavigationBar { ... },
        }
    )
}

private data object BottomNavSharedElementKey
</code></pre>

<p><strong>注意：</strong> canShowBottomNavigation 是从 ScaffoldState 读取的，用于 AnimatedVisibility。</p>

<p>可以为其他持久性 UI 元素（例如导航栏或浮动操作按钮）编写同类扩展。功能模块可以依赖于脚手架模块，并按如下方式使用脚手架：</p>

<pre><code class="Kotlin">    @Composable
    fun FeedRoute(
        viewModel: ListingFeedViewModel,
        //从导航库中获取。
        // 在 Navigation Compose 中，它由composable&lt;Destination&gt; { } lambda 提供。
        animatedVisibilityScope: AnimatedVisibilityScope,
        // 从导航目的地声明中传递。
        sharedTransitionScope: SharedTransitionScope,
    ) { route -&gt;
        rememberScaffoldState(
            animatedVisibilityScope = animatedVisibilityScope,
            sharedTransitionScope = sharedTransitionScope,
        ).PersistentScaffold(
            topBar = {
                TopAppBar(
                    title = {
                        Text(text = stringResource(id = R.string.listing_app))
                    },
                )
            },
            content = { paddingValues -&gt;
                ListingFeedScreen(
                    modifier = Modifier
                        .padding(paddingValues),
                    scaffoldState = this,
                    state = viewModel.state.collectAsStateWithLifecycle().value,
                    actions = viewModel.accept
                )
            },
            navigationBar = {
               PersistentNavigationAppBar(
                    modifier = Modifier
                        .animateEnterExit(
                            enter = slideInVertically(initialOffsetY = { it }),
                            exit = slideOutVertically(targetOffsetY = { it }),
                        )
                )
            },
            navigationRail = {
                PersistentNavigationNavRail()
            }
        )
    }
</code></pre>

<p>每个使用的 API 以及它们支持的 UI/UX 如下所示：</p>

<p><img src="https://storage.googleapis.com/tunji-web-public/articles/68248e8ecc8e85f53ce1aa46/shared_elements_cropped.gif" alt="A" /></p>

<p><img src="https://storage.googleapis.com/tunji-web-public/articles/68248e8ecc8e85f53ce1aa46/navigation_changes_cropped.gif" alt="B" /></p>

<p><img src="https://storage.googleapis.com/tunji-web-public/articles/68248e8ecc8e85f53ce1aa46/local_changes_cropped.gif" alt="C" /></p>

<p>从上到下：跨导航目的地的持久 UI 共享元素、跨导航目的地的持久 UI 进入和退出以及同一目的地内的持久 UI 进入和退出。</p>

<p>如上表所示，使用 ScaffoldState 作为界面状态容器，可以根据 Jetpack Compose 动画 API 的优势进行定制，同时将它们组合成一个整体。更详细地说：</p>

<ol>
<li>ScaffoldState 和 Modifier.sharedElement()：在不同导航目标上调用的持久化界面元素将使用共享元素 API 来保持视觉连续性。在所示的示例中，每个导航目标都负责其自身的浮动操作按钮，但仍保持了持久化的效果。在此特定示例中，图库目标脚手架与详情目标完全相同，只是它使用不同的参数调用 PersistentFab。</li>
<li>ScaffoldState 和 AnimatedContent：持久化界面元素的调用可以使用 Modifier.animateEnterExit() 来定义 EnterTransition 和/或 ExitTransition 来用于导航更改。在此示例中，持久化导航栏通过垂直滑动来动画化地显示和隐藏。在此特定示例中，详情目标脚手架与动态目标完全相同，但以下几点不同：</li>
<li>不调用 PersistentNavigationAppBar。</li>
<li>调用 PersistentFab。</li>
<li>ScaffoldState、AnimatedVisibility 和 Modifier.animateBounds()：调用 PersistentNavigationAppBar 和/或 PersistentNavigationNavRail 会根据当前 WindowSizeClass（即本地屏幕变化）自动隐藏或显示。当其中一个显示或隐藏时，内容可组合项会根据变化调整其大小和位置。用户还可以直接将 EnterTransition 或 ExitTransition 传递给可组合项来自定义动画。</li>
</ol>


<h3>持久的 UI 和业务逻辑</h3>

<p>像导航栏或导航栏这样的持久性 UI 有时需要显示与其本地上下文相距甚远的状态；这就是业务逻辑。有时，这些信息可能位于不同的模块中。例如：</p>

<ul>
<li>未显示通知的通知标记。</li>
<li>消息的未读计数。</li>
<li>用户个人资料警报或提醒。</li>
</ul>


<p>在这种情况下，你的应用应该定义一个 AppState。在 Now In Android 示例中，这个 AppState 是 NiaAppState。在跨导航目标使用持久性 UI 时，这个 AppState 至关重要，因为它可以访问应用的导航语义以及填充导航栏中当前项目所需的所有资源。最简单的 AppState 可能如下所示：</p>

<pre><code class="Kotlin">@Stable
class AppState(
    private val navigationStateHolder: NavigationStateHolder,
) {
    private val navState by navigationStateHolder.state

    lateinit var sharedTransitionScope: SharedTransitionScope

    val navItems: List&lt;NavItem&gt; get() = navItemsFrom(navState)
}
</code></pre>

<p><strong>注意：</strong> 在上面，导航状态由 Compose 状态支持，但是当使用带有 NavigationController 的导航 API 时，这仍然适用。</p>

<p>AppState 是应用层级服务的入口点。应用的导航状态、应用能够显示的窗格数量等等都驻留在 AppState 中。它可能需要访问业务逻辑，并且通常需要依赖注入的数据源。在 Now In Android 示例中，NiaAppState 使用数据源来确定哪些选项卡带有通知标记。</p>

<p>为了从 AppState 为持久化 UI 元素提供状态，ScaffoldState 应该依赖 AppState 作为内部实现细节，并作为状态持有者复合的示例：</p>

<pre><code class="Kotlin">class ScaffoldState internal constructor(
    ...
    internal val appState: AppState
) : AnimatedVisibilityScope by animatedVisibilityScope,
    // 从 AppState 中检索 SharedTransitionScope
    SharedTransitionScope by appState.sharedTransitionScope {

    ...

    internal val canShowNavRail
        get() = appState.isInEdgePane &amp;&amp; isMediumScreenWidthOrWider.value
}

internal val LocalAppState = staticCompositionLocalOf&lt;AppState&gt; {
    throw IllegalArgumentException("AppState must be provided in the app scaffolding.")
}
</code></pre>

<p>要检索要使用的 AppState，脚手架模块中应该有一个内部 LocalAppState 定义以及一个 App Composable。然后，此 AppState 会在应用的入口点提供给组合树，以便进行 Composing。</p>

<pre><code class="Kotlin">@Composable
fun App(
    modifier: Modifier,
    appState: AppState,
) {
    AppTheme {
        Surface {
            // 根 LookaheadScope 用于锚定所有共享元素转换
            SharedTransitionLayout(
                modifier = modifier.fillMaxSize()
            ) {
                // 你可以选择保留对 SharedElementTransitionScope 的引用
                appState.sharedElementTransitionScope = this@SharedTransitionLayout
                CompositionLocalProvider(
                    LocalAppState provides appState,
                ) {
                    // 应用 UI 的其余部分都放在这里，例如 `NavHost`，等等。
                }
            }
        }
    }
}

internal val LocalAppState = staticCompositionLocalOf&lt;AppState&gt; {
    throw IllegalStateException("CompositionLocal LocalAppState not present")
}
</code></pre>

<p>在 Android 应用程序中，上述内容将在活动中使用，类似于以下内容：</p>

<pre><code class="Kotlin">
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        enableEdgeToEdge()
        super.onCreate(savedInstanceState)

        // 在此处创建你的应用状态。如果它需要依赖注入的数据源
        // 或访问导航控制器或导航状态，也请在此处提供或在 Composition 中提供。

        val appState: AppState = ...

        setContent {
            App(
                modifier = Modifier,
                appState = appState,
            )
        }
    }
}
</code></pre>

<p>接下来，用于记住 ScaffoldState 的调用站点将更新为：</p>

<pre><code class="Kotlin">@Composable
fun rememberScaffoldState(
    // 这是由导航库提供的
    animatedVisibilityScope: AnimatedVisibilityScope,
) : ScaffoldState {
    val isMediumScreenWidthOrWider = isMediumScreenWidthOrWider
    val appState = LocalAppState.current
    return remember {
        ScaffoldState(
            animatedVisibilityScope = animatedVisibilityScope,
            isMediumScreenWidthOrWider = isMediumScreenWidthOrWider,
            // SharedTransitionScope 现在由 AppState 提供
            appState = appState,
        )
    }
}
</code></pre>

<p><strong>注意：</strong> LocalAppState 应该位于脚手架模块内部。</p>

<p>只需指定要运行的修饰符或转换即可声明 PersistentNavigationAppBar：</p>

<pre><code class="Kotlin">fun ScaffoldState.PersistentNavigationAppBar(
    modifier: Modifier = Modifier,
    ...,
) {
    AnimatedVisibility(
       modifier = modifier
            .sharedElement(...),
        ...,
        content = {
            NavigationBar {
                val appState = LocalAppState.current
                appState.navItems.forEach { item -&gt;
                    NavigationBarItem(...)
                }
            }
        },
    )
}
</code></pre>

<h2>真正的持久化 UI</h2>

<p>如果持久化 UI 元素中存在一些无法通过共享元素保存的局部瞬时状态，则可以使用可移动共享元素。请考虑此处描述和实现的导航栏设计，其中选中某个选项卡时，选项卡之间会呈现动画效果：</p>

<p><img src="https://storage.googleapis.com/tunji-web-public/articles/68248e8ecc8e85f53ce1aa46/transient_animation.gif" alt="导航栏中的局部瞬态动画" /></p>

<p>幻想只能到此为止，此时需要真正的持久性。这可以通过添加可移动内容 API 来创建可移动的共享元素来实现。也就是说，架构将提升的不仅仅是 UI 状态，而是整个 UI 元素及其状态。要了解更多关于为什么此时需要可移动内容 API 的信息，请阅读以下详细介绍<a href="https://www.tunjid.com/articles/3-neat-animations-you-can-create-with-modifieranimatebounds-67e474130e9ba862fe18b5e5?open-graph-scrape=true">组合持久性概念的文章</a>。</p>

<p>在 Compose 中使用 movedContentOf 时，必须注意确保可移动内容每次只在一个位置进行组合。例如，从目的地 A 导航到目的地 B 时，在动画持续时间内，有两个目的地可组合项共存：</p>

<ol>
<li>目的地 A 动画退出。</li>
<li>目的地 B 动画进入。</li>
</ol>


<p>动画启动后，可移动导航栏必须立即与目的地 A 中的诱饵导航栏进行交换，同时，必须立即在目的地 B 开始组合。以下概述了实现此目的的界面逻辑。</p>

<h3>定义可移动持久界面</h3>

<p>ScaffoldState 导航栏首先将其声明拆分。仅依赖于 AppState 的部分作为 AppState 的扩展单独编写：</p>

<pre><code class="Kotlin">@Composable
internal fun AppState.NavigationBar(
    modifier: Modifier = Modifier,
) {
    NavigationBar(
        modifier = modifier,
    ) {
        navItems.forEach { item -&gt;
            NavigationBarItem(...)
        }
    }
}
</code></pre>

<h3>提升可移动持久化 UI</h3>

<p>真正持久化的导航栏 (NavigationBar) 可以使用可移动内容 (movableContentOf) 提升到 AppState 中：</p>

<pre><code class="Kotlin">class AppState(
    ...
) {
    internal val movableNavigationBar = movableContentOf&lt;Modifier&gt; { modifier -&gt;
        NavigationBar(
            modifier = modifier,
        )
    }
}
</code></pre>

<h3>可移动持久 UI 的 UI 逻辑</h3>

<p>定义可移动导航栏后，将确定何时可以安全组合的逻辑添加到 ScaffoldState 中：</p>

<pre><code class="Kotlin">class ScaffoldState internal constructor(
    ...
    internal val appState: AppState
) : AnimatedVisibilityScope by animatedVisibilityScope,
    SharedTransitionScope by appState.sharedTransitionScope {

    internal val canShowNavigationBar get() = !isMediumScreenWidthOrWider

    internal val canUseMovableNavigationBar
        // 从 AnimatedVisibility Scope 读取过渡目标状态
        get() = canShowNavigationBar &amp;&amp; transition.targetState == EnterExitState.Visible
}
</code></pre>

<h3>构建可移动的持久化 UI</h3>

<p>最后，在 ScaffoldState 的公共扩展方法中，根据 ScaffoldState 中定义的 UI 逻辑，在 AppState 中的持久化 UI 元素与其诱饵元素之间进行切换：</p>

<pre><code class="Kotlin">@Composable
fun ScaffoldState.PeristentNavigationBar(
    modifier: Modifier = Modifier,
    ...
) {
    AnimatedVisibility(
        modifier = modifier
            .sharedElement(...),
        visible = canShowNavigationBar,
        ...
        content = {
            if (canUseMovableNavigationBar) appState.movableNavigationBar(
                Modifier,
            )
            else appState.NavigationBar(
                modifier = Modifier,
            )
        },
    )
}
</code></pre>

<p>其结果如下所示：</p>

<p><img src="https://storage.googleapis.com/tunji-web-public/articles/68248e8ecc8e85f53ce1aa46/cropped_persistent_navigation_bar.gif" alt="使用可移动内容 (movableContentOf) 在导航栏中保留局部瞬态动画" /></p>

<h2>总结</h2>

<p>以上描述了一种用于应用持久化 UI 的架构模式。该架构的一大优势在于它能够扩展到平板电脑和桌面设备；这将在后续的博客文章中介绍。</p>

<p>总结一下，该架构支持以下功能：</p>

<ul>
<li>导航目标控制持久化 UI 动画，用于导航目标内部的局部变化，例如窗口大小变化。</li>
<li>导航目标控制持久化 UI 动画，用于跨导航目标进行导航变化。</li>
<li>完全自定义每个导航目标上哪些 UI 元素是持久化的，哪些不是。</li>
<li>一种将持久化 UI 元素描述为导航目标 ScaffoldState 函数的模式。</li>
<li>能够将具有内部瞬态状态的 UI 元素提升到 AppState，这些 UI 元素驱动的动画无法通过不同实例之间的共享元素过渡来近似实现。</li>
</ul>


<p>使用脚手架模块或类似组件，将 AppState 的细粒度控制分发到导航目标。</p>

<p><a href="https://github.com/tunjid/listingApp?open-graph-scrape=true">这里</a>可以看到一个带有脚手架模块、AppState 和每个导航目的地定制的应用程序中上述内容的示例。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Kotlin Multiplatform项目中使用DataStore]]></title>
    <link href="https://alexhilton.github.io/blog/2025/06/04/datastore-in-kmp/"/>
    <updated>2025-06-04T23:05:35+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/06/04/datastore-in-kmp</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Implementing DataStore in Kotlin Multiplatform Projects」，原文链接<a href="https://carrion.dev/en/posts/datastore-in-kmp/">https://carrion.dev/en/posts/datastore-in-kmp/</a>，由 Ignacio Carrión发布于2025年5月9日。</p></blockquote>

<p>DataStore 是 Google 开发的一种现代数据存储解决方案，用于替代 SharedPreferences。它提供了一个一致、类型安全的 API，用于存储键值对和类型化对象，并支持 Kotlin 协程和 Flow。随着 Kotlin Multiplatform (KMP) 的最新进展，我们现在可以将 DataStore 集成到 KMP 项目中，从而实现跨平台共享偏好设置和数据存储代码。这篇博文探讨了如何在 KMP 环境中配置、实现和优化 DataStore。</p>

<p><a href=""><img src="file:///Users/alexhilton/Downloads/datastore.png" title="auto auto" ></a></p>

<!-- more -->


<h2>理解 Kotlin 多平台环境中的 DataStore</h2>

<p>KMP 中的 DataStore 旨在提供跨平台一致的 API，同时利用平台特定的存储机制。DataStore 有两种类型：</p>

<ol>
<li>Preferences DataStore：用于存储键值对</li>
<li>Proto DataStore：用于使用协议缓冲区存储类型化对象</li>
</ol>


<p>在 KMP 上下文中，DataStore：</p>

<ol>
<li>平台特定的实现提供实际的存储机制</li>
<li>API 使用协程和 Flow，跨平台保持一致</li>
</ol>


<p>这种方法使我们能够用通用代码定义数据访问模式，而底层存储操作则由平台特定的实现处理。</p>

<pre><code class="Kotlin">// In commonMain - DataStore interface
interface UserPreferences {
    val userData: Flow&lt;UserData&gt;
    suspend fun updateUsername(name: String)
    suspend fun updateEmail(email: String)
    suspend fun clearData()
}

// In commonMain - Data model
data class UserData(
    val username: String = "",
    val email: String = "",
    val isLoggedIn: Boolean = false
)
</code></pre>

<h2>在 KMP 项目中设置数据存储</h2>

<p>要将 DataStore 集成到你的 KMP 项目中，你需要正确配置构建文件。以下是分步指南：</p>

<h3>1. 在共享模块中配置 build.gradle.kts 文件</h3>

<pre><code class="Kotlin">plugins {
    kotlin("multiplatform")
    id("com.android.library")
    id("com.google.devtools.ksp") version "2.1.20-2.0.1" // For Proto DataStore
}

kotlin {
    androidTarget()
    iosX64()
    iosArm64()
    iosSimulatorArm64()

    sourceSets {
        val commonMain by getting {
            dependencies {
                // For Preferences DataStore
                implementation("androidx.datastore:datastore-preferences-core:1.1.0")

                // For coroutines
                implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3")
            }
        }
    }
}
</code></pre>

<h3>2. 从通用代码创建 DataStore 实例</h3>

<pre><code class="Kotlin">/**
 * 获取单例 DataStore 实例，如有必要则创建它。
 */
fun createDataStore(producePath: () -&gt; String): DataStore&lt;Preferences&gt; =
   PreferenceDataStoreFactory.createWithPath(
      produceFile = { producePath().toPath() }
   )

internal const val dataStoreFileName = "dice.preferences_pb"
</code></pre>

<h2>特定平台的考虑因素</h2>

<h3>Android 实现</h3>

<pre><code class="Kotlin">// shared/src/androidMain/kotlin/DataStore.kt

fun createDataStoreAndroid(context: Context): DataStore&lt;Preferences&gt; = createDataStore(
   producePath = { context.filesDir.resolve(dataStoreFileName).absolutePath }
)
</code></pre>

<h3>iOS 实现</h3>

<pre><code class="Kotlin">// shared/src/iosMain/kotlin/DataStore.kt

fun createDataStoreIOS(): DataStore&lt;Preferences&gt; = createDataStore(
   producePath = {
      val documentDirectory: NSURL? = NSFileManager.defaultManager.URLForDirectory(
         directory = NSDocumentDirectory,
         inDomain = NSUserDomainMask,
         appropriateForURL = null,
         create = false,
         error = null,
      )
      requireNotNull(documentDirectory).path + "/$dataStoreFileName"
   }
)
</code></pre>

<h2>实际示例：实现用户偏好存储库</h2>

<p>为了演示完整的实现，让我们创建一个使用 DataStore 的存储库：</p>

<pre><code class="Kotlin">// In commonMain
class UserPreferencesRepository(private val dataStore: PreferencesDataStore) {
    //定义preferences的键
    private object PreferenceKeys {
        val USERNAME = stringPreferencesKey("username")
        val EMAIL = stringPreferencesKey("email")
        val IS_LOGGED_IN = booleanPreferencesKey("is_logged_in")
    }

    // Get user data as a Flow
    val userData: Flow&lt;UserData&gt; = dataStore.data.map { preferences -&gt;
        UserData(
            username = preferences[PreferenceKeys.USERNAME] ?: "",
            email = preferences[PreferenceKeys.EMAIL] ?: "",
            isLoggedIn = preferences[PreferenceKeys.IS_LOGGED_IN] ?: false
        )
    }

    // Update username
    suspend fun updateUsername(name: String) {
        dataStore.updateData { preferences -&gt;
            preferences.toMutablePreferences().apply {
                this[PreferenceKeys.USERNAME] = name
            }
        }
    }

    // Update email
    suspend fun updateEmail(email: String) {
        dataStore.updateData { preferences -&gt;
            preferences.toMutablePreferences().apply {
                this[PreferenceKeys.EMAIL] = email
            }
        }
    }

    // Set login status
    suspend fun setLoggedIn(isLoggedIn: Boolean) {
        dataStore.updateData { preferences -&gt;
            preferences.toMutablePreferences().apply {
                this[PreferenceKeys.IS_LOGGED_IN] = isLoggedIn
            }
        }
    }

    // Clear all data
    suspend fun clearData() {
        dataStore.updateData { preferences -&gt;
            preferences.toMutablePreferences().apply {
                remove(PreferenceKeys.USERNAME)
                remove(PreferenceKeys.EMAIL)
                remove(PreferenceKeys.IS_LOGGED_IN)
            }
        }
    }
}

// In commonMain - ViewModel or Presenter
class UserViewModel(private val userPreferencesRepository: UserPreferencesRepository) {
    val userData: Flow&lt;UserData&gt; = userPreferencesRepository.userData

    suspend fun updateUserProfile(username: String, email: String) {
        if (username.isNotBlank()) {
            userPreferencesRepository.updateUsername(username)
        }

        if (email.isNotBlank()) {
            userPreferencesRepository.updateEmail(email)
        }
    }

    suspend fun login() {
        userPreferencesRepository.setLoggedIn(true)
    }

    suspend fun logout() {
        userPreferencesRepository.setLoggedIn(false)
    }

    suspend fun clearUserData() {
        userPreferencesRepository.clearData()
    }
}
</code></pre>

<h2>KMP 中的高级数据存储功能</h2>

<p>DataStore 提供了几种可在 KMP 环境中利用的高级功能：</p>

<h3>1. 用于类型化对象的 Proto DataStore</h3>

<p>如果你需要存储复杂对象，Proto DataStore 提供了一个类型安全的解决方案：</p>

<pre><code class="proto">// 在 .proto 文件中定义数据结构
syntax = "proto3";

option java_package = "com.example.app";
option java_multiple_files = true;

message UserPreferences {
  string username = 1;
  string email = 2;
  bool is_logged_in = 3;
}
</code></pre>

<pre><code class="Kotlin">// In commonMain - 创建序列化器
class UserPreferencesSerializer : Serializer&lt;UserPreferences&gt; {
    override val defaultValue: UserPreferences = UserPreferences.getDefaultInstance()

    override suspend fun readFrom(input: InputStream): UserPreferences {
        return UserPreferences.parseFrom(input)
    }

    override suspend fun writeTo(t: UserPreferences, output: OutputStream) {
        t.writeTo(output)
    }
}

// Proto DataStore 的平台特定实现
</code></pre>

<h3>2.数据迁移</h3>

<pre><code class="Kotlin">// In androidMain - 从 SharedPreferences 迁移到 DataStore
val dataStore = context.createDataStore(
    name = "user_preferences",
    produceMigrations = { context -&gt;
        listOf(
            SharedPreferencesMigration(
                context = context,
                sharedPreferencesName = "legacy_preferences"
            )
        )
    }
)
</code></pre>

<h3>3.处理异常</h3>

<pre><code class="Kotlin">// In commonMain - 数据操作过程中的异常处理
val userData = dataStore.data
    .catch { exception -&gt;
        // 处理异常（例如数据损坏）
        if (exception is IOException) {
            emit(emptyPreferences())
        } else {
            throw exception
        }
    }
    .map { preferences -&gt;
        // Map preferences to your data model
        UserData(
            username = preferences[USERNAME] ?: "",
            email = preferences[EMAIL] ?: ""
        )
    }
</code></pre>

<h2>KMP 中数据存储的最佳实践</h2>

<ol>
<li>利用协程和 Flow 进行异步操作

<ul>
<li>DataStore 操作本质上是异步的</li>
<li>使用 Flow 观察存储数据的变化</li>
<li>应用 Map、Filter 和 Combine 等 Flow 操作符进行数据转换</li>
</ul>
</li>
<li>创建存储库层

<ul>
<li>将 DataStore 操作抽象到存储库后面</li>
<li>这样可以更轻松地根据需要切换实现</li>
<li>为你的业务逻辑提供简洁的 API</li>
</ul>
</li>
<li>优雅地处理错误

<ul>
<li>使用 catch 操作符处理 Flow 中的异常</li>
<li>在无法读取数据时提供回退值</li>
<li>考虑为关键操作实现重试机制</li>
</ul>
</li>
<li>优化性能

<ul>
<li>最大限度地减少 DataStore 更新次数</li>
<li>将相关的更改集中处理</li>
<li>使用 distinctUntilChanged() 避免不必要的排放</li>
</ul>
</li>
<li>彻底测试你的 DataStore 代码

<ul>
<li>在 commonTest 中为你的存储库编写测试</li>
<li>使用测试替身模拟不同的场景</li>
</ul>
</li>
</ol>


<h2>结论</h2>

<p>将 DataStore 集成到 Kotlin Multiplatform 项目中，提供了一种现代化、类型安全的跨平台数据存储和访问方法。</p>

<p>本文概述的方法提供了一种实用的方法，可以跨平台共享首选项和数据存储逻辑，并且只需极少的平台特定代码。DataStore 对协程和 Flow 的支持使其与 KMP 项目完美契合，能够通过一致的 API 实现响应式和异步数据操作。</p>

<p>通过遵循本文概述的配置步骤、平台特定注意事项和最佳实践，你可以在 KMP 项目中成功实现 DataStore，并创建稳定、高效的跨平台数据存储解决方案，并且只需极少的平台特定代码。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[揭秘原生View与Jetpack Compose之间的传送门]]></title>
    <link href="https://alexhilton.github.io/blog/2025/06/02/android-vies-in-compose/"/>
    <updated>2025-06-02T21:44:19+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/06/02/android-vies-in-compose</id>
    <content type="html"><![CDATA[<p>芳菲随春去，碧绿入夏来，不知不觉中<a href="https://juejin.cn/column/7367555191338467337">Compose专题</a>已经写了近40篇文章了，从Compose各组件的使用方法，到Compose的编程思想，再到内部原理和最佳实践。通过<a href="https://juejin.cn/column/7367555191338467337">这一系列的文章</a>相信对Compose已经有了足够的理解，能够在项目中进行实战和运用。学无止境，今天将继续学习，重点探讨如何在已有的项目中使用Compose。</p>

<p><a href=""><img src="file:///Users/alexhilton/Downloads/portal_2.png" title="auto auto" ></a></p>

<!-- more -->


<h2>缘起</h2>

<p>无疑Jetpack Compose是一个优秀的声明式UI框架，它与原生的View方式最大的区别，在于思考问题的方式上并不一样。声明式框架能把开发者从繁杂的命令式的UI细节中解放出来，重点思考一个好的体验应该是什么样子的，而具体的UI细节由框架来处理。尽管如此，毕竟Compose是近几年来发展起来的，现今大量的项目仍是原生View主导的。此外，Compose也还在发展中，有些特定业务领域如Camera，视频，3D渲染，还没有能力支持。因此，整合原生View和Compose是项目中很现实的一个难题，本文将重点讨论两个议题：一个是如何在原生View中嵌入Compose，另一个就是如何在Compose中嵌入原生View。</p>

<p><strong>注意：</strong> 本文中提到的两个组件ComposeView和AndroidView都仅在Jetpack Compose（for Android）生效，并不适用于跨平台的Compose Multiplatform。</p>

<h2>在原生View中嵌入Compose</h2>

<p>第一个传送门是如何进入Compose的世界。相信现在绝大多数项目都是基于原生View的，借助<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/ComposeView">ComposeView</a>就可以进入到Compose的世界。</p>

<pre><code class="Kotlin">    val composeView = ComposeView(context).apply {
                setContent {
                    // 这里调用Composables
                }
            }
</code></pre>

<p>ComposeView是View的一个子类，能够作为Compose的容器，在<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/ComposeView#setContent(kotlin.Function0">其setContent方法</a>)中提供一个Composable即可。ComposeView与其他View一样，可以用在View tree中，用在Fragment里和Activity里面。实际上作为平台的入口ComponentActivity用的也是ComposeView。</p>

<h3>在View层级中直接嵌入</h3>

<p>ComposeView就是一个普通的Android View，跟其他View的子类是一样的，所以可以把它放在任何可以使用View的地方，比如一个布局里面，作为一个页面的一部分。</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/container"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity"&gt;

    &lt;androidx.compose.ui.platform.ComposeView
        android:id="@+id/compose_view"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" /&gt;

    &lt;Button
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="WidgetButton"
        /&gt;
&lt;/LinearLayout&gt;
</code></pre>

<p><strong>注意：</strong> 尽管可以把ComposeView当成普通的View，直接嵌入到布局中，作为页面中的一部分，但这并不是一个好的做法，一来是不能发挥Compose的优势，另外Compose本身是有特定的生命周期的（重组），它需要知道平台的生命周期，以管控它自己的生命周期。而常规的View tree之中是没有平台生命周期的，因为常规的View tree并不关心平台的生命周期，view tree主要受窗口影响（attachToWindow，detachFromWindow），这个与平台组件的生命周期没有关系。</p>

<h3>用在Fragment中</h3>

<p>想要在某个Fragment中集成Compose的方式就是把ComposeView作为Fragment的根View即可：</p>

<pre><code class="Kotlin">class ExampleFragmentNoXml : Fragment() {

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        return ComposeView(requireContext()).apply {
            // 当View的宿主destroy时销毁组合
            setViewCompositionStrategy(ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed)
            setContent {
                MaterialTheme {
                    // 进入到Compose世界
                    Text("Hello Compose!")
                }
            }
        }
    }
}
</code></pre>

<h3>用在Activity中</h3>

<p>这其实是最好的方式，在一个新的页面窗口中使用Compose，这就能与其余view独立开来，是最为理想的。</p>

<pre><code class="Kotlin">class ExampleActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContent {
            MaterialTheme {
                Greeting(name = "compose")
            }
        }
    }
}

@Composable
fun Greeting(name: String) {
    Text(text = "Hello $name!")
}
</code></pre>

<h3>使用建议</h3>

<p>虽然ComposeView可以当成一个普通的View来使用，但最为合理的方式就是在一个新的Activity中才使用Compose，也就是说当有一个全新的页面时，考虑使用Compose来开发，这样才能发挥出它的价值。</p>

<p>除非有特别的需求，否则不要把ComposeView作为现有页面的一部分嵌入到View tree中（也就是作为页面的一部分）。</p>

<p>至于在Fragment中使用，如果是一个全新的页面，而非现有布局的一部分，那也可以考虑使用Compose。</p>

<p><strong>注意：</strong> 其根本原因在于，我们使用Jetpack Compose并不是图它能实现什么特别的UI效果，Compose能做的事情View都能做，甚至它不能做的事情View也能做。用Compose是因为它是声明式的UI框架，在开发效率和可扩展性上面有巨大的优势。所以，只应该在想要发挥声明式框架优势的时候，才考虑使用它，并且应该从一个全新的页面开始。</p>

<h2>在Compose中嵌入原生View</h2>

<p>Jetpack Compose提供了足够丰富的组件，足以应对常规的UI，但它毕竟还不是特别的成熟，总会遇到一些场景，发现Compose无法胜任，而且并不是通过自定义组件就能够解决的，比如一些特定领域的UI，如camera，如视频，如3D渲染。或者说，已经有了自定义好的View，并不想重复开发。再或者说对于一些三方的库，它并没有对应的Compose组件。这些场景就需要把原生的View嵌入到Compose之中。</p>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/viewinterop/package-summary#AndroidView(kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Function1,kotlin.Function1,kotlin.Function1">AndroidView</a>)就是专门用于把原生View嵌入到Compose中的一个特殊composable。它就像一个传送门一样，能把原生的View，无论是一个现成的自定义View，还是特定领域的View或者三方库的View，带入到Compose中，变成一个composable。</p>

<h3>AndroidView的使用方法</h3>

<p>AndroidView是一个composable，把它放在想要的位置即可。它有三个参数，一个是常规的Modifier用以约束这个composable的；另两个是lambda，一个是用于创建View的，返回一个View的实例，只会被调用一次；另一个就是用于更新View的，会被调用多次：</p>

<pre><code class="Kotlin">@Composable
fun CustomView() {
    var selectedItem by remember { mutableStateOf(0) }

    // 添加原生View到Compose
    AndroidView(
        modifier = Modifier.fillMaxSize(),
        factory = { context -&gt;
            // 创建View的实例
            MyView(context).apply {
                // 设置View的点击事件，更新状态，这会触发重组
                setOnClickListener {
                    selectedItem = 1
                }
            }
        },
        update = { view -&gt;
            // 更新View的状态
            // 这里读了状态，所以重组时update会被再次调用，view能拿到最新的状态
            view.selectedItem = selectedItem
        }
    )
}

@Composable
fun ContentExample() {
    Column(Modifier.fillMaxSize()) {
        Text("Look at this CustomView!")
        CustomView()
    }
}
</code></pre>

<p><strong>注意：</strong> factory仅会被调用一次，用于创建View实例，update会被调用多次，用于更新view的状态，包括初次组合时，也就是factory执行之后，就会调用update。AndroidView函数会帮助提供View需要的参数context，以及管理View的实例，所以update中会把view当作参数传给我们，所以我们完全没有必要再用额外的状态（remember）去缓存View的实例了。</p>

<h3>使用建议</h3>

<p>虽然AndroidView是一个传送门，可以连接两个世界，但是能不用还是不要用，非必要不使用。如果能用Compose搞定的事情，还是要用Compose来搞，比如用Canvas去实现自定义组件。</p>

<p>需要使用AndroidView的场景只有三个：一是有现成的自定义View，拿过来就可以用，不想二次开发；二是三方库的View；三就是Compose确实搞不定的特定领域，如WebView，如视频，如SurfaceView或者3D渲染（OpenGL ES）等等。除以之外，不建议使用。</p>

<p>还需要特别注意的是，如果原生的View交互比较复杂，不光是点击，还涉及Touch事件处理，处理事件的同时还要不断更新View的状态，那也不应该使用它。比较理想的情况是，嵌入的这个View是一个比较纯粹的生产者，比如它只产生事件，不需要再往回更新状态；或者是一个比较纯粹的消费者，比如它就负责展示，只需要塞数据就行了。</p>

<h2>总结</h2>

<p>网上的教程或者Demo中的世界是很美好的，往往都是一个新建的项目，一个新的页面，直接就进入了Compose世界，也都在讲Compose能做的事情。但现实的世界往往不是这样子的，极少情况下是全新开始的项目，往往需要与遗留代码打交道，需要实现的需求也是多种多样的。本文中介绍了两个传送门，ComposeView和AndroidView可以方便地连接原生View和Compose两个世界，为现实项目中遇到的问题提供了一个可行的解决方案。</p>

<h3>让Compose支持OpenGL ES</h3>

<ul>
<li><a href="https://stackoverflow.com/questions/78796021/how-to-render-opengl-alongside-jetpack-compose-ui-without-covering-other-element">How to render OpenGL alongside Jetpack Compose UI without covering other elements</a></li>
<li><a href="https://www.reddit.com/r/Kotlin/comments/on36sy/experiment_to_make_opengl_work_together_with/?rdt=62185">Experiment to make OpenGL work together with Jetpack Compose</a></li>
<li><a href="https://composables.com/foundation/androidexternalsurface">AndroidExternalSurface</a></li>
<li><a href="https://youtrack.jetbrains.com/issue/CMP-3810/Using-Open-GL-with-Compose-Multiplatform">Using Open GL with Compose Multiplatform</a></li>
</ul>


<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/migrate/interoperability-apis/compose-in-views">Using Compose in Views</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/migrate/interoperability-apis/views-in-compose">Using Views in Compose</a></li>
<li><a href="https://medium.com/@seungbae2/jetpack-compose-androidview-seamless-integration-of-android-views-into-compose-ui-644f217437d3">Jetpack Compose AndroidView: Seamless Integration of Android Views into Compose UI</a></li>
<li><a href="https://stackoverflow.com/questions/59995970/using-custom-views-with-jetpack-compose">Using Custom Views with Jetpack Compose</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Jetpack Compose构建创意动画]]></title>
    <link href="https://alexhilton.github.io/blog/2025/05/31/animations-in-jetpack-compose/"/>
    <updated>2025-05-31T23:19:03+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/05/31/animations-in-jetpack-compose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Animating Inside and Outside the Box with Jetpack Compose」，原文链接<a href="https://medium.com/proandroiddev/animating-inside-and-outside-the-box-with-jetpack-compose-a56eba1b6af6">https://medium.com/proandroiddev/animating-inside-and-outside-the-box-with-jetpack-compose-a56eba1b6af6</a>，由Nirbhay Pherwani发布于2023年12月13日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YDhqS2nzvjXmvlC58vcDNQ.png" title="auto auto" ></a></p>

<!-- more -->


<h2>缘起</h2>

<p>动画能够让用户界面充满活力、引人入胜。在Android中，Jetpack Compose提供高级工具，让你轻松掌握这项强大功能，打造真正的动态UI。本文将深入探讨 Jetpack Compose 中动画的深层技术。</p>

<p><strong>译注：</strong> 虽然原文是以Jetpack Compose为基础来写的，但其实动画这块并不涉及平台特性，也适用于Compose Multiplatform。</p>

<p>我们将涵盖一系列技巧，从创建流畅的、基于物理的动效（增添真实感）到创建复杂的编排序列（为界面增添叙事质感）。无论你是想提升技能，还是仅仅想探索无限可能，本教程都将提供实用的见解，帮助你的应用不仅运行流畅，还能让用户在每次交互中都感到愉悦。</p>

<p>让我们深入探索这些动画如何改变你的 UI设计方法，使其更加直观、响应迅速，并为用户带来愉悦的体验。</p>

<h2>第 1 部分 — Jetpack Compose中的自定义动画</h2>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C1_mzDHNHOfSZkIiULgRzw.gif" alt="游戏角色的移动" /></p>

<h3>利用自定义动画实现动态交互</h3>

<p>在本节中，我们将探索如何在 Jetpack Compose中使用高级自定义动画来创建动态且可交互的 UI 元素。我们将重点介绍一个真实示例，该示例演示了用户交互如何以有意义的方式影响动画。</p>

<h3>案例 - 交互式游戏角色移动</h3>

<p>我们将通过一个示例来说明这一概念，其中游戏角色（由面部图标表示）沿着由用户可拖动控制点确定的路径移动。</p>

<pre><code class="Kotlin">@Composable
fun GameCharacterMovement() {
    val startPosition = Offset(100f, 100f)
    val endPosition = Offset(250f, 400f)
    val controlPoint = remember { mutableStateOf(Offset(200f, 300f)) }
    val position = remember { Animatable(startPosition, Offset.VectorConverter) }

    LaunchedEffect(controlPoint.value) {
        position.animateTo(
            targetValue = endPosition,
            animationSpec = keyframes {
                durationMillis = 5000
                controlPoint.value at 2500 // 可拖动控制点控制的中间点
            }
        )
    }

    val onControlPointChange: (offset: Offset) -&gt; Unit = {
        controlPoint.value = it
    }

    Box(modifier = Modifier.fillMaxSize()) {

        Icon(
            Icons.Filled.Face, contentDescription = "Localized description", modifier = Modifier
                .size(50.dp)
                .offset(x = position.value.x.dp, y = position.value.y.dp)
        )

        DraggableControlPoint(controlPoint.value, onControlPointChange)
    }
}
</code></pre>

<h4>代码说明</h4>

<ul>
<li>GameCharacterMovement 为代表游戏角色的图标设置动画。动画路径由 controlPoint 控制，该控制点通过用户交互设置和更新。</li>
<li>Animatable 用于将图标的位置从 startPosition 平滑过渡到 endPosition。</li>
<li>LaunchedEffect 监听 controlPoint 值的变化，并在控制点移动时重新触发动画。</li>
<li>animationSpec — 这是一种配置项，用于定义动画的持续时间、延迟和缓动。它决定了动画值如何随时间变化。</li>
<li>keyframes — 允许你在动画的特定时间点指定值，从而控制动画的中间点。这对于创建复杂的、精心设计的动画特别有用。</li>
<li>keyframes 块将动画定义为一系列关键帧。在 2500 毫秒（中间点）时，角色到达控制点，然后继续移动到结束位置。</li>
</ul>


<pre><code class="Kotlin">@Composable
fun DraggableControlPoint(controlPoint: Offset, onControlPointChange: (Offset) -&gt; Unit) {
    var localPosition by remember { mutableStateOf(controlPoint) }
    Box(
        modifier = Modifier
            .offset {
                IntOffset(
                    x = localPosition.x.roundToInt() - 15,
                    y = localPosition.y.roundToInt() - 15
                )
            }
            .size(30.dp)
            .background(Color.Red, shape = CircleShape)
            .pointerInput(Unit) {
                detectDragGestures(onDragEnd = {
                    onControlPointChange(localPosition)
                }) { _, dragAmount -&gt;
                    // adjust based on screen bounds
                    val newX = (localPosition.x + dragAmount.x).coerceIn(0f, 600f)
                    val newY = (localPosition.y + dragAmount.y).coerceIn(0f, 600f)
                    localPosition = Offset(newX, newY)
                }
            }
    )
}
</code></pre>

<h4>代码说明</h4>

<ul>
<li>DraggableControlPoint 是一个可组合项，允许用户以交互方式更改控制点的位置。</li>
<li>拖动控制点会更新 localPosition，并在拖动手势完成（onDragEnd）后将其反馈回 GameCharacterMovement。此交互会改变动画图标的路径。</li>
</ul>


<h3>实际用例</h3>

<ol>
<li>交互式教育应用：在教育应用中，动画可用于提升学习的吸引力。例如，在天文学应用中，拖动行星沿其轨道运行即可查看不同的星座。</li>
<li>交互式故事叙述和游戏：在数字故事叙述或游戏应用中，允许用户通过可拖动元素来影响故事或游戏环境，可以创造更具沉浸感的体验。</li>
</ol>


<h2>第 2 部分 — 在 Jetpack Compose中编排复杂动画</h2>

<h3>同步多个元素以实现和谐效果</h3>

<p>在本部分中，我们将深入探讨在 Jetpack Compose 中编排（Choreographing）复杂动画的艺术。我们专注于创建同步动画，使多个元素能够无缝交互，从而提升整体用户体验。</p>

<h3>A) 连锁反应动画 — 多米诺骨牌效应</h3>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iNeJJU3ixcdcZnQFHHSWYw.gif" alt="多米诺骨牌效应" /></p>

<p>通过设置一系列动画可以在 UI 中创建多米诺骨牌效应，其中一个动画的完成会触发下一个动画的开始。</p>

<pre><code class="Kotlin">@Composable
fun DominoEffect() {
    val animatedValues = List(6) { remember { Animatable(0f) } }

    LaunchedEffect(Unit) {
        animatedValues.forEachIndexed { index, animate -&gt;
            animate.animateTo(
                targetValue = 1f,
                animationSpec = tween(durationMillis = 1000, delayMillis = index * 100)
            )
        }
    }

    Box (modifier = Modifier.fillMaxSize()){
      animatedValues.forEachIndexed { index, value -&gt;
        Box(
            modifier = Modifier
                .size(50.dp)
                .offset(x = ((index+1) * 50).dp, y = ((index+1) * 30).dp)
                .background(getRandomColor(index).copy(alpha = value.value))
        )
      }
    }
}

fun getRandomColor(seed: Int): Color {
    val random = Random(seed = seed).nextInt(256)
    return Color(random, random, random)
}
</code></pre>

<h4>代码说明</h4>

<ul>
<li>animatedValues 是一个Animatable对象的列表，每个值控制一个框的 Alpha（不透明度）。</li>
<li>LaunchedEffect 会触发这些值的一系列动画，从而创建一种交错效果，即每个框在前一个框之后淡入，类似于多米诺骨牌倒下。</li>
<li>getRandomColor 函数会为每个框生成随机的灰色阴影，为序列中的每个组件添加独特的视觉元素。</li>
<li>这些框沿屏幕对角线放置，增强了多米诺骨牌效应。</li>
</ul>


<h3>B) 交互式滚动时间轴</h3>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kk-V0g5pEqy83NajRy_6lA.gif" alt="交互式滚动时间轴" /></p>

<p>在这个时间轴中，每个元素都会随着用户滚动而淡入并移动到位。我们将使用 LazyColumn来呈现可滚动列表，并使用Animatable来呈现动画。</p>

<pre><code class="Kotlin">@Composable
fun InteractiveTimeline(timelineItems: List&lt;String&gt;) {
    val scrollState = rememberLazyListState()

    LazyColumn(state = scrollState) {
        itemsIndexed(timelineItems) { index, item -&gt;
            val animatableAlpha = remember { Animatable(0f) }
            val isVisible = remember {
                derivedStateOf {
                    scrollState.firstVisibleItemIndex &lt;= index
                }
            }

            LaunchedEffect(isVisible.value) {
                if (isVisible.value) {
                    animatableAlpha.animateTo(
                        1f, animationSpec = tween(durationMillis = 1000)
                    )

                }
            }

            TimelineItem(
                text = item,
                alpha = animatableAlpha.value,
            )
        }
    }
}

@Composable
fun TimelineItem(text: String, alpha: Float) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .background(Color.DarkGray.copy(alpha = alpha))
            .padding(16.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(
            text = text,
            color = Color.White,
            modifier = Modifier.fillMaxWidth(),
            textAlign = TextAlign.Center,
            fontSize = 18.sp,
            fontWeight = FontWeight.SemiBold
        )
    }
}
</code></pre>

<h4>代码说明</h4>

<ul>
<li>animatableAlpha 控制每个时间轴项目的 Alpha（不透明度），初始设置为 0（完全透明）。</li>
<li>isVisible 状态源自当前滚动位置，用于确定项目是否可见。</li>
<li>当用户滚动时，LaunchedEffect会触发进入视口的项目的淡入动画。</li>
</ul>


<h4>用例</h4>

<p>此交互式时间轴非常适合那些希望以视觉吸引力十足的方式呈现一系列事件或步骤的应用。动画通过在项目进入视野时吸引用户的注意力来增强用户的参与度。</p>

<p><strong>此类动画不仅引人入胜，还可以用来引导用户关注应用中的一系列事件或操作。</strong></p>

<h2>第 3 部分 — Jetpack Compose中基于物理的真实动画</h2>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lZ_rpGorcFzewpUJN6WPAQ.gif" alt="弹性拖拽动画" /></p>

<h3>利用物理原理增强UI动态效果</h3>

<p>在本节中，我们将探索如何使用 Jetpack Compose将物理原理融入动画，为 UI 增添一层真实感和交互性。我们将重点介绍一个弹性拖拽交互示例。</p>

<h3>拖拽时的弹性效果</h3>

<p>此示例演示了图标上的弹性拖拽交互。垂直拖动时，图标会拉伸并回弹，产生弹性效果，模拟弹簧或橡皮筋​​的行为。</p>

<pre><code class="Kotlin">@Composable
fun ElasticDraggableBox() {
    var animatableOffset by remember { mutableStateOf(Animatable(0f)) }

    Box(modifier = Modifier.fillMaxSize().background(Color(0xFFFFA732)), contentAlignment = Alignment.Center) {
        Box(
            modifier = Modifier
                .offset(y = animatableOffset.value.dp)
                .draggable(
                    orientation = Orientation.Vertical,
                    state = rememberDraggableState { delta -&gt;
                        animatableOffset = Animatable(animatableOffset.value + delta)
                    },
                    onDragStopped = {
                        animatableOffset.animateTo(0f, animationSpec = spring())
                    }
                )
                .size(350.dp),
            contentAlignment = Alignment.Center
        ) {
            Icon(
                Icons.Filled.Favorite,
                contentDescription = "heart",
                modifier = Modifier.size(animatableOffset.value.dp + 150.dp),
                tint = Color.Red
            )
        }
    }
}
</code></pre>

<h4>说明</h4>

<ul>
<li>使用 draggable 修饰符将包含图标的 Box 可组合项设置为可拖动。</li>
<li>animatableOffset 跟踪图标因拖动而产生的垂直偏移。</li>
<li>在拖动过程中，图标的大小会根据拖动量而变化，从而产生拉伸效果。</li>
<li>当拖动停止（onDragStopped）时，animatableOffset 会使用弹簧动画返回到 0f，从而使图标弹回其原始大小和位置。</li>
</ul>


<h2>第 4 节 — Jetpack Compose 中的手势动画</h2>

<h3>通过响应式手势提升用户体验</h3>

<p>在本部分中，我们将探索如何使用 Jetpack Compose 创建由用户手势控制的动画。我们将重点介绍两个示例——一个支持多点触控的可变形图像和一个由手势控制的音频波形。</p>

<h3>A) 多点触控可变形图像</h3>

<p>在本示例中，我们将创建一个图像视图，用户可以使用捏合、缩放和旋转等多点触控（Multi-touch）手势进行交互。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*34WxcBivTWhiCY6KVSVelQ.gif" alt="多点触控可变形图像" /></p>

<pre><code class="Kotlin">@Composable
fun TransformableImage(imageId: Int = R.drawable.android) {
    var scale by remember { mutableStateOf(1f) }
    var rotation by remember { mutableStateOf(0f) }
    var offset by remember { mutableStateOf(Offset.Zero) }

    Box(modifier = Modifier.fillMaxSize().background(Color.DarkGray), contentAlignment = Alignment.Center) {
        Image(
            painter = painterResource(id = imageId),
            contentDescription = "Transformable image",
            contentScale = ContentScale.Crop,
            modifier = Modifier
                .size(300.dp)
                .graphicsLayer(
                    scaleX = scale,
                    scaleY = scale,
                    rotationZ = rotation,
                    translationX = offset.x,
                    translationY = offset.y
                )
                .pointerInput(Unit) {
                    detectTransformGestures { _, pan, zoom, rotate -&gt;
                        scale *= zoom
                        rotation += rotate
                        offset += pan
                    }
                }
        )
    }
}
</code></pre>

<h4>代码说明</h4>

<ul>
<li>Image 可组合项通过 graphicsLayer 进行修改，以应用缩放、旋转和平移等变换。</li>
<li>pointerInput 带有 detectTransformGestures 接口，用于处理多点触控手势，并相应地更新缩放、旋转和偏移。</li>
</ul>


<h3>B) 手势控制波形</h3>

<p>这是一个波形可视化效果，它根据用户手势（例如滑动和捏合）改变外观，以控制幅度和频率等方面。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qKzb1XpUrSGKdCL-OxhtLw.gif" alt="手势控制波形" /></p>

<pre><code class="Kotlin">@Composable
fun GestureControlledWaveform() {
    var amplitude by remember { mutableStateOf(100f) }
    var frequency by remember { mutableStateOf(1f) }

    Canvas(modifier = Modifier
        .fillMaxSize()
        .pointerInput(Unit) {
            detectDragGestures { _, dragAmount -&gt;
                amplitude += dragAmount.y
                frequency += dragAmount.x / 500f 
                // 根据拖拽调整频率
            }
        }
        .background(
            Brush.verticalGradient(
                colors = listOf(Color(0xFF003366), Color.White, Color(0xFF66B2FF))
            )
        )) {
        val width = size.width
        val height = size.height
        val path = Path()

        val halfHeight = height / 2
        val waveLength = width / frequency

        path.moveTo(0f, halfHeight)

        for (x in 0 until width.toInt()) {
            val theta = (2.0 * Math.PI * x / waveLength).toFloat()
            val y = halfHeight + amplitude * sin(theta.toDouble()).toFloat()
            path.lineTo(x.toFloat(), y)
        }

        val gradient = Brush.horizontalGradient(
            colors = listOf(Color.Blue, Color.Cyan, Color.Magenta)
        )

        drawPath(
            path = path,
            brush = gradient
        )
    }
}
</code></pre>

<h4>代码说明</h4>

<ul>
<li>amplitude 和 frequency 是状态变量，分别控制波形的幅度和频率。</li>
<li>Canvas 可组合项用于绘制波形。Canvas 内部的绘制逻辑根据正弦函数计算每个 X 位置的 Y 位置，从而创建波浪效果。</li>
<li>detectDragGestures 修饰符用于根据用户拖动手势更新幅度和频率。水平拖动调整频率，垂直拖动调整幅度。</li>
<li>当用户在屏幕上拖动时，波形的形状会相应变化，从而营造出互动体验。</li>
</ul>


<h4>注意事项</h4>

<ul>
<li>这是一个基本的实现。为了获得更逼真的音频波形，你需要集成实际的音频数据。</li>
<li>可以通过调整拖动过程中幅度和频率的修改方式来微调波形对手势的响应能力。</li>
</ul>


<p>此示例演示了如何在 Compose 中创建基本的交互式波形，并且可以对其进行扩展或修改，以用于更复杂的用例或处理更复杂的手势。</p>

<h2>第 5 节 — Jetpack Compose 中的状态驱动动画模式</h2>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nkfhmC6JjQnshL3y_izhKg.gif" alt="带动画线图" /></p>

<h3>基于数据和状态变化的UI动画</h3>

<p>本部分重点介绍如何创建由数据或UI 状态变化驱动的动画，从而增强应用的交互性和响应能力。我们将探讨两个具体示例——数据图动画和在多状态 UI 中实现状态转换。</p>

<h3>A) 数据驱动的图形动画</h3>

<p>本示例演示了一个动画线图，其中图形的路径（Path）会随着数据集的变化而变化。</p>

<pre><code class="Kotlin">@Composable
fun AnimatedGraphExample() {
    var dataPoints by remember { mutableStateOf(generateRandomDataPoints(5)) }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .background(Color.DarkGray)
    ) {
        AnimatedLineGraph(dataPoints = dataPoints)

        Spacer(modifier = Modifier.height(16.dp))

        Button(
            onClick = {
                dataPoints = generateRandomDataPoints(5)
            },
            modifier = Modifier.align(Alignment.CenterHorizontally),
            colors = ButtonDefaults.buttonColors(containerColor = Color.Green)
        ) {
            Text(
                "Update Data",
                fontWeight = FontWeight.Bold,
                color = Color.DarkGray,
                fontSize = 18.sp
            )
        }
    }
}

@Composable
fun AnimatedLineGraph(dataPoints: List&lt;Float&gt;) {
    val animatableDataPoints = remember { dataPoints.map { Animatable(it) } }
    val path = remember { Path() }

    LaunchedEffect(dataPoints) {
        animatableDataPoints.forEachIndexed { index, animatable -&gt;
            animatable.animateTo(dataPoints[index], animationSpec = TweenSpec(durationMillis = 500))
        }
    }

    Canvas(
        modifier = Modifier
            .fillMaxWidth()
            .height(400.dp)
    ) {
        path.reset()
        animatableDataPoints.forEachIndexed { index, animatable -&gt;
            val x = (size.width / (dataPoints.size - 1)) * index
            val y = size.height - (animatable.value * size.height)
            if (index == 0) path.moveTo(x, y) else path.lineTo(x, y)
        }
        drawPath(path, Color.Green, style = Stroke(5f))
    }
}

fun generateRandomDataPoints(size: Int): List&lt;Float&gt; {
    return List(size) { Random.nextFloat() }
}
</code></pre>

<h4>代码说明</h4>

<ul>
<li>AnimatedGraphExample 可组合项创建了一个可以更新折线图数据点的环境。</li>
<li>该图表绘制在 Canvas 中，其中 drawPath 方法使用来自 animatableDataPoints 的动画值。</li>
<li>对于图表中的每个数据点，我们需要计算其在画布上对应的 x（水平）和 y（垂直）位置。</li>
<li>x 计算 - x 位置是根据数据点的索引和画布的总宽度计算得出的。我们将数据点沿画布的宽度均匀分布。
<code>Kotlin
val x = (size.width / (dataPoints.size - 1)) * index
</code></li>
<li>y 计算——y 位置是根据数据点（animatable.value）的值和画布的高度计算的。
<code>Kotlin
val y = size.height - (animatable.value * size.height)
</code></li>
<li>路径从第一个数据点开始，然后使用 lineTo 绘制一条线到每个后续点，从而创建图形线。</li>
<li>路径基于数据点的动画值绘制，从而在数据发生变化时创建动画效果。</li>
</ul>


<h3>B) 多状态 UI 中的状态转换</h3>

<p>可以使用 Animatable 在多状态 UI 中实现状态转换，从而在不同 UI 状态之间进行动画处理。</p>

<pre><code class="Kotlin">enum class UIState { StateA, StateB, StateC }

@Composable
fun StateTransitionUI() {
    var currentState by remember { mutableStateOf(UIState.StateA) }

    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(getBackgroundColorForState(currentState)),
        contentAlignment = Alignment.Center
    ) {
        AnimatedContent(currentState = currentState)

        Button(
            onClick = { currentState = getNextState(currentState) },
            modifier = Modifier.align(Alignment.BottomCenter)
        ) {
            Text("Next State")
        }
    }
}

@Composable
fun AnimatedContent(currentState: UIState) {
    AnimatedVisibility(
        visible = currentState == UIState.StateA,
        enter = fadeIn(animationSpec = tween(durationMillis = 2000)) + expandVertically(),
        exit = fadeOut(animationSpec = tween(durationMillis = 2000)) + shrinkVertically()
    ) {
        Text("This is ${currentState.name}", fontSize = 32.sp)
    }

    // 与B 和 C 的类似的代码块
}

fun getBackgroundColorForState(state: UIState): Color {
    return when (state) {
        UIState.StateA -&gt; Color.Red
        UIState.StateB -&gt; Color.Green
        UIState.StateC -&gt; Color.Blue
    }
}

fun getNextState(currentState: UIState): UIState {
    return when (currentState) {
        UIState.StateA -&gt; UIState.StateB
        UIState.StateB -&gt; UIState.StateC
        UIState.StateC -&gt; UIState.StateA
    }
}
</code></pre>

<h4>代码说明</h4>

<ul>
<li>在此示例中，AnimatedVisibility 用于为每个状态下内容的出现和消失添加动画效果。这会在状态变化时添加平滑的过渡效果。</li>
<li>对于每个状态（StateA、StateB、StateC），都有一个 AnimatedVisibility 块，用于通过淡入淡出和展开/收缩动画控制其内容的可见性。</li>
<li>AnimatedVisibility 的进入和退出参数分别定义了内容可见或隐藏时的动画。</li>
</ul>


<h2>第 6 节 — 在 Compose中改变（Morphing）形状</h2>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q82EIocVzR8XBMuG_14mdg.gif" alt="形状变形" /></p>

<p>动画形状之间的变换涉及这些形状的属性的插值。</p>

<pre><code class="Kotlin">@Composable
fun ShapeMorphingAnimation() {
    val animationProgress = remember { Animatable(0f) }

    LaunchedEffect(Unit) {
        animationProgress.animateTo(
            targetValue = 1f,
            animationSpec = infiniteRepeatable(
                animation = tween(2000, easing = LinearOutSlowInEasing),
                repeatMode = RepeatMode.Reverse
            )
        )
    }

    Canvas(modifier = Modifier.padding(40.dp).fillMaxSize()) {
        val sizeValue = size.width.coerceAtMost(size.height) / 2
        val squareRect = Rect(center = center, sizeValue)

        val morphedPath = interpolateShapes(progress = animationProgress.value, squareRect = squareRect)
        drawPath(morphedPath, color = Color.Blue, style = Fill)
    }
}

fun interpolateShapes(progress: Float, squareRect: Rect): Path {
    val path = Path()

    val cornerRadius = CornerRadius(
        x = lerp(start = squareRect.width / 2, stop = 0f, fraction = progress),
        y = lerp(start = squareRect.height / 2, stop = 0f, fraction = progress)
    )

    path.addRoundRect(
        roundRect = RoundRect(rect = squareRect, cornerRadius = cornerRadius)
    )

    return path
}

fun lerp(start: Float, stop: Float, fraction: Float): Float {
    return (1 - fraction) * start + fraction * stop
}
</code></pre>

<h4>代码说明</h4>

<ul>
<li>ShapeMorphingAnimation 设置了一个无限动画，将 animationProgress 的值在 0 和 1 之间切换。</li>
<li>Canvas 可组合项用于绘制形状。在这里，我们根据画布大小定义正方形 (squareRect) 的尺寸。</li>
<li>interpolateShapes 接收当前动画进度和正方形的矩形，在圆形和正方形之间进行插值。它使用 lerp（线性插值）逐步调整圆角矩形的 cornerRadius，该矩形代表我们的变形形状。</li>
<li>当 progress 为 0 时，cornerRadius 是矩形大小的一半，使形状变为圆形。当 progress 为 1 时，cornerRadius 为 0，使形状变为正方形。</li>
</ul>


<h4>实际用例</h4>

<ul>
<li>加载和进度指示器——变形形状可用于创建更具吸引力的加载或进度指示器，以视觉上引人入胜的方式指示进度或加载状态。</li>
<li>UI 中的图标过渡——变形图标可用于根据用户操作提供视觉反馈。例如，点击播放按钮时会变形为暂停按钮，汉堡菜单图标会变形为后退箭头。</li>
<li>数据可视化——在复杂的数据可视化中，变形可以帮助在不同视图或数据状态之间过渡，使用户更容易跟踪和理解随时间或类别变化的变化。</li>
</ul>


<h2>想看雪花特效吗？</h2>

<p>我们将演示一个简单的粒子系统（Particle system）来创建雪花效果。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E26GhhxDZLGTpE8gMvJoHw.gif" alt="雪花特效" /></p>

<pre><code class="Kotlin">data class Snowflake(
    var x: Float,
    var y: Float,
    var radius: Float,
    var speed: Float
)

@Composable
fun SnowfallEffect() {
    val snowflakes = remember { List(100) { generateRandomSnowflake() } }
    val infiniteTransition = rememberInfiniteTransition(label = "")

    val offsetY by infiniteTransition.animateFloat(
        initialValue = 0f,
        targetValue = 1000f,
        animationSpec = infiniteRepeatable(
            animation = tween(durationMillis = 5000, easing = LinearEasing),
            repeatMode = RepeatMode.Restart
        ), label = ""
    )

    Canvas(modifier = Modifier.fillMaxSize().background(Color.Black)) {
        snowflakes.forEach { snowflake -&gt;
            drawSnowflake(snowflake, offsetY % size.height)
        }
    }
}

fun generateRandomSnowflake(): Snowflake {
    return Snowflake(
        x = Random.nextFloat(),
        y = Random.nextFloat() * 1000f,
        radius = Random.nextFloat() * 2f + 2f, // Snowflake size
        speed = Random.nextFloat() * 1.2f + 1f  // Falling speed
    )
}

fun DrawScope.drawSnowflake(snowflake: Snowflake, offsetY: Float) {
    val newY = (snowflake.y + offsetY * snowflake.speed) % size.height
    drawCircle(Color.White, radius = snowflake.radius, center = Offset(snowflake.x * size.width, newY))
}
</code></pre>

<h4>代码说明</h4>

<ul>
<li>SnowfallEffect 设置了一个包含多个雪花（Snowflake 对象）的粒子系统。</li>
<li>每个雪花都具有位置 (x, y)、半径（大小）和速度等属性。</li>
<li>rememberInfiniteTransition 和 animateFloat 用于创建连续的垂直运动效果，模拟降雪。</li>
<li>Canvas 可组合函数用于绘制每片雪花。drawSnowflake 函数根据每片雪花的速度和动画的 offsetY 计算其新的位置。</li>
<li>雪花从底部落下后会重新出现在顶部，从而产生循环降雪效果。</li>
</ul>


<h2>总结</h2>

<p>随着我们对 Jetpack Compose 动画的探索逐渐深入，我们清楚地认识到，动画不仅仅是视觉上的点缀。它们是打造引人入胜、直观且赏心悦目的用户体验的关键工具。</p>

<h3>拥抱互动性</h3>

<p>从动态游戏角色运动到交互式时间轴，我们见证了动画如何让用户交互更具吸引力和信息量。</p>

<h3>打造逼真的体验</h3>

<p>雪花飘落效果和变形形状展现了该工具包将真实感和流畅性带入数字世界的能力。这些动画有助于打造与用户产生共鸣的沉浸式体验。</p>

<h3>简化复杂性</h3>

<p>无论是编排多个元素还是制作状态转换动画，其简单易用性都令人瞩目。</p>

<h2>结束语</h2>

<p>如果你喜欢本文，请随时留下宝贵的反馈或赞赏。我一直期待与其他开发者一起学习、合作、共同成长。</p>

<p>如有任何疑问，请随时给我留言！</p>

<p>在 Medium 上关注我，获取更多文章 — <a href="https://medium.com/@pherwani37">Medium 个人资料</a>（链接：<a href="https://medium.com/@pherwani37%EF%BC%89">https://medium.com/@pherwani37%EF%BC%89</a></p>

<p>在<a href="https://linkedin.com/in/nirbhaypherwani">LinkedIn</a>（链接：<a href="https://linkedin.com/in/nirbhaypherwani%EF%BC%89%E5%92%8C">https://linkedin.com/in/nirbhaypherwani%EF%BC%89%E5%92%8C</a><a href="https://twitter.com/nirbhayph">Twitter</a>（链接：<a href="https://twitter.com/nirbhayph%EF%BC%89%E4%B8%8A%E4%B8%8E%E6%88%91%E8%81%94%E7%B3%BB%EF%BC%8C%E4%BB%A5%E4%BE%BF%E6%88%91%E4%BB%AC%E8%BF%9B%E8%A1%8C%E5%90%88%E4%BD%9C%E3%80%82">https://twitter.com/nirbhayph%EF%BC%89%E4%B8%8A%E4%B8%8E%E6%88%91%E8%81%94%E7%B3%BB%EF%BC%8C%E4%BB%A5%E4%BE%BF%E6%88%91%E4%BB%AC%E8%BF%9B%E8%A1%8C%E5%90%88%E4%BD%9C%E3%80%82</a></p>

<p>祝你动画制作愉快！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解Jetpack Compose中副作用函数的内部原理]]></title>
    <link href="https://alexhilton.github.io/blog/2025/05/01/understanding-side-effect-handlers/"/>
    <updated>2025-05-01T11:05:24+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/05/01/understanding-side-effect-handlers</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Understanding the Internals of Side-Effect Handlers in Jetpack Compose」，原文链接<a href="https://proandroiddev.com/understanding-the-internals-of-side-effect-handlers-in-jetpack-compose-d55fbf914fde">https://proandroiddev.com/understanding-the-internals-of-side-effect-handlers-in-jetpack-compose-d55fbf914fde</a>，由Jaewoong Eum发布于2025年4月10日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GNgL_XzYpw16hn6BxocOww.jpeg" title="auto auto" ></a></p>

<!-- more -->


<p>近年来，Jetpack Compose生态呈指数级增长，现已被广泛用于构建 Android 应用的产品级UI。现在，我们可以说 Jetpack Compose 代表了 Android UI 开发的未来。</p>

<p>Compose 最大的优势之一是其声明式（declarative）方法——它允许开发者描述 UI 应该显示的内容，而框架则负责处理 UI 在底层状态发生变化时应如何更新。这种模型将焦点从命令式（imperative）UI 转移到更直观、更具响应式的思维方式。</p>

<p>然而，尽管声明式 UI有很多优势，但妥善管理副作用也至关重要。可组合函数可能会因各种原因（例如状态或参数的变化）而被重组，如果副作用处理不当，应用的行为可能会变得不可预测。</p>

<p>在本文中，你将探索 Jetpack Compose 默认提供的副作用处理 API。你还将研究它们的内部工作流程，以更好地了解 Compose 如何在底层管理这些操作。</p>

<h2>副作用（Side Effect）是啥？</h2>

<p>副作用（Side Effect）是指发生在可组合函数作用域之外的应用状态变化。在 Jetpack Compose 中，由于状态变化、参数更新或其他事件触发的重组，可组合函数可能会频繁且不可预测地重新执行（译注：也就是说Compose的重组是不受开发者控制的）。因此，你不能假设一个可组合函数只会被调用一次。</p>

<p>换句话说，在可组合函数内部直接调用业务逻辑（例如从网络获取数据或查询数据库）是有风险的。由于潜在的重组，这些操作可能会无意中运行多次，从而导致错误或性能问题。</p>

<p>为了解决这个问题，Jetpack Compose 提供了一组专门用于以安全可控的方式管理副作用的API。这些 API包括 LaunchedEffect 、 DisposableEffect 、 SideEffect 、 rememberCoroutineScope 等等。在本文中，你将重点介绍三个最常用的处理程序—— LaunchedEffect 、 DisposableEffect 和 SideEffect ——并仔细研究它们的内部实现，以便更好地理解它们的底层工作原理。</p>

<h2>LaunchedEffect</h2>

<p>LaunchedEffect是Jetpack Compose中最常用的副作用处理 API之一。它允许你以可组合生命周期感知的方式（而非 Android 生命周期）启动协程，并确保除非指定的关键参数（keys）之一发生变化，否则不会重新执行提供的代码块。这种行为使得 LaunchedEffect 特别适合执行与特定状态相关的一次性事件，例如显示 Toast或Snackbar、记录事件或触发业务逻辑，正如你在 Now in Android 项目中的示例代码中所见：</p>

<pre><code class="Kotlin">val snackbarHostState = remember { SnackbarHostState() }
val isOffline by appState.isOffline.collectAsStateWithLifecycle()

// 如果用户未连接到互联网，则显示一个Snackbar来通知他们。
val notConnectedMessage = stringResource(R.string.not_connected)
LaunchedEffect(isOffline) {
    if (isOffline) {
        snackbarHostState.showSnackbar(
            message = notConnectedMessage,
            duration = Indefinite,
        )
    }
  }
</code></pre>

<p>需要注意的是，LaunchedEffect 会在底层创建一个新的协程作用域。这意味着它主要用于在可组合函数作用域内执行基于协程的任务，并在可组合函数离开组合时自动取消其协程。因此，LaunchedEffect 最适合用于与协程相关的操作，例如数据获取、延迟效果或事件处理，而不是简单地执行非暂停函数。现在，让我们深入探究一下，以更好地理解 LaunchedEffect 的内部工作原理。</p>

<pre><code class="Kotlin">@Composable
fun LaunchedEffect(
    key1: Any?,
    block: suspend CoroutineScope.() -&gt; Unit
) {
    val applyContext = currentComposer.applyCoroutineContext
    remember(key1) { LaunchedEffectImpl(applyContext, block) }
}

internal class LaunchedEffectImpl(
    parentCoroutineContext: CoroutineContext,
    private val task: suspend CoroutineScope.() -&gt; Unit
) : RememberObserver {
    private val scope = CoroutineScope(parentCoroutineContext)
    private var job: Job? = null

    override fun onRemembered() {
        // 这不应该发生，但为了安全起见留在这里
        job?.cancel("Old job was still running!")
        job = scope.launch(block = task)
    }

    override fun onForgotten() {
        job?.cancel(LeftCompositionCancellationException())
        job = null
    }

    override fun onAbandoned() {
        job?.cancel(LeftCompositionCancellationException())
        job = null
    }
}
</code></pre>

<p>正如你在LaunchedEffect的内部实现中所看到的，它会创建LaunchedEffectImpl并将其存储在内存中，并将给定的键值作为参数，以便在键发生变化时重新创建 LaunchedEffectImpl 实例。</p>

<p>如果你查看内部 LaunchedEffectImpl 类，你会发现它实现了RememberObserver接口，并首先创建一个新的 CoroutineScope。然后，当可组合项进入组合阶段时，提供的 lambda 会在此范围内启动。当可组合项离开组合阶段时，协程范围会自动取消，从而确保资源得到正确清理，并避免潜在的内存泄漏或性能问题。</p>

<p>话虽如此，如果你的任务不涉及任何与协程相关的操作，而只是需要在键发生变化时重新执行，那么使用 LaunchedEffect 可能略显多余。虽然创建协程作用域的开销通常很小，但在实际不使用协程的情况下，它仍然是不必要的。在这种情况下，你可以考虑使用更轻量级的副作用处理library (<a href="https://github.com/skydoves/compose-effects?tab=readme-ov-file#rememberedeffect">RememberedEffect</a>)，它更适合非挂起（non-suspending）任务。</p>

<p>另一个常见的误解是LaunchedEffect能够感知 Android生命周期——但事实并非如此。从内部实现可以看出，LaunchedEffect的作用域完全限定于Jetpack Compose组合生命周期，与 Android组件（Activity和Fragment）的生命周期没有直接关联。</p>

<p>换句话说，它本身并不了解任何有关 Activity、Fragment 或 onStop()或 onDestroy()等生命周期事件的信息。这意味着，如果你在 LaunchedEffect 中启动一个协程，并且 Android 组件（例如 Activity）在可组合项未离开组合的情况下被停止或销毁，则该协程可能会继续运行，除非它明确与Android组件生命周期绑定。</p>

<h2>DisposableEffect</h2>

<p>DisposableEffect是Jetpack Compose 运行时提供的另一个副作用处理API。它允许你与可组合项的生命周期同步执行设置和清理逻辑。与LaunchedEffect不同，它提供了一个 DisposableEffectScope 作为接收器（receiver），使你能够定义一个清理代码块（clean-up code block），该代码块在可组合项离开组合时自动运行。这使得它非常适合管理需要显式卸载的外部资源，例如监听器、回调或广播接收器。</p>

<pre><code class="Kotlin">val lifecycleOwner = LocalLifecycleOwner.current

// 如果 `lifecycleOwner` 发生变化，则释放并重置效果
DisposableEffect(lifecycleOwner) {
  // 创建一个观察者，触发我们记住的回调以发送分析事件
  val observer = LifecycleEventObserver { _, event -&gt;
    if (event == Lifecycle.Event.ON_RESUME) {
      // do something
    } else if (event == Lifecycle.Event.ON_PAUSE || event == Lifecycle.Event.ON_STOP) {
      // do something
    }
  }

  // Add the observer to the lifecycle
  lifecycleOwner.lifecycle.addObserver(observer)

  // 当效果离开 Composition 时，移除观察者
  onDispose {
    lifecycleOwner.lifecycle.removeObserver(observer)
  }
</code></pre>

<p>上面的示例使用 DisposableEffect 将 LifecycleEventObserver注册到lifecycleOwner，使其能够观察生命周期变化并根据当前状态执行特定逻辑。观察者会在onDispose块内被安全地移除，确保在可组合项离开组合时进行适当的清理。现在，让我们深入了解DisposableEffect的内部工作原理。</p>

<pre><code class="Kotlin">@Composable
fun DisposableEffect(
    key1: Any?,
    effect: DisposableEffectScope.() -&gt; DisposableEffectResult
) {
    remember(key1) { DisposableEffectImpl(effect) }
}

private class DisposableEffectImpl(
    private val effect: DisposableEffectScope.() -&gt; DisposableEffectResult
) : RememberObserver {
    private var onDispose: DisposableEffectResult? = null

    override fun onRemembered() {
        onDispose = InternalDisposableEffectScope.effect()
    }

    override fun onForgotten() {
        onDispose?.dispose()
        onDispose = null
    }

    override fun onAbandoned() {
        // 由于未调用 [onRemembered]，因此无需执行任何操作。
    }
}

class DisposableEffectScope {
    inline fun onDispose(
        crossinline onDisposeEffect: () -&gt; Unit
    ): DisposableEffectResult = object : DisposableEffectResult {
        override fun dispose() {
            onDisposeEffect()
        }
    }
}
</code></pre>

<p>如 DisposableEffect 的内部实现所示，它会创建一个 DisposableEffectImpl 实例，并使用提供的键将其存储在内存中。
每当键发生变化时，都会创建一个新的DisposableEffectImpl 实例，以便相应地重新执行该效果。</p>

<p>DisposableEffectImpl类实现了 RememberObserver 接口，并初始创建一个 DisposableEffectResult。当可组合项进入组合阶段时，效果 lambda 会在 DisposableEffectScope 中启动。退出组合时，会自动调用 DisposableEffectResult的onDispose 函数，以确保在可组合项完全从组合中移除之前正确清理资源并防止内存泄漏或性能问题。</p>

<h2>SideEffect</h2>

<p>Jetpack Compose中的SideEffect API 用于安全地将可组合项内发生的状态变化通知给外部非 Compose 管理的对象。它确保效果在重组成功后运行，使其成为触发依赖于界面最终稳定状态的副作用的理想选择。</p>

<p>使用 SideEffect可以避免在重组阶段执行的操作可能会被丢弃的风险，如果你在未采取此保护措施的情况下直接在可组合项中编写效果，则可能会发生这种情况。因此，当你需要将 Compose 状态与外部系统（例如日志记录工具、分析工具或命令式界面组件）同步时，SideEffect 至关重要，如下例所示：</p>

<pre><code class="Kotlin">@Composable
fun rememberFirebaseAnalytics(user: User): FirebaseAnalytics {
    val analytics: FirebaseAnalytics = remember {
        FirebaseAnalytics()
    }

    // 每次成功组合后，使用当前用户的用户类型更新 FirebaseAnalytics，
    // 确保将来的分析事件已附加此元数据
    SideEffect {
        analytics.setUserProperty("userType", user.userType)
    }
    return analytics
}
</code></pre>

<p>现在，让我们探索一下 SideEffect API 的底层工作原理。</p>

<pre><code class="Kotlin">@Composable
fun SideEffect(
    effect: () -&gt; Unit
) {
    currentComposer.recordSideEffect(effect)
}

/** 当我们应用组合变化时安排运行副作用。 */
override fun recordSideEffect(effect: () -&gt; Unit) {
    changeListWriter.sideEffect(effect)
}
</code></pre>

<p>乍一看，上面的代码可能看似简单，但实际上却难以完全理解，这很正常。这是因为 SideEffect API与 Compose运行时底层内部机制紧密相关，尤其是 ChangeList，它用于跟踪和管理用于更新渲染UI的状态驱动变更列表。</p>

<p>根据 Compose源代码中的内部注释，SideEffect API的表示如下：</p>

<blockquote><p>安排效果在当前合成成功完成并应用更改时运行。SideEffect 可用于将副作用应用于合成管理的、未受快照支持的对象，以便在当前合成操作失败时避免这些对象处于不一致的状态。</p>

<p>副作用将始终在合成的应用调度程序上运行，并且应用器永远不会与自身、彼此并发运行，也不会将更改应用于合成树或运行 RememberObserver 事件回调。SideEffect 始终在 RememberObserver 事件回调之后运行。</p></blockquote>

<p>因此，SideEffect API 会在每次成功重组后运行。</p>

<h2>结论</h2>

<p>在本文中，你探索了 Jetpack Compose 中常用的三个主要副作用处理API。由于声明式UI（declarative UI）的特性，状态会影响运行时行为的诸多方面，因此正确地使用副作用函数对于确保任务执行的正确性和可预测性至关重要。</p>

<p>本主题最初在<a href="https://github.com/doveletter/">Dove Letter</a>（译注：链接是<a href="https://github.com/doveletter/%EF%BC%89%E4%B8%AD%E4%BB%8B%E7%BB%8D%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E7%A7%81%E4%BA%BA%E4%BB%A3%E7%A0%81%E5%BA%93%EF%BC%8C%E6%8F%90%E4%BE%9B%E6%9C%89%E5%85%B3">https://github.com/doveletter/%EF%BC%89%E4%B8%AD%E4%BB%8B%E7%BB%8D%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E7%A7%81%E4%BA%BA%E4%BB%A3%E7%A0%81%E5%BA%93%EF%BC%8C%E6%8F%90%E4%BE%9B%E6%9C%89%E5%85%B3</a> Android 和 Kotlin 的每日见解，涵盖 Compose、架构、行业面试问题和实用代码技巧等主题。自上线以来的短短 37 周内，Dove Letter 已拥有超过 700 名个人订阅者和 20 名企业/终身订阅者。如果你渴望深入了解 Android、Kotlin 和 Compose，请务必查看<a href="https://medium.com/@skydoves/learn-kotlin-and-android-with-dove-letter-26265da11903">“通过 Dove Letter 学习 Kotlin 和 Android”</a>（译注：链接是<a href="https://medium.com/@skydoves/learn-kotlin-and-android-with-dove-letter-26265da11903%EF%BC%89%E3%80%82">https://medium.com/@skydoves/learn-kotlin-and-android-with-dove-letter-26265da11903%EF%BC%89%E3%80%82</a></p>
]]></content>
  </entry>
  
</feed>
