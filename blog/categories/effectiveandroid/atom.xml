<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2024-08-04T21:12:17+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『时乘六龙』| Advanced Gestures]]></title>
    <link href="http://toughcoder.net/blog/2024/08/02/advanced-gesture-in-compose/"/>
    <updated>2024-08-02T07:46:30+08:00</updated>
    <id>http://toughcoder.net/blog/2024/08/02/advanced-gesture-in-compose</id>
    <content type="html"><![CDATA[<p>通过<a href="https://juejin.cn/post/7395020728623480841">前面的一篇文章</a>我们学会了如何用各种高级别抽象的扩展函数来进行手势处理。像clickable，draggable，scrollable和anchoredDraggable都是类似于View系统中的各种回调（如onClick或者onScroll）是高级别的抽象，这里我们只能处理手势，大部分情况下这也够用了。</p>

<p><a href=""><img src="file:///Users/alexhilton/Downloads/compose_libs/gesture/advanced_gesture.jpeg" title="auto auto" ></a></p>

<!-- more -->


<p>但是，对于一些复杂的交互 场景需要我们先识别手势，然后再处理手势，这时就不能再用封装好的扩展函数了，而必须要用到像View系统中的onTouchEvent那样的低级别的回调，直接拿到触点事件，然后再识别手势，最后再处理手势。这篇文章就学习一下如何使用Jetpack Compose中的低级别函数来识别和处理手势。</p>

<h2>处理原始触点事件</h2>

<p>除了使用一些封装好了的扩展函数来直接处理某个手势以外，还可以直接接收原始的事件输入。</p>

<p>Jetpack Compose在Modifier中提供了扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/package-summary#(androidx.compose.ui.Modifier">pointerInput</a>.pointerInput(kotlin.Any,kotlin.Any,kotlin.coroutines.SuspendFunction1))来接收原始的触点事件，与View系统中的<a href="https://developer.android.com/reference/android/view/View.OnTouchListener">onTouch</a>是类似的，这是触点事件的低级别的API。通过此API能获得触点事件，之后可以进行手势识别和手势处理，因为拿到的是原始的触点事件，所以很多逻辑要自己写，有些麻烦，但因为完全可控，所以可以实现一些更为复杂的手势识别和手势处理，比如任意方向的拖拽和滑动，长按后的拖拽，多点触控等等。</p>

<h3>接收触点事件</h3>

<p>扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/package-summary#(androidx.compose.ui.Modifier">pointerInput</a>.pointerInput(kotlin.Any,kotlin.Any,kotlin.coroutines.SuspendFunction1))接收三个参数，前两个都是作为<strong>事件处理回调的标识（keys）</strong>，第三个参数是<strong>事件处理回调</strong>，是一个尾部lambda，当某个key发生变化，这个lambda会重新执行，否则即使发生重组（Recomposition），这个lambda也会不会重新执行。</p>

<pre><code class="Kotlin">fun Modifier.pointerInput(key1: Any?, key2: Any?, block: suspend PointerInputScope.() -&gt; Unit): Modifier
</code></pre>

<p>第三参数就是我们要提供的事件处理回调，它是运行在<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/PointerInputScope">PointerInputScope</a>上下文中的lambda，这个上下文作用域里面有很多扩展函数可以直接使用。仔细看这个lambda是suspend的，这是因为输入事件可能不是即时的，可能会有等待的情况，也就是说lambda是在有事件的时候才会执行。PointerInputScope中的函数也都定义为suspend的，这些函数在lambda中可以直接调用，所以lambda本身也必须 是suspend的。</p>

<p>比如说想要打印触点事件，就可以这样写：</p>

<pre><code class="Kotlin">@Composable
private fun LogPointerEvents(filter: PointerEventType? = null) {
    var log by remember { mutableStateOf("") }
    Column {
        Text(log)
        Box(
            Modifier
                .size(100.dp)
                .background(Color.Red)
                .pointerInput(filter) {
                    awaitPointerEventScope {
                        while (true) {
                            val event = awaitPointerEvent()
                            // handle pointer event
                            if (filter == null || event.type == filter) {
                                log = "${event.type}, ${event.changes.first().position}"
                            }
                        }
                    }
                }
        )
    }
}
</code></pre>

<p>filter是一个事件的类型参数当作key，也当作过滤条件。在事件处理回调lambda中，用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/AwaitPointerEventScope#awaitPointerEvent(androidx.compose.ui.input.pointer.PointerEventPass">awaitPointerEvent</a>)获得每一个触点事件，然后打印出来，<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/AwaitPointerEventScope">awaitPoniterEventScope</a>函数是创建一个协程上下文作用域用以等待事件输入，在其内调用awaitPointerEvent来获得事件。</p>

<h3>识别手势</h3>

<p>虽然pointerInput是一个低级别的接口，但也并不意味着所有的逻辑都必须从头写，在<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/PointerInputScope">PointerInputScope</a>中已经定义了大量的函数可以识别大部分手势：</p>

<ul>
<li>非连续性手势如单击（tap），双击（double tap）和长按（long press）：<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.input.pointer.PointerInputScope">detectTapGestures</a>.detectTapGestures(kotlin.Function1,kotlin.Function1,kotlin.coroutines.SuspendFunction2,kotlin.Function1))</li>
<li>拖拽（drag）：<a href="">detectDragGestures</a>，<a href="">detectDragGesturesAfterLongPress</a>，以及固定方向拖拽<a href="">detectHorizontalDragGestures</a>和<a href="">detectVerticalDragGestures</a></li>
<li>多点触控变幻的手势识别（旋转，平移和缩放）：<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.input.pointer.PointerInputScope">detectTransformGestures</a>.detectTransformGestures(kotlin.Boolean,kotlin.Function4))</li>
</ul>


<p>比如像<a href="https://juejin.cn/post/7395020728623480841">前面文章中</a>提到的拖拽也可以用pointerInput实现：</p>

<pre><code class="Kotlin">@Composable
private fun DraggableTextLowLevel() {
    Box(modifier = Modifier.fillMaxSize()) {
        var offsetX by remember { mutableStateOf(0f) }
        var offsetY by remember { mutableStateOf(0f) }

        Box(
            Modifier
                .offset { IntOffset(offsetX.roundToInt(), offsetY.roundToInt()) }
                .background(Color.Blue)
                .size(50.dp)
                .pointerInput(Unit) {
                    detectDragGestures { change, dragAmount -&gt;
                        change.consume()
                        offsetX += dragAmount.x
                        offsetY += dragAmount.y
                    }
                }
        )
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/gestures-drag.gif" alt="detect_drag_demo" /></p>

<p>前面提到了像detectTapGestures和detectDragGestures都是suspend的函数，所以在一个pointerInter的lambda中只能有一个，比如像下面这样写detectDragGestures不会得到执行：</p>

<pre><code class="Kotlin">var log by remember { mutableStateOf("") }
Column {
    Text(log)
    Box(
        Modifier
            .size(100.dp)
            .background(Color.Red)
            .pointerInput(Unit) {
                detectTapGestures { log = "Tap!" }
                // 不会得到执行，走不到这里，前面一个是suspend的
                detectDragGestures { _, _ -&gt; log = "Dragging" }
            }
    )
}
</code></pre>

<p>一个可行的解决办法就是可以写多个pointerInput，每个ponterInput处理一种手势：</p>

<pre><code class="Kotlin">var log by remember { mutableStateOf("") }
Column {
    Text(log)
    Box(
        Modifier
            .size(100.dp)
            .background(Color.Red)
            .pointerInput(Unit) {
                detectTapGestures { log = "Tap!" }
            }
            .pointerInput(Unit) {
                // These drag events will correctly be triggered
                detectDragGestures { _, _ -&gt; log = "Dragging" }
            }
    )
}
</code></pre>

<h3>直接处理事件</h3>

<p>遇到交互比较复杂的场景，或者当PointerInputScope中提供的识别函数不能解决问题时，或者需要把几种不同的手势组合在一起时，就需要直接处理事件。像View系统中的onTouch一样，我们需要知道不同的事件类型，比如pointer down，pointer move和pointer up等。PointerInputScope中提供了一个函数awaitEachGesture可以取代while (true)来获得每个事件；awaitFirstDown，是手势的开始相当于ACTION&#95;DOWN；waitForUpOrCancellation是事件结束，相当于ACTION&#95;UP和ACTION&#95;CANCEL；drag相当于ACTION&#95;MOVE。我们来看一个例子：</p>

<pre><code class="Kotlin">@Composable
private fun LogPointerEvents() {
    var log by remember { mutableStateOf("") }
    Column(
        modifier = Modifier.fillMaxSize(),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        Text(log)
        Box(
            Modifier
                .size(240.dp)
                .background(Color.DarkGray)
                .pointerInput(Unit) {
                    awaitEachGesture {
                        val down = awaitFirstDown().also {
                            log = "Action Down"
                        }
                        var change = awaitTouchSlopOrCancellation(down.id) { ch, _ -&gt;
                            ch.consume()
                        }
                        while (change != null &amp;&amp; change.pressed) {
                            change = awaitDragOrCancellation(change.id)
                            if (change != null &amp;&amp; change.pressed) {
                                log = "Action Move ${change.type} ${change.position}"
                            }
                        }
                        log = "Action Up"
                    }
                }
        )
    }
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/gesture/event.gif" alt="event_demo" /></p>

<p>需要注意的是这些函数都是suspend的，也就是说当预期的行为发生时才会带着结果返回，比如awaitFirstDown()当有第一个触点事件发生时结束suspend然后返回；awaitTouchSlopOrCancellation当有超过拖拽阈值时结束suspend然后返回；awaitDragOrCancellation当有拖拽发生时结束suspend返回。</p>

<h2>触点事件的派发流程</h2>

<p>为了更好的处理事件，需要了解一下Jetpack Compose的事件派发流程，与View系统是类似的，事件派发的过程也是沿着Composable的树形结构，从父Composable到子Composable，同一层级的顺序则是从上到下，从前到后（Z轴方向），依次做『Hit test』，直到事件被消费，就停止派发。</p>

<p>事件的消费过程则是反过来，子Composable如果未消费就返回给父Composable，前面的Composable未消费，就继续向下传递，直到事件被消费。</p>

<p>如果是自己在pointerInput中直接处理事件，就要特别注意手动的把事件给消费掉，否则可能会继续传递。像awaitPointerEvent，awaitFirstDown，awaitDragOrCancellation等返回的都是<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/PointerInputChange">PointerInputChange</a>对象，调用它的<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/PointerInputChange#consume(">consume()</a>)方法即可把事件消费掉。再比如像上面的例子awaitTouchSlopOrCancellation中，也需要手动的把事件给消费掉，如果把ch.consume()这句删除，就会发现awaitDragOrCancellation不会得到执行，这是因为awaitTouchSlopOrCancellation这个方法还在执行中，调用ch.consume()把事件消费掉，这个函数才会返回。</p>

<p>这也说明了，还是要尽量用系统封装好的手势识别和手势处理函数，不到万不得已不要直接处理原始事件，因为逻辑写起来肯定相当复杂。</p>

<h2>多点触控</h2>

<p>多点触控是超过一个触点同时在屏幕上操作，最为常见的手势就是旋转和缩放，可以使用扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">transformable</a>.transformable(androidx.compose.foundation.gestures.TransformableState,kotlin.Boolean,kotlin.Boolean))监听旋转，平移和缩放手势，其中平移单个触点也能触发，缩放和旋转则需要两个触点，当超过3个触点时这个函数不会回调，也即不会触发任何手势：</p>

<pre><code class="Kotlin">@Composable
private fun TransformableSample() {
    // set up all transformation states
    var scale by remember { mutableStateOf(1f) }
    var rotation by remember { mutableStateOf(0f) }
    var offset by remember { mutableStateOf(Offset.Zero) }
    val state = rememberTransformableState { zoomChange, offsetChange, rotationChange -&gt;
        scale *= zoomChange
        rotation += rotationChange
        offset += offsetChange
    }
    Box(
        Modifier
            // 把参数应用到图层去做变幻
            .graphicsLayer(
                scaleX = scale,
                scaleY = scale,
                rotationZ = rotation,
                translationX = offset.x,
                translationY = offset.y
            )
            // 接收变幻手势
            .transformable(state = state)
            .background(Color.Blue)
            .fillMaxSize()
    )
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/gestures-multitouch.gif" alt="multi_touch_demo" /></p>

<p>除了直接使用Modifier.transformable以外，还可以用前面提到过的pointerInput中的<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.input.pointer.PointerInputScope">detectTransformGestures</a>.detectTransformGestures(kotlin.Boolean,kotlin.Function4))这个函数也能得到平移，旋转和缩放的变化数值，把这些数值应用到graphicsLayer去做变幻就可以了，使用detectTransformGestures的另一个好处是可以与其他的手势结合起来。</p>

<h2>总结</h2>

<p>通过本文我们学习如何得到原始的触点事件，以及如何识别手势，相信对触点事件以及手势识别有了更深入的理解，并且借助这些扩展函数就可以写出交互性更好的应用程序界面。即使遇到一些复杂的交互 场景，或者需要组合多种手势时，也都能从容应对。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/understand-gestures">Understand gestures</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/multi-touch">Multitouch: Panning, zooming, rotating</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/user-interactions/handling-interactions">Handling user interactions</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『鱼跃于渊』| Gesture Handling]]></title>
    <link href="http://toughcoder.net/blog/2024/07/29/pointer-event-in-compose/"/>
    <updated>2024-07-29T20:41:20+08:00</updated>
    <id>http://toughcoder.net/blog/2024/07/29/pointer-event-in-compose</id>
    <content type="html"><![CDATA[<p>UI是用户界面，一个最为基础的功能就是与用户进行交互，要具有可交互性。要想有可交互性就需要处理用户输入事件。手势是最为常见的一种用户输入，今天就来专门学习一下如何处理Jetpack Compose中最为常见的手势。</p>

<p><a href=""><img src="https://koenig-media.raywenderlich.com/uploads/2022/10/GesturesInJetpackCompose-twitter.png" title="auto auto" ></a></p>

<!-- more -->


<h2>输入事件与手势概述</h2>

<p>在开始学习之前有必要先澄清一些概念，以免混淆。与View系统不太一样的是，触摸事件在Jetpack Compose中称之为触点事件（Pointer event），对应的主体称之为触点（Pointer），一连串的触点事件就形成了手势（Gesture）。之所以叫触点，是因为并不总是由触摸屏幕触发事件，也可以是手写笔，（外接）鼠标或者（外接）触摸板，这些都是触控类的输入主体，它的最主要的特点是发生在屏幕上的一个坐标点。其具体的类型称之为触点类型（Pointer type）。</p>

<p>事件处理最主要的是也就是要识别各种不同的触点手势，然后做出响应，以让UI具体可交互性。</p>

<h2>点击事件（Tap and Press）</h2>

<p>点击事件是最为常见，也是最为基础的一种手势了，可以简单的看成按下事件（pointer down）和抬起事件（pointer up）组成，但其实也会有移动（pointer move），只不过移动的位移特别小而已，这里我们不过多的纠结。点击事件分为单击，双击和长按，幸运的是在Compose中都有封装好的回调函数可以直接使用，我们一一来看一下。</p>

<h3>单击（Tap/Click）</h3>

<p>单击是最为常见的事件处理了，在之前的教程已经见过了，通过Modifier的扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier">Modifier.clickable</a>.clickable(kotlin.Boolean,kotlin.String,androidx.compose.ui.semantics.Role,kotlin.Function0))就可以为任意一个Composable设置单击事件处理函数。</p>

<h3>双击（Double tap/Double click）和长按（LongPress/Long click）</h3>

<p>对于双击和长按，并不像clickable那样常用，因此需要用到另外一个扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier">Modifier.combinedClickable</a>.combinedClickable(androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.foundation.Indication,kotlin.Boolean,kotlin.String,androidx.compose.ui.semantics.Role,kotlin.String,kotlin.Function0,kotlin.Function0,kotlin.Function0))，这个函数可以设置多个点击事件处理函数，单击双击和长按都可以通过它来设置：</p>

<pre><code class="Kotlin">    Box(
        modifier = Modifier
            .size(100.dp)
            .background(Color.Yellow)
            .combinedClickable(
                onClick = { gotoDetail() },
                onClickLabel = "Go to details",
                onLongClick = { showContextMneu() },
                onLongClickLabel = "Open context menu",
                onDoubleClick = { shareContent() }
            )
    )
</code></pre>

<h2>滚动（Scroll）</h2>

<p>滚动手势是指朝着某一固定的方向慢速的滑动，多用于查看屏幕之外的内容。像集合性布局设计的目的就是为了显示大量的同一类型的数据集合，天生就支持滚动。对于滚动手势需要处理的就是常规布局支持滚动，以及滚动的嵌套。</p>

<h3>非集合性布局支持滚动</h3>

<p>对于常规的非集合性布局（Box，Row和Column）正常情况下是不可滚动的，是没有办法查看超出其尺寸大小范围的内容的。想让这几个布局可滚动也不难，用Modifier的扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier">verticalScroll</a>.verticalScroll(androidx.compose.foundation.ScrollState,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean))和<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier">horizontalScroll</a>.horizontalScroll(androidx.compose.foundation.ScrollState,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean))就可以让不可滚动布局（Box，Row和Column）支持垂直方向滚动和水平方向滚动：</p>

<pre><code class="Kotlin">@Composable
private fun ScrollBoxes() {
    Column(
        modifier = Modifier
            .background(Color.LightGray)
            .size(100.dp)
            .verticalScroll(rememberScrollState())
    ) {
        repeat(10) {
            Text("Item $it", modifier = Modifier.padding(2.dp))
        }
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/gestures-simplescroll.gif" alt="scrollable_box" /></p>

<p>大部分情况下，如果只是想让布局可滚动就不需要处理<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/ScrollState">ScrollState</a>，但如果想要获取滚位置，或者改变滚动位置，比如说页面进入时（Initial composition）自动滚动到某一们位置，可以通过修改<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/ScrollState">SrollState</a>来实现：</p>

<pre><code class="Kotlin">@Composable
private fun ScrollBoxesSmooth() {
    // 进入页面时就自动的平滑的滚动
    val state = rememberScrollState()
    LaunchedEffect(Unit) { state.animateScrollTo(100) }

    Column(
        modifier = Modifier
            .background(Color.LightGray)
            .size(100.dp)
            .padding(horizontal = 8.dp)
            .verticalScroll(state)
    ) {
        // ...
    }
}
</code></pre>

<h3>滚动手势处理</h3>

<p>对于任意的Composable来文章，都可以通过Modifier的扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.Modifier">scrollable</a>.scrollable(androidx.compose.foundation.gestures.ScrollableState,androidx.compose.foundation.gestures.Orientation,kotlin.Boolean,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,androidx.compose.foundation.interaction.MutableInteractionSource))来监听并处理滚动手势。需要注意的是，scrollable仅会告诉你有滚动手势发生和当前的滚动距离，但并不会直接修改布局，需要开发者去使用滑动距离进行布局的修改：</p>

<pre><code class="Kotlin">@Composable
private fun ScrollableSample() {
    // actual composable state
    var offset by remember { mutableStateOf(0f) }
    Box(
        Modifier
            .size(150.dp)
            .scrollable(
                orientation = Orientation.Vertical,
                // Scrollable state: describes how to consume
                // scrolling delta and update offset
                state = rememberScrollableState { delta -&gt;
                    offset += delta
                    delta
                }
            )
            .background(Color.LightGray),
        contentAlignment = Alignment.Center
    ) {
        Text(offset.toString())
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/gestures-numeric-offset.gif" alt="handle_scrollable" /></p>

<p>如果让滚动对布局产生影响，可以用计算得到offset去改变布局的offset属性offset(y = offset.dp)就可以了。</p>

<h3>滚动嵌套</h3>

<p>手势处理最大的一个麻烦就是手势的嵌套，而又以滚动的嵌套最为麻烦，最为典型的就是同一方向的列表中套着列表，开发者必须手动处理滑动冲突。滚动冲突处理的策略并不难，优先由子View消费滚动事件，当子View还可以滚动时，就把事件消费掉；如果子View已到达边界，无法滚动时，视为事件未消费，把事件再传递给父View，由父View消费，这时父View会进行滚动；当然如果滑动事件没有发生在子View上面，那肯定 是父View滚动。</p>

<p>策略虽然简单，但有魔鬼细节，传统的View必须要在onTouch和onInterceptTouch里面写上大坨大坨的逻辑，还要定义很多个全局变量。幸运的是，针对 于同方向的可滚动布局嵌套，Jetpack Compose已经帮我们处理了。对于使用verticalScroll，horizontalScroll，scrollable，集合性布局（LazyRow，LazyColumn和LazyGrid）和TextField实现的同方向滚动嵌套，不用再特殊处理，Compose已经按照前面说的策略处理好了，这就是<strong>自动嵌套滚动机制（Automatic nested scrolling）</strong>。来看一个例子：</p>

<pre><code class="Kotlin">@Composable
private fun AutomaticNestedScroll() {
    val gradient = Brush.verticalGradient(0f to Color.Yellow, 1000f to Color.Red)
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .height(400.dp)
            .background(Color.LightGray)
            .verticalScroll(rememberScrollState())
            .padding(32.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        repeat(6) {
            Box(
                modifier = Modifier
                    .height(128.dp)
                    .verticalScroll(rememberScrollState())
            ) {
                Text(
                    "$it 滑动试试！",
                    modifier = Modifier
                        .align(Alignment.Center)
                        .border(12.dp, Color.DarkGray)
                        .background(brush = gradient)
                        .padding(24.dp)
                        .height(150.dp)
                )
            }
        }
    }
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/gesture/ascroll.gif" alt="nested_scrolling" />
这个例子中外层Column支持垂直滚动，里面的每个Box也支持垂直滚动，当里面的Box自己消费滚动时，外层 是不会动的，而当里面的Box无法滚动时（overscrolled）事件就到了外层的Column，即Column会滚动。</p>

<p><strong>注意：</strong>滚动嵌套并不是一个好的交互设计，尽管有技术手段解决，但用起来仍旧是怪怪的，操作起来也并不方便，误操作的可能性很大。不同方向的滚动嵌套在一起是比较好的方案，比如横向的Tab页代表不同的分类，竖向的内容页是一个分类中的具体内容，内容是竖向的，内容中仍旧可以有一些横向滑动的扩展内容，如图片库，tag标签等。</p>

<h2>拖拽（Drag）</h2>

<p>拖拽是指按住屏幕慢速移动，被点击到的UI元素应该跟随手势移动并停留在触点离开屏幕的地方。通过扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.Modifier">Modifier.draggable</a>.draggable(androidx.compose.foundation.gestures.DraggableState,androidx.compose.foundation.gestures.Orientation,kotlin.Boolean,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Boolean,kotlin.coroutines.SuspendFunction2,kotlin.coroutines.SuspendFunction2,kotlin.Boolean))可以处理单一方向的拖拽手势。在draggable中我们可以用状态记录移动的距离，然后把距离应用到Composable的offset以生成拖拽后的效果：</p>

<pre><code class="Kotlin">@Composable
private fun DraggableText() {
    var offsetX by remember { mutableStateOf(0f) }
    Text(
        modifier = Modifier
            .offset { IntOffset(offsetX.roundToInt(), 0) }
            .background(Color.LightGray)
            .padding(8.dp)
            .draggable(
                orientation = Orientation.Horizontal,
                state = rememberDraggableState { delta -&gt;
                    offsetX += delta
                }
            ),
        text = "降Compose十八掌！",
        style = MaterialTheme.typography.headlineLarge,
        color = MaterialTheme.colorScheme.primary
    )
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/gesture/drag.gif" alt="drag_demo" /></p>

<h2>滑动（Swipe/Fling）</h2>

<p>滑动与拖拽的区别在于滑动是有速度的，滑动手势在触点离开屏幕后并不会立即停止，而且是会继续朝原方向减速直到速度变为0才停，最为常见的交互方式就是滑动删除（swipe-to-dismiss），以及像列表的Fling手势。</p>

<p>使用Modifier的扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.Modifier">anchoredDraggable</a>.anchoredDraggable(androidx.compose.foundation.gestures.AnchoredDraggableState,androidx.compose.foundation.gestures.Orientation,kotlin.Boolean,kotlin.Boolean,androidx.compose.foundation.interaction.MutableInteractionSource))来处理滑动事件，定义一些<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/DraggableAnchors">锚点（DraggableAnchors）</a>，视为一个手势操作中的不同状态，比如像滑动开关，就是开和关，像滑动删除就是正常和已删除，再用一个<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/AnchoredDraggableState">AnchoredDraggableState</a>来追踪滑动的状态，这里面可以定义初始锚点，锚点值，和终止状态的阈值（positionalThreshold超过一定位置就认为到达终点锚点，velocityThreshold速度小于这个时就认为到达终点锚点），以及手势过程中的动画（animationSpec）。然后，再把AnchoredDraggableState中的滑动距离offset设置到Composable中即可。</p>

<p>说的挺复杂，其实很直观，看一个例子就明了：</p>

<pre><code class="Kotlin">enum class SwipeableSwitchState {
    SWITCH_ON, SWITCH_OFF
}

@OptIn(ExperimentalFoundationApi::class)
@Composable
private fun SwipeableSample() {
    val width = 128.dp
    val squareSize = 64.dp

    val density = LocalDensity.current
    val sizePx = with(density) { squareSize.toPx() }
    val anchors = DraggableAnchors {
        SwipeableSwitchState.SWITCH_ON at sizePx
        SwipeableSwitchState.SWITCH_OFF at 0f
    }
    val swipeableState = remember {
        AnchoredDraggableState(
            initialValue = SwipeableSwitchState.SWITCH_OFF,
            anchors = anchors,
            positionalThreshold = { d: Float -&gt; d * 0.4f },
            velocityThreshold = { with(density) { 100.dp.toPx() } },
            animationSpec = tween()
        )
    }
    Box(
        modifier = Modifier
            .width(width)
            .anchoredDraggable(
                state = swipeableState,
                orientation = Orientation.Horizontal,
                startDragImmediately = false
            )
            .background(Color.LightGray)
    ) {
        Box(
            Modifier
                .offset {
                    IntOffset(
                        if (swipeableState.offset.isNaN()) 0 else swipeableState.offset.roundToInt(),
                        0
                    )
                }
                .size(squareSize)
                .background(Color.DarkGray)
        )
    }
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/gesture/swipe.gif" alt="swipe_demo" />
这个例子展示了一个滑动开关的手势处理，滑动距离超过整体长度0.4时，或者速度小于100时就认为到达另一锚点状态。可以明显的看出与拖拽的区别，滑动后手可以离开，但手势仍在继续直到达到终点锚点。</p>

<p><strong>注意：</strong>在Compose 1.6版本以前有另外一个扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#(androidx.compose.ui.Modifier">swipeable</a>.swipeable(androidx.compose.material.SwipeableState,kotlin.collections.Map,androidx.compose.foundation.gestures.Orientation,kotlin.Boolean,kotlin.Boolean,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Function2,androidx.compose.material.ResistanceConfig,androidx.compose.ui.unit.Dp))来处理滑动手势，但在1.6版本时已废弃，被anchoredDraggable取代，并且有一个<a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/migrate-swipeable">替换的教程</a>。</p>

<h2>未完待续</h2>

<p>事件处理对于UI来说是极其重要的，本篇重点讲述了Jetpack Compose中的最为基础和最为常见的事件处理方式，足以满足绝大多数应用场景。事件处理也是极其复杂的，对于交互极其复杂的页面来说，还需要进一步的了解更为底层的事件处理方法，以达到复杂交互的目的，将在后面的文章中继续深入探讨事件处理。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/tap-and-press">Tap and press</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/drag-swipe-fling">Drag, swipe, and fling</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/scroll">Scroll</a></li>
<li><a href="https://canopas.com/how-to-implement-swipe-to-action-using-anchoreddraggable-in-jetpack-compose-cccb22e44dff">How to Implement Swipe-to-Action using AnchoredDraggable in Jetpack Compose</a></li>
<li><a href="https://fvilarino.medium.com/exploring-jetpack-compose-anchored-draggable-modifier-5fdb21a0c64c">Exploring Jetpack Compose Anchored Draggable Modifier</a></li>
<li><a href="https://medium.com/@AungThiha3/jetpack-compose-anchored-draggable-item-in-motionlayout-part-1-8d5a1cde880f">Jetpack Compose: Anchored Draggable Item in MotionLayout Part 1</a></li>
<li><a href="https://medium.com/@AungThiha3/jetpack-compose-anchored-draggable-item-in-motionlayout-part-2-c1fd94188e56">Jetpack Compose: Anchored Draggable Item in MotionLayout Part 2</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『双龙取水』| Text Edit]]></title>
    <link href="http://toughcoder.net/blog/2024/07/24/text-edit-in-compose/"/>
    <updated>2024-07-24T08:28:55+08:00</updated>
    <id>http://toughcoder.net/blog/2024/07/24/text-edit-in-compose</id>
    <content type="html"><![CDATA[<p>文本是所有UI系统中非常重要的一个种元素，文本的输入在UI框架中的重要性也特别的高，因为这是最重要的一种用户输入。今天专注于文本的输入处理，包括文本输入框，以及文本的选择和富式点击处理。</p>

<p><a href=""><img src="https://static.wixstatic.com/media/0d004d_ea93b43aabf348cb8f96c0dc94f85365~mv2.jpg/v1/fit/w_1000%2Ch_600%2Cal_c%2Cq_80/file.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>文本输入</h2>

<p>Compose提供了符合<a href="https://material.io/components/text-fields">Material Design</a>的文本输入<a href="https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#TextField(androidx.compose.ui.text.input.TextFieldValue,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Boolean,androidx.compose.ui.text.TextStyle,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Boolean,androidx.compose.ui.text.input.VisualTransformation,androidx.compose.foundation.text.KeyboardOptions,androidx.compose.foundation.text.KeyboardActions,kotlin.Boolean,kotlin.Int,kotlin.Int,androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.ui.graphics.Shape,androidx.compose.material.TextFieldColors">TextField</a>)，默认的实现是全填充的：</p>

<pre><code class="Kotlin">@Composable
fun SimpleFilledTextFieldSample() {
    var text by remember { mutableStateOf("Hello") }

    TextField(
        value = text,
        onValueChange = { text = it },
        label = { Text("Label") }
    )
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-textfield-hello.png" alt="textfield" />
还有一个边框式的<a href="https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#OutlinedTextField(kotlin.String,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Boolean,androidx.compose.ui.text.TextStyle,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Boolean,androidx.compose.ui.text.input.VisualTransformation,androidx.compose.foundation.text.KeyboardOptions,androidx.compose.foundation.text.KeyboardActions,kotlin.Boolean,kotlin.Int,kotlin.Int,androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.ui.graphics.Shape,androidx.compose.material.TextFieldColors">OutlinedTextField</a>)：</p>

<pre><code class="Kotlin">@Composable
fun SimpleOutlinedTextFieldSample() {
    var text by remember { mutableStateOf("") }

    OutlinedTextField(
        value = text,
        onValueChange = { text = it },
        label = { Text("Label") }
    )
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-outlinedtextfield.png" alt="outlined_textfield" />
可以看到TextField函数最关键的有三个参数：文本框中的显示的文本text，文本变化回调onValueChange，提示标签label。需要注意传给text的变量要是状态（State），这样才会触发重组，否则TextField显示的文本不会发生变化。</p>

<h3>定制TextField</h3>

<p>可以通过其他的参数来控制输入框的行为，最为常用的就是行数限制singleLine和maxLines， 以及文本的样式控制textStyle，它可以控制文本颜色和字体：</p>

<pre><code class="Kotlin">@Composable
fun StyledTextField() {
    var value by remember { mutableStateOf("Hello\nWorld\nInvisible") }

    TextField(
        value = value,
        onValueChange = { value = it },
        label = { Text("Enter text") },
        maxLines = 2,
        textStyle = TextStyle(color = Color.Blue, fontWeight = FontWeight.Bold),
        modifier = Modifier.padding(20.dp)
    )
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-textfield-multiline.png" alt="textfield_customize" />
textStyle比较丰富，除了直接指定颜色以外，还可以用<a href="https://developer.android.com/develop/ui/compose/text/style-text#brush">Brush API</a>，以实现一些颜色渐变，渐变效果是针对整个输入框的，换言之不同的行效果是一样的：</p>

<pre><code class="Kotlin">var text by remember { mutableStateOf("") }
val brush = remember {
    Brush.linearGradient(
        colors = listOf(Color.RED, Color.YELLOW, Color.GREEN, Color.BLUE)
    )
}
TextField(
    value = text, onValueChange = { text = it }, textStyle = TextStyle(brush = brush)
)
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-textfieldgradient.gif" alt="brush_textstyle" /></p>

<h3>与键盘联动</h3>

<p>TextField能够配置软件盘以实现特定输入样式，比如只输入数字，只有英文字符等等，通过TextField的keyboardOptions参数，传入一个<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/KeyboardOptions#KeyboardOptions(androidx.compose.ui.text.input.KeyboardCapitalization,kotlin.Boolean,androidx.compose.ui.text.input.KeyboardType,androidx.compose.ui.text.input.ImeAction">KeyboardOptions</a>)对象。常用的配置项有：</p>

<ul>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/KeyboardCapitalization">capitalization</a> 对于有大小写的语言来说，输入时词首自动大写</li>
<li>autoCorrect 自动更正</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/KeyboardType">keyboardType</a> 键盘类型，如纯字符，纯数字，E-mail地址，网址等等</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/ImeAction">imeAction</a> 让键盘的显示输入完成后的行为相关的按扭，比如<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/ImeAction#Search(">『搜索（Search）』</a>)，<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/ImeAction#Send(">『发送（Send）』</a>)等</li>
</ul>


<p>当输入完成后，用户点了imeAction指定的按扭后，可以指定回调函数以执行相关的操作，通过keyboardActions参数指定一个<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/KeyboardActions">KeyboardActions</a>对象，里面可以指定对应于imeAction中的各种回调，如onSearch会在imeAction指定为Search时，用户点击后触发；onSend会在imeAction是Send时，用户点击触发，等等。</p>

<h3>特殊形式的输入</h3>

<p>有些特殊的场景是不能够直接把用户的输入文本直接的展现在框里，比如输入密码时，再比如像输入电话号码时，可能会自动在3个数字后面加上短横线。这时就需要用到<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/VisualTransformation">VisualTransformation</a>来对文本进行转换处理：</p>

<pre><code class="Kotlin">@Composable
fun PasswordTextField() {
    var password by rememberSaveable { mutableStateOf("") }

    TextField(
        value = password,
        onValueChange = { password = it },
        label = { Text("Enter password") },
        visualTransformation = PasswordVisualTransformation(),
        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password)
    )
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-textfield-password.png" alt="password_textfield" /></p>

<h3>文本状态管理</h3>

<p>TextField的文本（text参数）是需要转换成状态的，这样才能更好的触发重组。基础的通用的TextField使用方式是，把文本转成状态，塞给TextField，然后在其onValueChange中再更新此状态：</p>

<pre><code class="Kotlin">    // ...
    var text by remember { mutableStateOf("") }

    TextField(
        value = text,
        onValueChange = { text = it },
    )
    // ...
</code></pre>

<p>但现实的代码不可能这么简单，用户的输入必然会有业务逻辑去处理，所以onValueChange肯定会调用ViewModel去处理用户输入。那么自然也要从ViewModel处获得。但由于TextField的特殊性，仍然要把使用MutableState来定义状态，而不能用响应式的Reactive stream或者StateFlow：</p>

<pre><code class="Kotlin">class SignUpViewModel(private val userRepository: UserRepository) : ViewModel() {

    var username by mutableStateOf("")
        private set

    fun updateUsername(input: String) {
        username = input
    }
}

// SignUpScreen.kt

@Composable
fun SignUpScreen(/*...*/) {

    OutlinedTextField(
        value = viewModel.username,
        onValueChange = { username -&gt; viewModel.updateUsername(username) }
        /*...*/
    )
}
</code></pre>

<h2>文本的选择</h2>

<p>除了文本输入以外，文本显示的选择也视为文字编辑的一种方式，因为选择之后就可以执行复制或者搜索等全局操作。Compose提供了细粒度的可交互式文本显示控制。Text本身是不支持选择的（Not Selectable），自然也就无法复制。可以使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/selection/package-summary#SelectionContainer(androidx.compose.ui.Modifier,kotlin.Function0">SelectableContainer</a>)来包裹Text以实现可选择（Selectable）：</p>

<pre><code class="Kotlin">@Composable
fun SelectableText() {
    SelectionContainer {
        Text("This text is selectable")
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-selected.png" alt="selectable_text" />
并且，可选择区域可以跨多个Text。与之相对的，还有不可选择函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/selection/package-summary#DisableSelection(kotlin.Function0">DisableSelection</a>)，比如一大片可选择文本中，想让某一小块文本不能被选择，这时DisableSelection就派上用场了：</p>

<pre><code class="Kotlin">@Composable
fun PartiallySelectableText() {
    SelectionContainer {
        Column {
            Text("This text is selectable")
            Text("This one too")
            Text("This one as well")
            DisableSelection {
                Text("But not this one")
                Text("Neither this one")
            }
            Text("But again, you can select this one")
            Text("And this one too")
        }
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-partially-selected.png" alt="disable_selection" /></p>

<p>可以看出对于文本的选择控制还是相当的灵活的（flexible）。</p>

<h2>富式文本点击</h2>

<p>对于针对 整个文本的点击事件可以用Modifier中的<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier">clickable</a>.clickable(kotlin.Boolean,kotlin.String,androidx.compose.ui.semantics.Role,kotlin.Function0))函数来处理，这跟常规的Composable没区别都一样的。但对于文本来说有更为细腻的点击事件处理，包括获取具体点击的光标位置，以及富式文本点击，也即针对 文本中不同部分的响应。</p>

<h3>获取点击的光标位置</h3>

<p>想要获取到文本中点击的光标位置，其实也就是点击的是第几个字符，可以用<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/package-summary#ClickableText(androidx.compose.ui.text.AnnotatedString,androidx.compose.ui.Modifier,androidx.compose.ui.text.TextStyle,kotlin.Boolean,androidx.compose.ui.text.style.TextOverflow,kotlin.Int,kotlin.Function1,kotlin.Function1">ClickableText</a>)，它有一个自己的onClick回调函数，里面的参数是一个offset表示被点击字符的索引：</p>

<pre><code class="Kotlin">@Composable
fun SimpleClickableText() {
    ClickableText(text = AnnotatedString("Click Me"), onClick = { offset -&gt;
        Log.d("ClickableText", "$offset -th character is clicked.")
    })
}
</code></pre>

<p>注意onClick的参数是文本字符串的索引，从0开始。这个索引一般用来确定点击的富文本中的某一个标记（Annotation）。</p>

<h3>富文本的点击处理</h3>

<p>Text是支持富文本的（基于<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/AnnotatedString">AnnotatedString</a>）。通过ClickableText中onClick的索引参数，就能知道点击的具体是哪个Annotation。比如一个超链接标记，具体的URL对用户是不可见的，作为额外的Tag信息在Annotation中，通过索引判断当点击到了超链接上面时，可以跳转到此URL：</p>

<pre><code class="Kotlin">@Composable
fun AnnotatedClickableText() {
    val annotatedText = buildAnnotatedString {
        append("Click ")

        // We attach this *URL* annotation to the following content
        // until `pop()` is called
        pushStringAnnotation(
            tag = "URL", annotation = "https://developer.android.com"
        )
        withStyle(
            style = SpanStyle(
                color = Color.Blue, fontWeight = FontWeight.Bold
            )
        ) {
            append("here")
        }

        pop()
    }

    ClickableText(text = annotatedText, onClick = { offset -&gt;
        // We check if there is an *URL* annotation attached to the text
        // at the clicked position
        annotatedText.getStringAnnotations(
            tag = "URL", start = offset, end = offset
        ).firstOrNull()?.let { annotation -&gt;
            // If yes, we log its value
            Log.d("Clicked URL", annotation.item)
        }
    })
}
</code></pre>

<h2>总结</h2>

<p>本文介绍了两种最常规的文本编辑，一是文本输入，一个是文本的选择和点击，这些都是日常项目开发中的非常常见的需求。Jetpack Compose对文本的操作提供了非常友好的支持，能够应付绝大部分的需求场景。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/text/user-input">Handle user input</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/text/user-interactions">Enable user interactions</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『或跃在渊』| Advanced Animations]]></title>
    <link href="http://toughcoder.net/blog/2024/07/24/advanced-animations-in-compose/"/>
    <updated>2024-07-24T08:26:32+08:00</updated>
    <id>http://toughcoder.net/blog/2024/07/24/advanced-animations-in-compose</id>
    <content type="html"><![CDATA[<p>对于Jetpack Compose来说动画是一个很大的话题，对应的API也比较繁杂，我们在<a href="https://juejin.cn/post/7385758285960609831">前面一篇文章</a>中介绍了最为常用的创建动画的方式，在此基础之上来学习一些更为复杂的动画玩法。</p>

<p><a href=""><img src="https://static.wixstatic.com/media/0d004d_3306bc9db6214c459f675f2a417cc718~mv2.jpeg/v1/fit/w_1000%2Ch_600%2Cal_c%2Cq_80/file.jpeg" title="auto auto" ></a></p>

<!-- more -->


<h2>动画的本质：参数随时间变化</h2>

<p>前面的文章提到过属性驱动动画，比如<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/package-summary#animateFloatAsState(kotlin.Float,androidx.compose.animation.core.AnimationSpec,kotlin.Float,kotlin.String,kotlin.Function1">animateFloatAsState</a>)，本质上就是让数值随时间变化，数值再作为Composable的属性去驱动变幻，进而产生动画效果。那一坨animate&#42;AsState都是通过一个animateValueAsState函数来实现的，这个函数是一个泛型，它可以把任意的数据类型转成随时间变化的动画状态。所以当遇到自定义的数据类型时，就可以使用animateValueAsState来驱动动画。这些属性动画函数animate&#42;AsState是基于更底层的<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Animatable">Animatable</a>实现的。</p>

<h2>使用Transition来组合属性动画</h2>

<p>当动画比较复杂时，比如涉及多个属性的变化时，如果仍然使用animate&#42;AsState那一坨，虽然也是可以行的，但会让代码和逻辑都混乱不堪，特别是如果要协调多个属性动画时就更为困难。这样实现还有一个更大的问题，那就是无法复用，理论上来说动画与UI应该解耦，即使没有动效UI也是可用的，动效也应该可以应用于不同的UI。</p>

<p>这时就可以使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Transition">Transition</a>来管理和组合多个属性动画。但是Transition并不是像<a href="https://developer.android.com/reference/android/animation/AnimatorSet">AnimatorSet</a>那样的单纯的管理器，它其实是另一种概念的抽象，意为过渡，从一种状态过渡到另一种状态，状态变化的细节就是各种属性的变化。Transition支持泛型，也就是状态完全自定义，Transition定义了很多变更数值的方法如animateFloat，animateColor，animateDp等等可以用于更新不同的属性数值。前一篇文章中提到的所见即所得的动画函数（AnimatedVisibility，Crossfade和AnimatedContent）都是基于Transition来实现的。而Transition与属性动画函数animate&#42;AsState并不一样，是基于更底层的<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Animation">Animation</a>实现的。</p>

<h3>Transition创建动画的具体步骤</h3>

<p>Transition是对两个不同的状态之间过渡的封装，因此先要定义状态，基于动效的目标和特点定义状态即可，一般用枚举类型就行了，因为状态仅用于代表过渡中的一个时间点，并没有具体的意义。接下来，使用remember函数转成为Compose的State，以便能触发Recomposition，然后调用函数updateTransition来得到当前时刻的过渡状态：</p>

<pre><code class="Kotlin">enum class BoxState {
    Collapsed,
    Expanded
}
var currentState by remember { mutableStateOf(BoxState.Collapsed) }
val transition = updateTransition(currentState, label = "box state")
</code></pre>

<p>这三步是通用的，使用Transition时都一样。然后就是对于当前时刻过渡状态的去定义具体的属性数值，这步也是自定义的，看要实现的动效而定，可以使用扩展函数animate&#42;来得到的具体的数值：</p>

<pre><code class="Kotlin">val rect by transition.animateRect(label = "rectangle") { state -&gt;
    when (state) {
        BoxState.Collapsed -&gt; Rect(0f, 0f, 100f, 100f)
        BoxState.Expanded -&gt; Rect(100f, 100f, 300f, 300f)
    }
}
val borderWidth by transition.animateDp(label = "border width") { state -&gt;
    when (state) {
        BoxState.Collapsed -&gt; 1.dp
        BoxState.Expanded -&gt; 0.dp
    }
}
</code></pre>

<p>最后，把得到的属性数值rect和borderWidth应用到Composable上即可。</p>

<h3>Transition是支持创建子Transition</h3>

<p>对于Composable结构复杂的情况时，还可以使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Transition#(androidx.compose.animation.core.Transition">createChildTransition</a>.createChildTransition(kotlin.String,kotlin.Function1))来为子布局创建Transition。这样就能够把Transition也按树形关系组织起来，以能让动效更加的协调。</p>

<h3>使用Transition来封装动画</h3>

<p>使用Transition最大的好处在于能够把动效封装起来以能复用：</p>

<pre><code class="Kotlin">enum class BoxState { Collapsed, Expanded }

// Holds the animation values.
private class TransitionData(
    color: State&lt;Color&gt;,
    size: State&lt;Dp&gt;
) {
    val color by color
    val size by size
}

// Create a Transition and return its animation values.
@Composable
private fun updateTransitionData(boxState: BoxState): TransitionData {
    val transition = updateTransition(boxState, label = "box state")
    val color = transition.animateColor(label = "color") { state -&gt;
        when (state) {
            BoxState.Collapsed -&gt; Color.Gray
            BoxState.Expanded -&gt; Color.Red
        }
    }
    val size = transition.animateDp(label = "size") { state -&gt;
        when (state) {
            BoxState.Collapsed -&gt; 64.dp
            BoxState.Expanded -&gt; 128.dp
        }
    }
    return remember(transition) { TransitionData(color, size) }
}
</code></pre>

<p>创建好的Transition可以用于任意的Composable：</p>

<pre><code class="Kotlin">@Composable
fun AnimatingBox(
    modifier: Modifier = Modifier.fillMaxSize()
) {
    var boxState by remember { mutableStateOf(BoxState.Expanded) }
    val transitionData = updateTransitionData(boxState)
    // UI tree
    Box(
        modifier = Modifier
            .background(transitionData.color)
            .size(transitionData.size)
            .clickable {
                boxState =
                    if (boxState == BoxState.Expanded) BoxState.Collapsed else BoxState.Expanded
            }
    )
}

@Composable
fun AnimatingColumn(
    modifier: Modifier = Modifier.fillMaxSize()
) {
    var boxState by remember { mutableStateOf(BoxState.Collapsed) }

    LaunchedEffect(Unit) {
        boxState = BoxState.Expanded
    }

    val transitionData = updateTransitionData(boxState)
    Column(
        modifier = Modifier
            .background(transitionData.color)
            .size(transitionData.size)
    ) {
        Text("Apply to a column")
    }
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/animation/anim_transition.gif" alt="transition_demo" /></p>

<p>可以看一看<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#AnimatedVisibility(kotlin.Boolean,androidx.compose.ui.Modifier,androidx.compose.animation.EnterTransition,androidx.compose.animation.ExitTransition,kotlin.Function1">AnimatedVisibility</a>)以及<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#Crossfade(kotlin.Any,androidx.compose.ui.Modifier,androidx.compose.animation.core.FiniteAnimationSpec,kotlin.String,kotlin.Function1">Crossfade</a>)和<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#AnimatedContent(kotlin.Any,androidx.compose.ui.Modifier,kotlin.Function1,androidx.compose.ui.Alignment,kotlin.Function2">AnimatedContent</a>)的实现，它们都是基于Transition实现的。</p>

<h2>动画的底层API</h2>

<p>到现在我们已经学习了很多创建动画的方式，从封装的层次来说，最上层是所见即所得动画函数如AnimatedVisibility，Crossfade和AnimatedContent，它们是基于<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Transition">Transition</a>实现的；属性动画函数animate&#42;AsState是基于Animatable实现的。这些函数都是Composables，也就是必须在Composition环境中才能使用。而Animatable和Transition都是基于最底层的Animation实现的，Animatable和Animation类似于View系统中的<a href="https://developer.android.com/reference/android/animation/Animator">Animator</a>，管理着某种值随时间在两个状态之间变化。它们两个只与值和时间有关，与Composition无关，因此可以在任意上下文中使用。可以用官方提供的一张图，来搞清楚API之间的关系：</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/animation-low-level.svg" alt="anim_api_level" /></p>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Animation">Animation</a>是最为底层的API，它只管理着值随时间的变化，其余的事情像动画是否已开始，是否已结束都需要调用者自己管理。它使用起来相当的麻烦，除非有必要否则一般不建议直接使用这个对象，本文也不再讨论它。</p>

<p>可以重点研究一下<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Animatable">Animatable</a>，它是基于Animation的，但是封装的较为完整。它是基于协程的单个数值变化动画，它能保证数值的变化是连续的，不过它的主要方法如<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Animatable#animateTo(kotlin.Any,androidx.compose.animation.core.AnimationSpec,kotlin.Any,kotlin.Function1">animateTo</a>)都是suspend的，意味着要在协程上下文中调用，比如启动动画就要用Animatable：</p>

<pre><code class="Kotlin">val color = remember { Animatable(Color.Gray) }
LaunchedEffect(ok) {
    color.animateTo(if (ok) Color.Green else Color.Red)
}
Box(Modifier.fillMaxSize().background(color.value))
</code></pre>

<p>使用Animatable可以创建出很多富有创意的复杂动画，比如说多米诺式的顺次动画，以及并发动画。</p>

<h3>多个部件顺次动画</h3>

<p>多个部件的顺次动画也就是依次发生的动画，比如A，B，和C三个动画作用于不同的UI部件，A先启动，结束后B接着启动，结束后C再启动。比较常规的方式是使用动画回调，在前一个的结束回调中启动下一个，或者使用延时启动，B的启动延时设置为A的动画时长。</p>

<p>借助于Animatable，可以有更为优雅的方案，在同一个协程中依次调用不同的Animatable的animateTo函数就可以，让几个不同的Animatable依次启动了：</p>

<pre><code class="Kotlin">val alphaAnimation = remember { Animatable(0f) }
val yAnimation = remember { Animatable(0f) }

LaunchedEffect("animationKey") {
    alphaAnimation.animateTo(1f)
    yAnimation.animateTo(100f)
    yAnimation.animateTo(500f, animationSpec = tween(100))
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/animations/multiple_properties_sequential.gif" alt="anim_sequential_flow" />
注意，这个动图展示的是顺次动画的流程图，而非一个案例的效果。</p>

<h3>多个部件并发动画</h3>

<p>类似的还有并发动画，就是作用于多个不同的部件的动画同时启动，这个其实相较于顺次动画要容易一些，因为我们用Transition组合多个属性动画实际上就是并发动画。</p>

<p>除了Transition以外，用多个Animatable也可以，我们只需要启动多个协程去执行animateTo即可：</p>

<pre><code class="Kotlin">val alphaAnimation = remember { Animatable(0f) }
val yAnimation = remember { Animatable(0f) }

LaunchedEffect("animationKey") {
    launch {
        alphaAnimation.animateTo(1f)
    }
    launch {
        yAnimation.animateTo(100f)
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/animations/multiple_properties.gif" alt="anim_concurrent_flow" />
注意，这个是并发动画的流程图，而非动画效果。</p>

<h2>集合性布局中的元素项动画</h2>

<p>对于集合性布局来说，当其元素项发生变化时，会触发相应的动画效果，这就是<a href="https://developer.android.com/develop/ui/compose/lists#item-animations">item animations</a>。我们只需要1）为每个子元素项定义一个集合中唯一标识的key；2）然后再调用扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/lazy/LazyItemScope#(androidx.compose.ui.Modifier">Modifier.aniamteItem</a>.animateItem(androidx.compose.animation.core.FiniteAnimationSpec,androidx.compose.animation.core.FiniteAnimationSpec,androidx.compose.animation.core.FiniteAnimationSpec))；即可以在元素项变化时触发动画，它会子元素项出现，消失和发生替换时触发动画效果。</p>

<h2>动画最佳实践</h2>

<p>我们学习了这么多创建动画的方式，在实际项目中要遵守几个原则：1）尽可能优先使用Compose封装好的动画函数，不要重复造轮子；2）第二个就是要为每个动画设置一个label，所有的动画API都会有一个label参数，要尽可能为每个动画设置一个唯一的label，这个是用于Android Studio调试动画时的唯一标识。</p>

<p>再有就是动画会触发Recomposition，re-layout和re-draw，为了尽可能的避免减少re-layout和re-draw，要尽可能的使用已封装好的函数来修改属性，比如使用Modifier的扩展函数（如<a href="https://developer.android.com/develop/ui/compose/graphics/draw/modifiers">Modifier.graphicsLayer {}</a>），而不是直接去改size或者padding。</p>

<h2>References</h2>

<ul>
<li><a href="https://proandroiddev.com/animating-inside-and-outside-the-box-with-jetpack-compose-a56eba1b6af6">Animating Inside and Outside the Box with Jetpack Compose</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/value-based">Value-based animations</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/vectors">Animated vector images in Compose</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/advanced">Advanced animation example: Gestures</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『震惊百里』| Animations]]></title>
    <link href="http://toughcoder.net/blog/2024/07/24/compose-animation-basics/"/>
    <updated>2024-07-24T07:59:35+08:00</updated>
    <id>http://toughcoder.net/blog/2024/07/24/compose-animation-basics</id>
    <content type="html"><![CDATA[<p>动画对于UI来说无疑是最重要的核心功能，它能够让UI变得生动有吸引力。适当的使用动画可以提升UI的流畅性，让UI体验更为顺滑。在Jetpack Compose中有丰富的函数可以用来实现动画，今天就从一些最为常用的学起，闲话就说这么多，赶紧开工。</p>

<p><a href=""><img src="https://koenig-media.raywenderlich.com/uploads/2020/09/JetpackComposeAnimations-twitter.png" title="auto auto" ></a></p>

<!-- more -->


<h2>所见即所得的动画函数</h2>

<p>最为方便和快速上手的就是使用封装的最好的动画函数（Animation Composables）。</p>

<h3>给Composable出现和隐藏加上动画</h3>

<p>UI元素的出现和隐藏是动画最为常用的场景，让视觉体验平滑过度，不那么的突兀。使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#AnimatedVisibility(androidx.compose.animation.core.MutableTransitionState,androidx.compose.ui.Modifier,androidx.compose.animation.EnterTransition,androidx.compose.animation.ExitTransition,kotlin.String,kotlin.Function1">函数AnimatedVisibility</a>)就可以方便的给单个部件的出现和隐藏加上动画：</p>

<pre><code class="Kotlin">        var visible by remember {
            mutableStateOf(true)
        }

        AnimatedVisibility(visible) {
            Box(
                modifier = Modifier
                    .size(200.dp)
                    .clip(RoundedCornerShape(8.dp))
                    .background(colorGreen)
            )        
        }

        Button(modifier = Modifier.align(Alignment.BottomCenter), onClick = {
            visible = !visible
        }) {
            Text("Toggle Show/Hide")
        }
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/animations/animated_visibility_column.gif" alt="anim_visibility" /></p>

<p><strong>注意：</strong>AnimatedVisibility做完淡出动画时，会把其子布局从渲染树中移除。</p>

<p>AnimatedVisibility默认会使用淡入（fadeIn）/淡出（fadeOut）+缩放（shrinking）作为内容的出现/隐藏动画，如果要指定不同的动画，可以通过参数enter和参数exit来指定。<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/EnterTransition">EnterTransition</a>和<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/ExitTransition">ExitTransition</a>有很多<a href="https://developer.android.com/develop/ui/compose/animation/composables-modifiers#enter-exit-transition">预定义的动画</a>可以使用，并且可以通过+进行组合：</p>

<pre><code class="Kotlin">var visible by remember { mutableStateOf(true) }
val density = LocalDensity.current
AnimatedVisibility(
    visible = visible,
    enter = slideInVertically {
        // Slide in from 40 dp from the top.
        with(density) { -40.dp.roundToPx() }
    } + expandVertically(
        // Expand from the top.
        expandFrom = Alignment.Top
    ) + fadeIn(
        // Fade in with the initial alpha of 0.3f.
        initialAlpha = 0.3f
    ),
    exit = slideOutVertically() + shrinkVertically() + fadeOut()
) {
    Text("降Compose十八掌", Modifier.fillMaxWidth().height(200.dp))
}
</code></pre>

<p>仔细看AnimatedVisibility的实现，不难发现，它其实相当于是一个Column，可以当成一个Column来使用，动画是加在此布局上面的。它还支持对其子布局设置单独的动画。可以使用这个扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/AnimatedVisibilityScope#(androidx.compose.ui.Modifier">animateEnterExit</a>.animateEnterExit(androidx.compose.animation.EnterTransition,androidx.compose.animation.ExitTransition,kotlin.String))来对子布局的出现/隐藏加上特定的动画：</p>

<pre><code class="Kotlin">@Composable
fun CustomForChildren(modifier: Modifier = Modifier.fillMaxSize()) {
    Column(
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        var visible by remember { mutableStateOf(true) }

        AnimatedVisibility(
            visible = visible,
            enter = fadeIn(),
            exit = fadeOut()
        ) {
            // Fade in/out the background and the foreground.
            Box(
                Modifier
                    .fillMaxWidth()
                    .height(200.dp)
                    .background(Color.LightGray)) {
                Box(
                    Modifier
                        .align(Alignment.Center)
                        .animateEnterExit(
                            // Slide in/out the inner box.
                            enter = slideInHorizontally(),
                            exit = slideOutHorizontally()
                        )
                        .sizeIn(minWidth = 256.dp, minHeight = 64.dp)
                        .background(Color.Magenta)
                ) {
                    Text(
                        text = "你会看到不同的风景！",
                        style = MaterialTheme.typography.headlineLarge,
                        modifier = Modifier
                            .padding(16.dp)
                            .align(Alignment.Center)
                    )
                }
            }
        }

        Button(
            onClick = { visible = !visible },
            modifier = Modifier.padding(16.dp)
        ) {
            Text("点击有惊喜！！！")
        }
    }
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/animation/custom_for_children.gif" alt="children_enter_exit" /></p>

<h3>两个布局之间淡入淡出</h3>

<p>AnimatedVisibility只能用于单个部件或者单个布局的出现隐藏。但有时会涉及两个部件之间的切换，虽然也是一个出现，前一个隐藏，但它们是有联动的，这时就需要使用专门的切换动画函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#(androidx.compose.animation.core.Transition">Crossfade</a>.Crossfade(androidx.compose.ui.Modifier,androidx.compose.animation.core.FiniteAnimationSpec,kotlin.Function1,kotlin.Function1))，最为典型的场景就是加载内容，先是显示加载进度，有数据可显示时就把进度隐藏，让内容显示：</p>

<pre><code class="Kotlin">@Composable
fun CrossfadeDemo(modifier: Modifier = Modifier.fillMaxSize()) {
    var done by remember { mutableStateOf(false) }

    LaunchedEffect(Unit) {
        delay(5000)
        done = true
    }

    Crossfade(
        modifier = modifier,
        targetState = !done,
        label = "crossfade"
    ) { loading -&gt;
        Box(
            modifier = Modifier.fillMaxSize(),
            contentAlignment = if (loading) Alignment.Center else Alignment.TopStart
        ) {
            if (loading) {
                Column(horizontalAlignment = Alignment.CenterHorizontally) {
                    CircularProgressIndicator(Modifier.size(66.dp))
                    Text(
                        text = "玩命加载中...",
                        modifier = Modifier.padding(16.dp),
                        style = MaterialTheme.typography.headlineMedium
                    )
                }
            } else {
                Text(
                    text =
                    """
                       “降龙十八掌可说是【武学中的巅峰绝诣】，当真是无坚不摧、无固不破。虽招数有限，但每一招均具绝大威力。
                        北宋年间，丐帮帮主萧峰以此邀斗天下英雄，极少有人能挡得他三招两式，气盖当世，群豪束手。
                        当时共有“降龙廿八掌”，后经萧峰及他义弟虚竹子删繁就简，取精用宏，改为降龙十八掌，掌力更厚。
                        这掌法传到洪七公手上，在华山绝顶与王重阳、黄药师等人论剑时施展出来，王重阳等尽皆称道。”
                    """.trimIndent(),
                    modifier = Modifier.padding(16.dp),
                    style = MaterialTheme.typography.headlineMedium
                )
            }
        }
    }
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/animation/crossfade.gif" alt="crossfade" /></p>

<h3>通用的布局切换动画</h3>

<p>如果变幻不止有淡入淡出，或者说布局不只有两个，这时就要用更为通用也更为强大的切换动画函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#AnimatedContent(kotlin.Any,androidx.compose.ui.Modifier,kotlin.Function1,androidx.compose.ui.Alignment,kotlin.Function2">AnimatedContent</a>)，它可以用来定制多个布局之间两两切换的动画：</p>

<pre><code class="Kotlin">var state by remember {
    mutableStateOf(UiState.Loading)
}
AnimatedContent(
    state,
    transitionSpec = {
        fadeIn(
            animationSpec = tween(3000)
        ) togetherWith fadeOut(animationSpec = tween(3000))
    },
    modifier = Modifier.clickable(
        interactionSource = remember { MutableInteractionSource() },
        indication = null
    ) {
        state = when (state) {
            UiState.Loading -&gt; UiState.Loaded
            UiState.Loaded -&gt; UiState.Error
            UiState.Error -&gt; UiState.Loading
        }
    },
    label = "Animated Content"
) { targetState -&gt;
    when (targetState) {
        UiState.Loading -&gt; {
            LoadingScreen()
        }
        UiState.Loaded -&gt; {
            LoadedScreen()
        }
        UiState.Error -&gt; {
            ErrorScreen()
        }
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/animations/animated_content_slower.gif" alt="animated_content" /></p>

<h2>尺寸改变动画</h2>

<p>UI元素的尺寸变化也是非常常用的一类动画，通常作为出场和入场比较合适。对于尺寸的改变可以通过<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#(androidx.compose.ui.Modifier">Modifier.animateContentSize</a>.animateContentSize(androidx.compose.animation.core.FiniteAnimationSpec,kotlin.Function2))来实现。它会自己感知尺寸的变化，然后触发动画。可以设置一个参数finishedListener以接收动画做完了的通知。需要特别注意的是，<strong>调用的顺序很重要，animateContentSize必须在任何的尺寸设置之前</strong>，还要注意的是尺寸必须根据不同的条件有所变化，要不然动画没机会展示：</p>

<pre><code class="Kotlin">var expanded by remember { mutableStateOf(false) }
Box(
    modifier = Modifier
        .background(colorBlue)
        .animateContentSize()
        .height(if (expanded) 400.dp else 200.dp)
        .fillMaxWidth()
        .clickable(
            interactionSource = remember { MutableInteractionSource() },
            indication = null
        ) {
            expanded = !expanded
        }

)
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/animations/animated_content_size.gif" alt="" /></p>

<h2>属性状态驱动动画</h2>

<p>一般来说，动画的本质是让参数随时间变化，然后再让UI元素响应这些参数的变化，通过重新渲染，或者做渲染图层的变幻。在Compose中参数变化想影响部件的渲染，就必须把其封装成状态（State），这样参数变化就能被Compose感知到并做Recomposition。然后我们把状态的变化再通过属性设置给Composables，让其做渲染或者变幻，就形成了动画效果。这就是属性动画。</p>

<p>Compose定义了很多方法可以把参数转变成为状态，不同的参数可以通过不同的函数作用于不同的属性：</p>

<h3><a href="https://developer.android.com/develop/ui/compose/animation/value-based#animate-as-state">animateFloatAsState</a></h3>

<p>可以把值的类型为浮点数的属性变为状态驱动动画，比如透明度（alpha），尺寸（size），间隔（padding/offset），字体大小（textSize）以及像旋转/缩放/位移等等。只要是浮点类型就可以用这个来转成状态，然后再通过相应的属性设置给Composable即可。</p>

<p>最为常用的就是结合graphicsLayer图层做变幻：</p>

<pre><code class="Kotlin">@Composable
fun PropertyAnimation(modifier: Modifier = Modifier.fillMaxSize()) {
    var showing by remember { mutableStateOf(false) }

    val scale by animateFloatAsState(
        targetValue = if (showing) 0f else 1f,
        label = "property"
    )
    val alpha by animateFloatAsState(
        targetValue = if (showing) 0f else 1f,
        label = "property"
    )
    Column(
        modifier = Modifier.padding(20.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
    ) {
        Text(
            text = "降Compose十八掌",
            modifier = Modifier
                .padding(20.dp)
                .graphicsLayer {
                    this.alpha = alpha
                    scaleX = scale
                    scaleY = scale
                },
            style = MaterialTheme.typography.headlineLarge
        )
        Spacer(Modifier.height(50.dp))
        Button(onClick = { showing = !showing}) {
            Text("再点一下试试！（试试就试试！）")
        }
    }
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/animation/property.gif" alt="property_state" /></p>

<p>至于其他的像尺寸和间隔，虽然也可以，但因为像padding和offset会直接用dp或者Offset作为值，有更为舒适的API可以直接用（尽管浮点值也可以转换成为dp或者Offset）。</p>

<h3>animateColorAsState</h3>

<p>专门用于颜色值变化，指定两个值后，会在它们中间进行的插值作为动画的帧，能让颜色变化更为平滑和细腻。</p>

<h3>animateIntOffsetAsState</h3>

<p>用于把值Offset的变化变成动画，适合于使用Offset的地方，如Modifier.offset，Modifier.layout等。</p>

<h3>animateDpAsState</h3>

<p>把类型为Dp的值变为动画，适合所有能使用Dp作为参数值的地方，如padding，shadowElavation等。</p>

<p>小结：可以发现由属性状态驱动的动画使用起来比较麻烦，先是要把参数转化为状态，要管理好不同状态下参数的值，还要使用正确的函数把状态作用于Composable的属性。复杂的同时意味着强大，它能实现一些更为复杂的动画。推荐优先使用动画函数，如果无法满足再考虑用属性状态动画。</p>

<h2>页面切换转场动画</h2>

<p>页面是应用中较为完整的一屏UI，比如说新闻应用，列表页是一个页面，点开进入单篇新闻又是一个页面，用户中心是一个页面，设置又是一个页面。不同的页面之间的跳转称之为导航，用的是Jetpack中的库navigation，在Compose中通过navigation-compose做了桥接，所以在Compose中可以直接使用navigation，可以通过创建NavHost时通过参数enterTransition和exitTransition来为页面设置转场动画。可以为每个页面设置单独的转场，也可以设置一个统一的默认的转场动画：</p>

<pre><code class="Kotlin">val navController = rememberNavController()
NavHost(
    navController = navController, startDestination = "landing",
    enterTransition = { EnterTransition.None },
    exitTransition = { ExitTransition.None }
) {
    composable("landing") {
        ScreenLanding(
            // ...
        )
    }
    composable(
        "detail/{photoUrl}",
        arguments = listOf(navArgument("photoUrl") { type = NavType.StringType }),
        enterTransition = {
            fadeIn(
                animationSpec = tween(
                    300, easing = LinearEasing
                )
            ) + slideIntoContainer(
                animationSpec = tween(300, easing = EaseIn),
                towards = AnimatedContentTransitionScope.SlideDirection.Start
            )
        },
        exitTransition = {
            fadeOut(
                animationSpec = tween(
                    300, easing = LinearEasing
                )
            ) + slideOutOfContainer(
                animationSpec = tween(300, easing = EaseOut),
                towards = AnimatedContentTransitionScope.SlideDirection.End
            )
        }
    ) { backStackEntry -&gt;
        ScreenDetails(
            // ...
        )
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/animations/navigation_compose_animation.gif" alt="navigation_transition" /></p>

<h2>组合首次运行时动画</h2>

<p>对于像AnimatedVisibility以及使用animate&42;AsState属性状态动画来说，可以发现它们都是在组合发生之后才能生效，这是因为状态是为了重组而设置的，状态只会在组合之后部件渲染完了，响应事件由事件触发状态变化。组合首次运行的时候，状态仅是初始值，但不会变化，也就不会触发动画。</p>

<p>所以需要一个能在首次组合时就能运行的事件来触发动画依赖的状态，<a href="https://developer.android.com/develop/ui/compose/side-effects#launchedeffect">LaunchedEffect</a>正合适。LaunchedEffect会在首次组合时运行，可以在里面执行一些「副作用」也就是Compose组合之外的行为。可以在这里触发动画的状态，就能够让动画在首次组合时生效了。这一般用作部件的出场动画：</p>

<pre><code class="Kotlin">@Composable
fun LaunchAnimation(modifier: Modifier = Modifier.fillMaxSize()) {
    val alphaAnimation = remember {
        Animatable(0f)
    }
    LaunchedEffect(Unit) {
        alphaAnimation.animateTo(
            targetValue = 1f,
            animationSpec = tween(durationMillis = 30000)
        )
    }
    Box(
        modifier = Modifier
            .offset(16.dp, 16.dp)
            .size(200.dp)
            .graphicsLayer {
                alpha = alphaAnimation.value
            }
            .background(Color.Magenta)
    )
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/animation/launch_anim.gif" alt="launch_anim" />
<strong>需要注意</strong>，LaunchedEffect的参数用作标识，参数有变化时，会再次运行，因此对于出场动画，LaunchedEffect的参数要设置为不可变的常量，如Unit。还需要注意的是，LaunchedEffect会在首次组合时运行，对于像集合性布局，会重复的使用子布局来展示元素项，所以每次元素项进入屏幕可视范围时，LaunchedEffect都会运行，动画都会触发，这并不是想要的结果，因为我们只想列表首次加载时触发动画。一个解决办法就是把状态和LaunchedEffect提高到列表的上一级Composable中。</p>

<h2>调整动画参数进行定制</h2>

<p>动画除了具体的形式以外，还有一些共性的参数可以设置，像时长，速度和是否重复，有过View动画经验的同学对此一定不会陌生。可以通过<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/AnimationSpec">AnimationSpec</a>对象来对动画参数进行定制，所有的动画API都能接受一个animationSpec参数。Compose提供了很多AnimationSpec的构造函数可以直接使用：</p>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/animation/customize#spring">spring</a> 刚性动画（或者叫做弹性动画）是模拟物理中刚性物体运动和碰撞的动画，与生活中的体验类似，所以这是默认的动画参数。可以通过调整硬度（stiffness）和阻尼系数（dampingRatio）来改变动画效果。</li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/customize#tween">tween</a> 补间动画，有一定时长，在两个值之间通过Easing函数插值形成的动画。</li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/customize#keyframes">keyframes</a> 关键帧动画，指定一定的关键节点作为动画中的帧。</li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/customize#repeatable">repeatable</a> 可重复一定次数的动画，通过RepeatMode指定重复方式（简单重复，或者反向播放）。</li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/customize#infiniterepeatable">infiniteRepeatable</a> 无限重复动画，通过RepeatMode指定重复方式。</li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/customize#snap">snap</a> 猛跳到目标值，无动画。</li>
</ul>


<p>根据不同的动画参数，可以进一步的做更细致的参数调整，比如像时长和速度。</p>

<h3>修改动画的时长和延时</h3>

<p>动画肯定都有时长，即使无限重复的动画，其每一次也是有时长的。大部分AnimationSpec函数都能接受一个durationMillis参数来调整动画的时长。</p>

<p>动画被触发后，也不一定立马播放，参数本身有一个延时可以控制，大部分都能接受一个delayMilis参数来控制播放的延时。</p>

<p>注意，刚性动画（spring）比较特殊，它不能直接控制时长和延时，刚性动画是通过硬度和阻尼来调整，时长是根据它们计算出来的，而物理世界的刚硬碰撞哪有延时？</p>

<h3>修改动画的播放速度</h3>

<p>对于补间动画和关键帧动画，还可以通过Easing函数来改变动画的播放速度，比如匀速，先快后慢，先慢后快，匀速等等。Easing函数与View动画中的<a href="https://developer.android.com/reference/android/graphics/Interpolator">Interpolator</a>是同样的东西。它是一个简单的数学函数，一个浮点数输入代表当前的时间点，一个浮点数输出代表动画应该到达的位置，取值都是0到1之间。可以理解为物理题，输入参数是时间t，输出则是位移s。</p>

<p>有很多定义好的<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/package-summary#Ease(">Easing函数</a>)可以使用，当然也可以自定义：</p>

<pre><code class="Kotlin">val CustomEasing = Easing { fraction -&gt; fraction * fraction }

@Composable
fun EasingUsage() {
    val value by animateFloatAsState(
        targetValue = 1f,
        animationSpec = tween(
            durationMillis = 300,
            easing = CustomEasing
        )
    )
    // ……
}
</code></pre>

<h2>未完待续</h2>

<p>动画是UI中比较复杂的话题，在Compose中更是如此，动画的本质是把参数转成状态随时间变化，状态再去驱动部件做渲染或者做变幻。本文总结了最常用的和封装层次较为高级的创建动画的方法，足以应付较为常见的动画需求场景。但涉及动画的内容还有很多，比如像与手势交互相关的动画，多个不同的部件联动的动画，以及像动画的性能调优等一些较复杂的话题，将在后续的文章中讲解。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/animation/quick-guide">Quick guide to Animations in Compose</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/composables-modifiers">Animation modifiers and composables</a></li>
<li><a href="https://medium.com/@silaelijah/animations-in-jetpack-compose-60d90a322ca3">Animations In Jetpack Compose</a></li>
<li><a href="https://medium.com/@android-world/jetpack-compose-animation-for-beginners-a-step-by-step-guide-58f1215b7c2c">Jetpack Compose Animation for Beginners: A Step-by-Step Guide</a></li>
<li><a href="https://www.jetpackcompose.net/jetpack-compose-animations">Jetpack Compose Animations</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/customize">Customize animations</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
