<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2024-11-24T08:49:59+08:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Compose大前端从上车到起飞]]></title>
    <link href="https://alexhilton.github.io/blog/2024/11/24/master-compose-multiplatform/"/>
    <updated>2024-11-24T08:45:46+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/11/24/master-compose-multiplatform</id>
    <content type="html"><![CDATA[<p>在前面的一篇文章<a href="https://juejin.cn/post/7436648335380496434">赶紧上车开启Compose大前端之路</a>中我们学习了CMP的基本概念以及如何创建一个CMP项目。今天将继续学习CMP，深入研究项目的配置方法，了解CMP的内部机制并总结一些CMP开发的最佳实践。</p>

<p><a href=""><img src="https://repository-images.githubusercontent.com/293498508/6469be07-159b-49de-9ffe-56340d5dfd07" title="auto auto" ></a></p>

<!-- more -->


<h2>深入了解项目结构</h2>

<p>CMP的基础结构与一个标准的Android应用的项目结构基本一样，只不过主module名字变成了「composeApp」。项目根目录下的build.gradle.kts是整个项目的配置，主要是指定使用的插件；settings.gradle.kts指定项目的依赖仓库，以及项目包含哪些module；gradle/wrapper/libs.version.toml定义着依赖的版本信息。模块「composeApp」包含着源码集合（source sets）以及一个build.gradle.kts，这是描述这个模块如何构建的脚本。</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/project-view.png" alt="图1. 项目结构" /></p>

<p>对于Android开发同学来说，这样的项目结构非常熟悉，事实上如果把项目视图切换到「Android」，就会发现，这比起常规的Android项目，无非就是多了一些源码集合。</p>

<p>仔细看一下源码集合「androidMain」它就是一个标准的Android项目，里面有AndroidManifest文件，以及一个入口MainActivity，它会调用「commonMain」中定义的composable App()，由此就进入到了「commonMain」中。</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/android-entry.png" alt="图2. Android源码关系" /></p>

<p>虽然并不在源码集合中，iosApp子目录其实是一个标准的Xcode项目，里面全是Xcode项目的配置文件，可以用Xcode直接打开。它是iOS应用的入口，它的调用顺序是iOSApp，到ContentView，这两个是标准的iOS的代码，用的是Swift。然后会进入到「iosMain」中的MainConntroller，这里就到了Kotlin地界了，MainController，再进入到common中的composable App()，由此进入了「commonMain」中。</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/ios-entry.png" alt="图3. iOS源码关系" /></p>

<h2>依赖配置方法</h2>

<p>现代的软件不可能全都是从零开始，有很多现成的代码库可以使用，这就需要为项目配置依赖。CMP中依赖配置方法与常规的Android略不一样，视依赖的使用，以及依赖的平台依赖性，需要分别针对不同的源码集合配置。</p>

<p>需要注意的就是依赖的作用域，如果是在commonMain中配置的，那就会对所有的平台生效；如果是为androidMain配置的依赖，只能在Android中生效，以次类推。</p>

<h3>在源码集合中配置依赖</h3>

<p>最直接的方式就是针对每个源码集合配置其依赖：</p>

<pre><code class="Kotlin">kotlin {
    sourceSets {
        commonMain.dependencies {
            implementation("com.example:my-library:1.0") // 所有平台共享的依赖
        }
    }
}
</code></pre>

<h3>在顶层DSL dependencies中配置</h3>

<p>除了在源码集合处配置依赖，也可以在顶层DSL dependencies中配置，本质都是一样的，只不过是方式略有不同。具体的格式是<strong> &lt;源码集合&gt;&lt;具体的依赖&gt; </strong>，比如上面酱紫写：</p>

<pre><code class="Kotlin">dependencies {
    "commonMainImplementation"("com.example:my-library:1.0")
}
</code></pre>

<p>这与像上面在源码集合commonMain中配置是一样的。在顶层配置依赖的好处在于这里可以配置一些源码集合中找不到的依赖，如testing等等。</p>

<h3>本地module如何相互依赖</h3>

<p>如果是本地的库（module），可以通过project方式引入，同样的如果是共享的库加在common里，如果是某个平台特有的，或者只想在某个平台使用就单独加到它上面：</p>

<pre><code class="Kotlin">kotlin {
    sourceSets {
        commonMain.dependencies {
            implementation(project(":some-other-multiplatform-module"))
        }
    }
}
</code></pre>

<h2>如何共享和定制代码</h2>

<p>CMP的终极目的是要尽可能的共享代码，让一套代码能够跑在多个平台上面。但现实的世界是不完美的，平台的差异是不可忽视的。像存储，I/O，硬件资源等等都是平台强相关的。我们只能尽可能多的共享我们自己写的业务逻辑，对于实现业务逻辑而需要的系统平台相关的API，肯定还是需要每个平台定制化的去实现。</p>

<p>CMP通过Kotlin中的关键字expect和actual来处理平台定制API。</p>

<p>具体的做法就是在common中定义一个用关键字expect修饰的类型（函数，类，接口枚举，属性等），然后在每个平台的源码集合中去具体实现，并用关键字actual来修饰。注意，这里的类型没有限制，可以是函数，可以是类/接口/枚举，也可以是属性，尽管绝大多数情况下都是函数。</p>

<p><img src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/expect-functions-properties.svg" alt="图4. 用expect和actual来定制API" /></p>

<p>可以理解为OO中的接口，但又不完全一样。区别在于，common中的expect函数不能有默认实现代码，并且函数的声明要在同一个包下面。编译的时候，编译器会用平台代码里面的actual去替换common中的expect函数。也就是说这是发生在编译时的行为，所以它要求包名和函数的签名完全一致。</p>

<h2>资源管理</h2>

<p>CMP是能构建跨平台UI的，而UI必然会涉及资源，最常见的资源就是图片和字符串，资源的复杂地方在于它会有限定属性，比如不同屏幕分辨率要用不同的图片，比如不同的地区语言要用不同的字符串，所以资源是相当复杂的，而且平台强相关。</p>

<p>为此CMP提供了一个专门的库用于管理资源，可以屏蔽平台特定，以统一的方式来管理资源。只需要在commonMain中引入依赖即可：</p>

<pre><code class="Kotlin">kotlin {
    sourceSets {
        commonMain.dependencies {
            implementation(compose.components.resources)
        }
    }
}
</code></pre>

<p>资源是放在commonMain中与kotlin同级别的目录中：</p>

<p><img src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/compose-resources-qualifiers.png" alt="图5. 资源文件管理" /></p>

<p>资源可以分为几种类型，图片应该放在子目录drawable中，字体资源放在fonts中，字符串放在values中，其他文件放在files中。</p>

<p>资源文件还可以有限定符以支持定制化，如屏幕分辨率（xhdpi，xxhdpi等），区域语言（en，zh-rCN等）和主题（dark，light等）。可以发现，规则与Android平台资源管理规则是非常接近的。</p>

<p>图片字体等直接添加文件即可，字符串的话放在一个xml文件中，根Tag是resources，每个字符串的Tag是string，如：</p>

<pre><code class="Kotlin">&lt;resources&gt;
    &lt;string name="app_name"&gt;My awesome app&lt;/string&gt;
    &lt;string name="title"&gt;Some title&lt;/string&gt;
&lt;/resources&gt;
</code></pre>

<p>需要注意资源的命名，与Android的资源规则一样，要是小写字符，可以有数字和下划线。</p>

<p>添加好资源后，编译插件会自动生成一个类Res，通过它就可以引用各种资源，如：</p>

<pre><code class="Kotlin">Image(
    painter = painterResource(Res.drawable.my_icon),
    contentDescription = null
)

Text(stringResource(Res.string.app_name))
</code></pre>

<h2>一些开发实践建议</h2>

<p>CMP是为了构建跨平台应用的，那么应该尽最大的可能去共享代码。虽然有平台定制机制，但只应该用它来定制细粒度的具体的API，而不是业务逻辑。比如说，从一个文件中读文本内容，不应该定义一个getFileContent，而是应该定制细粒度的openFile，closeFile和readLine，这是因为读取文件过程真正不同的是处理文件的API，除打开文件，读出每一行以外，其他的逻辑是一样的，应该共享。</p>

<p>还有，在写业务的时候要注意看Compose文档中以及Kotlin文档中API标注的平台范围，尽可能选择标记为「Common」或者「Cmn」的API。</p>

<p>另外，因为Kotlin是基于JVM的语言，标准JDK中的API都可以用，但在CMP的iOS（目标是Native）平台和Web（目标是Wasm）却无法使用JDK的API，所以我们应该多使用Kotlin标准库以及Kotlin扩展库（kotlinx），这些API都做了多平台适配。</p>

<h2>总结</h2>

<p>利益于Gradle中的源码集合，CMP对源码的结构是很宽容的，并没有严格的要求，这对于现有项目来说是相当友好的，因为把现有的项目源码搬进来就可以了，不用改太多，然后通过源码集合来做具体的指定和逻辑上的关系处理。每个源码集合其实都是其平台的一个标准项目，把common作为其依赖而已，关系就这么简单，甚至还可以用其平台的原生方式去写UI，写逻辑，这都是可以的。</p>

<p>虽然这样做貌似会失去共享代码和逻辑的意义，但是这对改造现有项目是十分友好的，比如第一步可能是把Android项目和iOS项目先融合进来，然后再慢慢的把两个平台的共享代码抽离出来入进common。这样做不但能慢慢推进跨端，每个项目各自仍是完整的，如果有紧急 的事情仍可先用原生方式去开发构建。</p>

<h2>References</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/multiplatform-add-dependencies.html">Adding dependencies on multiplatform libraries</a></li>
<li><a href="https://kotlinlang.org/docs/gradle-configure-project.html#configure-dependencies">Configure dependencies</a></li>
<li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-connect-to-apis.html">Use platform-specific APIs</a></li>
<li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-multiplatform-resources.html">Resources overview</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[赶紧上车开启Compose大前端之路]]></title>
    <link href="https://alexhilton.github.io/blog/2024/11/17/compose-multiplatform-made-easy/"/>
    <updated>2024-11-17T20:33:51+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/11/17/compose-multiplatform-made-easy</id>
    <content type="html"><![CDATA[<p>在<a href="https://juejin.cn/column/7367555191338467337">前面的文章中</a>，我们一再强调Jetpack Compose是一个声明式的UI框架，尽管我们都是基于Android开发来实战的，但Compose并不局限于Android开发，它其实与特定的开发平台没有关系，是可以做到跨平台开发的。事实上JetBrains早就已经准备好了一套工具，以让Compose跨平台，开发多端应用，跻身于大前端的一员。今天就来学习一下如何使用Compose进行大前端开发。</p>

<p><a href=""><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/j9tap6mygsqvxh6aauc8.png" title="auto auto" ></a></p>

<!-- more -->


<h2>缘起</h2>

<p>时光荏苒，白云苍狗，自乔帮主发布iPhone开启移动互网联至今已有十余载。对于互联网应用来说，早已从最初的Android加iOS两端并行，发展到现在的大前端时代。时至今日，不论大厂小厂，多端拉齐（Web，Android, iOS, Desktop，鸿蒙）已经是一个标配和强需求。那么如何减少多端的重复开发，如何跨多端开发就成了一个永不过时的研究方向。从最初的Mobile H5，到Hybrid App，再到React Native，再到后来的Flutter，大前端已经得到了长足的发展。得益于Kotlin Multiplatform（KMP），Compose也有了跨端的能力，跻身于大前端工具之列。</p>

<p>在深入主题学习之前，我们先来理解一下重要的概念。</p>

<h2>概念理解</h2>

<p>为了避免混淆和加强理解，需要对一些概念进行澄清。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 概念 </th>
<th style="text-align:left;"> 缩写 </th>
<th style="text-align:left;"> 说明 </th>
<th style="text-align:left;"> 开发者 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> Jetpack Compose </td>
<td style="text-align:left;"> Compose </td>
<td style="text-align:left;"> 基于Kotlin语言的声明式UI开发框架，与平台无关，源于以及主要用于Android开发 </td>
<td style="text-align:left;"> Google </td>
</tr>
<tr>
<td style="text-align:left;"> Compose Multiplatform </td>
<td style="text-align:left;"> CMP </td>
<td style="text-align:left;"> 用于把Compose转化为多端的一个框架 </td>
<td style="text-align:left;"> JetBrains </td>
</tr>
<tr>
<td style="text-align:left;"> Kotlin Multiplatform </td>
<td style="text-align:left;"> KMP </td>
<td style="text-align:left;"> 把Kotlin编译为多端的框架，这是Compose能跨平台的根基 </td>
<td style="text-align:left;"> JetBrains </td>
</tr>
</tbody>
</table>


<p>为了简便，在后文以及以后的文章中将使用缩写。虽然严格来说CMP专指把Compose转化为多端的UI框架，但大部分场合也用它来代指Compose跨端开发，后面也会这样用。</p>

<p><strong>注意：</strong> 在早些时候，也就是在JetBrains刚推出KMP的时候，仅针对和支持Android和iOS两个平台，所以当时就叫做Kotlin Multiplatform Mobile，缩写为KMM，后来也能编译出桌面（Desktop）和Web端了，就把Mobile去掉了，就是现在的KMP，代表Kotlin Multiplatform。所以，如果 在其他地方看到了KMM，把它当成KMP就可以了。</p>

<h2>Compose大前端技术栈</h2>

<p>在继续深入之前，捋捋技术栈，从大的角度来了解一下用到的技术工具的关系是很有必要的。</p>

<p>仍是用Jetpack Compose来写UI，用Kotlin来写业务逻辑，这是个是没有变的。而Compose Multiplatform（CMP）相当于是一个转换工具，能把Compose写的UI转变成为不同平台的UI实现。编程语言用的是都是Kotlin，最终要依赖KMM编译出具体平台的目标文件（Target）。所以，它们三个是依赖关系Compose依赖CMP，它们又都依赖KMM。</p>

<p>最先出现的当然是编程语言Kotlin，之后Google推出了声明式UI框架Jetpack Compose，采用了Kotlin语言。随着Kotlin的发展，JetBrains推出了KMP，让Kotlin实现跨多端，在这之后又基于Compose，推出了CMP，因为都是Kotlin语言，与KMP一起凑成了Compose/Kotlin的跨端。现在谷歌也与JetBrains紧密的合作，一起努力把Compose往前推进，去挑战React Native和Flutter。</p>

<p>学习成本并不高，因为对于开发者来说仍旧是Compose和Kotlin，CMP和KMP是透明的，它们以插件和依赖库的形式存在，没有额外的学习成本。当然，这对Android开发同学来说更为友好一些，因为大部分Android开发同学早已掌握了Compose和Kotlin。</p>

<h2>开发环境搭建</h2>

<p>CMP的技术栈并不复杂，如果已具备Android开发环境，那基本上就齐活儿了，这再次说明CMP对Android开发同学是相当友好的。开发用的IDE就是Android Studio，编译工具用的是Gradle，这对Android同学来说已经是标配了，不熟悉的同学可自行Google。</p>

<p>唯一需要安装的就是KMP的插件（plugin），也即Android Studio中，到插件市场搜索Kotlin Multiplatform，这是JetBrains官方提供的插件，找到后可放心安装，之后重启AS即可。</p>

<p>以上是通用开发配置，但如果目标平台是iOS就略麻烦一些。此小节后面的内容，仅当目标平台包含iOS时需要，否则可以跳过。</p>

<p><strong>注意：</strong> Mac虽然也是水果系统，但Mac属于桌面端（Desktop），如果为Mac构建应用要选择Desktop为目标平台。</p>

<p>因为水果的生态是封闭的，要想构建iOS就必须要用Xcode，而Xcode只在Mac上面才能用，所以要想构建iOS端应用，必须要用Mac来开发，而且要是新一点的Mac（三年以内）。然后安装最新的Xcode就差不多了，官方提供了一个Mac上为iOS环境的检查工具kdoctor（用brew install kdoctor来安装），但其实如果配置了Android开发环境后，再装上Xcode就够了。</p>

<p><strong>注意：</strong> 如果是比较旧的Mac，Big Sur以前的，就不用再折腾了，无法构建iOS，因为构建iOS需要Xcode 12.5，而<a href="https://developer.apple.com/support/xcode/">Xcode 12.5又至少需要macOS 11.7（即Big Sur）</a>。环境检查工具kdoctor本身也是要求Xcode 12.5以上，建议在安装之前可以先用brew info kdoctor来检查一下。水果就这点不好，硬件和软件更新都特别快，向后兼容又不友好，最多支持三个版本（时间跨度在3年左右）。</p>

<h2>创建一个多端应用</h2>

<p>环境配置好后，就可以开始创建CMP了，官方提供了一个<a href="https://kmp.jetbrains.com/?_gl=1*271nsz*_gcl_au*MTE5MzE4NTY0NS4xNzMxMzIzNDU3*_ga*MzUyNjc2MzcuMTU5NDM3NDQ0MA..*_ga_9J976DJZ68*MTczMTQwMDc1MC4xOC4wLjE3MzE0MDA3NTAuNjAuMC4w">KMP项目创建向导</a>可以方便的生成一个项目模板。需要注意的是就是，如果要构建iOS，一定要勾选『Share UI』。</p>

<p><strong>注意：</strong> 要想构建iOS目标需要较新的Mac才可以，如果开发环境不是Mac，或者Mac较旧，就不用钩选iOS了，因为选了也无法构建出来和运行目标产物。</p>

<p><img src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/multiplatform-web-wizard.png" alt="图1. CMP项目创建向导" /></p>

<p>在创建向导中配置好后，点击下载就可以了。解压之后，用Android Studio打开（File | Open）项目文件，就可以开始CMP的开发了。注意，要直接打开解压出来的根目录，而不是里面的某个子目录。因为AS打开的项目默认使用专为Android开发优化后的视图结构「Android」，为了更方便需要切换为「Project」。</p>

<p>可以看一眼项目结构，与常规的Android项目相比差不多，包含了两个模块（module）：</p>

<ul>
<li>composeApp 这是最主要的模块，可以说东西都在这里面。它是一个Kotlin模块（Kotlin module），包含了多端共用代码，以及不同平台的定制代码。使用Gradle来构建，用Gradle的脚本来描述构建方式。</li>
<li>iosApp 这是一个完整的Xcode项目，主要用于构建iOS目标，它会依赖于composeApp。</li>
</ul>


<p><strong>注意：</strong> 如果在<a href="https://kmp.jetbrains.com/?_gl=1*zmaxre*_gcl_au*NDM5ODU1NDAyLjE3Mjc1OTk1MDU.*_ga*MzEyMDU2NTg5LjE2NzQwMDg5NjM.*_ga_9J976DJZ68*MTczMTQwMTE0NC45NC4xLjE3MzE0MDExNDguNTYuMC4w">项目创建向导</a>中没有钩选iOS，将不会有模块iosApp，以及composeApp中的iosMain。</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/cmp-structure.png" alt="图2. 项目结构" /></p>

<p>重点需要关注<strong>composeApp</strong>，它包含了几个源码集合（source sets）：</p>

<ul>
<li>commonMain 这是最主要的集合，包含共享代码，由一个composable函数作为入口开始（如App()）开始。这里应该是项目的主要代码集合。</li>
<li>androidMain 包含与Android平台相关的代码，包括入口（如Android manifest和Activity），入口会调用commonMain中的入口composable。以及提供平台特定的定制化实现。</li>
<li>desktopMain 桌面端的入口，以及定制化实现。</li>
<li>iosMain 水果移动端的入口，以及定制化实现。</li>
<li>wasmJsMain Web端的入口，以及定制化实现。</li>
</ul>


<p><strong>注意：</strong> 源码集的具体数量取决于创建项目时钩选的目标平台。</p>

<p>源码集合（source set）构建工具Gradle的一个概念，它包含逻辑上相关的一坨源码文件，资源文件，以及其依赖，对于Android开发同学来说这个概念并不陌生。</p>

<p><img src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/module-structure.png" alt="图3. 项目源码集合关系" /></p>

<p>这种项目源码集合关系是由KMP定义的，编译构建的时候common部分会编译成为一个依赖组件，平台部分把common当成一个依赖使用，然后最终构建出目标产物，详细的过程可以<a href="https://kotlinlang.org/docs/multiplatform-discover-project.html">看KMP的文档</a>。</p>

<p>这个模板有默认的页面，可以看一下，打开文件commonMain中的App.kt，它包含一个composable函数App()，这就是CMP的入口，可以从这里开始用Compose写应用了。</p>

<h2>构建与运行</h2>

<p>项目创建向导创建出来的模板项目，包含了基本的页面，可以直接构建和运行。</p>

<p><strong>注意：</strong> 首次打开项目会比较慢，这是因为要下载Gradle工具链以及项目的依赖，视网络情况，可能需要几分钟到十几分钟不等，之后就能秒开。</p>

<p><strong>注意：</strong> 创建出来的项目依赖用的都比较新，比如像Android开发插件AGP可能会用8.5.2，但AGP的版本受制于Android Studio，<a href="https://developer.android.com/build/releases/gradle-plugin#android_gradle_plugin_and_android_studio_compatibility">AGP与AS的兼容对应关系可以看这里</a>。如果使用的AS版本较旧，需要调整AGP的版本。</p>

<p>待Gradle sync完成之后，就可以运行了。</p>

<h3>运行Android app</h3>

<p>对于Android app来说可以直接运行，在运行配置那里选择「composeApp」，连上手机（或者模拟器），运行就可以了。</p>

<p><img src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/compose-run-android.png" alt="图4. 运行Android app" /></p>

<h3>运行桌面端（Desktop）App</h3>

<p>桌面端没有默认运行配置，需要创建一个。在菜单中编辑运行配置（Run | Edit Configurations），点左上的加号，选择「Gradle」，输入个名字如「desktopRun」，然后在配置那一侧中的「Tasks and arguments」输入：</p>

<pre><code class="Bash">composeApp:run
</code></pre>

<p><img src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/compose-run-desktop-temp.png" alt="图5. 运行桌面端App" />
之后，选择「desktopRun」运行即可。</p>

<h3>运行iOS app</h3>

<p>如果选择了iOS的话，也有默认运行配置，可直接运行。但水果的东西必须依赖于水果的工具，所以要先打开Xcode，打开就行，放在一边不用做啥。然后回到AS，选择「iosApp」，运行，如果顺利，在Xcode那头就会启动iOS的模拟器，并运行App了。</p>

<p><img src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/compose-run-ios.png" alt="图6. 运行iOS app" /></p>

<p><strong>注意：</strong> 要想运行iOS，Xcode版本必须要在12.5以上，因为iOS构建方式是基于Xcode 12.5的。</p>

<h2>运行Web app</h2>

<p>Web端也没有默认配置，需要像桌面端那样创建一个，同样是Gradle，区别在于命令不一样：</p>

<pre><code class="Bash">wasmJsBrowserRun -t --quiet
</code></pre>

<p><img src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/compose-run-web.png" alt="图7. 运行Web app" />
然后，运行，这会开启一个本地server，如果浏览器没有自动打开的话，就手动打开浏览器，并输入「localhost:8080」，就能看到。</p>

<p><strong>注意：</strong> 如果开发平台是Mac，运行Web app时会有编译错误：</p>

<pre><code class="Bash">Continuous build does not work when file system watching is disabled
</code></pre>

<p>可以通过修改构建指令参数，添加&#45;&#45;watch&#45;fs来解决：</p>

<pre><code class="Bash">wasmJsBrowserRun -t --quiet --watch-fs
</code></pre>

<p>或者添加Gradle选项，以对所有的构建配置命令都生效：</p>

<pre><code class="Bash">org.gradle.vfs.watch=true
</code></pre>

<p>但是，无论是&#45;&#45;watch&#45;fs，还是Gradle选项，对于macOS 12（Monterey）以后才生效，详见<a href="https://docs.gradle.org/current/userguide/file_system_watching.html">Gradle文档</a>。</p>

<p>到此，应该说CMP的开发已经完全就位了。</p>

<h2>总结</h2>

<p>CMP配置简单，上手较快，前景光明，相信通过本文的学习可以了解并完全上车CMP开发了，还等啥呢赶紧上手撸一撸吧！</p>

<h2>References</h2>

<ul>
<li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/get-started.html">Get started with Kotlin Multiplatform</a></li>
<li><a href="https://kotlinlang.org/docs/multiplatform-intro.html">Introduction to Kotlin Multiplatform</a></li>
<li><a href="https://getstream.io/blog/build-app-kotlin-multiplatform/">Build Your First Android and iOS Mobile App With Kotlin Multiplatform</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用Compose中的CompositionLocal来暗渡陈仓]]></title>
    <link href="https://alexhilton.github.io/blog/2024/11/10/understanding-composition-local/"/>
    <updated>2024-11-10T23:17:56+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/11/10/understanding-composition-local</id>
    <content type="html"><![CDATA[<p>通过<a href="https://juejin.cn/column/7367555191338467337">前面的学习</a>我们知道Jetpack Compose是一个声明式的UI框架，采用的是函数式编程思想，直观上来看就是一坨函数从上调到下。当函数需要数据时，会通过函数调用的参数来传递，一般来说这也没有什么问题。但当需要的数据特别多时，特别是对于一些非业务逻辑本身的数据（输入与输出），如上下文环境变量（Context，或者主题之类），都通过函数调用的参数传递就难免会让代码变得非常的庞杂和臃肿。这时候就可以使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/CompositionLocal">CompositionLocal</a>，一种在组合树中隐式的从上到下传递数据的方法，我们来具体地看一下。</p>

<p><a href=""><img src="file:///Users/alexhilton/Downloads/compose_libs/compositionlocal.png" title="auto auto" ></a></p>

<!-- more -->


<p><strong>注意：</strong> Compose中的函数通常叫做composable，可以简单的理解为同一个东西。从根composable开始，一个套一个的调用，自上而下的意思就是指composable的调用顺序，根函数在上，被调用的函数在下。函数调用是可以传递参数的，正常的从上到下的数据传递都是通过函数调用时的参数。</p>

<p>废话不多说，我们先来看一下什么是CompositionLocal以及它能做什么事情。</p>

<h2>什么是CompositionLocal</h2>

<p>CompositionLocal提供一种<strong>自上而下</strong>的数据传递方式，<strong>隐式的传递</strong>，也就是说，不用把数据放在参数里传递给子函数，子函数像在类中的方法访问域变量那样直接访问。我们来看一个粟子。</p>

<p>比如说，页面中有一个文案，可能需要定制字体颜色，常规方式是这样子写：</p>

<pre><code class="Kotlin">@Composable
fun MyApp() {
    val colors = colors()
    SomeTextLabel(text, colors.onPrimary)
}

@Composable
fun SomeTextLabel(labelText: String, color: Int) {
    Text(
        text = labelText,
        color = color
    )
}
</code></pre>

<p>文案的颜色，以及像背景等等这些东西是与整个App的配置相关的，或者与运行环境（如手机）的主题风格有关的，它并不是应用程序的业务逻辑。它属于上下文环境变量，其变化往往是由于运行环境变化而变化，或者是由于用户更改了应用的配置。这就非常适合使用CompositionLocal来转化为隐式数据传递，进而简化代码，使用后就变成酱婶儿的：</p>

<pre><code class="Kotlin">@Composable
fun MyApp() {
    // 在上级函数中定义主题相关的颜色，并定义为CompositionLocal
    val colors = staticCompositionLocalOf( colors() )
    CompositionLocalProvider(LocalColors provides colors) {
        SomeTextLabel(text)
    }
}

// 被调用的子函数
@Composable
fun SomeTextLabel(labelText: String) {
    Text(
        text = labelText,
        color = LocalColors.onPrimary // 可以直接访问定义好的颜色
    )
}
</code></pre>

<p>通过这个示例可以看出，定义了CompositionLocal以后，在被调用到的所有子函数中（desendants）都可以直接使用，就像访问全局变量那样。这就是CompositionLocal的作用，在指定的作用域中提供隐式的数据。</p>

<h2>如何使用CompositionLocal</h2>

<p>使用起来非常的方便，就像在类的方法中使用域变量那样，或者像使用全局变量那样，找到上级所定义的的CompositionLocal实例，然后引用其中的变量即可。</p>

<p>其实，已经在不知不觉中经常地使用了CompositionLocal，主题风格相关的<a href="https://developer.android.com/reference/kotlin/androidx/compose/material3/MaterialTheme">MaterialTheme</a>，Android的上下文<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/package-summary#LocalContext(">LocalContext</a>)以及像绘制时常用的<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/package-summary#LocalDensity(">LocalDensity</a>)，这些都是CompositionLocal实例，是由Compose定义好的顶层实例，在所有的composables中都可以直接使用。</p>

<p>需要理解的是CompositionLocal实例，本身并不是一个数据，它更像是一个集装箱，它本身是一个数据传递的机制，会在后面定义CompositionLocal实例时详细讲解。</p>

<p>另外，需要特别注意的是CompositionLocal是有作用域的，对其所有的子函数生效，并且也可以嵌套的，<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/CompositionLocal#current(">属性current</a>)引用的是最近一层父函数（closest ancestor）中绑定的值。比如说：</p>

<pre><code class="Kotlin">@Composable
fun CompositionLocalExample() {
    MaterialTheme {
        // 绑定一个值到LocalContentColor
        CompositionLocalProvider(LocalContentColor provides MaterialTheme.colorScheme.primary) {
            Surface {
                Column {
                    Text("Uses Surface's provided content color")
                    // 重新绑定一个值到LocalContentColor
                    CompositionLocalProvider(LocalContentColor provides MaterialTheme.colorScheme.error) {
                        DescendantExample()
                    }
                }
            }
        }
    }
}

@Composable
fun DescendantExample() {
    // current会指向最后绑定的值，即MaterialTheme.colorScheme.error
    Text(text = "This Text uses the error color now", color = LocalContentColor.current)
}
</code></pre>

<h2>如何定义一个CompositionLocal</h2>

<p>大部分时候Compose中定义好的就够我们用了，但也可以针对具体的场景来自定义一个CompositionLocal。分为两个步骤，创建实例，和绑定数据。</p>

<p>CompositionLocal实例是一个集装箱，用以封装需要从顶层往底层传递的数据，这些数据也不一定非要是常量，也是会改变的，比如应用或者页面上下文环境变化时，或者整个应用的配置发生变化时。</p>

<h3>创建CompositionLocal实例</h3>

<p>第一步是先创建一个实例，有两种方法创建一个CompositionLocal实例，这两种方式的主要区别就在于当数据变化时如何影响着重组（reComposition）：</p>

<ul>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#compositionLocalOf(androidx.compose.runtime.SnapshotMutationPolicy,kotlin.Function0">compositionLocalOf</a>) 当数据发生变化时仅会影响读取数据函数的重组；</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#staticCompositionLocalOf(kotlin.Function0">staticCompositionLocalOf</a>) 当数组变化时，提供数据的所有子函数都会被重组。</li>
</ul>


<p>可以发现，这两个方法的区别就在于影响重组的范围，前一个是影响着读取数据的地方，这与状态（State）一样；后一个则是影响着所有的被调用的composables。</p>

<pre><code class="Kotlin">// LocalElevations.kt file

data class Elevations(val card: Dp = 0.dp, val default: Dp = 0.dp)

// 使用Elevations的默认值构造一个全局的CompositinLocal实例
// 这个实例可以被应用中的所有composables访问得到
val LocalElevations = compositionLocalOf { Elevations() }
</code></pre>

<p><strong>注意：</strong> 为了更好的可读性和可维护性，CompositionLocal实例的命名应该以Local开头，如LocalColors。</p>

<h3>把数据绑定到实例中去</h3>

<p>光创建实例没什么用，创建完实例后，还需要把数组绑定到CompositionLocal实例中去，并<strong>同时指定作用域</strong>，这是非常关键的一步，不但决定了CompositionLocal中有什么数据，还决定了谁可以使用这些数据。使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#CompositionLocalProvider(kotlin.Array,kotlin.Function0">CompositionLocalProvider</a>)来绑定数据：</p>

<pre><code class="Kotlin">// MyActivity.kt file

class MyActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContent {
            // 基于系统主题来计算具体的elevation
            val elevations = if (isSystemInDarkTheme()) {
                Elevations(card = 1.dp, default = 1.dp)
            } else {
                Elevations(card = 0.dp, default = 0.dp)
            }

            // 把上面计算得到的elevation绑定到LocalElevations
            CompositionLocalProvider(LocalElevations provides elevations) {
                // ... Content goes here ...
                // 这里的子composables都可以直接访问LocalElevations.current
                // 以得到elevation
            }
        }
    }
}
</code></pre>

<p>函数CompositionLocalProvider接收一个CompositionLocal实例和一个composable lambda，这个lambda就是这个实例的作用域，也即此lambda所调用的所有composables都可以使用访问此实例的数据。参数LocalElevations就是实例，可以看前面的创建代码。LocalElevations provides elevation这是infix符号式写法，相当于LocalElevations.provides(elevation)，elevation则是具体的数据，这意思就是在此lambda的作用域中，CompositionLocal实例LocalElevations会提供数据elevation。</p>

<pre><code class="Kotlin">@Composable
fun SomeComposable() {
    // 使用的地方直接通过LocalElevations.current就能访问到
    MyCard(elevation = LocalElevations.current.card) {
        // Content
    }
}
</code></pre>

<p>这里多说一下，compositionLocalOf是更为精细化的控制（fine-grained control），因为，当数据发生变化时，在作用域中只有读取了数据的composables才会被重组；而staticCompositionLocalOf影响范围较大，因为（当数据发生变化 时）整个作用域内（即CompositionLocalProvider的lambda）的composables都会被重组。</p>

<h2>什么时候该用CompositionLocal</h2>

<p>CompositionLocal提供了一种新的数据传递方式，当数据需要在一定作用域内（Scoped）分享时，就可以考虑使用它。但并不是所有的场景都适用，具体来说，要符合以下标准：</p>

<ul>
<li>数据要是非业务逻辑数据，也就是非代码所直接需要的输入和输出。</li>
<li>数据要有一个极其合理的初始值（默认值）。</li>
<li>数据不一定要是常量，也可以变化，但是业务逻辑并不是数据变化的原因。</li>
<li>数据的使用有一定的作用域。并且在作用域内<strong>所有的composables都可能会</strong>使用此数据。这一点很重要，如果仅仅是某个特定的composable使用，那就直接传参就好了。</li>
</ul>


<p>适合使用CompositionLocal的数据有应用的主题风格，应用的配置信息，平台提供的上下文变量，平台的配置信息，或者对于一个局部来说是上下文变量的数据（比如说一个Dialog用到的数据）。除此之外，绝大部分时候不应该使用CompositionLocal。特别是涉及业务逻辑代码本身强相关的数据（输入与输出），一定不能使用CompositionLocal，这会让代码极难理解和维护，造成极难调试的Bug。</p>

<p>CompositionLocal的一个大的特点就是有明确的作用域，那么如何选择合适的作用域呢？总的来说应该让作用域越小越好。视数据的 影响范围和使用范围来决定其作用域：</p>

<ul>
<li>整个应用级别的（App level），如主题风格，应用配置，平台的配置信息，或者会话数据（user sessions）。应该在根composable，即setContent处绑定数据。</li>
<li>整个页面级别的（Screen level），如平台上下文变量（Context或者Density），导航，或者页面内部的定制参数。</li>
<li>组件级别的（Component level），页面中某一个局部，比如Dialog的主题风格，或者Dialog并不直接操作，但却依赖的数据。</li>
</ul>


<p>任何工具都是为了适合其的场景而生的，要了解清楚什么场景适合使用非常重要，切忌滥用。</p>

<h2>它与状态（State）的区别是什么</h2>

<p>从前面的文章<a href="https://juejin.cn/post/7376094685495001139">降Compose十八掌之『鸿渐于陆』| State</a>我们了解到，状态（State）是为了重组时数据不丢失，也就是说在composable多次运行时，数据能够得以留存。反过来状态变化了，也会触发重组，因为要刷新UI。状态是时间上的概念（使用此状态的composables）多次运行，状态持有的数据都得以保存，不会变成初始值。如果想要使用状态，必须当作参数传递过去。</p>

<p>而CompositionLocal是为了能在不同的composables中共享数据，不用参数传递，它是空间上的概念。</p>

<p>它们是为了解决不同的问题而设计出来的。可以把状态绑定到CompositionLocal中去，但其实没必要这么做，因为内部实现上已经会把绑定的数据封装为状态，因为CompositionLocal的数据是可能发生变化的，并且当变化时，也是要触发重组的。</p>

<h2>它与全局变量的区别是什么</h2>

<p>Kotlin语言是支持顶级全局变量（Top level globals）的，也就是与class平齐，在任何class之外的全局变量，其作用域是整个进程，任何导入（import）此变量的地方都可以访问。Compose是基于Kotlin语言的，所以Compose也是可以使用全局变量的。</p>

<p>全局变量的缺点是没有作用域，容易失控，仅应该用于常量，并且它也不能用于composables的重组。虽然全局变量可以跨越空间，让所有函数都能访问。全局变量是编程语言层面的东西，仅适用于常量的定义，也即整个应用程序运行期间确定不会发生改变的值。</p>

<p>这正是CompositionLocal有价值的地方，它能限定作用域，又可以触发重组，允许数据值改变，又可以跨越空间。这是Compose框架层面提供的工具，自然更适合在Compose中使用。</p>

<h2>总结</h2>

<p>调用函数时传递参数可谓是『明修栈道』，而CompositionLocal则是『暗渡陈仓』，提供了一种在组合（Composition）中自上而下隐式传递数据的一种方式，可以让函数调用只关心与逻辑相关的输入数据。恰当的使用CompositionLocal可以有效的管控上下文环境变量，并极大地简化代码，让代码更加的优雅和简洁。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/compositionlocal">Locally scoped data with CompositionLocal</a></li>
<li><a href="https://www.valueof.io/blog/compose-compositionlocal-compositionlocalprovider">Passing data using CompositionLocal</a></li>
<li><a href="https://www.kodeco.com/34513206-compositionlocal-in-jetpack-compose">CompositionLocal in Jetpack Compose</a></li>
<li><a href="https://medium.com/mobile-innovation-network/understanding-composition-local-jetpack-compose-4546605df5e1">Understanding Composition Local: Jetpack Compose</a></li>
<li><a href="https://medium.com/@ramadan123sayed/composition-local-in-jetpack-compose-4d0a54afa67c">Composition Local in Jetpack Compose</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给Jetpack Compose添加Native支持]]></title>
    <link href="https://alexhilton.github.io/blog/2024/11/08/android-jni-made-easy/"/>
    <updated>2024-11-08T22:40:32+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/11/08/android-jni-made-easy</id>
    <content type="html"><![CDATA[<p>Jetpack Compose是一个声明式的UI框架，但一个项目不可能光有UI，还需要有业务逻辑。Compose所用的编程语言是Kotlin，一种基于JVM的多范式通用编程语言，尽管非常强大，但因为现代的项目都非常复杂，多语言混合，有些东西用Kotlin没法实现，或者有些现成的C/C++代码可以复用，这时就需要能把native代码集成到Compose项目中去。</p>

<p><a href=""><img src="https://questdot.com/wp-content/uploads/2016/07/ndkjni-720x340.png" title="auto auto" ></a></p>

<!-- more -->


<p>想要在Compose中使用native代码是完全可行的，这是因为Compose是基于Kotlin的，而Kotlin本质上是JVM的字节码，也就是运行在虚拟机之上的语言。Java的Native接口，即JNI其实是虚拟机开出的口子，只要能在JVM上运行就可以用JNI，所以标准的Java JNI是完全可以用在Compose里面的。</p>

<p><strong>注意：</strong> native代码（原生代码）在不同的语境有不同的意思，它通常指操作系统直接支持的可执行程序。Java（字节码）是运行在虚拟机上的，操作系统被虚拟机给隔离了，对Java是透明的，这时像可以编译为直接在操作系统上运行的代码（如C/C++）称为native代码；假如换个语境，如运行在WebView中的Web前端，则可以直接运行在Android上的或者iOS上的原生SDK代码则称为native代码。</p>

<p>先来看一下如何在Compose项目中添加native支持。</p>

<h2>新项目</h2>

<p>新的项目在创建项目的时候可以选择C++，无论是Kotlin的类，以及C++的实现，以及配置文件都会有模板。但除了demo以外，一般不会有新建项目的机会，极少项目是从0开始。绝大多数情况都是在现有项目中添加native支持，所以我们重点看看如何在现有项目中添加native支持。</p>

<h2>现有项目添加JNI支持</h2>

<p>现在的Android Studio已经对JNI有了很好的支持，AGP中也提供了支持，所以可以不用NDK中命令行式的ndk-build了。对于现有项目想添加JNI支持也不麻烦，有两种方式：一种是添加一个native的Module，新建Module时选择native library就可以了，这个Module里面与新建的Native项目是差不多的。这种方式适合于比较独立的一个新的需要native支持的模块，然后此模块再作为主模块的依赖，比较合适的场景是一个独立的功能模块；</p>

<p>第二种方式就是，像新建 的native项目那样，直接添加native支持：</p>

<h3>Step 1 添加C/C++源码目录</h3>

<p>先在对应的module如app中添加cpp源码目录，要放在与java或者kotlin同级别的目录，如app/src/main/下面，之后所有native层的东西都在app/src/main/cpp下面。</p>

<h3>Step 2 设置CMake</h3>

<p>在建 好的目录下面添加源码LocalJNI.cpp和编译文件CMakeLists.txt。</p>

<pre><code class="Bash">cmake_minimum_required(VERSION 3.22.1)

project("effectivejni")

add_library(${CMAKE_PROJECT_NAME} SHARED
        # List C/C++ source files with relative paths to this CMakeLists.txt.
        LocalJNI.cpp)
target_link_libraries(${CMAKE_PROJECT_NAME}
        # List libraries link to the target library
        android
        log)
</code></pre>

<p>CMake是一个跨平台的C/C++编译系统，可以参考 <a href="https://cmake.org/">其官文档</a>了解详细信息。</p>

<h3>Step 3 在Gradle脚本中添加native build关联</h3>

<p>在android块中加入externalNativeBuild：</p>

<pre><code class="Kotlin">android {
    // ...
    externalNativeBuild {
        cmake {
            path("src/main/cpp/CMakeLists.txt")
            version = "3.22.1"
        }
    }
}
</code></pre>

<h3>Step 4 添加带有native方法的类</h3>

<p>这一步要特别注意，因为JNI是Java Native Interface，所以必须要严格符合Java的方式，native方法的声明必须是某个类的方法；另外，JNI调用Java时也必须先找到某个类，然后再调用它的方法。所以必须 要有一个Java的public类：</p>

<pre><code class="Kotlin">package net.toughcoder.effectivejni

class LocalJNI {

    external fun stringFromLocal(): String

    companion object {
        init {
            System.loadLibrary("effectivejni")
        }
    }
}
</code></pre>

<p>当然，这个类可以放在任何文件中。因为Kotlin放宽了Java的限制，在Java中每一个public的类必须要放在一个名字一样的文件中，但Kotlin的文件与类没有对应的关系，所以可以把这个类放在任何文件中，当然了package要指明，因为在JNI中查找class时，要指定package name。</p>

<h3>Step 5 实现native方法</h3>

<p>具体native方法的实现就看具体要做什么了。这里只是演示所以简单返回一个字符串。</p>

<pre><code class="C++">#include &lt;jni.h&gt;
#include &lt;string&gt;

extern "C" JNIEXPORT jstring JNICALL
Java_net_toughcoder_effectivejni_LocalJNI_stringFromJNI(
        JNIEnv* env,
        jobject /* this */) {
    std::string hello = "Hello from C++ with static mapping";
    return env-&gt;NewStringUTF(hello.c_str());
}
</code></pre>

<p><strong>注意：</strong> 虽然Compose使用的编程语言是Kotlin，但毕竟Kotlin是JVM语言，也与Java可以相互替换。对于JNI来说，Kotlin与Java无区别，所以后面会以Java来统一当作native的另一端。</p>

<h2>JNI注册</h2>

<p>无论是用C/C++去实现native接口，还是复用现成的native方法，都需要要把native方法与Java层声明的方法进行关联映射，以让JVM能找到此方法的实现，这也即所谓的JNI注册。有两种方式进行JNI注册。</p>

<p>静态方式，其实就是Java默认支持的方式，它要求Native的实现函数是纯C的，要用『extern C』包裹起来，还有就是方法的名字要是Java&#95;包名&#95;类名&#95;方法名，比较严格。前面的示例用的就是静态注册。</p>

<p>动态注册的原理是加载so的时候，当虚拟机在找到so以后，会查找里面一个叫做JNI&#95;OnLoad的函数指针，然后执行此函数。那么，在so的实现中，写一个叫做JNI&#95;OnLoad的函数，在里面手动进行Native方法注册，然后当so被加载时JNI&#95;OnLoad就会被执行，JNI方法就注册好了。</p>

<pre><code class="C++">#include &lt;jni.h&gt;
#include &lt;string&gt;

// Method declaration
jstring dynamicString(JNIEnv *env, jobject thiz);

// JNI wrapper
const char className[] = "net/toughcoder/effectivejni/LocalJNI";

const JNINativeMethod methods[] = {
        {"stringFromJNI", "()Ljava/lang/String;", reinterpret_cast&lt;void *&gt;(dynamicString)}
};

JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved) {
    JNIEnv *env;
    if (vm-&gt;GetEnv(reinterpret_cast&lt;void **&gt;(&amp;env), JNI_VERSION_1_6) != JNI_OK) {
        return JNI_ERR;
    }
    jclass clazz = env-&gt;FindClass(className);
    env-&gt;RegisterNatives(clazz, methods, (int) (sizeof(methods) / sizeof(methods[0])));

    return JNI_VERSION_1_6;
}

// The implementation
jstring dynamicString(JNIEnv *env, jobject thiz) {
    std::string str = "String from JNI via dynamic mapping.";
    return env-&gt;NewStringUTF(str.c_str());
}
</code></pre>

<p>这个JNI&#95;OnLoad的方法的参数很有意思是一个JavaVM对象指针，JavaVM对象每个应用进程只有一个，可以认为就是应用的虚拟机。但每个JNI方法都有一个JNIEnv对象指针，它给native方法提供一个JNI上下文，这个则是每个线程都有一个。</p>

<p>推荐使用动态注册方式进行JNI注册，这是因为这种方式更为灵活，不必写繁琐的方法声明，也不必用extern C限制，可以是常规的C++函数。</p>

<h2>JNI是一个接口层</h2>

<p>JNI是一个口子，可以让Java调用native代码，也能让native代码调用Java代码，调用Java代码就相当于反射。JNI是一个传送门，虽然入口处有一些限制，但深入到native里面就是完全的C和C++世界了，只要是C和C++能实现的事情都可以做。</p>

<p><img src="file:///Users/alexhilton/Downloads/JNI.svg" alt="图1. JNI是一个传送门" /></p>

<h2>JNI线程</h2>

<p>需要注意的是结构体JavaVM是所有线程共享，它代表着进程所在的虚拟机。但结构体JNIEnv则是代表着栈中的执行环境（因为JNI仅一个方法，而方法必然运行在某个线程之中），每个线程有一个。创建的局部引用也不能跨线程使用。</p>

<p>从JNIEnv获取JavaVM：env->GetJavaVM(&amp;vm)</p>

<p>从JavaVM获得当前JNIENV：vm->AttachCurrentThread(&amp;env, null)</p>

<p>最好都从Java层来管理线程，JNI只是某些方法的实现。</p>

<p>如果JNI的native代码也很复杂需要线程的话，也可以用pthread创建线程，但也应该维持在一定的作用域范围内，不应该再从此线程去调用Java。这样只会制造混乱。</p>

<h2>两个世界的对象连接</h2>

<p>需要注意JNI是纯C接口，没有对象的概念，入口处的native方法不属于任何C++对象。假如native深入层足够复杂也有一套对象，如何建立起 Java层对象和native对象的连接呢？可以参考Android frameworks的作法，它通常会给Java层的对象有一个整形域变量，用以存放native层对象指针，这样就能建立起来对象与对象的一一对应关系。</p>

<h2>添加已编译好的native库</h2>

<p>JNI是连接Java层与C/C++层的传送门，除了新写的native代码，也可以直接使用已编译好的C/C++的库，静态库libxxx.a和动态库libxxx.so。</p>

<p>预编译的库通常作为JNI的依赖，当然也可以直接加载，前提是so里面已包含了JNI接口。但需要特别注意的是静态的库.a是无法直接在Java中加载的，也即无法通过System.loadLibrary()来加载native的静态库。因此静态库只能作为依赖，要包一层，写一个Wrapper层编译为so，静态库作为so的依赖，然后把so加载为JNI。</p>

<p>通过CMake中的add_library指令来添加预编译好的库，具体可以 <a href="https://cmake.org/cmake/help/latest/command/add_library.html">参考其文档</a>。</p>

<h2>NDK的版本</h2>

<p>在项目的配置gradle文件中可以指定具体的NDK版本：</p>

<pre><code class="Kotlin">android {
    ndkVersion = "28.0.12433566"
}
</code></pre>

<p>NDK的版本可以看<a href="https://developer.android.com/ndk/downloads/revision_history">官方发布历史</a>，NDK主要是指Android提供的native API（C/C++ API），主要是一些系统提供的能力，如音频视频能力，图形图像能力等，可以看<a href="https://developer.android.com/ndk/guides/stable_apis">其接口说明文档</a>，以及<a href="https://developer.android.com/ndk/reference">NDK开发文档</a>。</p>

<h2>C/C++的版本指定</h2>

<p>C++语言自从其诞生，在Java和新一代编程语言出现后，曾一度长期停滞，在泛型，函数式编程，并发上面落后于其他语言，并被诟病。但从C++11开始，（C++语言的版本以年份的后两位来命名，如C++11是指2011年发布的版本，C++17指2017年发布的，以此类推）这门古老的语言焕然一新，增加了很多新时代编程语言的特性，其后的C++17继续前进，到现在的C++20已经完全是一个现代化的编程语言了，lambda，函数式，泛型和并发都有了非常好的支持，甚至已经超越了老对手Java。因此，C++11以后的版本也称为『现代C++（Modern C++）』。</p>

<p>都4202年了，肯定要用最新的C++20才行啊。CMake使用的是LLVM编译器，而LLVM已经完全支持C++20了，但默认的版本使用的是C++17，想要特别的版本，就需要在CMakefile.txt中进行指定，也即通过添加编译选项来指定C++的版本：</p>

<pre><code class="Bash">set(CMAKE_ANDROID_STL_TYPE "c++_shared")
set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -std=c99")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++20")
</code></pre>

<h2>JNI内存管理</h2>

<p>Java层是自动档（自动内存管理），但C/C++是手动档，因此穿过JNI后就需要特别小心内存管理。有一些注意事项：</p>

<ul>
<li>Java 层传过来的对象，不需要手动去释放。比如说传过来的数组或者字符串。</li>
<li>传回给Java层的对象，也不需要手动释放。比如像上面的例子新创建出来的字符串，尽管使用了New，但不需要管。GC会追踪。而且你也没法释放，创建完对象交给Java层了，不确定Java还在不在使用中呢，你咋delete？</li>
<li>只应该管理生命周期全都在native的new出来的对象，和引用。</li>
<li>需要特别注意方法运行的上下文，也即JNIEnv，这个东西每个线程有一个，且是不同的。要保证在同一个JNIEnv中管理内存，不同的JNIEnv无法共享创建出来的对象和引用，不能交叉使用，更不能交叉式的释放。</li>
</ul>


<h2>JNI能做什么</h2>

<p>JNI是一个接口层，能够让Java进入C/C++世界，调用C/C++的代码，包括现有代码。所以只要编译出来了目标平台（ARM）的so，就可以在JNI中用。</p>

<p>当然了，为了兼容性，使用的so最好用NDK进行编译。</p>

<p>因为Android是Linux内核的，所以，理论上Linux系统调用支持的东西全都能在JNI里面搞。当然，使用native最为正确的体位是使用NDK来实现想要的功能，可以查看<a href="https://developer.android.com/ndk/reference">NDK的开发文档</a>来明确可以做哪些事情。</p>

<h2>使用JNI的正确姿式</h2>

<p>JNI虽好，但不要滥用，不能单单以『C/C++语言性能高于Java（JVM）』为理由就去使用JNI。JNI本身是一个口子，单从方法调用角度讲，从Java层调用过来要有历经查询和数据转换，不见得会比Java方法高效到哪里去。而且JNI在线程调度，异常管理和内存管理上面都较Java层相比非常的不方便，那点看起来的性能优势的代价是很大的，所以说能不用JNI就别用。</p>

<p>使用JNI的正确理由：</p>

<ol>
<li>做一些Java层无法做到的事情，比如一些底层的系统调用（System calls），Java层做不到，那自然得用C/C++</li>
<li>使用一些现有的C/C++代码，这个是最为正统的理由</li>
<li>基于安全角度考量，把一些关键的实现放在C/C++层，这个也合理，因为C/C++相较于Java字节码要略难破解一些</li>
<li>基于跨平台角度考虑，把一些与平台关联密切的，且独立的模块用C/C++实现，比如像通信协议，或者加密，或者压缩之类的非常独立的功能模块，用C/C++来实现，屏蔽名个平台的不同，这会让Java层更加的简单</li>
</ol>


<p>除此之外，似乎没有理由使用JNI。另外，在使用的时候也要注意尽可能的单进单出，也就是说从Java层调用native方法，进去后一直在native运算，得到结果后返回给Java。而不应该频繁的有交互，比如说Java层调用进了native方法，但在native中又频繁 的调用Java层的方法。这明显是设计不合理，应该在Java层把需要的数据准备齐全后，再调用native层。</p>

<h2>References</h2>

<ul>
<li><a href="https://juejin.cn/post/7382893339098906665">Android JNI入门</a></li>
<li><a href="https://juejin.cn/post/7302684536148230194">一、Android-JNI开发</a></li>
<li><a href="https://juejin.cn/post/6844903933375152136">Android NDK-深入理解JNI</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1666741">JNI线程相关</a></li>
<li><a href="https://developer.android.com/studio/projects/add-native-code">Add C and C++ code to your project</a></li>
<li><a href="https://developer.android.com/training/articles/perf-jni">JNI tips</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让Activity更加优雅地跳转]]></title>
    <link href="https://alexhilton.github.io/blog/2024/10/14/activity-result-launcher/"/>
    <updated>2024-10-14T22:24:55+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/10/14/activity-result-launcher</id>
    <content type="html"><![CDATA[<p>有过Android开发经验的小伙伴对<a href="https://developer.android.com/reference/android/app/Activity#startActivityForResult(android.content.Intent,%20int">startActivityForResult</a>)以及<a href="https://developer.android.com/reference/android/app/Activity#onActivityResult(int,%20int,%20android.content.Intent,%20android.app.ComponentCaller">onActivityResult</a>)一定不陌生，正是这一对API让组件 的复用变成可能。今天就来学习一下如何在函数式的范式中驾驭Activity的跳转。</p>

<p><a href=""><img src="https://akexorcist.dev/content/images/size/w2000/2021/12/activity_result_api-header.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>缘起</h2>

<p>系统组件复用，特别是Activity的复用，是Android系统中非常重要的一个设计理念。组件复用打破了应用程序之间的壁垒，在整个系统范围内可以共享和复用一些公共的组件，比如像打开网页，拍照片，查看图片等等，开发者不必再用原始API去实现一套，直接使用startActivityForResult和onActivityResult就可以取到需要的资源。</p>

<p>这套API最大的问题在于它并不是常规的异步式的回调，调用了startActivityForResult后，结果的处理，必须要在Activity的继承体系内覆写onActivityResult，并且因为Activity实例只能由系统创建，这就导致了组件复用的逻辑必须都在Activity内部。这就导致了Activity的体积通常会相当的臃肿，上千行，甚至大几千行的Activity随处可见。理想的情况下Activity，作为一个系统的容器和接口，应该越薄越好，但要能把逻辑移出Activity才行。</p>

<p>另一方面，onActivityResult无法在函数式的情境中使用，因为它会跑到函数外面去，比如在Jetpack Compose中就无法直接使用startActivityForResult和onActivityResult。</p>

<p>为了解决这两个问题，就需要使用到Jetpack中的<a href="https://developer.android.com/reference/androidx/activity/result/package-summary">Activity Result API</a>了。</p>

<h2>Activity Result API的使用方法</h2>

<p>在Jetpack的AndroidX中的<a href="https://developer.android.com/jetpack/androidx/releases/activity">Activity</a>和<a href="https://developer.android.com/jetpack/androidx/releases/fragment">Fragment</a>中，可以像常规的回调那样向系统注册一个处理result的回调，一旦系统派发了activity result就能被系统回调到。</p>

<p><strong>注意：</strong> 这里提到的方法都在AndroidX中的<a href="https://developer.android.com/reference/androidx/activity/ComponentActivity">ComponentActivity</a>和<a href="https://developer.android.com/reference/androidx/fragment/app/Fragment">Fragment</a>里面，也就是说要继承AndroidX中的组件才可以。</p>

<h3>注册一个activity result回调</h3>

<p>这套API的方式是在ComponentActivity和Fragment中，提供了一个<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultCaller#public-methods_1">registerForActivityResult</a>方法用于注册activity result的回调。参数是一个<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContract">ActivityResultContract</a>实例和一个<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultCallback">ActivityResultCallback</a>实例。返回的是一个<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultLauncher">ActivityResultLauncher</a>，这个launcher可以用来启动目标Activity，也即触发获取资源的流程，相当于原来的startActivityForResult：</p>

<pre><code class="Kotlin">val getContent = registerForActivityResult(GetContent()) { uri: Uri? -&gt;
    // 处理结果
}
</code></pre>

<p>一个ActivityResultContract，如它的名字所示，定义着组件复用的的接口，即输入类型和输出类型。API中定义了<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContracts">大量的现成可用的，也是常见的接口</a>，比如拍照，权限请求等等。当然也可以创建<a href="https://developer.android.com/training/basics/intents/result#custom">自定义接口</a>。</p>

<p>回调ActivityResultCallback是只有一个方法onActivityResult()的接口，此方法的参数由ActivityResultContract来定义。</p>

<h3>启动目标Activity</h3>

<p>当调用registerForActivityResult时，能拿到一个launcher，但此API仅是向系统注册一个回调，这时还没有启动目标（即还没有发起请求）。发起请求需要使用ActivityResultLauncher来完成。</p>

<p>调用其<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultLauncher#launch(I">方法launch</a>)就会发起请求，启动目标Activity，开启获取结果的流程。如果给launch传递了参数，会依据ActivityResultContract做进一步的匹配（其实这些输入最终会转化为Intent对象提供给startActivityForResult）。用户在目标Activity页面完成了操作后，就会返回到当前页面，回调ActivityResultCallback的方法onActivityResult就会被执行：</p>

<pre><code class="Kotlin">val getContent = registerForActivityResult(GetContent()) { uri: Uri? -&gt;
    // 处理结果，即返回的Uri
}

override fun onCreate(savedInstanceState: Bundle?) {
    // ...

    val selectButton = findViewById&lt;Button&gt;(R.id.select_button)

    selectButton.setOnClickListener {
        // 接口是获取内空，这里传mime type作为参数，那么就是要获取一个图片内容
        getContent.launch("image/*")
    }
}
</code></pre>

<p>如果需要多个组件复用，那就传递不同的参数多次调用registerForActivityResult。并且registerForActivityResult可以在任何时候调用，在onCreate之前调用也是安全的，所以可以在声明ActivityResultLauncher的时候就直接调用，这样可以直接初始化。</p>

<p>但是要特别注意，使用launcher来启动Activity则必须在onCreate之后。</p>

<p>还有一点需要特别注意，因为launch之后，onActivityResult之前这段时间会离开当前的Activity，这个时间内Activity可能会被系统回收，也即触发了状态恢复。所以处理结果时，也即onActivityResult中的逻辑，如果有依赖其他状态，这些状态需要在onSaveInstanceState中进行保存。</p>

<h3>处理结果</h3>

<p>结果的处理就在ActivityResultCallback中的方法onActivityResult，这里使用返回的参数就可以了。</p>

<h2>在Activity之外使用</h2>

<p>如前面所述，使用这套Result API的最大的好处在于把结果的处理从Activity中解耦出来，因此，最为理想的方式是能在独立的class中做这些事情。</p>

<p>这就需要使用<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultRegistry">ActivityResultRegistry</a>，它才是核心，另外三个类（launcher，contract和callback）都是一些封装，事实上Activity和Fragment里面的方法registerForActivityResult其实也是使用这个registry来实现的。从Activity中可以拿到registry的实例，以此作为参数，就可以在自定义的class中使用Result APIs了。</p>

<p>比如单独封装获取图片的流程可以这样写：</p>

<pre><code class="Kotlin">class MyLifecycleObserver(private val registry : ActivityResultRegistry)
        : DefaultLifecycleObserver {
    lateinit var getContent : ActivityResultLauncher&lt;String&gt;

    override fun onCreate(owner: LifecycleOwner) {
        getContent = registry.register("key", owner, GetContent()) { uri -&gt;
            // Handle the returned Uri
        }
    }

    fun selectImage() {
        getContent.launch("image/*")
    }
}

class MyFragment : Fragment() {
    lateinit var observer : MyLifecycleObserver

    override fun onCreate(savedInstanceState: Bundle?) {
        // ...

        observer = MyLifecycleObserver(requireActivity().activityResultRegistry)
        lifecycle.addObserver(observer)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        val selectButton = view.findViewById&lt;Button&gt;(R.id.select_button)

        selectButton.setOnClickListener {
            // 触发获取图片的流程
            observer.selectImage()
        }
    }
}
</code></pre>

<p>这个示例把获取图片的流程（发起和结果处理）都封装在了一个单独的类中，同时又是明是监听了Activity组件的生命周期。谷歌是强烈建议同时要<a href="https://developer.android.com/reference/kotlin/androidx/lifecycle/LifecycleObserver">监听生命周期</a>（通过扩展LifecycleObserver），这是因为<a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner">LifecycleOwner</a>会在destroy时自动帮你反注册ActivityResultLauncher，不然的话就要手动的<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultLauncher#unregister(">反注册</a>)。</p>

<h2>自定义Contract</h2>

<p>尽管谷歌已经在<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContracts">ActivityResultContracts</a>中已经预定义了大量的contracts可以使用，但仍然会有一些特殊的场景因预定义的contract无法满足需求而需要自定义一个contract。这个contract实际上就是约定了组件复用的接口，就像普通的interface一样，定义好输入与输出的类型就可以了，所以需要给contract提供输入输出的类型，如果不需要输入或者输出就使用Void?或者Unit。</p>

<p>此外还需要实现一个<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContract#createIntent(android.content.Context,kotlin.Any">createIntent方法</a>)，这个方法接收一个Context和其他输入（即contract约定的输入，最终是由ActivityResultLauncher中方法launch时提供）作为参数并返回一个Intent对象，此Intent会是startActivityForResult的输入参数。同时还需要实现另外一个<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContract#parseResult(kotlin.Int,android.content.Intent">方法parseIntent</a>)，此方法将<a href="https://developer.android.com/reference/android/app/Activity#onActivityResult(int,%20int,%20android.content.Intent,%20android.app.ComponentCaller">Activity的标准钩子onActivityResult</a>)中的参数resultCode和Intent转化为contract中约定的输出（此输出会作为回调ActivityResultCallback函数方法onActivityResult的输入参数）。</p>

<pre><code class="Kotlin">class PickRingtone : ActivityResultContract&lt;Int, Uri?&gt;() {
    override fun createIntent(context: Context, ringtoneType: Int) =
        Intent(RingtoneManager.ACTION_RINGTONE_PICKER).apply {
            putExtra(RingtoneManager.EXTRA_RINGTONE_TYPE, ringtoneType)
        }

    override fun parseResult(resultCode: Int, result: Intent?) : Uri? {
        if (resultCode != Activity.RESULT_OK) {
            return null
        }
        return result?.getParcelableExtra(RingtoneManager.EXTRA_RINGTONE_PICKED_URI)
    }
}
</code></pre>

<p>如果现有的contracts不满足需求，且也无具体的输入输出要求，那么可以用一个万用contract，即<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContracts.StartActivityForResult">StartActivityForResult</a>。这个万用contract的输入是一个Intent，输出是一个<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResult">ActivityResult</a>，在回调方法onActivityResult中可以直接从ActivityResult实例中取出resultCode和目标返回的Intent对象：</p>

<pre><code class="Kotlin">val startForResult = registerForActivityResult(StartActivityForResult()) { result: ActivityResult -&gt;
    if (result.resultCode == Activity.RESULT_OK) {
        val intent = result.data
        // 处理目标返回的Intent
    }
}

override fun onCreate(savedInstanceState: Bundle) {
    // ...

    val startButton = findViewById(R.id.start_button)

    startButton.setOnClickListener {
        // 传入想要启动的Intent对象
        startForResult.launch(Intent(this, ResultProducingActivity::class.java))
    }
}
</code></pre>

<p>从这里我们可以看出，这套Result API本质上仍是依赖于原始的startActivityForResult和onActivityResult。</p>

<h2>在Compose中使用Result API</h2>

<p>接下来我们看看如何在Jetpack Compose使用这套API，这套API与Activity彻底解耦且支持函数式写法，所以可以在Compose中使用。这套API的核心是ActivityResultRegistry，有了它其他几个就可以使用起来了，而它的实例可以直接从Activity中取出来，所以这套API在Compose中完全可以用起来，与前面讲到的在Activity之外的逻辑完全一样：获取此对象用于register一个contract，同时得到一个launcher对象，在回调中处理结果，在合适的时机触发launch。</p>

<p>幸运的是完全用不着自己折腾，Compose中已经做好了封装，直接使用<a href="https://developer.android.com/reference/kotlin/androidx/activity/compose/package-summary#rememberlauncherforactivityresult">rememberLauncherForActivityResult</a>即可：</p>

<pre><code class="Kotlin">@Composable
fun GetContentExample() {
    var imageUri by remember { mutableStateOf&lt;Uri?&gt;(null) }
    val launcher = rememberLauncherForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? -&gt;
        imageUri = uri
    }
    Column {
        Button(onClick = { launcher.launch("image/*") }) {
            Text(text = "Load Image")
        }
        Image(
            painter = rememberAsyncImagePainter(imageUri),
            contentDescription = "My Image"
        )
    }
}
</code></pre>

<p>今天我们学习了Jetpack中提供的新式处理activity result的方法，这不仅能让在函数式编程范式中复用组件变成可能，也可以把很多逻辑从Activity中抽离出来，能给Activity瘦身，让组件跳转变得更为优雅。</p>

<h2>References</h2>

<ul>
<li><a href="https://blog.dogukangun.de/the-usage-of-activity-result-launcher-9c3d2241ec8">The Usage of Activity Result Launcher</a></li>
<li><a href="https://developer.android.com/training/basics/intents/result">Get a result from an activity</a></li>
<li><a href="https://stackoverflow.com/questions/64721218/jetpack-compose-launch-activityresultcontract-request-from-composable-function">Jetpack Compose: Launch ActivityResultContract request from Composable function</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/libraries">Compose and other libraries</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
