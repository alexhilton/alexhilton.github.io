<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2024-06-26T22:15:19+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『突如其来』| Graphics Modifiers]]></title>
    <link href="http://toughcoder.net/blog/2024/06/26/graphics-with-modifiers/"/>
    <updated>2024-06-26T22:14:14+08:00</updated>
    <id>http://toughcoder.net/blog/2024/06/26/graphics-with-modifiers</id>
    <content type="html"><![CDATA[<p>在Jetpack Compose中创建自定义绘制内容的方式不止一种，除了前面提到的<a href="https://juejin.cn/post/7381826917086920742">通过Canvas函数的方式</a>以外，还可以通过Modifier的几个扩展函数更为灵活实现一些的自定义内容。今天就来学习一下如何使用Modifier的扩展函数来绘制自定义内容。</p>

<p><a href=""><img src="https://files.koenig.kodeco.com/uploads/2023/11/GraphicsJetpackCompose-twitter.png" title="auto auto" ></a></p>

<!-- more -->


<h2>使用Modifier来叠加自定义内容</h2>

<p>先用一个简单的实例来看一下，如何用Modifier来实现一个自定义内容：</p>

<pre><code class="Kotlin">    val textMeasurer = rememberTextMeasurer()

    Box(
        modifier = Modifier.fillMaxSize()
            .padding(16.dp)
            .drawWithContent {
                drawRect(Color.LightGray)

                drawText(
                    textMeasurer = textMeasurer,
                    text = "降Compose十八掌",
                    topLeft = Offset(size.width / 4f, size.height / 2.2f)
                )

                drawCircle(
                    color = Color.Magenta,
                    radius = size.width / 10f,
                    center = Offset(size.width / 1.8f, size.height / 3f)
                )
                drawCircle(
                    color = Color.Yellow,
                    radius = size.width / 12f,
                    center = Offset(size.width / 1.6f, size.height / 4.5f)
                )
                drawCircle(
                    color = Color.Green,
                    radius = size.width / 14f,
                    center = Offset(size.width / 1.46f, size.height / 7f)
                )
            }
    )
</code></pre>

<p><img src="file:///Users/alexhilton/Desktop/hello_graphics_modifer.png" alt="hello_graphics_modifier" /></p>

<p>可以看到使用Modifier方式与Canvas略不一样，它要应用到其他的Composable上面，所以Modifier方式主要用于<strong>修改或者增强</strong>现有的Composable以达到想要的效果。仍是提供了一个带有<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/drawscope/DrawScope">DrawScope</a>指针的lambda，在这里写绘制指令。</p>

<p>Modifier提供的自定义绘制方式有四种：drawWithContent，drawBehind，drawWithCache和graphicsLayer。前面三种是是针对绘制的扩展，也就是影响绘制的内容；最后一个是图形的扩展，也就是主要用于已经绘制好了的内容的变幻。</p>

<h2>覆写式绘制</h2>

<p>最核心的扩展函数就是<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/draw/package-summary#(androidx.compose.ui.Modifier">Modifier.drawWithContent</a>.drawWithContent(kotlin.Function1))，它可以让你在目标Composable的内容绘制前或者绘制后，执行一些DrawScope的绘制命令来进行自定义的绘制。也就是说，这个扩展函数可以你让自由的决定在目标Composable绘制之前前或者绘制之后，执行自己想要的绘制命令，以实现一些额外的自定义效果。不过，要记得调用drawContent函数，这个函数是目标Composable的内容绘制函数，当然也可以不调用，那样就变成纯的自定义Composable了。</p>

<p>来看一个猫眼效果：</p>

<pre><code class="Kotlin">@Composable
fun DrawContentDemo(modifier: Modifier = Modifier.fillMaxSize()) {
    var pointerOffset by remember {
        mutableStateOf(Offset(0f, 0f))
    }
    Column(
        modifier = Modifier
            .fillMaxSize()
            .pointerInput("dragging") {
                detectDragGestures { change, dragAmount -&gt;
                    pointerOffset += dragAmount
                }
            }
            .onSizeChanged {
                pointerOffset = Offset(it.width / 2f, it.height / 2f)
            }
            .drawWithContent {
                drawContent()
                // draws a fully black area with a small keyhole at pointerOffset that’ll show part of the UI.
                drawRect(
                    Brush.radialGradient(
                        listOf(Color.Transparent, Color.Black),
                        center = pointerOffset,
                        radius = 100.dp.toPx(),
                    )
                )
            }
    ) {
        Text(
            text =
            """
                “降龙十八掌可说是【武学中的巅峰绝诣】，当真是无坚不摧、无固不破。虽招数有限，但每一招均具绝大威力。
                北宋年间，丐帮帮主萧峰以此邀斗天下英雄，极少有人能挡得他三招两式，气盖当世，群豪束手。
                当时共有“降龙廿八掌”，后经萧峰及他义弟虚竹子删繁就简，取精用宏，改为降龙十八掌，掌力更厚。
                这掌法传到洪七公手上，在华山绝顶与王重阳、黄药师等人论剑时施展出来，王重阳等尽皆称道。”
            """.trimIndent(),
            modifier = Modifier
                .padding(16.dp)
                .drawWithCache {
                    val brush = Brush.linearGradient(
                        listOf(
                            Color(0xFF9E8240),
                            Color(0xFF42A565),
                            Color(0xFFE2E575)
                        )
                    )
                    onDrawBehind {
                        drawRoundRect(
                            brush,
                            cornerRadius = CornerRadius(10.dp.toPx())
                        )
                    }
                }
                .padding(16.dp),
            style = MaterialTheme.typography.headlineMedium
        )
    }
}
</code></pre>

<p><img src="file:///Users/alexhilton/Desktop/draw_content.gif" alt="cat_eye" /></p>

<h2>背景式绘制</h2>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/draw/package-summary#(androidx.compose.ui.Modifier">Modifier.drawBehind</a>.drawBehind(kotlin.Function1))是在目标Composable内容的下面一层（更远离用户的方向）执行绘制命令，所以方便添加一些背景：</p>

<pre><code class="Kotlin">Box {
        Text(
            "降Compose十八掌!",
            modifier = Modifier
                .padding(16.dp)
                .drawBehind {
                    drawRoundRect(
                        Color(0xFFBBAAEE),
                        cornerRadius = CornerRadius(10.dp.toPx())
                    )
                }
                .padding(8.dp),
            style = MaterialTheme.typography.headlineLarge
        )
    }
</code></pre>

<p><img src="file:///Users/alexhilton/Desktop/draw_behind.png" alt="" /></p>

<h2>缓存式绘制</h2>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/draw/package-summary#(androidx.compose.ui.Modifier">Modifier.drawWithCache</a>.drawWithCache(kotlin.Function1))能够缓存在lambda内部创建的一些对象，这主要是为了提升性能的。有过View经验的同学一定知道在自定义View的时候不能在onDraw里面创建对象，因为这会影响性能。这个函数的用途也在于此，把一些对象缓存起来，避免多次创建，以提升渲染性能。</p>

<p>需要注意的是，这些缓存对象的生命周期是画面尺寸未改变，以及创建对象依赖的状态没有变化，也就是说一旦画面有改变，或者依赖的状态有变化，那么缓存失效，对象要被重新创建。</p>

<p>注意，这个函数主要用于与绘制命令强相关的，或者说仅在绘制命令范围内使用的对象，如颜色啊，画刷（Brush），着色器（Shader）啊，路径（Path）啊之类的。</p>

<pre><code class="Kotlin">Box {
        Text(
            "降Compose十八掌!",
            modifier = Modifier
                .padding(16.dp)
                .drawWithCache {
                    val brush = Brush.linearGradient(
                        listOf(
                            Color(0xFF9E82F0),
                            Color(0xFF42A5F5),
                            Color(0xFFE2E575)
                        )
                    )
                    onDrawBehind {
                        drawRoundRect(
                            brush,
                            cornerRadius = CornerRadius(10.dp.toPx())
                        )
                    }
                }
                .padding(16.dp),
            style = MaterialTheme.typography.headlineLarge
        )
    }
</code></pre>

<p><img src="file:///Users/alexhilton/Desktop/drawcache_demo.png" alt="caceh_demo" /></p>

<p>还要注意与状态（State）的区别，使用remember函数可以创建状态，这些状态的生命周期也是能跨越函数的，这也相当于是缓存。但状态的目的是让Compose感知数据变化，进面进行重组（ReComposition）。把与绘制强相关的对象放在状态里面（即用remember转成状态）并不合适。因为与绘制强相关的对象如Brush，Color和Shader等，它并不是自变量，而是因变量，这些对象依赖其底层的数据变化而需要重新创建。所以，最恰当的方式是，是把自变量如底层的颜色数值，或者图片放到状态里面，而Brush和Shader放在drawWithCache里面。</p>

<h2>图形变幻</h2>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/package-summary#(androidx.compose.ui.Modifier.graphicsLayer(kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,androidx.compose.ui.graphics.TransformOrigin,androidx.compose.ui.graphics.Shape,kotlin.Boolean,androidx.compose.ui.graphics.RenderEffect,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.CompositingStrategy">Modifier.graphicsLayer</a>))是一个图形的扩展函数，它能够把目标Composable的内容绘制到一个图层（layer）上面，然后提供了一些针对图层进行操作的函数，进而能实现一些变幻。这相当于是把绘制指令做了隔离，先把绘制结果放到一个图层上面，除了变幻，图层还能做很多事情：</p>

<ul>
<li>做类似于<a href="https://developer.android.com/reference/android/graphics/RenderNode">RenderNode</a>那样的渲染管线化（render pipeline），把图层用作管理线中的一个节点，而不用每次都重新绘制。</li>
<li>光栅化（Rasterization），图层可以光栅化，甚至离屏渲染（offscreen drawing），这可以优化动画的帧率和流畅度。</li>
</ul>


<p>不过，最主要的仍是做变幻，进而实现动画（Animation）。但要注意，图形变幻，仅是针对绘制过程做的变幻，并不影响Composable的真实的属性。</p>

<p>graphicsLayer也是一个扩展函数，它的lambda参数是GraphicsLayerScope的一个扩展函数，所以lambda中有指向GraphicsLayerScope的隐式指针。变幻，只需要指定一些参数的值即可，通过一些例子，一看就能懂。</p>

<h3>缩放/位移/旋转/透明度</h3>

<p>通过在graphicsLayer的lambda中指定相应的参数即可以实现这些变幻。对于旋转和缩放，还可以指定中心点（Origin），特别注意旋转，它是三维的有x，y，z三个参数，通过一个例子来感受这些变幻效果：</p>

<pre><code class="Kotlin">    Box(
        modifier = Modifier
            .graphicsLayer {
                scaleX = 1.1f
                scaleY = 1.6f
                translationX = 30.dp.toPx()
                translationY = 50.dp.toPx()
                alpha = 0.7f
                rotationX = 10f
                rotationY = 5f
            }
    ) {
        Text(
            "降Compose十八掌!",
            modifier = Modifier
                .padding(16.dp)
                .drawWithCache {
                    val brush = Brush.linearGradient(
                        listOf(
                            Color(0xFF9E82F0),
                            Color(0xFF42A5F5),
                            Color(0xFFE2E575)
                        )
                    )
                    onDrawBehind {
                        drawRoundRect(
                            brush,
                            cornerRadius = CornerRadius(10.dp.toPx())
                        )
                    }
                }
                .padding(16.dp),
            style = MaterialTheme.typography.headlineLarge
        )
    }
</code></pre>

<p><img src="file:///Users/alexhilton/Desktop/graphics_layer_transform.png" alt="transformation" /></p>

<h3>剪辑与形状</h3>

<p>剪辑（clip）是把绘制好的图层进行裁剪，裁剪的效果由形状（shape）来指定。这里可以尽情的发挥想像力，做出非常炫酷的视觉效果。</p>

<pre><code class="Kotlin">       Box(
            modifier = Modifier
                .size(200.dp)
                .graphicsLayer {
                    clip = true
                    shape = CircleShape
                }
                .background(Color(0xFFF06292))
        ) {
            Text(
                "降Compose十八掌",
                style = TextStyle(color = Color.Black, fontSize = 36.sp),
                modifier = Modifier.align(Alignment.Center)
            )
        }
</code></pre>

<p><img src="file:///Users/alexhilton/Desktop/clip_shape.png" alt="clip_shape" /></p>

<h3>图层的变幻仅对绘制生效</h3>

<p>需要注意的是，对图层做的变幻仅是对渲染结果生效，它并不影响Composable本身的属性（如大小和位置）。比如说，通过剪辑和位移，图层可能会超出Composable本身的区域，也就是说在View树中，这个元素的位置和大小还是原来的样子。</p>

<p>通过Modifier中其他的函数能对Composable本身进行剪辑这才会真正影响它自身的大小，超出边界的内容会被裁剪掉：</p>

<pre><code class="Kotlin">    Column(modifier = Modifier.fillMaxSize().padding(16.dp)) {
        Box(
            modifier = Modifier
                .size(200.dp)
                .clip(RectangleShape)
                .border(2.dp, Color.Black)
                .graphicsLayer {
                    clip = true
                    shape = CircleShape
                    translationX = 50.dp.toPx()
                    translationY = 50.dp.toPx()
                }
                .background(Color(0xFFF06292))
        ) {
            Text(
                "降Compose十八掌",
                style = TextStyle(color = Color.Black, fontSize = 36.sp),
                modifier = Modifier.align(Alignment.Center)
            )
        }

        Box(
            modifier = Modifier
                .size(200.dp)
                .background(Color(0xFF4DB6AC))
        )
    }
</code></pre>

<p><img src="file:///Users/alexhilton/Desktop/clip_modifier.png" alt="clip_modifier" /></p>

<h2>创建Composable的快照</h2>

<p>就像截屏一样，可以给Composable拍照，即把Composable的绘制结果转成一个Bitmap，进而可以保存成图片文件，或者分享到其他应用。主要是通过graphicsLayer的record函数：</p>

<pre><code class="Kotlin">val coroutineScope = rememberCoroutineScope()
val graphicsLayer = rememberGraphicsLayer()
Box(
    modifier = Modifier
        .drawWithContent {
            // 用record函数来录制图层
            graphicsLayer.record {
                // 把内容绘制到图层上面
                this@drawWithContent.drawContent()
            }
            // 把图层再绘制到画布上面，以让内容能正常显示
            drawLayer(graphicsLayer)
        }
        .clickable {
            coroutineScope.launch {
                val bitmap = graphicsLayer.toImageBitmap()
                // 快照Bitmap已准备好了，可以使用此Bitmap了
            }
        }
        .background(Color.White)
) {
    Text("Hello Android", fontSize = 26.sp)
}
</code></pre>

<blockquote><p>注意：函数rememberGraphicsLayer只在compose的1.7.0-alpha07以后的版本才支持，在稳定版本中是不支持的。以BOM方式指定的依赖都是稳定版。可以单独给compose-ui:ui指定版本，如implementation(&ldquo;androidx.compose.ui:ui:1.7.0-beta03&rdquo;)</p></blockquote>

<p><img src="file:///Users/alexhilton/Desktop/graphics_to_bitmap.png" alt="bitmap_share" /></p>

<h2>如何选择恰当的方式</h2>

<p>自定义绘制有两种，一种纯的自已绘制内容，类似于直接继承View，在onDraw中绘制自己想要的效果；另外一种就是基于现有的部件进行改进和增强，类似于子例化TextView或者子例化ImageView，基于原View的内容，再进行变幻，改进或者增强。</p>

<p>视具体的问题而定，如果是第一种，就用Canvas函数，否则的话就用上面讲的Modifier的扩展函数。</p>

<p>其实如果仔细看API的实现，就可以发现Canvas函数其实是Modifier.drawBehind的一层包装：</p>

<pre><code class="Kotlin">@Composable
fun Canvas(modifier: Modifier, onDraw: DrawScope.() -&gt; Unit) =
    Spacer(modifier.drawBehind(onDraw))
</code></pre>

<p>因为Spacer是一个空白的占位符，本身的内容就是空的（只有大小，没有内容），所以整体效果就相当于是一个纯的自定义绘制内容了。</p>

<p>不过本质上都是使用DrawScope对象来进行具体的绘制，上面提到的Modifier的扩展函数也都是对DrawScope的封装。Modifier的强大之处在于它可以应用于所有其他的Composables，可以让开发者非常方便的对现有的Composables进行扩展和增强。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/graphics/draw/modifiers">Graphics modifiers</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『利涉大川』| Canvas]]></title>
    <link href="http://toughcoder.net/blog/2024/06/24/canvas-in-compose/"/>
    <updated>2024-06-24T20:22:49+08:00</updated>
    <id>http://toughcoder.net/blog/2024/06/24/canvas-in-compose</id>
    <content type="html"><![CDATA[<p>任何一个GUI框架都会提供大量的预定义的UI部件，让开发者构建UI页面，但有些时候预定义的部件无法满足需求，这时就需要定制，甚至是自定义绘制的内容。对于Android开发者来说，这已经是家常便饭了，因为肯定有过用自定义View来实现一些特殊设计需求的经验。在Jetpack Compose中也有同样的方法来实现自定义绘制内容，今天就来学习一下。</p>

<p><a href=""><img src="https://apptractor.ru/wp-content/uploads/2021/03/1_r_ly2xx-jo8vixat0xh7qa.png" title="auto auto" ></a></p>

<!-- more -->


<h2>使用Canvas来自定义内容</h2>

<p>在Compose中， 我们用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/package-summary#Canvas(android.graphics.Canvas">Canvas函数</a>)来绘制自定义内容，可以把它理解成为自定义View，但，它是一个函数，把绘制指令传给它就可以了：</p>

<pre><code class="Kotlin">    val textMeasurer = rememberTextMeasurer()

    Canvas(modifier = Modifier.fillMaxSize()) {
        drawRect(Color.LightGray)

        drawText(
            textMeasurer = textMeasurer,
            text = "降Compose十八掌",
            topLeft = Offset(size.width / 4f, size.height / 2.2f)
        )

        drawCircle(
            color = Color.Magenta,
            radius = size.width / 10f,
            center = Offset(size.width / 1.8f, size.height / 3f)
        )
        drawCircle(
            color = Color.Yellow,
            radius = size.width / 12f,
            center = Offset(size.width / 1.6f, size.height / 4.5f)
        )
        drawCircle(
            color = Color.Green,
            radius = size.width / 14f,
            center = Offset(size.width / 1.46f, size.height / 7f)
        )
    }
</code></pre>

<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f7c77abcb2b34e0683201294f4926082~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1220&amp;h=1436&amp;s=75585&amp;e=png&amp;b=cccccc" alt="hello_canvas" /></p>

<h2>坐标系统</h2>

<p>坐标系统，与常见的GUI坐标系统，以及View的坐标系统都是一样的，左上角是原点（0，0），x轴向右，y轴向下。</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/graphics/introduction/compose_coordinate_system_drawing.png" alt="" /></p>

<h2>绘图上下文DrawScope</h2>

<p>仔细看Canvas函数，可以发现，写绘制指令的地方是一个尾部lambda，这是Compose中非常常见的一种设计方式。这个lambda被定义为DrawScope对象的一个扩展函数，所以在这个lambda中可以隐式的访问DrawScope对象。我们所使用的绘制指令，以及很多参数其实都是在通过this指针隐式的调用DrawScope。对于扩展函数不熟悉的同学可以去复习一下<a href="https://juejin.cn/post/7327478228188594202">Kotlin中函数的一些高级用法</a>。</p>

<p>通过AndroidStudio的提示，也能看到隐式的this指针是一个DrawScope对象。</p>

<p>所以呢，当查找API文档时记得要去找<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/drawscope/DrawScope">DrawScope</a>，而不是Canvas函数。其实Canvas就是一个封装的函数，也没啥东西。但还有一个略微底层一些的作为Graphics接口的<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/Canvas">对象Canvas</a>，它与Android SDK中的Canvas对象是差不多的概念。</p>

<p>接下来我们重点看看如何使用绘制指令绘制出我们需要的内容。</p>

<h2>画图形</h2>

<p>图形（Shape）是最为常见的一类绘制目标，比如圆，椭圆，矩形，线，扇形等等。不难，看一眼就会用：</p>

<pre><code class="Kotlin">    Canvas(modifier = Modifier.fillMaxSize()) {
        drawRect(Color.LightGray)

        drawOval(
            color = Color.Green,
            topLeft = Offset(50f, 50f),
            size=  Size(size.width / 10f, size.height / 12f)
        )

        drawLine(
            color = Color.Yellow,
            start = Offset(50 + size.width / 20f, 50f + size.height / 24f),
            end = Offset(size.width / 1.8f, size.height / 3f),
            strokeWidth = Stroke.DefaultMiter
        )

        drawCircle(
            color = Color.Magenta,
            radius = size.width / 5f,
            center = Offset(size.width / 1.8f, size.height / 3f)
        )

        drawPoints(
            color = Color.DarkGray,
            pointMode = PointMode.Points,
            strokeWidth = 50f,
            points = genPoints(size.width / 2f, size.height / 3f)
        )
    }
</code></pre>

<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6b042b2c41f4899aeb3245baa99f591~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1219&amp;h=1447&amp;s=77422&amp;e=png&amp;b=cccccc" alt="shapes" /></p>

<h2>画路径</h2>

<p>路径（Path）是把一系列的数学指令转化为绘制命令，可以更为灵活的画一些曲线和图形，比如说画一个三角函数曲线：</p>

<pre><code class="Kotlin">@Composable
fun PathDemo() {
    val tm = rememberTextMeasurer()

    Canvas(modifier = Modifier.fillMaxSize()) {
        drawRect(Color.LightGray)

        drawText(tm, "cosine of [-PI, PI]", Offset(size.width / 3f, 60f))

        drawLine(
            color = Color.DarkGray,
            start = Offset(0f, size.height / 2f),
            end = Offset(size.width, size.height / 2f),
            strokeWidth = 3f
        )

        drawLine(
            color = Color.DarkGray,
            start = Offset(size.width / 2f, size.height / 3f),
            end = Offset(size.width / 2f, size.height * 2/ 3f),
            strokeWidth = 3f
        )

        drawPath(genPath(size.width, size.height), Color.Magenta, style = Stroke(width = 10f))
    }
}

fun genPath(width: Float, height: Float): Path {
    val slices = 60
    val path = Path();
    path.moveTo(0f, height / 3f)
    for (i in 1..slices) {
        val x0 = 2f * i.toFloat() * PI.toFloat() /  slices.toFloat() - PI.toFloat()
        val y0 = cos(x0) * height / 6f
        val x = i.toFloat() / slices.toFloat() * width
        val y = y0 + height / 2f
        path.lineTo(x, y)
        path.moveTo(x, y)
    }
    path.close()
    return path;
}
</code></pre>

<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd5a91eab8a34a8fae51874ec21d989d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1217&amp;h=1994&amp;s=104973&amp;e=png&amp;b=cccccc" alt="path" />
路径在绘制中是非常强大的功能，可以实现非常炫酷的动画效果。</p>

<h2>画文字</h2>

<p>文字是特别重要的UI元素，通常情况下我们都是过Text来展示文字，再与其他部件进行组合就能满足需求。一般来说不需要在自定义内容也使用文字，因为文字绘制一般来说比较复杂，因为像基线对齐，字体样式，字体大小等等，都需要考虑。文字部件Text内容其实也是用与自定义一样的更低层的API来实现的，但它把像对齐，样式，富文本等等都封装好了。</p>

<p>DrawScope也提供了绘制文字的函数，不过呢使用起来比较麻烦，需要详细计算文字所占用的区域大小，而文字的measure通常是非常麻烦的，因为像文字的字体以及文字大小都会影响到measure，因此measure要保存成为一个状态，这样当有影响到文字绘制的因素发生变化时，measure就会发生变化，进而触发Re-Composition：</p>

<pre><code class="Kotlin">@Composable
fun TextDemo() {
    val textMeasure = rememberTextMeasurer()

    Canvas(modifier = Modifier.fillMaxSize()) {
        val measuredText =
            textMeasure.measure(
                AnnotatedString(
                    text =
                    """
                        “降龙十八掌可说是【武学中的巅峰绝诣】，当真是无坚不摧、无固不破。虽招数有限，但每一招均具绝大威力。
                        北宋年间，丐帮帮主萧峰以此邀斗天下英雄，极少有人能挡得他三招两式，气盖当世，群豪束手。
                        当时共有“降龙廿八掌”，后经萧峰及他义弟虚竹子删繁就简，取精用宏，改为降龙十八掌，掌力更厚。
                        这掌法传到洪七公手上，在华山绝顶与王重阳、黄药师等人论剑时施展出来，王重阳等尽皆称道。”
                    """.trimIndent(),
                    spanStyle = SpanStyle(
                        fontSize = 20.sp,
                        fontWeight = FontWeight.ExtraBold,
                        brush = Brush.verticalGradient(listOf(Color.Magenta, Color.Cyan, Color.Blue))
                    )
                ),
                constraints = Constraints.fixed(
                    width = (size.width / 1.6f).toInt(),
                    height = (size.height / 2f).toInt()
                ),
                overflow = TextOverflow.Ellipsis,
                style = TextStyle(fontSize = 18.sp)
            )

        drawText(
            textLayoutResult = measuredText,
            topLeft = Offset(60f, 60f)
        )
    }
}
</code></pre>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2aaf95cc9fff45dc9c963065098b0faa~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1220&amp;h=1774&amp;s=275925&amp;e=png&amp;b=fefbff" alt="text" /></p>

<h2>画图片</h2>

<p>图片（Image）是与文字类似的非常重要的UI元素，像图标，头像，表情，背景图，Banner图，以及内容中的图像都属于图片元素，一般情况下用Image函数可以用来展示图片。</p>

<p>对于自定义绘制内容也可以使用图片，DrawScope中有提供绘制图片的方法：</p>

<pre><code class="Kotlin">val dogImage = ImageBitmap.imageResource(id = R.drawable.dog)
Canvas(modifier = Modifier.fillMaxSize(), onDraw = {
    drawImage(dogImage)
})
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_image.png" alt="" /></p>

<h2>变幻</h2>

<p>除了绘制以外，DrawScope还提供了一系列做变幻的函数。包括缩放，位移，旋转这些变幻直接作用于绘制指令上面。</p>

<h3>缩放</h3>

<p>使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/drawscope/DrawScope#(androidx.compose.ui.graphics.drawscope.DrawScope">DrawScope.scale</a>.scale(kotlin.Float,kotlin.Float,androidx.compose.ui.geometry.Offset,kotlin.Function1))函数来对绘制指令进行缩放，参数是x轴方向和y轴方向的缩放倍数（大于1放大，小于1缩小），还可以指定中心坐标，默认是几何中心。</p>

<pre><code class="Kotlin">Canvas(modifier = Modifier.fillMaxSize()) {
    scale(scaleX = 10f, scaleY = 15f) {
        drawCircle(Color.Blue, radius = 20.dp.toPx())
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_scale.png" alt="" /></p>

<h3>位移</h3>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/drawscope/DrawScope#(androidx.compose.ui.graphics.drawscope.DrawScope">DrawScope.translate</a>.translate(kotlin.Float,kotlin.Float,kotlin.Function1))可以实现位移，参数是x方向或者y方向的距离。参数为正，是沿着坐标轴正向，为负就是反向。</p>

<pre><code class="Kotlin">Canvas(modifier = Modifier.fillMaxSize()) {
    translate(left = 100f, top = -300f) {
        drawCircle(Color.Blue, radius = 200.dp.toPx())
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_translate.png" alt="" /></p>

<h3>旋转</h3>

<p>用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/drawscope/DrawScope#(androidx.compose.ui.graphics.drawscope.DrawScope">DrawScope.rotate</a>.rotate(kotlin.Float,androidx.compose.ui.geometry.Offset,kotlin.Function1))函数实现旋转，参数为正时是顺时针的角度，为负就是逆时针，可以指定中心点，默认是几何中心。</p>

<pre><code class="Kotlin">Canvas(modifier = Modifier.fillMaxSize()) {
    rotate(degrees = 45F) {
        drawRect(
            color = Color.Gray,
            topLeft = Offset(x = size.width / 3F, y = size.height / 3F),
            size = size / 3F
        )
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_rotate.png" alt="" /></p>

<h3>画布尺寸调整</h3>

<p>用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/drawscope/package-summary#(androidx.compose.ui.graphics.drawscope.DrawScope">DrawScope.inset</a>.inset(kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Function1))函数来对DrawScope的画布进行调整，参数是周围四个方向的边距偏移量。</p>

<pre><code class="Kotlin">Canvas(modifier = Modifier.fillMaxSize()) {
    val canvasQuadrantSize = size / 2F
    inset(horizontal = 50f, vertical = 30f) {
        drawRect(color = Color.Green, size = canvasQuadrantSize)
    }
}
</code></pre>

<p>这样调整后，inset内部的lambda中的绘制指令的尺寸size会受影响，size.width = width - 2 * horizontal，size.height = height - 2 * vertical，相当于是加了padding。</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/graphics/introduction/compose_graphics_canvas_inset.png" alt="" /></p>

<h3>组合变幻</h3>

<p>变幻除了可以单独使用，还可以组合起来使用，能更简便的实现变幻效果。使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/drawscope/package-summary#(androidx.compose.ui.graphics.drawscope.DrawScope">DrawScope.withTransform</a>.withTransform(kotlin.Function1,kotlin.Function1))来组合变幻：</p>

<pre><code class="Kotlin">Canvas(modifier = Modifier.fillMaxSize()) {
    withTransform({
        translate(left = size.width / 5F)
        rotate(degrees = 45F)
    }) {
        drawRect(
            color = Color.Gray,
            topLeft = Offset(x = size.width / 3F, y = size.height / 3F),
            size = size / 3F
        )
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/graphics/introduction/compose_graphics_multiple_transforms.png" alt="" /></p>

<h2>总结</h2>

<p>今天主要学习了如何通过Canvas函数来实现自定义绘制内容，Canvas给我们了封装了一个包含有DrawScope的lambda，通过DrawScope提供的各种绘制指令可以实现我们的想要的自定义内容。可以自由的通过绘制图形，文字和图像，并且可以做变幻，以实现一些特效。相信通过今天的学习，足可以应付常见的自定义绘制需求。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/graphics/draw/overview">Graphics in Compose</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『潜龙勿用』| Thinking in Compose]]></title>
    <link href="http://toughcoder.net/blog/2024/06/15/thinking-in-compose/"/>
    <updated>2024-06-15T20:12:15+08:00</updated>
    <id>http://toughcoder.net/blog/2024/06/15/thinking-in-compose</id>
    <content type="html"><![CDATA[<p>Jetpack Compose是Android平台的现代化的声明式UI框架。它提供了一套声明式API，可以不必再机械式的操作View就能构建 出UI，从而更容易的构建出应用的UI，并且易于维护，易于扩展。今天我们重点理解一下Jetpack Compose背后的思想，学会以声明式思维来思考，进而写出更加专业的声明式UI代码。</p>

<p><a href=""><img src="https://anahisalgado.com/wp-content/uploads/2022/05/jetpack-compose-anncode-anahi-salgado.png" title="auto auto" ></a></p>

<!-- more -->


<h2>从过程式UI到声明式UI</h2>

<p>通过前面的学习，我们已经知道声明式UI的特点了，它是一坨一坨的函数。状态（要显示给用户的数据）作为参数，再写出使用这些状态的函数，然后Compose会运行这些函数最终生成UI。不必关心函数具体的执行，以及执行的结果，我们只需要描述好需要显示什么就可以了，简言之就是定义好如何使用数据的函数即可。这就是声明式UI的核心思想，它让开发者把精力放在你想要展示什么，而非繁杂的如何展示。</p>

<p><img src="https://s3-eu-west-2.amazonaws.com/wolfpack-digital-attachments-production/ckeditor_assets/pictures/374/content_Building_apps_with_declarative_UI_5.png" alt="" /></p>

<p>实际上这是函数式编程范式的一种，时刻记着我们都是在定义函数就可以了。</p>

<h2>Compose的工作原理</h2>

<p>传统的过程式UI（比如Android中的View和XML）是基于OO（面向对象）的，每个元素都是一个对象，它有一些属性，要构建出一颗View tree，然后当有事件变化或者有数据更新时，我们会具体的刷新具体的View。但像声明式UI，比如Compose，工作方式并不是这样的，开发者写出的并不是View tree，而是一系列描述着要展示数据的函数，其余的事情都是Comose负责。</p>

<p>Compose会执行这些函数，收集它们的结果，生成一颗<a href="https://www.geeksforgeeks.org/difference-between-virtual-dom-and-real-dom/">虚拟的View tree</a>，这一步要叫做Compositon；然后再把虚拟的View tree，生成真实的与平台相关的View tree，这一步叫做渲染。当有状态变化的时候，代表数据有更新，需要刷新UI，这时Compose会重新执行一遍函数，这就叫做重组Recomposition。因为重组会发生很多次，如果每次重组都直接去更新目标平台View tree开销太大了，因此就有了虚拟View tree这一层，每次重新会重新生成一颗虚拟View tree，然后比较两颗虚拟View tree，只当差异时，再用差异去更新目标平台的View tree。</p>

<p>有同学举手了，说这费二遍事，性能肯定会变得更差吧？这位同学先坐下。确实多费了一道工序，但随着CPU性能越来越高，以及像<a href="https://www.infoq.cn/article/react-dom-diff">virtual dom diff技术</a>的应用，Compose本身性能的差异已经追上传统方式了。但它的优势，比如开发效率以及可扩展性却无限放大，总的来说收益还是很大的。</p>

<p>说到底这是函数式编程方式，那么就会有函数式编程的特点，比如说这些函数的执行顺序不一定就是开发者写的那样，再比如说这些函数可能会并行的执行，甚至有些函数会被跳过。并且呢，重组可能随时发生，而且发生的很频繁。Compose这样做是为了保证底层UI能够及时得到刷新。</p>

<p>那么，在使用Compose时，就有一些注意事项，比如尽可能的使用Stateless的函数，尽可能的减少副作用。以及千万不要依赖函数的执行顺序。</p>

<h2>拆分为细粒度的函数，加强复用</h2>

<p>Compose是以函数来搭建UI，这相比于xml方式的一个最大的好处就是这非常方便的复用，因为可以像重构代码那样，把重复的代码抽成可复用函数。要以「自上而下」函数调用的方式来构建UI。</p>

<p>推荐的方式是，先把整个页面划分为不同的区域，每个区域是一个函数（Composable）；再把每个区域细分成为更为细节的函数；这些细节函数如果是共性的就复用。这样做的方式，不但能够做到代码结构清晰，可读性很强，且易于维护，方便扩展。非常容易找到与UI的对应，而且容易复用，如果有新的页面，把不同的细节函数组合起来就可以了。</p>

<p>其实以前用XML也应该这样，但毕竟XML不像代码这样方便的管理和复用，拆成过多的XML文件不但难以管理，也会影响编译速度。</p>

<p>可以做一下<a href="https://developer.android.com/codelabs/jetpack-compose-layouts#0">Basic layouts in Compose</a>，这个CodeLab非常好的演示了如何「自顶而下」的用Compose来构建UI。</p>

<h2>Preview局部而非整体</h2>

<p>Compose的一个强大功能就是即时Preview，不必非要到设备上运行就可以看到UI效果。不过呢Preview需要数据，而且要是静态的数据，也就是需要Mock。这对于复杂的数据来说是致命的缺点。比如说像字段非常之多的列表，或者有很多特殊字段的对象，Mock起来相当的麻烦。</p>

<p>一个可行的办法就是要尽可能的Preview局部，数据复杂，必然对应着复杂的页面，把复杂的页面拆开，变成一系列的简单的Composable的组合，这时每个Composable对应的数据都是相对简单的，只有几个参数，这时就是可Preview的了，Mock起来就容易得多了。</p>

<p>具体的来说，对于像集合性UI，我们只需要预览它的一个单元项就可以了，只要一个单元项没啥问题，组合起来看集合地无非就是重复很多个；再比如对于复杂的多字段对象，划分成为几个不同的子区域，每个子区域对应一个函数，这个函数经过Preview后没啥问题，那把这些组合起来成为一个整体后也不会有太大的问题。</p>

<p>Preview的作用是快速预览，减少编译运行的次数，毕竟编译运行一次要慢得多，所以要以简单快捷方便为主。而并不是真的当成运行结果，最终肯定要以在手机上运行结果为准，并进行最终的调试。</p>

<h2>总结</h2>

<p>对于习惯了View和XML方式的同学来说，开始用Compose肯定会略有不习惯，就需要理解一下它的原理，转变成声明式UI的思维，以函数为核心来思考问题，这样才能写出比较专业的Compose代码。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/mental-model">Thinking in Compose</a></li>
<li><a href="https://proandroiddev.com/why-we-adopted-jetpack-compose-b66bfd3dbde5">Why We Adopted Jetpack Compose</a></li>
<li><a href="https://medium.com/israeli-tech-radar/declarative-ui-what-how-and-why-13e092a7516f">Declarative UI — What, How, and Why?</a></li>
<li><a href="https://www.rootstrap.com/blog/imperative-v-declarative-ui-design-is-declarative-programming-the-future">Imperative v Declarative UI Design - Is Declarative Programming the future?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『鸿渐于陆』| State]]></title>
    <link href="http://toughcoder.net/blog/2024/06/04/jetpack-compose-state/"/>
    <updated>2024-06-04T21:05:02+08:00</updated>
    <id>http://toughcoder.net/blog/2024/06/04/jetpack-compose-state</id>
    <content type="html"><![CDATA[<p>Jetpack Compose是一种声明式的UI框架，用以构建GUI应用程序。通过前面的文章我们学会了<a href="https://juejin.cn/post/7371239685702844454">如何使用元素来填充页面</a>，也学会了<a href="https://juejin.cn/post/7373867360020480038">如何装饰元素</a>，但这还不够。UI还必须处理与页面直接相关的数据，因为这是对用户有价值的东西。今天就来学习一下Compose如何处理数据。</p>

<p><a href=""><img src="https://alexzh.com/content/images/size/w2000/2021/02/logo-1.65-1980-4.png" title="auto auto" ></a></p>

<!-- more -->


<h2>什么是状态</h2>

<p>状态（State）其实就是数据，Compose是一种UI框架，UI要显示数据才会有价值。但是呢，Compose毕竟是一种UI框架，它应该只处理需要展示给用户的那部分数据，所以，这里说的数据应该是经过业务逻辑处理过的，需要展示给用户的那部分数据。也就是说只需要处理从ViewModel推送过来的数据即可。</p>

<p>此外，还有一部分只需要在UI内部处理的数据，比如像一些控件的状态，动画中的参数变化等等，这些数据需要完全在UI部分处理掉，都不应该暴露给ViewModel。</p>

<p>因此，对于Compose来说的状态（State），就包括两部分，一部分是从ViewModel推过来的需要展示的数据（具体叫做UiState），以及UI内部逻辑中的状态。</p>

<h2>状态与重组</h2>

<p>本质上来说Compose就是坨函数，更新UI的方式就变成了用新的参数来重新调用这些函数。这些参数便是状态了。任何时候状态发生变化就会发生重组（re-Composition），结果就是UI刷新了，最新的数据呈现给了用户。感知状态变化如何影响着UI的刷新就是状态管理。</p>

<p>有些术语需要说明一下：组合（Composition）描述着UI的生成过程，也即当Compose执行我们所声明的一坨坨函数的时候；初始组合（Initial Composition）首次执行这一坨函数的过程；重组（re-Composition）当状态有更新，重新运行某些函数的过程。</p>

<p>UI要想刷新，呈现最新的数据，这就需要Compose进行重组，而重组是由状态更新触发的，也就是说我们需要用新的数据来重新执行这一坨函数。对于业务逻辑数据，这很好办，可以通过ViewModel推送新的数据，然后重新调用UI函数即可。但这并没有看起来那么容易，因为ViewModel与UI的关系通常不是ViewModel直接持有着UI的对象或者函数，更多的时候是Compose的函数（Composable）中创建持有ViewModel对象，一个函数是没有办法直接调用自身的，这会陷入死循环的（StackOverFlow）。</p>

<pre><code class="Kotlin">@Composable
fun WellnessScreen(
    modifier: Modifier = Modifier,
    wellnessViewModel: WellnessViewModel = viewModel()
) {
    Column(modifier = modifier) {

        WellnessTasksList(
            list = wellnessViewModel.tasks,
            onCheckedTask = { },
            onCloseTask = { }
        )
    }
}
</code></pre>

<p>对于UI逻辑中的数据也是如此，比如说，一个很简单的按扭计数，按照常规的理解，似乎可以这样写：</p>

<pre><code class="Kotlin">@Composable
fun WaterCounter(modifier: Modifier = Modifier) {
    var count = 0

    Column(modifier = modifier.padding(16.dp)) {
        Text(
            text = "You have had $count glasses.",
            modifier = modifier.padding(16.dp)
        )
        Row(
            modifier = modifier.padding(top = 8.dp),
            horizontalArrangement = Arrangement.SpaceEvenly,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Button(onClick = { count++ }, enabled = count &lt; 10) {
                Text("Add one")
            }
            Button(onClick = { count = 0 }, Modifier.padding(start = 8.dp), enabled = count &gt; 0) {
                Text("Clear water count")
            }
        }
    }
}
</code></pre>

<p>但这样写文本中的数字不会变化。</p>

<p>重组要想发生，就必须重新调用Compose的『根函数』，这就需要用到专门的数据结构<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/MutableState">MutableState</a>，Compose会识别并跟踪这些State，当其变化时，会触发重组，并使用State中的最新值。</p>

<pre><code class="Kotlin">interface MutableState&lt;T&gt; : State&lt;T&gt; {
    override var value: T
}
</code></pre>

<h2>管理UI状态</h2>

<p>要想让Compose识别到数据变化，就需要使用状态State，这样当数据变化时会触发重组，Compose会用State中的最新数值来重新运行函数，以刷新UI。比如上面的计数的例子，可以这样修改：</p>

<pre><code class="Kotlin">@Composable
fun WaterCounter(modifier: Modifier = Modifier) {
    var count by remember { mutableStateOf(0) }
    // Other codes not changed
}
</code></pre>

<p>这次，能得到期望的行为：</p>

<p><img src="https://pic2.zhimg.com/v2-d26bd68593ea22ef777f42f83aee37f5_b.webp" alt="state demo" /></p>

<p>有三种方式声明一个状态MutableState：</p>

<ul>
<li>val state = remember { mutableStateOf(default) }</li>
<li>var value by remember { mutableStateOf(default) }</li>
<li>val (vale, setValue) = remember { mutableStateOf(default) }</li>
</ul>


<p>基本上无差别，一般委托方式用的稍多一些。这里<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#remember(kotlin.Function0">remember</a>)的作用是让Compose记住并追踪状态的变化。如果想要让状态能够跨Activity的实例（比如遇到屏幕旋转，语言变化等配置变化导致Activity重启）就需要用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/saveable/package-summary#rememberSaveable(kotlin.Array,androidx.compose.runtime.saveable.Saver,kotlin.String,kotlin.Function0">remeberSaveable</a>)。</p>

<p>这些主要是针对Composable中内部的状态。对于像从ViewModel过来的业务数据，一般都用<a href="https://developer.android.com/reference/kotlin/androidx/lifecycle/compose/package-summary#(androidx.lifecycle.Lifecycle">collectAsState</a>.currentStateAsState())系列方法。</p>

<h2>有状态（Stateful）和无状态（Stateless）</h2>

<p>对于包含了创建State的函数就称作有状态的Composable，而不包含创建状态就是Stateless的。</p>

<p>无状态的Composable是幂等的，调用时直接传入数据，不会产生副作用，也不会触发重组，显然这对开发者来说是最高效的，因为很纯粹，使用起来相当简单，并且完全可复用，<strong>应该尽可能的创建并使用无状态Composables</strong>：</p>

<pre><code class="Kotlin">@Composable
fun CustomButton(text: String, onClick: ()-&gt;Unit) {
     Button(onClick) {
         Text(text)
     }
}
</code></pre>

<h2>状态提升</h2>

<p>因为State是有额外的成本的，因此应该尽可能的减少State的创建，那么就要尽可能的复用State。这就需要把状态提升到使用此State的所有子函数的最小公共函数里面。比如前面的例子，状态count在Text和两个Button中都有使用，那么count至少要提升到它们的公共函数里面。假如，这个count在其他Composable中也有使用，那么就提升到WaterCounter的更上一层，甚至是整个Screen级别。</p>

<p>一般情况下，除了一些仅在局部使用的状态外，放在页面级别的根函数里面是比较好的选择，这样的话只有页面的根函数是Stateful的，其余函数都是Stateless的。</p>

<h2>实战</h2>

<p>纸上来行终觉浅，要想掌握还是要亲手撸。状态管理对于UI框架是相当重要的，因为这是UI发挥作用和产生价值的地方。对于状态管理有一些非常好的CodeLab，可以亲手撸一下，感受一下状态管理到底是啥。</p>

<ul>
<li><a href="https://developer.android.com/codelabs/jetpack-compose-state#0">State in Jetpack Compose</a></li>
</ul>


<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/state">State and Jetpack Compose</a></li>
<li><a href="https://decode.agency/article/jetpack-compose-state/">How to handle state in Jetpack Compose</a></li>
<li><a href="https://www.composables.com/tutorials/state">Everything you need to know about State in Jetpack Compose with examples</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『见龙在田』| Modifier]]></title>
    <link href="http://toughcoder.net/blog/2024/05/30/modifier-made-easy/"/>
    <updated>2024-05-30T20:51:52+08:00</updated>
    <id>http://toughcoder.net/blog/2024/05/30/modifier-made-easy</id>
    <content type="html"><![CDATA[<p>通过<a href="https://juejin.cn/post/7371239685702844454">前面的文章</a>我们学会了如何使用元素来构建和填充我们的UI页面，但这只完成了一半，元素还需要装饰，以及进行动画和事件响应，这才能生成完整的UI。这就要用到Modifier，Jetpack Compose中的灵魂，它被用来装饰和增强Composables，让一个个平凡的元素变成鲜活的，好看的，可交互UI。我们来具体的看一下Modifier的使用方法。</p>

<p><a href=""><img src="https://static.wixstatic.com/media/0d004d_2c19a3d66d7c4007a2f08ce17be24959~mv2.jpg/v1/fill/w_1000,h_500,al_c,q_85,usm_0.66_1.00_0.01/0d004d_2c19a3d66d7c4007a2f08ce17be24959~mv2.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>对于Compose来说，每一个元素叫做Composable，它是一个函数，比如前面学过的布局（如Row）和小部件（如Text）等都是一个Composable，可以把它理解成为一个元素。</p>

<h2>概念和基本使用方法</h2>

<p>Modifier之于元素，犹如CSS之于HTML，但能做的更多，因为除了样式装饰以外，Modifier还能做很多事情，比如响应用户输入。</p>

<p>每一个Composable都可以接收一个Modifier参数，准确地说第一个参数都是Modifier，可以把一个Modifier对象作为第一个参数传给元素；也可以用命名参数如modifier = Modifier.padding(8.dp)。Modifier支持链式调用，它的每个方法都会把当前对象返回：</p>

<pre><code class="Kotlin">@Composable
private fun Greeting(name: String) {
    Column(
        modifier = Modifier
            .padding(24.dp)
            .fillMaxWidth()
    ) {
        Text(text = "Hello,")
        Text(text = name)
    }
}
</code></pre>

<h2>装饰元素的样式</h2>

<p>重点来看一下如何用Modifier装饰元素的样式。需要注意的是Modifier是装饰元素的共性样式如尺寸，背景，边框和位移等等，而像具体元素特性，如Text中的文本样式，是无法用Modifier来修改的。</p>

<h3>尺寸Size</h3>

<p>尺寸对于一个UI元素来说是必要的，就是渲染之后的视觉上的宽度和高度。可以通过Modifier的下列函数来进行尺寸约束：</p>

<ul>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">width</a>.width(androidx.compose.ui.unit.Dp))/<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">height</a>.height(androidx.compose.ui.unit.Dp)) - 指定固定的偏好宽度和偏好高度，参数传入具体的数值如Modifier.width(320.dp).height(480.dp)，就是指定某个元素的宽度是320dp，高度是480dp。偏好（preferred）的意思是可能会被其他约束条件覆盖，而最终值可能会不一样。</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">size</a>.size(androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp)) - 同时指定宽度和高度为某一偏好的数值，只传一个参数就是一个正方形，如Modifier.size(100.dp)，等同于Modifier.width(100.dp).height(100.dp)；传两个参数时分别指定宽和高，如Modifier.size(320.dp, 480.dp)等同于Modifier.width(320.dp).height(480.dp)。</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">wrapContentWidth</a>.wrapContentWidth(androidx.compose.ui.Alignment.Horizontal,kotlin.Boolean))/<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">wrapContentHeight</a>.wrapContentHeight(androidx.compose.ui.Alignment.Vertical,kotlin.Boolean))/<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">wrapContentSize</a>.wrapContentSize(androidx.compose.ui.Alignment,kotlin.Boolean)) - 让元素自己决定尺寸，无视最小尺寸限制（minimum_wdith/minimum_height），类似于XML中的wrap_content，这是比较严格的限制。</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">requiredWidth</a>.requiredWidth(androidx.compose.ui.unit.Dp))/<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">requiredHeight</a>.requiredHeight(androidx.compose.ui.unit.Dp)) - 指定宽度和高度必须为某一数值，不可以被其他限制约束覆盖。带有In的函数可以指定一个范围。</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">requiredSize</a>.requiredSize(androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp)) - 指定宽度和高度必须为某一数值，带有In的函数可以指定范围。</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">widthIn</a>.widthIn(androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp))/<a href="">heightIn</a>/<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">sizeIn</a>.sizeIn(androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp)) - 带有in的函数，可以指定一个范围而非具体数值，比如Modifier.widthIn(10.dp, 100.dp)，就是说限制此元素的宽度为10dp到100dp之间。</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">fillMaxWidth</a>.fillMaxWidth(kotlin.Float))/<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">fillMaxHeight</a>.fillMaxHeight(kotlin.Float)) - 不固定具体的数值，按比例填充最大可用空间，比例为1.0时填满，类似于XML中的match_parent。</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">fillMaxSize</a>.fillMaxSize(kotlin.Float)) - 按比例填充满可用空间。</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/RowScope#(androidx.compose.ui.Modifier">weight</a>.weight(kotlin.Float,kotlin.Boolean)) - 权重比例，仅在父布局是Row或者Column时，且尺寸与父布局约束一致时有效，比如在Row中，对width生效，在Column中对height生效。最终的占比是『权重比例 x 可用空间』，不指定weight则weight是0，比如一个Row中，有三个元素，其中两个元素A和B指定了weight为1和2，另一个没指定，那么A将占Row中剩余可用宽度的1/3，B将占2/3。与View中的LinearLayout中的权重是差不多的。</li>
</ul>


<p>Modifier修饰尺寸的函数比较多，容易学杂了，需要梳理一下：size相当于快捷方式，可以同时约束宽和高；带有In的函数可以为某个约束指定范围。宽高是一种限制性约束，不同的函数的限制严格性是不一样的，带有required是最严格的限制约束，优先级最高，如有冲突，以它为准；wrapContentWidth/wrapContentHeight/wrapContentSize是较严格的限制，仅次于required；width/height/size是中等严格，较wrapContent再次之；weight再次之；fillMax则是最弱的限制。</p>

<h3>间隔</h3>

<p>间隔（padding）是在元素与其边界之间添加的额外的空白空间，<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">Modifier.padding</a>.padding(androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp))不影响元素的尺寸，它是在测量之前就应用生效。</p>

<p>对于有XML经验的同学来说，以往的间隔有两个，一个是margin控制着元素边界之外的间隔，padding控制着边界与元素本身内容间隔。对于Modifier来说，只有一个函数，在不同的位置调用padding函数会有不同的效果，<strong>如果在尺寸之后调用padding，则是调整边界与内容之间的间隔，如果是在尺寸之前调用，则是调整边界与外部的间隔</strong>。另外，就是padding不可以传负值。</p>

<pre><code class="Kotlin">@Composable
fun PaddingDemo(modifier: Modifier = Modifier.fillMaxSize()) {
    Box(modifier = Modifier
        .fillMaxSize()
        .background(Color.LightGray)) {
        Text(
            text = "降龙十八掌",
            style = MaterialTheme.typography.headlineLarge,
            modifier = Modifier
                .padding(16.dp) // As margin: outside space beyond border
                .background(Color.Cyan)
                .size(360.dp, 120.dp)
                .padding(10.dp) // As padding: space between border and content
        )
    }
}
</code></pre>

<p><img src="https://pic2.zhimg.com/80/v2-2e631702c0ecb3e9197b78bcca795781_1440w.webp" alt="padding demo" /></p>

<h3>位移Offset</h3>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">函数Modifier.offset</a>.offset(kotlin.Function1))用来给水平和垂直方向加一个位移，数值可正可负，注意仅是增加位移，并不会改变元素的尺寸。与View中的translateX和translateY是类似的。它有两个函数，只有一个参数时是水平和垂直方向都加上相同的位移；两个参数时是分别指定水平方向和垂直方向。</p>

<pre><code class="Kotlin">@Composable
fun ModifierDemo(modifier: Modifier = Modifier.fillMaxSize()) {
    var offset by remember { mutableStateOf(0) }
    Column(
        modifier = modifier
            .padding(8.dp)
            .clickable { offset += 8 }
    ) {
        Text(
            text = "降龙十八掌",
            style = MaterialTheme.typography.headlineLarge,
            color = MaterialTheme.colorScheme.primary,
            modifier = Modifier
                .offset(offset.dp, offset.dp)
                .background(Color.Cyan)
                .padding(16.dp)
        )
    }
}
</code></pre>

<p><img src="https://pic2.zhimg.com/80/v2-89bf155dba60d2811a2fd164cde81d89_1440w.webp" alt="offset demo" /></p>

<p>因为offset并不改变元素的尺寸，仅是在原位置上进行偏移，所以多用于点击效果，或者点击动画。</p>

<h3>背景Background</h3>

<p>使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">Modifier.background</a>.background(androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Shape))函数来修改元素的背景颜色，唯一需要注意的是padding的影响，background是给尺寸所指定的区域加背景色，所以padding调用的位置会有影响。</p>

<h3>边框Border</h3>

<p>用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">Modifier.bodrer</a>.border(androidx.compose.foundation.BorderStroke,androidx.compose.ui.graphics.Shape))函数可以指定边框的样式，如形状，粗细，线条和颜色。需要注意的是它也是跟尺寸一样的，受padding的影响：</p>

<pre><code class="Kotlin">@Composable
fun BorderWithShape(modifier: Modifier = Modifier.fillMaxSize()) {
    Box {
        Text(
            text = "降龙十八掌",
            style = MaterialTheme.typography.headlineLarge,
            modifier = Modifier
                .padding(10.dp)
                .border(2.dp, SolidColor(Color.Green), RoundedCornerShape(20.dp))
                .padding(10.dp)
        )
    }
}
</code></pre>

<p><img src="https://pic4.zhimg.com/80/v2-59bd2c586c1a0124d178c1bf84f49feb_1440w.webp" alt="border demo" /></p>

<h3>变幻</h3>

<p>Modifier还能对元素进行一些变幻，如透明度（Alpha），旋转（Rotate）和缩放（Scale）。通常用来实现一些非动画的静态特效。</p>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">Modifier.alpha</a>.alpha(kotlin.Float))指定透明度，0是透明，1是完全不透明，默认值是1.0。</p>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">Modifier.rotate</a>.rotate(kotlin.Float))实现旋转，参数是一个角度，顺时针旋转为正值，逆时针旋转为负值，默认值是0度。</p>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">Modifier.scale</a>.scale(kotlin.Float,kotlin.Float))是以元素的几何中心为中心点进行缩放负值会进行水平和垂直方向翻转：</p>

<pre><code class="Kotlin">@Composable
fun TransformationDemo(modifier: Modifier = Modifier.fillMaxSize()) {
    Box(
        modifier = Modifier.fillMaxSize()
            .background(Color.LightGray)
    ) {
        Text(
            text = "降龙十八掌",
            style = MaterialTheme.typography.headlineLarge,
            color = MaterialTheme.colorScheme.primary,
            modifier = Modifier
                .padding(16.dp)
                .alpha(0.618f)
                .rotate(11.8f)
                .scale(0.618f)
                .background(Color.Cyan)
                .size(360.dp, 120.dp)
                .offset(10.dp, 10.dp)
        )
    }
}
</code></pre>

<p><img src="https://pic4.zhimg.com/80/v2-7c306b043b33f57d6eae20fcf59a1303_1440w.webp" alt="transformation demo" /></p>

<h2>事件监听</h2>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">Modifier.clickable</a>.clickable(kotlin.Boolean,kotlin.String,androidx.compose.ui.semantics.Role,kotlin.Function0))函数用来指定点击事件响应。此外，还可以用于指定元素是否可以点击。</p>

<p>另外，还可以通过<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">Modifier.scrollable</a>.scrollable(androidx.compose.foundation.gestures.ScrollableState,androidx.compose.foundation.gestures.Orientation,kotlin.Boolean,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,androidx.compose.foundation.interaction.MutableInteractionSource))来指定元素是否可以滑动。</p>

<h2>最佳实践</h2>

<p>Modifier是非常强大的，也是非常复杂的，前面列出的都是最为常用的一些函数。接下再来学习一下使用Modifier时需要注意的事项。</p>

<h3>顺序很重要</h3>

<p>Modifier有很多很多函数，修改着同一个对象实例，有些函数会相互影响，因此这些<strong>函数的调用顺序</strong>就变得相当重要，特别是涉及尺寸强相关的装饰特性时，如background和border，它们会受到padding以及变幻的影响。比如前面变幻小节的例子，可以试着修改函数的调用顺序，就会发现结果会不一样。在实例使用时，如果出现与预期不一致的结果时，就尝试调整一下Modifiier函数的顺序，看是否是顺序 导致的。</p>

<h3>留意上下文</h3>

<p>在Compose中，有一些Modifier函数只能在特定的元素中使用，这就涉及了Compose上下文（Scope）。比如说像<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/BoxScope#(androidx.compose.ui.Modifier">Modifier.align</a>.align(androidx.compose.ui.Alignment))只能在<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/BoxScope">BoxScope</a>中使用，也就是说只能在Box的子元素中使用。对其他任何布局来说都是不能用的，所以在使用的时候也要注意元素所在的父布局。</p>

<h3>尽可能的复用</h3>

<p>每个元素在渲染的时候都需要一个Modifier对象，通常情况下都是通过Modifier的函数进行对象创建。但对于一些循环的场景，且Modifier对象没啥变化 时，这时就应该复用对象，而非每次都创建。比如说动画，以及像集合性布局的子布局，这时都应该在其父布局缓存Modifier对象，直接传给子元素，而不是让其每次都创建新对象：</p>

<pre><code class="Kotlin">val modifier = Modifier
        .padding(12.dp)
        .background(Color.Gray)
@Composable
fun LoadingWheelAnimation() {
    val animatedState = animateFloatAsState(/*...*/)

    LoadingWheel(
        // 把Modifier对象缓存到上一级的父布局中，以免每帧动画都创建一个Modifier对象
        modifier = reusableModifier,
        animatedState = animatedState
    )
}
</code></pre>

<p>对于集合性布局也最好是能复用Modifier对象：</p>

<pre><code class="Kotlin">val reusableItemModifier = Modifier
    .padding(bottom = 12.dp)
    .size(216.dp)
    .clip(CircleShape)

@Composable
private fun AuthorList(authors: List&lt;Author&gt;) {
    LazyColumn {
        items(authors) {
            AsyncImage(
                // 提升到上一级中时进行缓存，而不是每次都创建
                modifier = reusableItemModifier,
            )
        }
    }
}
</code></pre>

<h3>保持一致性</h3>

<p>一致性对于代码的可维护性和可扩展性是非常重要的，因为每个元素都需要Modifier对象，在Compose中到处都可以看到Modifier，在实际使用中保持一致性就非常重要。比如说Modifier要作为Composable的第一个参数，参数的命名应该是modifier，并且最好要有默认值，可以查阅Compose本身的代码，可以发现其所有的元素都遵循此约定。另外，就是对于共性的装饰要提升到父布局中进行统一设定，比如说根布局统一设定padding，而不是每个子布局进行分别设定，等等。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/modifiers">Compose modifiers</a></li>
<li><a href="https://www.jetpackcompose.net/jetpack-compose-modifiers">6. Jetpack Compose Modifiers</a></li>
<li><a href="https://www.kodeco.com/books/jetpack-compose-by-tutorials/v1.0/chapters/6-using-compose-modifiers">6. Using Compose Modifiers</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
