<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2024-08-18T13:03:32+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『损则有孚』| Lifecycle]]></title>
    <link href="http://toughcoder.net/blog/2024/08/18/jetpack-compose-lifecycle/"/>
    <updated>2024-08-18T12:14:35+08:00</updated>
    <id>http://toughcoder.net/blog/2024/08/18/jetpack-compose-lifecycle</id>
    <content type="html"><![CDATA[<blockquote><p>这篇文章大部分是<a href="https://developer.android.com/develop/ui/compose/lifecycle">官方文档</a>的翻译，但并不是严格的翻译，同时也加入了笔者自己的理解。</p></blockquote>

<p>通过前面的一系列文章我们已经基本掌握了使用Jetpack Compose来构建UI的方法，在接下来的几篇文章中将重点转移到Compose本身，理解一下Compose是如何把一坨坨的函数（Composables）转化成为目标平台UI的。先从composable的生命周期开始。</p>

<p><a href=""><img src="https://koenig-media.raywenderlich.com/uploads/2022/05/LifecycleOfComposablesInJetpackCompose-twitter.png" title="auto auto" ></a></p>

<!-- more -->


<p><strong>注意：</strong> 这里的生命周期是指Compose中的基本单元composable函数的生命周期，与目标平台（如Android）的生命周期不是一个概念，没有关系。</p>

<h2>概述</h2>

<p>在前面<a href="https://juejin.cn/post/7376094685495001139">讲解状态（State）的文章</a>中提到过，composable函数是Jetpack Compose的基本单元，运行composables就是组合（Composition），组合将会变成应用的UI。</p>

<p>当Jetpack Compose首次运行composables时，也即首次组合（Initial composition），它会追踪在组合中用来描述UI的composables。之后，当有状态变化时，Jetpack Compose会安排重组。重组就是重新执行状态发生变化的composables以作为对状态变化的响应，然后再更新组合体现变更。</p>

<p>组合仅能在首次组合过程中生成然后在重组中更新。修改组合的唯一方式就是通过重组。</p>

<h2>生命周期定义</h2>

<p>一个composable的生命周期可以用三个事件来定义：进入组合，重组，离开组合。</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-composition.png" alt="lifecycle" /></p>

<blockquote><p>图1. 组合中的一个composable的生命周期：进入组合，没有重组或者重组多次，最后离开组合。</p></blockquote>

<p>重组通常都是由状态对象发生变化触发的。Compose会追踪这些状态然后执行在组合中读取这些状态的所有composables，以及被这些composables调用的且无法被跳过的composables。</p>

<p><strong>注意：</strong> Composable的生命周期较View系统和Android平台的Activity以及Fragment要相对简单一些。如果一个composable需要处理外部的资源或者管理更为复杂的生命周期，可以使用副作用（Side Effects）。</p>

<p>如果一个composable被调用了多次，就会有多个实例被放入到组合之中。每一次调用都有独立的属于它自己的生命周期。来看一个例子：</p>

<pre><code class="Kotlin">@Composable
fun MyComposable() {
    Column {
        Text("Hello")
        Text("World")
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-hierarchy.png" alt="composition" /></p>

<blockquote><p>图2. 在组合中MyComposable的可视化表示。如果一个composable被调用了多次，会在组合中生成多个实例。图中不同颜色的元素代表不同的实例。</p></blockquote>

<h2>剖析组合中的composables</h2>

<p>组合中一个composable实例是用其调用点来标识的。Compose编译器认为每个调用点都是不一样的。从多个调用点调用composables会在组合中创建多个实例。</p>

<p><strong>关键术语：</strong> 调用点指的是composable被调用的代码位置。调用点会影响组合，进而影响最终UI。</p>

<p>在重组过程中，如果一个composable调用了与其上一次重组中调用的不同的composables，Compose会标识出哪些composables已调用过，哪些还未被调用过，对于两次组合中都调用了的composables，如果它们的输入没有变化则Compose不会予以执行。</p>

<p>因此，给关联到composable的副作用（各种Side Effects）指定标识就显得龙为重要，这样它们能成功的执行完成，而不是每次重组时都重新启动。</p>

<p>对于下面这个例子：</p>

<pre><code class="Kotlin">@Composable
fun LoginScreen(showError: Boolean) {
    if (showError) {
        LoginError()
    }
    LoginInput() // This call site affects where LoginInput is placed in Composition
}

@Composable
fun LoginInput() { /* ... */ }

@Composable
fun LoginError() { /* ... */ }
</code></pre>

<p>上面的代码中，函数LoginScreen会在一定条件下调用函数LogginError，并且总是会调用函数LoginInput。每个调用都有一个独一无二的调用点和代码位置，编译器正是用这些信息来独一无二的标识每个composable。
<img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-showerror.png" alt="recomposition" /></p>

<blockquote><p>图3. 在组合中，当有状态变化和重组发生时，LoginScreen的可视化展示。相同的颜色元素代表没有被重组。</p></blockquote>

<p>尽管LoginInput从第一个被调用的函数变成了第二个被调用的函数，它的实例在重组中得以留存。并且，因为LoginInput并没有在重组之间发生变化的参数，Compose会跳过对LoginInput的再次调用。</p>

<h2>提供额外的信息以优化重组</h2>

<p>多次调用一个composable会在组合中添加多个实例。当在同一个调用点多次调用同一个composable时，因为Compose没有可用的信息来独一无二的标识每个调用，所以composable的执行顺序被用以区别这些composable实例。有些时候这也够用了，但有些时候这会导致一些非预期的行为。</p>

<pre><code class="Kotlin">@Composable
fun MoviesScreen(movies: List&lt;Movie&gt;) {
    Column {
        for (movie in movies) {
            // MovieOverview composables are placed in Composition given its
            // index position in the for loop
            MovieOverview(movie)
        }
    }
}
</code></pre>

<p>在上面的代码中，Compose会用执行顺序来区别调用的composable实例。如果一个新的数据元素movie被添加到了列表的底部（最后面），Compose可以复用已经在组合中的实例，因为它们的位次没有变化，故而这些composable的输入数据元素movie并不会变化，也就是说因为只在最后添加，先前存在的实例与其数据还是能够对应得上的。</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-newelement-bottom.png" alt="no_key" /></p>

<blockquote><p>图4. 当一个新数据元素moviei添加到列表底部后时，组合中MovieScreen的可视化表示。组合中函数MovieOverview的实例会被复用。相同颜色的元素表示未被重组。</p></blockquote>

<p>然而，如果输入列表的变化是在其顶部添加新元素，或者在中间添加新元素，或者有移除，或者变化元素顺序时，就会对列表中位置发生变化的所有MovieOverview进行重组。如果有储如在MovieOverview中获取电影图片的副作用函数的话，这些仅因位置改变而发生的重组就特别重要了。因为重组会影响副作用函数，如果副作用正在进行中，会被取消然后重新启动。</p>

<pre><code class="Kotlin">@Composable
fun MovieOverview(movie: Movie) {
    Column {
        // Side effect explained later in the docs. If MovieOverview
        // recomposes, while fetching the image is in progress,
        // it is cancelled and restarted.
        val image = loadNetworkImage(movie.url)
        MovieHeader(image)

        /* ... */
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-newelement-top-all-recompose.png" alt="side_effect" /></p>

<blockquote><p>图5. 新元素添加到列表中时组合中MovieScreen的可视化表示。MovieScreen实例无法复用，所有的副作用会重启。不同的颜色代表发生了重组。</p></blockquote>

<p>理想情况下，应该让函数MovieScreen的实例标识与其数据项的标识联系起来。如果列表数据项顺序有变化，最为想理的办法是也把组合树中的对应的函数实例进行次序调整，而不是进行重组（前面说了次序作为函数实例的标识，次序变了，就要使用新位置的数据项调用composable进行重组）。Compose给我们提供了一个方法用以标识组会树中的函数实例：即<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#key(kotlin.Array,kotlin.Function0">函数key</a>)。</p>

<p>把代码块放入函数key里面，再传给函数key一些数据，这些数据会被组合起来以标识组合中的函数实例。传给函数key的数据不必是全局唯一的，它只需要在key所在的调用点是唯一的就行。比如在前面例子中，每个数据项movie需要有一个唯一的标识，它能在这个列表中唯一标识一部电影就可以了：</p>

<pre><code class="Kotlin">@Composable
fun MoviesScreenWithKey(movies: List&lt;Movie&gt;) {
    Column {
        for (movie in movies) {
            key(movie.id) { // Unique ID for this movie
                MovieOverview(movie)
            }
        }
    }
}
</code></pre>

<p>像上面用了key以后，无论列表怎么变化，Compose都能辩识出具体composable实例，然后加以复用：
<img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-newelement-top-keys.png" alt="key" /></p>

<blockquote><p>图6. 当新数据元素添加到列表时组合中MovieScreen的可视化展示。因为有了唯一标识，Compose能识别出哪些实例未发生变化，加以复用，它们附带的副作用会继续执行。</p></blockquote>

<p><strong>关键点：</strong> 适度的使用函数key来帮助Compose唯一标识函数实例。特别是针对在同一个调用点大量调用同一个composable时，比如在各种集合性布局中。</p>

<p>有些composable有更为友好的key支持方法。比如像LazyColumn它可以直接在其items DSL中传入一个lambda作为key：</p>

<pre><code class="Kotlin">@Composable
fun MoviesScreenLazy(movies: List&lt;Movie&gt;) {
    LazyColumn {
        items(movies, key = { movie -&gt; movie.id }) { movie -&gt;
            MovieOverview(movie)
        }
    }
}
</code></pre>

<h2>重组时跳过composable的策略</h2>

<p>在重组过程中，一些具备条件的composable函数可以让Compose跳过他们的执行，如果它们的输入参数较前一次组合时没有任何变化。
除了以下情况外，就可以说一个composable函数具备跳过条件：</p>

<ul>
<li>函数有返回值（non-Unit return type）</li>
<li>函数使用了注解&#64;NonRestartableComposable或者&#64;NonSkippableComposable修饰</li>
<li>必需的参数是一个非稳定类型（non-stable type）</li>
</ul>


<p>前两个都好理解，接下来重点看第三个情况。一个类型要想成为稳定的（stable），必须符合以下约定：</p>

<ul>
<li>对于两个相内实例来说，对其们使用equals方法的返回值必须永远相同</li>
<li>如果一个类型的公开属性发生变化，组合会得到通知</li>
<li>所有公开属性类型也必须是稳定的</li>
</ul>


<p>有一些重要的常见类型符合这个约定，Compose编译器会把它们当成稳定的类型，尽管他们并没有使用注解&#64;Stable显式地标注为稳定的：</p>

<ul>
<li>所有的基础数据类型：布尔（Boolean），整数（Int），长整数（Long），浮点（Float），字符（Char）等</li>
<li>字符串（String）</li>
<li>所有的函数类型（lambdas）</li>
</ul>


<p>所有这些类型都能符合稳定约定，因为他们都是不可变类型。因为不可变类型实例不会改变，它们不会通知组合说值有所改变，因此就能符合上述约定。</p>

<p><strong>注意：</strong> 所有的整体不可变类型都可以安全地当成稳定的类型。</p>

<p>一个值得注意的类型是可变状态类型（MutableState），虽然是稳定的但却可变可修改。如果MutableState中持有一个值，这个状态对象被认为是稳定的，因为State属性.value发生的任何变化都会通知给Compose。</p>

<p>当作为传递给一个composable函数参数的所有类型都是稳定的（stable）时，这些参数的值会基于它们在UI树中的函数位置进行等值比较（equality）。从前一次组合起如果值未变化就会跳过其重组。换句话说输入参数的类型是稳定的（stable）是一个大前提，只有稳定的类型比较等值才有意义。</p>

<p><strong>关键点：</strong> 如果一个composable的输入是稳定的且未有变化，Compose就会跳过它的重组。等值比较使用的是方法equals。</p>

<p>仅当Compose能够证明一个类型是稳定的时，才会把一个类型当作稳定的。例如，接口（interface）通常认为是不稳定的，拥有可变公开属性的类型，虽然这些属性的实现可以是不可变的，但这种类型也认为是不稳定的。</p>

<p>如果Compose无法推断出一个类型是不是稳定的，但是想强制它被当作稳定的类型，可以使用注解&#64;Stable来标注。</p>

<pre><code class="Kotlin">// Marking the type as stable to favor skipping and smart recompositions.
@Stable
interface UiState&lt;T : Result&lt;T&gt;&gt; {
    val value: T?
    val exception: Throwable?

    val hasError: Boolean
        get() = exception != null
}
</code></pre>

<p>上面的代码片段中，因为UiState是一个接口，会被当成不稳定的类型。通过添加注解&#64;Stable，告诉Compose它是稳定的，让Compose进行智能重组。这也意味着，当接口类型用于参数类型时，Compose会把接口的所有具体实现当成稳定的类型。</p>

<p><strong>关键点：</strong> 如果Compose无法推断出类型的稳定性，使用注解&#64;Stable来标注以让Compose进行智能重组。</p>

<h2>总结</h2>

<p>Composable函数是Compose的基本单元，通过此文我们理解了一个composable的生命周期，并对Compose的重组机制做了介绍，以及如何更好的让Compose做智能重组。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/lifecycle">Lifecycle of composables</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『密云不雨』| Navigation]]></title>
    <link href="http://toughcoder.net/blog/2024/08/12/navigation-with-compose/"/>
    <updated>2024-08-12T07:46:31+08:00</updated>
    <id>http://toughcoder.net/blog/2024/08/12/navigation-with-compose</id>
    <content type="html"><![CDATA[<p>除了一些玩具性的Demo以外，相信任何一个应用程序不可能只有一个页面，最为极简的应用也至少会有两个页面，一个主页和一个设置页。对于传统的View系统来说对于导航这块没有专门的API，一般都是自己写逻辑跳Activity，或者跳到Fragment，然后再反向的Back，所以有了很多三方的各种Router类库（如大阿里的ARouter，货拉拉的TheRouter）。其实谷歌已经提供了解决方案，在Jetpack中提供了<a href="https://developer.android.com/guide/navigation">Navigation组件</a>，专门用于解决应用内部各种页面之间跳转的问题。</p>

<p><a href=""><img src="https://blog.mindorks.com/images/banner-jetpack-compose-navigation-657edc7b323cafdf.png" title="auto auto" ></a></p>

<!-- more -->


<p>对于Jetpack Compose来说，因为是全新的框架，在设计之初就考虑到了导航的问题，但也不是重新开发了一套新库，而是把Jetpack中的组件Navigation深度的结合了进来。换句话说，在Jetpack Compose中可以直接使用Navigation组件来进行页面之间的跳转，并且有非常符合Compose的粘合API，使用起来非常的丝滑顺手。</p>

<h2>基本概念</h2>

<p>在深入之前有必要先澄清Navigation中的一些概念，了解了一些基本的概念和术语之后，会有助于理解组件的设计理念，也会更容易上手使用。</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 术语 </th>
<th style="text-align:left;"> 用途 </th>
<th style="text-align:left;"> 具体的Composable </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> Host </td>
<td style="text-align:left;"> 包含了当前导航页面的容器。应该把它理解成为导航的容器，包含着当前的页面， 以及一个NavController。 </td>
<td style="text-align:left;"> <a href="https://developer.android.com/reference/kotlin/androidx/navigation/compose/package-summary#NavHost(androidx.navigation.NavHostController,androidx.navigation.NavGraph,androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1">NavHost</a>) </td>
</tr>
<tr>
<td style="text-align:center;"> Graph </td>
<td style="text-align:left;"> 静态的数组结构，定义着一个应用中的所有页面，以及它们之间应该如何跳转。 </td>
<td style="text-align:left;"> <a href="https://developer.android.com/reference/androidx/navigation/NavGraph">NavGraph</a> </td>
</tr>
<tr>
<td style="text-align:center;"> Controller </td>
<td style="text-align:left;"> 页面之间导航的核心管理者。它封装着如何在页面之间跳转的方法，处理链接的方法，以及返回堆栈的方法。 </td>
<td style="text-align:left;"> <a href="https://developer.android.com/reference/androidx/navigation/NavController">NavController</a> </td>
</tr>
<tr>
<td style="text-align:center;"> Destination </td>
<td style="text-align:left;"> 在Graph中的一个节点。当跳转到这个节点时，Host中就包含并展示它的页面。在实际项目中，往往是一个Fragment或者一个Composable，也就是一个页面。 </td>
<td style="text-align:left;"> <a href="https://developer.android.com/reference/androidx/navigation/NavDestination">NavDestination</a> </td>
</tr>
<tr>
<td style="text-align:center;"> Route </td>
<td style="text-align:left;"> Destination的全局唯一标识，包括其所需要的参数。大部分时候，特别是在Compose中，这就是一坨类似于Uri一样的String </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p>还需要说明一下的就是导航的基本的操作对象是一个页面，一个页面可以理解为一个全屏的，逻辑上内聚，内容上互相关联，自成一家的一个UI页面，比如说一个应用的主页是一个页面，文章列表是一个页面，文章详情是一个页面，设置是一个页面，用户页又是一个页面。当然，这里全屏并不是直观的全屏，意思是说（特别是对于Compose）一个页面的大小是受系统控制的，并不能像普通的Composable那样随意设置大小，对于手机就是全屏的，对于平板可能会一个占据三分之一（列表页），一个占据三分之二（详情页）。</p>

<h2>使用Navigation</h2>

<p>Jetpack Compose是声明式UI，是函数式编程，每一个Composable都是一个函数，所以在Compose中使用Navigation略微的有点不一样。核心原理和核心的规则肯定与Navigation是一样一样的，只是使用上的API略不一样，其实是更简单更方便了（这是声明式UI带来的收益）。</p>

<h3>添加依赖</h3>

<p>在使用之前先要添加Navigation库作为项目的依赖：</p>

<pre><code class="Kotlin">dependencies {
    val navVersion = "2.7.7"
    implementation("androidx.navigation:navigation-runtime-ktx:$navVersion")
    implementation("androidx.navigation:navigation-compose:$navVersion")
}
</code></pre>

<h3>使用Navigation的方法</h3>

<p>可以通过以下步骤来使用Navigation：</p>

<ul>
<li>创建NavHost，并设置为应用的入口，通过Composable函数<a href="https://developer.android.com/reference/kotlin/androidx/navigation/compose/package-summary#NavHost(androidx.navigation.NavHostController,androidx.navigation.NavGraph,androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1">NavHost</a>)。</li>
<li>创建NavController，可以直接创建，但推荐的方式是使用Compose提供的状态构造函数<a href="https://developer.android.com/reference/kotlin/androidx/navigation/compose/package-summary#rememberNavController(kotlin.Array">rememberNavController</a>)，它的好处在于当前导航会提升为一个状态。</li>
<li>定义Destination和Route，其实对于Compose来说都是用类似于Uri的String来作为Destination，每一个Destition唯一对应着一个页面。</li>
<li>添加页面，通过函数NavHost的尾部lambda，它实际上是一个<a href="https://developer.android.com/reference/kotlin/androidx/navigation/NavGraphBuilder">NavGraphBuilder</a>的扩展函数，这里调用函数<a href="https://developer.android.com/reference/kotlin/androidx/navigation/compose/package-summary#(androidx.navigation.NavGraphBuilder">composable</a>.composable(kotlin.collections.Map,kotlin.collections.List,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function2))来添加页面。</li>
<li>配置跳转，通过前面创建的navController来实现跳转，用<a href="https://developer.android.com/reference/kotlin/androidx/navigation/NavController#navigate(android.net.Uri">navController.navigate</a>)来跳转到指定的Destination，用<a href="https://developer.android.com/reference/androidx/navigation/NavController#popBackStack(">navController.popBackStack</a>)来返回到前一个页面。而触发的入口肯定是在具体的页面之中，所以页面要把其跳转函数作为参数，在NavGraphBuilder时，再用NavController去实现，这样所有的跳转逻辑就都在NavGraph中，便于管理。</li>
</ul>


<h3>具体实例</h3>

<p>说了那么多貌似挺烦杂的，让我们看一个实例就会瞬间明白。</p>

<p>一个简单的应用有4个页面，先定义Destinations：</p>

<pre><code class="Kotlin">object Destinations {
    const val APP_URI = "http://toughcoder.net/chronos"
    const val HOME_ROUTE = "home" // 主页
    const val HISTORY_ROUTE = "history" // 历史记录页面
    const val SETTINGS = "settings" // 设置页
    const val ARTICLES = "articles" // 文章页
}
</code></pre>

<p>那么就可以如此配置Navigation：</p>

<pre><code class="Kotlin">@Composable
fun ChronosNavGraph(
    modifier: Modifier = Modifier,
    navController: NavHostController = rememberNavController(),
    start: String = Destinations.HOME_ROUTE // 默认的初始页面为主页
) {
    NavHost(
        modifier = modifier,
        navController = navController,
        startDestination = start
    ) {
        composable(
            route = Destinations.HOME_ROUTE,
            deepLinks = listOf(
                navDeepLink { uriPattern = "${Destinations.APP_URI}/${Destinations.HOME_ROUTE}" }
            )
        ) {
            ChronosScreen(
                gotoSettings = { navController.navigate(Destinations.SETTINGS) },
                gotoHistory = { navController.navigate(Destinations.HISTORY_ROUTE) },
                gotoArticles = { navController.navigate(Destinations.ARTICLES) }
            )
        }

        composable(
            route = Destinations.HISTORY_ROUTE,
            deepLinks = listOf(
                navDeepLink { uriPattern = "${Destinations.APP_URI}/${Destinations.HISTORY_ROUTE}" }
            )
        ) {
            HistoryScreen(
                viewModel = viewModel()
            ) {
                navController.popBackStack()
            }
        }

        composable(
            route = Destinations.SETTINGS,
            deepLinks = listOf(
                navDeepLink { uriPattern = "${Destinations.APP_URI}/${Destinations.SETTINGS}" }
            )
        ) {
            SettingsScreen(
                viewModel = viewModel()
            ) {
                navController.popBackStack()
            }
        }

        composable(
            route = Destinations.ARTICLES,
            deepLinks = listOf(
                navDeepLink { uriPattern = "${Destinations.APP_URI}/${Destinations.ARTICLES}" }
            )
        ) {
            ArticlesScreen(
                viewModel = viewModel()
            ) {
                navController.popBackStack()
            }
        }
    }
}
</code></pre>

<p>可以看到每一个composable函数用以创建一个导航页面，里面有其Route，具体的页面，以及跳转的入口函数。deepLinks是每个页面的Uri式的链接，后面会详细的讲解。</p>

<p>最后就是把这个NavGraph作为应用的入口页面：</p>

<pre><code class="Kotlin">override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            ChronosTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    ChronosNavGraph()
                }
            }
        }
    }
</code></pre>

<h2>在页面之间传递参数</h2>

<p>页面跳转还必然会涉及参数的传递，比如具有递进关系的两个页面，核心参数肯定要由前一个页传递过去，最为典型的场景就是列表类页面到详情页面的跳转，比如文章列表要把文章的Id传给详情页，这样详情页才知道去展示哪个文章，用户列表要把用户Id传给详情页，详情页才知道展示哪个用户。</p>

<p>Navigation提供了传递参数的方法，在创建导航页面时传入的Route可以加入占位符形参，然后在跳转navController.navigate时可以传入实参，只不过参数的类型有限制，只能是基础数据类型如字串或者数字。目标页面使用时通过backStackEntry.arguments来获得参数。来具体看一下，比如说传递用户Id的场景：</p>

<pre><code class="Kotlin">NavHost() {
    composable(
          "profile/{userId}",
          arguments = listOf(navArgument("userId") { type = NavType.StringType } // 这句可以省略，因为默认类型都当成是字符串
    ) { backStackEntry -&gt;
          Profile(navController, backStackEntry.arguments?.getString("userId"))
    }
}
</code></pre>

<p>上面参数类型的声明，其实可以省略，因为默认的类型都当成String来解析和处理，如果是其他类型则需要显式地声明。这样目标页面的参数就声明好了，我们在跳转的时候传入实参就可以了：</p>

<pre><code class="Kotlin">navController.navigate("profile/user1234")
</code></pre>

<p>大部分时候参数都是<strong>必填参数</strong>，像上面这样写userId是必填的参数。但有些时候一些非核心的参数，可能不是每次跳转都会传，这就需要页面把参数声明为<strong>可选参数</strong>。可选参数在声明的时候Uri中必须使用查询式语句，如（&#8221;?argName={argName}&ldquo;），另外必须 设置默认值，或者类型是nullable的。这也意味着我们不能省略导航页面构建composable函数中的arguments参数：</p>

<pre><code class="Kotlin">composable(
    "profile?userId={userId}",
    arguments = listOf(navArgument("userId") { defaultValue = "user1234" }) // 注意这里的默认值，当调用navigate时如果不传userId就用这个默认值
) { backStackEntry -&gt;
    Profile(navController, backStackEntry.arguments?.getString("userId"))
}
</code></pre>

<p><strong>注意：</strong> 要尽可能的使用基本的数据类型，如String，Int或者Long，而不传递复杂的数据。复杂的数据通常都是业务逻辑数据，而业务逻辑数据应该使用基本的参数，再从数据源处（通常是通过ViewModel从Repo处）去主动获取，这样才能保证数据的真实有效。这是设计原则中的『单一数据源原则Single Source of Truth』。复杂数据从Repo处获取后，可能会变得过时或者失真，而且在页面之间传递会有拷贝，效率也不高，因此要避免在页面之间传递复杂数据。</p>

<h2>处理DeepLinks</h2>

<p>DeepLinks是Uri式的链接跳转范式，能够以字符串形式的Uri精准的定位到某个应用的具体某个页面，就犹如互联网中的Uri一样。它的好处在于形成了一个统一的标准，形式简单方便，一个字符串就能定位到一个页面。</p>

<p>使用导航页面构建函数composable在构建页面的时候可以传入<a href="https://developer.android.com/reference/androidx/navigation/NavDeepLink">NavDeepLink</a>对象，更为方便的是使用其构建函数<a href="https://developer.android.com/reference/kotlin/androidx/navigation/package-summary#navDeepLink(kotlin.Function1">navDeepLink</a>)：</p>

<pre><code class="Kotlin">val uri = "https://www.example.com"

composable(
    "profile?id={id}",
    deepLinks = listOf(navDeepLink { uriPattern = "$uri/{id}" })
) { backStackEntry -&gt;
    Profile(navController, backStackEntry.arguments?.getString("id"))
}
</code></pre>

<p>从示例中可以看出Uri中还可以带有参数，形参的声明，以及参数的获取与前面提到的页面参数是一样一样的，如果实际传过来的Uri是&#8221;<a href="https://www.example.com/user123">https://www.example.com/user123</a>&#8220;，到此页面后，就能解析出参数id为user123。</p>

<p>正常情况下这些DeepLinks只能在应用内部使用，如果要对应用外开放，则需要在应用的AndroidManifest文件中进行声明，声明为intent filter：</p>

<pre><code class="xml">&lt;activity …&gt;
  &lt;intent-filter&gt;
    ...
    &lt;data android:scheme="https" android:host="www.example.com" /&gt;
  &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>

<h2>页面跳转过渡动画</h2>

<p>页面跳转可以指定具体的过渡动画，具体的可以参考<a href="https://juejin.cn/post/7385758285960609831#heading-10">前面专门讲动画的那篇文章</a>，这里就不再重复了。</p>

<h2>Route的类型安全</h2>

<p>通常情况下Route都是使用Uri式的String，但这明显不够安全，因为调用navController#navigate的时候，可能会传一个不认识的页面Route，或者参数传错了（比如数字参数传了String），等等。轻则跳转失败，因为找不到Destination页面，重则会Crash。要想类型安全，就不能使用String式的Uri，需要把Ruote定义为类型（也即class），但要使用注解&#64;Serializeable标记一下：</p>

<pre><code class="Kotlin">// 主页面，不带任何参数
@Serializable
object Home

// 用户页面，参数是用户Id，其类型是一个String
@Serializable
data class Profile(val id: String)
</code></pre>

<p>然后在构建导航页面的时候，函数composable其实是一个泛型函数，它可以指定Route的参数类型：</p>

<pre><code class="Kotlin">NavHost(navController, startDestination = Home) {
     composable&lt;Home&gt; { // 泛型函数，可以指定参数类型
         HomeScreen(onNavigateToProfile = { id -&gt;
             navController.navigate(Profile(id)) // 跳转的时候传入的实参是一个对象，类型就是上面定义的Route
         })
     }
     composable&lt;Profile&gt; { backStackEntry -&gt;
         val profile: Profile = backStackEntry.toRoute()  // 获取参数的时候，用toRoute来获得Route对象，类型就是我们定义的那个
         ProfileScreen(profile.id)
     }
}
</code></pre>

<p>然后在跳转的时候就可以把Route对象作为实参传进去：</p>

<pre><code class="Kotlin">navController.navigate(Profile(id = 123))
</code></pre>

<p>这样因为都是定义的类型，所以编译器会做编译时检查，虚拟机也会做运行时的类型检查，保证类型安全。</p>

<p><strong>注意：</strong> 不要混淆，这里Route虽然是自定义类型，但并不算是在页面之间传递复杂的业务数据，因为具体的参数仍是诸如String和Int之类的基础数值。把Route定义为类型（class），而不是直接使用String，是为了让编译器帮忙我们保证类型安全，减少出错。</p>

<h2>总结</h2>

<p>使用Navigation可以非常轻松的把应用的各个页面组织连接起来，形成一个完整的交互闭环。谷歌也提供了相应的<a href="https://developer.android.com/codelabs/jetpack-compose-navigation#0">CodeLab</a>可以学习一下。此外，谷歌的一些Sample app，像<a href="https://github.com/android/sunflower/tree/main">Sunflower</a>和<a href="https://github.com/android/compose-samples/tree/main/JetNews">JetNews</a>也是使用Navigation来实现导航的，是非常好的学习案例。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/navigation">Navigation with Compose</a></li>
<li><a href="https://developer.android.com/guide/navigation">Navigation</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『时乘六龙』| Advanced Gestures]]></title>
    <link href="http://toughcoder.net/blog/2024/08/02/advanced-gesture-in-compose/"/>
    <updated>2024-08-02T07:46:30+08:00</updated>
    <id>http://toughcoder.net/blog/2024/08/02/advanced-gesture-in-compose</id>
    <content type="html"><![CDATA[<p>通过<a href="https://juejin.cn/post/7395020728623480841">前面的一篇文章</a>我们学会了如何用各种高级别抽象的扩展函数来进行手势处理。像clickable，draggable，scrollable和anchoredDraggable都是类似于View系统中的各种回调（如onClick或者onScroll）是高级别的抽象，这里我们只能处理手势，大部分情况下这也够用了。</p>

<p><a href=""><img src="file:///Users/alexhilton/Downloads/compose_libs/gesture/advanced_gesture.jpeg" title="auto auto" ></a></p>

<!-- more -->


<p>但是，对于一些复杂的交互 场景需要我们先识别手势，然后再处理手势，这时就不能再用封装好的扩展函数了，而必须要用到像View系统中的onTouchEvent那样的低级别的回调，直接拿到触点事件，然后再识别手势，最后再处理手势。这篇文章就学习一下如何使用Jetpack Compose中的低级别函数来识别和处理手势。</p>

<h2>处理原始触点事件</h2>

<p>除了使用一些封装好了的扩展函数来直接处理某个手势以外，还可以直接接收原始的事件输入。</p>

<p>Jetpack Compose在Modifier中提供了扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/package-summary#(androidx.compose.ui.Modifier">pointerInput</a>.pointerInput(kotlin.Any,kotlin.Any,kotlin.coroutines.SuspendFunction1))来接收原始的触点事件，与View系统中的<a href="https://developer.android.com/reference/android/view/View.OnTouchListener">onTouch</a>是类似的，这是触点事件的低级别的API。通过此API能获得触点事件，之后可以进行手势识别和手势处理，因为拿到的是原始的触点事件，所以很多逻辑要自己写，有些麻烦，但因为完全可控，所以可以实现一些更为复杂的手势识别和手势处理，比如任意方向的拖拽和滑动，长按后的拖拽，多点触控等等。</p>

<h3>接收触点事件</h3>

<p>扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/package-summary#(androidx.compose.ui.Modifier">pointerInput</a>.pointerInput(kotlin.Any,kotlin.Any,kotlin.coroutines.SuspendFunction1))接收三个参数，前两个都是作为<strong>事件处理回调的标识（keys）</strong>，第三个参数是<strong>事件处理回调</strong>，是一个尾部lambda，当某个key发生变化，这个lambda会重新执行，否则即使发生重组（Recomposition），这个lambda也会不会重新执行。</p>

<pre><code class="Kotlin">fun Modifier.pointerInput(key1: Any?, key2: Any?, block: suspend PointerInputScope.() -&gt; Unit): Modifier
</code></pre>

<p>第三参数就是我们要提供的事件处理回调，它是运行在<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/PointerInputScope">PointerInputScope</a>上下文中的lambda，这个上下文作用域里面有很多扩展函数可以直接使用。仔细看这个lambda是suspend的，这是因为输入事件可能不是即时的，可能会有等待的情况，也就是说lambda是在有事件的时候才会执行。PointerInputScope中的函数也都定义为suspend的，这些函数在lambda中可以直接调用，所以lambda本身也必须 是suspend的。</p>

<p>比如说想要打印触点事件，就可以这样写：</p>

<pre><code class="Kotlin">@Composable
private fun LogPointerEvents(filter: PointerEventType? = null) {
    var log by remember { mutableStateOf("") }
    Column {
        Text(log)
        Box(
            Modifier
                .size(100.dp)
                .background(Color.Red)
                .pointerInput(filter) {
                    awaitPointerEventScope {
                        while (true) {
                            val event = awaitPointerEvent()
                            // handle pointer event
                            if (filter == null || event.type == filter) {
                                log = "${event.type}, ${event.changes.first().position}"
                            }
                        }
                    }
                }
        )
    }
}
</code></pre>

<p>filter是一个事件的类型参数当作key，也当作过滤条件。在事件处理回调lambda中，用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/AwaitPointerEventScope#awaitPointerEvent(androidx.compose.ui.input.pointer.PointerEventPass">awaitPointerEvent</a>)获得每一个触点事件，然后打印出来，<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/AwaitPointerEventScope">awaitPoniterEventScope</a>函数是创建一个协程上下文作用域用以等待事件输入，在其内调用awaitPointerEvent来获得事件。</p>

<h3>识别手势</h3>

<p>虽然pointerInput是一个低级别的接口，但也并不意味着所有的逻辑都必须从头写，在<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/PointerInputScope">PointerInputScope</a>中已经定义了大量的函数可以识别大部分手势：</p>

<ul>
<li>非连续性手势如单击（tap），双击（double tap）和长按（long press）：<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.input.pointer.PointerInputScope">detectTapGestures</a>.detectTapGestures(kotlin.Function1,kotlin.Function1,kotlin.coroutines.SuspendFunction2,kotlin.Function1))</li>
<li>拖拽（drag）：<a href="">detectDragGestures</a>，<a href="">detectDragGesturesAfterLongPress</a>，以及固定方向拖拽<a href="">detectHorizontalDragGestures</a>和<a href="">detectVerticalDragGestures</a></li>
<li>多点触控变幻的手势识别（旋转，平移和缩放）：<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.input.pointer.PointerInputScope">detectTransformGestures</a>.detectTransformGestures(kotlin.Boolean,kotlin.Function4))</li>
</ul>


<p>比如像<a href="https://juejin.cn/post/7395020728623480841">前面文章中</a>提到的拖拽也可以用pointerInput实现：</p>

<pre><code class="Kotlin">@Composable
private fun DraggableTextLowLevel() {
    Box(modifier = Modifier.fillMaxSize()) {
        var offsetX by remember { mutableStateOf(0f) }
        var offsetY by remember { mutableStateOf(0f) }

        Box(
            Modifier
                .offset { IntOffset(offsetX.roundToInt(), offsetY.roundToInt()) }
                .background(Color.Blue)
                .size(50.dp)
                .pointerInput(Unit) {
                    detectDragGestures { change, dragAmount -&gt;
                        change.consume()
                        offsetX += dragAmount.x
                        offsetY += dragAmount.y
                    }
                }
        )
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/gestures-drag.gif" alt="detect_drag_demo" /></p>

<p>前面提到了像detectTapGestures和detectDragGestures都是suspend的函数，所以在一个pointerInter的lambda中只能有一个，比如像下面这样写detectDragGestures不会得到执行：</p>

<pre><code class="Kotlin">var log by remember { mutableStateOf("") }
Column {
    Text(log)
    Box(
        Modifier
            .size(100.dp)
            .background(Color.Red)
            .pointerInput(Unit) {
                detectTapGestures { log = "Tap!" }
                // 不会得到执行，走不到这里，前面一个是suspend的
                detectDragGestures { _, _ -&gt; log = "Dragging" }
            }
    )
}
</code></pre>

<p>一个可行的解决办法就是可以写多个pointerInput，每个ponterInput处理一种手势：</p>

<pre><code class="Kotlin">var log by remember { mutableStateOf("") }
Column {
    Text(log)
    Box(
        Modifier
            .size(100.dp)
            .background(Color.Red)
            .pointerInput(Unit) {
                detectTapGestures { log = "Tap!" }
            }
            .pointerInput(Unit) {
                // These drag events will correctly be triggered
                detectDragGestures { _, _ -&gt; log = "Dragging" }
            }
    )
}
</code></pre>

<h3>直接处理事件</h3>

<p>遇到交互比较复杂的场景，或者当PointerInputScope中提供的识别函数不能解决问题时，或者需要把几种不同的手势组合在一起时，就需要直接处理事件。像View系统中的onTouch一样，我们需要知道不同的事件类型，比如pointer down，pointer move和pointer up等。PointerInputScope中提供了一个函数awaitEachGesture可以取代while (true)来获得每个事件；awaitFirstDown，是手势的开始相当于ACTION&#95;DOWN；waitForUpOrCancellation是事件结束，相当于ACTION&#95;UP和ACTION&#95;CANCEL；drag相当于ACTION&#95;MOVE。我们来看一个例子：</p>

<pre><code class="Kotlin">@Composable
private fun LogPointerEvents() {
    var log by remember { mutableStateOf("") }
    Column(
        modifier = Modifier.fillMaxSize(),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        Text(log)
        Box(
            Modifier
                .size(240.dp)
                .background(Color.DarkGray)
                .pointerInput(Unit) {
                    awaitEachGesture {
                        val down = awaitFirstDown().also {
                            log = "Action Down"
                        }
                        var change = awaitTouchSlopOrCancellation(down.id) { ch, _ -&gt;
                            ch.consume()
                        }
                        while (change != null &amp;&amp; change.pressed) {
                            change = awaitDragOrCancellation(change.id)
                            if (change != null &amp;&amp; change.pressed) {
                                log = "Action Move ${change.type} ${change.position}"
                            }
                        }
                        log = "Action Up"
                    }
                }
        )
    }
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/gesture/event.gif" alt="event_demo" /></p>

<p>需要注意的是这些函数都是suspend的，也就是说当预期的行为发生时才会带着结果返回，比如awaitFirstDown()当有第一个触点事件发生时结束suspend然后返回；awaitTouchSlopOrCancellation当有超过拖拽阈值时结束suspend然后返回；awaitDragOrCancellation当有拖拽发生时结束suspend返回。</p>

<h2>触点事件的派发流程</h2>

<p>为了更好的处理事件，需要了解一下Jetpack Compose的事件派发流程，与View系统是类似的，事件派发的过程也是沿着Composable的树形结构，从父Composable到子Composable，同一层级的顺序则是从上到下，从前到后（Z轴方向），依次做『Hit test』，直到事件被消费，就停止派发。</p>

<p>事件的消费过程则是反过来，子Composable如果未消费就返回给父Composable，前面的Composable未消费，就继续向下传递，直到事件被消费。</p>

<p>如果是自己在pointerInput中直接处理事件，就要特别注意手动的把事件给消费掉，否则可能会继续传递。像awaitPointerEvent，awaitFirstDown，awaitDragOrCancellation等返回的都是<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/PointerInputChange">PointerInputChange</a>对象，调用它的<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/PointerInputChange#consume(">consume()</a>)方法即可把事件消费掉。再比如像上面的例子awaitTouchSlopOrCancellation中，也需要手动的把事件给消费掉，如果把ch.consume()这句删除，就会发现awaitDragOrCancellation不会得到执行，这是因为awaitTouchSlopOrCancellation这个方法还在执行中，调用ch.consume()把事件消费掉，这个函数才会返回。</p>

<p>这也说明了，还是要尽量用系统封装好的手势识别和手势处理函数，不到万不得已不要直接处理原始事件，因为逻辑写起来肯定相当复杂。</p>

<h2>多点触控</h2>

<p>多点触控是超过一个触点同时在屏幕上操作，最为常见的手势就是旋转和缩放，可以使用扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">transformable</a>.transformable(androidx.compose.foundation.gestures.TransformableState,kotlin.Boolean,kotlin.Boolean))监听旋转，平移和缩放手势，其中平移单个触点也能触发，缩放和旋转则需要两个触点，当超过3个触点时这个函数不会回调，也即不会触发任何手势：</p>

<pre><code class="Kotlin">@Composable
private fun TransformableSample() {
    // set up all transformation states
    var scale by remember { mutableStateOf(1f) }
    var rotation by remember { mutableStateOf(0f) }
    var offset by remember { mutableStateOf(Offset.Zero) }
    val state = rememberTransformableState { zoomChange, offsetChange, rotationChange -&gt;
        scale *= zoomChange
        rotation += rotationChange
        offset += offsetChange
    }
    Box(
        Modifier
            // 把参数应用到图层去做变幻
            .graphicsLayer(
                scaleX = scale,
                scaleY = scale,
                rotationZ = rotation,
                translationX = offset.x,
                translationY = offset.y
            )
            // 接收变幻手势
            .transformable(state = state)
            .background(Color.Blue)
            .fillMaxSize()
    )
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/gestures-multitouch.gif" alt="multi_touch_demo" /></p>

<p>除了直接使用Modifier.transformable以外，还可以用前面提到过的pointerInput中的<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.input.pointer.PointerInputScope">detectTransformGestures</a>.detectTransformGestures(kotlin.Boolean,kotlin.Function4))这个函数也能得到平移，旋转和缩放的变化数值，把这些数值应用到graphicsLayer去做变幻就可以了，使用detectTransformGestures的另一个好处是可以与其他的手势结合起来。</p>

<h2>总结</h2>

<p>通过本文我们学习如何得到原始的触点事件，以及如何识别手势，相信对触点事件以及手势识别有了更深入的理解，并且借助这些扩展函数就可以写出交互性更好的应用程序界面。即使遇到一些复杂的交互 场景，或者需要组合多种手势时，也都能从容应对。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/understand-gestures">Understand gestures</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/multi-touch">Multitouch: Panning, zooming, rotating</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/user-interactions/handling-interactions">Handling user interactions</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『鱼跃于渊』| Gesture Handling]]></title>
    <link href="http://toughcoder.net/blog/2024/07/29/pointer-event-in-compose/"/>
    <updated>2024-07-29T20:41:20+08:00</updated>
    <id>http://toughcoder.net/blog/2024/07/29/pointer-event-in-compose</id>
    <content type="html"><![CDATA[<p>UI是用户界面，一个最为基础的功能就是与用户进行交互，要具有可交互性。要想有可交互性就需要处理用户输入事件。手势是最为常见的一种用户输入，今天就来专门学习一下如何处理Jetpack Compose中最为常见的手势。</p>

<p><a href=""><img src="https://koenig-media.raywenderlich.com/uploads/2022/10/GesturesInJetpackCompose-twitter.png" title="auto auto" ></a></p>

<!-- more -->


<h2>输入事件与手势概述</h2>

<p>在开始学习之前有必要先澄清一些概念，以免混淆。与View系统不太一样的是，触摸事件在Jetpack Compose中称之为触点事件（Pointer event），对应的主体称之为触点（Pointer），一连串的触点事件就形成了手势（Gesture）。之所以叫触点，是因为并不总是由触摸屏幕触发事件，也可以是手写笔，（外接）鼠标或者（外接）触摸板，这些都是触控类的输入主体，它的最主要的特点是发生在屏幕上的一个坐标点。其具体的类型称之为触点类型（Pointer type）。</p>

<p>事件处理最主要的是也就是要识别各种不同的触点手势，然后做出响应，以让UI具体可交互性。</p>

<h2>点击事件（Tap and Press）</h2>

<p>点击事件是最为常见，也是最为基础的一种手势了，可以简单的看成按下事件（pointer down）和抬起事件（pointer up）组成，但其实也会有移动（pointer move），只不过移动的位移特别小而已，这里我们不过多的纠结。点击事件分为单击，双击和长按，幸运的是在Compose中都有封装好的回调函数可以直接使用，我们一一来看一下。</p>

<h3>单击（Tap/Click）</h3>

<p>单击是最为常见的事件处理了，在之前的教程已经见过了，通过Modifier的扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier">Modifier.clickable</a>.clickable(kotlin.Boolean,kotlin.String,androidx.compose.ui.semantics.Role,kotlin.Function0))就可以为任意一个Composable设置单击事件处理函数。</p>

<h3>双击（Double tap/Double click）和长按（LongPress/Long click）</h3>

<p>对于双击和长按，并不像clickable那样常用，因此需要用到另外一个扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier">Modifier.combinedClickable</a>.combinedClickable(androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.foundation.Indication,kotlin.Boolean,kotlin.String,androidx.compose.ui.semantics.Role,kotlin.String,kotlin.Function0,kotlin.Function0,kotlin.Function0))，这个函数可以设置多个点击事件处理函数，单击双击和长按都可以通过它来设置：</p>

<pre><code class="Kotlin">    Box(
        modifier = Modifier
            .size(100.dp)
            .background(Color.Yellow)
            .combinedClickable(
                onClick = { gotoDetail() },
                onClickLabel = "Go to details",
                onLongClick = { showContextMneu() },
                onLongClickLabel = "Open context menu",
                onDoubleClick = { shareContent() }
            )
    )
</code></pre>

<h2>滚动（Scroll）</h2>

<p>滚动手势是指朝着某一固定的方向慢速的滑动，多用于查看屏幕之外的内容。像集合性布局设计的目的就是为了显示大量的同一类型的数据集合，天生就支持滚动。对于滚动手势需要处理的就是常规布局支持滚动，以及滚动的嵌套。</p>

<h3>非集合性布局支持滚动</h3>

<p>对于常规的非集合性布局（Box，Row和Column）正常情况下是不可滚动的，是没有办法查看超出其尺寸大小范围的内容的。想让这几个布局可滚动也不难，用Modifier的扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier">verticalScroll</a>.verticalScroll(androidx.compose.foundation.ScrollState,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean))和<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier">horizontalScroll</a>.horizontalScroll(androidx.compose.foundation.ScrollState,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean))就可以让不可滚动布局（Box，Row和Column）支持垂直方向滚动和水平方向滚动：</p>

<pre><code class="Kotlin">@Composable
private fun ScrollBoxes() {
    Column(
        modifier = Modifier
            .background(Color.LightGray)
            .size(100.dp)
            .verticalScroll(rememberScrollState())
    ) {
        repeat(10) {
            Text("Item $it", modifier = Modifier.padding(2.dp))
        }
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/gestures-simplescroll.gif" alt="scrollable_box" /></p>

<p>大部分情况下，如果只是想让布局可滚动就不需要处理<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/ScrollState">ScrollState</a>，但如果想要获取滚位置，或者改变滚动位置，比如说页面进入时（Initial composition）自动滚动到某一们位置，可以通过修改<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/ScrollState">SrollState</a>来实现：</p>

<pre><code class="Kotlin">@Composable
private fun ScrollBoxesSmooth() {
    // 进入页面时就自动的平滑的滚动
    val state = rememberScrollState()
    LaunchedEffect(Unit) { state.animateScrollTo(100) }

    Column(
        modifier = Modifier
            .background(Color.LightGray)
            .size(100.dp)
            .padding(horizontal = 8.dp)
            .verticalScroll(state)
    ) {
        // ...
    }
}
</code></pre>

<h3>滚动手势处理</h3>

<p>对于任意的Composable来文章，都可以通过Modifier的扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.Modifier">scrollable</a>.scrollable(androidx.compose.foundation.gestures.ScrollableState,androidx.compose.foundation.gestures.Orientation,kotlin.Boolean,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,androidx.compose.foundation.interaction.MutableInteractionSource))来监听并处理滚动手势。需要注意的是，scrollable仅会告诉你有滚动手势发生和当前的滚动距离，但并不会直接修改布局，需要开发者去使用滑动距离进行布局的修改：</p>

<pre><code class="Kotlin">@Composable
private fun ScrollableSample() {
    // actual composable state
    var offset by remember { mutableStateOf(0f) }
    Box(
        Modifier
            .size(150.dp)
            .scrollable(
                orientation = Orientation.Vertical,
                // Scrollable state: describes how to consume
                // scrolling delta and update offset
                state = rememberScrollableState { delta -&gt;
                    offset += delta
                    delta
                }
            )
            .background(Color.LightGray),
        contentAlignment = Alignment.Center
    ) {
        Text(offset.toString())
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/gestures-numeric-offset.gif" alt="handle_scrollable" /></p>

<p>如果让滚动对布局产生影响，可以用计算得到offset去改变布局的offset属性offset(y = offset.dp)就可以了。</p>

<h3>滚动嵌套</h3>

<p>手势处理最大的一个麻烦就是手势的嵌套，而又以滚动的嵌套最为麻烦，最为典型的就是同一方向的列表中套着列表，开发者必须手动处理滑动冲突。滚动冲突处理的策略并不难，优先由子View消费滚动事件，当子View还可以滚动时，就把事件消费掉；如果子View已到达边界，无法滚动时，视为事件未消费，把事件再传递给父View，由父View消费，这时父View会进行滚动；当然如果滑动事件没有发生在子View上面，那肯定 是父View滚动。</p>

<p>策略虽然简单，但有魔鬼细节，传统的View必须要在onTouch和onInterceptTouch里面写上大坨大坨的逻辑，还要定义很多个全局变量。幸运的是，针对 于同方向的可滚动布局嵌套，Jetpack Compose已经帮我们处理了。对于使用verticalScroll，horizontalScroll，scrollable，集合性布局（LazyRow，LazyColumn和LazyGrid）和TextField实现的同方向滚动嵌套，不用再特殊处理，Compose已经按照前面说的策略处理好了，这就是<strong>自动嵌套滚动机制（Automatic nested scrolling）</strong>。来看一个例子：</p>

<pre><code class="Kotlin">@Composable
private fun AutomaticNestedScroll() {
    val gradient = Brush.verticalGradient(0f to Color.Yellow, 1000f to Color.Red)
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .height(400.dp)
            .background(Color.LightGray)
            .verticalScroll(rememberScrollState())
            .padding(32.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        repeat(6) {
            Box(
                modifier = Modifier
                    .height(128.dp)
                    .verticalScroll(rememberScrollState())
            ) {
                Text(
                    "$it 滑动试试！",
                    modifier = Modifier
                        .align(Alignment.Center)
                        .border(12.dp, Color.DarkGray)
                        .background(brush = gradient)
                        .padding(24.dp)
                        .height(150.dp)
                )
            }
        }
    }
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/gesture/ascroll.gif" alt="nested_scrolling" />
这个例子中外层Column支持垂直滚动，里面的每个Box也支持垂直滚动，当里面的Box自己消费滚动时，外层 是不会动的，而当里面的Box无法滚动时（overscrolled）事件就到了外层的Column，即Column会滚动。</p>

<p><strong>注意：</strong>滚动嵌套并不是一个好的交互设计，尽管有技术手段解决，但用起来仍旧是怪怪的，操作起来也并不方便，误操作的可能性很大。不同方向的滚动嵌套在一起是比较好的方案，比如横向的Tab页代表不同的分类，竖向的内容页是一个分类中的具体内容，内容是竖向的，内容中仍旧可以有一些横向滑动的扩展内容，如图片库，tag标签等。</p>

<h2>拖拽（Drag）</h2>

<p>拖拽是指按住屏幕慢速移动，被点击到的UI元素应该跟随手势移动并停留在触点离开屏幕的地方。通过扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.Modifier">Modifier.draggable</a>.draggable(androidx.compose.foundation.gestures.DraggableState,androidx.compose.foundation.gestures.Orientation,kotlin.Boolean,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Boolean,kotlin.coroutines.SuspendFunction2,kotlin.coroutines.SuspendFunction2,kotlin.Boolean))可以处理单一方向的拖拽手势。在draggable中我们可以用状态记录移动的距离，然后把距离应用到Composable的offset以生成拖拽后的效果：</p>

<pre><code class="Kotlin">@Composable
private fun DraggableText() {
    var offsetX by remember { mutableStateOf(0f) }
    Text(
        modifier = Modifier
            .offset { IntOffset(offsetX.roundToInt(), 0) }
            .background(Color.LightGray)
            .padding(8.dp)
            .draggable(
                orientation = Orientation.Horizontal,
                state = rememberDraggableState { delta -&gt;
                    offsetX += delta
                }
            ),
        text = "降Compose十八掌！",
        style = MaterialTheme.typography.headlineLarge,
        color = MaterialTheme.colorScheme.primary
    )
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/gesture/drag.gif" alt="drag_demo" /></p>

<h2>滑动（Swipe/Fling）</h2>

<p>滑动与拖拽的区别在于滑动是有速度的，滑动手势在触点离开屏幕后并不会立即停止，而且是会继续朝原方向减速直到速度变为0才停，最为常见的交互方式就是滑动删除（swipe-to-dismiss），以及像列表的Fling手势。</p>

<p>使用Modifier的扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.Modifier">anchoredDraggable</a>.anchoredDraggable(androidx.compose.foundation.gestures.AnchoredDraggableState,androidx.compose.foundation.gestures.Orientation,kotlin.Boolean,kotlin.Boolean,androidx.compose.foundation.interaction.MutableInteractionSource))来处理滑动事件，定义一些<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/DraggableAnchors">锚点（DraggableAnchors）</a>，视为一个手势操作中的不同状态，比如像滑动开关，就是开和关，像滑动删除就是正常和已删除，再用一个<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/AnchoredDraggableState">AnchoredDraggableState</a>来追踪滑动的状态，这里面可以定义初始锚点，锚点值，和终止状态的阈值（positionalThreshold超过一定位置就认为到达终点锚点，velocityThreshold速度小于这个时就认为到达终点锚点），以及手势过程中的动画（animationSpec）。然后，再把AnchoredDraggableState中的滑动距离offset设置到Composable中即可。</p>

<p>说的挺复杂，其实很直观，看一个例子就明了：</p>

<pre><code class="Kotlin">enum class SwipeableSwitchState {
    SWITCH_ON, SWITCH_OFF
}

@OptIn(ExperimentalFoundationApi::class)
@Composable
private fun SwipeableSample() {
    val width = 128.dp
    val squareSize = 64.dp

    val density = LocalDensity.current
    val sizePx = with(density) { squareSize.toPx() }
    val anchors = DraggableAnchors {
        SwipeableSwitchState.SWITCH_ON at sizePx
        SwipeableSwitchState.SWITCH_OFF at 0f
    }
    val swipeableState = remember {
        AnchoredDraggableState(
            initialValue = SwipeableSwitchState.SWITCH_OFF,
            anchors = anchors,
            positionalThreshold = { d: Float -&gt; d * 0.4f },
            velocityThreshold = { with(density) { 100.dp.toPx() } },
            animationSpec = tween()
        )
    }
    Box(
        modifier = Modifier
            .width(width)
            .anchoredDraggable(
                state = swipeableState,
                orientation = Orientation.Horizontal,
                startDragImmediately = false
            )
            .background(Color.LightGray)
    ) {
        Box(
            Modifier
                .offset {
                    IntOffset(
                        if (swipeableState.offset.isNaN()) 0 else swipeableState.offset.roundToInt(),
                        0
                    )
                }
                .size(squareSize)
                .background(Color.DarkGray)
        )
    }
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/gesture/swipe.gif" alt="swipe_demo" />
这个例子展示了一个滑动开关的手势处理，滑动距离超过整体长度0.4时，或者速度小于100时就认为到达另一锚点状态。可以明显的看出与拖拽的区别，滑动后手可以离开，但手势仍在继续直到达到终点锚点。</p>

<p><strong>注意：</strong>在Compose 1.6版本以前有另外一个扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#(androidx.compose.ui.Modifier">swipeable</a>.swipeable(androidx.compose.material.SwipeableState,kotlin.collections.Map,androidx.compose.foundation.gestures.Orientation,kotlin.Boolean,kotlin.Boolean,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Function2,androidx.compose.material.ResistanceConfig,androidx.compose.ui.unit.Dp))来处理滑动手势，但在1.6版本时已废弃，被anchoredDraggable取代，并且有一个<a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/migrate-swipeable">替换的教程</a>。</p>

<h2>未完待续</h2>

<p>事件处理对于UI来说是极其重要的，本篇重点讲述了Jetpack Compose中的最为基础和最为常见的事件处理方式，足以满足绝大多数应用场景。事件处理也是极其复杂的，对于交互极其复杂的页面来说，还需要进一步的了解更为底层的事件处理方法，以达到复杂交互的目的，将在后面的文章中继续深入探讨事件处理。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/tap-and-press">Tap and press</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/drag-swipe-fling">Drag, swipe, and fling</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/scroll">Scroll</a></li>
<li><a href="https://canopas.com/how-to-implement-swipe-to-action-using-anchoreddraggable-in-jetpack-compose-cccb22e44dff">How to Implement Swipe-to-Action using AnchoredDraggable in Jetpack Compose</a></li>
<li><a href="https://fvilarino.medium.com/exploring-jetpack-compose-anchored-draggable-modifier-5fdb21a0c64c">Exploring Jetpack Compose Anchored Draggable Modifier</a></li>
<li><a href="https://medium.com/@AungThiha3/jetpack-compose-anchored-draggable-item-in-motionlayout-part-1-8d5a1cde880f">Jetpack Compose: Anchored Draggable Item in MotionLayout Part 1</a></li>
<li><a href="https://medium.com/@AungThiha3/jetpack-compose-anchored-draggable-item-in-motionlayout-part-2-c1fd94188e56">Jetpack Compose: Anchored Draggable Item in MotionLayout Part 2</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『双龙取水』| Text Edit]]></title>
    <link href="http://toughcoder.net/blog/2024/07/24/text-edit-in-compose/"/>
    <updated>2024-07-24T08:28:55+08:00</updated>
    <id>http://toughcoder.net/blog/2024/07/24/text-edit-in-compose</id>
    <content type="html"><![CDATA[<p>文本是所有UI系统中非常重要的一个种元素，文本的输入在UI框架中的重要性也特别的高，因为这是最重要的一种用户输入。今天专注于文本的输入处理，包括文本输入框，以及文本的选择和富式点击处理。</p>

<p><a href=""><img src="https://static.wixstatic.com/media/0d004d_ea93b43aabf348cb8f96c0dc94f85365~mv2.jpg/v1/fit/w_1000%2Ch_600%2Cal_c%2Cq_80/file.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>文本输入</h2>

<p>Compose提供了符合<a href="https://material.io/components/text-fields">Material Design</a>的文本输入<a href="https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#TextField(androidx.compose.ui.text.input.TextFieldValue,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Boolean,androidx.compose.ui.text.TextStyle,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Boolean,androidx.compose.ui.text.input.VisualTransformation,androidx.compose.foundation.text.KeyboardOptions,androidx.compose.foundation.text.KeyboardActions,kotlin.Boolean,kotlin.Int,kotlin.Int,androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.ui.graphics.Shape,androidx.compose.material.TextFieldColors">TextField</a>)，默认的实现是全填充的：</p>

<pre><code class="Kotlin">@Composable
fun SimpleFilledTextFieldSample() {
    var text by remember { mutableStateOf("Hello") }

    TextField(
        value = text,
        onValueChange = { text = it },
        label = { Text("Label") }
    )
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-textfield-hello.png" alt="textfield" />
还有一个边框式的<a href="https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#OutlinedTextField(kotlin.String,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Boolean,androidx.compose.ui.text.TextStyle,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Boolean,androidx.compose.ui.text.input.VisualTransformation,androidx.compose.foundation.text.KeyboardOptions,androidx.compose.foundation.text.KeyboardActions,kotlin.Boolean,kotlin.Int,kotlin.Int,androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.ui.graphics.Shape,androidx.compose.material.TextFieldColors">OutlinedTextField</a>)：</p>

<pre><code class="Kotlin">@Composable
fun SimpleOutlinedTextFieldSample() {
    var text by remember { mutableStateOf("") }

    OutlinedTextField(
        value = text,
        onValueChange = { text = it },
        label = { Text("Label") }
    )
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-outlinedtextfield.png" alt="outlined_textfield" />
可以看到TextField函数最关键的有三个参数：文本框中的显示的文本text，文本变化回调onValueChange，提示标签label。需要注意传给text的变量要是状态（State），这样才会触发重组，否则TextField显示的文本不会发生变化。</p>

<h3>定制TextField</h3>

<p>可以通过其他的参数来控制输入框的行为，最为常用的就是行数限制singleLine和maxLines， 以及文本的样式控制textStyle，它可以控制文本颜色和字体：</p>

<pre><code class="Kotlin">@Composable
fun StyledTextField() {
    var value by remember { mutableStateOf("Hello\nWorld\nInvisible") }

    TextField(
        value = value,
        onValueChange = { value = it },
        label = { Text("Enter text") },
        maxLines = 2,
        textStyle = TextStyle(color = Color.Blue, fontWeight = FontWeight.Bold),
        modifier = Modifier.padding(20.dp)
    )
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-textfield-multiline.png" alt="textfield_customize" />
textStyle比较丰富，除了直接指定颜色以外，还可以用<a href="https://developer.android.com/develop/ui/compose/text/style-text#brush">Brush API</a>，以实现一些颜色渐变，渐变效果是针对整个输入框的，换言之不同的行效果是一样的：</p>

<pre><code class="Kotlin">var text by remember { mutableStateOf("") }
val brush = remember {
    Brush.linearGradient(
        colors = listOf(Color.RED, Color.YELLOW, Color.GREEN, Color.BLUE)
    )
}
TextField(
    value = text, onValueChange = { text = it }, textStyle = TextStyle(brush = brush)
)
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-textfieldgradient.gif" alt="brush_textstyle" /></p>

<h3>与键盘联动</h3>

<p>TextField能够配置软件盘以实现特定输入样式，比如只输入数字，只有英文字符等等，通过TextField的keyboardOptions参数，传入一个<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/KeyboardOptions#KeyboardOptions(androidx.compose.ui.text.input.KeyboardCapitalization,kotlin.Boolean,androidx.compose.ui.text.input.KeyboardType,androidx.compose.ui.text.input.ImeAction">KeyboardOptions</a>)对象。常用的配置项有：</p>

<ul>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/KeyboardCapitalization">capitalization</a> 对于有大小写的语言来说，输入时词首自动大写</li>
<li>autoCorrect 自动更正</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/KeyboardType">keyboardType</a> 键盘类型，如纯字符，纯数字，E-mail地址，网址等等</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/ImeAction">imeAction</a> 让键盘的显示输入完成后的行为相关的按扭，比如<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/ImeAction#Search(">『搜索（Search）』</a>)，<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/ImeAction#Send(">『发送（Send）』</a>)等</li>
</ul>


<p>当输入完成后，用户点了imeAction指定的按扭后，可以指定回调函数以执行相关的操作，通过keyboardActions参数指定一个<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/KeyboardActions">KeyboardActions</a>对象，里面可以指定对应于imeAction中的各种回调，如onSearch会在imeAction指定为Search时，用户点击后触发；onSend会在imeAction是Send时，用户点击触发，等等。</p>

<h3>特殊形式的输入</h3>

<p>有些特殊的场景是不能够直接把用户的输入文本直接的展现在框里，比如输入密码时，再比如像输入电话号码时，可能会自动在3个数字后面加上短横线。这时就需要用到<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/VisualTransformation">VisualTransformation</a>来对文本进行转换处理：</p>

<pre><code class="Kotlin">@Composable
fun PasswordTextField() {
    var password by rememberSaveable { mutableStateOf("") }

    TextField(
        value = password,
        onValueChange = { password = it },
        label = { Text("Enter password") },
        visualTransformation = PasswordVisualTransformation(),
        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password)
    )
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-textfield-password.png" alt="password_textfield" /></p>

<h3>文本状态管理</h3>

<p>TextField的文本（text参数）是需要转换成状态的，这样才能更好的触发重组。基础的通用的TextField使用方式是，把文本转成状态，塞给TextField，然后在其onValueChange中再更新此状态：</p>

<pre><code class="Kotlin">    // ...
    var text by remember { mutableStateOf("") }

    TextField(
        value = text,
        onValueChange = { text = it },
    )
    // ...
</code></pre>

<p>但现实的代码不可能这么简单，用户的输入必然会有业务逻辑去处理，所以onValueChange肯定会调用ViewModel去处理用户输入。那么自然也要从ViewModel处获得。但由于TextField的特殊性，仍然要把使用MutableState来定义状态，而不能用响应式的Reactive stream或者StateFlow：</p>

<pre><code class="Kotlin">class SignUpViewModel(private val userRepository: UserRepository) : ViewModel() {

    var username by mutableStateOf("")
        private set

    fun updateUsername(input: String) {
        username = input
    }
}

// SignUpScreen.kt

@Composable
fun SignUpScreen(/*...*/) {

    OutlinedTextField(
        value = viewModel.username,
        onValueChange = { username -&gt; viewModel.updateUsername(username) }
        /*...*/
    )
}
</code></pre>

<h2>文本的选择</h2>

<p>除了文本输入以外，文本显示的选择也视为文字编辑的一种方式，因为选择之后就可以执行复制或者搜索等全局操作。Compose提供了细粒度的可交互式文本显示控制。Text本身是不支持选择的（Not Selectable），自然也就无法复制。可以使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/selection/package-summary#SelectionContainer(androidx.compose.ui.Modifier,kotlin.Function0">SelectableContainer</a>)来包裹Text以实现可选择（Selectable）：</p>

<pre><code class="Kotlin">@Composable
fun SelectableText() {
    SelectionContainer {
        Text("This text is selectable")
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-selected.png" alt="selectable_text" />
并且，可选择区域可以跨多个Text。与之相对的，还有不可选择函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/selection/package-summary#DisableSelection(kotlin.Function0">DisableSelection</a>)，比如一大片可选择文本中，想让某一小块文本不能被选择，这时DisableSelection就派上用场了：</p>

<pre><code class="Kotlin">@Composable
fun PartiallySelectableText() {
    SelectionContainer {
        Column {
            Text("This text is selectable")
            Text("This one too")
            Text("This one as well")
            DisableSelection {
                Text("But not this one")
                Text("Neither this one")
            }
            Text("But again, you can select this one")
            Text("And this one too")
        }
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-partially-selected.png" alt="disable_selection" /></p>

<p>可以看出对于文本的选择控制还是相当的灵活的（flexible）。</p>

<h2>富式文本点击</h2>

<p>对于针对 整个文本的点击事件可以用Modifier中的<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier">clickable</a>.clickable(kotlin.Boolean,kotlin.String,androidx.compose.ui.semantics.Role,kotlin.Function0))函数来处理，这跟常规的Composable没区别都一样的。但对于文本来说有更为细腻的点击事件处理，包括获取具体点击的光标位置，以及富式文本点击，也即针对 文本中不同部分的响应。</p>

<h3>获取点击的光标位置</h3>

<p>想要获取到文本中点击的光标位置，其实也就是点击的是第几个字符，可以用<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/package-summary#ClickableText(androidx.compose.ui.text.AnnotatedString,androidx.compose.ui.Modifier,androidx.compose.ui.text.TextStyle,kotlin.Boolean,androidx.compose.ui.text.style.TextOverflow,kotlin.Int,kotlin.Function1,kotlin.Function1">ClickableText</a>)，它有一个自己的onClick回调函数，里面的参数是一个offset表示被点击字符的索引：</p>

<pre><code class="Kotlin">@Composable
fun SimpleClickableText() {
    ClickableText(text = AnnotatedString("Click Me"), onClick = { offset -&gt;
        Log.d("ClickableText", "$offset -th character is clicked.")
    })
}
</code></pre>

<p>注意onClick的参数是文本字符串的索引，从0开始。这个索引一般用来确定点击的富文本中的某一个标记（Annotation）。</p>

<h3>富文本的点击处理</h3>

<p>Text是支持富文本的（基于<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/AnnotatedString">AnnotatedString</a>）。通过ClickableText中onClick的索引参数，就能知道点击的具体是哪个Annotation。比如一个超链接标记，具体的URL对用户是不可见的，作为额外的Tag信息在Annotation中，通过索引判断当点击到了超链接上面时，可以跳转到此URL：</p>

<pre><code class="Kotlin">@Composable
fun AnnotatedClickableText() {
    val annotatedText = buildAnnotatedString {
        append("Click ")

        // We attach this *URL* annotation to the following content
        // until `pop()` is called
        pushStringAnnotation(
            tag = "URL", annotation = "https://developer.android.com"
        )
        withStyle(
            style = SpanStyle(
                color = Color.Blue, fontWeight = FontWeight.Bold
            )
        ) {
            append("here")
        }

        pop()
    }

    ClickableText(text = annotatedText, onClick = { offset -&gt;
        // We check if there is an *URL* annotation attached to the text
        // at the clicked position
        annotatedText.getStringAnnotations(
            tag = "URL", start = offset, end = offset
        ).firstOrNull()?.let { annotation -&gt;
            // If yes, we log its value
            Log.d("Clicked URL", annotation.item)
        }
    })
}
</code></pre>

<h2>总结</h2>

<p>本文介绍了两种最常规的文本编辑，一是文本输入，一个是文本的选择和点击，这些都是日常项目开发中的非常常见的需求。Jetpack Compose对文本的操作提供了非常友好的支持，能够应付绝大部分的需求场景。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/text/user-input">Handle user input</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/text/user-interactions">Enable user interactions</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
