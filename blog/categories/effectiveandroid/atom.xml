<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2015-08-16T09:21:09+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[实战技巧：Android异步指南]]></title>
    <link href="http://toughcoder.net/blog/2015/05/25/effective-android-asynchrony/"/>
    <updated>2015-05-25T23:49:19+08:00</updated>
    <id>http://toughcoder.net/blog/2015/05/25/effective-android-asynchrony</id>
    <content type="html"><![CDATA[<p>异步向来都是提高性能的必要手段，当然也是引发问题的常见根源。Android之中更是如此，主线程事关应用的流畅程度，所以把更多能放在工作线程中事，放到工作线程中去，是提升App性能之必经之路。Android中使用线程有多种方式，我们该如何选择，以及在使用过程中要注意哪些问题，今天就来探讨一下。</p>

<p><a href=""><img src="http://image.slidesharecdn.com/scandev-120418025620-phpapp02/95/threading-in-android-1-728.jpg?cb=1334718039"></a></p>

<!-- more -->


<h2>Bitmap处理</h2>

<p>在Android中显示图片，<a href="http://developer.android.com/reference/android/graphics/Bitmap.html">Bitmap</a>是必须要学会的。Bitmap是Android中抽象出来代表图片的类，把图片文件或者数据转化成Bitmap进而再放置到视图系统中显示。Bitmap的处理也常常会引发OOM问题。</p>

<p>关于Bitmap的处理，遵守二个原则，就是按需解析和及时释放。现在的图片文件都很大，但很多时候我们需要展示的区域（目标View的大小）却不是很大，这个时候就需要在解析的时候，适当的降低帧率，以减小所需要申请的内存。及时释放时也需要注意，要确定不用了，再释放，如果有View仍在显示时，在另外的地方把Bitmap释放了，那会引发异常的。</p>

<p>对于Bitmap的使用，<a href="http://developer.android.com/training/displaying-bitmaps/index.html">官方文档</a>有着比较详细的教程。现在的Android文档是很齐全的，相比较2010年代时2.0和2.1时多了很多最佳实践，所以不要浪费。</p>

<p>除内存外，Bitmap的处理也是比较耗时的，因为它经常涉及IO，以及压缩和处理，即使不耗时，因为它跟UI没关系，所以也是可以放在工作线程中去做的。Android中记住一个准则就是主线程做的事情越少越好，越少你的应用就越流畅。至于如何具体的去做也建议参考<a href="http://developer.android.com/training/displaying-bitmaps/process-bitmap.html">官方教程</a>。</p>

<h2>异步的方式</h2>

<p>在Android中异步实现的方式非常多：</p>

<ul>
<li>Thread</li>
<li>AsyncTask</li>
<li>Executors</li>
<li>Handler, Looper</li>
</ul>


<p>各种方式的使用方法参阅相关文档或者查阅网上浆料就可以了。这里主要说一下区别和适用的场景：</p>

<h3>Thread</h3>

<p>这是Java的简单粗暴的方式，优点就是简单，方便。对于某些简单的，一次性的，不需要与主线程通信和操作UI，不是很频繁（一次启动执行一次），的费时操作，直接使用Thread方式还是相当方便的。</p>

<h3>AsyncTask</h3>

<p>这是Android中专门针对平台本身的特性而封装的一个类，它的优势在于与主线程通信方便，能非常方便的操作UI。所以使用AsyncTask的理由就是当你需要在异步操作完成时直接操作UI时，除此外，你不应该使用它。</p>

<p>使用AsyncTask时，最好使用AsyncTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);以免任务不能及时获得执行，详细原因可以看<a href="http://blog.csdn.net/hitlion2008/article/details/8194510">这篇文章</a>。</p>

<h3>Executors</h3>

<p>当有大量的任务，或者重复性的任务需要执行时，就要使用线程池来复用和管理线程。</p>

<h3>Handler与Looper</h3>

<p>这是Android事件循环的基础类，也是AsyncTask的实现方式，是线程间通信的利器。所以如果你有复杂的线程通信（通常是工作线程和主线程之间），可以使用这二个类来自行进行定义。</p>

<h3>其他的高级工具</h3>

<p>对于多线程，已经有足够的工具供我们使用比如java.util.concurrent.*，以及Universal Image Loader，或者EventBus，所以当设计时首先要看现在的工具能否满足我们的需求。而不是自己去实现，子曰：不能重复造轮子，就是就是这个道理。</p>

<h2>异步时要注意Activity的生命周期</h2>

<p>异步时最容易出错的就是忽略Activity的生命周期。比如，当异步执行完成了，Activity却退出了前台，或者已经结束，如果异步完成时要操作UI，那么这种情况下肯定会报错，具体的错误取决于场景。这个问题的解法就是在异步操作完成后要用Activity.isFinishing()来判断下Activity是否还是alive的。或者设置一个变量来查看Activity是否还在前台。</p>

<p>另外，即使异步操作中不涉及UI，那么当Activity转入后台，或者退出时，也要及时的终止工作线程，否则也会造成Activity的对象无法及时销毁而最终导致内存泄露。这个问题需要在设计异步task时把可取消考虑进去，当Activity退出前台时发送消息给线程，让其终止执行。对于常见的费时操作，比如IO，网络，复杂计算等在都要考虑取消，每一个小步骤执行前都要判断取消标志位，以及时终止操作。通常这需要在Activity中持有任务的引用，或者使用Executors来管理任务，或者有一个类似的对象来管理异步任务，当Activity退出时，来终止任务。或者使用EventBus这类工具来降低耦合。</p>

<h2>有用的资源</h2>

<p>关于Android中的异步已经有了一本专门的书了<a href="http://shop.oreilly.com/product/0636920029397.do">《Efficient Android Threading》</a>，内容还是比较丰富的，可以看一看。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android布局技巧：使用TextView的drawable属性]]></title>
    <link href="http://toughcoder.net/blog/2015/05/20/android-layout-trick-drawable-of-textview/"/>
    <updated>2015-05-20T23:07:29+08:00</updated>
    <id>http://toughcoder.net/blog/2015/05/20/android-layout-trick-drawable-of-textview</id>
    <content type="html"><![CDATA[<p>在布局中Icon+文字组成一个视觉上的元素是非常普遍的需求，或者是成为一个可点击的整体，或者是展示某种信息。比如顶部导航栏（ActionBar或者是自已定义实现的类似功能的）都会有一个返回，通常都是一个向左的Icon加上一个文字标签。</p>

<p><a href=""><img src="http://www.gaditek.com/blog/wp-content/uploads/2013/08/Android-App-Development-Tips-Tricks-for-Beginners.jpg" title="auto auto" ></a></p>

<p>这种需求实现起来也是非常的简单，初学安卓的同学也能很快的写出来，一个ImageView加上一个TextView，外面再包一层LinearLayout或者RelativeLayout。Okay，这没有问题，但有更好的实现方式，这需要三个View对象，一个外层group，一个ImageView一个TextView，可以仅使用一个TextView对象，达到同样的效果。</p>

<!-- more -->


<h2>TextView的drawable属性</h2>

<p>TextView有一些属性可以在Text的四周设置一个drawable对象，图片,shape等合法的drawable都可以用。</p>

<ul>
<li> drawableStart API 14才有</li>
<li> drawableLeft</li>
<li> drawableTop</li>
<li> drawableBottom</li>
<li> drawableRight</li>
<li> drawableEnd  API 14才有</li>
<li> drawablePadding 用以设置drawable与text之间的空间</li>
</ul>


<p><a href="http://developer.android.com/reference/android/widget/TextView.html#attr_android:drawableStart">它们的含义</a>就像其名字所暗示的那样，left/top/right/bottom就是在文字的上下左右放置drawable。而drawableStart和drawableEnd则有特殊的意义，虽然它们是API 14加上去的，但是要在API 17后才能真正的生效，它们的作用是当语言方向发生变化时，会换边，LTR语言drawableStart在左边，而drawableEnd在右边；但对于RTL语言来说就会反过来drawableStart在右，drawableEnd在左。可以看<a href="http://stackoverflow.com/questions/13907618/whats-the-different-between-drawableleft-and-drawablestart-in-edittext">这个解释</a>。</p>

<p><img class="<a" src="href="http://7u2scv.com1.z0.glb.clouddn.com/tctextview-drawable.png">http://7u2scv.com1.z0.glb.clouddn.com/tctextview-drawable.png</a>&#8221;></p>

<pre><code class="xml">&lt;TextView android:text="Text along with Image\nsecond\nthird\nforth\nfifth" android:layout_width="400dip"
        android:layout_height="wrap_content"
        android:drawableStart="@drawable/ic_launcher"
        android:drawableLeft="@drawable/ic_launcher"
        android:textSize="16sp"
        android:paddingTop="10dip"
        android:paddingBottom="10dip"
        android:paddingLeft="10dip"
        android:gravity="center"
        android:drawablePadding="5dip"/&gt;;
</code></pre>

<h2>TextView的drawable的一些注意事项</h2>

<ol>
<li>TextView的padding作用在drawable之外</li>
<li>TextView的高度或宽度为wrap_content时将是文字和drawable中较大的那一个，再加上padding和margin</li>
<li>gravity只对文字起作用，对drawable不起作用</li>
<li>drawable会在其所在的维度居中显示，比如drawableLeft是上下垂直居中的，以此类推</li>
</ol>


<h2>局限性</h2>

<p>有些时候它也有一些局限性而没有办法用它：</p>

<ol>
<li>当drawable本身没有高度时（比如shape），这个drawable高度就会依赖于文字，因为padding是加在drawable之外，所以只会依赖于文字的高度。有些时候这不是想要的结果。</li>
<li>当Icon需要与文字分开单独控制时，很显示这要分成二个View。</li>
<li>当需要对Icon进行特殊的个性化时，比如添加背景，特效等。</li>
<li>其他一些造成无法使用的。</li>
<li>除上述情况外，就要考虑使用drawable了。</li>
</ol>


<h2>why bother?</h2>

<p>有同学可能会问，有什么区别，为啥费这么大劲折腾，也就省了二个view对象而已嘛？这位同学可以坐下了，孤来说明下：首先，作为开发者要有永不止境的学习和优化的意识，即使带来的效果是微小的，能用一个对象搞定的，为啥用三个呢？其次，对于整体不复杂的页面，这样带来的效果确实不明显，但是对于超复杂的页面，页面的布局有上百个View时，比如Launcher或者淘宝系的应用，就会带来明显的收益。还有，汇集小溪而成大河，把所有小的点都优化到了极致，那么整体肯定会得到质的飞跃。</p>

<p>子曰：学无止境，技术和优化也无止境啊，各位同学可以多用用Google系的应用，以及国外的优质应用(Facebook, Twitter等），你会发现，虽然应用也很复杂，比如Google+它的页面里展示的元素也非常多，但是为什么用起来是那么流畅。就在于Google里的Android开发都是专家级的人物，他们牛在什么地方，就牛在他们总能用最好的方式来实现，就在于他们总能找到一个对象就能解决我们靠三个对象才能搞定的方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android实战技巧：Fragment的那些坑]]></title>
    <link href="http://toughcoder.net/blog/2015/04/30/android-fragment-the-bad-parts/"/>
    <updated>2015-04-30T00:40:26+08:00</updated>
    <id>http://toughcoder.net/blog/2015/04/30/android-fragment-the-bad-parts</id>
    <content type="html"><![CDATA[<p>Fragment是Android在3.0（Homeycomb)版本时加入的用以更灵活的构建多屏幕界面的可UI组件。关于Fragment以基本使用方法可以参考官方的<a href="http://developer.android.com/guide/components/fragments.html">教程</a>和<a href="http://developer.android.com/training/basics/fragments/index.html">最佳实践</a>，以及<a href="http://toughcoder.net/blog/2014/10/22/effective-android-ui-architecture/">选择Activity还是Fragment</a>。
但是Fragment使用起来却远没有教程中说的那样简单，也远比Activity要复杂一些，这里总结了孤在使用Fragment时所遇到的坑。</p>

<p><a href=""><img src="http://www.opensourceforu.com/wp-content/uploads/2011/05/Figure-1-Design-Principle.png" width="480" height="320"></a></p>

<!-- more -->


<h2>嵌套Fragment时Duplicated id或者Tag之痒</h2>

<p>这是一个小坑，但是初学者很容易遇到，特别是在Fragment之中套有Fragment时，且又是布局中添加子Fragment时更容易遇到。</p>

<h3>现象：</h3>

<p>Fragment中套有另一个Fragment，当第二次进入父Fragment时或者由Fragment创建的界面时会抛异常，大致意思是子Fragment的Id或Tag重复了。如果你在layout中给子fragment加了id或者tag，那么一定会遇到此异常。</p>

<h3>原因：</h3>

<p>在添加Fragment时都可以为Fragment指定一个Id或者Tag用以标识这个Fragment。因为每个Activity所附带的Fragment都是放在一个对象池中，在Activity的生命周期里，Fragment仍然在池中，即使是把某一个Fragment从Activity中detach掉（也即用FragmentManager pop掉），这个池是由FragmentManager来管理的。当你再次要以某个id或者Tag添加Fragment时，FragmentManager会在池中检索，如果发现已经存在Fragment对象带有此Id或者Tag时，就会抛此异常并报怨Id重复。这么做的目的就是减少对象的创建，尽可以的复用对象。</p>

<h3>如何破解：</h3>

<ol>
<li>在布局中写fragment时，不要添加id或者tag；</li>
<li><p>如果非要添加id或者tag，就在代码中添加fragment，如使用Id或者Tag时，先到FragmentManager中查找对象是否存在，不存在时再创建，也即：</p>

<pre><code class="java">  Fragment target = getFragmentManager().findFragmentByTag("tag");
  if (target == null) {
      targe = new SomeFragment();
  }
  FragmentTransaction ft = getFragmentManager().beginTransaction();
  ft.add(R.id.content, target, "tag");
  ft.commit();
</code></pre></li>
</ol>


<h2>replace之痛</h2>

<h3>现象：</h3>

<p>当有二个相同的整体页面层叠时，想把最后一个布局中的某个用Fragment来replace，会发现，它把前面的replace，后面的没效果。</p>

<h3>原因：</h3>

<p>布局的Id在一个窗体（Activity)中是唯一的，Fragment的replace也是使用此唯一的Id来把相应布局替换成Fragment的。当相同的页面层叠时，同一个Id的布局出现了二次，但Id是一样的。所以FragmentTransaction在replace时仅替换了一个。而不会像期待的那样，替换最后一个页面。</p>

<h3>如何破解：</h3>

<p>如果相同的页面非要层叠，要么不使用Fragment，要么为布局设置不同的Id。这种情况多出现在布局的复用上面，比如某二个页面长的像，所以复用了同一整体布局。但实际的逻辑上不是相同的页面，完全可以为布局设置不同的Id。</p>

<h2>可见性之疼</h2>

<h3>现象：</h3>

<p>当有多个Fragment层叠在一起时，每个Fragment如何能感知其对用户的可见性。比如应用有三个页面，A，B和C，比如A是整体类别列表，B是每个类别的详情，C又是类别的某种更详细的信息，当C显示出来时，A和B怎么能知道它其实对于用户已经不可见了，所以就可以不刷新，不加载数据等等。当C被用户BACK后，B又如何感觉它变成可见了？</p>

<h3>原因：</h3>

<p>Fragment的生命周期与Activity是一样的，添加到Activity会把OnCreate类似的回调走一遍，然后，Activity onResume/onPause/onstart/onStop时，其所持有的Fragment也走相应的onResume/onPause/onstart/onPause。但是Fragment与Activity非常不同的是，Activity当有另一个Activity显示时，当前的Activity会走onPause/onStop，而Fragment则完全没有感知。最多只能从FragmentManager那里知道BackStackState改变了，但是是Fragment增加了，还是减少了，并不能知道。</p>

<h3>如何破解：</h3>

<p>这个一个非常令人蛋疼的问题，简单的页面还好，但是涉及到数据加载或者要针对某些事件（网络）刷新时就有问题了，对用户不可见的页面没必要刷新。可行的解法就是：</p>

<ol>
<li>监听FragmentManager的BackStackState的改变</li>
<li>定义页面路径深度然后与BackStack深度比较，以感知是否对用户可见
  如前面A是一级，其path为1，B是2，C是3。当前Stack深度为3时，C是可见的，A与B不可见，以此类推。</li>
</ol>


<h2>空白区域的点击之脓</h2>

<h3>现象:</h3>

<p>一个Fragment，层叠在另外一个Fragment或者Activity之上，此Fragment中有一些空白区域，也即Widget之外的空白区域，当点击这些空白区域的时候发现这个Fragment下面的Fragment或者Activity中的View收到了事件并且响应了点击事件。</p>

<h3>原因：</h3>

<p>Fragment的本质就是一个View布局的管理器，当Fragment attach到Activity时，其实就是把Fragment#onCreateView()返回的View，替换掉(如果是用replace)FragmentTransaction#replace中指定的View，或者添加到(如果是add)FragmentTransaction#add()中指定的ViewGroup里面。</p>

<p>当我们以层叠方式显示多个Fragment时，通常的做法就是弄一个FrameLayout，然后每次把Fragment add到此布局。因此，这时Activity的页面布局树实际上就是一个FrameLayout里面包含几个View。</p>

<p>所以，当点击上面Fragment的空白区域时，如果事件没被吃掉，就会向下传递。</p>

<h3>如何破解：</h3>

<p>在Fragment的根布局加上一个clickable=true，这会让根布局把点击事件吃掉，以防止事件会继续传递下去，造成上面的情况。</p>

<h2>Activity重新创建之殇</h2>

<h3>现象：</h3>

<p>这个没有一般性的错误，只会有与项目相关的具体的错误异常，或者页面显示不正确。以及为什么教程中都有这么一句：
<code>java
@Override
onCreate(Bundle savedInstance) {
   if (savedIntance == null) {
      // create fragment and add it to Activity.
   }
}
</code></p>

<h3>原因：</h3>

<p>Activity除了正常启动走到onCreate，还有另外的入口，比如系统配置信息发生变化时，或者Activity在栈比较深的地方，系统会把Activity杀掉，然后再<em>重新创建</em>它，问题就是在这个重新创建。重新创建与新建一个Activity不同，它是要尽可能的恢复先前所在的状态，因为这对用户来说是透明的，也就是说不能让用户感知到，否则体验会相当差。唯一与常规创建的区别就在于传给onCreate的参数savedInstanceState是不是null.</p>

<h3>如何破解：</h3>

<p>为了能在Activity重建时恢复状态，需要：</p>

<ol>
<li><p>对于Activity</p>

<p>要在onSaveInstanceState()时，把一些变量保存，然后在onCreate时恢复</p></li>
<li><p>对于Fragment</p>

<p>告诉系统，你想恢复状态Fragment#setRetainInstance(true)。然后，也在onSavedInstance()中保存状态，在onCreate时恢复。
这就够了，系统会在重新创建Activity时把其所持有的Fragment也创建出来。所以为什么每个Fragment子类都需要定义一个默认的Constructor。更多的可以参考<a href="http://www.androiddesignpatterns.com/2013/04/retaining-objects-across-config-changes.html">这篇文章</a>。</p></li>
</ol>


<h2>FragmentTransaction的异步操作之殇</h2>

<p>FragmentTransaction是异步的，commit()仅是相当于把操作加入到FragmentManager的队列，然后FragmentManager会在某一个时刻来执行，并不是立即执行。所以，真正开始执行commit()时，如果Activity的生命周期发生了变化，比如走到了onPause，或者走到了onStop，或者onDestroy都走完了，那么就会报出IllegalStateException。具体的原因，以及如何避免可以参考大牛的<a href="http://www.androiddesignpatterns.com/2013/08/fragment-transaction-commit-state-loss.html">这篇文章</a>。</p>

<h2>参考</h2>

<ul>
<li><a href="http://developer.android.com/guide/components/fragments.html">Fragments</a></li>
<li><a href="http://developer.android.com/training/basics/fragments/index.html">Building a Dynamic UI with Fragments</a></li>
<li><a href="http://www.androiddesignpatterns.com/2013/08/fragment-transaction-commit-state-loss.html">Fragment Transactions &amp; Activity State Loss</a></li>
<li><a href="http://www.androiddesignpatterns.com/2013/04/retaining-objects-across-config-changes.html">Handling Configuration Changes with Fragments</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android NDK开发的一些技巧]]></title>
    <link href="http://toughcoder.net/blog/2015/04/27/android-ndk-backward-compatibility/"/>
    <updated>2015-04-27T23:34:58+08:00</updated>
    <id>http://toughcoder.net/blog/2015/04/27/android-ndk-backward-compatibility</id>
    <content type="html"><![CDATA[<p>Android NDK(Native Development Kit)是基于Java JNI的使用C/C++和Java来混合开发应用的一种方式，甚至在Android 2.3(API 9)以后可以用Native(Native这个字在不同的语境中意义是不一样的，这里指的是JNI中的C/C++的代码；如果放在Hybrid中Native就是指平台原生的语言和API)代码来创建标准界面组件Activity，换句话说就可以用纯C/C++来写一个Android应用，但是貌似还没有人这么干过，这只是一种理论上的可能性。因为除了Activity以外很多东西比如权限，广播通知等等很多东西在Native中还是不够方便。</p>

<p><a href=""><img src="http://androids.zone/wp-content/uploads/2014/06/android-ndk.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>函数签名的写法</h2>

<p>Java代码中调用Native的代码还是比较简单的，把方法声明成为native，然后可以当作普通的Java方法一样来使用，只不过这个native的方法的实现是在Native中。</p>

<p>JNI是一个桥梁，让不同的语言能够在一起使用，不但Java能调用Native层代码，在Native层也是能够调用Java的代码。但是JNI的最初目的是能够让Java使用C/C++语言来解决Java做不到的事情，所以在Native中调用Java的方法要稍微费一点劲。要获取JNI的执行环境(JNIEnv)，要找到类和对象，更重要的是要写对函数签名，否则是找不到的。</p>

<h3>函数签名的写法</h3>

<p>&ldquo;(<em>[type1]</em>;<em>[type2]</em>&hellip;)<em>[return types]</em>&rdquo;</p>

<p>type包括：</p>

<ul>
<li> B = byte</li>
<li> C = char</li>
<li> D = double</li>
<li> F = float</li>
<li> I = int</li>
<li> J = long</li>
<li> S = short</li>
<li> V = void</li>
<li> Z = boolean</li>
<li> V = void</li>
<li> Lfully-qualified-class = fully qualified class. For instance String &ndash; Ljava/lang/String;</li>
<li> [type = array of type</li>
</ul>


<p>Samples:
   * &ldquo;(Ljava/lang/String;I)V&rdquo; // void foo(String str, int limit);</p>

<h2>线程解惑</h2>

<p>Native的代码是执行在其直接调入的Java的方法所在的调用栈里的，比较绕，简单来说吧，JNI的方法也是一个方法，只不过它是在Native层实现的，所以都是一系列的方法的调用，因此调用栈从Java层开始，一直到Native，JNI不会改变调用栈，因此也不会改变线程环境，除非你让它改变。</p>

<p>当你改变线程时，就要注意了，如果你在Native用pthread开启了一个新的线程，且这个线程又需要与Java通信，要调用Java层的方法，那么常规的方式是不行的，要先把线程attach到JNI环境，findClass也不会找到相应的类，因为这个线程是pthread_create出来的，不具备JNI的环境，甚至常规的类，方法和对象的引用在新衍生出的线程中统统都是无效的。</p>

<p>那么该如何做呢？首先，要先调用AttachCurrentThread来把线程attach到JVM；然后，把要在此线程里访问的Java类，方法和对象生成JVM的Global引用，也就是NewGlobalRef来保存引用；最后，当完成与Java的通信后要调用DetachCurrentThread来做detach。</p>

<h2>注意内存问题</h2>

<p>到了Native的环境，就要注意内存问题，因为Native的代码都是要手动的申请内存，手动的释放。当然，业务逻辑里面的申请和释放用标准的new/delete或者malloc/free，或者用智能指针之类的。JNI部分是有封装好的方法的，比如NewGlobalRef，NewLocalRef, DeleteGlobalRef, DeleteLocalRef等。</p>

<p>需要注意的是用这些方法创建出来的引用要及时的删除。因为这些引用都是在JVM中一个表中存放的，而这个表是有容量限制，当到达一定数量后就不能再存放了，就会报出异常。所以要及时删除创建出来的引用。</p>

<h2>版本的兼容性</h2>

<p>使用SDK开发应用时可以用minsdk和targetsdk来解决版本的兼容性问题，minsdk指定最低SDK版本要求，targetsdk指定目标的版本。但在NDK，只能用一个android-target来指定最低的版本要求，其实这就是限定了在NDK你能使用的API的范围。为了保证最好的兼容性，要保证NDK中的android-target与minsdk保持一致。</p>

<p>SDK中的做法是指定了minsdk后，选择尽可能高的targetsdk，这样可以获取最好和最新的编译toolchains的支持。但是NDK中不建议这样做，尽管你没有使用高版本的API，但是使用高版本来编译会链到高版本的库，有可能会导致问题，因为高版本的某些API实现方式会变。比如signal.h中的signal函数，如果使用android-21编译，那么在低于5.0 版本的手机上是跑不起来，错误是无法找到signal函数，原因就是5.0以后signal.h中的signal函数的实现方式变了。</p>

<h2>支持64位</h2>

<p>5.0开始，Android有了64位处理器了。对于以Java作为平台语言的Android来说，特别是广大的应用开发者来说，这并不需要做什么特殊的处理。但是对于涉及到Native的代码时就要注意了，在编译的时候要为arm64准备东西了。在编译的时候要为arm64编译出一个target。</p>

<p>但是问题来了，arm64只有当android-target设置为21时才能编译出来，而我们的应用不可能只target到5.0，前面讲到了我们要对齐到最低版本。解决方案就是构建二次：</p>

<ul>
<li> 第一次正常target到最低版本构建出arm和armeabi-v7a的库</li>
<li> 第二次target到21，编译出arm64的库</li>
</ul>


<p>再把这些so打包起来就可以了。</p>

<h2>多多参考NDK文档以及官方教程和指导</h2>

<p>使用任何的别人提供的东西，最好获取帮助的方式就是看人家给你的文档和指导。现在的文档都写的很详细了。Android开发者官网上面也有很多关于NDK开发的<a href="http://developer.android.com/training/articles/perf-jni.html">教程</a>，都值得仔细读一读的。</p>

<h2>使用第三方工具来简化开发</h2>

<p>最好的开发方式不是自己写，而是去用别人现有的东西，子曰：不能重复造轮子。NDK的开发，也是有一些第三方的工具来帮助我们减少开发量的。<a href="http://swig.org/">SWIG</a>就是一个优秀的工具，它能免去写丑陋的JNI方法的痛苦，而且SWIG是编译工具链的一个组件，不是运行时，所以不会带来性能上的损失。</p>

<h2>不错的书籍</h2>

<p><a href="http://www.apress.com/9781430248279">《Pro Android C++ with NDK》</a>是一本相当不错的书籍，有中文版本了，可以好好的读一读。</p>

<h2>参考资料</h2>

<ul>
<li><a href="http://docs.oracle.com/javase/6/docs/technotes/guides/jni/spec/invocation.html">The Invocation API</a></li>
<li><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html">The JNI Functions</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[诡异的EOF Exception]]></title>
    <link href="http://toughcoder.net/blog/2015/01/31/unexpected-eof-exception/"/>
    <updated>2015-01-31T17:00:39+08:00</updated>
    <id>http://toughcoder.net/blog/2015/01/31/unexpected-eof-exception</id>
    <content type="html"><![CDATA[<p>近日在写一个简单的HTTP代码中遇到了诡异的EOFException,当读取ResponseCode的时候就抛出了EOF异常,感觉很诡异,下面进行问题还原,以及分析和解决过程.</p>

<h2>问题</h2>

<p>有问题的代码如下:</p>

<!-- more -->


<pre><code class="java">    private void testEcho() {
        String payload = "The quick brown fox jumps over the lazy dog.";
        try {
            HttpURLConnection conn = null;
            BufferedReader br = null;
            try {
                String ep = Base64.encodeToString(payload.getBytes(), Base64.URL_SAFE);
                URL u = new URL("http://httpbin.org/get?p=" + ep + "&amp;key=testEcho");
                conn = (HttpURLConnection) u.openConnection();
                conn.setRequestMethod("GET");
                conn.setDoInput(true);
                conn.setDoOutput(false);
                conn.connect();
                if (conn.getResponseCode() != HttpURLConnection.HTTP_OK) {
                    Log.e(TAG, "http res " + conn.getResponseCode() + ", msg : " + conn.getResponseMessage());
                    return;
                }
                br = new BufferedReader(new InputStreamReader(conn.getInputStream()));
                String buf = null;
                while ((buf = br.readLine()) != null) {
                    Log.e(TAG, "HTTP res: " + buf);
                }
            } finally {
                if (br != null) {
                    br.close();
                }
                if (conn != null) {
                    conn.disconnect();
                }
            }
        } catch (IOException e) {
            Log.e(TAG, "ioexception ", e);
        }
    }
</code></pre>

<p>这段代码进行后会在getResponseCode()这行抛出EOFException:
<a href=""><img src="http://7u2scv.com1.z0.glb.clouddn.com/eof.png" title="auto auto" ></a>
很疑惑,百思不得解,这是一个简单的GET请求,却抛出了这样难以理解的异常.于是去Google,发现都认为是Android本身的问题,要加上connection close
<code>java
conn.setRequestProperty("Connection", "close");
</code>
比如,<a href="http://stackoverflow.com/questions/19258518/android-httpurlconnection-eofexception">这个讨论</a>,以及<a href="http://stackoverflow.com/questions/15411213/android-httpsurlconnection-eofexception">这个讨论</a>.
尝试了,但仍没有解决掉抛出的EOFException.</p>

<h2>分析与解决</h2>

<p>这个时候就要冷静的分析下,先从根本开始,怀疑一切,把请求的每一句都打印出来,突然发现URL竟然含有一个CRLF换行符(\r\n). 感觉奇怪,于是查阅文档,发现Base64在编码的时候会默认给结果加上CRLF以换行,于是再加一个Flag, NO_WRAP后,问题解决:
<code>java
     String ep = Base64.encodeToString(payload.getBytes(), Base64.URL_SAFE | Base64.NO_WRAP);
</code></p>

<h2>深入分析</h2>

<p>问题是解决了,但感觉没有完全弄明白.于是做了多次尝试,发现只要URL中部含有换行(\n或\r\n)都会引发此问题,而在尾部则没事.
<a href="http://7u2scv.com1.z0.glb.clouddn.com/eof_req.png"><img src="http://7u2scv.com1.z0.glb.clouddn.com/eof_req.png" title="auto auto" ></a>
这是请求包
<a href="http://7u2scv.com1.z0.glb.clouddn.com/eof_res.png"><img src="http://7u2scv.com1.z0.glb.clouddn.com/eof_res.png" title="auto auto" ></a>
这是Server回应</p>

<p>通过抓包可以看出,换行符会导致发送的HTTP请求包不完整,Server返回也认为HTTP是trunk的,所以期待更多的数据,因此这个时候是没有response的,任何对response的读操作(getResponseCode(), getResponseMessage(), getInputStream())都会立即抛出EOFException.</p>

<h2>总结</h2>

<p>虽然这个问题不大,但是也还值得总结一下:</p>

<ol>
<li><p>遇到问题先检查没犯低级错误</p>

<p>也就是说,当遇到诡异的问题时,先查看文档,检查参数,确保是否是在按正确的方式在做事情,这很关键,因为很多时候都是我们犯了低级错误,比如拼写错误,或者没传正确的参数,或者解错了API等.因为越是简单的错误越容易被忽略.</p></li>
<li><p>问Google和其他人</p>

<p>Google一下或者问下身边的人,可能会很有帮助</p></li>
<li>如果还搞不定,那就真的是遇到难题了,这个时候只能去查阅源码和书籍,定位出问题,分析原因,解不解得了,就看造化了.</li>
<li><p>找Plan B</p>

<p>不用认死理儿,一条路不通,可走另外的路,或者搭个桥什么的.</p></li>
</ol>

]]></content>
  </entry>
  
</feed>
