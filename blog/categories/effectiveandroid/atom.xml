<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2024-11-10T23:19:00+08:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[用Compose中的CompositionLocal来暗渡陈仓]]></title>
    <link href="https://alexhilton.github.io/blog/2024/11/10/understanding-composition-local/"/>
    <updated>2024-11-10T23:17:56+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/11/10/understanding-composition-local</id>
    <content type="html"><![CDATA[<p>通过<a href="https://juejin.cn/column/7367555191338467337">前面的学习</a>我们知道Jetpack Compose是一个声明式的UI框架，采用的是函数式编程思想，直观上来看就是一坨函数从上调到下。当函数需要数据时，会通过函数调用的参数来传递，一般来说这也没有什么问题。但当需要的数据特别多时，特别是对于一些非业务逻辑本身的数据（输入与输出），如上下文环境变量（Context，或者主题之类），都通过函数调用的参数传递就难免会让代码变得非常的庞杂和臃肿。这时候就可以使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/CompositionLocal">CompositionLocal</a>，一种在组合树中隐式的从上到下传递数据的方法，我们来具体地看一下。</p>

<p><a href=""><img src="file:///Users/alexhilton/Downloads/compose_libs/compositionlocal.png" title="auto auto" ></a></p>

<!-- more -->


<p><strong>注意：</strong> Compose中的函数通常叫做composable，可以简单的理解为同一个东西。从根composable开始，一个套一个的调用，自上而下的意思就是指composable的调用顺序，根函数在上，被调用的函数在下。函数调用是可以传递参数的，正常的从上到下的数据传递都是通过函数调用时的参数。</p>

<p>废话不多说，我们先来看一下什么是CompositionLocal以及它能做什么事情。</p>

<h2>什么是CompositionLocal</h2>

<p>CompositionLocal提供一种<strong>自上而下</strong>的数据传递方式，<strong>隐式的传递</strong>，也就是说，不用把数据放在参数里传递给子函数，子函数像在类中的方法访问域变量那样直接访问。我们来看一个粟子。</p>

<p>比如说，页面中有一个文案，可能需要定制字体颜色，常规方式是这样子写：</p>

<pre><code class="Kotlin">@Composable
fun MyApp() {
    val colors = colors()
    SomeTextLabel(text, colors.onPrimary)
}

@Composable
fun SomeTextLabel(labelText: String, color: Int) {
    Text(
        text = labelText,
        color = color
    )
}
</code></pre>

<p>文案的颜色，以及像背景等等这些东西是与整个App的配置相关的，或者与运行环境（如手机）的主题风格有关的，它并不是应用程序的业务逻辑。它属于上下文环境变量，其变化往往是由于运行环境变化而变化，或者是由于用户更改了应用的配置。这就非常适合使用CompositionLocal来转化为隐式数据传递，进而简化代码，使用后就变成酱婶儿的：</p>

<pre><code class="Kotlin">@Composable
fun MyApp() {
    // 在上级函数中定义主题相关的颜色，并定义为CompositionLocal
    val colors = staticCompositionLocalOf( colors() )
    CompositionLocalProvider(LocalColors provides colors) {
        SomeTextLabel(text)
    }
}

// 被调用的子函数
@Composable
fun SomeTextLabel(labelText: String) {
    Text(
        text = labelText,
        color = LocalColors.onPrimary // 可以直接访问定义好的颜色
    )
}
</code></pre>

<p>通过这个示例可以看出，定义了CompositionLocal以后，在被调用到的所有子函数中（desendants）都可以直接使用，就像访问全局变量那样。这就是CompositionLocal的作用，在指定的作用域中提供隐式的数据。</p>

<h2>如何使用CompositionLocal</h2>

<p>使用起来非常的方便，就像在类的方法中使用域变量那样，或者像使用全局变量那样，找到上级所定义的的CompositionLocal实例，然后引用其中的变量即可。</p>

<p>其实，已经在不知不觉中经常地使用了CompositionLocal，主题风格相关的<a href="https://developer.android.com/reference/kotlin/androidx/compose/material3/MaterialTheme">MaterialTheme</a>，Android的上下文<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/package-summary#LocalContext(">LocalContext</a>)以及像绘制时常用的<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/package-summary#LocalDensity(">LocalDensity</a>)，这些都是CompositionLocal实例，是由Compose定义好的顶层实例，在所有的composables中都可以直接使用。</p>

<p>需要理解的是CompositionLocal实例，本身并不是一个数据，它更像是一个集装箱，它本身是一个数据传递的机制，会在后面定义CompositionLocal实例时详细讲解。</p>

<p>另外，需要特别注意的是CompositionLocal是有作用域的，对其所有的子函数生效，并且也可以嵌套的，<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/CompositionLocal#current(">属性current</a>)引用的是最近一层父函数（closest ancestor）中绑定的值。比如说：</p>

<pre><code class="Kotlin">@Composable
fun CompositionLocalExample() {
    MaterialTheme {
        // 绑定一个值到LocalContentColor
        CompositionLocalProvider(LocalContentColor provides MaterialTheme.colorScheme.primary) {
            Surface {
                Column {
                    Text("Uses Surface's provided content color")
                    // 重新绑定一个值到LocalContentColor
                    CompositionLocalProvider(LocalContentColor provides MaterialTheme.colorScheme.error) {
                        DescendantExample()
                    }
                }
            }
        }
    }
}

@Composable
fun DescendantExample() {
    // current会指向最后绑定的值，即MaterialTheme.colorScheme.error
    Text(text = "This Text uses the error color now", color = LocalContentColor.current)
}
</code></pre>

<h2>如何定义一个CompositionLocal</h2>

<p>大部分时候Compose中定义好的就够我们用了，但也可以针对具体的场景来自定义一个CompositionLocal。分为两个步骤，创建实例，和绑定数据。</p>

<p>CompositionLocal实例是一个集装箱，用以封装需要从顶层往底层传递的数据，这些数据也不一定非要是常量，也是会改变的，比如应用或者页面上下文环境变化时，或者整个应用的配置发生变化时。</p>

<h3>创建CompositionLocal实例</h3>

<p>第一步是先创建一个实例，有两种方法创建一个CompositionLocal实例，这两种方式的主要区别就在于当数据变化时如何影响着重组（reComposition）：</p>

<ul>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#compositionLocalOf(androidx.compose.runtime.SnapshotMutationPolicy,kotlin.Function0">compositionLocalOf</a>) 当数据发生变化时仅会影响读取数据函数的重组；</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#staticCompositionLocalOf(kotlin.Function0">staticCompositionLocalOf</a>) 当数组变化时，提供数据的所有子函数都会被重组。</li>
</ul>


<p>可以发现，这两个方法的区别就在于影响重组的范围，前一个是影响着读取数据的地方，这与状态（State）一样；后一个则是影响着所有的被调用的composables。</p>

<pre><code class="Kotlin">// LocalElevations.kt file

data class Elevations(val card: Dp = 0.dp, val default: Dp = 0.dp)

// 使用Elevations的默认值构造一个全局的CompositinLocal实例
// 这个实例可以被应用中的所有composables访问得到
val LocalElevations = compositionLocalOf { Elevations() }
</code></pre>

<p><strong>注意：</strong> 为了更好的可读性和可维护性，CompositionLocal实例的命名应该以Local开头，如LocalColors。</p>

<h3>把数据绑定到实例中去</h3>

<p>光创建实例没什么用，创建完实例后，还需要把数组绑定到CompositionLocal实例中去，并<strong>同时指定作用域</strong>，这是非常关键的一步，不但决定了CompositionLocal中有什么数据，还决定了谁可以使用这些数据。使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#CompositionLocalProvider(kotlin.Array,kotlin.Function0">CompositionLocalProvider</a>)来绑定数据：</p>

<pre><code class="Kotlin">// MyActivity.kt file

class MyActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContent {
            // 基于系统主题来计算具体的elevation
            val elevations = if (isSystemInDarkTheme()) {
                Elevations(card = 1.dp, default = 1.dp)
            } else {
                Elevations(card = 0.dp, default = 0.dp)
            }

            // 把上面计算得到的elevation绑定到LocalElevations
            CompositionLocalProvider(LocalElevations provides elevations) {
                // ... Content goes here ...
                // 这里的子composables都可以直接访问LocalElevations.current
                // 以得到elevation
            }
        }
    }
}
</code></pre>

<p>函数CompositionLocalProvider接收一个CompositionLocal实例和一个composable lambda，这个lambda就是这个实例的作用域，也即此lambda所调用的所有composables都可以使用访问此实例的数据。参数LocalElevations就是实例，可以看前面的创建代码。LocalElevations provides elevation这是infix符号式写法，相当于LocalElevations.provides(elevation)，elevation则是具体的数据，这意思就是在此lambda的作用域中，CompositionLocal实例LocalElevations会提供数据elevation。</p>

<pre><code class="Kotlin">@Composable
fun SomeComposable() {
    // 使用的地方直接通过LocalElevations.current就能访问到
    MyCard(elevation = LocalElevations.current.card) {
        // Content
    }
}
</code></pre>

<p>这里多说一下，compositionLocalOf是更为精细化的控制（fine-grained control），因为，当数据发生变化时，在作用域中只有读取了数据的composables才会被重组；而staticCompositionLocalOf影响范围较大，因为（当数据发生变化 时）整个作用域内（即CompositionLocalProvider的lambda）的composables都会被重组。</p>

<h2>什么时候该用CompositionLocal</h2>

<p>CompositionLocal提供了一种新的数据传递方式，当数据需要在一定作用域内（Scoped）分享时，就可以考虑使用它。但并不是所有的场景都适用，具体来说，要符合以下标准：</p>

<ul>
<li>数据要是非业务逻辑数据，也就是非代码所直接需要的输入和输出。</li>
<li>数据要有一个极其合理的初始值（默认值）。</li>
<li>数据不一定要是常量，也可以变化，但是业务逻辑并不是数据变化的原因。</li>
<li>数据的使用有一定的作用域。并且在作用域内<strong>所有的composables都可能会</strong>使用此数据。这一点很重要，如果仅仅是某个特定的composable使用，那就直接传参就好了。</li>
</ul>


<p>适合使用CompositionLocal的数据有应用的主题风格，应用的配置信息，平台提供的上下文变量，平台的配置信息，或者对于一个局部来说是上下文变量的数据（比如说一个Dialog用到的数据）。除此之外，绝大部分时候不应该使用CompositionLocal。特别是涉及业务逻辑代码本身强相关的数据（输入与输出），一定不能使用CompositionLocal，这会让代码极难理解和维护，造成极难调试的Bug。</p>

<p>CompositionLocal的一个大的特点就是有明确的作用域，那么如何选择合适的作用域呢？总的来说应该让作用域越小越好。视数据的 影响范围和使用范围来决定其作用域：</p>

<ul>
<li>整个应用级别的（App level），如主题风格，应用配置，平台的配置信息，或者会话数据（user sessions）。应该在根composable，即setContent处绑定数据。</li>
<li>整个页面级别的（Screen level），如平台上下文变量（Context或者Density），导航，或者页面内部的定制参数。</li>
<li>组件级别的（Component level），页面中某一个局部，比如Dialog的主题风格，或者Dialog并不直接操作，但却依赖的数据。</li>
</ul>


<p>任何工具都是为了适合其的场景而生的，要了解清楚什么场景适合使用非常重要，切忌滥用。</p>

<h2>它与状态（State）的区别是什么</h2>

<p>从前面的文章<a href="https://juejin.cn/post/7376094685495001139">降Compose十八掌之『鸿渐于陆』| State</a>我们了解到，状态（State）是为了重组时数据不丢失，也就是说在composable多次运行时，数据能够得以留存。反过来状态变化了，也会触发重组，因为要刷新UI。状态是时间上的概念（使用此状态的composables）多次运行，状态持有的数据都得以保存，不会变成初始值。如果想要使用状态，必须当作参数传递过去。</p>

<p>而CompositionLocal是为了能在不同的composables中共享数据，不用参数传递，它是空间上的概念。</p>

<p>它们是为了解决不同的问题而设计出来的。可以把状态绑定到CompositionLocal中去，但其实没必要这么做，因为内部实现上已经会把绑定的数据封装为状态，因为CompositionLocal的数据是可能发生变化的，并且当变化时，也是要触发重组的。</p>

<h2>它与全局变量的区别是什么</h2>

<p>Kotlin语言是支持顶级全局变量（Top level globals）的，也就是与class平齐，在任何class之外的全局变量，其作用域是整个进程，任何导入（import）此变量的地方都可以访问。Compose是基于Kotlin语言的，所以Compose也是可以使用全局变量的。</p>

<p>全局变量的缺点是没有作用域，容易失控，仅应该用于常量，并且它也不能用于composables的重组。虽然全局变量可以跨越空间，让所有函数都能访问。全局变量是编程语言层面的东西，仅适用于常量的定义，也即整个应用程序运行期间确定不会发生改变的值。</p>

<p>这正是CompositionLocal有价值的地方，它能限定作用域，又可以触发重组，允许数据值改变，又可以跨越空间。这是Compose框架层面提供的工具，自然更适合在Compose中使用。</p>

<h2>总结</h2>

<p>调用函数时传递参数可谓是『明修栈道』，而CompositionLocal则是『暗渡陈仓』，提供了一种在组合（Composition）中自上而下隐式传递数据的一种方式，可以让函数调用只关心与逻辑相关的输入数据。恰当的使用CompositionLocal可以有效的管控上下文环境变量，并极大地简化代码，让代码更加的优雅和简洁。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/compositionlocal">Locally scoped data with CompositionLocal</a></li>
<li><a href="https://www.valueof.io/blog/compose-compositionlocal-compositionlocalprovider">Passing data using CompositionLocal</a></li>
<li><a href="https://www.kodeco.com/34513206-compositionlocal-in-jetpack-compose">CompositionLocal in Jetpack Compose</a></li>
<li><a href="https://medium.com/mobile-innovation-network/understanding-composition-local-jetpack-compose-4546605df5e1">Understanding Composition Local: Jetpack Compose</a></li>
<li><a href="https://medium.com/@ramadan123sayed/composition-local-in-jetpack-compose-4d0a54afa67c">Composition Local in Jetpack Compose</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给Jetpack Compose添加Native支持]]></title>
    <link href="https://alexhilton.github.io/blog/2024/11/08/android-jni-made-easy/"/>
    <updated>2024-11-08T22:40:32+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/11/08/android-jni-made-easy</id>
    <content type="html"><![CDATA[<p>Jetpack Compose是一个声明式的UI框架，但一个项目不可能光有UI，还需要有业务逻辑。Compose所用的编程语言是Kotlin，一种基于JVM的多范式通用编程语言，尽管非常强大，但因为现代的项目都非常复杂，多语言混合，有些东西用Kotlin没法实现，或者有些现成的C/C++代码可以复用，这时就需要能把native代码集成到Compose项目中去。</p>

<p><a href=""><img src="https://questdot.com/wp-content/uploads/2016/07/ndkjni-720x340.png" title="auto auto" ></a></p>

<!-- more -->


<p>想要在Compose中使用native代码是完全可行的，这是因为Compose是基于Kotlin的，而Kotlin本质上是JVM的字节码，也就是运行在虚拟机之上的语言。Java的Native接口，即JNI其实是虚拟机开出的口子，只要能在JVM上运行就可以用JNI，所以标准的Java JNI是完全可以用在Compose里面的。</p>

<p><strong>注意：</strong> native代码（原生代码）在不同的语境有不同的意思，它通常指操作系统直接支持的可执行程序。Java（字节码）是运行在虚拟机上的，操作系统被虚拟机给隔离了，对Java是透明的，这时像可以编译为直接在操作系统上运行的代码（如C/C++）称为native代码；假如换个语境，如运行在WebView中的Web前端，则可以直接运行在Android上的或者iOS上的原生SDK代码则称为native代码。</p>

<p>先来看一下如何在Compose项目中添加native支持。</p>

<h2>新项目</h2>

<p>新的项目在创建项目的时候可以选择C++，无论是Kotlin的类，以及C++的实现，以及配置文件都会有模板。但除了demo以外，一般不会有新建项目的机会，极少项目是从0开始。绝大多数情况都是在现有项目中添加native支持，所以我们重点看看如何在现有项目中添加native支持。</p>

<h2>现有项目添加JNI支持</h2>

<p>现在的Android Studio已经对JNI有了很好的支持，AGP中也提供了支持，所以可以不用NDK中命令行式的ndk-build了。对于现有项目想添加JNI支持也不麻烦，有两种方式：一种是添加一个native的Module，新建Module时选择native library就可以了，这个Module里面与新建的Native项目是差不多的。这种方式适合于比较独立的一个新的需要native支持的模块，然后此模块再作为主模块的依赖，比较合适的场景是一个独立的功能模块；</p>

<p>第二种方式就是，像新建 的native项目那样，直接添加native支持：</p>

<h3>Step 1 添加C/C++源码目录</h3>

<p>先在对应的module如app中添加cpp源码目录，要放在与java或者kotlin同级别的目录，如app/src/main/下面，之后所有native层的东西都在app/src/main/cpp下面。</p>

<h3>Step 2 设置CMake</h3>

<p>在建 好的目录下面添加源码LocalJNI.cpp和编译文件CMakeLists.txt。</p>

<pre><code class="Bash">cmake_minimum_required(VERSION 3.22.1)

project("effectivejni")

add_library(${CMAKE_PROJECT_NAME} SHARED
        # List C/C++ source files with relative paths to this CMakeLists.txt.
        LocalJNI.cpp)
target_link_libraries(${CMAKE_PROJECT_NAME}
        # List libraries link to the target library
        android
        log)
</code></pre>

<p>CMake是一个跨平台的C/C++编译系统，可以参考 <a href="https://cmake.org/">其官文档</a>了解详细信息。</p>

<h3>Step 3 在Gradle脚本中添加native build关联</h3>

<p>在android块中加入externalNativeBuild：</p>

<pre><code class="Kotlin">android {
    // ...
    externalNativeBuild {
        cmake {
            path("src/main/cpp/CMakeLists.txt")
            version = "3.22.1"
        }
    }
}
</code></pre>

<h3>Step 4 添加带有native方法的类</h3>

<p>这一步要特别注意，因为JNI是Java Native Interface，所以必须要严格符合Java的方式，native方法的声明必须是某个类的方法；另外，JNI调用Java时也必须先找到某个类，然后再调用它的方法。所以必须 要有一个Java的public类：</p>

<pre><code class="Kotlin">package net.toughcoder.effectivejni

class LocalJNI {

    external fun stringFromLocal(): String

    companion object {
        init {
            System.loadLibrary("effectivejni")
        }
    }
}
</code></pre>

<p>当然，这个类可以放在任何文件中。因为Kotlin放宽了Java的限制，在Java中每一个public的类必须要放在一个名字一样的文件中，但Kotlin的文件与类没有对应的关系，所以可以把这个类放在任何文件中，当然了package要指明，因为在JNI中查找class时，要指定package name。</p>

<h3>Step 5 实现native方法</h3>

<p>具体native方法的实现就看具体要做什么了。这里只是演示所以简单返回一个字符串。</p>

<pre><code class="C++">#include &lt;jni.h&gt;
#include &lt;string&gt;

extern "C" JNIEXPORT jstring JNICALL
Java_net_toughcoder_effectivejni_LocalJNI_stringFromJNI(
        JNIEnv* env,
        jobject /* this */) {
    std::string hello = "Hello from C++ with static mapping";
    return env-&gt;NewStringUTF(hello.c_str());
}
</code></pre>

<p><strong>注意：</strong> 虽然Compose使用的编程语言是Kotlin，但毕竟Kotlin是JVM语言，也与Java可以相互替换。对于JNI来说，Kotlin与Java无区别，所以后面会以Java来统一当作native的另一端。</p>

<h2>JNI注册</h2>

<p>无论是用C/C++去实现native接口，还是复用现成的native方法，都需要要把native方法与Java层声明的方法进行关联映射，以让JVM能找到此方法的实现，这也即所谓的JNI注册。有两种方式进行JNI注册。</p>

<p>静态方式，其实就是Java默认支持的方式，它要求Native的实现函数是纯C的，要用『extern C』包裹起来，还有就是方法的名字要是Java&#95;包名&#95;类名&#95;方法名，比较严格。前面的示例用的就是静态注册。</p>

<p>动态注册的原理是加载so的时候，当虚拟机在找到so以后，会查找里面一个叫做JNI&#95;OnLoad的函数指针，然后执行此函数。那么，在so的实现中，写一个叫做JNI&#95;OnLoad的函数，在里面手动进行Native方法注册，然后当so被加载时JNI&#95;OnLoad就会被执行，JNI方法就注册好了。</p>

<pre><code class="C++">#include &lt;jni.h&gt;
#include &lt;string&gt;

// Method declaration
jstring dynamicString(JNIEnv *env, jobject thiz);

// JNI wrapper
const char className[] = "net/toughcoder/effectivejni/LocalJNI";

const JNINativeMethod methods[] = {
        {"stringFromJNI", "()Ljava/lang/String;", reinterpret_cast&lt;void *&gt;(dynamicString)}
};

JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved) {
    JNIEnv *env;
    if (vm-&gt;GetEnv(reinterpret_cast&lt;void **&gt;(&amp;env), JNI_VERSION_1_6) != JNI_OK) {
        return JNI_ERR;
    }
    jclass clazz = env-&gt;FindClass(className);
    env-&gt;RegisterNatives(clazz, methods, (int) (sizeof(methods) / sizeof(methods[0])));

    return JNI_VERSION_1_6;
}

// The implementation
jstring dynamicString(JNIEnv *env, jobject thiz) {
    std::string str = "String from JNI via dynamic mapping.";
    return env-&gt;NewStringUTF(str.c_str());
}
</code></pre>

<p>这个JNI&#95;OnLoad的方法的参数很有意思是一个JavaVM对象指针，JavaVM对象每个应用进程只有一个，可以认为就是应用的虚拟机。但每个JNI方法都有一个JNIEnv对象指针，它给native方法提供一个JNI上下文，这个则是每个线程都有一个。</p>

<p>推荐使用动态注册方式进行JNI注册，这是因为这种方式更为灵活，不必写繁琐的方法声明，也不必用extern C限制，可以是常规的C++函数。</p>

<h2>JNI是一个接口层</h2>

<p>JNI是一个口子，可以让Java调用native代码，也能让native代码调用Java代码，调用Java代码就相当于反射。JNI是一个传送门，虽然入口处有一些限制，但深入到native里面就是完全的C和C++世界了，只要是C和C++能实现的事情都可以做。</p>

<p><img src="file:///Users/alexhilton/Downloads/JNI.svg" alt="图1. JNI是一个传送门" /></p>

<h2>JNI线程</h2>

<p>需要注意的是结构体JavaVM是所有线程共享，它代表着进程所在的虚拟机。但结构体JNIEnv则是代表着栈中的执行环境（因为JNI仅一个方法，而方法必然运行在某个线程之中），每个线程有一个。创建的局部引用也不能跨线程使用。</p>

<p>从JNIEnv获取JavaVM：env->GetJavaVM(&amp;vm)</p>

<p>从JavaVM获得当前JNIENV：vm->AttachCurrentThread(&amp;env, null)</p>

<p>最好都从Java层来管理线程，JNI只是某些方法的实现。</p>

<p>如果JNI的native代码也很复杂需要线程的话，也可以用pthread创建线程，但也应该维持在一定的作用域范围内，不应该再从此线程去调用Java。这样只会制造混乱。</p>

<h2>两个世界的对象连接</h2>

<p>需要注意JNI是纯C接口，没有对象的概念，入口处的native方法不属于任何C++对象。假如native深入层足够复杂也有一套对象，如何建立起 Java层对象和native对象的连接呢？可以参考Android frameworks的作法，它通常会给Java层的对象有一个整形域变量，用以存放native层对象指针，这样就能建立起来对象与对象的一一对应关系。</p>

<h2>添加已编译好的native库</h2>

<p>JNI是连接Java层与C/C++层的传送门，除了新写的native代码，也可以直接使用已编译好的C/C++的库，静态库libxxx.a和动态库libxxx.so。</p>

<p>预编译的库通常作为JNI的依赖，当然也可以直接加载，前提是so里面已包含了JNI接口。但需要特别注意的是静态的库.a是无法直接在Java中加载的，也即无法通过System.loadLibrary()来加载native的静态库。因此静态库只能作为依赖，要包一层，写一个Wrapper层编译为so，静态库作为so的依赖，然后把so加载为JNI。</p>

<p>通过CMake中的add_library指令来添加预编译好的库，具体可以 <a href="https://cmake.org/cmake/help/latest/command/add_library.html">参考其文档</a>。</p>

<h2>NDK的版本</h2>

<p>在项目的配置gradle文件中可以指定具体的NDK版本：</p>

<pre><code class="Kotlin">android {
    ndkVersion = "28.0.12433566"
}
</code></pre>

<p>NDK的版本可以看<a href="https://developer.android.com/ndk/downloads/revision_history">官方发布历史</a>，NDK主要是指Android提供的native API（C/C++ API），主要是一些系统提供的能力，如音频视频能力，图形图像能力等，可以看<a href="https://developer.android.com/ndk/guides/stable_apis">其接口说明文档</a>，以及<a href="https://developer.android.com/ndk/reference">NDK开发文档</a>。</p>

<h2>C/C++的版本指定</h2>

<p>C++语言自从其诞生，在Java和新一代编程语言出现后，曾一度长期停滞，在泛型，函数式编程，并发上面落后于其他语言，并被诟病。但从C++11开始，（C++语言的版本以年份的后两位来命名，如C++11是指2011年发布的版本，C++17指2017年发布的，以此类推）这门古老的语言焕然一新，增加了很多新时代编程语言的特性，其后的C++17继续前进，到现在的C++20已经完全是一个现代化的编程语言了，lambda，函数式，泛型和并发都有了非常好的支持，甚至已经超越了老对手Java。因此，C++11以后的版本也称为『现代C++（Modern C++）』。</p>

<p>都4202年了，肯定要用最新的C++20才行啊。CMake使用的是LLVM编译器，而LLVM已经完全支持C++20了，但默认的版本使用的是C++17，想要特别的版本，就需要在CMakefile.txt中进行指定，也即通过添加编译选项来指定C++的版本：</p>

<pre><code class="Bash">set(CMAKE_ANDROID_STL_TYPE "c++_shared")
set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -std=c99")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++20")
</code></pre>

<h2>JNI内存管理</h2>

<p>Java层是自动档（自动内存管理），但C/C++是手动档，因此穿过JNI后就需要特别小心内存管理。有一些注意事项：</p>

<ul>
<li>Java 层传过来的对象，不需要手动去释放。比如说传过来的数组或者字符串。</li>
<li>传回给Java层的对象，也不需要手动释放。比如像上面的例子新创建出来的字符串，尽管使用了New，但不需要管。GC会追踪。而且你也没法释放，创建完对象交给Java层了，不确定Java还在不在使用中呢，你咋delete？</li>
<li>只应该管理生命周期全都在native的new出来的对象，和引用。</li>
<li>需要特别注意方法运行的上下文，也即JNIEnv，这个东西每个线程有一个，且是不同的。要保证在同一个JNIEnv中管理内存，不同的JNIEnv无法共享创建出来的对象和引用，不能交叉使用，更不能交叉式的释放。</li>
</ul>


<h2>JNI能做什么</h2>

<p>JNI是一个接口层，能够让Java进入C/C++世界，调用C/C++的代码，包括现有代码。所以只要编译出来了目标平台（ARM）的so，就可以在JNI中用。</p>

<p>当然了，为了兼容性，使用的so最好用NDK进行编译。</p>

<p>因为Android是Linux内核的，所以，理论上Linux系统调用支持的东西全都能在JNI里面搞。当然，使用native最为正确的体位是使用NDK来实现想要的功能，可以查看<a href="https://developer.android.com/ndk/reference">NDK的开发文档</a>来明确可以做哪些事情。</p>

<h2>使用JNI的正确姿式</h2>

<p>JNI虽好，但不要滥用，不能单单以『C/C++语言性能高于Java（JVM）』为理由就去使用JNI。JNI本身是一个口子，单从方法调用角度讲，从Java层调用过来要有历经查询和数据转换，不见得会比Java方法高效到哪里去。而且JNI在线程调度，异常管理和内存管理上面都较Java层相比非常的不方便，那点看起来的性能优势的代价是很大的，所以说能不用JNI就别用。</p>

<p>使用JNI的正确理由：</p>

<ol>
<li>做一些Java层无法做到的事情，比如一些底层的系统调用（System calls），Java层做不到，那自然得用C/C++</li>
<li>使用一些现有的C/C++代码，这个是最为正统的理由</li>
<li>基于安全角度考量，把一些关键的实现放在C/C++层，这个也合理，因为C/C++相较于Java字节码要略难破解一些</li>
<li>基于跨平台角度考虑，把一些与平台关联密切的，且独立的模块用C/C++实现，比如像通信协议，或者加密，或者压缩之类的非常独立的功能模块，用C/C++来实现，屏蔽名个平台的不同，这会让Java层更加的简单</li>
</ol>


<p>除此之外，似乎没有理由使用JNI。另外，在使用的时候也要注意尽可能的单进单出，也就是说从Java层调用native方法，进去后一直在native运算，得到结果后返回给Java。而不应该频繁的有交互，比如说Java层调用进了native方法，但在native中又频繁 的调用Java层的方法。这明显是设计不合理，应该在Java层把需要的数据准备齐全后，再调用native层。</p>

<h2>References</h2>

<ul>
<li><a href="https://juejin.cn/post/7382893339098906665">Android JNI入门</a></li>
<li><a href="https://juejin.cn/post/7302684536148230194">一、Android-JNI开发</a></li>
<li><a href="https://juejin.cn/post/6844903933375152136">Android NDK-深入理解JNI</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1666741">JNI线程相关</a></li>
<li><a href="https://developer.android.com/studio/projects/add-native-code">Add C and C++ code to your project</a></li>
<li><a href="https://developer.android.com/training/articles/perf-jni">JNI tips</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让Activity更加优雅地跳转]]></title>
    <link href="https://alexhilton.github.io/blog/2024/10/14/activity-result-launcher/"/>
    <updated>2024-10-14T22:24:55+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/10/14/activity-result-launcher</id>
    <content type="html"><![CDATA[<p>有过Android开发经验的小伙伴对<a href="https://developer.android.com/reference/android/app/Activity#startActivityForResult(android.content.Intent,%20int">startActivityForResult</a>)以及<a href="https://developer.android.com/reference/android/app/Activity#onActivityResult(int,%20int,%20android.content.Intent,%20android.app.ComponentCaller">onActivityResult</a>)一定不陌生，正是这一对API让组件 的复用变成可能。今天就来学习一下如何在函数式的范式中驾驭Activity的跳转。</p>

<p><a href=""><img src="https://akexorcist.dev/content/images/size/w2000/2021/12/activity_result_api-header.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>缘起</h2>

<p>系统组件复用，特别是Activity的复用，是Android系统中非常重要的一个设计理念。组件复用打破了应用程序之间的壁垒，在整个系统范围内可以共享和复用一些公共的组件，比如像打开网页，拍照片，查看图片等等，开发者不必再用原始API去实现一套，直接使用startActivityForResult和onActivityResult就可以取到需要的资源。</p>

<p>这套API最大的问题在于它并不是常规的异步式的回调，调用了startActivityForResult后，结果的处理，必须要在Activity的继承体系内覆写onActivityResult，并且因为Activity实例只能由系统创建，这就导致了组件复用的逻辑必须都在Activity内部。这就导致了Activity的体积通常会相当的臃肿，上千行，甚至大几千行的Activity随处可见。理想的情况下Activity，作为一个系统的容器和接口，应该越薄越好，但要能把逻辑移出Activity才行。</p>

<p>另一方面，onActivityResult无法在函数式的情境中使用，因为它会跑到函数外面去，比如在Jetpack Compose中就无法直接使用startActivityForResult和onActivityResult。</p>

<p>为了解决这两个问题，就需要使用到Jetpack中的<a href="https://developer.android.com/reference/androidx/activity/result/package-summary">Activity Result API</a>了。</p>

<h2>Activity Result API的使用方法</h2>

<p>在Jetpack的AndroidX中的<a href="https://developer.android.com/jetpack/androidx/releases/activity">Activity</a>和<a href="https://developer.android.com/jetpack/androidx/releases/fragment">Fragment</a>中，可以像常规的回调那样向系统注册一个处理result的回调，一旦系统派发了activity result就能被系统回调到。</p>

<p><strong>注意：</strong> 这里提到的方法都在AndroidX中的<a href="https://developer.android.com/reference/androidx/activity/ComponentActivity">ComponentActivity</a>和<a href="https://developer.android.com/reference/androidx/fragment/app/Fragment">Fragment</a>里面，也就是说要继承AndroidX中的组件才可以。</p>

<h3>注册一个activity result回调</h3>

<p>这套API的方式是在ComponentActivity和Fragment中，提供了一个<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultCaller#public-methods_1">registerForActivityResult</a>方法用于注册activity result的回调。参数是一个<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContract">ActivityResultContract</a>实例和一个<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultCallback">ActivityResultCallback</a>实例。返回的是一个<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultLauncher">ActivityResultLauncher</a>，这个launcher可以用来启动目标Activity，也即触发获取资源的流程，相当于原来的startActivityForResult：</p>

<pre><code class="Kotlin">val getContent = registerForActivityResult(GetContent()) { uri: Uri? -&gt;
    // 处理结果
}
</code></pre>

<p>一个ActivityResultContract，如它的名字所示，定义着组件复用的的接口，即输入类型和输出类型。API中定义了<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContracts">大量的现成可用的，也是常见的接口</a>，比如拍照，权限请求等等。当然也可以创建<a href="https://developer.android.com/training/basics/intents/result#custom">自定义接口</a>。</p>

<p>回调ActivityResultCallback是只有一个方法onActivityResult()的接口，此方法的参数由ActivityResultContract来定义。</p>

<h3>启动目标Activity</h3>

<p>当调用registerForActivityResult时，能拿到一个launcher，但此API仅是向系统注册一个回调，这时还没有启动目标（即还没有发起请求）。发起请求需要使用ActivityResultLauncher来完成。</p>

<p>调用其<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultLauncher#launch(I">方法launch</a>)就会发起请求，启动目标Activity，开启获取结果的流程。如果给launch传递了参数，会依据ActivityResultContract做进一步的匹配（其实这些输入最终会转化为Intent对象提供给startActivityForResult）。用户在目标Activity页面完成了操作后，就会返回到当前页面，回调ActivityResultCallback的方法onActivityResult就会被执行：</p>

<pre><code class="Kotlin">val getContent = registerForActivityResult(GetContent()) { uri: Uri? -&gt;
    // 处理结果，即返回的Uri
}

override fun onCreate(savedInstanceState: Bundle?) {
    // ...

    val selectButton = findViewById&lt;Button&gt;(R.id.select_button)

    selectButton.setOnClickListener {
        // 接口是获取内空，这里传mime type作为参数，那么就是要获取一个图片内容
        getContent.launch("image/*")
    }
}
</code></pre>

<p>如果需要多个组件复用，那就传递不同的参数多次调用registerForActivityResult。并且registerForActivityResult可以在任何时候调用，在onCreate之前调用也是安全的，所以可以在声明ActivityResultLauncher的时候就直接调用，这样可以直接初始化。</p>

<p>但是要特别注意，使用launcher来启动Activity则必须在onCreate之后。</p>

<p>还有一点需要特别注意，因为launch之后，onActivityResult之前这段时间会离开当前的Activity，这个时间内Activity可能会被系统回收，也即触发了状态恢复。所以处理结果时，也即onActivityResult中的逻辑，如果有依赖其他状态，这些状态需要在onSaveInstanceState中进行保存。</p>

<h3>处理结果</h3>

<p>结果的处理就在ActivityResultCallback中的方法onActivityResult，这里使用返回的参数就可以了。</p>

<h2>在Activity之外使用</h2>

<p>如前面所述，使用这套Result API的最大的好处在于把结果的处理从Activity中解耦出来，因此，最为理想的方式是能在独立的class中做这些事情。</p>

<p>这就需要使用<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultRegistry">ActivityResultRegistry</a>，它才是核心，另外三个类（launcher，contract和callback）都是一些封装，事实上Activity和Fragment里面的方法registerForActivityResult其实也是使用这个registry来实现的。从Activity中可以拿到registry的实例，以此作为参数，就可以在自定义的class中使用Result APIs了。</p>

<p>比如单独封装获取图片的流程可以这样写：</p>

<pre><code class="Kotlin">class MyLifecycleObserver(private val registry : ActivityResultRegistry)
        : DefaultLifecycleObserver {
    lateinit var getContent : ActivityResultLauncher&lt;String&gt;

    override fun onCreate(owner: LifecycleOwner) {
        getContent = registry.register("key", owner, GetContent()) { uri -&gt;
            // Handle the returned Uri
        }
    }

    fun selectImage() {
        getContent.launch("image/*")
    }
}

class MyFragment : Fragment() {
    lateinit var observer : MyLifecycleObserver

    override fun onCreate(savedInstanceState: Bundle?) {
        // ...

        observer = MyLifecycleObserver(requireActivity().activityResultRegistry)
        lifecycle.addObserver(observer)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        val selectButton = view.findViewById&lt;Button&gt;(R.id.select_button)

        selectButton.setOnClickListener {
            // 触发获取图片的流程
            observer.selectImage()
        }
    }
}
</code></pre>

<p>这个示例把获取图片的流程（发起和结果处理）都封装在了一个单独的类中，同时又是明是监听了Activity组件的生命周期。谷歌是强烈建议同时要<a href="https://developer.android.com/reference/kotlin/androidx/lifecycle/LifecycleObserver">监听生命周期</a>（通过扩展LifecycleObserver），这是因为<a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner">LifecycleOwner</a>会在destroy时自动帮你反注册ActivityResultLauncher，不然的话就要手动的<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultLauncher#unregister(">反注册</a>)。</p>

<h2>自定义Contract</h2>

<p>尽管谷歌已经在<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContracts">ActivityResultContracts</a>中已经预定义了大量的contracts可以使用，但仍然会有一些特殊的场景因预定义的contract无法满足需求而需要自定义一个contract。这个contract实际上就是约定了组件复用的接口，就像普通的interface一样，定义好输入与输出的类型就可以了，所以需要给contract提供输入输出的类型，如果不需要输入或者输出就使用Void?或者Unit。</p>

<p>此外还需要实现一个<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContract#createIntent(android.content.Context,kotlin.Any">createIntent方法</a>)，这个方法接收一个Context和其他输入（即contract约定的输入，最终是由ActivityResultLauncher中方法launch时提供）作为参数并返回一个Intent对象，此Intent会是startActivityForResult的输入参数。同时还需要实现另外一个<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContract#parseResult(kotlin.Int,android.content.Intent">方法parseIntent</a>)，此方法将<a href="https://developer.android.com/reference/android/app/Activity#onActivityResult(int,%20int,%20android.content.Intent,%20android.app.ComponentCaller">Activity的标准钩子onActivityResult</a>)中的参数resultCode和Intent转化为contract中约定的输出（此输出会作为回调ActivityResultCallback函数方法onActivityResult的输入参数）。</p>

<pre><code class="Kotlin">class PickRingtone : ActivityResultContract&lt;Int, Uri?&gt;() {
    override fun createIntent(context: Context, ringtoneType: Int) =
        Intent(RingtoneManager.ACTION_RINGTONE_PICKER).apply {
            putExtra(RingtoneManager.EXTRA_RINGTONE_TYPE, ringtoneType)
        }

    override fun parseResult(resultCode: Int, result: Intent?) : Uri? {
        if (resultCode != Activity.RESULT_OK) {
            return null
        }
        return result?.getParcelableExtra(RingtoneManager.EXTRA_RINGTONE_PICKED_URI)
    }
}
</code></pre>

<p>如果现有的contracts不满足需求，且也无具体的输入输出要求，那么可以用一个万用contract，即<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContracts.StartActivityForResult">StartActivityForResult</a>。这个万用contract的输入是一个Intent，输出是一个<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResult">ActivityResult</a>，在回调方法onActivityResult中可以直接从ActivityResult实例中取出resultCode和目标返回的Intent对象：</p>

<pre><code class="Kotlin">val startForResult = registerForActivityResult(StartActivityForResult()) { result: ActivityResult -&gt;
    if (result.resultCode == Activity.RESULT_OK) {
        val intent = result.data
        // 处理目标返回的Intent
    }
}

override fun onCreate(savedInstanceState: Bundle) {
    // ...

    val startButton = findViewById(R.id.start_button)

    startButton.setOnClickListener {
        // 传入想要启动的Intent对象
        startForResult.launch(Intent(this, ResultProducingActivity::class.java))
    }
}
</code></pre>

<p>从这里我们可以看出，这套Result API本质上仍是依赖于原始的startActivityForResult和onActivityResult。</p>

<h2>在Compose中使用Result API</h2>

<p>接下来我们看看如何在Jetpack Compose使用这套API，这套API与Activity彻底解耦且支持函数式写法，所以可以在Compose中使用。这套API的核心是ActivityResultRegistry，有了它其他几个就可以使用起来了，而它的实例可以直接从Activity中取出来，所以这套API在Compose中完全可以用起来，与前面讲到的在Activity之外的逻辑完全一样：获取此对象用于register一个contract，同时得到一个launcher对象，在回调中处理结果，在合适的时机触发launch。</p>

<p>幸运的是完全用不着自己折腾，Compose中已经做好了封装，直接使用<a href="https://developer.android.com/reference/kotlin/androidx/activity/compose/package-summary#rememberlauncherforactivityresult">rememberLauncherForActivityResult</a>即可：</p>

<pre><code class="Kotlin">@Composable
fun GetContentExample() {
    var imageUri by remember { mutableStateOf&lt;Uri?&gt;(null) }
    val launcher = rememberLauncherForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? -&gt;
        imageUri = uri
    }
    Column {
        Button(onClick = { launcher.launch("image/*") }) {
            Text(text = "Load Image")
        }
        Image(
            painter = rememberAsyncImagePainter(imageUri),
            contentDescription = "My Image"
        )
    }
}
</code></pre>

<p>今天我们学习了Jetpack中提供的新式处理activity result的方法，这不仅能让在函数式编程范式中复用组件变成可能，也可以把很多逻辑从Activity中抽离出来，能给Activity瘦身，让组件跳转变得更为优雅。</p>

<h2>References</h2>

<ul>
<li><a href="https://blog.dogukangun.de/the-usage-of-activity-result-launcher-9c3d2241ec8">The Usage of Activity Result Launcher</a></li>
<li><a href="https://developer.android.com/training/basics/intents/result">Get a result from an activity</a></li>
<li><a href="https://stackoverflow.com/questions/64721218/jetpack-compose-launch-activityresultcontract-request-from-composable-function">Jetpack Compose: Launch ActivityResultContract request from Composable function</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/libraries">Compose and other libraries</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[喜迎国庆，用Compose赶制一面五星红旗]]></title>
    <link href="https://alexhilton.github.io/blog/2024/10/11/waving-flag-with-compose/"/>
    <updated>2024-10-11T22:38:22+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/10/11/waving-flag-with-compose</id>
    <content type="html"><![CDATA[<p>我们学习Jetpack Compose已经有一段时间了，通过前面的学习已能掌握足够的技巧以在实战中应用。恰逢普天庆国庆，利用我们学过的知识，使用Jetpack Compose来画一个迎风飘扬的五星红旗吧！废话不多说，先来看一眼效果图。</p>

<p><a href=""><img src="file:///Users/alexhilton/Downloads/compose_libs/red_flag.gif" title="auto auto" ></a></p>

<!-- more -->


<h2>五星红旗的设计标准</h2>

<p>需要特别注意，五星红旗有明确的设计标准的，在<a href="https://www.gov.cn/xinwen/2020-12/24/content_5572913.htm">国旗法中有明确的制法说明</a>。</p>

<p>总结一下要点：宽与高之比为3比2，五颗星都在左上四分之一小矩形内，最大五角星直径约为高的十分之一，四个小五角星的一个角要指向大五角星的中心。</p>

<h2>如何画五角星</h2>

<p>五星红旗并不是特别复杂，拆解一下，其组成图案就是矩形和五角星了，矩形是基本的图形可以直接画。需要研究一下五角星怎么画。</p>

<p>画对称多边形的方法都要借助圆，因为几何图形最容易画的同时也是最标准的就是圆了，再借助角度从圆上取点，把点连成线就是多边形。多边形的顶角度数不一样，因此把圆分成多少份，就能画出不同的多边形了。</p>

<p>五角星也要借助圆，把五角星五个顶点连线就是一个正五边形了，所以在圆上取5个等分点，也即每隔72度取一个点，然后把这5个点每隔一点连成线，就是五角星了。如下图所示：</p>

<p><img src="https://www.algebra.com/cgi-bin/plot-formula.mpl?expression=drawing%28330%2C330%2C-6.6%2C6.6%2C-6.6%2C6.6%2Cgrid%280%29%2C%0D%0Ared%28circle%280%2C0%2C6%29%29%2Cline%280%2C6%2C3.527%2C-4.854%29%2Clocate%285.8%2C1.9%2CP%29%2C%0D%0Aline%280%2C6%2C-3.527%2C-4.854%29%2Cline%28-3.527%2C-4.854%2C5.706%2C1.854%29%2C%0D%0Aline%28-5.706%2C1.854%2C5.706%2C1.854%29%2Cline%28-5.706%2C1.854%2C3.527%2C-4.854%29%2C%0D%0Ared%28arrow%280%2C0%2C6.562%2C2.132%29%29%2Cred%28arc%280%2C0%2C4.4%2C4.4%2C-18%2C0%29%29%2C%0D%0Alocate%282.2%2C1%2Cred%2890%5Eo-72%5Eo=18%5Eo%29%29%2Cred%28arc%280%2C0%2C8%2C8%2C-90%2C-18%29%29%2C%0D%0Alocate%282.8%2C3.5%2Cred%2872%5Eo%29%29%2Cgreen%28arrow%280%2C0%2C3.879%2C5.34%29%29%2C%0D%0Agreen%28arc%280%2C0%2C2.2%2C2.2%2C-90%2C-54%29%29%2Clocate%280.1%2C2%2Cgreen%2836%5Eo%29%29%0D%0A%29" alt="图2. 五角星画法" /></p>

<p>这种画法对手工尺规作图很友好，对程序来说，就没那么友好了。程序化的API需要明确的坐标点，把点串连成路径（Path）。这里需要的五角星是填充的，所以如果能知道5个顶点，和凹进来的五个点，只要把这10个点串起来，就能组成一个闭合的图形，得到我们想要五角星了。</p>

<p>五角星的外面五个点和内部五个点能组成两个正五边形，这两个正五边形的外接圆是两个同心圆，外顶点与内顶点刚好相差36度，正五边形的顶点之间是72度。所以，我们通过画两个半径不同的同心圆，每个圆分成5份，大圆的点与小圆的点交错开，就能画出一个五角星了。圆心和半径是关键的参数，通过圆心与半径，就能精细调整五角星的形状。</p>

<p><img src="https://mathalino.com/sites/default/files/images/005-planegeom-pentagram.jpg" alt="图3. 填充式五角星" /></p>

<p>因为五角星是填充色，所以我们把最外层的五个点与内层的五个点连串一起组成一个闭合的图形。通过前面的<a href="https://juejin.cn/post/7381826917086920742">降Compose十八掌之『利涉大川』| Canvas</a>学习，我们知道可以用路径（Path）来画图形，一共10个点把圆分成10分，所以角度是36度，半径是一大一小交错开来：</p>

<pre><code class="Kotlin">   val path = Path().apply {
        val pointNumber = 5
        val angle = PI.toFloat() / pointNumber
        val innerRadius = radius * cos(angle) / 2f

        for (i in pointNumber * 2 downTo 0) {
            val r = if (i % 2 == 1) radius else innerRadius
            val omega = angle * i

            val x = center.x + r * sin(omega)
            val y = center.y + r * cos(omega)
            lineTo(x, y)
        }
    }

    drawPath(
        path = path,
        color = color,
        style = Fill
    )
</code></pre>

<h2>画五星红旗</h2>

<p>根据制法以及画五角星的方法，我们总结一下设计要点：</p>

<ol>
<li>用一个高height作为主要参数，那么宽就是其1.5倍，其他的参数都与height有关系，所以改变height就可以完全控制整个旗子的大小；</li>
<li>大五星圆心x是宽的1/6，y是height的1/4，可以看出比例是一致的，所以可以先计算y，再乘1.5就是x；</li>
<li>大五星的外接圆直径约是height的3/10，半径就是高度的3/20，这样大五星就完全确定了；</li>
<li>小五星的直径是高的1/10，半径就是1/20；从上到下命名为a，b，c，d；</li>
<li>小五星a的圆心x在宽的1/3，y在高的1/10</li>
<li>小五星b的圆心x在宽的2/5，y在高的1/5</li>
<li>小五星c的圆心x在宽的2/5，y在高的7/20</li>
<li>小五星d的圆心x在宽的1/3，y在高的9/20</li>
<li>小五星的角要对着大五星的圆心，也就是要把小五星旋转一下。一个办法对Path做变幻，但其实不用那么复杂。我们在画五角星时，选择点时加上一个偏移角度beta就可以了，这样尖角就有旋转角度了。这个旋转角度可以用小五星的圆心与alpha的圆心来求得，就是这两个圆心连线与水平x轴的夹角，用反正切atan来求。</li>
</ol>


<p>综上，就可以写代码啦：</p>

<pre><code class="Kotlin">@Composable
fun FiveStarsRedFlag(height: Dp = 200.dp) {
    val stickWidth = 10.dp
    val flagWidth = height.times(1.5f)
    val flagHeight = height
    val canvasWidth = flagWidth.plus(stickWidth)
    val canvasHeight = height.times(2f)

    Canvas(modifier = Modifier.size(canvasWidth, canvasHeight)) {
        // The background
        drawRect(color = Color.Red, size = Size(flagWidth.toPx(), flagHeight.toPx()))

        // The stick
        drawRect(color = Color.LightGray, size = Size(stickWidth.toPx(), canvasHeight.toPx()))

        val centerY = flagHeight.toPx() / 4f
        val centerX = flagWidth.toPx() / 6f
        val radius = flagHeight.toPx() * 3f / 20f
        val smallRadius = flagHeight.toPx() / 20f
        val alphaCenter = Offset(centerX, centerY)

        // 大五角星 alpha
        drawStar(
            alphaCenter = alphaCenter,
            center = alphaCenter,
            radius = radius,
            color = Color.Yellow
        )

        // 小五星 a
        drawStar(
            alphaCenter = alphaCenter,
            center = Offset(flagWidth.toPx() / 3f, flagHeight.toPx() / 10f),
            radius = smallRadius,
            color = Color.Yellow
        )

        // 小五星 b
        drawStar(
            alphaCenter = alphaCenter,
            center = Offset(flagWidth.toPx() * 0.4f, flagHeight.toPx() / 5f),
            radius = smallRadius,
            color = Color.Yellow
        )

        // 小五星 c
        drawStar(
            alphaCenter = alphaCenter,
            center = Offset(flagWidth.toPx() * 0.4f, flagHeight.toPx() * 7 / 20f),
            radius = smallRadius,
            color = Color.Yellow
        )

        // 小五星 d
        drawStar(
            alphaCenter = alphaCenter,
            center = Offset(flagWidth.toPx() / 3f, flagHeight.toPx() * 9 / 20f),
            radius = smallRadius,
            color = Color.Yellow
        )
   }
}

fun DrawScope.drawStar(alphaCenter: Offset, center: Offset, radius: Float, color: Color) {
    val pointNumber = 5
    val angle = PI.toFloat() / pointNumber
    val innerRadius = radius * cos(angle) / 2f

    val beta = if (alphaCenter == center) {
        0f
    } else {
        PI.toFloat() / 2f - atan((center.y - alphaCenter.y) / (center.x - alphaCenter.x))
    }

    val path = Path().apply {
        for (i in 0 .. pointNumber * 2) {
            val r = if (i % 2 == 1) radius else innerRadius
            val omega = angle * i + beta

            val x = center.x + r * sin(omega)
            val y = center.y + r * cos(omega)
            lineTo(x, y)
        }
        close()
    }

    drawPath(
        path = path,
        color = color,
        style = Fill
    )
}
</code></pre>

<p>为了检查画图结果是否符合设计，我们可以画出制法中的那样的格子：</p>

<pre><code class="Kotlin">        if (DEBUG) {
            val strokeWidth = 0.8.dp.toPx()

            // Slice
            drawLine(
                Color.Black,
                Offset(stickWidth.toPx(), flagHeight.toPx() / 2f),
                Offset(flagWidth.toPx(), flagHeight.toPx() / 2f),
                strokeWidth = strokeWidth * 2f
            )

            drawLine(
                Color.Black,
                Offset(flagWidth.toPx() / 2f, 0f),
                Offset(flagWidth.toPx() / 2f, flagHeight.toPx()),
                strokeWidth = strokeWidth * 2f
            )

            // Grid
            for (i in 1 until 10) {
                drawLine(
                    Color.Black,
                    Offset(stickWidth.toPx(), flagHeight.toPx() * i / 20f),
                    Offset(flagWidth.toPx() / 2f, flagHeight.toPx() * i / 20f),
                    strokeWidth = strokeWidth
                )
            }

            for (i in 1 until 14) {
                drawLine(
                    Color.Black,
                    Offset(stickWidth.toPx() + flagWidth.toPx() * i / 30f, 0f),
                    Offset(stickWidth.toPx() + flagWidth.toPx() * i / 30f, flagHeight.toPx() / 2f),
                    strokeWidth = strokeWidth
                )
            }
       }
</code></pre>

<p>拿带格子的效果图，与制法设计图对比，可以发现一模一样，完全符合设计。</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/flag_with_grid.png" alt="图4. 带格子的效果图" /></p>

<p>好了，到这里，我们的五星红旗就画完了。未完，别走啊，我们还要让旗子飘扬起来。</p>

<h2>让五星红旗飘扬起来</h2>

<p>旗子飘扬的真实形态是三维的曲面，比如用三角函数曲面计算每一个坐标点x, y, z，就像<a href="https://juejin.cn/post/7206950454098247736">这篇文章</a>中的做法那样。</p>

<p>但在Compose中无法实现，因为Compose，虽然也可以做三维的变幻，但都是针对整个图层的，没有办法针对图形中的每个坐标点去单独做变幻，这也是与三维图形库如OpenGL ES的最大区别。</p>

<p>在Compose中要想每个坐标点都不一样，只能绘制曲线，曲线 的点再由动画动态的去改变，这样就会有类似波动一样的效果，但都局限在二维。为此，我们需要用Path来画背景，上边和下边都用曲线，曲线的点用动画来不断的波动，这样就能有点波动的感觉了：</p>

<pre><code class="Kotlin">    val infiniteTransition = rememberInfiniteTransition(label = "infinite transition")

    val amplitude = with(LocalDensity.current) { height.div(8f).toPx() }
    val heightPx = with(LocalDensity.current) { height.toPx() }

    val waveDuration = 2000
    val ya by infiniteTransition.animateFloat(
        initialValue = amplitude / 2f,
        targetValue = -amplitude / 2f,
        animationSpec = infiniteRepeatable(tween(waveDuration), RepeatMode.Reverse),
        label = "ya"
    )
    val yb by infiniteTransition.animateFloat(
        initialValue = -amplitude / 2f,
        targetValue = amplitude / 2f,
        animationSpec = infiniteRepeatable(tween(waveDuration), RepeatMode.Reverse),
        label = "yb"
    )
    val yc by infiniteTransition.animateFloat(
        initialValue = amplitude / 2f,
        targetValue = -amplitude / 2f,
        animationSpec = infiniteRepeatable(tween(waveDuration), RepeatMode.Reverse),
        label = "yc"
    )

    val ye by infiniteTransition.animateFloat(
        initialValue = heightPx + amplitude / 2f,
        targetValue = heightPx - amplitude / 2f,
        animationSpec = infiniteRepeatable(tween(waveDuration), RepeatMode.Reverse),
        label = "ye"
    )
    val yf by infiniteTransition.animateFloat(
        initialValue = heightPx - amplitude / 2f,
        targetValue = heightPx + amplitude / 2f,
        animationSpec = infiniteRepeatable(tween(waveDuration), RepeatMode.Reverse),
        label = "yf"
    )
    val yg by infiniteTransition.animateFloat(
        initialValue = heightPx + amplitude / 2f,
        targetValue = heightPx - amplitude / 2f,
        animationSpec = infiniteRepeatable(tween(waveDuration), RepeatMode.Reverse),
        label = "yg"
    )

    Canvas(
        modifier = Modifier.size(canvasWidth, height)
    ) {
        val stickOffset = Offset(stickWidth.toPx(), 0f)

        // The background
        val pathBG = Path().apply {
            moveTo(0f, 0f)
            cubicTo(flagWidth.toPx() / 3f, ya, flagWidth.toPx() * 2f / 3f, yb, flagWidth.toPx(), yc)

            lineTo(flagWidth.toPx(), ye)

            cubicTo(flagWidth.toPx() * 2f / 3f, yf, flagWidth.toPx() / 3f, yg, 0f, size.height)

            lineTo(0f, 0f)

            translate(stickOffset)
        }
        drawPath(path = pathBG, color = Color.Red, style = Fill)
   }
</code></pre>

<p>也可以用GraphicsLayer，再添加一点点Y轴和Z轴的旋转，就更像那么回事了：</p>

<pre><code class="Kotlin">val rotateY by infiniteTransition.animateFloat(
        initialValue = -3f,
        targetValue = 6f,
        animationSpec = infiniteRepeatable(tween(3000), RepeatMode.Reverse),
        label = "rotateY"
    )
Canvas(
        modifier = Modifier
            .size(canvasWidth, height)
            .graphicsLayer {
                transformOrigin = TransformOrigin(0f, 0f)
                rotationZ = 2f
                rotationY = rotateY
            }
    ) { ... }
</code></pre>

<p>至此，我们的五星红旗就算做完了，当然了可对背景的左边和右边也加上波动，就会更像一些了，完整代码可以<a href="https://github.com/alexhilton/EffectiveCompose/blob/main/app/src/main/java/net/toughcoder/effectivecompose/WavingFlag.kt">看这里</a>。</p>

<p>让我们小结一下，看似简单的一个五星红旗，实现起来其实并不容易，用到了好多数学知识，书到用时方恨少，数学真的太重要了，无处不在。UI开发会涉及大量的数学（特别是几何）知识，要想做好UI必须 要有良好的数学功底，难度并不小。</p>

<h2>仅供娱乐，请勿参考</h2>

<p>以上的实现方式其实仅供娱乐，在真实的项目中不建议这样一笔一笔的用Canvas来画。建议的实现方式应该是找一个（或者让设计师提供）现成的五星红旗图形资源，然后当成图片来展示 出来。</p>

<p>这样做的好处是把设计与代码实现分离开来，当需要调整设计效果时，不必去修改代码，毕竟替换一个资源比起修改代码的风险要小很多，虽然说可能也只是调整一个整数（颜色），但毕竟是改代码了，风险还是有的。再者，分离开来能让设计工作由更为专业的人士来做，而不必受到（或者考虑）代码实现的限制。还有就是，用代码一笔一笔的画，无论研发效率还是运行效率其实都不高，远不如显示一张图片性能好。</p>

<h2>最后</h2>

<p>祝愿伟大的祖国繁荣昌盛，国泰民安！祝愿所有的朋友国庆快乐，天天开心！</p>

<h2>References</h2>

<ul>
<li><a href="https://codepen.io/jonkemp/pen/EVgaLR">Five-pointed star using CSS</a></li>
<li><a href="https://stackoverflow.com/questions/14580033/algorithm-for-drawing-a-5-point-star">Algorithm for drawing a 5 point star</a></li>
<li><a href="https://www.instructables.com/How-to-draw-a-5-point-star/">How to Draw a 5-point Star</a></li>
<li><a href="https://codepen.io/udit007/pen/XWJooNQ">Waving Flag animation with CSS</a></li>
<li><a href="https://codepen.io/christopheschwyzer/pen/nMoWBa">CSS3 Waving Flags</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搞定在Jetpack Compose中优雅地申请运行时权限]]></title>
    <link href="https://alexhilton.github.io/blog/2024/09/27/handle-permissions-in-compose/"/>
    <updated>2024-09-27T08:36:47+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/09/27/handle-permissions-in-compose</id>
    <content type="html"><![CDATA[<p>随着安全与隐私问题越来越被人们所重视，操作系统对应用程序的限制也越来越严格。一个非常明显的控制就是对于运行时权限（Runtime permissions）的管控是越来越严格，很多原本不需要权限的地方也需要了权限。这就要求应用程序必须能够灵活的处理运行时权限。Jetpack Compose作为一个独立于平台的声明式UI框架，本身并没有权限的概念，权限是平台强相关的，本文将研究一下如何在Compose中优雅的申请运行时权限。</p>

<p><a href=""><img src="https://img-blog.csdnimg.cn/9f802deb822f45a794a15fd9de4bc42d.png" title="auto auto" ></a></p>

<!-- more -->


<p><strong>注意：</strong> 这里提到的权限都是运行时权限，也就是需要在访问某些API之前动态地向用户申请授权许可。</p>

<h2>运行时权限申请用例</h2>

<p>有过Android开发经验的同学对运行时权限申请一定不陌生。自从Android Marshmallow（6.0，API Level 23）开始，对于一些敏感的权限，除了在应用的Manifest中声明以外，还需要在运行时动态的<a href="https://developer.android.com/training/permissions/requesting">向用户申请使用权限</a>，只有在用户同意授权后才可以使用相关的功能，当然用户也可能会拒绝。自此，运行时的权限申请就变成了应用开发的一个标配了。</p>

<p>比如以相机权限为例，第一步，要先在AndroidManifest中声明权限使用：</p>

<pre><code class="xml">&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"&gt;
    &lt;uses-permission android:name="android.permission.CAMERA" /&gt;
    &lt;application
        ...
    &lt;/application&gt;
&lt;/manifest&gt;
</code></pre>

<p>之后第二步，在要使用相机的入口地方，也就是要访问相机API的入口处先进行权限检查，如果已授予，则走正常的逻辑（如打开相机），否则进行权限申请：</p>

<pre><code class="Kotlin">    // 调用相机的入口处
    if (ContextCompat.checkSelfPermission(context, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED) {
        happyWithCamera()
    } else {
        // 提示用户需要权限，然后申请权限
        ActivityCompat.requestPermissions(context,  arrayOf(Manifest.permission.CAMERA), 1024)
    }
</code></pre>

<p>权限申请会离开当前的页面，进入到系统的权限处理逻辑。然后第三步，在系统权限回调中（类似于onActivityResult）检查用户权限授予结果，如果已授予则走第二步中的正常逻辑，否则，弹窗提示用户，解释权限对于应用程序的必要性，视权限的必要程度和交互逻辑，可以再次申请权限或者走无权限的逻辑（假如部分功能还可用）或者直接退出：</p>

<pre><code class="Kotlin">// 系统权限回调，类似于onActivityResult
@Override
public void onRequestPermissionResult(int reqCode, @NonNull String[] perms, @NonNull int[] results) {
    super.onRequestPermissionResult(reqCode, perms, results)
    if (reqCode == 1024) {
        if (results.length &gt; 1 &amp;&amp; results[0] == PackageManager.PERMISSION_GRANTED) {
            // 用户授权了，可以使用相机了
            happyWithCamera()
        } else {
            // 权限被用户拒绝，有三种做法：
            // 1. 如果是必须的权限，可再次申请；
            // 2. 如果已被拒绝多次，或者不想再次申请，那就提示用户然后退出
            // 3. 如果是非必须权限，那就走剩余的流程
        }
    }
}
</code></pre>

<p>如果是多个权限，处理的方式也是一样的，因为申请权限以及权限回调中都是数组，也即是可以处理多个权限。</p>

<p>对于在何时着手处理权限，要视权限对业务逻辑的重要程度，如果是必须的权限（如Location于地图应用，Camera于相机应用）那应该在应用启动时，加载任何页面之前作为第一件事情去做；如果不是，非主要业务逻辑，如微信或者支付宝的扫码功能，绝大多数应用都有扫码功能但都非其主要业务逻辑，那应该在用户启动扫码功能时去处理相机权限。</p>

<h2>以原生方式申请运行时权限</h2>

<p>让我们回到Compose世界，因为在Jetpack Compose中没有权限的概念，因此要把原生的权限处理方式在Composable中完成。第一步权限的声明仍需要在应用程序的Manifest中来做，这一步是没有变化的。</p>

<p>第二步和第三步有些麻烦，Compose是由一坨坨的composable函数组成的，我们只能调用其他的函数，没有办法处理权限回调，这是Activity的一个public方法，不是可以设置的常规回调，因为我们没有办法创建Activity的实例。另外前面的例子中请求权限会用到Activity，而在Compossable中不应该去尝试获取Activity，虽然是可以拿到实例的，但作为一个独立的UI框架不应该去拿平台强相关的且生命周期不可控的对象实例。</p>

<p>这里就可以通过一个叫做<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultLauncher">ActivityResultLancher</a>来对Activity的跳转和onActivityResult进行封装，创建一个ActivityResultLancher实例，设置一个onResult回调来处理onActivityResult，这个launcher也可以用来启动新的Activity。本质上与覆写Activity的方法也是一样的，但最重要的是我们可以自主的创建ActivityResultLancher对象，这样就可以在纯函数式的composable中使用了。ActivityResultLancher可以应对很多跳转场景，由<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContract">ActivityResultContract</a>对象来定义，已经有很多预定义类型了，对于申请权限要使用<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContracts.RequestPermission">RequestPermission</a>。</p>

<p>仍是以相机权限为例，假定是一个相机权限强必须的拍照应用，可以在应用的入口处定义PermissionInterceptor来处理权限：</p>

<pre><code class="Kotlin">class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            HelloComposeTheme {
                // A surface container using the 'background' color from the theme
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    PermissionInterceptor(
                        content = {
                            Text("Happy with Camera!")
                        },
                        noPermission = {
                            Text("To use this app, you must grant CAMERA permission!")
                        }
                    )
                }
            }
        }
    }
}

@SuppressLint("LaunchDuringComposition")
@Composable
fun PermissionInterceptor(
    modifier: Modifier = Modifier,
    content: @Composable BoxScope.()-&gt;Unit,
    noPermission: @Composable BoxScope.()-&gt;Unit
) {
    val context = LocalContext.current
    val permission = Manifest.permission.CAMERA

    var isGranted by remember { mutableStateOf&lt;Boolean?&gt;(null) }
    val permissionLauncher = rememberLauncherForActivityResult(
        ActivityResultContracts.RequestPermission()
    ) { granted -&gt;
        isGranted = granted
    }

    Box(modifier = modifier, contentAlignment = Alignment.Center) {
        if (isGranted == true ||
            ContextCompat.checkSelfPermission(
                context,
                permission
            ) == PackageManager.PERMISSION_GRANTED) {
            content()
        } else if (isGranted == null) {
            LaunchedEffect(permissionLauncher) {
                permissionLauncher.launch(permission)
            }
        } else {
            noPermission()
        }
    }
}
</code></pre>

<p>需要注意是如果是像上面例子这样在应用的入口处时就检查并申请权限，需要把launcher包裹在副作用函数LauncherEffect中，否则会有『IllegalStateException: Launcher has not been initialized』，这是因为初始化工作并未做完，但如果是用户点击之后才会触发权限申请则不需要。</p>

<p>在实际项目中，可能不止一个权限需要申请。申请多个动态权限，流程逻辑也一样的，需要传入<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContracts.RequestMultiplePermissions">RequestMultiplePermissions</a>，以及参数和结果都是数组：</p>

<pre><code class="Kotlin">@Composable
fun MultiplePermissionsInterceptor(
    modifier: Modifier = Modifier,
    content: @Composable BoxScope.()-&gt;Unit,
    noPermission: @Composable BoxScope.()-&gt;Unit
) {
    val context = LocalContext.current
    val permissions = arrayOf(
                        Manifest.permission.CAMERA,
                        Manifest.permission.ACCESS_COARSE_LOCATION,
                        Manifest.permission.ACCESS_FINE_LOCATION
                    )
    var isGranted by remember { mutableStateOf&lt;Boolean?&gt;(null) }
    val permissionLauncher = rememberLauncherForActivityResult(
        ActivityResultContracts.RequestMultiplePermissions()
    ) { granted -&gt;
        isGranted = granted.all { it.value }
    }

    Box(modifier = modifier, contentAlignment = Alignment.Center) {
        if (isGranted == true ||
            permissions.all {
                ContextCompat.checkSelfPermission(
                    context,
                    it
                ) == PackageManager.PERMISSION_GRANTED
            }
        ) {
            content()
        } else if (isGranted == null) {
            LaunchedEffect(permissionLauncher) {
                permissionLauncher.launch(permissions)
            }
        } else {
            noPermission()
        }
    }
}
</code></pre>

<h2>使用Accompanist-permissions</h2>

<p>事实上谷歌也在着手解决Compose中的权限处理问题，在<a href="https://google.github.io/accompanist/permissions/">accompanist库中有处理权限</a>的API。</p>

<blockquote><p><a href="https://google.github.io/accompanist/">Accompanist</a>是一个由谷歌提供的Jetpack Compose的补充库，也就是说一些开发者强烈需求的API，但还未正式放入Compose中，但谷歌也有意要提供，那么就会先放放Accompanist中，等开发完成试用很好，可能就会移入到Jetpack Compose中变成正式的API。Accompanist中能找到很多新奇的东西，比如像下拉刷新，流式布局，权限处理，WebView等等。但需要注意的是Accompanist多半是试验性的，API很不稳定，说变就变，说没就没，使用之前要三思。</p></blockquote>

<h3>配置accompanist-permission</h3>

<p>Accompanist是一个独立的库，而且拆分的很细，权限处理是一个独立的包：</p>

<pre><code class="Kotlin">dependencies {
    // Accompanist permission
    val accompanistVersion = "0.32.0"
    implementation("com.google.accompanist:accompanist-permissions:$accompanistVersion")
}
</code></pre>

<h3>使用Accompanist-permission</h3>

<p>既然是API自然在封装上会做的更好，使用起来更加的方便。Accompanist使用<a href="https://google.github.io/accompanist/api/permissions/com.google.accompanist.permissions/remember-permission-state.html">rememberPermissionState</a>和<a href="https://google.github.io/accompanist/api/permissions/com.google.accompanist.permissions/remember-multiple-permissions-state.html">rememberMultiplePermissionsState</a>返回一个状态<a href="https://google.github.io/accompanist/api/permissions/com.google.accompanist.permissions/-permission-state/index.html">PermissionState</a>，这个状态既可以检查权限申请结果，也可以去申请权限，体验丝般顺滑：</p>

<pre><code class="Kotlin">@OptIn(ExperimentalPermissionsApi::class)
@Composable
fun AccompanistInterceptor(
    modifier: Modifier = Modifier,
    content: @Composable BoxScope.()-&gt;Unit,
    noPermission: @Composable BoxScope.()-&gt;Unit
) {
    val permissionState = rememberPermissionState(permission = Manifest.permission.CAMERA)

    Box(modifier = modifier, contentAlignment = Alignment.Center) {
        if (permissionState.status.isGranted) {
            content()
        } else if (permissionState.status.shouldShowRationale) {
            noPermission()
        } else {
            LaunchedEffect(permissionState) {
                permissionState.launchPermissionRequest()
            }
        }
    }
}
</code></pre>

<p>处理多个权限时用带有multiple字样的接口就可以了：</p>

<pre><code class="Kotlin">@OptIn(ExperimentalPermissionsApi::class)
@Composable
fun MultipleAccompanistInterceptor(
    modifier: Modifier = Modifier,
    content: @Composable BoxScope.()-&gt;Unit,
    noPermission: @Composable BoxScope.()-&gt;Unit
) {
    val permissions = listOf(
                        Manifest.permission.CAMERA,
                        Manifest.permission.ACCESS_COARSE_LOCATION,
                        Manifest.permission.ACCESS_FINE_LOCATION
                    )
    val permissionState = rememberMultiplePermissionsState(permissions = permissions)

    Box(modifier = modifier, contentAlignment = Alignment.Center) {
        if (permissionState.allPermissionsGranted) {
            content()
        } else if (permissionState.shouldShowRationale) {
            noPermission()
        } else {
            LaunchedEffect(permissionState) {
                permissionState.launchMultiplePermissionRequest()
            }
        }
    }
}
</code></pre>

<blockquote><p><strong>注意：</strong> 因为Accompanist库是实验性质的，所以它的API都要求带上注解&#64;OptIn(ExperimentalPermissionsApi::class)。</p></blockquote>

<p>扩展阅读：</p>

<ul>
<li><a href="https://medium.com/@rzmeneghelo/how-to-request-permissions-in-jetpack-compose-a-step-by-step-guide-7ce4b7782bd7">How to Request Permissions in Jetpack Compose: A Step-by-Step Guide</a></li>
<li><a href="https://www.paleblueapps.com/rockandnull/how-to-request-permissions-in-jetpack-compose/">Jetpack Compose Permissions: A Quick and Easy Guide</a></li>
<li><a href="https://blog.stackademic.com/the-best-way-of-managing-runtime-permissions-using-permissionhandler-in-jetpack-compose-adb8057577d4">The best way to manage the Runtime permissions using PermissionHandler in Jetpack Compose</a></li>
<li><a href="https://www.composables.com/tutorials/permissions">A comprehensive guide to Android runtime permissions using Jetpack Compose</a></li>
<li><a href="https://stackoverflow.com/questions/73898807/how-to-handle-runtime-permissions-in-jetpack-compose-properly-by-accompanist">How to handle runtime permissions in jetpack compose properly by accompanist?</a></li>
</ul>


<h2>总结</h2>

<p>本文详细了介绍了目标平台是Android时，Compose的两种运行时权限申请方式。推荐使用Accompanist库中的permission模块，虽然这会引入一个新的依赖，虽然它只是实验性的，毕竟用起来方便啊。当然，如果想要精细化的处理权限的各种结果就直接用原生方式，也并没有麻烦多少。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/training/permissions/requesting">Request runtime permissions</a></li>
<li><a href="https://betterprogramming.pub/jetpack-compose-request-permissions-in-two-ways-fd81c4a702c">2 Ways to Request Permissions in Jetpack Compose</a></li>
<li><a href="https://www.howtodoandroid.com/runtime-permission-on-jetpack-compose/">Best ways to handle runtime permission on jetpack compose</a></li>
<li><a href="https://www.freecodecamp.org/news/requesting-location-permissions-in-jetpack-compose/">How to Request Location Permissions in Jetpack Compose</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
