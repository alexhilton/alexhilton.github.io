<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 猿轩阁]]></title>
  <link href="http://alexhilton.github.io/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="http://alexhilton.github.io/"/>
  <updated>2014-10-26T21:37:26+08:00</updated>
  <id>http://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[适配多屏幕的最佳实践]]></title>
    <link href="http://alexhilton.github.io/blog/2014/10/26/best-practices-to-support-multiple-screen/"/>
    <updated>2014-10-26T19:58:10+08:00</updated>
    <id>http://alexhilton.github.io/blog/2014/10/26/best-practices-to-support-multiple-screen</id>
    <content type="html"><![CDATA[<p>对于Android应用开发来讲，比较头疼的，也是比较重要的一个工作就是要尽可能多的支持市场上的Android设备，由于Android的开放性，各种奇奇怪怪的设备都有，符合标准的，不符合标准的，行货，水货，山寨货鱼龙混杂，防不胜防。为了让我们的应用能够得到尽可能多的用户，我们就必须能让应用以超强的适应性，以能在混乱的手机里生存。而适配设备，GUI屏幕的适配又是重中之中，如果用户都无法正确的看到你的UI页面，那还用个毛线啊！</p>

<p>之前曾经写过<a href="http://blog.csdn.net/hitlion2008/article/details/9200135">一篇文章</a>，介绍了一下子如何使用dimen资源来适配多屏幕，随着Android版本的演进，有些概念已经过时，需要重新整理一下。</p>

<p><img class="<a" src="href="http://developer.android.com/images/resources/resource_devices_diagram2.png">http://developer.android.com/images/resources/resource_devices_diagram2.png</a>&#8221;></p>

<p>其实对于多屏幕适配，一个核心的原则就是要对布局做好抽象的分离，把可变与不可变分开，把与屏幕相关的尺度dimen写在单独的dimen文件中，然后使用引用。如果不这样做，就会造成更多的代码重复。</p>

<!-- more -->


<h2>以最佳的方式来提供资源</h2>

<p>通常我们的做法是以屏幕密度(<a href="http://developer.android.com/guide/topics/resources/providing-resources.html">Screen Density</a>)，做为区分来提供不同的资源，以达到支持和适配不同的屏幕，比如我们会为mdpi, hdpi, xhdpi，各准备一套图片和dimen，大多数情况下，这很好，能对付了大多数设备，但这还不够。</p>

<p>比如说，480x800, 480x854, 540x960这三种设备，都是同样的屏幕密度hdpi，但是屏幕尺寸并不相同，对于qHD(540x960)，它的可用空间要比标准hdpi(480x800)要多得多，如果以qHD为基准来调的布局，那么放到480x800上，有些元素会被挤扁，或者显示不完全。而且目前，540x960的设备要多于480x800的，因为屏幕都是越来越大，精度越来越高的。</p>

<p>那么如何解决呢？
现在推荐的做法是用屏幕的可用高度(注意是可用高度，不包括状态栏和底部硬键)来区分不同的资源。以前是可以在屏幕密度后面指定具体的分辨率来区分，比如values-hdpi-960x540。但是现在这种做法已被废弃，<a href="http://developer.android.com/guide/practices/screens_support.html">官方文档</a>中都不会提及了。很显然它的问题在于不够通用。</p>

<p>现在推荐的做法是用可用高度或者可用宽度来指定：</p>

<ul>
<li>values-h<sw>dp</li>
<li>values-h<sh>dp</li>
</ul>


<p>这里面的sw和sh就是屏幕的可用宽度和可用高度。这种方式的适配规则是：用小于且最接近设备屏幕高度或宽度的那个资源，比如设备可用高度是610dp，则选择values-h600dp，以此类推。用这个方式就能区分同为hdpi的480x800和540x960，因为：</p>

<ul>
<li>480x800     533dp</li>
<li>540x960     640dp</li>
</ul>


<p>所以，可以用values-h600dp来区分二者。
使用此的方法为：</p>

<ul>
<li>计算某个设备的高度或者宽度，以dp为单位。高度dp=可用高度px/density</li>
<li>创建可以区分不同设备的资源目录，如values-h500dp, values-h600dp等</li>
</ul>


<h2>增加适配性的更多技巧</h2>

<p>除了上面提到的，还有一些在适配时需要注意的事情。</p>

<ol>
<li>尽量多用WRAP_CONTENT和MATCH_PARENT，特别是对于像文字图片等元素的度量</li>
<li>对于页面的边框距离，最好用最外层的ViewGroup来指定，或者使用margin或者使用padding。
这点的主要意思是，如果你想要页边框距是20dip，那么用一个ViewGroup来指定，要么是最外层的，要么是最里层的，千万不要是外面的5dp，中间的5dp，里面的5dp，最里面的5dp，虽然整体效果看起来是一致的，但是当适配时就会蛋疼了。固定在某个上面，这样既方便调试，也方便适配和移植。</li>
<li>同一个应用，边框距等最好做到一致，起码对于同一类型的页面更是如此。</li>
</ol>


<h2>一些常见设备的参数</h2>

<ul>
<li>320x480   1   mdpi  480dp</li>
<li>480x800   1.5 hdpi  533dp</li>
<li>540x960   1.5 hdpi  640dp</li>
<li>720x1280  2   xhdpi 640dp</li>
<li>1080x1920 3 xxhdpi 640dp</li>
</ul>


<h2>参考</h2>

<ul>
<li><a href="http://developer.android.com/guide/topics/resources/providing-resources.html">http://developer.android.com/guide/topics/resources/providing-resources.html</a></li>
<li><a href="http://developer.android.com/guide/topics/resources/providing-resources.html#Compatibility">http://developer.android.com/guide/topics/resources/providing-resources.html#Compatibility</a></li>
<li><a href="http://developer.android.com/guide/topics/resources/runtime-changes.html">http://developer.android.com/guide/topics/resources/runtime-changes.html</a></li>
<li><a href="http://stackoverflow.com/questions/16907023/best-way-to-support-540x960-and-480x800-both-hdpi">http://stackoverflow.com/questions/16907023/best-way-to-support-540x960-and-480x800-both-hdpi</a></li>
<li><a href="http://forums.xamarin.com/discussion/2784/best-way-to-support-540x960-and-480x800-both-hdpi">http://forums.xamarin.com/discussion/2784/best-way-to-support-540x960-and-480x800-both-hdpi</a></li>
<li><a href="http://developer.android.com/guide/practices/screens_support.html">http://developer.android.com/guide/practices/screens_support.html</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何有效的减少重复的代码]]></title>
    <link href="http://alexhilton.github.io/blog/2014/10/25/tricks-to-remove-duplicates/"/>
    <updated>2014-10-25T21:59:26+08:00</updated>
    <id>http://alexhilton.github.io/blog/2014/10/25/tricks-to-remove-duplicates</id>
    <content type="html"><![CDATA[<p>重复的代码一直都是可维护性的大敌，重构的重要任务之一也就是要去除掉重复的代码，有效的减少重复代码，可以大大提高软件的扩展性。</p>

<p>在Android开发中，很容易产生重复的代码。因为Android是组件，模板式开发，每个页面都是独立用Activity或Fragment实现，布局文件都是用XML方式去写，所以很容易造成代码的重复，虽然二个页长的差不多，但毕竟是二个Activity，于是就拷一份出来，改吧改吧就成了。</p>

<p><img class="<a" src="href="https://cdn.tutsplus.com/mobile/uploads/legacy/134_Android-User-Interface-Design_Relative-Layouts/fig2.png">https://cdn.tutsplus.com/mobile/uploads/legacy/134_Android-User-Interface-Design_Relative-Layouts/fig2.png</a>&#8221; width=&#8221;600&#8221; height=&#8221;320&#8221;></p>

<p>那么我们如何做才能去掉重复的代码呢？</p>

<!-- more -->


<h2>为你的项目定义一个基Activity或Fragment</h2>

<p>无论你的项目大或小，定义一个基Activity或Fragment总是有好处的。随着项目的发展，会有大量的公共代码可以抽出来放到基类里去。或者在基类里面做一些项目特色的事情。再或者添加一些统计，崩溃反馈等等。在一个基类里面改动总比把每个Activity或Fragment里面都改一遍要好的多。</p>

<h2>代码的去重复技巧</h2>

<p>从代码上去除重复的代码就是用通用的重构技巧，比如提炼方法，抽象基类，提炼常量等。但是光是代码还不够，因为Android的页面代码跟布局文件的关联非常大，通常Activity或者Fragment都是为了操作布局页写的，所以要想彻底的减少代码的重复，还必须先减少布局的重复。</p>

<h2>用<a href="http://developer.android.com/training/improving-layouts/reusing-layouts.html">include</a>减少局部布局的重复</h2>

<p><include/>标签是减少布局重复的利器，它的作用是把另外一个布局文件全部无修改式的嵌入到标签所在的位置。这与C/C++语言的预处理指令#include是一样的。在WEB框架式开发中，也非常常用HTML模板，其中也有类似的include。目的也是减少代码的重复。</p>

<p>要想把include用的恰到好处，首先要做的就是把整体布局模块化，从整体的布局出发，找出可复用的局部布局或布局组合，把它们放入单独一个布局文件中，然后在其他的地方就可以include了。</p>

<h2>用<a href="http://developer.android.com/reference/android/view/ViewStub.html">ViewStub</a>减少整体的布局的重复</h2>

<p>前面是找出布局中的可复用布局组合，include以减少重复。但有些时候是反过来的，也就是说有几个页面，它们整体的一样的，但是某个局部是不同的，这个时候include就不行了。这个时候就可以使用一样的整体布局+ViewStub来做布局。</p>

<p>ViewStub是一个轻量级别的，不可见的View，当ViewStub被设为visible时，或者显示调用layout()时，才会去把它所指向的布局渲染出来，所以它非常适合处理整体相同，局部不同的情况。关于ViewStub的使用可以参考<a href="http://blog.csdn.net/hitlion2008/article/details/6737537">这篇博客</a>。
具体的策略是：</p>

<ul>
<li>规划整体布局，抽象出共同的布局，把可变的布局识别出来</li>
<li>写整体布局，对于可变的局部布局用ViewStub替代</li>
<li>用一个基Fragment来操作整体布局。</li>
<li>创建基Fragment的子类，每个子类，用真正的布局来替换ViewStub。</li>
</ul>


<h2>多用引用而不是写死</h2>

<p>这点是非常重要的，Android的强大之处在于，所有的资源的指定都可以用引用，而非直接写死，直接写死就会出现重复代码，比如颜色，背影，字串，布局，ID，度量(dimen)，风格等等。那么，我们在使用的时候，也尽可能的使用引用，这样非常易于复用，修改和定制，从而也就更方便复用。</p>

<h2>分析，分离变与不变</h2>

<p>其实代码的去重复的关键都在于要分析出可变与不可变，共性和特性，这是抽象与封装的基础。这个没有直接可操作性的建议，只能靠自己平时多多积累，以及遇到问题时多多思考。</p>

<p>另外，就是对于重复的定义是达到三次及三次以上。如果仅出现二次，并且，无可能出现别一次，这个时候其时，要不要去重复有在商榷，写第二次时，花时间重构，与拷贝或重新实现，其实代码差不多。当发现第三次实现某个东西时，就要考虑好好的重构一下，减少重复。</p>

<p>还有，就是，在项目开始不要考虑的太多，不要过度设计。孤认为，不过过度设计，更不要过早优化，就根据需求和进度和发展状况综合来看。当出现了重复，需要重构时就立马去做，这样就不会出问题。但如果没能及时去做重构，欠了债，那么由于涉及代码，功能和模块都比较多时，再去重构，难度大，风险也大。就好比房屋的维护保养，当出现灰尘时就去打扫，很容易，个把小时就搞定了，但如果一直拖着，一年才打扫一次，可能要十天半个月才能完事。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用工具来提升Android开发效率]]></title>
    <link href="http://alexhilton.github.io/blog/2014/10/24/boosts-android-development-with-tools/"/>
    <updated>2014-10-24T18:15:56+08:00</updated>
    <id>http://alexhilton.github.io/blog/2014/10/24/boosts-android-development-with-tools</id>
    <content type="html"><![CDATA[<p>正所谓工欲善其事，必先利其器。学习并应用优秀的轮子，可以让我们跑的更快，走的更远。这里所指的工具是广义的，泛指能帮助我们开发的东西，或者能提高我们效率的东西，包括：开发工具，监测工具，第三方代码库等。
<img class="<a" src="href="http://img.clubic.com/05250064-photo-apple-tools.jpg">http://img.clubic.com/05250064-photo-apple-tools.jpg</a>&#8221; width=&#8221;600&#8221; height=&#8221;320&#8221;></p>

<h2>优质的第三方开源类库</h2>

<!-- more -->


<h3>图片加载与缓存</h3>

<p>现代的应用程序难免会有图片显示给用户，对于资讯类，旅游类，购物类等应用程序而言，图片的展示更是应用里面关键的一环。而图片从加载，到缓存再到显示是一个比较复杂的过程，中间还要处理网络异常，解析异常等。图片又是极其耗费内存的，稍不注意就会出现OutOfMemory（OOM）的错误。如果你的图片在你的应用中不是主要的东西，仅是偶尔显示个Icon和图标之类的，那还好，普通的异步加载和解析（<a href="http://developer.android.com/reference/android/graphics/BitmapFactory.html">BitmapFactory</a>）就好。但如果要在应用中展示大量的图片时，甚至应用的主要内容就是图片时，这时就要借助于优秀的开源库了：</p>

<ul>
<li><p><a href="https://github.com/nostra13/Android-Universal-Image-Loader">Universal Image Loader</a></p>

<p> 这个库非常强大，从加载，到解析到显示，你只配置参数，告诉它如何做，再给它一个ImageView就可以了，然后你就可以去喝茶去了。</p></li>
<li><a href="https://github.com/square/picasso">Picasso</a></li>
</ul>


<h3>EventBus完全解耦模块</h3>

<p>观察者模式，或者生产者消费者模型在开发中是很常见的，比如说异步加载数据，之类的都会用到类似的结构。通常的做法就是创建一个Listener用于回调，以返回数据。如果有一个二个还好，但如果多了，应用需要获取大量的不同的数据，就会出现大量的线程和Listener，到处是addListener和implements Listener，这会造成大量的代码和依赖，程序会变得混乱，业务逻辑会迷失在Listener之中，而且还要及时的unregisterListener，以防不该被回调到时能取消。这还会造成代码和模块之间的强耦合，也就是写代码的时候必要在有另一方，否则不会编译过。这时就可以用EventBus来解耦了，它是一个框架能让双方很容易的进行通讯，而不必知道彼此的存在与否：</p>

<ul>
<li><a href="https://github.com/greenrobot/EventBus">EventBus</a>
 这个库非常的高效与方便，它完全不依赖于注解。</li>
<li><a href="http://square.github.io/otto/">Otto</a>
 这个要使用注解，所以在效率上可能会略差一些。</li>
<li><a href="https://code.google.com/p/guava-libraries/wiki/EventBusExplained">Guava</a>
 这个是Google Java增加库Guava中的一个</li>
</ul>


<p>这些的库的基思想和目的都是一致的，都是以总线的方式，让强耦合的双方解耦，不妨在你的应用中使用一下，体验一下。</p>

<h3><a href="https://github.com/hdodenhof/CircleImageView">CirclImageView</a></h3>

<p>这似乎是一个比较小型的库，它只是一个特殊的ImageView用圆形的方式来显示图片。</p>

<h3><a href="https://github.com/Maxwin-z/XListView-Android">XListView</a></h3>

<p>这是一个支持下拉刷新(PulltoRefresh)和上拉加载更多(Load more)的定制ListView。</p>

<h3><a href="https://github.com/JakeWharton/Android-ViewPagerIndicator">ViewPageIndicator</a></h3>

<p>这个是要与官方的<a href="http://developer.android.com/reference/android/support/v4/view/ViewPager.html">ViewPager</a>一起使用的，为ViewPager添加indicator的类库，非常的有名，很多应用都在使用。</p>

<h3><a href="https://github.com/JakeWharton/ActionBarSherlock">ActionbarSherlock</a></h3>

<p>这个库非常的有名，很多优秀的应用都基于此。<a href="http://developer.android.com/reference/android/app/ActionBar.html">ActionBar</a>是一个不错的用户体验，它能集导航，操作和信息于一体的导航栏，Google也极力推荐使用它。但是有一个问题就是它是<a href="http://developer.android.com/about/versions/android-3.0-highlights.html">HoneyCombe</a>（API 11）才引及的一个组件，而对于大多数开发者来说，GingerBread(2.3)还是不能放弃的肉，所以这个类库应运而生。这个库易于使用，根据手机版本来选择实现方式，如果是3.0以上就直接使用系统的Actionbar。其中的代码也是值得所有开发者去拜读。</p>

<h3><a href="https://github.com/bauerca/drag-sort-listview">DragSortListView</a></h3>

<p>用过iOS设备的人可能会注意到iOS里面的所有列表都有一个非常酷的功能，那就是在编辑模式下，可以任意对列表进行重新排库。但是令开发沮丧的是，这是iOS中UITableView的标准内嵌功能。而Android的ListView只提供最基本的功能。因此就有了此类库的出现。其实除了此库，还有很多其他的库的出现也都是为了实现类似iOS体验而做的。
当然这个类库有一个小问题需要注意，就是它内部会创建一个ItemView来Wrapper客户代码提供的ItemView，而在Wrapper时，它会使用WRAP_CONTENT做为高和宽，所以，用了这个类库会发现宽度不会Match整个屏幕。解决的办法就是在创建Adapter#getView时再用代码指定一扁LayoutParams，把宽设为MatchParent就好了。</p>

<h3><a href="http://nineoldandroids.com">NineOldAndroid</a></h3>

<p>这个库也是解决低版本之痛的。从3.0开始，Google引入了新的动画库，称作Property动画，使实现动画不但变得非常简单，同时也能实现更加复杂的动画。只要对对象的属性进行计算，就能让这个对象动起来。但是同样，对于2.3以前就只能用旧的补间动画(Tween Animation)，这种动画复杂，需要写大量的代码。这个库就能统一操作，让动画变得简单
这里介绍的，只是一些比较常用的也是比较有名的类库。这些库不但优秀，好用，而且最重要的是还开源，你可以去学习，去研究，甚至去改进。那么，这些还远远不够，我们的应用日益复杂，各种需求，怎么办呢？</p>

<h2>如何获取更多的类库</h2>

<p>学习编程的第一天起，前辈们就说，不要重复制造轮子，老手与新手的区别也在于，老手善于利用已有的东西，而不是一起都从0开始，无数的优秀的类库已经能帮忙解决很多问题，它们健壮，方便，好用，所以为什么还要自己费劲去重新造轮子呢？</p>

<h3>二个开发者必备之神器</h3>

<p>现在的开源类库非常之多，有些我们可能不知道，即使看到一个类库的主页或者源码，也要花时间研究下，它究竟能干什么，适合干什么，以及能否解决我们遇到的问题，这是介绍三款神器：</p>

<ul>
<li> <a href="https://play.google.com/store/apps/details?id=com.indianic.coslib">Developer Library for Android</a></li>
<li> <a href="https://play.google.com/store/apps/details?id=com.inappsquared.devappsdirect">DevAppsDirect</a></li>
<li> <a href="https://play.google.com/store/apps/details?id=com.limecreativelabs.app">LiME Creative Labs</a></li>
</ul>


<p>这三款都是Android应用，只是它们的内容是介绍众多优质的开源类库，它会列出每个类库的信息，如作者，源友位置，简要说明。最最重要的是它把类库的例子也集成起来了，你可以立马运行类库的Demo以体验这个类库到底是干啥的，这真的是良心之作。等什么呢，赶快去下载安装吧。</p>

<h3>Github</h3>

<p>提起开源，<a href="https://github.com/">Github</a>当然是首届一指的，其上托管着无数的优秀的开源库，没事常去逛逛总会有好处，甚至是惊喜的。唯一麻烦的就是，里面的内容太多了，容易看花眼和找不到想要的东西。所以还是上面的应用来的干脆直接。</p>

<h3>优质的聚合平台</h3>

<p>除此之外，还有一些优秀的网络社区和博客会收集和整理优秀的开源类库，这也是我们需要关注的，比如：</p>

<ul>
<li> <a href="http://hao.jobbole.com/category/android/">伯乐</a>
  这里面罗列了大量的优秀的库和工具，这里不仅有库还有工具。此外这个网站也值得所有开发者收藏，里面会聚合优秀的博客和资源。</li>
<li> <a href="http://guides.codepath.com/android">CodePath</a></li>
</ul>


<h2>每个应用程序必不可少的组件</h2>

<p>现在的应用程序有一些东西是必要的，比如分享功能，比如推送消息，比如应用程序统计和崩溃报告等，如果你是一个大型公司，拥有大团队，或者已经发现成为行业领头羊，那么这些东西最好自己实现，以达到更好的控制和运营，也防止数据外泄。但对于小团队，或者个人开发者，来说，还是利用现成的解决方案比如靠谱。</p>

<h3>分享到社交平台</h3>

<p><a href="http://www.mob.com/">ShareSDK</a>和<a href="http://www.umeng.com">友盟</a>都提供了免费的SDK用以实现分享到各大社交平台。
其实每个社交平台都有提供了SDK，但是有些麻烦的是开发者必须要一一去注册，以获取APP_KEY，同时还要处理用户授权以获得访问社交数据，不同的SDK，虽然基本思想是一致的，但是具体开发过程难免会有坑。ShareSDK就是帮助开发者解决了这些问题，它在各个媒体平台上都注册了，也封装处理了授权过程，但是带来方便的同时，它有缺点：
   * 分享到社交媒体上的信息会显示“来自ShareSDK”，而非你的应用。这个通常是显示开发者在社交媒体上注册的信息。
   * ShareSDK的授权方式是通过网页形式，而非API，过于简单且授权信息不容易持久化，也就是用户可能会经常（甚至每次）分享时都需要授权。而如果直接使用媒体授权API，可以直接获取APP_SECRETE，在未过期（一般Expiration会比较长）之前都可以直接分享，无需授权。</p>

<p>所以你看所有的用户量超大的应用，各大新闻客户端等，都是自己集成和绑定社交媒体，不会通过第三方的库。</p>

<h3>推送消息</h3>

<p>现在的应用程序基本上都会有后台服务提供数据，也会增加推送消息，这个是运营的重要手段，能保持应用的活跃，虽然我不喜欢推送消息，因为早上一打开手机，全都是推送消息。但是推送还是必要的，也有现成的方案可以用：</p>

<ul>
<li> <a href="http://www.igetui.com">个推</a></li>
<li> <a href="http://www.umeng.com/">友盟</a></li>
</ul>


<p>这二个也都非常好用，它包括客户端SDK和Server端后台，是全套的，非常方便实用。
除此之外，如果是面向海外用户，可以用Google提供的，<a href="http://developer.android.com/google/gcm/index.html">Google Clould Messaging</a>，它也非常好用，因为毕竟是官方的，可以与Apple的推送服务媲美。但是它的最大的缺点在于，Google Services都依赖于Google Play，也就是说运行时手机上必须要有Google Play Services，也即必须要安装有GMS才可以。但中国大陆的手机全部没有GMS，因此GCM也用不了。所以个推和友盟也才有机会。</p>

<h3>应用统计信息</h3>

<p>移动开发不单单只有开发出一个出色的APP这么简单，开发完了还要运营，而应用的统计绝对是运营的一个重要手段，后期的新功能，以及发展方向要取决于应用的统计数据，统计能看出用户的特征，分布，使用习惯等。当然了，在统计方面友盟绝对是最好的，它开始的最好，现在也是做的最好的，使用也非常的简单。</p>

<h3>应用崩溃报告</h3>

<p>现在的Android手机种类极其之多，各种奇葩的设备都有，在标准的手机和模拟器上运行没有问题，但是在某些定制ROM的手机上可能就会挂。另外，程序也会有你想不到Bug导致崩溃。因此我们需要收集应用的崩溃信息，以后期改进。如果你集成了友盟统计，它会自动收集崩溃信息，但是它只能收集Java层的，且信息比较简单，只有一个StackTrace。如果想要收集Native层的，以及获得更多的信息的话，就要使用其他库，或者自己实现。自己实现也不难，就是要处理unhandledException，然后把客户端的信息，如版本，配置，再把手机的信息收集一下，发到后台，后台再做个报表，能查看错误信息就可以了。但如果不想自己做，可以使用<a href="https://github.com/ACRA/acra">Application Crash Reports for Android</a>这个库可以解决客户端的问题，也就是说它能在发生Crash时，收集足够的信息(哪配置要收集哪些信息)，然后发送，它可以配置成发送到Server后台，也可以发送到开发者的邮箱，很方便和实用，特别是对于个人开发者来说。需要注意的是，要想能发送到邮箱，手机用户必须配置了Email帐户，国内用户貌似没有这习惯，因为国内用户不习惯用邮件，更不要说给手机配置邮件帐户。但是对于国外用户，这是没有问题的，国外用户习惯电子邮件，而且手机上都会配置。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android应用UI架构]]></title>
    <link href="http://alexhilton.github.io/blog/2014/10/22/effective-android-ui-architecture/"/>
    <updated>2014-10-22T23:06:43+08:00</updated>
    <id>http://alexhilton.github.io/blog/2014/10/22/effective-android-ui-architecture</id>
    <content type="html"><![CDATA[<p>这个标题听起来可能有点大，其实这里主要就是讨论一个应用程序的UI组件，是全用Activity还是全用Fragment，或者是二者皆有，以及使用Activity和Fragment的一些注意事项。
<img class="<a" src="href="http://i.stack.imgur.com/S4TpY.png">http://i.stack.imgur.com/S4TpY.png</a>&#8221;></p>

<h2>Activity or Fragment</h2>

<p>从API 11，Honeycomb开始，Google在Android之中加入了Fragment，一个轻量级的，可复用的，模块化的UI组件，并且官方也极力的推荐要尽可能的使用Fragment实现UI，尽量避免使用Activity，但是官方并没有详尽的解析为什么要这样做，因此，引发了很多人的困惑和网络上的争论</p>

<!-- more -->


<h3>一些讨论</h3>

<p><a href="https://stackoverflow.com/">StackOverflow</a>上面有很多类似的讨论，比如<a href="http://stackoverflow.com/questions/20306091/dilemma-when-to-use-fragments-vs-activities">这个</a>和<a href="http://stackoverflow.com/questions/10478233/android-need-some-clarifications-of-fragments-vs-activities-and-views">这个</a>，以及<a href="http://blog.pluralsight.com/android-fragments">这篇博客</a>和<a href="https://www.altamiracorp.com/blog/employee-posts/fragments-vs-activities-in-and">这篇</a>。</p>

<p>总体的来讲，也都是推荐使用Fragment，并尽可能的使用Fragment，除非你必须使用Activity，否则就使用Fragment。</p>

<h3>主要的区别</h3>

<p>要想真正的理解什么时候该用Activity什么时候该用Fragment，就要从根本上理解它们之间到底有什么区别，以及各自所能做的事情：</p>

<h4>Activity的优缺点</h4>

<p>Activity是Android系统的四大核心组件之一，是唯一用户可见的组件，是可视化应用程序的基础，同时也是应用程序的主要入口。
它的优点是：</p>

<ul>
<li>方便使用，简单，没有版本限制</li>
<li>可以处理系统相关的事情，比如窗体管理，对话框管理，与第三方应用交互，作为应用的入口，处理系统事件等</li>
<li>生命周期简单明了</li>
<li>不同的Activity实例的生命周期相互独立</li>
<li>有系统的ActivityManager来管理，创建和维护实例，以及栈</li>
</ul>


<p>Activity的缺点：</p>

<ul>
<li>无法完全的控制，创建和各种状态全部由Frameworks操控</li>
<li>过于庞大和复杂</li>
<li>传递参数相当费劲</li>
<li>launchMode和栈的管理过于复杂，让人捉摸不透</li>
</ul>


<p>所以，因为它有缺点，所以它适合做为第一级组件，而不适合到处都用。也因此有了Fragment的诞生。</p>

<h4>Fragment的优缺点</h4>

<p>Fragment号称是轻量级的Activity，它有着Activity的部分功能，比如有生命周期，可以显示UI元素，可以有控制逻辑，它有很多优点：</p>

<ul>
<li>可以像普通对象那样自由的创建和控制</li>
<li>因为可以得到实例，所以传递参数等会更加的容易和方便</li>
<li>不用处理系统相关的事情</li>
<li>显示方式可控制，替换，还是层叠，部分还是整体，都容易控制</li>
<li>进出动画都相对容易</li>
</ul>


<p>可以看出Fragment是实现可复用的，模块化UI的良好组件，熟悉iOS开发的人应该知道，这个Fragment跟iOS中的UIViewController是很相似的，都是MVC模式中的负责协调和控制的Controller。</p>

<h3>实用的建议</h3>

<p>那么，到此，我想我们应该能够总结出，到底什么时候该用Activity，什么时候该用Fragment了：</p>

<ul>
<li>一个应用程序必须至少要有一个Activity</li>
<li>如果你需要开放入口给第三方应用，那么要用Activity。比如原生应用中的联系人，信息，相机，图库等，因为要留有接口给第三方使用，所以要用Activity。这也是所谓的组件级复用。</li>
<li>如果要处理系统相关的事情，需要用Activity，比如横竖屏，语言变化，键盘等</li>
<li>如果非要在横屏或竖屏显示，也要用Activity</li>
<li>如果感觉用Fragment来做有很多的不方便，或者很困难，出于各种原因吧。</li>
</ul>


<p>除此外，就使用Fragment吧。因此，对于一个应用程序的UI架构就是一个Host的Activity+Fragment的方式来做。</p>

<h2>使用Activity时的注意事项</h2>

<p>Activity是学习Android开发的第一堂课，我相信有过Android开发经验的人对Activity必定非常的熟悉了，对于使用Activity要注意：</p>

<ul>
<li>除非特别需要，否则要声明configChagnes，至少orientation和keyboard以及keyboardHidden需要加上</li>
<li>减小对Activity实例的引用，尽可能用getApplication()或者getApplicationContext()来做为平台接口需要的Context参数</li>
<li>在AndroidManifest.xml的activity标签中声明全屏，透明或者没有TitleBar的属性，而不是在onCreate()中去requestWindowFeature。除非你需要动态控制</li>
<li>Activity之间传递参数用Intent，尽量传基本数据类型和数据及ArrayList，和平台提供的数据类型如Uri。对于简单的POD(Plain Old Datastructure)数据类型，可以直接由基本数据组成，不必声明对象。对于有必要存在的对象，可以实现Parcelable接口，以方便在Activity之间传递。</li>
</ul>


<h2>使用Fragment时的注意事项</h2>

<p>Fragment是由FragmentManager来管理的，每一个Activity有一个FragmentManager，管理着一个Fragment的栈，所以，Activity是系统级别的，由系统来管理ActivityManager，栈也是系统范围的。而Fragment则是每个Activity范围内的。</p>

<ul>
<li><p>同一个Activity中，只能有一个ID或TAG标识的Fragment实例。</p>

<p>  这很容易理解，同一个范围内，有标识的实例肯定是要唯一才行（否则还要标识干嘛）这个在布局中经常犯错，在布局中写Fragment最好不要加ID或者TAG，否则很容易出现不允许创建的错误。我的原则是如果放在布局中，就不要加ID和TAG；如果需要ID和TAG就全用代码控制。创建新实例前先到FragmentManager中查找一番，这也正是有标识的意义所在。</p></li>
<li><p>一个Activity中有一个Fragment池，实例不一定会被销毁，可能会保存在池中。这个跟第一点差不多。就好比系统会缓存Activity的实例一样，FragmentManager也会缓存Fragment实例，以方便和加速再次显示。</p></li>
<li><p>如前所述，FragmentManager的作用范围是整个Activity，所以，某一个布局ID，不能重复被Fragment替换。</p>

<p>  通常显示Fragment有二种方式，一种是层叠到某个布局上，或者把某个布局上面的Fragment替换掉，但是这个布局不能出现二次，比如布局A中有ID为id的区域，要显示为Fragment，此布局A，只能在一个Activity中显示一个，否则第二个id区域不能被Fragment成功替换。因为虽有二个ID布局的实例，但ID是相同的，对FragmentManager来说是一样的，它会认为只有一个，因为它看的是布局的ID，而不是布局的实例。</p></li>
<li><p>Fragment的生命周期反应Activity的生命周期。</p>

<p>  Fragment在显示和退出时会走一遍完整的生命周期。此外，正在显示时，就跟Activity的一样，Activity被onPause，里面的Fragment就onPause，以此类推，由此带来的问题就是，比如你在onStart()里面做了一些事情，那么，当宿主Activity被挡住，又出现时（比如接了个电话），Fragment的onStart也会被高到，所以你要想到，这些生命周期不单单在显示和退出时会走到。</p></li>
<li><p>Fragment的对用户可见性。</p>

<p>  这个问题出现在有Fragment栈的时候，也就是说每个Fragment不知道自己是否真的对用户可见。比如现在是Fragment A，又在其上面显示了Fragment B，当B显示后，A并不知道自己上面还有一个，也不知道自己对用户不可见了，同样再有一个C，B也不知。C退出后，B依然不知自己已在栈顶，对用户可见，B退后，A也不知。也就是说Fragment显示或者退出，栈里的其他Fragment无法感知。这点就不如Activity，a被b盖住后，a会走到onStop()，同样c显示后，b也能通过onStop()感知。Fragment可以从FragmentManager监听BackStackState的变化，但它只告诉你Stack变了，不告诉你是多了，还是少，还有你处的位置。有一个解决方案就是，记录页面的Path深度，再跟Fragment所在的Stack深度来比较，如果一致，那么这个Fragment就在栈顶。因为每个页面的Path深度是固定的，而Stack深度是不变化的，所以这个能准确的判断Fragment是否对用户可见，当然，这个仅针对整个页面有效，对于布局中的一个区域是无效的。</p></li>
<li><p>Fragment的事件传递。</p>

<p>  对于层叠的Fragment，其实就相当于在一个FrameLayout里面加上一堆的View，所以，如果处于顶层的Fragment没处理点击事件，那么事件就会向下层传递，直到事件被处理。比如有二个Fragment A和B，B在A上面，B只有一个简单的TextView且没处理事件，那么点击B时，会发现A里的View处理了事件。这个对于Activity也不会发生，因为事件不能跨窗体传播，上面的Activity没处理事件，也不会传给下面的Activity，即使它可见。解决之法，就是让上面的Fragment的根布局吃掉事件，为每个根ViewGroup添加onClick=&ldquo;true&#8221;。</p></li>
<li><p>与第三方Activity交互。与第三方交互，仍要采用Android的标准startActivityForResult()和onActivityResult()这二个方法来进行。但对于Fragment有些事情需要注意，Fragment也有这二个方法，但是为了能正确的让Fragment收到onActivityResult()，需要：</p>

<ol>
<li>  宿主Activity要实现一个空的onActivityResult()，里面调用super.onActivityResult()</li>
<li>  调用Fragment#startActivityForResult()而不是用Activity的
当然，也可以直接使用Activity的startActivityForResult()，那样的话，就只能在宿主Activity里处理返回的结果了。</li>
</ol>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
