<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2024-12-09T22:11:44+08:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[实战：把一个现有的Compose项目转化为CMP项目]]></title>
    <link href="https://alexhilton.github.io/blog/2024/12/09/migrate-existing-project-to-cmp/"/>
    <updated>2024-12-09T22:09:28+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/12/09/migrate-existing-project-to-cmp</id>
    <content type="html"><![CDATA[<p>通过<a href="https://juejin.cn/column/7367555191338467337">前面两篇文章</a>的学习，我们已经对CMP有了一定的了解，接下来要进入实战阶段。在现实的世界中极小数项目会从0开始，今天重点研究一下如何把一个现成的用Jetpack Compose开发的Android项目转成CMP项目。</p>

<p><a href=""><img src="https://www.mouritech.com/wp-content/uploads/2024/01/Compose-Multiplatform.png" title="auto auto" ></a></p>

<!-- more -->


<h2>总体思路</h2>

<p>在前面的文章<a href="https://juejin.cn/post/7439251025385996307">Compose大前端从上车到起飞</a>里面我们学习到了，CMP对Android开发同学是相当友好的，CMP项目与Android项目在项目结构上面是非常相似的。并且因为CMP的开发IDE就是Android Studio，因此，可以直接把一个Android项目改造成为CMP项目，而不是创建一个全新的CMP项目之后把项目代码移动进去。</p>

<p>具体的步骤如下：</p>

<ol>
<li>添加CMP的插件，添加源码集合，配置CMP的依赖</li>
<li>把代码从「androidMain」移动到「commonMain」中去</li>
<li>把资源转换成为CMP方式</li>
<li>添加并适配其他平台</li>
</ol>


<p><strong>小贴士：</strong> 针对 不同的类型的任务需要采取 不同的策略，比如开发功能的时候使用「自上而下」的方式要更为好一些，因为先关注大粒度的组件，类与方法，不被细节拖住，更有利于我们看清架构和优先解决掉重点问题；但当做移植任务时，应该采用「自下而上」，因为依赖是一层套一层，先把下面的移好，上面的自然就会更加容易。</p>

<p>这里选用的项目是先前用纯Jetpack Compose开发的<a href="https://github.com/alexhilton/Aeolus">一款天气应用</a>，项目比较简单，依赖不多，完全是用Jetpack Compose实现的UI，也符合<a href="https://juejin.cn/post/7411812014047461387">现代应用开发架构原则</a>，非常适合当作案例。</p>

<p><strong>注意：</strong> 其实这里的项目并没有严格要求，只要是一个能运行的Android项目即可，其他的（是不是Jetpack Compose实现的，用的是不是Kotlin）并不是最关键的。因为CMP项目对于每个源码集合本身并没有明确的要求，前面的文章也讲了，每个平台的源码集合，其实就是其平台的完整的项目。移植的目的就是把 <strong>可共用共享</strong> 的代码从现有项目中抽出来放进「commonMain」中，即可以是原有的业务逻辑，也可以是新开发的代码。采用新技术或者新工具的一个非常重要的原则 就是要循序渐进，不搞一刀切。如果时间不充裕，完全可以新功能和新代码先用CMP方式开发，老代码暂且不动它，待日后慢慢再移植。当然了，纯Jetpack Compose实现的项目移植过程会相对容易一些。</p>

<p>下面我们进行详细的一步一步的实践。</p>

<h2>配置CMP的插件，源码集合和依赖</h2>

<p>首先要做的是配置Gradle构建插件（这是把Gradle常用的Tasks等打包成为一个构建 插件，是编译过程中使用的）：</p>

<ul>
<li>使用Kotlin Multiplatform（「org.jetbrains.kotlin.multiplatform」）替换Kotlin Android（「org.jetbrains.kotlin.android」），这个主要是Kotlin语言的东西，版本号就是Kotlin的版本号，注意要与其他（如KSP，如Coroutines）版本进行匹配；</li>
<li>添加Compose compiler（「org.jetbrains.kotlin.plugin.compose」）的插件，版本号要与Kotlin版本号保持一致；</li>
<li>以及添加Compose Multiplatform（org.jetbrains.compose」）插件，版本号是CMP的版本号。</li>
</ul>


<p>注意，构建插件配置是修改项目根目录的那个build.gradle.kts：</p>

<pre><code class="Kotlin">// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    id("com.android.application") version "8.1.4" apply false
    id("com.android.library") version "8.1.4" apply false
    id("org.jetbrains.kotlin.multiplatform") version "2.0.21" apply false
    id("com.google.devtools.ksp") version "2.0.21-1.0.28" apply false
    id("org.jetbrains.kotlin.plugin.compose") version "2.0.21" apply false
    id("org.jetbrains.compose") version "1.7.0" apply false
}
</code></pre>

<p>之后是修改module的build.gradle.kts，先是启用需要的插件，然后是添加kotlin相关的配置（即DSL kotlin {&hellip;}），在其中指定需要编译的目标，源码集合以及其依赖，具体的可以仿照着CMP的demo去照抄就好了。对于依赖，可以把其都从顶层DSL dependencies中移动到androidMain.dependencies里面，如果有无法移动的就先放在原来的位置，暂不动它，最终build.gradle.kts会是酱紫：</p>

<pre><code class="Kotlin">plugins {
    id("com.android.application")
    id("com.google.devtools.ksp")
    id("org.jetbrains.kotlin.multiplatform")
    id("org.jetbrains.kotlin.plugin.compose")
    id("org.jetbrains.compose")
}

kotlin {
    androidTarget {
        @OptIn(org.jetbrains.kotlin.gradle.ExperimentalKotlinGradlePluginApi::class)
        compilerOptions {
            jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_17)
        }
    }

    sourceSets {
        androidMain.dependencies {
            // Jetpack
            implementation("androidx.core:core-ktx:1.15.0")
            implementation("androidx.appcompat:appcompat:1.7.0")
            implementation("androidx.activity:activity-compose:1.9.3")
            val lifecycleVersion = "2.8.7"
            implementation("androidx.lifecycle:lifecycle-runtime-ktx:$lifecycleVersion")
            implementation("androidx.lifecycle:lifecycle-runtime-compose:$lifecycleVersion")
            implementation("androidx.lifecycle:lifecycle-viewmodel-compose:$lifecycleVersion")
            val navVersion = "2.8.4"
            implementation("androidx.navigation:navigation-runtime-ktx:$navVersion")
            implementation("androidx.navigation:navigation-compose:$navVersion")
            implementation("androidx.datastore:datastore-preferences:1.1.1")

            // Google Play Services
            implementation("com.google.android.gms:play-services-location:21.3.0")

            // Compose
            implementation(compose.preview)
            implementation(project.dependencies.platform("androidx.compose:compose-bom:2024.02.00"))
            implementation("androidx.compose.ui:ui")
            implementation("androidx.compose.ui:ui-graphics")
            implementation("androidx.compose.ui:ui-tooling-preview")
            implementation("androidx.compose.material3:material3")
            implementation("androidx.compose.material:material")

            // Network
            implementation("com.google.code.gson:gson:2.10.1")
            implementation("com.squareup.retrofit2:retrofit:2.9.0")
            implementation("com.squareup.retrofit2:converter-gson:2.9.0")
            implementation("com.squareup.okhttp3:logging-interceptor:4.12.0")

            // Accompanist
            implementation("com.google.accompanist:accompanist-permissions:0.32.0")
        }
        commonMain.dependencies {
            implementation(compose.runtime)
            implementation(compose.foundation)
            implementation(compose.material)
            implementation(compose.ui)
            implementation(compose.components.resources)
            implementation(compose.components.uiToolingPreview)
            val lifecycleVersion = "2.8.3"
            implementation("org.jetbrains.androidx.lifecycle:lifecycle-viewmodel:$lifecycleVersion")
            implementation("org.jetbrains.androidx.lifecycle:lifecycle-runtime-compose:$lifecycleVersion")
        }
    }
}

android { ... }

dependencies { ... }
</code></pre>

<p>最后，把DSL android {&hellip;}中不支持的字段删除掉即可，如kotlinOptions，它用来指定Kotlin JVM target的，现改在DSL kotlin中的androidTarget()中指定了，但要注意Kotlin的JVM target要与android中的compileOptions的sourceCompatibility以及targetCompatibility版本保持一致，比如都是17或者都是11，否则会有编译错误。</p>

<p>需要特别注意的是DSL kotlin中的源码集合名字要与真实的目录一致，否则编译会出错。建议的方式就是依照CMP的demo那样在module中去创建androidMain和commonMain即可。另外，可以把module名字从「app」改为「composeApp」，然后把运行配置从「app」改为「androidApp」，这下就齐活儿了：</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/migrate-struct.png" alt="图1. 重命名后的项目结构" /></p>

<p>CMP的插件和依赖配置好了以后，运行「androidApp」应该就可以正常运行。因为仅是配置一些依赖，这仍是一个完整的Android应用，应该能够正常运行。这时第一步就做完了，虽然看起来貌似啥也没干，但这已经是一个CMP项目了，基础打好了，可以大步向前了。</p>

<p><strong>小贴士：</strong> 通过配置依赖可以发现，CMP的artifact依赖都是以org.jetbrans.*开头的，哪怕是对于Compose本身，纯Android上面Jetpack Compose的依赖是「&#8221;androidx.compose.ui:ui&#8221;」，而CMP中的则是「&#8221;org.jetbrains.compose.ui:ui&#8221;」。虽然都是Jetpack Compose，代码是兼容的，但技术上来讲是两个不同的实现。确切地说JetBrains的Compose是从谷歌的上面fork出来的一个分支，以让其更好的适用于CMP，但完全兼容，标准的Compose代码都是能正常跑的。</p>

<h2>把代码从「androidMain」移动到「commonMain」</h2>

<p>这是最关键的一步了，也是最难啃的硬骨头，具体的难度取决于项目中使用了多少「不兼容」的库和API。Compose和Jetpack中的绝大多数库都是支持的，可以在CMP中使用，可以无缝切换，这是JetBrains和Google共同努力的结果，谷歌现在对CMP/KMP的态度非常的积极，给与「第一优先支持（First class support）」。所以对于依赖于room，navigation，material和viewmodel的代码都可以直接移到common中。</p>

<p>也就是说对于data部分，model部分以及domain部分（即view models）都可以直接先移到common中，因为这些层，从架构角度来说都属于业务逻辑，都应该是平台独立的，它们的主要依赖应该是Jetpack以及三方的库，这些库大多也都可以直接跨平台。</p>

<p>当然，不可能这么顺利，因为或多或少会用到与平台强相关的API，比如最为常见的就是上下文对象（Context）以及像权限管理和硬件资源（如位置信息），这就需要用到平台定制机制（即expect/actual）来进行定制。</p>

<p>可能有同学会很奇怪，为啥UI层还不移动到common中，UI是用Compose写的啊，而Compose是可以直接在CMP上跑的啊。Compose写的UI确实可以直接跑，但UI必然会用到资源，必须 先把资源从android中移到common中，否则UI是跑不起来的。</p>

<h2>把资源转化成为CMP方式</h2>

<p>在前一篇文章<a href="https://juejin.cn/post/7439251025385996307">Compose大前端从上车到起飞</a>有讲过CMP用一个库resources来专门处理资源，规则与Android开发管理资源的方式很像，所以可以把UI用到的资源移动到common中的composeResources里面，就差不多了。</p>

<p>但需要特别注意，不要把全部的资源都从androidMain中移出，只需要把UI层用到的那部分资源移出即可。androidMain中至少要把Android强相关的资源留下，如应用的icon，应用的名字，以及一些关键的需要在manifest中使用的xml等。这是因为这些资源是需要在Android应用的配置文件AndroidManifest中使用的，所以必须还放在android源码集中。</p>

<p>资源文件移动好后，就可以把UI移动到common中了，最后一步就是使用CMP的资源类Res代替Android的资源类R即可。</p>

<p>到此，就完成了从Android项目到CMP项目的转变。</p>

<h2>添加并适配其他平台</h2>

<p>前面的工作做好后，再适配其他的平台就非常容易了，添加其他平台的target和入口（可以仿照CMP的demo），然后实现相关的expect接口即可。由此，一个大前端 项目就彻底大功告成了。</p>

<h2>总结</h2>

<p>CMP对项目结构中源码 集合 的限制 并不多，每个平台相关的sourceSet可以保持其原来的样子，这对现有项目是非常友好的，可以让现有的项目轻松的转成为CMP项目，这也是CMP最大的一个优势。</p>

<h2>References</h2>

<ul>
<li><a href="https://touchlab.co/compose-multiplatform-transition-guide">Jetpack Compose to Compose Multiplatform: Transition Guide</a></li>
<li><a href="https://stackoverflow.com/questions/71510247/how-to-convert-kotlin-project-to-kotlin-multiplatform-mobile-after-the-project-c">How to convert Kotlin project to Kotlin Multiplatform Mobile after the project completion?</a></li>
<li><a href="https://markonovakovic.medium.com/from-android-to-multiplatform-migrating-real-100-jetpack-compose-app-to-fully-multiplatform-app-2d65dc9e212e">From Android to Multiplatform: Migrating real 100% Jetpack Compose App to fully Multiplatform App. Intro</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compose大前端从上车到起飞]]></title>
    <link href="https://alexhilton.github.io/blog/2024/11/24/master-compose-multiplatform/"/>
    <updated>2024-11-24T08:45:46+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/11/24/master-compose-multiplatform</id>
    <content type="html"><![CDATA[<p>在前面的一篇文章<a href="https://juejin.cn/post/7436648335380496434">赶紧上车开启Compose大前端之路</a>中我们学习了CMP的基本概念以及如何创建一个CMP项目。今天将继续学习CMP，深入研究项目的配置方法，了解CMP的内部机制并总结一些CMP开发的最佳实践。</p>

<p><a href=""><img src="https://repository-images.githubusercontent.com/293498508/6469be07-159b-49de-9ffe-56340d5dfd07" title="auto auto" ></a></p>

<!-- more -->


<h2>深入了解项目结构</h2>

<p>CMP的基础结构与一个标准的Android应用的项目结构基本一样，只不过主module名字变成了「composeApp」。项目根目录下的build.gradle.kts是整个项目的配置，主要是指定使用的插件；settings.gradle.kts指定项目的依赖仓库，以及项目包含哪些module；gradle/wrapper/libs.version.toml定义着依赖的版本信息。模块「composeApp」包含着源码集合（source sets）以及一个build.gradle.kts，这是描述这个模块如何构建的脚本。</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/project-view.png" alt="图1. 项目结构" /></p>

<p>对于Android开发同学来说，这样的项目结构非常熟悉，事实上如果把项目视图切换到「Android」，就会发现，这比起常规的Android项目，无非就是多了一些源码集合。</p>

<p>仔细看一下源码集合「androidMain」它就是一个标准的Android项目，里面有AndroidManifest文件，以及一个入口MainActivity，它会调用「commonMain」中定义的composable App()，由此就进入到了「commonMain」中。</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/android-entry.png" alt="图2. Android源码关系" /></p>

<p>虽然并不在源码集合中，iosApp子目录其实是一个标准的Xcode项目，里面全是Xcode项目的配置文件，可以用Xcode直接打开。它是iOS应用的入口，它的调用顺序是iOSApp，到ContentView，这两个是标准的iOS的代码，用的是Swift。然后会进入到「iosMain」中的MainConntroller，这里就到了Kotlin地界了，MainController，再进入到common中的composable App()，由此进入了「commonMain」中。</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/ios-entry.png" alt="图3. iOS源码关系" /></p>

<h2>依赖配置方法</h2>

<p>现代的软件不可能全都是从零开始，有很多现成的代码库可以使用，这就需要为项目配置依赖。CMP中依赖配置方法与常规的Android略不一样，视依赖的使用，以及依赖的平台依赖性，需要分别针对不同的源码集合配置。</p>

<p>需要注意的就是依赖的作用域，如果是在commonMain中配置的，那就会对所有的平台生效；如果是为androidMain配置的依赖，只能在Android中生效，以次类推。</p>

<h3>在源码集合中配置依赖</h3>

<p>最直接的方式就是针对每个源码集合配置其依赖：</p>

<pre><code class="Kotlin">kotlin {
    sourceSets {
        commonMain.dependencies {
            implementation("com.example:my-library:1.0") // 所有平台共享的依赖
        }
    }
}
</code></pre>

<h3>在顶层DSL dependencies中配置</h3>

<p>除了在源码集合处配置依赖，也可以在顶层DSL dependencies中配置，本质都是一样的，只不过是方式略有不同。具体的格式是<strong> &lt;源码集合&gt;&lt;具体的依赖&gt; </strong>，比如上面酱紫写：</p>

<pre><code class="Kotlin">dependencies {
    "commonMainImplementation"("com.example:my-library:1.0")
}
</code></pre>

<p>这与像上面在源码集合commonMain中配置是一样的。在顶层配置依赖的好处在于这里可以配置一些源码集合中找不到的依赖，如testing等等。</p>

<h3>本地module如何相互依赖</h3>

<p>如果是本地的库（module），可以通过project方式引入，同样的如果是共享的库加在common里，如果是某个平台特有的，或者只想在某个平台使用就单独加到它上面：</p>

<pre><code class="Kotlin">kotlin {
    sourceSets {
        commonMain.dependencies {
            implementation(project(":some-other-multiplatform-module"))
        }
    }
}
</code></pre>

<h2>如何共享和定制代码</h2>

<p>CMP的终极目的是要尽可能的共享代码，让一套代码能够跑在多个平台上面。但现实的世界是不完美的，平台的差异是不可忽视的。像存储，I/O，硬件资源等等都是平台强相关的。我们只能尽可能多的共享我们自己写的业务逻辑，对于实现业务逻辑而需要的系统平台相关的API，肯定还是需要每个平台定制化的去实现。</p>

<p>CMP通过Kotlin中的关键字expect和actual来处理平台定制API。</p>

<p>具体的做法就是在common中定义一个用关键字expect修饰的类型（函数，类，接口枚举，属性等），然后在每个平台的源码集合中去具体实现，并用关键字actual来修饰。注意，这里的类型没有限制，可以是函数，可以是类/接口/枚举，也可以是属性，尽管绝大多数情况下都是函数。</p>

<p><img src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/expect-functions-properties.svg" alt="图4. 用expect和actual来定制API" /></p>

<p>可以理解为OO中的接口，但又不完全一样。区别在于，common中的expect函数不能有默认实现代码，并且函数的声明要在同一个包下面。编译的时候，编译器会用平台代码里面的actual去替换common中的expect函数。也就是说这是发生在编译时的行为，所以它要求包名和函数的签名完全一致。</p>

<h2>资源管理</h2>

<p>CMP是能构建跨平台UI的，而UI必然会涉及资源，最常见的资源就是图片和字符串，资源的复杂地方在于它会有限定属性，比如不同屏幕分辨率要用不同的图片，比如不同的地区语言要用不同的字符串，所以资源是相当复杂的，而且平台强相关。</p>

<p>为此CMP提供了一个专门的库用于管理资源，可以屏蔽平台特定，以统一的方式来管理资源。只需要在commonMain中引入依赖即可：</p>

<pre><code class="Kotlin">kotlin {
    sourceSets {
        commonMain.dependencies {
            implementation(compose.components.resources)
        }
    }
}
</code></pre>

<p>资源是放在commonMain中与kotlin同级别的目录中：</p>

<p><img src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/compose-resources-qualifiers.png" alt="图5. 资源文件管理" /></p>

<p>资源可以分为几种类型，图片应该放在子目录drawable中，字体资源放在fonts中，字符串放在values中，其他文件放在files中。</p>

<p>资源文件还可以有限定符以支持定制化，如屏幕分辨率（xhdpi，xxhdpi等），区域语言（en，zh-rCN等）和主题（dark，light等）。可以发现，规则与Android平台资源管理规则是非常接近的。</p>

<p>图片字体等直接添加文件即可，字符串的话放在一个xml文件中，根Tag是resources，每个字符串的Tag是string，如：</p>

<pre><code class="Kotlin">&lt;resources&gt;
    &lt;string name="app_name"&gt;My awesome app&lt;/string&gt;
    &lt;string name="title"&gt;Some title&lt;/string&gt;
&lt;/resources&gt;
</code></pre>

<p>需要注意资源的命名，与Android的资源规则一样，要是小写字符，可以有数字和下划线。</p>

<p>添加好资源后，编译插件会自动生成一个类Res，通过它就可以引用各种资源，如：</p>

<pre><code class="Kotlin">Image(
    painter = painterResource(Res.drawable.my_icon),
    contentDescription = null
)

Text(stringResource(Res.string.app_name))
</code></pre>

<h2>一些开发实践建议</h2>

<p>CMP是为了构建跨平台应用的，那么应该尽最大的可能去共享代码。虽然有平台定制机制，但只应该用它来定制细粒度的具体的API，而不是业务逻辑。比如说，从一个文件中读文本内容，不应该定义一个getFileContent，而是应该定制细粒度的openFile，closeFile和readLine，这是因为读取文件过程真正不同的是处理文件的API，除打开文件，读出每一行以外，其他的逻辑是一样的，应该共享。</p>

<p>还有，在写业务的时候要注意看Compose文档中以及Kotlin文档中API标注的平台范围，尽可能选择标记为「Common」或者「Cmn」的API。</p>

<p>另外，因为Kotlin是基于JVM的语言，标准JDK中的API都可以用，但在CMP的iOS（目标是Native）平台和Web（目标是Wasm）却无法使用JDK的API，所以我们应该多使用Kotlin标准库以及Kotlin扩展库（kotlinx），这些API都做了多平台适配。</p>

<h2>总结</h2>

<p>利益于Gradle中的源码集合，CMP对源码的结构是很宽容的，并没有严格的要求，这对于现有项目来说是相当友好的，因为把现有的项目源码搬进来就可以了，不用改太多，然后通过源码集合来做具体的指定和逻辑上的关系处理。每个源码集合其实都是其平台的一个标准项目，把common作为其依赖而已，关系就这么简单，甚至还可以用其平台的原生方式去写UI，写逻辑，这都是可以的。</p>

<p>虽然这样做貌似会失去共享代码和逻辑的意义，但是这对改造现有项目是十分友好的，比如第一步可能是把Android项目和iOS项目先融合进来，然后再慢慢的把两个平台的共享代码抽离出来入进common。这样做不但能慢慢推进跨端，每个项目各自仍是完整的，如果有紧急 的事情仍可先用原生方式去开发构建。</p>

<h2>References</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/multiplatform-add-dependencies.html">Adding dependencies on multiplatform libraries</a></li>
<li><a href="https://kotlinlang.org/docs/gradle-configure-project.html#configure-dependencies">Configure dependencies</a></li>
<li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-connect-to-apis.html">Use platform-specific APIs</a></li>
<li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-multiplatform-resources.html">Resources overview</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[赶紧上车开启Compose大前端之路]]></title>
    <link href="https://alexhilton.github.io/blog/2024/11/17/compose-multiplatform-made-easy/"/>
    <updated>2024-11-17T20:33:51+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/11/17/compose-multiplatform-made-easy</id>
    <content type="html"><![CDATA[<p>在<a href="https://juejin.cn/column/7367555191338467337">前面的文章中</a>，我们一再强调Jetpack Compose是一个声明式的UI框架，尽管我们都是基于Android开发来实战的，但Compose并不局限于Android开发，它其实与特定的开发平台没有关系，是可以做到跨平台开发的。事实上JetBrains早就已经准备好了一套工具，以让Compose跨平台，开发多端应用，跻身于大前端的一员。今天就来学习一下如何使用Compose进行大前端开发。</p>

<p><a href=""><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/j9tap6mygsqvxh6aauc8.png" title="auto auto" ></a></p>

<!-- more -->


<h2>缘起</h2>

<p>时光荏苒，白云苍狗，自乔帮主发布iPhone开启移动互网联至今已有十余载。对于互联网应用来说，早已从最初的Android加iOS两端并行，发展到现在的大前端时代。时至今日，不论大厂小厂，多端拉齐（Web，Android, iOS, Desktop，鸿蒙）已经是一个标配和强需求。那么如何减少多端的重复开发，如何跨多端开发就成了一个永不过时的研究方向。从最初的Mobile H5，到Hybrid App，再到React Native，再到后来的Flutter，大前端已经得到了长足的发展。得益于Kotlin Multiplatform（KMP），Compose也有了跨端的能力，跻身于大前端工具之列。</p>

<p>在深入主题学习之前，我们先来理解一下重要的概念。</p>

<h2>概念理解</h2>

<p>为了避免混淆和加强理解，需要对一些概念进行澄清。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 概念 </th>
<th style="text-align:left;"> 缩写 </th>
<th style="text-align:left;"> 说明 </th>
<th style="text-align:left;"> 开发者 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> Jetpack Compose </td>
<td style="text-align:left;"> Compose </td>
<td style="text-align:left;"> 基于Kotlin语言的声明式UI开发框架，与平台无关，源于以及主要用于Android开发 </td>
<td style="text-align:left;"> Google </td>
</tr>
<tr>
<td style="text-align:left;"> Compose Multiplatform </td>
<td style="text-align:left;"> CMP </td>
<td style="text-align:left;"> 用于把Compose转化为多端的一个框架 </td>
<td style="text-align:left;"> JetBrains </td>
</tr>
<tr>
<td style="text-align:left;"> Kotlin Multiplatform </td>
<td style="text-align:left;"> KMP </td>
<td style="text-align:left;"> 把Kotlin编译为多端的框架，这是Compose能跨平台的根基 </td>
<td style="text-align:left;"> JetBrains </td>
</tr>
</tbody>
</table>


<p>为了简便，在后文以及以后的文章中将使用缩写。虽然严格来说CMP专指把Compose转化为多端的UI框架，但大部分场合也用它来代指Compose跨端开发，后面也会这样用。</p>

<p><strong>注意：</strong> 在早些时候，也就是在JetBrains刚推出KMP的时候，仅针对和支持Android和iOS两个平台，所以当时就叫做Kotlin Multiplatform Mobile，缩写为KMM，后来也能编译出桌面（Desktop）和Web端了，就把Mobile去掉了，就是现在的KMP，代表Kotlin Multiplatform。所以，如果 在其他地方看到了KMM，把它当成KMP就可以了。</p>

<h2>Compose大前端技术栈</h2>

<p>在继续深入之前，捋捋技术栈，从大的角度来了解一下用到的技术工具的关系是很有必要的。</p>

<p>仍是用Jetpack Compose来写UI，用Kotlin来写业务逻辑，这是个是没有变的。而Compose Multiplatform（CMP）相当于是一个转换工具，能把Compose写的UI转变成为不同平台的UI实现。编程语言用的是都是Kotlin，最终要依赖KMM编译出具体平台的目标文件（Target）。所以，它们三个是依赖关系Compose依赖CMP，它们又都依赖KMM。</p>

<p>最先出现的当然是编程语言Kotlin，之后Google推出了声明式UI框架Jetpack Compose，采用了Kotlin语言。随着Kotlin的发展，JetBrains推出了KMP，让Kotlin实现跨多端，在这之后又基于Compose，推出了CMP，因为都是Kotlin语言，与KMP一起凑成了Compose/Kotlin的跨端。现在谷歌也与JetBrains紧密的合作，一起努力把Compose往前推进，去挑战React Native和Flutter。</p>

<p>学习成本并不高，因为对于开发者来说仍旧是Compose和Kotlin，CMP和KMP是透明的，它们以插件和依赖库的形式存在，没有额外的学习成本。当然，这对Android开发同学来说更为友好一些，因为大部分Android开发同学早已掌握了Compose和Kotlin。</p>

<h2>开发环境搭建</h2>

<p>CMP的技术栈并不复杂，如果已具备Android开发环境，那基本上就齐活儿了，这再次说明CMP对Android开发同学是相当友好的。开发用的IDE就是Android Studio，编译工具用的是Gradle，这对Android同学来说已经是标配了，不熟悉的同学可自行Google。</p>

<p>唯一需要安装的就是KMP的插件（plugin），也即Android Studio中，到插件市场搜索Kotlin Multiplatform，这是JetBrains官方提供的插件，找到后可放心安装，之后重启AS即可。</p>

<p>以上是通用开发配置，但如果目标平台是iOS就略麻烦一些。此小节后面的内容，仅当目标平台包含iOS时需要，否则可以跳过。</p>

<p><strong>注意：</strong> Mac虽然也是水果系统，但Mac属于桌面端（Desktop），如果为Mac构建应用要选择Desktop为目标平台。</p>

<p>因为水果的生态是封闭的，要想构建iOS就必须要用Xcode，而Xcode只在Mac上面才能用，所以要想构建iOS端应用，必须要用Mac来开发，而且要是新一点的Mac（三年以内）。然后安装最新的Xcode就差不多了，官方提供了一个Mac上为iOS环境的检查工具kdoctor（用brew install kdoctor来安装），但其实如果配置了Android开发环境后，再装上Xcode就够了。</p>

<p><strong>注意：</strong> 如果是比较旧的Mac，Big Sur以前的，就不用再折腾了，无法构建iOS，因为构建iOS需要Xcode 12.5，而<a href="https://developer.apple.com/support/xcode/">Xcode 12.5又至少需要macOS 11.7（即Big Sur）</a>。环境检查工具kdoctor本身也是要求Xcode 12.5以上，建议在安装之前可以先用brew info kdoctor来检查一下。水果就这点不好，硬件和软件更新都特别快，向后兼容又不友好，最多支持三个版本（时间跨度在3年左右）。</p>

<h2>创建一个多端应用</h2>

<p>环境配置好后，就可以开始创建CMP了，官方提供了一个<a href="https://kmp.jetbrains.com/?_gl=1*271nsz*_gcl_au*MTE5MzE4NTY0NS4xNzMxMzIzNDU3*_ga*MzUyNjc2MzcuMTU5NDM3NDQ0MA..*_ga_9J976DJZ68*MTczMTQwMDc1MC4xOC4wLjE3MzE0MDA3NTAuNjAuMC4w">KMP项目创建向导</a>可以方便的生成一个项目模板。需要注意的是就是，如果要构建iOS，一定要勾选『Share UI』。</p>

<p><strong>注意：</strong> 要想构建iOS目标需要较新的Mac才可以，如果开发环境不是Mac，或者Mac较旧，就不用钩选iOS了，因为选了也无法构建出来和运行目标产物。</p>

<p><img src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/multiplatform-web-wizard.png" alt="图1. CMP项目创建向导" /></p>

<p>在创建向导中配置好后，点击下载就可以了。解压之后，用Android Studio打开（File | Open）项目文件，就可以开始CMP的开发了。注意，要直接打开解压出来的根目录，而不是里面的某个子目录。因为AS打开的项目默认使用专为Android开发优化后的视图结构「Android」，为了更方便需要切换为「Project」。</p>

<p>可以看一眼项目结构，与常规的Android项目相比差不多，包含了两个模块（module）：</p>

<ul>
<li>composeApp 这是最主要的模块，可以说东西都在这里面。它是一个Kotlin模块（Kotlin module），包含了多端共用代码，以及不同平台的定制代码。使用Gradle来构建，用Gradle的脚本来描述构建方式。</li>
<li>iosApp 这是一个完整的Xcode项目，主要用于构建iOS目标，它会依赖于composeApp。</li>
</ul>


<p><strong>注意：</strong> 如果在<a href="https://kmp.jetbrains.com/?_gl=1*zmaxre*_gcl_au*NDM5ODU1NDAyLjE3Mjc1OTk1MDU.*_ga*MzEyMDU2NTg5LjE2NzQwMDg5NjM.*_ga_9J976DJZ68*MTczMTQwMTE0NC45NC4xLjE3MzE0MDExNDguNTYuMC4w">项目创建向导</a>中没有钩选iOS，将不会有模块iosApp，以及composeApp中的iosMain。</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/cmp-structure.png" alt="图2. 项目结构" /></p>

<p>重点需要关注<strong>composeApp</strong>，它包含了几个源码集合（source sets）：</p>

<ul>
<li>commonMain 这是最主要的集合，包含共享代码，由一个composable函数作为入口开始（如App()）开始。这里应该是项目的主要代码集合。</li>
<li>androidMain 包含与Android平台相关的代码，包括入口（如Android manifest和Activity），入口会调用commonMain中的入口composable。以及提供平台特定的定制化实现。</li>
<li>desktopMain 桌面端的入口，以及定制化实现。</li>
<li>iosMain 水果移动端的入口，以及定制化实现。</li>
<li>wasmJsMain Web端的入口，以及定制化实现。</li>
</ul>


<p><strong>注意：</strong> 源码集的具体数量取决于创建项目时钩选的目标平台。</p>

<p>源码集合（source set）构建工具Gradle的一个概念，它包含逻辑上相关的一坨源码文件，资源文件，以及其依赖，对于Android开发同学来说这个概念并不陌生。</p>

<p><img src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/module-structure.png" alt="图3. 项目源码集合关系" /></p>

<p>这种项目源码集合关系是由KMP定义的，编译构建的时候common部分会编译成为一个依赖组件，平台部分把common当成一个依赖使用，然后最终构建出目标产物，详细的过程可以<a href="https://kotlinlang.org/docs/multiplatform-discover-project.html">看KMP的文档</a>。</p>

<p>这个模板有默认的页面，可以看一下，打开文件commonMain中的App.kt，它包含一个composable函数App()，这就是CMP的入口，可以从这里开始用Compose写应用了。</p>

<h2>构建与运行</h2>

<p>项目创建向导创建出来的模板项目，包含了基本的页面，可以直接构建和运行。</p>

<p><strong>注意：</strong> 首次打开项目会比较慢，这是因为要下载Gradle工具链以及项目的依赖，视网络情况，可能需要几分钟到十几分钟不等，之后就能秒开。</p>

<p><strong>注意：</strong> 创建出来的项目依赖用的都比较新，比如像Android开发插件AGP可能会用8.5.2，但AGP的版本受制于Android Studio，<a href="https://developer.android.com/build/releases/gradle-plugin#android_gradle_plugin_and_android_studio_compatibility">AGP与AS的兼容对应关系可以看这里</a>。如果使用的AS版本较旧，需要调整AGP的版本。</p>

<p>待Gradle sync完成之后，就可以运行了。</p>

<h3>运行Android app</h3>

<p>对于Android app来说可以直接运行，在运行配置那里选择「composeApp」，连上手机（或者模拟器），运行就可以了。</p>

<p><img src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/compose-run-android.png" alt="图4. 运行Android app" /></p>

<h3>运行桌面端（Desktop）App</h3>

<p>桌面端没有默认运行配置，需要创建一个。在菜单中编辑运行配置（Run | Edit Configurations），点左上的加号，选择「Gradle」，输入个名字如「desktopRun」，然后在配置那一侧中的「Tasks and arguments」输入：</p>

<pre><code class="Bash">composeApp:run
</code></pre>

<p><img src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/compose-run-desktop-temp.png" alt="图5. 运行桌面端App" />
之后，选择「desktopRun」运行即可。</p>

<h3>运行iOS app</h3>

<p>如果选择了iOS的话，也有默认运行配置，可直接运行。但水果的东西必须依赖于水果的工具，所以要先打开Xcode，打开就行，放在一边不用做啥。然后回到AS，选择「iosApp」，运行，如果顺利，在Xcode那头就会启动iOS的模拟器，并运行App了。</p>

<p><img src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/compose-run-ios.png" alt="图6. 运行iOS app" /></p>

<p><strong>注意：</strong> 要想运行iOS，Xcode版本必须要在12.5以上，因为iOS构建方式是基于Xcode 12.5的。</p>

<h2>运行Web app</h2>

<p>Web端也没有默认配置，需要像桌面端那样创建一个，同样是Gradle，区别在于命令不一样：</p>

<pre><code class="Bash">wasmJsBrowserRun -t --quiet
</code></pre>

<p><img src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/compose-run-web.png" alt="图7. 运行Web app" />
然后，运行，这会开启一个本地server，如果浏览器没有自动打开的话，就手动打开浏览器，并输入「localhost:8080」，就能看到。</p>

<p><strong>注意：</strong> 如果开发平台是Mac，运行Web app时会有编译错误：</p>

<pre><code class="Bash">Continuous build does not work when file system watching is disabled
</code></pre>

<p>可以通过修改构建指令参数，添加&#45;&#45;watch&#45;fs来解决：</p>

<pre><code class="Bash">wasmJsBrowserRun -t --quiet --watch-fs
</code></pre>

<p>或者添加Gradle选项，以对所有的构建配置命令都生效：</p>

<pre><code class="Bash">org.gradle.vfs.watch=true
</code></pre>

<p>但是，无论是&#45;&#45;watch&#45;fs，还是Gradle选项，对于macOS 12（Monterey）以后才生效，详见<a href="https://docs.gradle.org/current/userguide/file_system_watching.html">Gradle文档</a>。</p>

<p>到此，应该说CMP的开发已经完全就位了。</p>

<h2>总结</h2>

<p>CMP配置简单，上手较快，前景光明，相信通过本文的学习可以了解并完全上车CMP开发了，还等啥呢赶紧上手撸一撸吧！</p>

<h2>References</h2>

<ul>
<li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/get-started.html">Get started with Kotlin Multiplatform</a></li>
<li><a href="https://kotlinlang.org/docs/multiplatform-intro.html">Introduction to Kotlin Multiplatform</a></li>
<li><a href="https://getstream.io/blog/build-app-kotlin-multiplatform/">Build Your First Android and iOS Mobile App With Kotlin Multiplatform</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用Compose中的CompositionLocal来暗渡陈仓]]></title>
    <link href="https://alexhilton.github.io/blog/2024/11/10/understanding-composition-local/"/>
    <updated>2024-11-10T23:17:56+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/11/10/understanding-composition-local</id>
    <content type="html"><![CDATA[<p>通过<a href="https://juejin.cn/column/7367555191338467337">前面的学习</a>我们知道Jetpack Compose是一个声明式的UI框架，采用的是函数式编程思想，直观上来看就是一坨函数从上调到下。当函数需要数据时，会通过函数调用的参数来传递，一般来说这也没有什么问题。但当需要的数据特别多时，特别是对于一些非业务逻辑本身的数据（输入与输出），如上下文环境变量（Context，或者主题之类），都通过函数调用的参数传递就难免会让代码变得非常的庞杂和臃肿。这时候就可以使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/CompositionLocal">CompositionLocal</a>，一种在组合树中隐式的从上到下传递数据的方法，我们来具体地看一下。</p>

<p><a href=""><img src="file:///Users/alexhilton/Downloads/compose_libs/compositionlocal.png" title="auto auto" ></a></p>

<!-- more -->


<p><strong>注意：</strong> Compose中的函数通常叫做composable，可以简单的理解为同一个东西。从根composable开始，一个套一个的调用，自上而下的意思就是指composable的调用顺序，根函数在上，被调用的函数在下。函数调用是可以传递参数的，正常的从上到下的数据传递都是通过函数调用时的参数。</p>

<p>废话不多说，我们先来看一下什么是CompositionLocal以及它能做什么事情。</p>

<h2>什么是CompositionLocal</h2>

<p>CompositionLocal提供一种<strong>自上而下</strong>的数据传递方式，<strong>隐式的传递</strong>，也就是说，不用把数据放在参数里传递给子函数，子函数像在类中的方法访问域变量那样直接访问。我们来看一个粟子。</p>

<p>比如说，页面中有一个文案，可能需要定制字体颜色，常规方式是这样子写：</p>

<pre><code class="Kotlin">@Composable
fun MyApp() {
    val colors = colors()
    SomeTextLabel(text, colors.onPrimary)
}

@Composable
fun SomeTextLabel(labelText: String, color: Int) {
    Text(
        text = labelText,
        color = color
    )
}
</code></pre>

<p>文案的颜色，以及像背景等等这些东西是与整个App的配置相关的，或者与运行环境（如手机）的主题风格有关的，它并不是应用程序的业务逻辑。它属于上下文环境变量，其变化往往是由于运行环境变化而变化，或者是由于用户更改了应用的配置。这就非常适合使用CompositionLocal来转化为隐式数据传递，进而简化代码，使用后就变成酱婶儿的：</p>

<pre><code class="Kotlin">@Composable
fun MyApp() {
    // 在上级函数中定义主题相关的颜色，并定义为CompositionLocal
    val colors = staticCompositionLocalOf( colors() )
    CompositionLocalProvider(LocalColors provides colors) {
        SomeTextLabel(text)
    }
}

// 被调用的子函数
@Composable
fun SomeTextLabel(labelText: String) {
    Text(
        text = labelText,
        color = LocalColors.onPrimary // 可以直接访问定义好的颜色
    )
}
</code></pre>

<p>通过这个示例可以看出，定义了CompositionLocal以后，在被调用到的所有子函数中（desendants）都可以直接使用，就像访问全局变量那样。这就是CompositionLocal的作用，在指定的作用域中提供隐式的数据。</p>

<h2>如何使用CompositionLocal</h2>

<p>使用起来非常的方便，就像在类的方法中使用域变量那样，或者像使用全局变量那样，找到上级所定义的的CompositionLocal实例，然后引用其中的变量即可。</p>

<p>其实，已经在不知不觉中经常地使用了CompositionLocal，主题风格相关的<a href="https://developer.android.com/reference/kotlin/androidx/compose/material3/MaterialTheme">MaterialTheme</a>，Android的上下文<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/package-summary#LocalContext(">LocalContext</a>)以及像绘制时常用的<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/package-summary#LocalDensity(">LocalDensity</a>)，这些都是CompositionLocal实例，是由Compose定义好的顶层实例，在所有的composables中都可以直接使用。</p>

<p>需要理解的是CompositionLocal实例，本身并不是一个数据，它更像是一个集装箱，它本身是一个数据传递的机制，会在后面定义CompositionLocal实例时详细讲解。</p>

<p>另外，需要特别注意的是CompositionLocal是有作用域的，对其所有的子函数生效，并且也可以嵌套的，<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/CompositionLocal#current(">属性current</a>)引用的是最近一层父函数（closest ancestor）中绑定的值。比如说：</p>

<pre><code class="Kotlin">@Composable
fun CompositionLocalExample() {
    MaterialTheme {
        // 绑定一个值到LocalContentColor
        CompositionLocalProvider(LocalContentColor provides MaterialTheme.colorScheme.primary) {
            Surface {
                Column {
                    Text("Uses Surface's provided content color")
                    // 重新绑定一个值到LocalContentColor
                    CompositionLocalProvider(LocalContentColor provides MaterialTheme.colorScheme.error) {
                        DescendantExample()
                    }
                }
            }
        }
    }
}

@Composable
fun DescendantExample() {
    // current会指向最后绑定的值，即MaterialTheme.colorScheme.error
    Text(text = "This Text uses the error color now", color = LocalContentColor.current)
}
</code></pre>

<h2>如何定义一个CompositionLocal</h2>

<p>大部分时候Compose中定义好的就够我们用了，但也可以针对具体的场景来自定义一个CompositionLocal。分为两个步骤，创建实例，和绑定数据。</p>

<p>CompositionLocal实例是一个集装箱，用以封装需要从顶层往底层传递的数据，这些数据也不一定非要是常量，也是会改变的，比如应用或者页面上下文环境变化时，或者整个应用的配置发生变化时。</p>

<h3>创建CompositionLocal实例</h3>

<p>第一步是先创建一个实例，有两种方法创建一个CompositionLocal实例，这两种方式的主要区别就在于当数据变化时如何影响着重组（reComposition）：</p>

<ul>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#compositionLocalOf(androidx.compose.runtime.SnapshotMutationPolicy,kotlin.Function0">compositionLocalOf</a>) 当数据发生变化时仅会影响读取数据函数的重组；</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#staticCompositionLocalOf(kotlin.Function0">staticCompositionLocalOf</a>) 当数组变化时，提供数据的所有子函数都会被重组。</li>
</ul>


<p>可以发现，这两个方法的区别就在于影响重组的范围，前一个是影响着读取数据的地方，这与状态（State）一样；后一个则是影响着所有的被调用的composables。</p>

<pre><code class="Kotlin">// LocalElevations.kt file

data class Elevations(val card: Dp = 0.dp, val default: Dp = 0.dp)

// 使用Elevations的默认值构造一个全局的CompositinLocal实例
// 这个实例可以被应用中的所有composables访问得到
val LocalElevations = compositionLocalOf { Elevations() }
</code></pre>

<p><strong>注意：</strong> 为了更好的可读性和可维护性，CompositionLocal实例的命名应该以Local开头，如LocalColors。</p>

<h3>把数据绑定到实例中去</h3>

<p>光创建实例没什么用，创建完实例后，还需要把数组绑定到CompositionLocal实例中去，并<strong>同时指定作用域</strong>，这是非常关键的一步，不但决定了CompositionLocal中有什么数据，还决定了谁可以使用这些数据。使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#CompositionLocalProvider(kotlin.Array,kotlin.Function0">CompositionLocalProvider</a>)来绑定数据：</p>

<pre><code class="Kotlin">// MyActivity.kt file

class MyActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContent {
            // 基于系统主题来计算具体的elevation
            val elevations = if (isSystemInDarkTheme()) {
                Elevations(card = 1.dp, default = 1.dp)
            } else {
                Elevations(card = 0.dp, default = 0.dp)
            }

            // 把上面计算得到的elevation绑定到LocalElevations
            CompositionLocalProvider(LocalElevations provides elevations) {
                // ... Content goes here ...
                // 这里的子composables都可以直接访问LocalElevations.current
                // 以得到elevation
            }
        }
    }
}
</code></pre>

<p>函数CompositionLocalProvider接收一个CompositionLocal实例和一个composable lambda，这个lambda就是这个实例的作用域，也即此lambda所调用的所有composables都可以使用访问此实例的数据。参数LocalElevations就是实例，可以看前面的创建代码。LocalElevations provides elevation这是infix符号式写法，相当于LocalElevations.provides(elevation)，elevation则是具体的数据，这意思就是在此lambda的作用域中，CompositionLocal实例LocalElevations会提供数据elevation。</p>

<pre><code class="Kotlin">@Composable
fun SomeComposable() {
    // 使用的地方直接通过LocalElevations.current就能访问到
    MyCard(elevation = LocalElevations.current.card) {
        // Content
    }
}
</code></pre>

<p>这里多说一下，compositionLocalOf是更为精细化的控制（fine-grained control），因为，当数据发生变化时，在作用域中只有读取了数据的composables才会被重组；而staticCompositionLocalOf影响范围较大，因为（当数据发生变化 时）整个作用域内（即CompositionLocalProvider的lambda）的composables都会被重组。</p>

<h2>什么时候该用CompositionLocal</h2>

<p>CompositionLocal提供了一种新的数据传递方式，当数据需要在一定作用域内（Scoped）分享时，就可以考虑使用它。但并不是所有的场景都适用，具体来说，要符合以下标准：</p>

<ul>
<li>数据要是非业务逻辑数据，也就是非代码所直接需要的输入和输出。</li>
<li>数据要有一个极其合理的初始值（默认值）。</li>
<li>数据不一定要是常量，也可以变化，但是业务逻辑并不是数据变化的原因。</li>
<li>数据的使用有一定的作用域。并且在作用域内<strong>所有的composables都可能会</strong>使用此数据。这一点很重要，如果仅仅是某个特定的composable使用，那就直接传参就好了。</li>
</ul>


<p>适合使用CompositionLocal的数据有应用的主题风格，应用的配置信息，平台提供的上下文变量，平台的配置信息，或者对于一个局部来说是上下文变量的数据（比如说一个Dialog用到的数据）。除此之外，绝大部分时候不应该使用CompositionLocal。特别是涉及业务逻辑代码本身强相关的数据（输入与输出），一定不能使用CompositionLocal，这会让代码极难理解和维护，造成极难调试的Bug。</p>

<p>CompositionLocal的一个大的特点就是有明确的作用域，那么如何选择合适的作用域呢？总的来说应该让作用域越小越好。视数据的 影响范围和使用范围来决定其作用域：</p>

<ul>
<li>整个应用级别的（App level），如主题风格，应用配置，平台的配置信息，或者会话数据（user sessions）。应该在根composable，即setContent处绑定数据。</li>
<li>整个页面级别的（Screen level），如平台上下文变量（Context或者Density），导航，或者页面内部的定制参数。</li>
<li>组件级别的（Component level），页面中某一个局部，比如Dialog的主题风格，或者Dialog并不直接操作，但却依赖的数据。</li>
</ul>


<p>任何工具都是为了适合其的场景而生的，要了解清楚什么场景适合使用非常重要，切忌滥用。</p>

<h2>它与状态（State）的区别是什么</h2>

<p>从前面的文章<a href="https://juejin.cn/post/7376094685495001139">降Compose十八掌之『鸿渐于陆』| State</a>我们了解到，状态（State）是为了重组时数据不丢失，也就是说在composable多次运行时，数据能够得以留存。反过来状态变化了，也会触发重组，因为要刷新UI。状态是时间上的概念（使用此状态的composables）多次运行，状态持有的数据都得以保存，不会变成初始值。如果想要使用状态，必须当作参数传递过去。</p>

<p>而CompositionLocal是为了能在不同的composables中共享数据，不用参数传递，它是空间上的概念。</p>

<p>它们是为了解决不同的问题而设计出来的。可以把状态绑定到CompositionLocal中去，但其实没必要这么做，因为内部实现上已经会把绑定的数据封装为状态，因为CompositionLocal的数据是可能发生变化的，并且当变化时，也是要触发重组的。</p>

<h2>它与全局变量的区别是什么</h2>

<p>Kotlin语言是支持顶级全局变量（Top level globals）的，也就是与class平齐，在任何class之外的全局变量，其作用域是整个进程，任何导入（import）此变量的地方都可以访问。Compose是基于Kotlin语言的，所以Compose也是可以使用全局变量的。</p>

<p>全局变量的缺点是没有作用域，容易失控，仅应该用于常量，并且它也不能用于composables的重组。虽然全局变量可以跨越空间，让所有函数都能访问。全局变量是编程语言层面的东西，仅适用于常量的定义，也即整个应用程序运行期间确定不会发生改变的值。</p>

<p>这正是CompositionLocal有价值的地方，它能限定作用域，又可以触发重组，允许数据值改变，又可以跨越空间。这是Compose框架层面提供的工具，自然更适合在Compose中使用。</p>

<h2>总结</h2>

<p>调用函数时传递参数可谓是『明修栈道』，而CompositionLocal则是『暗渡陈仓』，提供了一种在组合（Composition）中自上而下隐式传递数据的一种方式，可以让函数调用只关心与逻辑相关的输入数据。恰当的使用CompositionLocal可以有效的管控上下文环境变量，并极大地简化代码，让代码更加的优雅和简洁。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/compositionlocal">Locally scoped data with CompositionLocal</a></li>
<li><a href="https://www.valueof.io/blog/compose-compositionlocal-compositionlocalprovider">Passing data using CompositionLocal</a></li>
<li><a href="https://www.kodeco.com/34513206-compositionlocal-in-jetpack-compose">CompositionLocal in Jetpack Compose</a></li>
<li><a href="https://medium.com/mobile-innovation-network/understanding-composition-local-jetpack-compose-4546605df5e1">Understanding Composition Local: Jetpack Compose</a></li>
<li><a href="https://medium.com/@ramadan123sayed/composition-local-in-jetpack-compose-4d0a54afa67c">Composition Local in Jetpack Compose</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[给Jetpack Compose添加Native支持]]></title>
    <link href="https://alexhilton.github.io/blog/2024/11/08/android-jni-made-easy/"/>
    <updated>2024-11-08T22:40:32+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/11/08/android-jni-made-easy</id>
    <content type="html"><![CDATA[<p>Jetpack Compose是一个声明式的UI框架，但一个项目不可能光有UI，还需要有业务逻辑。Compose所用的编程语言是Kotlin，一种基于JVM的多范式通用编程语言，尽管非常强大，但因为现代的项目都非常复杂，多语言混合，有些东西用Kotlin没法实现，或者有些现成的C/C++代码可以复用，这时就需要能把native代码集成到Compose项目中去。</p>

<p><a href=""><img src="https://questdot.com/wp-content/uploads/2016/07/ndkjni-720x340.png" title="auto auto" ></a></p>

<!-- more -->


<p>想要在Compose中使用native代码是完全可行的，这是因为Compose是基于Kotlin的，而Kotlin本质上是JVM的字节码，也就是运行在虚拟机之上的语言。Java的Native接口，即JNI其实是虚拟机开出的口子，只要能在JVM上运行就可以用JNI，所以标准的Java JNI是完全可以用在Compose里面的。</p>

<p><strong>注意：</strong> native代码（原生代码）在不同的语境有不同的意思，它通常指操作系统直接支持的可执行程序。Java（字节码）是运行在虚拟机上的，操作系统被虚拟机给隔离了，对Java是透明的，这时像可以编译为直接在操作系统上运行的代码（如C/C++）称为native代码；假如换个语境，如运行在WebView中的Web前端，则可以直接运行在Android上的或者iOS上的原生SDK代码则称为native代码。</p>

<p>先来看一下如何在Compose项目中添加native支持。</p>

<h2>新项目</h2>

<p>新的项目在创建项目的时候可以选择C++，无论是Kotlin的类，以及C++的实现，以及配置文件都会有模板。但除了demo以外，一般不会有新建项目的机会，极少项目是从0开始。绝大多数情况都是在现有项目中添加native支持，所以我们重点看看如何在现有项目中添加native支持。</p>

<h2>现有项目添加JNI支持</h2>

<p>现在的Android Studio已经对JNI有了很好的支持，AGP中也提供了支持，所以可以不用NDK中命令行式的ndk-build了。对于现有项目想添加JNI支持也不麻烦，有两种方式：一种是添加一个native的Module，新建Module时选择native library就可以了，这个Module里面与新建的Native项目是差不多的。这种方式适合于比较独立的一个新的需要native支持的模块，然后此模块再作为主模块的依赖，比较合适的场景是一个独立的功能模块；</p>

<p>第二种方式就是，像新建 的native项目那样，直接添加native支持：</p>

<h3>Step 1 添加C/C++源码目录</h3>

<p>先在对应的module如app中添加cpp源码目录，要放在与java或者kotlin同级别的目录，如app/src/main/下面，之后所有native层的东西都在app/src/main/cpp下面。</p>

<h3>Step 2 设置CMake</h3>

<p>在建 好的目录下面添加源码LocalJNI.cpp和编译文件CMakeLists.txt。</p>

<pre><code class="Bash">cmake_minimum_required(VERSION 3.22.1)

project("effectivejni")

add_library(${CMAKE_PROJECT_NAME} SHARED
        # List C/C++ source files with relative paths to this CMakeLists.txt.
        LocalJNI.cpp)
target_link_libraries(${CMAKE_PROJECT_NAME}
        # List libraries link to the target library
        android
        log)
</code></pre>

<p>CMake是一个跨平台的C/C++编译系统，可以参考 <a href="https://cmake.org/">其官文档</a>了解详细信息。</p>

<h3>Step 3 在Gradle脚本中添加native build关联</h3>

<p>在android块中加入externalNativeBuild：</p>

<pre><code class="Kotlin">android {
    // ...
    externalNativeBuild {
        cmake {
            path("src/main/cpp/CMakeLists.txt")
            version = "3.22.1"
        }
    }
}
</code></pre>

<h3>Step 4 添加带有native方法的类</h3>

<p>这一步要特别注意，因为JNI是Java Native Interface，所以必须要严格符合Java的方式，native方法的声明必须是某个类的方法；另外，JNI调用Java时也必须先找到某个类，然后再调用它的方法。所以必须 要有一个Java的public类：</p>

<pre><code class="Kotlin">package net.toughcoder.effectivejni

class LocalJNI {

    external fun stringFromLocal(): String

    companion object {
        init {
            System.loadLibrary("effectivejni")
        }
    }
}
</code></pre>

<p>当然，这个类可以放在任何文件中。因为Kotlin放宽了Java的限制，在Java中每一个public的类必须要放在一个名字一样的文件中，但Kotlin的文件与类没有对应的关系，所以可以把这个类放在任何文件中，当然了package要指明，因为在JNI中查找class时，要指定package name。</p>

<h3>Step 5 实现native方法</h3>

<p>具体native方法的实现就看具体要做什么了。这里只是演示所以简单返回一个字符串。</p>

<pre><code class="C++">#include &lt;jni.h&gt;
#include &lt;string&gt;

extern "C" JNIEXPORT jstring JNICALL
Java_net_toughcoder_effectivejni_LocalJNI_stringFromJNI(
        JNIEnv* env,
        jobject /* this */) {
    std::string hello = "Hello from C++ with static mapping";
    return env-&gt;NewStringUTF(hello.c_str());
}
</code></pre>

<p><strong>注意：</strong> 虽然Compose使用的编程语言是Kotlin，但毕竟Kotlin是JVM语言，也与Java可以相互替换。对于JNI来说，Kotlin与Java无区别，所以后面会以Java来统一当作native的另一端。</p>

<h2>JNI注册</h2>

<p>无论是用C/C++去实现native接口，还是复用现成的native方法，都需要要把native方法与Java层声明的方法进行关联映射，以让JVM能找到此方法的实现，这也即所谓的JNI注册。有两种方式进行JNI注册。</p>

<p>静态方式，其实就是Java默认支持的方式，它要求Native的实现函数是纯C的，要用『extern C』包裹起来，还有就是方法的名字要是Java&#95;包名&#95;类名&#95;方法名，比较严格。前面的示例用的就是静态注册。</p>

<p>动态注册的原理是加载so的时候，当虚拟机在找到so以后，会查找里面一个叫做JNI&#95;OnLoad的函数指针，然后执行此函数。那么，在so的实现中，写一个叫做JNI&#95;OnLoad的函数，在里面手动进行Native方法注册，然后当so被加载时JNI&#95;OnLoad就会被执行，JNI方法就注册好了。</p>

<pre><code class="C++">#include &lt;jni.h&gt;
#include &lt;string&gt;

// Method declaration
jstring dynamicString(JNIEnv *env, jobject thiz);

// JNI wrapper
const char className[] = "net/toughcoder/effectivejni/LocalJNI";

const JNINativeMethod methods[] = {
        {"stringFromJNI", "()Ljava/lang/String;", reinterpret_cast&lt;void *&gt;(dynamicString)}
};

JNIEXPORT jint JNICALL JNI_OnLoad(JavaVM *vm, void *reserved) {
    JNIEnv *env;
    if (vm-&gt;GetEnv(reinterpret_cast&lt;void **&gt;(&amp;env), JNI_VERSION_1_6) != JNI_OK) {
        return JNI_ERR;
    }
    jclass clazz = env-&gt;FindClass(className);
    env-&gt;RegisterNatives(clazz, methods, (int) (sizeof(methods) / sizeof(methods[0])));

    return JNI_VERSION_1_6;
}

// The implementation
jstring dynamicString(JNIEnv *env, jobject thiz) {
    std::string str = "String from JNI via dynamic mapping.";
    return env-&gt;NewStringUTF(str.c_str());
}
</code></pre>

<p>这个JNI&#95;OnLoad的方法的参数很有意思是一个JavaVM对象指针，JavaVM对象每个应用进程只有一个，可以认为就是应用的虚拟机。但每个JNI方法都有一个JNIEnv对象指针，它给native方法提供一个JNI上下文，这个则是每个线程都有一个。</p>

<p>推荐使用动态注册方式进行JNI注册，这是因为这种方式更为灵活，不必写繁琐的方法声明，也不必用extern C限制，可以是常规的C++函数。</p>

<h2>JNI是一个接口层</h2>

<p>JNI是一个口子，可以让Java调用native代码，也能让native代码调用Java代码，调用Java代码就相当于反射。JNI是一个传送门，虽然入口处有一些限制，但深入到native里面就是完全的C和C++世界了，只要是C和C++能实现的事情都可以做。</p>

<p><img src="file:///Users/alexhilton/Downloads/JNI.svg" alt="图1. JNI是一个传送门" /></p>

<h2>JNI线程</h2>

<p>需要注意的是结构体JavaVM是所有线程共享，它代表着进程所在的虚拟机。但结构体JNIEnv则是代表着栈中的执行环境（因为JNI仅一个方法，而方法必然运行在某个线程之中），每个线程有一个。创建的局部引用也不能跨线程使用。</p>

<p>从JNIEnv获取JavaVM：env->GetJavaVM(&amp;vm)</p>

<p>从JavaVM获得当前JNIENV：vm->AttachCurrentThread(&amp;env, null)</p>

<p>最好都从Java层来管理线程，JNI只是某些方法的实现。</p>

<p>如果JNI的native代码也很复杂需要线程的话，也可以用pthread创建线程，但也应该维持在一定的作用域范围内，不应该再从此线程去调用Java。这样只会制造混乱。</p>

<h2>两个世界的对象连接</h2>

<p>需要注意JNI是纯C接口，没有对象的概念，入口处的native方法不属于任何C++对象。假如native深入层足够复杂也有一套对象，如何建立起 Java层对象和native对象的连接呢？可以参考Android frameworks的作法，它通常会给Java层的对象有一个整形域变量，用以存放native层对象指针，这样就能建立起来对象与对象的一一对应关系。</p>

<h2>添加已编译好的native库</h2>

<p>JNI是连接Java层与C/C++层的传送门，除了新写的native代码，也可以直接使用已编译好的C/C++的库，静态库libxxx.a和动态库libxxx.so。</p>

<p>预编译的库通常作为JNI的依赖，当然也可以直接加载，前提是so里面已包含了JNI接口。但需要特别注意的是静态的库.a是无法直接在Java中加载的，也即无法通过System.loadLibrary()来加载native的静态库。因此静态库只能作为依赖，要包一层，写一个Wrapper层编译为so，静态库作为so的依赖，然后把so加载为JNI。</p>

<p>通过CMake中的add_library指令来添加预编译好的库，具体可以 <a href="https://cmake.org/cmake/help/latest/command/add_library.html">参考其文档</a>。</p>

<h2>NDK的版本</h2>

<p>在项目的配置gradle文件中可以指定具体的NDK版本：</p>

<pre><code class="Kotlin">android {
    ndkVersion = "28.0.12433566"
}
</code></pre>

<p>NDK的版本可以看<a href="https://developer.android.com/ndk/downloads/revision_history">官方发布历史</a>，NDK主要是指Android提供的native API（C/C++ API），主要是一些系统提供的能力，如音频视频能力，图形图像能力等，可以看<a href="https://developer.android.com/ndk/guides/stable_apis">其接口说明文档</a>，以及<a href="https://developer.android.com/ndk/reference">NDK开发文档</a>。</p>

<h2>C/C++的版本指定</h2>

<p>C++语言自从其诞生，在Java和新一代编程语言出现后，曾一度长期停滞，在泛型，函数式编程，并发上面落后于其他语言，并被诟病。但从C++11开始，（C++语言的版本以年份的后两位来命名，如C++11是指2011年发布的版本，C++17指2017年发布的，以此类推）这门古老的语言焕然一新，增加了很多新时代编程语言的特性，其后的C++17继续前进，到现在的C++20已经完全是一个现代化的编程语言了，lambda，函数式，泛型和并发都有了非常好的支持，甚至已经超越了老对手Java。因此，C++11以后的版本也称为『现代C++（Modern C++）』。</p>

<p>都4202年了，肯定要用最新的C++20才行啊。CMake使用的是LLVM编译器，而LLVM已经完全支持C++20了，但默认的版本使用的是C++17，想要特别的版本，就需要在CMakefile.txt中进行指定，也即通过添加编译选项来指定C++的版本：</p>

<pre><code class="Bash">set(CMAKE_ANDROID_STL_TYPE "c++_shared")
set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -std=c99")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++20")
</code></pre>

<h2>JNI内存管理</h2>

<p>Java层是自动档（自动内存管理），但C/C++是手动档，因此穿过JNI后就需要特别小心内存管理。有一些注意事项：</p>

<ul>
<li>Java 层传过来的对象，不需要手动去释放。比如说传过来的数组或者字符串。</li>
<li>传回给Java层的对象，也不需要手动释放。比如像上面的例子新创建出来的字符串，尽管使用了New，但不需要管。GC会追踪。而且你也没法释放，创建完对象交给Java层了，不确定Java还在不在使用中呢，你咋delete？</li>
<li>只应该管理生命周期全都在native的new出来的对象，和引用。</li>
<li>需要特别注意方法运行的上下文，也即JNIEnv，这个东西每个线程有一个，且是不同的。要保证在同一个JNIEnv中管理内存，不同的JNIEnv无法共享创建出来的对象和引用，不能交叉使用，更不能交叉式的释放。</li>
</ul>


<h2>JNI能做什么</h2>

<p>JNI是一个接口层，能够让Java进入C/C++世界，调用C/C++的代码，包括现有代码。所以只要编译出来了目标平台（ARM）的so，就可以在JNI中用。</p>

<p>当然了，为了兼容性，使用的so最好用NDK进行编译。</p>

<p>因为Android是Linux内核的，所以，理论上Linux系统调用支持的东西全都能在JNI里面搞。当然，使用native最为正确的体位是使用NDK来实现想要的功能，可以查看<a href="https://developer.android.com/ndk/reference">NDK的开发文档</a>来明确可以做哪些事情。</p>

<h2>使用JNI的正确姿式</h2>

<p>JNI虽好，但不要滥用，不能单单以『C/C++语言性能高于Java（JVM）』为理由就去使用JNI。JNI本身是一个口子，单从方法调用角度讲，从Java层调用过来要有历经查询和数据转换，不见得会比Java方法高效到哪里去。而且JNI在线程调度，异常管理和内存管理上面都较Java层相比非常的不方便，那点看起来的性能优势的代价是很大的，所以说能不用JNI就别用。</p>

<p>使用JNI的正确理由：</p>

<ol>
<li>做一些Java层无法做到的事情，比如一些底层的系统调用（System calls），Java层做不到，那自然得用C/C++</li>
<li>使用一些现有的C/C++代码，这个是最为正统的理由</li>
<li>基于安全角度考量，把一些关键的实现放在C/C++层，这个也合理，因为C/C++相较于Java字节码要略难破解一些</li>
<li>基于跨平台角度考虑，把一些与平台关联密切的，且独立的模块用C/C++实现，比如像通信协议，或者加密，或者压缩之类的非常独立的功能模块，用C/C++来实现，屏蔽名个平台的不同，这会让Java层更加的简单</li>
</ol>


<p>除此之外，似乎没有理由使用JNI。另外，在使用的时候也要注意尽可能的单进单出，也就是说从Java层调用native方法，进去后一直在native运算，得到结果后返回给Java。而不应该频繁的有交互，比如说Java层调用进了native方法，但在native中又频繁 的调用Java层的方法。这明显是设计不合理，应该在Java层把需要的数据准备齐全后，再调用native层。</p>

<h2>References</h2>

<ul>
<li><a href="https://juejin.cn/post/7382893339098906665">Android JNI入门</a></li>
<li><a href="https://juejin.cn/post/7302684536148230194">一、Android-JNI开发</a></li>
<li><a href="https://juejin.cn/post/6844903933375152136">Android NDK-深入理解JNI</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1666741">JNI线程相关</a></li>
<li><a href="https://developer.android.com/studio/projects/add-native-code">Add C and C++ code to your project</a></li>
<li><a href="https://developer.android.com/training/articles/perf-jni">JNI tips</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
