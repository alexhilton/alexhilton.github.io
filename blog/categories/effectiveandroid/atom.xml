<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2025-02-24T22:46:38+08:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[详解DiffUtils、Myers算法和 Jetpack Compose]]></title>
    <link href="https://alexhilton.github.io/blog/2025/02/24/diffutils-and-jetpack-compose/"/>
    <updated>2025-02-24T22:33:47+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/02/24/diffutils-and-jetpack-compose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自<a href="https://proandroiddev.com/diffutils-myers-algorithm-and-jetpack-compose-028c726e574d">《DiffUtils, Myers’ Algorithm and Jetpack Compose》</a>，原文发布于2024年12月27日。</p></blockquote>

<p>在 Android UI 开发领域，DiffUtils 是优化 RecyclerView 中列表更新的必备工具。DiffUtils 是一个实用程序类，它计算将一个列表转换为另一个列表所需的<strong>最小更改</strong>，并仅更新 UI 中已更改的部分，从而<strong>节省性能并减少不必要的重绘</strong>。这个强大的工具依赖于<strong>Myers算法</strong>，这是一种在两个序列之间找到<strong>最短编辑脚本（Shortest edit script）</strong>的有效方法。</p>

<p><a href=""><img src="https://www.pngmart.com/files/Android-App-Development-PNG-Free-Download.png" title="auto auto" ></a></p>

<!-- more -->


<p>但在 Jetpack Compose 中，是没有DiffUtils的，这又是为什么呢？</p>

<p>在这篇博客中，我将详细分析 DiffUtils 的工作原理、它与 Myers 算法的联系、为什么它是现代 Android 开发的重要组成部分，并探讨为什么 DiffUtil 在 Compose 中是不必要的、Compose 如何优化 UI 更新，以及你应该使用什么来代替。</p>

<p>让我们开始吧！</p>

<h2>DiffUtils 是什么？</h2>

<p>DiffUtils 是 Android 中的一个实用程序，它可以比较两个列表并生成一系列更新操作，例如：</p>

<ul>
<li>插入：添加新项目。</li>
<li>删除：移除过时的项目。</li>
<li>移动：重新排序现有项目。</li>
</ul>


<p>然后可以应用这些操作来有效地更新列表，最大限度地减少不必要的重绘或重新计算。这在 RecyclerView 等性能至关重要的组件中特别有用。</p>

<h3>DiffUtils 的工作原理</h3>

<blockquote><p>DiffUtil 使用 Eugene W. Myers 的差异算法来计算将一个列表转换为另一个列表所需的最少更新次数。Myers 的算法不处理移动的项目，因此 DiffUtil 对结果进行第二次遍历以检测移动的项目。&ndash; <a href="https://developer.android.com/reference/androidx/recyclerview/widget/DiffUtil">https://developer.android.com/reference/androidx/recyclerview/widget/DiffUtil</a></p></blockquote>

<p>Android 中的 DiffUtils 基于 Myers 算法，用于比较列表并找出它们之间的差异。Myers 算法和 DiffUtils 的目标是相同的：确定将一个序列（列表）转换为另一个序列（列表）所需的最小更改次数，包括插入、删除和移动。从本质上讲，DiffUtils 通过识别以下内容来计算两个列表之间的差异：</p>

<ol>
<li>最长公共子序列 (LCS)：新旧列表之间保持不变的元素。</li>
<li>编辑操作：将旧列表转换为新列表所需的插入、删除和移动。</li>
</ol>


<p><strong>关键见解：</strong>
DiffUtils使用 LCS 的概念来最小化更改（插入和删除），并且还针对移动进行了优化——这是基于列表的比较所特有的功能，其中元素不仅被删除和插入，而且还被重新定位。</p>

<h3>Myers 算法：DiffUtils 的基础</h3>

<p>Myers 算法于 1986 年推出，旨在计算两个序列之间的<strong>最短编辑脚本 (SES，Shortest Edit Script)</strong>。它找到将一个序列转换为另一个序列所需的最少操作数。这些操作包括：</p>

<ul>
<li>插入</li>
<li>删除</li>
<li>匹配（按顺序排列的公共元素）</li>
</ul>


<h4>Myers 算法的关键概念</h4>

<p>Myers 算法旨在找到将一个序列（例如，旧列表）转换为另一个序列（新列表）所需的最少<strong>插入、删除和移动</strong>次数。该算法基于<strong>编辑距离（Edit Distance）</strong>的概念，并专门计算将一个序列转换为另一个序列的一系列操作。</p>

<p>Myers 算法在计算<strong>最短的编辑操作序列</strong>方面特别有效，从而最小化所需的总更改次数。核心思想是找到两个序列之间的<strong>最长公共子序列 (LCS)</strong>，然后确定将旧序列转换为新序列的最小操作。</p>

<p>最长公共子序列 (LCS)：Myers 算法首先确定两个列表之间的 LCS。LCS 表示不需要修改的元素。</p>

<p><strong>编辑图：</strong></p>

<ul>
<li>该算法将转换可视化为一个图，其中每条路径
代表一系列操作（插入、删除或匹配）。</li>
<li>通过该图的最短路径对应于最短编辑脚本
（SES）。</li>
</ul>


<p><strong>优化：</strong></p>

<ul>
<li>Myers 算法使用动态规划来减少计算开销，实现高效的 O(ND) 时间复杂度，其中 N 和 D 是序列的长度和它们之间的距离。</li>
</ul>


<h3>DiffUtils 实际应用示例</h3>

<p>让我们考虑两个列表：</p>

<pre><code class="Kotlin">// Old list
["a", "b", "c", "d"]
// New List
["a", "d", "c", "b"]
</code></pre>

<ol>
<li><strong>确定 LCS</strong>：此处的 LCS 为 [&ldquo;a&rdquo;] 。</li>
<li><strong>计算编辑脚本</strong>：</li>
<li>删除“b”（旧列表）。</li>
<li>将“d”移到“c”之前。</li>
<li>在“c”之后插入“b”。</li>
<li><strong>应用更改</strong>：使用这些最少的操作将旧列表转换为新列表。</li>
</ol>


<h3>DiffUtils 在 RecyclerView 中的作用</h3>

<p>在 RecyclerView 中，每次更新都涉及计算哪些项目发生了变化、哪些项目被添加以及哪些项目被删除。单纯地更新整个列表可能会导致卡顿或无响应等性能问题。DiffUtils 通过以下方式解决此问题：</p>

<ul>
<li>最小化更改：仅执行必要的更新。</li>
<li>优化性能：实现流畅的动画和高效的列表更新。</li>
<li>减少重绘：仅重新渲染受影响的项目，从而提高整体 UI 响应能力。</li>
</ul>


<pre><code class="Java">// 第1步: 创建一个DiffUtil.Callback
public class MyDiffCallback extends DiffUtil.Callback {
    private final List&lt;String&gt; oldList;
    private final List&lt;String&gt; newList;

    public MyDiffCallback(List&lt;String&gt; oldList, List&lt;String&gt; newList) {
        this.oldList = oldList;
        this.newList = newList;
    }

    @Override
    public int getOldListSize() {
        return oldList.size();
    }

    @Override
    public int getNewListSize() {
        return newList.size();
    }

    @Override
    public boolean areItemsTheSame(int oldItemPosition, int newItemPosition) {
        return oldList.get(oldItemPosition).equals(newList.get(newItemPosition));
    }

    @Override
    public boolean areContentsTheSame(int oldItemPosition, int newItemPosition) {
        return oldList.get(oldItemPosition).equals(newList.get(newItemPosition));
    }
}

// 第2步: 计算差异
DiffUtil.DiffResult diffResult = DiffUtil.calculateDiff(
    new MyDiffCallback(oldList, newList)
);

// 第3步: 派发更新
myAdapter.submitList(newList);
diffResult.dispatchUpdatesTo(myAdapter);
</code></pre>

<p>DiffUtils 是一款功能强大的工具，用于处理 Android 中的列表更新，确保高效且最小的更改。通过利用 Myers 算法，它可以计算出将一个列表转换为另一个列表的最短编辑脚本。了解其工作原理不仅可以提高你对 Android 开发的掌握，还可以帮助你优化 RecyclerView 的性能。</p>

<h2>为什么 Compose 不需要 DiffUtils</h2>

<p>Jetpack Compose 建立在<strong>声明性 UI 原则</strong>之上，这意味着你可以根据当前状态<strong>描述 UI 应该是</strong>什么样子，而 Compose 会处理其余的事情。</p>

<p><strong>命令式 UI（视图）：</strong></p>

<ul>
<li>通过确定需要应用哪些更改，你可以手动更新 UI 组件。</li>
<li>DiffUtil 等工具对于计算列表的最小更新以控制性能必不可少。</li>
</ul>


<p><strong>声明式 UI（Compose）：</strong></p>

<ul>
<li>你描述给定状态下的 UI 应该是什么样子，而不是如何更改它。</li>
<li>Compose 会自动重新组合受状态更改影响的 UI 部分。</li>
</ul>


<p>在 Compose 中，<strong>状态驱动 UI，重组处理更新</strong>。DiffUtils 无需计算增量，因为系统会自动优化要重新渲染的内容。</p>

<p>以下是 Compose 不再需要 DiffUtils 的主要原因：</p>

<ol>
<li><strong>状态驱动的UI</strong></li>
</ol>


<p>在 Compose 中，当状态发生变化时，UI 会自动重组。你无需手动计算列表之间的差异；Compose 会为你处理。</p>

<pre><code class="Kotlin">val items = remember { mutableStateListOf("Apple", "Banana", "Cherry") }

LazyColumn {
    items(items) { item -&gt;
        Text(text = item)
    }
}
</code></pre>

<p>如果你从 items 中添加或删除项目，Compose 将仅重组 UI 中受影响的部分。无需 DiffUtils！</p>

<ol>
<li><strong>内置优化</strong></li>
</ol>


<p>Compose 使用 LazyColumn 和 LazyRow 中的键来优化项目渲染。通过为每个项目指定一个唯一键，Compose 可以识别哪些项目已更改、已添加或已移除。</p>

<pre><code class="Kotlin">LazyColumn {
    items(items = yourList, key = { item -&gt; item.id }) { item -&gt;
        Text(text = item.name)
    }
}
</code></pre>

<p>该key确保 Compose 有效地仅更新受影响的项目，类似于 DiffUtils 所做的。</p>

<ol>
<li><strong>智能重组</strong></li>
</ol>


<p>Compose 可以智能地跳过未发生改变的 UI 元素的重组。使用 Remember 和 RememberSaveable 等工具，你可以进一步优化重组行为。</p>

<pre><code class="Kotlin">@Composable
fun RememberExample() {
    val count = remember { mutableStateOf(0) }

    Button(onClick = { count.value++ }) {
        Text("Clicked ${count.value} times")
    }
}
// 在这里，当状态发生变化时，只有Button中的Text，而不是整个组件，会发生重组
</code></pre>

<p><strong>Compose 中的重组：</strong></p>

<ul>
<li>Compose 会观察状态变化。当特定 UI 元素的状态发生变化时，只会重组该元素（及其依赖项）。</li>
<li>系统会完全跳过未更改的 UI 元素。</li>
</ul>


<p><strong>Views 中的 DiffUtils：</strong></p>

<ul>
<li>需要明确计算列表的新旧状态之间的变化。</li>
<li>然后分派计算出的更改以更新 RecyclerView。</li>
</ul>


<h3>在 Compose 中用什么来代替 DiffUtils</h3>

<p>虽然你不需要 DiffUtils ，但 Compose 提供了实现类似优化的工具：</p>

<ol>
<li>带 Keys 的 LazyColumn</li>
</ol>


<p>使用 key 可以有效地识别和管理列表中的更改。</p>

<pre><code class="Kotlin">LazyColumn {
    items(items = yourList, key = { item -&gt; item.id }) { item -&gt;
        Text(text = item.name)
    }
}
</code></pre>

<ol>
<li>SnapshotStateList</li>
</ol>


<p>若要以被动方式管理列表，请使用 SnapshotStateList 。</p>

<pre><code class="Kotlin">val items = remember { mutableStateListOf("Apple", "Banana", "Cherry") }
Button(onClick = { items.add("Date") }) {
    Text("Add Item")
}
LazyColumn {
    items(items) { item -&gt;
        Text(text = item)
    }
}
</code></pre>

<ol>
<li>SubcomposeLayout</li>
</ol>


<p>对于复杂的场景，SubcomposeLayout 可以精确控制要重组的内容。</p>

<h2>相关的面试问题</h2>

<ol>
<li>为什么 Jetpack Compose 不需要 DiffUtils ？</li>
</ol>


<p>Compose 依赖于声明性 UI 模型。它会根据状态变化自动更新 UI，无需像 DiffUtil 那样手动计算列表差异。使用 LazyColumn 中的键可确保高效更新，而无需使用外部工具。</p>

<ol>
<li>Jetpack Compose 处理列表更新的方式与 RecyclerView 有何不同？</li>
</ol>


<p>Compose 不依赖手动差异计算 (DiffUtils)，而是观察状态变化并仅重组受影响的组件。这是通过使用键和 Compose 的重组逻辑在内部管理的。</p>

<ol>
<li><p>在 Android 开发中，声明式 UI 与命令式 UI 相比有哪些优势？</p></li>
<li><p>代码更简单：声明式 UI 通过关注内容而不是方式来减少样板代码。</p></li>
<li>自动状态管理：Compose 根据状态变化自动更新 UI。</li>
<li>可测试性提高：无状态可组合项可以独立测试。</li>
<li>一致性：重组确保 UI 始终反映当前状态。</li>
<li><p>Compose 中的重组是什么？它与 RecyclerView 中的传统视图失效有何不同？</p></li>
<li><p>重组：当 Compose 检测到状态变化时发生。它仅重新生成受变化影响的 UI 部分。</p></li>
<li>视图失效：在 RecyclerView 中，失效会触发视图重绘，如果没有 DiffUtil 之类的工具，这可能会很低效。</li>
<li><p>何时应在 Compose 中使用 Remember 和 RememberSaveable？</p></li>
<li><p>使用 Remember 在单个组合生命周期内存储状态。</p></li>
<li>使用 RememberSaveable 在配置更改（如屏幕旋转）期间保留状态。</li>
<li>Compose 如何决定要重组 UI 的哪些部分？</li>
</ol>


<p>Compose 会跟踪每个可组合项中的状态读取。当状态发生变化时，只有读取已更改状态的可组合项才会被重组。</p>

<ol>
<li>在 Compose 中实现 LazyColumn 以显示项目列表并添加按钮来更新列表。确保它能够高效更新。</li>
</ol>


<pre><code class="Kotlin">@Composable
fun LazyColumnExample() {
    val items = remember { mutableStateListOf("Apple", "Banana", "Cherry") }

    Column {
        Button(onClick = { items.add("Date") }) {
            Text("Add Item")
        }

        LazyColumn {
            items(items, key = { it }) { item -&gt;
                Text(text = item)
            }
        }
    }
}
</code></pre>

<ol>
<li>识别并修复 Compose 组件中不必要的重组。</li>
</ol>


<pre><code class="Kotlin">LazyColumn {
    items(items = list, key = { item -&gt; item.id }) { item -&gt;
        Text(text = item.name)
    }
}
</code></pre>

<ol>
<li><p>诊断 LazyColumn 中的滞后：</p></li>
<li><p>检查关键参数：确保每个项目都有唯一的键。</p></li>
<li>使用分析工具：使用 Android Studio 的Compose 调试器分析重组计数。</li>
<li>优化项目渲染：避免在 LazyColumn 中使用的可组合函数中进行大量计算。</li>
<li>调试列表更新中的不一致行为：</li>
</ol>


<p>确保数据源稳定并符合 UI 预期。使用SnapshotStateList 可以帮助保持反应性。</p>

<ol>
<li>SnapshotStateList 和 ArrayList 之间的区别：</li>
</ol>


<p>SnapshotStateList 是被动的；更改会自动触发 Compose 中的重组。ArrayList 不是被动的，需要手动通知 UI 更新。</p>

<ol>
<li>使用 SubcomposeLayout</li>
</ol>


<p>SubcomposeLayout 是 Jetpack Compose 中一个强大的布局工具，可让你按需组合布局的各个部分。这对于 UI 的某些部分占用大量资源或可能无法立即使用的情况尤其有用，例如从网络或数据库加载图像。SubcomposeLayout 允许按需组合布局的各个部分。</p>

<p>示例：动态加载图像并显示占位符，直到准备好为止。</p>

<pre><code class="Kotlin">@Composable
fun ImageWithPlaceholder(imageUrl: String, placeholder: Painter) {
    Box(modifier = Modifier.fillMaxSize()) {
        SubcomposeLayout { constraints -&gt;
            // First, compose the placeholder
            val placeholderLayout = subcompose(0) {
                Image(painter = placeholder, contentDescription = null, modifier = Modifier.fillMaxSize())
            }

            // Compose the image once it's loaded
            val imageLayout = subcompose(1) {
                AsyncImage(
                    model = imageUrl,
                    contentDescription = null,
                    modifier = Modifier.fillMaxSize(),
                    contentScale = ContentScale.Crop
                )你
            }

            // Return the max size for the layout
            layout(constraints.maxWidth, constraints.maxHeight) {
                placeholderLayout[0].measure(constraints).placeRelative(0, 0)
                imageLayout[0].measure(constraints).placeRelative(0, 0)
            }
        }
    }
}

@Preview
@Composable
fun ImageWithPlaceholderPreview() {
    ImageWithPlaceholder(
        imageUrl = "https://www.example.com/image.jpg",
        placeholder = painterResource(id = R.drawable.placeholder_image)
    )
}
</code></pre>

<ul>
<li>SubcomposeLayout：此布局允许你根据需要组合布局的各个部分。在这里，我们首先组合占位符，然后在图像准备好后组合图像。</li>
<li>subcompose()：此函数用于组合布局的各个部分。subcompose 函数返回 MeasureResult 对象列表，然后你可以测量这些对象并将其放置在屏幕上。</li>
<li>AsyncImage：我们使用 coil-compose 库中的 AsyncImage 异步加载图像。加载时，会显示占位符。</li>
<li>占位符：首先显示占位符。图像准备好后，它会接管。</li>
</ul>


<p>此方法可帮助你通过减少不必要的重新组合和更优雅地处理图像或数据等动态内容来创建更高效​​的 UI。</p>

<ol>
<li><p>将旧版 RecyclerView 迁移到 Compose：</p></li>
<li><p>用 LazyColumn 替换 RecyclerView。</p></li>
<li>将适配器逻辑移至可组合函数。</li>
<li>使用 Remember 或 SnapshotStateList 进行状态管理。</li>
<li>使用 Keys 进行优化。</li>
</ol>


<h2>结论</h2>

<ul>
<li>Compose 不需要 DiffUtils，因为它建立在声明性和状态驱动的架构上。</li>
<li>带有 key 的 LazyColumn 和 SnapshotStateList 提供类似的优化。</li>
<li>智能重组可确保高效的 UI 更新，从而减少手动优化的需要。</li>
</ul>


<p>通过拥抱 Compose 的声明性特性，你可以专注于构建美观、响应迅速的 UI，而无需担心列表更新的复杂性。</p>

<p>Happy Composing！</p>

<h2>参考文献</h2>

<ol>
<li>Myers, E. (1986)。O(ND) 差分算法及其变体。ACM编程语言和系统事务，1(2)，251–266。</li>
<li><a href="https://developer.android.com/reference/androidx/recyclerview/widget/DiffUtil">Android 开发者文档 — DiffUtils</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compose多平台 (CMP) 开发的四个实用技巧]]></title>
    <link href="https://alexhilton.github.io/blog/2025/02/04/tips-to-migrate-to-kmp/"/>
    <updated>2025-02-04T17:21:07+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/02/04/tips-to-migrate-to-kmp</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自<a href="https://proandroiddev.com/4-useful-tips-for-compose-kotlin-multiplatform-kmp-8809ba1cac51">Four useful tips for Compose Kotlin Multiplatform (KMP)</a></p></blockquote>

<p><strong>译注：</strong> 这篇文章虽然比较短，但提到的问题还是比较具体和典型的，针对CMP项目的一些配置还是很有借鉴意义的。</p>

<p><a href=""><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/j9tap6mygsqvxh6aauc8.png" title="auto auto" ></a></p>

<!-- more -->


<h2>简介</h2>

<p>正如我在上一篇文章<a href="https://medium.com/@lizarraga.iosu/a-complete-migration-of-a-multi-module-app-to-compose-kotlin-multiplatform-kmp-682905266bde">《将多模块应用程序完全迁移到 Compose Kotlin Multiplatform (KMP)》</a>中所说，上个月我一直在将现有的多模块应用程序迁移到 Compose Multiplatform，除此之外，我还从头开始创建一个新的 Compose Multiplatform 多模块项目。在这两个项目中，我都遇到了相同的“问题”或者说“阻碍”，因此，如果您正在迁移或从头开始启动 CMP 项目，那么本文就是为你量身定做的。</p>

<h2>提示 1：预览</h2>

<p>KMP 不支持 commonMain 目录Compose组件的预览，因此我想到了在 androidMain 目录中创建它们，并且它们的预览运行得很好。</p>

<blockquote><p><strong>译注：</strong>此文原文发布于2024年12月初，彼时非Android侧的源码确实无法Preview，后来JetBrains解决了这个问题，通过一个<a href="https://plugins.jetbrains.com/plugin/16541-compose-multiplatform-ide-support">支持桌面Compose的插件</a>。</p></blockquote>

<p>例如：</p>

<pre><code class="bash">commonMain/com/example/feature/component/FeatureScreen.kt
androidMain/com/example/feature/component/FeatureScreenPreview.kt
</code></pre>

<h2>提示 2：BackHandler</h2>

<p>KMP 不支持 BackHandler 操作，因此我创建了一个用于屏幕的expect函数，并在 androidMain 中的actual函数上添加了 BackHandler 操作，并将 iosMain 留空（因为我在 iOS 中没有找到类似的操作）。</p>

<p>例如：</p>

<pre><code class="Kotlin">// commonMain/ com.example.feature.component.FeatureScreen.kt
@Composable
expect fun FeatureScreen(
    viewModel: FeatureScreenViewModel,
)

@Composable
internal fun Content(
    viewModel: FeatureScreenViewModel,
) {
    ...
}
</code></pre>

<pre><code class="Kotlin">// androidMain/ com.example.feature.component.FeatureScreenActual.kt (needs a name different from common)
@Composable
actual fun FeatureScreen(
    viewModel: WorkScreenViewModel,
) {
    BackHandler { viewModel.onIntent(WorkIntent.Back) }

    Content(
        viewModel = viewModel,
    )
}
// extra: I have joined the preview in this same class to have it better organized.
</code></pre>

<pre><code class="Kotlin">// iosMain/ com.example.feature.component.FeatureScreenActual.kt (needs a name different from common)
@Composable
actual fun FeatureScreen(
    viewModel: WorkScreenViewModel,
) {
    Content(
        viewModel = viewModel,
    )
}
</code></pre>

<h2>提示 3：测试模拟</h2>

<p>我喜欢使用 <a href="https://mockk.io/">mockk</a> 库进行模拟测试，在撰写本文时，KMP 尚不支持该库，因此我决定在 androidUnitTest 目录中创建 UnitTest，并将库依赖项添加到 androidUnitTest.dependencies {} 块中。</p>

<p>对于此类测试，我使用了支持 KMP 的 kotlin-test jetbrains 库。</p>

<p>例如：</p>

<pre><code class="Kotlin">mockk = { group = "io.mockk", name = "mockk", version.ref = "mockk-version" }
kotlin-test = { group = "org.jetbrains.kotlin", name = "kotlin-test", version.ref = "kotlin-version" }
</code></pre>

<pre><code class="Kotlin">// feature build.gradle.kts
kotlin {
    ...

    sourceSets {
        androidUnitTest.dependencies {
            implementation(libs.mockk)
        }

        commonTest.dependencies {
            implementation(libs.kotlin.test)
        }
    }
}
</code></pre>

<pre><code class="bash">androidUnitTest/com/example/feature/usecase/UseCaseTest.kt
</code></pre>

<h2>提示 4：UI 测试</h2>

<p><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-test.html">官方的 Compose 多平台 UI 测试指南</a>指出，必须使用commonTest 目录进行 UI 测试，但我更喜欢使用androidInstrumentedTest目录，因为使用这种方法，我可以将单元测试与 UI 测试分开，并且我可以直接从同一个测试类执行它们，并从目录运行所有 UI 测试。</p>

<p>例如：</p>

<pre><code class="Kotlin">mockk-android = { group = "io.mockk", name = "mockk-android", version.ref = "mockk-version" }
ui-test-junit4-android = { group = "androidx.compose.ui", name = "ui-test-junit4-android", version.ref = "uiTestJunit4AndroidVersion" }
ui-test-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest", version.ref = "uiTestManifestVersion" }
kotlin-test = { group = "org.jetbrains.kotlin", name = "kotlin-test", version.ref = "kotlin-version" }
</code></pre>

<pre><code class="Kotlin">// feature build.gradle.kts
plugins {
    ...
    alias(libs.plugins.compose.multiplatform)
    alias(libs.plugins.compose)
}

kotlin {
    ...

    sourceSets {
        androidInstrumentedTest.dependencies {
            implementation(libs.mockk.android)
            implementation(libs.ui.test.junit4.android)
        }

        commonTest.dependencies {
            implementation(libs.kotlin.test)
            @OptIn(ExperimentalComposeLibrary::class)
            implementation(compose.uiTest)
        }
    }
}

...

dependencies {
    debugImplementation(libs.ui.test.manifest)
}
</code></pre>

<pre><code class="bash">androidInstrumentedTest/com/example/feature/component/ScreenAndroidTest.kt
</code></pre>

<h2>结论</h2>

<p>在本文中，我们看到了一些 Compose Multiplatform 技巧，希望您觉得它们有用。感谢您阅读本文，欢迎提供任何反馈。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于Android 16你想知道的都在这里]]></title>
    <link href="https://alexhilton.github.io/blog/2025/01/02/android-16-is-comming/"/>
    <updated>2025-01-02T22:14:32+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/01/02/android-16-is-comming</id>
    <content type="html"><![CDATA[<p>2025年的Android新版本来的比2024年稍早了一些。今年Google非常反常地提前就发布了Android的<a href="https://developer.android.com/about/versions/16">新版本Android 16 Baklava</a>，整体的计划比往年提前了2～3个月。另外，谷歌把<a href="https://www.androidfaithful.com/android-16-code-name/">Android 16的代码命名为「Baklava」</a>,这与先前的字母表顺序的点心食物命名方式截然不同，不过「Baklava」巴克拉瓦，又称果仁蜜饼，是一种口味浓郁、甜蜜的土耳其酥皮点心。</p>

<p><a href=""><img src="https://www.android-user.de/wp-content/uploads/2024/11/20241101-Android-16-Baklava-Beitragsbild.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>谷歌的发布计划</h2>

<p>从<a href="https://developer.android.com/about/versions/16">官方的消息</a>来看会在24年结束Preview，在25年1月其实是Q1就开始Beta release，并在Q2进入Platform Stability，预计上半年就可能会正式发布，整体的节奏较往年提前了约2～3个月（往年是Q1会有Preview，Q2发布Beta,6~7月左右开始Platform Stability，Q3 9月～10月正式发布）。</p>

<p><img src="file:///Users/alexhilton/Downloads/android-16-release.webp" alt="图1. Android 16的发布计划" /></p>

<p>不过现仍在非常为初始的Preview阶段，后面可能会有变数，官方也没有给具体的计划。但有一点是确定的，那就是今年Android 16的发布肯定较往年会提拉一些，至少提拉2个月。</p>

<p>对于应用开发者来说，更为关心的是API的发布情况，一般情况下API会较系统版本提前一个季度就会正式稳定下来（也即不会再有大的变动），换句话说，今年在Q2就能得到较为稳定的API版本，当然比往年还是有提拉的。</p>

<p><img src="file:///Users/alexhilton/Downloads/android16-api-release.webp" alt="图2. Android 16 API的发布计划" /></p>

<p>发布计划不受我们控制，了解一下就可以了，下面我们看一下如何用条件区分这些新的API。</p>

<h2>区分使用新的API的方式</h2>

<p>如果应用不是运行在最新的版本，那么新的API不应该被执行，因此我们需要用条件来区分不同的API版本，用<a href="https://developer.android.com/reference/android/os/Build.VERSION#SDK_INT">SDK_INT</a>和<a href="https://developer.android.com/reference/android/os/Build.VERSION_CODES">VERSION_CODES</a>就可以做到。当然，需要先在Android Studio中把SDK中的Android 16 Preview版本下载下来才能编译。</p>

<p><img src="file:///Users/alexhilton/Downloads/install-baklava-sdk.png" alt="图3. 升级SDK" /></p>

<pre><code class="Kotlin">if (SDK_INT &gt;= VERSION_CODES.BAKLAVA) {
  // 使用Android 16中才有的API
}
</code></pre>

<p>为了能更细致地区分版本，Android 16新增加了一个新的版本常量<a href="https://developer.android.com/reference/android/os/Build.VERSION#SDK_INT_FULL">SDK_INT_FULL</a>，并在<a href="https://developer.android.com/reference/android/os/Build.VERSION_CODES_FULL">VERSION_CODES_FULL</a>中定义了具体的常量值。它可以粒度更细地检查API的版本，分为Major版本和Minor版本。以往的SDK_INT只能区分大的版本（Major版本），这是它们最大的不同。</p>

<pre><code class="Kotlin">if (SDK_INT_FULL &gt;= VERSION_CODES_FULL.[MAJOR or MINOR RELEASE]) {
  // 用Major版本或者Minor版本才有的API
}
</code></pre>

<p>每个Major版本可能会多个Minor版本，如果不想麻烦，可以用<a href="https://developer.android.com/reference/android/os/Build#getMinorSdkVersion%28int%29">Build.getMinorSdkVersion()</a>来从VERSION_CODES_FULL中取出Minor版本号。</p>

<p><strong>注意：</strong> SDK_INT_FULL，VERSION_CODES_FULL以及getMinorSdkVersion都是Android 16中新增的API，确保把SDK升级到最新才可以编译成功。</p>

<p>接下来我们重点来看一下新一代的Android带来了哪些变化。</p>

<h2>新的功能和新的API</h2>

<p>很不幸，Android 16并没有带来全新的功能。只有一些小的新API。</p>

<h3>用户体验和系统UI</h3>

<p>提供一些的新的API以更好更灵活的控制系统的行为。</p>

<h4>可预见的返回更新</h4>

<p>Android 16增加了新的API以使能手势导航中的可预见返回系统动画，比如从应用返回到桌面的动画。使用新的<a href="https://developer.android.com/reference/android/window/OnBackInvokedDispatcher#PRIORITY_SYSTEM_NAVIGATION_OBSERVER">PRIORITY_SYSTEM_NAVIGATION_OBSERVER</a>向系统注册一个回调<a href="https://developer.android.com/reference/android/window/OnBackInvokedDispatcher#registerOnBackInvokedCallback(int,%20android.window.OnBackInvokedCallback">onBackInvokedCallback</a>)，每当系统处理一个返回导航时就能够收到<a href="https://developer.android.com/reference/android/window/OnBackInvokedCallback#onBackInvoked(">onBackInvoked</a>)回调，而不影响常规的返回导航流程。</p>

<p>Android 16还增加了两个API <a href="https://developer.android.com/reference/android/window/SystemOnBackInvokedCallbacks#finishAndRemoveTaskCallback(android.app.Activity">finishAndRemoveTaskCallback</a>)和<a href="https://developer.android.com/reference/android/window/SystemOnBackInvokedCallbacks#moveTaskToBackCallback(android.app.Activity">moveTaskToBackCallback</a>)。通过向<a href="https://developer.android.com/reference/android/window/OnBackInvokedDispatcher">OnBackInvokedDispatcher</a>注册这些回调，当执行返回手势时系统就能触发具体的行为和播放相关的动画。</p>

<h4>更加丰富的震感反馈</h4>

<p>Android 16增加了<a href="https://developer.android.com/reference/android/os/vibrator/package-summary">震感API</a>，能让应用定义震感效果的振幅和频率的曲线，同时屏蔽设备的差异。</p>

<h3>性能和电池</h3>

<p>Android 16提供了新的API以帮助收集应用的洞察。</p>

<h4>系统触发的分析</h4>

<p><a href="https://developer.android.com/about/versions/15/features#app-start-info">Android 15</a>添加的<a href="https://developer.android.com/reference/android/os/ProfilingManager">ProfilingManager</a>能让应用请求分析数据集。然而，这个分析必须由应用来发起，一些像启动过程以及ANR就很抓取得到（因为应用必须要先正常启动起来后，才能调用ProfilingManager去获取分析数据）。</p>

<p>为了解决这个问题，Android 16在ProfilingManager中增加了系统触发的分析数据。应用可以注册感兴趣的特定场景的trace，诸如冷起动或者ANR，系统会替应用开启和停止trace。trace收集完毕后，结果会传到应用的data目录。</p>

<h3>ApplicationStartInfo中增加Start component</h3>

<p>ApplicationStateInfo是在Android 15增加的，让应用能够看到进程启动原因，启动类型，启动时间等一系列诊断数据。Android 16增加了方法<a href="">getStartComponent</a>以辨识哪种组件类型触发的启动，这对于优化应用启动过程将会非常有帮助。</p>

<h3>更好的（后台）任务反查</h3>

<p>API <a href="https://developer.android.com/reference/android/app/job/JobScheduler#getPendingJobReason(int">JobScheduler#getPendingJobReason()</a>)能返回任何处于待处理的原因。当然，一个任务可能由于很多种原因待处理。</p>

<p>在Android 16中，增加了一个新的API <a href="https://developer.android.com/reference/android/app/job/JobScheduler#getPendingJobReasons(int">JobScheduler#getPendingJobReasons(int jobId)</a>)，用以返回任务处于待处理的多个原因，比如缘于开发者设置了显性的限制或者系统设置的隐性限制。</p>

<p>还增加了一个API <a href="https://developer.android.com/reference/android/app/job/JobScheduler#getPendingJobReasonsHistory(int">JobScheduler#getPendingJobReasonsHistory(int jobId)</a>)，用以返回最近的限制变更列表。</p>

<p>推荐使用这些API来调试为何后台任务没被执行，尤其是当看到特定任务的成功率降低时，或者特定任务完成有延迟时。例如，在后台更新桌面小部件时失败或者预先拉取任务在应用启动前失败等等。</p>

<p>这也能够更好的帮助你明白因为系统定义的限制还是因为显性的限制而导致特定的任务未执行完成。</p>

<h3>自适应刷新频率</h3>

<p>Android 15引入的自适应刷新频率(Adaptive refresh rate ARR)通过离散化的VSync步长能够让屏幕刷新频率适配内容频率。这会降低功耗同时消除潜在的掉帧。</p>

<p>Android 16增加了方法<a href="https://developer.android.com/reference/android/view/Display#hasArrSupport(">hasArrSupport</a>)和方法<a href="https://developer.android.com/reference/android/view/Display#getSuggestedFrameRate(int">getSuggestedFrameRate(int)</a>)以及<a href="https://developer.android.com/reference/android/view/Display#getSupportedRefreshRates(">getSupportedRefreshRates()</a>)，让应用容易利用ARR。Jetpack中的很多组件在内部实现上已经利用ARR以增强平滑的滑动，详细的可<a href="https://developer.android.com/media/optimize/performance/frame-rate">参见了此文章</a>。</p>

<h3>连接</h3>

<p>WiFi可以用来室内定位，Android 16增加了对WiFi位置安全性的支持，通过<a href="https://developer.android.com/reference/android/net/wifi/rtt/SecureRangingConfig">这个特性</a>。</p>

<h3>媒体</h3>

<h4>照片选择增强</h4>

<p><a href="https://developer.android.com/training/data-storage/shared/photopicker">照片选择器(photo picker)</a>提供了一个安全且内置的方式让应用在用户授权的情况下从存储中选择媒体文件。</p>

<p>Android 16带来的增强点有：</p>

<ul>
<li>嵌入式的图片选择器：<a href="https://developer.android.com/reference/android/widget/photopicker/package-summary">新的API</a>能够让应用把图片选择器嵌入到自己的视图中。这会让图片选择看起来更像是应用整体的一部分。后续的Jetpack中会提供可嵌入的图片选择器。</li>
<li>图片选择器支持云搜索：<a href="https://developer.android.com/sdk/api_diff/b-dp2-incr/changes/pkg_android.provider">新的API</a>在图片选择器将支持云搜索。</li>
</ul>


<h3>隐私</h3>

<h4>健康连接更新</h4>

<p>开发者Preview版本中的健康连接增加了ACTIVITY_INTENSITY（活动强度），依据世界健康组织（WHO）给出的指南中定义的一个新的数据类型。每一条记录将必须包括开始时间，结束时间以及活动强度。</p>

<h4>隐私沙盒</h4>

<p>Android 16集成了<a href="https://developers.google.com/privacy-sandbox/overview/android">Android隐私沙盒</a>的最新版本，这是一项为保护用户隐私而持续进行的工作。可以查看<a href="https://developer.android.com/design-for-safety/privacy-sandbox/program-overview">网站内容</a>以了解更多。</p>

<h2>行为变更</h2>

<p>比起新的API，Android 16带来的行为变更更值得我们关注，因为这会直接影响所有应用，无论targetSdkVersion是否是Baklava。</p>

<h3>核心功能</h3>

<h4>JobScheduler配额优化</h4>

<p>从Android 16开始，以基于以下因素来调整常规任务和加急任务的运行时配额：</p>

<ul>
<li>应用处于<a href="https://developer.android.com/topic/performance/appstandby">哪个等待区</a>：在Android 16中，活跃的等待区会减少限制。</li>
<li>如果任务开始执行时应用处于头部状态：在Android 16中，任务启动时，如果应用是用户可见的且应用变成可见后仍在继续执行，会加入到运行时配额中。</li>
<li>如果任务执行时正在运行一个前台服务：在Android 16中，当正在执行一个前台服务时，正在执行的任务将加入到运行时配额中。如果任务是用于用户数据传送，建议<a href="https://developer.android.com/develop/background-work/background-tasks/uidt">考虑替换方案</a>。</li>
</ul>


<p>这些变动将会影响由WorkManager，JobScheduler和DownloadManager调度的任务。如果要调试为何一个任务被终止了，建议通过调用<a href="https://developer.android.com/reference/androidx/work/WorkInfo#getStopReason(">WorkInfo.getStopReason()</a>)来打印日志。</p>

<p>也可以通过Android 16新增加的API <a href="https://developer.android.com/partners/android-16/features#feature-pending-job-reason-history">JobScheduler#getPendingJobReasonsHistory</a>来了解为何任务未执行。</p>

<p>另外，在Android 16上还可以通过adb命令强制调整运行时任务配额，以方便测试：</p>

<pre><code class="Bash"># 取消头部状态配额限制
adb shell am compat enable OVERRIDE_QUOTA_ENFORCEMENT_TO_TOP_STARTED_JOBS &lt;APP_PACKAGE_NAME&gt;

# 设置等待区
adb shell am set-standby-bucket &lt;APP_PACKAGE_NAME&gt; active|working_set|frequent|rare|restricted

# 获取所处的等待区状态
adb shell am get-standby-bucket &lt;APP_PACKAGE_NAME&gt;
</code></pre>

<h3>用户体验和系统UI</h3>

<p>Android 16废弃了无障碍公告(announcement)，一种使用<a href="https://developer.android.com/reference/android/view/View#announceForAccessibility(java.lang.CharSequence">announceForAccessibility</a>)或者派发<a href="https://developer.android.com/reference/android/view/accessibility/AccessibilityEvent#TYPE_ANNOUNCEMENT">TYPE_ANNOUNCEMENT</a>引起的无障碍事件。这些公告会造成Talkback和屏幕发声的混乱，容易被滥用，一些可行的替换方案有：</p>

<ul>
<li>对于像窗口变化之类的极重要的UI变化，可以用<a href="https://developer.android.com/reference/android/app/Activity#setTitle(java.lang.CharSequence">Activity.setTitle(CharSequence)</a>)和<a href="https://developer.android.com/reference/android/view/View#setAccessibilityPaneTitle(java.lang.CharSequence">setAccessibilityPaneTitle(java.lang.CharSequence)</a>)。在Compose中使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/semantics/package-summary#(androidx.compose.ui.semantics.SemanticsPropertyReceiver">Modifier.semantics { paneTitle = &ldquo;paneTitle&rdquo; }</a>.liveRegion)。</li>
<li>告知用户重要UI变化，使用<a href="https://developer.android.com/reference/android/view/View#setAccessibilityLiveRegion(int">setAccessibilityLiveRegion(int)</a>)。在Compose中，用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/semantics/package-summary#(androidx.compose.ui.semantics.SemanticsPropertyReceiver">Modifier.semantics { liveRegion = LiveRegionMode.[Polite|Assertive]}</a>.liveRegion)。这些也要小心使用，因为每当View刷新就会触发一个无障碍事件。</li>
<li>通知用户有错误，发送一个类型为<a href="https://developer.android.com/reference/android/view/accessibility/AccessibilityEvent#CONTENT_CHANGE_TYPE_ERROR">AccessibilityEvent#CONTENT_CHANGE_TYPE_ERROR</a>的无障碍事件，并且设置<a href="https://developer.android.com/reference/android/view/accessibility/AccessibilityNodeInfo#setError(java.lang.CharSequence">AccessibilityNodeInfo#setError(CharSequence)</a>)，或者<a href="https://developer.android.com/reference/android/widget/TextView#setError(java.lang.CharSequence">TextView#setError(CharSequence)</a>)。</li>
</ul>


<p>可以<a href="https://developer.android.com/reference/android/view/View#announceForAccessibility(java.lang.CharSequence">看文档</a>)以了解废弃announceForAccessibility的细节以及推荐的替代方案。</p>

<h2>适配建议</h2>

<p>到目前为止，我们能了解到的Android 16的变化就这么多，总的来看增量变化并不多，新的API 都是一些小的细节上的增强；行为的变更也很少很少，只涉及后台任务和无障碍。新的API不会影响现有的应用，行为变更也不多，可以说对于绝大多数应用来说影响甚微。</p>

<p>现在仍是开发者Preview阶段，只有亲儿子Pixel系列会收到OTA版本，我们了解一下就可以了。即使是应用可能会受到行为变更的影响，也不用着急，建议再等2～3个月，等到有更多的厂商发出Beta版本了，并且API也稳定了时再做适配也不迟。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/about/versions/16/features">Features and APIs</a></li>
<li><a href="https://android-developers.googleblog.com/2024/11/the-first-developer-preview-android16.html">The First Developer Preview of Android 16</a></li>
<li><a href="https://android-developers.googleblog.com/2024/12/second-developer-preview-android16.html">The Second Developer Preview of Android 16</a></li>
<li><a href="https://developer.android.com/about/versions/16/behavior-changes-16">Behavior changes: Apps targeting Android 16 or higher</a></li>
<li><a href="https://developer.android.com/about/versions/16/behavior-changes-all">Behavior changes: all apps</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[群星闪耀的大前端开发]]></title>
    <link href="https://alexhilton.github.io/blog/2024/12/10/a-brief-history-of-cross-platform-development/"/>
    <updated>2024-12-10T22:01:05+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/12/10/a-brief-history-of-cross-platform-development</id>
    <content type="html"><![CDATA[<p>乔帮主发布iPhone以降，把世界推向了智能手机时代，随之而来的是移动互联网大潮，一时间移动应用开发变得炙手可热起来，渐渐的超越了传统桌面端和传统前端，成为了主流。随之而来的就是重复开发的问题，同样的业务需要在Android上面实现一次，在iOS上面实现一次，通常也需要在Mobile Web（移动端H5）实现一次，自此跨端开发成了移动互联时代一个必须要攻克的难题。</p>

<p><a href=""><img src="https://www.ropstam.com/wp-content/uploads/2023/09/Best-Cross-Platform-App-Development-Frameworks.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>大前端开发简史</h2>

<p>工程师的使命是<strong>把不可能变可能，把可能变简单，把简单变优雅</strong>。如果能用同一套代码在不同的端侧都运行，那将是再美好不过的了，毕竟对于端侧业务逻辑一样的，但却要用不同的编程语言，不同的框架，不同的平台，不同的团队各开发一次。如果能够做到「开发一次，多端运行」，将极大的节省人力物力和财力，开发效率也将大大提升。遂业界一直在探索如何跨移动端开发，也即只用一套代码，开发一次，就可以在Android端，iOS端和移动Web端三端运行。</p>

<h3>史前时代：Hybrid app</h3>

<p>最先出来的框架是Hybrid app（<a href="https://phonegap.com/">PhoneGap</a>和<a href="https://cordova.apache.org/docs/en/latest/">Cordova</a>），利用Android端和iOS端都对WebView有较好的支持，因此用移动前端（也即网页）的方式来开发应用，绝大多数的业务逻辑都在网页里，Android端和iOS端都是用WebView去展示网页，对于JavaScript在网页中无法实现的，与平台强相关的事情可以通过JavaScript Bridge来调用平台实现的API，称之为JsBridge。</p>

<p>这种架构非常简单，对于Android和iOS来说，使用一个WebView，再实现一些native API就可以了，其余的都是标准的移动前端。得益于平台对HTML 5的支持，以及像jQuery Mobile等优秀的前端库的加持，无论是开发体验还是使用体验，Hybrid app并不差。最重的是它跨平台性特别好，性价比超高，对于UI部分很重，交互 也不复杂的以展示为主的页面来说，这是性价比超高的实现方式。</p>

<p>这个可以称之为史前时代。</p>

<h3>黑暗时代：不成熟的各种尝试</h3>

<p>Hybrid app方式虽然可行，但在不同的终端上面体验差距很明显。对于性能较好的中高端设备，因为设备整体性能较好，Hybrid app体验尚可，虽然与原生UI相比仍有差距，但属于可接受范围。但对于中低端设备来说，WebView不但性能差，而且兼容性不好，体验严重差于原生UI。另外，如果UI交互变得复杂，或者对体验和实时性操作要求比较高（如文档编辑类等）Hybrid方式与原生更是相距甚远。工程师们开始尝试新的方案。</p>

<p>比如坊间有用json格式来定义UI，定义好格式后，每个端拿到一坨json数据解析，然后生成UI。这其实都算不上是框架，其实就是用json来描述一个页面，解析与构建UI仍是由每个端自己搞，顶多算是一种UI描述格式。但难以通用，并且只能描述UI的静态结构，无法有动态的行为之类的。这种方案也曾有不少大厂用过，它非常适用于局部的，并不复杂的UI，业务逻辑固定，但UI排版样式可能随时会变页面。但要说用它来写整个应用，是不现实的。</p>

<p>这期间Google也做了尝试，搞出一个叫做<a href="https://developers.google.com/j2objc">j2objc的工具</a>，它能把Java代码翻译 成为Objective&#45;C代码，转换后的Objective-C代码无需修改可以直接编译运行。显然，这个工具并不适用于UI，因为UI都是与平台强相关的，需要大量的依赖于平台的SDK，并不是把代码「翻译」过来就完事了。这个工具适用于非UI部分的业务逻辑代码，效果也非常的好，经其转换后的代码可以直接编译运行。据说Google自己也在用，当时的GMS产品Google Inbox等都用j2objc达到了70%代码共用。</p>

<p>这是大前端的一个黑暗时代，虽然大家都在尝试，但始终没有一个比较理想的完整的解决方案。</p>

<h3>黎明的署光：划时代的ReactNative</h3>

<p>Hybrid方式最大的问题在于WebView是性能和体验的瓶颈，WebView之所以是瓶颈 在于它是一个完全的浏览器，它要完全支持JavaScript，HTML和CSS。但随着HTML5和Web前端技术的发展，有很多库可能只用JavaScript来实现。JavaScript独立出来与Node.js结合（严谨的说是JS引挚），同样可以做前端，但却少了HTML和CSS的拖累，沿着这个思路非死不可（彼时叫做Facebook，现在叫做Meta）推出了一个跨移动端平台的开发框架ReactNative。它是基于Facebook的React框架，做了面向移动端的延伸。它的主要实现方法是用React来写页面，这是一个基于JavaScript语言的声明式UI框架，加入了一个虚拟DOM层，用以屏蔽频繁的DOM改动，然后再把虚拟DOM转成一个渲染树，最后由Node开出口子，把渲染树用Native的API去实现，由此实现了原生UI。</p>

<p>ReactNative可以实现跨三端，页面用React写好后，不用修改就可以在Web，Android和iOS上运行。一经发布引发了巨大反响，坊间众人皆拍大腿「卧草，还可以这样玩儿啊！」。</p>

<p>ReactNative是划时代的，因为它确定了跨端框架的基本结构：声明式UI，虚拟DOM和渲染树，用原生API去实现渲染树（映射为Native的组件，或者用Native graphics API去实现渲染树）。后续的跨端框架基本上都是这个路子。</p>

<h3>群星闪耀的当下</h3>

<p>时光荏苒，移动互联大潮已经过了十几年，技术也层出不穷，新的框架在不断的涌现。现如今跨端这一领域百花齐放，群星闪耀，各大框架经过几年的沉淀与发展已经比较成熟。除了<a href="https://reactnative.dev/">ReactNative</a>以外，还有了NativeScript，Flutter以及CMP。这其中<a href="https://nativescript.org/">NativeScript</a>其实与ReactNative差不多，唯一的区别在于它允许用JavaScript家族语言（如<a href="https://www.typescriptlang.org/">TypeScript</a>和<a href="https://coffeescript.org/">CoffeeScript</a>），以及不限制开发框架，可以用Vue.js或者Angular.js来写UI。</p>

<p>当然，最为广泛流行，业界使用最多的当属于Flutter和ReactNative，CMP作为一颗新星也越来越受关注。</p>

<h2>流行框架对比</h2>

<p>这里简要对比一下最为流行的ReactNative和Flutter以及新星CMP，以方便使用者做出更好的选择。</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 框架 </th>
<th style="text-align:center;"> 开发者 </th>
<th style="text-align:center;"> 开发语言 </th>
<th style="text-align:center;"> UI开发库 </th>
<th style="text-align:center;"> 支持的端 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> ReactNative </td>
<td style="text-align:center;"> Meta </td>
<td style="text-align:center;"> JavaScript </td>
<td style="text-align:center;"> React </td>
<td style="text-align:center;"> Android, iOS, Web </td>
</tr>
<tr>
<td style="text-align:center;"> Flutter </td>
<td style="text-align:center;"> Google </td>
<td style="text-align:center;"> Dart </td>
<td style="text-align:center;"> </td>
<td style="text-align:center;"> Android, iOS, Desktop, Web </td>
</tr>
<tr>
<td style="text-align:center;"> CMP </td>
<td style="text-align:center;"> JetBrains </td>
<td style="text-align:center;"> Kotlin </td>
<td style="text-align:center;"> Jetpack Compose </td>
<td style="text-align:center;"> Android, iOS, Desktop, Web </td>
</tr>
</tbody>
</table>


<p>ReactNative和Flutter都相对较成熟和稳定了，使用者也较多，社区很活跃。ReactNative更适合移动端，而Flutter能跨的端和CMP要更多一些。此外，Flutter和CMP与其他框架最大的区别在于它使用Skia库构建了一个渲染引挚，可以直接把渲染树渲染成为平台支持的更为底层的canvas，直接接入native层的graphics API而不是映射成native组件，为此，它的渲染效率更为高效一些，进而性能更优一些，可以把它们想像成为一个浏览器。</p>

<p>技术栈也不一样，ReactNative是基于Node和JavaScript，属于前端技术栈，与前端融合更为紧密一些；而CMP是基于Kotlin和JVM与Android更为紧密一些，属于Java派系；而Flutter自成一派。</p>

<h2>选择是痛苦的</h2>

<p>实事求是的来说<a href="https://flutter.dev/">Flutter</a>是当前最为成熟 也最为完备的一个跨端框架，只不过可能学习成本略大，对于大部分同学来说Dart是一门小众的编程语言。而ReactNative最大的问题就在于React，它太前端化了，对于客户端同学来说写一坨HTML式的标签还是相当难受的。</p>

<p>应该说Flutter已经非常成功了，达到了它应该有高度，实现了它的价值，换句话说它的前景也不是特别明朗了，因为它已经很成熟了，所以有传言谷歌内部也在裁撤Flutter的研发资源。ReactNative也一样，这么多年了，版本还没有到1.0。</p>

<p><img src="https://blog.droidchef.dev/content/images/size/w1000/2022/11/Flutter-vs-Jetpack-Compose-Header--2-.png" alt="图1. Flutter vs CMP" /></p>

<p>而CMP刚刚兴起，使用起来非常的方便和简单，它的安装与配置是所有框架之中最为简便的（只需要安装一个Android Studio的插件，其余的都是编译插件和依赖，并不像Flutter和ReactNative都需要在开发机器上安装其他东西），前途无量，非常值得投入。并且Flutter对于谷歌来说九牛一毛，是非常不起眼的东西，谷歌毕竟家大业大，像谷歌和Meta等巨头现在都在狂卷AI，其他的小业务都不受重视。</p>

<p>但CMP不一样，JetBrains本身就是专门搞开发工具的，这是他们的主业肯定 会好好搞，把CMP与其IDE深度结合，对于开发者使用起来那就相当的方便了。事实上JetBrains已经开始弄了，它的最新的<a href="https://www.jetbrains.com/fleet/">IDE Fleet</a>（一个通用的IDE）将会深度绑定CMP，非常值得期待。</p>

<p>综合考虑，给出的建议就是如果是<strong>一个纯新的项目，特别是MVP阶段，不要犹豫就是用Flutter</strong>。而如果是<strong>现有项目，想要跨端，就选择CMP</strong>，它是对现有项目最为友好的一个。除非你是资源前端且是React粉，否则不要考虑ReactNative。</p>

<h2>框架只能解决一部分问题</h2>

<p>最后想说的是，对于跨端开发，框架只能解决一小部分问题。</p>

<p>跨端开发最难的地方在于合理的架构和团队的协同。架构需要做好层与层的隔离，特别是把与平台强相关的API做好隔离层，以最大限度 的共用代码，如果到处都是粗粒度的平台相关的实现，复杂度将急剧上升，那最后会变成多端的拼盘而非一个跨端项目。人员的协作应该以功能为单位来划分而不能再以端的维度，要彻底消灭端的思维，要以UI，功能和业务逻辑角度来思考问题，这样才能更好的协作。总之跨端对团队的要求更高，否则只会制造更多的问题。</p>

<p>人的问题永远要比技术问题要复杂一些，举个最简单的例子，以往每个端各自为政，Android端某个同学犯了错，顶多就是Android端不能用了，可能最多就3.25。真跨端了以后，再犯错那可就是所有端都搞挂了，可能最少是3.25起步，这里头的差别还是相当大的，如果没有强有力的大一点的老板来推，是很难推得动的。</p>

<p>研发同学都喜欢折腾，光完成业务是很无聊的，也不可能出成绩，都想方设法的搞出点「技术产出」（俗称造轮子）。记得ReactNative刚出来时，坊间很热情都在把其引入到各自的业务中去，但最终的结果是，没有人会真的在业务中重点使用，而是都花心思搞出了一套属于自己的跨端框架，并且向其他团队推广。年终汇报时，PPT很漂亮：「老板您看，我们不光完成了业务，还搞了一套跨端框架，它比ReactNative好在哪里，已经在我们的业务使用了，也给其他团队推广了」。相反，假如你真的使用了跨端，你咋 汇报？「老板，您看，我们用了别人的跨端技术，成功的实现了跨端，原来三个端15个人能做完的事情，现在只需要8个人！」。老板听了，很激动，3.25终于找到人选了，开猿节流也有着落了！</p>

<p>Anyway，总的来说跨端开发更适合业务不复杂，UI交互也不重的中小型App，或者那种UI占比较小非UI逻辑占比大的应用（最典型的就是浏览器），才能发挥出最大的价值。一个比较简单的判断标准就是，如果每个端的研发人员都超过10个人，可能就不太适合用跨平台的开发方式。</p>

<h2>References</h2>

<ul>
<li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/cross-platform-frameworks.html">The Six Most Popular Cross-Platform App Development Frameworks</a></li>
<li><a href="https://developers.google.com/j2objc">What J2ObjC is</a></li>
<li><a href="https://github.com/google/j2objc">A Java to iOS Objective-C translation tool and runtime.</a></li>
<li><a href="https://hackernoon.com/getting-started-with-react-native-for-windows-and-macos">Getting started with React Native for Windows &amp; macOS</a></li>
<li><a href="https://medium.com/@ankit-detroja/react-native-or-flutter-in-2024-7cfb0605698f">React native or Flutter in 2024</a></li>
<li><a href="https://leancode.co/blog/flutter-vs-react-native">Flutter vs. React Native: A Detailed Comparison for 2024</a></li>
<li><a href="https://nateshmbhat.medium.com/flutter-vs-react-native-performance-benchmarks-you-cant-miss-%EF%B8%8F-2e31905df9b4">Flutter Vs React Native : Performance Benchmarks you can’t miss ! 🔥⚡️ [Part -1]</a></li>
<li><a href="https://medium.com/newsoft-official/compose-multiplatform-vs-flutter-771673612c61">Compose Multiplatform VS. Flutter</a></li>
<li><a href="https://infinitelambda.com/flutter-kotlin-multiplatform-native-comparison/">FLUTTER VS KOTLIN MULTIPLATFORM VS NATIVE</a></li>
<li><a href="https://www.miquido.com/blog/kotlin-multiplatform-vs-flutter/">Flutter vs. Kotlin Multiplatform Mobile</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实战：把一个现有的Compose项目转化为CMP项目]]></title>
    <link href="https://alexhilton.github.io/blog/2024/12/09/migrate-existing-project-to-cmp/"/>
    <updated>2024-12-09T22:09:28+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/12/09/migrate-existing-project-to-cmp</id>
    <content type="html"><![CDATA[<p>通过<a href="https://juejin.cn/column/7367555191338467337">前面两篇文章</a>的学习，我们已经对CMP有了一定的了解，接下来要进入实战阶段。在现实的世界中极小数项目会从0开始，今天重点研究一下如何把一个现成的用Jetpack Compose开发的Android项目转成CMP项目。</p>

<p><a href=""><img src="https://www.mouritech.com/wp-content/uploads/2024/01/Compose-Multiplatform.png" title="auto auto" ></a></p>

<!-- more -->


<h2>总体思路</h2>

<p>在前面的文章<a href="https://juejin.cn/post/7439251025385996307">Compose大前端从上车到起飞</a>里面我们学习到了，CMP对Android开发同学是相当友好的，CMP项目与Android项目在项目结构上面是非常相似的。并且因为CMP的开发IDE就是Android Studio，因此，可以直接把一个Android项目改造成为CMP项目，而不是创建一个全新的CMP项目之后把项目代码移动进去。</p>

<p>具体的步骤如下：</p>

<ol>
<li>添加CMP的插件，添加源码集合，配置CMP的依赖</li>
<li>把代码从「androidMain」移动到「commonMain」中去</li>
<li>把资源转换成为CMP方式</li>
<li>添加并适配其他平台</li>
</ol>


<p><strong>小贴士：</strong> 针对 不同的类型的任务需要采取 不同的策略，比如开发功能的时候使用「自上而下」的方式要更为好一些，因为先关注大粒度的组件，类与方法，不被细节拖住，更有利于我们看清架构和优先解决掉重点问题；但当做移植任务时，应该采用「自下而上」，因为依赖是一层套一层，先把下面的移好，上面的自然就会更加容易。</p>

<p>这里选用的项目是先前用纯Jetpack Compose开发的<a href="https://github.com/alexhilton/Aeolus">一款天气应用</a>，项目比较简单，依赖不多，完全是用Jetpack Compose实现的UI，也符合<a href="https://juejin.cn/post/7411812014047461387">现代应用开发架构原则</a>，非常适合当作案例。</p>

<p><strong>注意：</strong> 其实这里的项目并没有严格要求，只要是一个能运行的Android项目即可，其他的（是不是Jetpack Compose实现的，用的是不是Kotlin）并不是最关键的。因为CMP项目对于每个源码集合本身并没有明确的要求，前面的文章也讲了，每个平台的源码集合，其实就是其平台的完整的项目。移植的目的就是把 <strong>可共用共享</strong> 的代码从现有项目中抽出来放进「commonMain」中，即可以是原有的业务逻辑，也可以是新开发的代码。采用新技术或者新工具的一个非常重要的原则 就是要循序渐进，不搞一刀切。如果时间不充裕，完全可以新功能和新代码先用CMP方式开发，老代码暂且不动它，待日后慢慢再移植。当然了，纯Jetpack Compose实现的项目移植过程会相对容易一些。</p>

<p>下面我们进行详细的一步一步的实践。</p>

<h2>配置CMP的插件，源码集合和依赖</h2>

<p>首先要做的是配置Gradle构建插件（这是把Gradle常用的Tasks等打包成为一个构建 插件，是编译过程中使用的）：</p>

<ul>
<li>使用Kotlin Multiplatform（「org.jetbrains.kotlin.multiplatform」）替换Kotlin Android（「org.jetbrains.kotlin.android」），这个主要是Kotlin语言的东西，版本号就是Kotlin的版本号，注意要与其他（如KSP，如Coroutines）版本进行匹配；</li>
<li>添加Compose compiler（「org.jetbrains.kotlin.plugin.compose」）的插件，版本号要与Kotlin版本号保持一致；</li>
<li>以及添加Compose Multiplatform（org.jetbrains.compose」）插件，版本号是CMP的版本号。</li>
</ul>


<p>注意，构建插件配置是修改项目根目录的那个build.gradle.kts：</p>

<pre><code class="Kotlin">// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    id("com.android.application") version "8.1.4" apply false
    id("com.android.library") version "8.1.4" apply false
    id("org.jetbrains.kotlin.multiplatform") version "2.0.21" apply false
    id("com.google.devtools.ksp") version "2.0.21-1.0.28" apply false
    id("org.jetbrains.kotlin.plugin.compose") version "2.0.21" apply false
    id("org.jetbrains.compose") version "1.7.0" apply false
}
</code></pre>

<p>之后是修改module的build.gradle.kts，先是启用需要的插件，然后是添加kotlin相关的配置（即DSL kotlin {&hellip;}），在其中指定需要编译的目标，源码集合以及其依赖，具体的可以仿照着CMP的demo去照抄就好了。对于依赖，可以把其都从顶层DSL dependencies中移动到androidMain.dependencies里面，如果有无法移动的就先放在原来的位置，暂不动它，最终build.gradle.kts会是酱紫：</p>

<pre><code class="Kotlin">plugins {
    id("com.android.application")
    id("com.google.devtools.ksp")
    id("org.jetbrains.kotlin.multiplatform")
    id("org.jetbrains.kotlin.plugin.compose")
    id("org.jetbrains.compose")
}

kotlin {
    androidTarget {
        @OptIn(org.jetbrains.kotlin.gradle.ExperimentalKotlinGradlePluginApi::class)
        compilerOptions {
            jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_17)
        }
    }

    sourceSets {
        androidMain.dependencies {
            // Jetpack
            implementation("androidx.core:core-ktx:1.15.0")
            implementation("androidx.appcompat:appcompat:1.7.0")
            implementation("androidx.activity:activity-compose:1.9.3")
            val lifecycleVersion = "2.8.7"
            implementation("androidx.lifecycle:lifecycle-runtime-ktx:$lifecycleVersion")
            implementation("androidx.lifecycle:lifecycle-runtime-compose:$lifecycleVersion")
            implementation("androidx.lifecycle:lifecycle-viewmodel-compose:$lifecycleVersion")
            val navVersion = "2.8.4"
            implementation("androidx.navigation:navigation-runtime-ktx:$navVersion")
            implementation("androidx.navigation:navigation-compose:$navVersion")
            implementation("androidx.datastore:datastore-preferences:1.1.1")

            // Google Play Services
            implementation("com.google.android.gms:play-services-location:21.3.0")

            // Compose
            implementation(compose.preview)
            implementation(project.dependencies.platform("androidx.compose:compose-bom:2024.02.00"))
            implementation("androidx.compose.ui:ui")
            implementation("androidx.compose.ui:ui-graphics")
            implementation("androidx.compose.ui:ui-tooling-preview")
            implementation("androidx.compose.material3:material3")
            implementation("androidx.compose.material:material")

            // Network
            implementation("com.google.code.gson:gson:2.10.1")
            implementation("com.squareup.retrofit2:retrofit:2.9.0")
            implementation("com.squareup.retrofit2:converter-gson:2.9.0")
            implementation("com.squareup.okhttp3:logging-interceptor:4.12.0")

            // Accompanist
            implementation("com.google.accompanist:accompanist-permissions:0.32.0")
        }
        commonMain.dependencies {
            implementation(compose.runtime)
            implementation(compose.foundation)
            implementation(compose.material)
            implementation(compose.ui)
            implementation(compose.components.resources)
            implementation(compose.components.uiToolingPreview)
            val lifecycleVersion = "2.8.3"
            implementation("org.jetbrains.androidx.lifecycle:lifecycle-viewmodel:$lifecycleVersion")
            implementation("org.jetbrains.androidx.lifecycle:lifecycle-runtime-compose:$lifecycleVersion")
        }
    }
}

android { ... }

dependencies { ... }
</code></pre>

<p>最后，把DSL android {&hellip;}中不支持的字段删除掉即可，如kotlinOptions，它用来指定Kotlin JVM target的，现改在DSL kotlin中的androidTarget()中指定了，但要注意Kotlin的JVM target要与android中的compileOptions的sourceCompatibility以及targetCompatibility版本保持一致，比如都是17或者都是11，否则会有编译错误。</p>

<p>需要特别注意的是DSL kotlin中的源码集合名字要与真实的目录一致，否则编译会出错。建议的方式就是依照CMP的demo那样在module中去创建androidMain和commonMain即可。另外，可以把module名字从「app」改为「composeApp」，然后把运行配置从「app」改为「androidApp」，这下就齐活儿了：</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/migrate-struct.png" alt="图1. 重命名后的项目结构" /></p>

<p>CMP的插件和依赖配置好了以后，运行「androidApp」应该就可以正常运行。因为仅是配置一些依赖，这仍是一个完整的Android应用，应该能够正常运行。这时第一步就做完了，虽然看起来貌似啥也没干，但这已经是一个CMP项目了，基础打好了，可以大步向前了。</p>

<p><strong>小贴士：</strong> 通过配置依赖可以发现，CMP的artifact依赖都是以org.jetbrans.*开头的，哪怕是对于Compose本身，纯Android上面Jetpack Compose的依赖是「&#8221;androidx.compose.ui:ui&#8221;」，而CMP中的则是「&#8221;org.jetbrains.compose.ui:ui&#8221;」。虽然都是Jetpack Compose，代码是兼容的，但技术上来讲是两个不同的实现。确切地说JetBrains的Compose是从谷歌的上面fork出来的一个分支，以让其更好的适用于CMP，但完全兼容，标准的Compose代码都是能正常跑的。</p>

<h2>把代码从「androidMain」移动到「commonMain」</h2>

<p>这是最关键的一步了，也是最难啃的硬骨头，具体的难度取决于项目中使用了多少「不兼容」的库和API。Compose和Jetpack中的绝大多数库都是支持的，可以在CMP中使用，可以无缝切换，这是JetBrains和Google共同努力的结果，谷歌现在对CMP/KMP的态度非常的积极，给与「第一优先支持（First class support）」。所以对于依赖于room，navigation，material和viewmodel的代码都可以直接移到common中。</p>

<p>也就是说对于data部分，model部分以及domain部分（即view models）都可以直接先移到common中，因为这些层，从架构角度来说都属于业务逻辑，都应该是平台独立的，它们的主要依赖应该是Jetpack以及三方的库，这些库大多也都可以直接跨平台。</p>

<p>当然，不可能这么顺利，因为或多或少会用到与平台强相关的API，比如最为常见的就是上下文对象（Context）以及像权限管理和硬件资源（如位置信息），这就需要用到平台定制机制（即expect/actual）来进行定制。</p>

<p>可能有同学会很奇怪，为啥UI层还不移动到common中，UI是用Compose写的啊，而Compose是可以直接在CMP上跑的啊。Compose写的UI确实可以直接跑，但UI必然会用到资源，必须 先把资源从android中移到common中，否则UI是跑不起来的。</p>

<h2>把资源转化成为CMP方式</h2>

<p>在前一篇文章<a href="https://juejin.cn/post/7439251025385996307">Compose大前端从上车到起飞</a>有讲过CMP用一个库resources来专门处理资源，规则与Android开发管理资源的方式很像，所以可以把UI用到的资源移动到common中的composeResources里面，就差不多了。</p>

<p>但需要特别注意，不要把全部的资源都从androidMain中移出，只需要把UI层用到的那部分资源移出即可。androidMain中至少要把Android强相关的资源留下，如应用的icon，应用的名字，以及一些关键的需要在manifest中使用的xml等。这是因为这些资源是需要在Android应用的配置文件AndroidManifest中使用的，所以必须还放在android源码集中。</p>

<p>资源文件移动好后，就可以把UI移动到common中了，最后一步就是使用CMP的资源类Res代替Android的资源类R即可。</p>

<p>到此，就完成了从Android项目到CMP项目的转变。</p>

<h2>添加并适配其他平台</h2>

<p>前面的工作做好后，再适配其他的平台就非常容易了，添加其他平台的target和入口（可以仿照CMP的demo），然后实现相关的expect接口即可。由此，一个大前端 项目就彻底大功告成了。</p>

<h2>总结</h2>

<p>CMP对项目结构中源码 集合 的限制 并不多，每个平台相关的sourceSet可以保持其原来的样子，这对现有项目是非常友好的，可以让现有的项目轻松的转成为CMP项目，这也是CMP最大的一个优势。</p>

<h2>References</h2>

<ul>
<li><a href="https://touchlab.co/compose-multiplatform-transition-guide">Jetpack Compose to Compose Multiplatform: Transition Guide</a></li>
<li><a href="https://stackoverflow.com/questions/71510247/how-to-convert-kotlin-project-to-kotlin-multiplatform-mobile-after-the-project-c">How to convert Kotlin project to Kotlin Multiplatform Mobile after the project completion?</a></li>
<li><a href="https://markonovakovic.medium.com/from-android-to-multiplatform-migrating-real-100-jetpack-compose-app-to-fully-multiplatform-app-2d65dc9e212e">From Android to Multiplatform: Migrating real 100% Jetpack Compose App to fully Multiplatform App. Intro</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
