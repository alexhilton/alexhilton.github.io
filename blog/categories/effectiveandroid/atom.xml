<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2026-01-22T12:41:39+00:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[务实的模块化：连接模块(wiring Modules)的妙用]]></title>
    <link href="https://alexhilton.github.io/blog/2026/01/03/pragmatic-modularization/"/>
    <updated>2026-01-03T00:00:00+00:00</updated>
    <id>https://alexhilton.github.io/blog/2026/01/03/pragmatic-modularization</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Pragmatic Modularization: The Case for Wiring Modules」，原文链接<a href="https://proandroiddev.com/pragmatic-modularization-the-case-for-wiring-modules-c936d3af3611">https://proandroiddev.com/pragmatic-modularization-the-case-for-wiring-modules-c936d3af3611</a>，由Alex Krafts发布于2025年11月22日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/0*9waVavO74e0cqQg6" title="auto auto" ></a></p>

<!-- more -->


<p>如果你正在经历漫长的模块化之旅，你应该已经阅读过官方的<a href="https://developer.android.com/topic/modularization">Google 开发者指南</a>。你可能已经见过关于提供依赖项的这种具体建议：</p>

<blockquote><p>“……app 模块通常是添加依赖项的好地方。要提供实现，请将其指定为所选构建变体或测试源集的依赖项。”</p></blockquote>

<p>下图展示了这种模式的一个常见示例，其中 <code>:app</code> 模块使用 <code>:database:impl:room</code> 作为其 <code>main</code> 源集，并使用 <code>:database:impl:mock</code> 作为 <code>androidTest</code> 源集。这是一种强大且正确的测试依赖项管理方法。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1304/0*Q3MP_6C6i4qhNhQr.png" alt="图 1. App 模块提供实际实现。" /></p>

<p>但这种模式存在一个<strong>微妙之处</strong>。当这种逻辑应用于大型项目中所有功能实现时，可能会<strong>无意中造成构建速度瓶颈</strong>，尤其是在处理遗留应用模块时。</p>

<pre><code class="kotlin">// :app/build.gradle.kts
dependencies {
    implementation(project(":database:api"))
    implementation(project(":database:impl:room")) // &lt;--- This is the trap for incremental builds
}
</code></pre>

<p>代码是模块化的，但你的 <code>:app</code> 模块现在与 <code>:database:impl:room</code> 模块<strong>构建耦合</strong>。这意味着任何<strong>资源更改</strong>（例如添加字符串）或对<strong>实现自身的公共接口</strong>的任何更改（例如在 <code>:impl</code> 内部添加一个不属于官方 <code>:api</code> 模块的新的 <code>public</code> 辅助类）都会破坏编译避免机制，并强制整个 <code>:app</code> 模块重新编译，从而抵消模块化带来的主要速度优势。</p>

<blockquote><p>即使启用了非传递 R 类等优化，直接依赖关系通常也会强制构建系统验证使用者是否与生产者的新资源符号匹配。布线模块充当防火墙，防止频繁的资源检查影响到庞大的 App 模块。</p></blockquote>

<h2>“精简应用”的理想状态与“臃肿应用”的现实</h2>

<p>官方建议让 <code>:app</code> 模块提供实现，这非常有效，尤其是在 Google 指南中展示的场景下：为不同的构建版本（例如 <code>main</code> 和 <code>androidTest</code>）替换依赖项。</p>

<p>但是，如果将此模式误用作所有功能实现的<em>通用规则</em>，尤其是在包含<strong>“臃肿应用”模块</strong>的项目中，就会出现一个微妙的陷阱。</p>

<p>官方指南通常会隐含地假设一种架构理想：<strong>“精简应用”模块</strong>。“精简应用”只是一个轻量级的汇编器。它几乎不包含任何代码或资源。它<em>唯一</em>的任务是应用 <code>com.android.application</code> 插件并将所有功能模块打包成一个 APK 文件。如果你的 <code>:app</code> 模块很精简，重新编译它既快速又便宜，因此它依赖于 <code>:impl</code> 模块并无大碍。</p>

<p>但对我们大多数人来说，现实情况是<strong>“厚应用”模块</strong>。它是最初的单体应用，仍然充斥着遗留代码、资源和半模块化的功能。</p>

<p>当你的“厚应用”模块直接依赖于某个功能的 <code>:impl</code> 时，例如 <code>:app</code> -> &ldquo;:database:impl:room&rdquo;<code>，你就创建了一个会拖慢构建速度的瓶颈。你最大、最复杂的模块现在与该功能的内部细节**构建耦合**了。任何对</code>:impl<code>中资源或实现自身公共接口的更改都会破坏编译规避机制，并强制整个</code>:app` 模块重新编译。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1304/1*su8uLnwQsJMVWsUxrlVBSg.png" alt="图 2. “厚应用”瓶颈。由于庞大的 :app 模块直接依赖于实现，因此底层任何 ABI 更改都会触发顶层的完全重新编译。红色箭头展示了功能模块中的一个微小改动如何迫使资源密集型的 `:app` 模块重新构建，从而破坏了避免编译的策略。" /></p>

<p>“现在，一个纯粹主义者可能会说：‘你应该更加自律，永远不要让你的 <code>:app</code> 模块从 <code>:impl</code> 导入任何东西，即使是公共的。’</p>

<p>他们的说法没错。但是，在一个拥有数十位贡献者的‘厚应用’单体应用中，‘自律’是一种脆弱的防御手段。而连接模块模式<strong>在构建系统层面强制执行了这种自律。</strong>它使得开发者<em>不可能</em>意外地将 <code>:app</code> 模块与某个功能的实现细节耦合在一起，从而默认地保证了构建速度。”</p>

<h2>“理想”方案 vs. “赋能”方案</h2>

<p>这让团队面临两条道路：</p>

<ol>
<li>“理想”（但缓慢）方案：纯粹主义者的解决方案是将“臃肿的应用”模块重构为真正“精简”的模块……这才是正确的长期目标，但这需要数年时间，循序渐进。</li>
<li>“赋能”（但快速）方案：这是“连接模块”模式。这种模式并非理想方案的替代方案，而是实现理想方案的催化剂。它提供了团队所需的构建速度和稳定性，使团队有时间和信心真正执行长期的增量重构。</li>
</ol>


<p>虽然这会增加“模块蔓延”，但它以架构的纯粹性换取了工程速度。在大型团队中，速度通常是更关键的指标。</p>

<p>但这种观点将问题简单地二元化了。实际上，这种模式是一种<strong>务实的权衡</strong>。你是在<strong>有意识地做出权衡</strong>。你接受了新的、可控的成本（增加模块数量和配置），以解决一个令人头疼的日常问题（缓慢的增量构建）。这种新的、明确的“连接”债务通常远比“臃肿应用”的单体架构债务成本低得多，后者正在扼杀团队的开发速度。这种构建速度往往正是团队能够拥有时间和稳定性来进行更大规模、更长期的重构的关键所在。</p>

<p>像 Slack、Spotify 和 Uber 这样的大型 Android 代码库都公开讨论过一些模式，这些模式大量依赖于将实现细节隐藏在稳定的 API 之后。这并非权宜之计；这是大型团队保持构建速度快和代码库可维护性的根本方法。</p>

<h2>解决方案：“连接模块”模式</h2>

<blockquote><p>这种模式有时被称为聚合模块，但我们更倾向于使用“连接”，因为它更能体现其在连接架构中的积极作用。</p></blockquote>

<p>此解决方案引入了一个新的轻量级<strong>“连接模块”</strong>（例如，<code>:database:wiring</code>）。该模块充当“守门人”或该功能的稳定外观。</p>

<p>其原理很简单：</p>

<ol>
<li><code>:app</code> 模块<em>仅</em>依赖于新的、稳定的 <code>:database:wiring</code> 模块。</li>
<li>连接模块<em>是唯一</em>了解其自身内部 <code>:impl</code>（以及 <code>:ui</code>、<code>:domain</code> 等）模块的模块。</li>
</ol>


<pre><code class="kotlin">// :app/build.gradle.kts (Corrected)
dependencies {
    // ...
    implementation(project(":database:wiring")) // NOW it's decoupled!
    implementation(project(":feature:home"))
}
</code></pre>

<pre><code class="kotlin">// :database:wiring/build.gradle.kts (The new "Wiring Module")
plugins {
    id("com.android.library")
}
android {
    namespace = "com.example.database.wiring"
}
dependencies {
    // Link the bindings internally without exposing the API transitively
    implementation(project(":database:api"))

    // Hide the implementation details from the :app module
    implementation(project(":database:impl:room"))
}
</code></pre>

<p>这种模式并非免费。这是一个务实的步骤，它能实现你承诺的快速增量构建，赋予你的团队速度和稳定性，从而支持那些规模更大、周期更长的重构。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1304/1*H2gD-qUVVI2r7CsTtMSt6Q.png" alt="图 3. 使用 :impl:room 模块 ABI 更改后的增量构建仅触发轻量级 :wiring 模块重建" /></p>

<p>现在，<code>:app</code> 模块仅依赖于稳定的 wiring 模块。</p>

<p><strong>关于依赖注入的说明：</strong></p>

<p>这个“wiring 模块”不仅仅是一个提升构建速度的技巧；它是你功能<strong>依赖注入绑定</strong>（例如 Dagger 或 Hilt 的 <code>@Module</code>）的理想存放位置。它的唯一职责就是将抽象的 <code>:api</code> 连接到具体的 <code>:impl</code>，这正是清晰依赖注入 (DI) 的精髓所在。</p>

<p>这种模式能够确保良好的架构，而构建速度的提升则是这种清晰分离带来的一个绝佳附加效果。</p>

<h2>为什么速度如此之快：理解编译避免</h2>

<p>这种结构并非权宜之计；它是启用 Gradle 最强大的构建速度提升功能——<strong>编译避免</strong>——的<em>正确</em>方法。</p>

<p>Gradle 团队在其精彩博文“<a href="https://blog.gradle.org/our-approach-to-faster-compilation">我们实现更快编译的方法</a>”中对此进行了解释。以下是关键要点：</p>

<ol>
<li><strong>Gradle 检查的是 ABI，而不是实现：</strong> 正如博文所述，Gradle 检查的是依赖项的<strong>应用程序二进制接口 (ABI)</strong>。ABI 是模块的“公共契约”或“公共结构”——即其公共类和方法签名。它<strong>不</strong>包含方法体等私有实现细节。</li>
<li><strong>旧方法会破坏这一点：</strong> 当你的 <code>:app</code> 模块直接依赖于 <code>:database:impl:room</code> 时，你实际上是在强制 Gradle 将整个实现都视为应用构建的一部分。正如我们之前提到的，<code>:database:impl:room</code> 中任何<strong>资源更改</strong>或对实现本身的<strong>公共接口</strong>（例如新增的 <code>public</code> 辅助函数）的更改，对于 <code>:app</code> 来说都是 ABI 不兼容的更改，从而导致需要完全重新编译。</li>
<li><p><strong>新方法可以解决这个问题：</strong> 使用我们的 <code>:database:wiring</code> 模块后：</p></li>
<li><p>开发人员更改了 <code>:database:impl:room</code> 中的一个文件。</p></li>
<li><code>:database:wiring</code> 模块重新编译（由于它很小，所以速度很快）。</li>
<li><strong>至关重要的是</strong>，正如 Gradle 博客文章中所解释的，这是一个 <strong>ABI 兼容的更改</strong>。连接模块的<em>公共结构</em>（即其 <code>api</code> 依赖项）并未改变。</li>
<li>Gradle 会检查 <code>:app</code>，发现其依赖项的 ABI 完全相同，因此<strong>完全跳过重新编译</strong> <code>:app</code>。</li>
</ol>


<p>这篇博文将此称为<strong>编译避免(Compilation Avoidance)</strong>（完全跳过模块的编译），并将其与<em>增量编译</em>（重新编译模块中的<em>某些</em>文件）区分开来。这种模式是实现主应用程序模块真正避免编译的最有效方法之一。</p>

<h2>实际应用：效果如何</h2>

<p>这并非纸上谈兵。我们在生产应用中使用 Gradle Profiler 来测试这种模式旨在解决的具体场景：在某个功能的 <code>:impl</code> 模块中进行破坏 ABI 的更改（例如，添加一个新的公共方法），然后运行增量 <code>:app:assembleDebug</code> 构建。</p>

<p>我们对八个不同的功能模块重复了此操作，并在引入连接模块前后分别对每个功能模块进行了平均 10 次运行。在旧配置中，<code>:app</code> 直接依赖于 <code>:feature:impl</code>，这些增量构建平均耗时约 <strong>99 秒</strong>。引入连接模块后，<code>:app</code> 仅依赖于 <code>:feature:wiring</code>，相同场景下的平均耗时降至约 <strong>63 秒</strong>。</p>

<p>在这八个功能模块中，速度提升幅度约为 <strong>29%</strong> 到 <strong>45%</strong>，在这种特定的增量构建场景下，平均提升幅度约为 <strong>36%</strong>。</p>

<p>在进行此次重构时，我恰好在研究是否值得将我的 MacBook 升级到更新的 Apple Silicon 机型。这个对比让我恍然大悟：对于这种工作负载，此次连接模块的更改所带来的构建速度提升，与升级到性能更强劲的高端 MacBook 机型**的效果不相上下。区别在于，这种重构能够有效地让参与项目的每个开发者都感受到“新机器”般的体验——而这仅仅是通过一个小的、有针对性的 Gradle 修改实现的，而非硬件升级。</p>

<h2>要点</h2>

<p>官方文档的建议在理论上是正确的，但理解实践中的权衡取舍至关重要。</p>

<p>对于任何实际的<strong>“厚应用”模块</strong>而言，直接依赖 <code>:impl</code> 模块通常会导致构建速度瓶颈，因为它将最大的模块与某个功能的内部变更耦合在一起。</p>

<p>保护构建速度至关重要。“模块连接”模式是一种非常实用且低成本的重构方式，它能显著提升日常工作流程的构建速度，而成本通常仅为完整 <code>:app</code> 模块重构的一小部分。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jetpack ViewModel内幕：内部机制与跨平台设计]]></title>
    <link href="https://alexhilton.github.io/blog/2025/12/31/inside-jetpack-viewmodel/"/>
    <updated>2025-12-31T00:00:00+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/12/31/inside-jetpack-viewmodel</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Inside Jetpack ViewModel: Internal Mechanisms and Multiplatform Design」，原文链接<a href="https://proandroiddev.com/inside-jetpack-viewmodel-internal-mechanisms-and-multiplatform-design-2625671eaef8">https://proandroiddev.com/inside-jetpack-viewmodel-internal-mechanisms-and-multiplatform-design-2625671eaef8</a>，由Jaewoong Eum发布于2025年12月7日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:2000/format:webp/0*tOtkLxn9LUT6ZAsI" title="auto auto" ></a></p>

<!-- more -->


<p>Jetpack 的 ViewModel 已成为现代 Android 开发中不可或缺的组件，它为 UI 相关数据提供了一个生命周期感知容器，即使配置发生更改，数据也能保持不变。虽然其 API 表面上看起来很简单，但其内部机制却展现了围绕生命周期管理、跨平台抽象、资源清理和线程安全缓存等方面的设计决策。了解 ViewModel 的底层工作原理有助于你做出更优的架构决策，并避免一些不易察觉的错误。</p>

<p>本文将深入探讨 Jetpack ViewModel 的内部工作原理，包括 <code>ViewModelStore</code> 如何在配置更改后保留实例、<code>ViewModelProvider</code> 如何协调创建和缓存、工厂模式如何实现灵活的实例化、<code>CreationExtras</code> 如何实现无状态工厂、如何通过 Closeable 模式管理资源清理，以及 <code>viewModelScope</code> 如何将协程与 ViewModel 生命周期集成。</p>

<h2>根本问题：配置更改后的保留</h2>

<p>配置更改是 Android 开发面临的一项根本性挑战。当用户旋转设备、更改语言设置或触发任何配置更改时，系统会销毁并重新创建 Activity。Activity 中存储的所有数据都会丢失：</p>

<pre><code class="kotlin">class MyActivity : ComponentActivity() {
    private var userData: User? = null  // Lost on rotation!

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // Must reload data after every rotation
        loadUserData()
    }
}
</code></pre>

<p>一种简单的方法是使用 <code>onSaveInstanceState()</code>：</p>

<pre><code class="kotlin">override fun onSaveInstanceState(outState: Bundle) {
    super.onSaveInstanceState(outState)
    outState.putParcelable("user", userData)
}

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    userData = savedInstanceState?.getParcelable("user")
}
</code></pre>

<p>这种方法适用于小型、可序列化的数据。但是，对于大型数据集、网络连接或无法序列化的对象呢？对于持续进行的网络请求等操作呢？Bundle 方法在这些情况下会失效，原因既有大小限制，也有序列化/反序列化的高昂开销。</p>

<p>ViewModel 通过提供一个生命周期感知容器来解决这个问题，该容器通过保留对象模式（而非序列化）来应对配置更改。</p>

<h2>ViewModelStore：保留机制</h2>

<p>ViewModel 配置变更后仍能保留的核心是 <code>ViewModelStore</code>，它是一个简单的键值存储，用于保存 ViewModel 实例：</p>

<pre><code class="kotlin">public open class ViewModelStore {

    private val map = mutableMapOf&lt;String, ViewModel&gt;()

    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
    public fun put(key: String, viewModel: ViewModel) {
        val oldViewModel = map.put(key, viewModel)
        oldViewModel?.clear()
    }

    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
    public operator fun get(key: String): ViewModel? {
        return map[key]
    }

    @RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
    public fun keys(): Set&lt;String&gt; {
        return HashSet(map.keys)
    }

    public fun clear() {
        for (vm in map.values) {
            vm.clear()
        }
        map.clear()
    }
}
</code></pre>

<p>实现非常简单，就是一个 <code>MutableMap&lt;String, ViewModel&gt;</code>。关键不在于存储本身，而在于存储的保留方式。</p>

<h3>键替换行为</h3>

<p>请注意 <code>put</code> 方法的行为：</p>

<pre><code class="kotlin">public fun put(key: String, viewModel: ViewModel) {
    val oldViewModel = map.put(key, viewModel)
    oldViewModel?.clear()
}
</code></pre>

<p>如果已存在具有相同键的 ViewModel，则旧的 ViewModel 会被立即清除。这确保了在替换 ViewModel 时能够正确清理。你可能想知道这种情况何时发生，它发生在你请求具有相同键但类型不同的 ViewModel 时：</p>

<pre><code class="kotlin">// First request creates TestViewModel1 with key "my_key"
val vm1: TestViewModel1 = viewModelProvider["my_key", TestViewModel1::class]

// Second request with same key but different type
val vm2: TestViewModel2 = viewModelProvider["my_key", TestViewModel2::class]

// vm1.onCleared() has been called, vm1 is no longer valid
</code></pre>

<p>此行为已在测试套件中验证：</p>

<pre><code class="kotlin">@Test
fun twoViewModelsWithSameKey() {
    val key = "the_key"
    val vm1 = viewModelProvider[key, TestViewModel1::class]
    assertThat(vm1.cleared).isFalse()
    val vw2 = viewModelProvider[key, TestViewModel2::class]
    assertThat(vw2).isNotNull()
    assertThat(vm1.cleared).isTrue()
}
</code></pre>

<h3>ViewModelStoreOwner 契约</h3>

<p><code>ViewModelStoreOwner</code> 接口定义了谁拥有该存储：</p>

<pre><code class="kotlin">public interface ViewModelStoreOwner {
    public val viewModelStore: ViewModelStore
}
</code></pre>

<p><code>ComponentActivity</code>、<code>Fragment</code> 和 <code>NavBackStackEntry</code> 都实现了这个简单的接口。所有者的职责有两方面：</p>

<ol>
<li><strong>在配置更改后保留存储</strong>：存储必须在 Activity 重建后仍然存在。</li>
<li><strong>在真正完成后清除存储</strong>：当所有者被销毁而未重建时，调用 <code>ViewModelStore.clear()</code>。</li>
</ol>


<p>对于 Activity 而言，这通常使用 <code>NonConfigurationInstances</code> 来实现，这是一种特殊的机制，允许对象在配置更改后仍然存在。Activity 框架在 <code>onRetainNonConfigurationInstance()</code> 期间保留这些对象，并在 <code>getLastNonConfigurationInstance()</code> 中恢复它们。</p>

<h3>为什么简单的映射有效</h3>

<p>你可能期望使用复杂的缓存机制，但简单的 <code>MutableMap</code> 就足够了，原因如下：</p>

<ol>
<li><strong>大小有限</strong>：每个屏幕上的 ViewModel 数量很少（通常为 1-5 个）。</li>
<li><strong>字符串键</strong>：键由类名生成，使得查找复杂度为 O(1)，并且哈希分布良好。</li>
<li><strong>无需驱逐</strong>：ViewModel 仅在显式请求或所有者被销毁时才会被清除。</li>
<li><strong>线程安全</strong>：访问在 ViewModelProvider 级别同步。</li>
</ol>


<h2>ViewModelProvider：编排层</h2>

<p><code>ViewModelProvider</code> 是获取 ViewModel 实例的主要 API。它负责编排 store、factory 和创建 extras 之间的交互：</p>

<pre><code class="kotlin">public actual open class ViewModelProvider
private constructor(private val impl: ViewModelProviderImpl) {

    public constructor(
        store: ViewModelStore,
        factory: Factory,
        defaultCreationExtras: CreationExtras = CreationExtras.Empty,
    ) : this(ViewModelProviderImpl(store, factory, defaultCreationExtras))

    public constructor(
        owner: ViewModelStoreOwner
    ) : this(
        store = owner.viewModelStore,
        factory = ViewModelProviders.getDefaultFactory(owner),
        defaultCreationExtras = ViewModelProviders.getDefaultCreationExtras(owner),
    )

    @MainThread
    public actual operator fun &lt;T : ViewModel&gt; get(modelClass: KClass&lt;T&gt;): T =
        impl.getViewModel(modelClass)

    @MainThread
    public actual operator fun &lt;T : ViewModel&gt; get(key: String, modelClass: KClass&lt;T&gt;): T =
        impl.getViewModel(modelClass, key)
}
</code></pre>

<h3>多平台抽象</h3>

<p>请注意 <code>ViewModelProviderImpl</code> 委托。ViewModel 库是一个 Kotlin 多平台库，支持 JVM、Android、iOS 和其他平台。Kotlin 多平台目前还不支持带有默认实现的 expect 类，因此通用逻辑被提取到内部实现类中：</p>

<pre><code class="kotlin">internal class ViewModelProviderImpl(
    private val store: ViewModelStore,
    private val factory: ViewModelProvider.Factory,
    private val defaultExtras: CreationExtras,
) {

    private val lock = SynchronizedObject()

    @Suppress("UNCHECKED_CAST")
    internal fun &lt;T : ViewModel&gt; getViewModel(
        modelClass: KClass&lt;T&gt;,
        key: String = ViewModelProviders.getDefaultKey(modelClass),
    ): T {
        return synchronized(lock) {
            val viewModel = store[key]
            if (modelClass.isInstance(viewModel)) {
                if (factory is ViewModelProvider.OnRequeryFactory) {
                    factory.onRequery(viewModel!!)
                }
                return@synchronized viewModel as T
            }

            val modelExtras = MutableCreationExtras(defaultExtras)
            modelExtras[ViewModelProvider.VIEW_MODEL_KEY] = key

            return@synchronized createViewModel(factory, modelClass, modelExtras).also { vm -&gt;
                store.put(key, vm)
            }
        }
    }
}
</code></pre>

<h3>获取或创建模式</h3>

<p><code>getViewModel</code> 方法实现了经典的获取或创建模式：</p>

<ol>
<li><strong>生成键</strong>：默认键基于类的规范名称。</li>
<li><strong>检查缓存</strong>：通过键查找已存在的 ViewModel。</li>
<li><strong>类型检查</strong>：验证缓存实例的类型是否正确。</li>
<li><strong>返回缓存</strong>：如果有效，则返回缓存的实例。</li>
<li><strong>创建新实例</strong>：如果未找到或类型错误，则通过工厂模式创建新实例。</li>
<li><strong>存储</strong>：将新实例放入存储中。</li>
</ol>


<h3>使用同步访问确保线程安全</h3>

<p><code>synchronized(lock)</code> 代码块确保线程安全访问。虽然 ViewModel 的访问通常来自主线程（如 <code>@MainThread</code> 所示），但同步机制可以防止后台线程访问 ViewModel 等极端情况，尤其是在测试场景或使用 <code>viewModelScope</code> 时。</p>

<h3>OnRequeryFactory 回调</h3>

<p><code>OnRequeryFactory</code> 是一种特殊的机制，用于在检索缓存的 ViewModel 时执行操作的工厂：</p>

<pre><code class="kotlin">@RestrictTo(RestrictTo.Scope.LIBRARY_GROUP)
public actual open class OnRequeryFactory {
    public actual open fun onRequery(viewModel: ViewModel) {}
}
</code></pre>

<p><code>SavedStateHandle</code> 内部使用此机制在配置更改后将 ViewModel 与当前的 SavedStateRegistry 重新连接。当从缓存中检索 ViewModel 时，会调用工厂的 <code>onRequery</code> 方法，从而更新可能已更改的引用。</p>

<h3>从类名生成键</h3>

<p>默认的键生成机制可防止意外冲突：</p>

<pre><code class="kotlin">internal fun &lt;T : ViewModel&gt; getDefaultKey(modelClass: KClass&lt;T&gt;): String {
    val canonicalName =
        requireNotNull(modelClass.canonicalName) {
            "Local and anonymous classes can not be ViewModels"
        }
    return "$VIEW_MODEL_PROVIDER_DEFAULT_KEY:$canonicalName"
}
</code></pre>

<p>前缀 <code>"androidx.lifecycle.ViewModelProvider.DefaultKey:"</code> 可确保键不会与用户提供的自定义键冲突。规范名称要求也解释了为什么本地类和匿名类不能是 ViewModel，因为它们没有规范名称：</p>

<pre><code class="kotlin">@Test
fun localViewModel() {
    class LocalViewModel : ViewModel()
    try {
        viewModelProvider[LocalViewModel::class]
        fail("Expected `IllegalArgumentException`")
    } catch (e: IllegalArgumentException) {
        assertThat(e)
            .hasMessageThat()
            .contains("Local and anonymous classes can not be ViewModels")
    }
}
</code></pre>

<h2>工厂模式：灵活实例化</h2>

<p><code>ViewModelProvider.Factory</code> 是创建 ViewModel 实例的机制：</p>

<pre><code class="kotlin">public actual interface Factory {
    public fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T =
        ViewModelProviders.unsupportedCreateViewModel()

    public fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;, extras: CreationExtras): T =
        create(modelClass)

    public actual fun &lt;T : ViewModel&gt; create(modelClass: KClass&lt;T&gt;, extras: CreationExtras): T =
        create(modelClass.java, extras)
}
</code></pre>

<h3>方法重载链</h3>

<p>工厂接口有三个 <code>create</code> 方法变体，形成一个链：</p>

<ol>
<li><code>create(KClass&lt;T&gt;, CreationExtras)</code>：Kotlin 优先 API，委托给 Java 变体</li>
<li><code>create(Class&lt;T&gt;, CreationExtras)</code>：主要实现点，默认为无附加组件的变体</li>
<li><code>create(Class&lt;T&gt;)</code>：传统 API，默认抛出异常</li>
</ol>


<p>此链在保持向后兼容性的同时，也鼓励使用基于 <code>CreationExtras</code> 的现代方法。</p>

<h3>NewInstanceFactory：基于反射的创建</h3>

<p>最简单的工厂使用反射来创建带有无参构造函数的 ViewModel：</p>

<pre><code class="kotlin">public open class NewInstanceFactory : Factory {
    public override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T =
        JvmViewModelProviders.createViewModel(modelClass)
}
</code></pre>

<p>JVM 实现使用反射并进行了细致的错误处理：</p>

<pre><code class="kotlin">internal object JvmViewModelProviders {
    fun &lt;T : ViewModel&gt; createViewModel(modelClass: Class&lt;T&gt;): T {
        val constructor =
            try {
                modelClass.getDeclaredConstructor()
            } catch (e: NoSuchMethodException) {
                throw RuntimeException("Cannot create an instance of $modelClass", e)
            }

        // Enforce public constructor for consistent behavior
        if (!Modifier.isPublic(constructor.modifiers)) {
            throw RuntimeException("Cannot create an instance of $modelClass")
        }

        return try {
            constructor.newInstance()
        } catch (e: InstantiationException) {
            throw RuntimeException("Cannot create an instance of $modelClass", e)
        } catch (e: IllegalAccessException) {
            throw RuntimeException("Cannot create an instance of $modelClass", e)
        }
    }
}
</code></pre>

<p>公共修饰符检查对于测试一致性至关重要。在插桩测试中，R8 可能会移除访问修饰符，使私有构造函数可访问。JVM 测试严格执行访问限制。此显式检查可确保跨测试环境的行为一致性。</p>

<h3>AndroidViewModelFactory：应用感知创建</h3>

<p><code>AndroidViewModelFactory</code> 继承自 <code>NewInstanceFactory</code> 以支持 <code>AndroidViewModel</code>，后者需要一个 <code>Application</code> 参数。该工厂在保持向后兼容性的同时，也采用了现代的 <code>CreationExtras</code> 方法：</p>

<pre><code class="kotlin">public open class AndroidViewModelFactory
private constructor(
    private val application: Application?,
    @Suppress("UNUSED_PARAMETER") unused: Int,
) : NewInstanceFactory() {

    override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;, extras: CreationExtras): T {
        return if (application != null) {
            create(modelClass)
        } else {
            val application = extras[APPLICATION_KEY]
            if (application != null) {
                create(modelClass, application)
            } else {
                if (AndroidViewModel::class.java.isAssignableFrom(modelClass)) {
                    throw IllegalArgumentException(
                        "CreationExtras must have an application by `APPLICATION_KEY`"
                    )
                }
                super.create(modelClass)
            }
        }
    }

    private fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;, app: Application): T {
        return if (AndroidViewModel::class.java.isAssignableFrom(modelClass)) {
            try {
                modelClass.getConstructor(Application::class.java).newInstance(app)
            } catch (e: NoSuchMethodException) {
                throw RuntimeException("Cannot create an instance of $modelClass", e)
            }
        } else super.create(modelClass)
    }
}
</code></pre>

<p>该工厂实现了级联解析策略：首先检查是否将 <code>Application</code> 传递给了构造函数（传统方法），然后通过 <code>APPLICATION_KEY</code> 在 <code>CreationExtras</code> 中查找（现代无状态方法），最后对于常规 ViewModel 回退到 <code>NewInstanceFactory</code>，或者如果 <code>AndroidViewModel</code> 没有可用的 <code>Application</code>，则抛出异常。</p>

<p>私有构造函数中的 <code>unused: Int</code> 参数是一个巧妙的技巧，用于区分重载构造函数，因为如果使用 <code>null</code> 调用 <code>constructor()</code>，编译器将无法区分 <code>constructor(application: Application?)</code>。</p>

<p>实例化使用了反射（<code>modelClass.getConstructor(Application::class.java).newInstance(app)</code>），这意味着你的 <code>AndroidViewModel</code> 子类必须有一个接受且仅接受一个 <code>Application</code> 参数的构造函数。对于其他依赖项，你需要自定义工厂或依赖注入框架，例如 Hilt。</p>

<h3>InitializerViewModelFactory：基于 Lambda 的创建</h3>

<p>对于具有自定义依赖项的 ViewModel，<code>InitializerViewModelFactory</code> 提供了一种基于 DSL 的方法，可以减少样板代码：</p>

<pre><code class="kotlin">val factory = viewModelFactory {
    initializer { MyViewModel(get(MY_KEY)) }
    initializer { AnotherViewModel(get(ANOTHER_KEY)) }
}
</code></pre>

<p>该 DSL 由一个构建器类驱动，该构建器类收集初始化 Lambda 表达式，其中每个初始化器将一个 <code>KClass</code> 与其创建 Lambda 表达式配对：</p>

<pre><code class="kotlin">@ViewModelFactoryDsl
public class InitializerViewModelFactoryBuilder public constructor() {

    private val initializers = mutableMapOf&lt;KClass&lt;*&gt;, ViewModelInitializer&lt;*&gt;&gt;()

    public fun &lt;T : ViewModel&gt; addInitializer(
        clazz: KClass&lt;T&gt;,
        initializer: CreationExtras.() -&gt; T,
    ) {
        require(clazz !in initializers) {
            "A `initializer` with the same `clazz` has already been added: ${clazz.canonicalName}."
        }
        initializers[clazz] = ViewModelInitializer(clazz, initializer)
    }

    public fun build(): ViewModelProvider.Factory =
        ViewModelProviders.createInitializerFactory(initializers.values)
}
</code></pre>

<p><code>@ViewModelFactoryDsl</code> 注解是一个 DSL 标记，可防止嵌套的构建器作用域意外访问外部作用域的方法。初始化 Lambda 表达式接收 <code>CreationExtras</code> 作为其接收器，允许通过 <code>get()</code> 直接访问额外内容。</p>

<p>在创建时，工厂会通过初始化器进行线性搜索，以找到匹配的类：</p>

<pre><code class="kotlin">internal fun &lt;VM : ViewModel&gt; createViewModelFromInitializers(
    modelClass: KClass&lt;VM&gt;,
    extras: CreationExtras,
    vararg initializers: ViewModelInitializer&lt;*&gt;,
): VM {
    val viewModel =
        initializers.firstOrNull { it.clazz == modelClass }?.initializer?.invoke(extras) as VM?
    return requireNotNull(viewModel) {
        "No initializer set for given class ${modelClass.canonicalName}"
    }
}
</code></pre>

<p>线性搜索是可以接受的，因为每个工厂创建的 ViewModel 数量通常很少（1-5 个），而且 ViewModel 的创建频率很低（每个生命周期一次）。</p>

<h2>CreationExtras：无状态工厂配置</h2>

<p><code>CreationExtras</code> 是一个类型安全的键值容器，用于在不使工厂成为有状态的情况下向其传递配置。工厂不再通过构造函数注入来持有依赖项，而是在创建时传递依赖项：</p>

<pre><code class="kotlin">public abstract class CreationExtras internal constructor() {
    internal val extras: MutableMap&lt;Key&lt;*&gt;, Any?&gt; = mutableMapOf()

    public interface Key&lt;T&gt;

    public abstract operator fun &lt;T&gt; get(key: Key&lt;T&gt;): T?

    public object Empty : CreationExtras() {
        override fun &lt;T&gt; get(key: Key&lt;T&gt;): T? = null
    }
}
</code></pre>

<h3>类型安全的键</h3>

<p>每个键都由其关联的值类型参数化，从而提供编译时类型安全。当你使用 <code>extras[APPLICATION_KEY]</code> 获取值时，返回类型会自动为 <code>Application?</code>：</p>

<pre><code class="kotlin">val APPLICATION_KEY: Key&lt;Application&gt; = CreationExtras.Companion.Key()
val VIEW_MODEL_KEY: Key&lt;String&gt; = CreationExtras.Companion.Key()
</code></pre>

<p>键的创建使用了一个内联函数，该函数创建一个实现 <code>Key</code> 接口的新匿名对象。由于每个键都是一个唯一的对象实例，因此键之间通过标识（<code>===</code>）进行比较，即使两个键具有相同的类型参数，也不会发生意外冲突：</p>

<pre><code class="kotlin">@JvmStatic
public inline fun &lt;reified T&gt; Key(): Key&lt;T&gt; = object : Key&lt;T&gt; {}
</code></pre>

<h3>用于修改的 MutableCreationExtras</h3>

<p>基类 <code>CreationExtras</code> 是只读的，而 <code>MutableCreationExtras</code> 允许添加条目。这种分离遵循 Kotlin 的集合设计理念（例如 <code>List</code> 与 <code>MutableList</code>），防止工厂意外修改共享的 extras：</p>

<pre><code class="kotlin">public class MutableCreationExtras
public constructor(initialExtras: CreationExtras = Empty) : CreationExtras() {

    init {
        extras += initialExtras.extras
    }

    public operator fun &lt;T&gt; set(key: Key&lt;T&gt;, t: T) {
        extras[key] = t
    }

    @Suppress("UNCHECKED_CAST")
    public override fun &lt;T&gt; get(key: Key&lt;T&gt;): T? = extras[key] as T?
}
</code></pre>

<h3>与 ViewModelProvider 集成</h3>

<p><code>ViewModelProvider</code> 会在调用工厂之前自动将 ViewModel 的键添加到 extras 中，这对于像 <code>SavedStateHandle</code> 这样需要键来正确限定持久化范围的功能至关重要：</p>

<pre><code class="kotlin">val modelExtras = MutableCreationExtras(defaultExtras)
modelExtras[ViewModelProvider.VIEW_MODEL_KEY] = key

return@synchronized createViewModel(factory, modelClass, modelExtras)
</code></pre>

<h3>HasDefaultViewModelProviderFactory</h3>

<p><code>ViewModelStoreOwner</code> 的实现可以通过 <code>HasDefaultViewModelProviderFactory</code> 接口提供默认的工厂和 extras。 <code>ComponentActivity</code> 和 <code>Fragment</code> 都实现了此接口，并提供了支持 <code>SavedStateHandle</code> 且预先填充了 <code>APPLICATION_KEY</code> 的工厂：</p>

<pre><code class="kotlin">public interface HasDefaultViewModelProviderFactory {
    public val defaultViewModelProviderFactory: ViewModelProvider.Factory

    public val defaultViewModelCreationExtras: CreationExtras
        get() = CreationExtras.Empty
}
</code></pre>

<p><code>ComponentActivity</code> 和 <code>Fragment</code> 都实现了此接口，并提供了支持 <code>SavedStateHandle</code> 和正确的 <code>CreationExtras</code> 且预先填充了 <code>APPLICATION_KEY</code> 的工厂。</p>

<p>从 <code>ViewModelStoreOwner</code> 创建 <code>ViewModelProvider</code> 时，会自动使用以下默认值：</p>

<pre><code class="kotlin">internal fun getDefaultFactory(owner: ViewModelStoreOwner): ViewModelProvider.Factory =
    if (owner is HasDefaultViewModelProviderFactory) {
        owner.defaultViewModelProviderFactory
    } else {
        DefaultViewModelProviderFactory
    }

internal fun getDefaultCreationExtras(owner: ViewModelStoreOwner): CreationExtras =
    if (owner is HasDefaultViewModelProviderFactory) {
        owner.defaultViewModelCreationExtras
    } else {
        CreationExtras.Empty
    }
</code></pre>

<p>这种模式支持渐进增强：简单的 ViewModel 使用默认工厂，而复杂的 ViewModel 可以通过 extras 获取丰富的配置，而无需更改获取 ViewModelProvider 的方式。</p>

<h2>ViewModel 类：资源管理</h2>

<p><code>ViewModel</code> 类通过 <code>AutoCloseable</code> 模式管理资源生命周期。<code>expect</code> 关键字表明这是一个 Kotlin 多平台声明，每个平台都提供自己的 <code>actual</code> 实现：</p>

<pre><code class="kotlin">public expect abstract class ViewModel {
    public constructor()
    public constructor(viewModelScope: CoroutineScope)
    public constructor(vararg closeables: AutoCloseable)
    public constructor(viewModelScope: CoroutineScope, vararg closeables: AutoCloseable)

    protected open fun onCleared()

    @MainThread internal fun clear()

    public fun addCloseable(key: String, closeable: AutoCloseable)
    public open fun addCloseable(closeable: AutoCloseable)
    public fun &lt;T : AutoCloseable&gt; getCloseable(key: String): T?
}
</code></pre>

<h3>ViewModelImpl 内部实现</h3>

<p>实际实现委托给 <code>ViewModelImpl</code>，遵循多平台模式，将通用逻辑提取到内部类中。<code>isCleared</code> 上的 <code>@Volatile</code> 注解确保跨线程可见，这对于清除后的保护机制至关重要：</p>

<pre><code class="kotlin">internal class ViewModelImpl {
    private val lock = SynchronizedObject()
    private val keyToCloseables = mutableMapOf&lt;String, AutoCloseable&gt;()
    private val closeables = mutableSetOf&lt;AutoCloseable&gt;()

    @Volatile private var isCleared = false

    constructor()

    constructor(viewModelScope: CoroutineScope) {
        addCloseable(VIEW_MODEL_SCOPE_KEY, viewModelScope.asCloseable())
    }

    constructor(vararg closeables: AutoCloseable) {
        this.closeables += closeables
    }

    constructor(viewModelScope: CoroutineScope, vararg closeables: AutoCloseable) {
        addCloseable(VIEW_MODEL_SCOPE_KEY, viewModelScope.asCloseable())
        this.closeables += closeables
    }
}
</code></pre>

<h3>两层可关闭存储</h3>

<p>该实现维护两个集合：<code>keyToCloseables</code> 用于注册后需要检索的资源（例如 <code>viewModelScope</code>），以及 <code>closeables</code> 用于即用即弃的清理。使用 <code>Set</code> 来管理匿名可关闭资源可以防止重复注册导致双重关闭。</p>

<h3>清除顺序</h3>

<p>当 ViewModel 被清除时，资源会按照特定的顺序进行清理。<code>isCleared = true</code> 标志会在同步代码块之前设置，以防止并发的 <code>addCloseable</code> 调用添加会被遗漏的资源：</p>

<pre><code class="kotlin">@MainThread
fun clear() {
    if (isCleared) return

    isCleared = true
    synchronized(lock) {
        for (closeable in keyToCloseables.values) {
            closeWithRuntimeException(closeable)
        }
        for (closeable in closeables) {
            closeWithRuntimeException(closeable)
        }
        // Clear only resources without keys to prevent accidental recreation
        closeables.clear()
    }
}
</code></pre>

<p>匿名 <code>closeables</code> 集合会被清除，但 <code>keyToCloseables</code> 会被有意保留。这可以防止在清除后代码访问 <code>viewModelScope</code> 等资源时意外地重新创建它们。</p>

<h3>清除后保护</h3>

<p>在清除 ViewModel 后添加可关闭对象会立即将其关闭，从而防止在协程仍在运行时 ViewModel 被清除时出现资源泄漏：</p>

<pre><code class="kotlin">fun addCloseable(key: String, closeable: AutoCloseable) {
    if (isCleared) {
        closeWithRuntimeException(closeable)
        return
    }

    val oldCloseable = synchronized(lock) { keyToCloseables.put(key, closeable) }
    closeWithRuntimeException(oldCloseable)
}
</code></pre>

<p>此外，请注意，添加键值可关闭对象时，任何具有相同键值的现有可关闭对象都会自动关闭，从而支持替换模式。</p>

<h3>用于模拟的可空实现</h3>

<p>JVM 实现提供了一个可空的 <code>impl</code> 对象，以支持模拟框架。当你模拟 ViewModel 时，模拟对象不会调用真正的构造函数，因此 <code>impl</code> 对象永远不会被初始化。如果没有可空类型和安全调用（<code>impl?.clear()</code>），测试会因 <code>NullPointerException</code> 而崩溃：</p>

<pre><code class="kotlin">public actual abstract class ViewModel {
    private val impl: ViewModelImpl?

    public actual constructor() {
        impl = ViewModelImpl()
    }

    @MainThread
    internal actual fun clear() {
        impl?.clear()
        onCleared()
    }
}
</code></pre>

<h2>viewModelScope：协程集成</h2>

<p><code>viewModelScope</code> 扩展属性提供了一个生命周期感知的 <code>CoroutineScope</code>，当 ViewModel 被清除时，该作用域会自动取消：</p>

<pre><code class="kotlin">public val ViewModel.viewModelScope: CoroutineScope
    get() =
        synchronized(VIEW_MODEL_SCOPE_LOCK) {
            getCloseable(VIEW_MODEL_SCOPE_KEY)
                ?: createViewModelScope().also { scope -&gt;
                    addCloseable(VIEW_MODEL_SCOPE_KEY, scope)
                }
        }
</code></pre>

<h3>使用键控存储的延迟创建</h3>

<p>作用域在首次访问时延迟创建，并使用键控可关闭机制进行存储。键名故意设置得非常详细，以避免与用户自定义的键发生冲突：</p>

<pre><code class="kotlin">internal const val VIEW_MODEL_SCOPE_KEY =
    "androidx.lifecycle.viewmodel.internal.ViewModelCoroutineScope.JOB_KEY"
</code></pre>

<h3>CloseableCoroutineScope</h3>

<p>协程和可关闭系统之间的桥梁是 <code>CloseableCoroutineScope</code>，它同时实现了 <code>CoroutineScope</code> 和 <code>AutoCloseable</code> 接口。在 ViewModel 清空期间调用 <code>close()</code> 时，所有正在运行的协程都会被取消：</p>

<pre><code class="kotlin">internal class CloseableCoroutineScope(override val coroutineContext: CoroutineContext) :
    AutoCloseable, CoroutineScope {

    constructor(coroutineScope: CoroutineScope) : this(coroutineScope.coroutineContext)

    override fun close() = coroutineContext.cancel()
}
</code></pre>

<h3>平台感知调度器选择</h3>

<p>作为 Kotlin 多平台库，ViewModel 在没有主线程概念的平台上也能工作，因为它会回退到 <code>EmptyCoroutineContext</code>。请注意，这里使用的是 <code>Dispatchers.Main.immediate</code> 而不是 <code>Dispatchers.Main</code>，这样可以避免在已经在主线程上运行时进行不必要的重新调度：</p>

<pre><code class="kotlin">internal fun createViewModelScope(): CloseableCoroutineScope {
    val dispatcher =
        try {
            Dispatchers.Main.immediate
        } catch (_: NotImplementedError) {
            // In Native environments where `Dispatchers.Main` might not exist (e.g., Linux)
            EmptyCoroutineContext
        } catch (_: IllegalStateException) {
            // In JVM Desktop environments where `Dispatchers.Main` might not exist (e.g., Swing)
            EmptyCoroutineContext
        }
    return CloseableCoroutineScope(coroutineContext = dispatcher + SupervisorJob())
}
</code></pre>

<h3>SupervisorJob 实现子协程独立失败</h3>

<p>该作用域使用 <code>SupervisorJob()</code>，允许子协程独立失败。而使用普通的 <code>Job</code> 时，如果一个子协程失败，它会取消所有同级协程。这种设计符合 UI 应用程序的预期，即失败的网络请求不应该取消正在进行的数据库操作。</p>

<h2>ViewModelLazy：Kotlin 属性委托</h2>

<p><code>viewModels()</code> 委托使用了 <code>ViewModelLazy</code>：</p>

<pre><code class="kotlin">public class ViewModelLazy&lt;VM : ViewModel&gt;
@JvmOverloads
constructor(
    private val viewModelClass: KClass&lt;VM&gt;,
    private val storeProducer: () -&gt; ViewModelStore,
    private val factoryProducer: () -&gt; ViewModelProvider.Factory,
    private val extrasProducer: () -&gt; CreationExtras = { CreationExtras.Empty },
) : Lazy&lt;VM&gt; {
    private var cached: VM? = null

    override val value: VM
        get() {
            val viewModel = cached
            return if (viewModel == null) {
                val store = storeProducer()
                val factory = factoryProducer()
                val extras = extrasProducer()
                ViewModelProvider.create(store, factory, extras).get(viewModelClass).also {
                    cached = it
                }
            } else {
                viewModel
            }
        }

    override fun isInitialized(): Boolean = cached != null
}
</code></pre>

<h3>双重缓存架构</h3>

<p>惰性委托会在首次访问后将 ViewModel 引用缓存到本地。这是一种双重缓存模式：</p>

<ol>
<li><strong>ViewModelStore 缓存</strong>：规范缓存，不受配置更改的影响。</li>
<li><strong>ViewModelLazy 缓存</strong>：本地缓存，用于避免重复创建 ViewModelProvider。</li>
</ol>


<p>本地缓存是一种优化，创建 <code>ViewModelProvider</code> 并查找 ViewModel 的开销很小，但缓存可以避免后续访问中哪怕是这种微小的开销。</p>

<h3>用于延迟访问的 Lambda 生产者</h3>

<p>所有三个生产者（store、factory、extras）都是 Lambda 表达式，允许延迟求值：</p>

<pre><code class="kotlin">private val viewModel by viewModels { MyViewModelFactory() }
// Factory is only created when viewModel is first accessed
</code></pre>

<p>这对于 Fragment 尤其重要，因为在属性初始化期间 Activity 可能不可用。</p>

<h2>Android 特有：AGP 代码脱糖兼容性</h2>

<p>Android 有一个特殊的兼容层，用于处理混合使用针对不同 ViewModel 版本编译的库时出现的 AGP（Android Gradle 插件）代码脱糖问题：</p>

<pre><code class="kotlin">internal actual fun &lt;VM : ViewModel&gt; createViewModel(
    factory: ViewModelProvider.Factory,
    modelClass: KClass&lt;VM&gt;,
    extras: CreationExtras,
): VM {
    return try {
        factory.create(modelClass, extras)
    } catch (e: AbstractMethodError) {
        try {
            factory.create(modelClass.java, extras)
        } catch (e: AbstractMethodError) {
            factory.create(modelClass.java)
        }
    }
}
</code></pre>

<p>这一系列 try-catch 代码块用于处理使用旧版本 ViewModel 编译的工厂缺少较新版本的 <code>create</code> 方法的情况。当运行时调用编译后的字节码中不存在的方法时，就会出现 <code>AbstractMethodError</code> 错误，这种情况通常发生在旧工厂只有 <code>create(Class&lt;T&gt;)</code> 方法，而运行时需要 <code>create(Class&lt;T&gt;, CreationExtras)</code> 方法时。这种防御性级联机制能够优雅地降级到方法变体，确保 ViewModel 创建功能不受库版本不匹配的影响。</p>

<h2>性能特性和设计权衡</h2>

<p>ViewModel 系统在设计上做出了一些权衡，以平衡正确性、灵活性和性能。</p>

<h3>同步开销</h3>

<p><code>ViewModelProviderImpl</code> 和 <code>ViewModelImpl</code> 都使用同步块来实现线程安全访问：</p>

<pre><code class="kotlin">synchronized(lock) {
    val viewModel = store[key]
    // ...
}
</code></pre>

<p>由于 ViewModel 访问通常发生在主线程上，临界区很短（简单的 map 操作），并且锁争用很少发生，因此这种同步开销非常小。该设计优先考虑正确性而非微优化，因为罕见的竞态条件代价远高于几乎察觉不到的同步开销。</p>

<h3>反射开销</h3>

<p><code>NewInstanceFactory</code> 使用 Java 反射来动态实例化 ViewModel 类：</p>

<pre><code class="kotlin">modelClass.getDeclaredConstructor().newInstance()
</code></pre>

<p>由于运行时类型检查和动态方法解析，反射比直接构造函数调用要慢。但是，这种开销可以忽略不计，因为 ViewModel 的创建频率很低（每个生命周期一次），而且无需编译时信息即可实例化任何 ViewModel 子类的灵活性远远超过了这点微小的开销。</p>

<h3>基于映射的存储</h3>

<p>使用 <code>MutableMap</code> 作为 ViewModelStore 可以提供 O(1) 的查找时间，但清除操作的时间复杂度为 O(n)，因为每个 ViewModel 都必须单独清除：</p>

<pre><code class="kotlin">public fun clear() {
    for (vm in map.values) {
        vm.clear()
    }
    map.clear()
}
</code></pre>

<p>由于 ViewModelStore 通常只包含 1-5 个 ViewModel，因此线性时间的清除操作实际上并无影响。使用标准 HashMap 的简洁性使得代码更易于理解和维护，对于这种有限的用例而言，其价值远大于理论上的优化。</p>

<h3>用于模拟的可空实现</h3>

<p>JVM ViewModel 中的可空 <code>impl</code> 会在每个操作中添加空值检查：</p>

<pre><code class="kotlin">impl?.clear()
</code></pre>

<p>这种微小的开销可以实现正确的模拟行为。当模拟框架创建 ViewModel 模拟对象时，它们会绕过真正的构造函数，导致 <code>impl</code> 未初始化。可空类型可以防止测试中出现 <code>NullPointerException</code>，这是一个值得的权衡。</p>

<h2>实际应用模式：理解 ViewModel 的使用</h2>

<p>理解其内部机制有助于你在实际应用中识别模式和反模式。</p>

<h3>模式 1：作用域 ViewModel 共享</h3>

<p>可以使用 Activity 的 ViewModelStore 而不是每个 Fragment 自己的存储来在 Fragment 之间共享 ViewModel：</p>

<pre><code class="kotlin">class FragmentA : Fragment() {
    private val sharedViewModel: SharedViewModel by activityViewModels()
}

class FragmentB : Fragment() {
    private val sharedViewModel: SharedViewModel by activityViewModels()
}
</code></pre>

<p>两个 Fragment 会获得相同的 ViewModel 实例，因为它们使用相同的 ViewModelStore（Activity 的）。这使得兄弟 Fragment 可以通过共享状态进行通信。内部机制：</p>

<pre><code class="kotlin">// activityViewModels() uses:
ViewModelProvider(
    store = requireActivity().viewModelStore,  // Same store for both fragments
    factory = ...,
)
</code></pre>

<h3>模式 2：自定义键用于多个实例</h3>

<p>你可以通过提供自定义键来拥有同一个 ViewModel 类的多个实例：</p>

<pre><code class="kotlin">val viewModel1: MyViewModel = viewModelProvider["user_1", MyViewModel::class]
val viewModel2: MyViewModel = viewModelProvider["user_2", MyViewModel::class]
</code></pre>

<p>该键包含自定义字符串，从而在 ViewModelStore 中创建单独的缓存条目。这对于同时管理多个用户配置文件或聊天对话等场景非常有用。</p>

<h3>模式 3：使用 CreationExtras 进行工厂注入</h3>

<p>现代工厂是无状态的，在创建时通过 CreationExtras 接收所有依赖项：</p>

<pre><code class="kotlin">class MyViewModelFactory : ViewModelProvider.Factory {
    override fun &lt;T : ViewModel&gt; create(modelClass: KClass&lt;T&gt;, extras: CreationExtras): T {
        val repository = extras[REPOSITORY_KEY]!!
        val userId = extras[USER_ID_KEY]!!
        return MyViewModel(repository, userId) as T
    }
}
</code></pre>

<p>这使得工厂可以作为单例，同时每次调用配置都不同，从而避免为每个具有不同依赖项的 ViewModel 创建新的工厂实例。</p>

<h3>反模式：在 ViewModel 中访问 Context</h3>

<pre><code class="kotlin">// Bad: Leaks Activity context
class MyViewModel(private val context: Context) : ViewModel()

// Good: Use Application context via AndroidViewModel
class MyViewModel(application: Application) : AndroidViewModel(application)

// Better: Don't hold Context at all, pass it to methods
class MyViewModel : ViewModel() {
    fun loadData(context: Context) { ... }
}
</code></pre>

<p>第一种方法可能会导致 Activity 泄漏，因为 ViewModel 在持有已销毁 Activity 的引用时，配置更改仍然存在。请使用 <code>AndroidViewModel</code> 来获取 Application 上下文，或者在需要时将 Context 传递给各个方法。</p>

<h3>反模式：在 onCleared 中阻塞</h3>

<p>你知道 <code>onCleared()</code> 是在主线程上调用的吗？诸如网络关闭或数据库清理之类的阻塞操作应该使用协程的 <code>addCloseable</code> 方法卸载到后台线程：</p>

<pre><code class="kotlin">// Bad: Blocking call in onCleared
override fun onCleared() {
    networkClient.shutdown()  // May block the main thread until completing the shutdown process!
}

// Good: Use addCloseable for managed cleanup
init {
    addCloseable {
        scope.launch { networkClient.shutdown() }
    }
}
</code></pre>

<h2>结论</h2>

<p>Jetpack ViewModel 的内部机制展现了一个精心设计的生命周期感知状态管理系统。ViewModelStore 通过保留映射提供简单而有效的缓存，而 ViewModelProvider 则通过线程安全的访问和灵活的工厂支持来协调创建过程。CreationExtras 通过外部化配置来实现无状态工厂，而 AutoCloseable 集成则确保了资源的正确清理。</p>

<p>多平台架构将通用逻辑提取到内部实现类中，使该库能够支持 JVM、Android、iOS 和其他平台。viewModelScope 集成通过 closeable 机制提供自动协程取消功能，并为没有主线程的环境提供平台感知的调度器选择。</p>

<p>如果你想掌握最新的技能、新闻、技术文章、面试题和实用代码技巧，请查看<a href="https://github.com/doveletter/">Dove Letter</a>。想要更深入地了解面试准备，千万不要错过终极 Android 面试指南：<a href="https://www.android.skydoves.me/">Manifest Android Interview</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用CameraX 1.5进行高速拍摄和慢动作视频拍摄]]></title>
    <link href="https://alexhilton.github.io/blog/2025/11/05/camerax-slow-motion/"/>
    <updated>2025-11-05T13:59:12+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/11/05/camerax-slow-motion</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「High-Speed Capture and Slow-Motion Video with CameraX 1.5」，原文链接<a href="https://android-developers.googleblog.com/2025/10/high-speed-capture-and-slow-motion.html">https://android-developers.googleblog.com/2025/10/high-speed-capture-and-slow-motion.html</a>，由Leo Huang发布于2025年10月28日。</p></blockquote>

<p><a href=""><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhSMEQNJHjQybdOLzAewkopnpZ6OUC0jYiXboj3chVWnaFbKtD5bPA4azyqjM7_ffdGv_nBnvYUgoqvhISE7-lff-aGkF8f200ENGHF9" title="auto auto" ></a></p>

<!-- more -->


<p>清晰捕捉快速运动的画面是现代相机应用的关键特性。这可以通过高速拍摄来实现——即以 120 或 240 fps 等速率采集帧。这种高保真拍摄可用于两种截然不同的用途：创建高帧率视频以进行逐帧的详细分析，或生成慢动作视频，使动作在屏幕上呈现出戏剧性的展开效果。</p>

<p>以前，使用 Camera2 API 实现这些功能需要更多的人工操作。现在，CameraX 1.5 中新增的<a href="https://developer.android.com/reference/androidx/camera/video/HighSpeedVideoSessionConfig">高速 API</a>简化了整个流程，让你可以灵活地创建真正的高帧率视频或即用型慢动作短片。本文将向你展示如何掌握这两种方法。如果你是 CameraX 新手，可以先阅读<a href="https://developer.android.com/media/camera/camerax">CameraX 概述</a>快速上手。</p>

<h2>慢动作原理</h2>

<p>慢动作的基本原理是以远高于播放帧率的帧率来录制视频。例如，如果你以每秒 120 帧 (fps) 的帧率录制一个一秒钟的事件，然后以标准的 30 fps 播放该录像，则视频需要四秒钟才能播放完毕。这种时间的“拉伸”正是慢动作效果的来源，让你能够看到肉眼无法捕捉到的快速细节。</p>

<p>为确保最终输出视频流畅自然，通常应以至少 30 fps 的帧率进行渲染。这意味着，要制作 4 倍慢动作视频，原始拍摄帧率必须至少为 120 fps（120 fps 拍摄帧率 ÷ 4 = 30 fps 播放帧率）。</p>

<p>拍摄高帧率素材后，主要有两种方法可以实现所需效果：</p>

<ul>
<li><p>播放器控制的慢动作（高帧率视频）：高速录制的视频（例如 120 fps）直接保存为高帧率视频文件。然后，视频播放器负责降低播放速度。这样，用户可以灵活地在正常播放和慢动作播放之间切换。</p></li>
<li><p>即用型慢动作（重新编码的视频）：高速视频流经过处理和重新编码，生成标准帧率（例如 30 fps）的文件。慢动作效果是通过调整帧时间戳“嵌入”到视频中的。生成的视频无需特殊处理即可在任何标准视频播放器中以慢动作播放。虽然视频默认以慢动作播放，但视频播放器仍然可以提供播放速度控制，允许用户加快播放速度并以原始速度观看视频。</p></li>
</ul>


<p>CameraX API 简化了这一过程，为你提供了一种统一的方式来选择所需的播放方式，如下所示。</p>

<h2>全新高速视频 API</h2>

<p>全新的 CameraX 解决方案基于两个主要组件：</p>

<ul>
<li><p><a href="https://developer.android.com/reference/kotlin/androidx/camera/video/Recorder#getHighSpeedVideoCapabilities(androidx.camera.core.CameraInfo)">Recorder#getHighSpeedVideoCapabilities(CameraInfo)</a>: 此方法用于检查摄像头是否支持高速录制，如果支持，则可查看支持哪些分辨率（Quality 对象）。</p></li>
<li><p><a href="https://developer.android.com/reference/androidx/camera/video/HighSpeedVideoSessionConfig">HighSpeedVideoSessionConfig</a>: 这是一个特殊的配置对象，用于将你的 VideoCapture 和 Preview 使用场景分组，并指示 CameraX 创建一个统一的高速摄像头会话。请注意，虽然 VideoCapture 流将以配置的高帧率运行，但为了确保屏幕流畅显示，预览流通常会被摄像头系统限制在至少 30 FPS 的标准帧率。</p></li>
</ul>


<h2>入门指南</h2>

<p>开始之前，请确保已将必要的 CameraX 依赖项添加到应用程序的 build.gradle.kts 文件中。你需要 camera-video 组件以及 CameraX 核心库。</p>

<pre><code class="kotlin">// build.gradle.kts (Module: app)


dependencies {

    val camerax_version = "1.5.1"


    implementation("androidx.camera:camera-core:$camerax_version")

    implementation("androidx.camera:camera-camera2:$camerax_version")

    implementation("androidx.camera:camera-lifecycle:$camerax_version")

    implementation("androidx.camera:camera-video:$camerax_version")

    implementation("androidx.camera:camera-view:$camerax_version")

}
</code></pre>

<h3>关于实验性 API 的说明</h3>

<p>需要注意的是，高速录制 API 目前处于实验阶段。这意味着它们在未来的版本中可能会发生变化。要使用它们，你必须通过在代码中添加以下注释来启用它们：</p>

<pre><code class="kotlin">@kotlin.OptIn(ExperimentalSessionConfig::class, ExperimentalHighSpeedVideo::class)
</code></pre>

<h2>具体实现</h2>

<p>两种结果的实现都从相同的设置步骤开始。创建高帧率视频还是慢动作视频的选择取决于一个设置。</p>

<h3>1.设置高速拍摄</h3>

<p>首先，无论你的目标是什么，你都需要获取 <a href="https://developer.android.com/reference/androidx/camera/lifecycle/ProcessCameraProvider">ProcessCameraProvider</a>，检查设备功能，并创建你的使用场景。</p>

<p>以下代码块展示了在挂起函数中的完整设置流程。你可以从协程作用域调用此函数，例如 <code>lifecycleScope.launch</code>。</p>

<pre><code class="kotlin">// Add the OptIn annotation at the top of your function or class

@kotlin.OptIn(ExperimentalSessionConfig::class, ExperimentalHighSpeedVideo::class)

private suspend fun setupCamera() {

    // Asynchronously get the CameraProvider

    val cameraProvider = ProcessCameraProvider.awaitInstance(this)


    // -- CHECK CAPABILITIES --

    val cameraInfo = cameraProvider.getCameraInfo(CameraSelector.DEFAULT_BACK_CAMERA)

    val videoCapabilities = Recorder.getHighSpeedVideoCapabilities(cameraInfo)

    if (videoCapabilities == null) {

        // This camera device does not support high-speed video.

        return

    }


    // -- CREATE USE CASES --

    val preview = Preview.Builder().build()    


    // You can create a Recorder with default settings.

    // CameraX will automatically select a suitable quality.

    val recorder = Recorder.Builder().build()


    // Alternatively, to use a specific resolution, you can configure the
    // Recorder with a QualitySelector. This is useful if your app has
    // specific resolution requirements or you want to offer user
    // preferences. 

    // To use a specific quality, you can uncomment the following lines.

    // Get the list of qualities supported for high-speed video. 

    // val supportedQualities = videoCapabilities.getSupportedQualities(DynamicRange.SDR)

    // Build the Recorder using the quality from the supported list.

    // val recorderWithQuality = Recorder.Builder()

    //     .setQualitySelector(QualitySelector.from(supportedQualities.first()))

    //     .build()


    // Create the VideoCapture use case, using either recorder or recorderWithQuality

    val videoCapture = VideoCapture.withOutput(recorder)

    // Now you are ready to configure the session for your desired output...

}
</code></pre>

<h3>2. 选择输出</h3>

<p>现在，你需要决定要创建哪种类型的视频。此代码将在上面所示的 <code>setupCamera()suspend</code> 函数中运行。</p>

<h4>选项 A：创建高帧率视频</h4>

<p>如果你希望最终文件具有高帧率（例如，120fps 的视频），请选择此选项。</p>

<pre><code class="kotlin">// Create a builder for the high-speed session

val sessionConfigBuilder = HighSpeedVideoSessionConfig.Builder(videoCapture)

    .setPreview(preview)


// Query and apply a supported frame rate. Common supported frame rates include 120 and 240 fps.

val supportedFrameRateRanges =

    cameraInfo.getSupportedFrameRateRanges(sessionConfigBuilder.build())


sessionConfigBuilder.setFrameRateRange(supportedFrameRateRanges.first())
</code></pre>

<h4>选项 B：创建可直接播放的慢动作视频</h4>

<p>如果你希望视频在任何标准视频播放器中自动以慢动作播放，请选择此选项。</p>

<pre><code class="kotlin">// Create a builder for the high-speed session

val sessionConfigBuilder = HighSpeedVideoSessionConfig.Builder(videoCapture)

    .setPreview(preview)


// This is the key: enable automatic slow-motion!

sessionConfigBuilder.setSlowMotionEnabled(true)


// Query and apply a supported frame rate. Common supported frame rates include 120, 240, and 480 fps.

val supportedFrameRateRanges =

   cameraInfo.getSupportedFrameRateRanges(sessionConfigBuilder.build())

sessionConfigBuilder.setFrameRateRange(supportedFrameRateRanges.first())
</code></pre>

<p>这个标志位是创建可直接播放的慢动作视频的关键。当 <code>setSlowMotionEnabled</code> 设置为 true 时，CameraX 会处理高速视频流并将其保存为标准的 30 fps 视频文件。慢动作播放速度由拍摄帧速率与标准播放速率的比值决定。</p>

<p>例如：</p>

<ul>
<li><p>以 120 fps 录制的视频将以 &frac14; 倍速播放 (120 ÷ 30 = 4)。</p></li>
<li><p>以 240 fps 录制的视频将以 1/8 倍速播放 (240 ÷ 30 = 8)。</p></li>
</ul>


<h2>整合所有步骤：录制视频</h2>

<p>配置好 HighSpeedVideoSessionConfig 并将其绑定到生命周期后，最后一步就是开始录制。准备输出选项、开始录制和处理视频事件的过程与标准视频捕获相同。</p>

<p>本文重点介绍高速配置，因此不会详细介绍录制过程。如需了解从准备 FileOutputOptions 或 MediaStoreOutputOptions 对象到处理 VideoRecordEvent 回调的完整指南，请参阅<a href="https://developer.android.com/media/camera/camerax/video-capture#videocapture-api-overview">VideoCapture 文档</a>。</p>

<pre><code class="kotlin">// Bind the session config to the lifecycle

cameraProvider.bindToLifecycle(

    this as LifecycleOwner,

    CameraSelector.DEFAULT_BACK_CAMERA,

    sessionConfigBuilder.build() // Bind the config object from Option A or B

)


// Start the recording using the VideoCapture use case

val recording = videoCapture.output

    .prepareRecording(context, outputOptions) // See docs for creating outputOptions

    .start(ContextCompat.getMainExecutor(context)) { recordEvent -&gt;

        // Handle recording events (e.g., Start, Pause, Finalize)

    }
</code></pre>

<h2>Google Photos 对慢动作视频的支持</h2>

<p>在 CameraX 中启用 setSlowMotionEnabled(true) 后，生成的视频文件将被设计为可在标准视频播放器和图库应用中立即识别并播放为慢动作视频。谷歌相册尤其针对慢动作视频提供了增强功能，当拍摄帧速率为 120、240、360、480 或 960fps 时，功能更加完善：</p>

<ul>
<li>缩略图中的独特 UI 识别：在谷歌相册中，慢动作视频会通过特定的 UI 元素进行识别，从而与普通视频区分开来。</li>
</ul>


<p><img src="https://blogger.googleusercontent.com/img/a/AVvXsEjPLQRSSF3hvj89T9DvO92-JNi_rjtUXQ-i76ZuyX4GHv4KitBFPVP5oHdqxICQJUf3l7HaOQeI0skgVK9bPM0qz7GToNYiIMszVYj6IsE4-wGa4jqZfYka03TTlFwUTDdYq56unwoIwv1fTnJrNpWIZ-5Iybgk-hFHlvcy08Bkm8xM0adbvYjqVxH12xc" alt="普通视频缩略图" /></p>

<p><img src="https://blogger.googleusercontent.com/img/a/AVvXsEiDmd0jikxU58PkjrGG1K181pYs-G-drnrNG_q_mQqVJWkK4NdbuwDSB4jCbQzGAgYeyikORVsPT3pyQp_VCfw_7rNDzafFudhj0x56-bqNZc6mQuRktDCa7ycSx2-qsIJsCCTiQXmxxrtImiBOFwlTz3ufBtbGDsonZvqzSQqWbNugNt-bbDVvyQz7Hw8" alt="慢动作视频缩略图" /></p>

<ul>
<li>播放时可调整速度：播放慢动作视频时，Google Photos 提供控制选项，允许用户调整视频中哪些部分以慢速播放，哪些部分以正常速度播放，从而赋予用户更大的创作自由。编辑后的视频可以使用“分享”按钮导出为新的视频文件，同时保留你定义的慢动作片段。</li>
</ul>


<p><img src="https://blogger.googleusercontent.com/img/a/AVvXsEj-dp-bHPORhk_l0I4zkSEdzYUNRYvRwb2boA4KKgd1s4Sr1D61iAV2rWUD6dOdVezRn10qIGtMLae4brWI8RxlP9wFz18gsrZu4qOdAydWnhqgpmmsuLcHAMfo5Rv6XZIxtTCC5dSJeIJERbOKmPZyUXTOdweJ6EjQett5iOVl4yJzaLYR7rrHXz0WnAI" alt="正常视频播放" /></p>

<p><img src="https://blogger.googleusercontent.com/img/a/AVvXsEi4AaVc78zpZzsG-hgOsuPdAqwCuSD6bb1b6de366Agvy2c3OG5qJ5mSPg94GA8GjR-LXDU4H7zBCoI_Pe3SxrfdDPiTyPmimTRM49IcTkGovC2mccTu0GnwcSyVAL5iW7qnNlWHGCoGHU9EeX3-8bZiSsmLWr6Ljf5KfJjInUuCEODrqF-g8Je3iLvEF4" alt="慢动作视频播放（带编辑控制）" /></p>

<h2>关于设备支持的说明</h2>

<p>CameraX 的高速 API 依赖于底层 Android 的 <a href="https://developer.android.com/reference/android/media/CamcorderProfile">CamcorderProfile</a> 系统来确定设备支持的高速分辨率和帧速率。CamcorderProfile 经过 <a href="https://source.android.com/docs/compatibility/cts">Android 兼容性测试套件 (CTS)</a> 的验证，这意味着你可以信赖设备所报告的视频录制功能。</p>

<p>这意味着，设备内置相机应用能够录制慢动作视频并不能保证 CameraX 高速 API 能够正常工作。出现这种差异的原因是，设备制造商负责在其设备固件中填充 CamcorderProfile 条目，而有时必要的高速配置文件（例如 CamcorderProfile.QUALITY_HIGH_SPEED_1080P 和 CamcorderProfile.QUALITY_HIGH_SPEED_720P）可能并未包含在内。当缺少这些配置文件时，<code>Recorder.getHighSpeedVideoCapabilities()</code> 将返回 null。</p>

<p>因此，务必始终使用 <code>Recorder.getHighSpeedVideoCapabilities()</code> 以编程方式检查支持的功能，因为这是确保在不同设备上获得一致体验的最可靠方法。如果尝试在 <code>Recorder.getHighSpeedVideoCapabilities()</code> 返回 null 的设备上绑定 <code>HighSpeedVideoSessionConfig</code>，则操作将失败并抛出 <code>IllegalArgumentException</code> 异常。你可以在 Google Pixel 设备上确认支持，因为它们始终包含这些高速配置文件。此外，其他制造商的各种设备，例如 Motorola Edge 30、OPPO Find N2 Flip 和 Sony Xperia 1 V，也支持高速视频功能。</p>

<h2>结论</h2>

<p>CameraX 高速视频 API 功能强大且灵活。无论你是需要用于技术分析的真正高帧率视频素材，还是想为你的应用添加电影级的慢动作效果，HighSpeedVideoSessionConfig 都能提供统一且简便的解决方案。通过了解 setSlowMotionEnabled 标志的作用，你可以轻松支持这两种使用场景，并赋予用户更大的创作自由。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[突破速度障碍：非阻塞启动画面如何将Android 应用启动时间缩短90%]]></title>
    <link href="https://alexhilton.github.io/blog/2025/10/14/non-blocking-splash/"/>
    <updated>2025-10-14T14:41:32+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/10/14/non-blocking-splash</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Breaking the Speed Barrier: How Non-Blocking Splash Screens Cut Android App Launch Time by 90%」，原文链接<a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90">https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90</a>，由Sankalp Chauhan发布于2025年9月28日。</p></blockquote>

<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#overview">概述</a></h2>

<p>正值佳节期间，我们在每个应用上都能看到精美的启动画面和自定义徽标。在开发这些应用时，每个 Android 开发者都会面临启动画面的困境：用户期望获得美观且品牌化的启动体验，但 Google 原生的启动画面 API 却存在明显的局限性。创建自定义 <strong>SplashActivity</strong> 的常见解决方案看似合理，但却会引入隐藏的性能损失，导致应用运行缓慢且响应迟钝。</p>

<p><a href=""><img src="https://sankalpchauhan.com/2db6f13d4b8881938f2fccacd47ff90b/untitled-design-1-.mp4.gif" title="auto auto" ></a></p>

<!-- more -->


<p>为了应对这一挑战，我开发了一个名为<strong>EventSplash</strong>的测试库，该库实现了一种非阻塞启动画面方法。完整的实现和基准测试代码可在 GitHub 上获取：<a href="https://github.com/sankalpchauhan-me/fast-splash-experiment">fast-splash-experiment</a>（链接：<a href="https://github.com/sankalpchauhan-me/fast-splash-experiment%EF%BC%89%E3%80%82">https://github.com/sankalpchauhan-me/fast-splash-experiment%EF%BC%89%E3%80%82</a></p>

<p>本案例研究通过一项对照实验，比较了传统的基于活动的启动画面和创新的基于视图的启动画面方法，并提供了实证证据。使用<strong>保守的同类比较</strong>，结果显示：<strong>页面加载时间缩短 90%</strong>，<strong>首次内容绘制时间提升 78%</strong>，<strong>完全绘制时间缩短 41%</strong>。</p>

<p>我们将探索 Lottie 等复杂动画可能带来的显著优势，同时明确并发处理的利弊权衡和资源成本。</p>

<ul>
<li><strong>首次内容绘制 (FCP)</strong>：屏幕上出现第一个有意义内容的时间</li>
<li><strong>完全绘制时间 (FPT)</strong>：屏幕完全渲染并可交互的时间</li>
<li><strong>冷启动</strong>：应用在进程未运行时启动（性能影响最大）</li>
<li><strong>卡顿</strong>：用户认为性能不佳的卡顿或掉帧</li>
<li><strong>TTID/TTFD</strong>：初始显示时间/完全绘制时间（Android 官方指标）</li>
<li><strong>内存压力</strong>：可用内存极低时的系统状态</li>
<li><strong>低内存终止程序 (LMK)</strong>：在内存压力下终止进程的 Android 守护进程</li>
<li><strong>Choreographer.doFrame</strong>：Android 的帧协调系统，用于管理动画、输入和绘制</li>
</ul>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#the-problem-statement">问题声明</a></h3>

<p>Google 原生的 Android 12+ SplashScreen API 性能出色，但自定义选项有限 <a href="https://developer.android.com/develop/ui/views/launch/splash-screen">[1]</a>。它不支持：</p>

<ul>
<li>视频背景</li>
<li>Lottie 动画</li>
<li>复杂的品牌元素</li>
<li>促销/活动期间的促销内容</li>
<li>自定义过渡效果</li>
</ul>


<p>这迫使开发者不得不进行自定义实现，通常使用专用的“SplashActivity”。虽然这种方法提供了创作自由，但它会创建一个<strong>阻塞序列</strong>，从而延迟应用主内容的显示。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#why-traditional-splash-activities-hurt-performance">为什么传统的闪屏活动会损害性能</a></h3>

<p>Android 文档强调，应用应该针对冷启动进行优化，因为这“也可以提高温启动和热启动的性能”<a href="https://developer.android.com/topic/performance/vitals/launch-time">[2]</a>。然而，传统的闪屏实现方式违背了这一原则。</p>

<p>当你使用单独的“SplashActivity”时，系统必须：</p>

<ol>
<li>创建并初始化启动画面 Activity</li>
<li>扩展启动画面视图</li>
<li>运行启动画面动画直至完成</li>
<li>销毁启动画面 Activity</li>
<li>创建并初始化主 Activity</li>
<li>扩展主内容视图</li>
</ol>


<p>这种顺序流程意味着你的主内容在启动画面完成之前无法开始加载，这是一个影响用户感知性能的根本架构缺陷。</p>

<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#the-journey-exploring-different-approaches">折腾：探索不同的方法</a></h2>

<p>在最终确定 EventSplash 实现方案之前，我探索了几种方法。了解这些探索为最终的设计决策提供了宝贵的背景，并展示了性能优化的迭代本质。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#discarded-approach-the-translucent-activity-overlay">弃用的方法：半透明 Activity 覆盖</a></h3>

<p>最初的想法是使用带有半透明主题的“SplashActivity”覆盖“MainActivity”。理论上，MainActivity 可以在后台加载，而启动画面则显示在最上面。</p>

<p><strong>启动顺序：</strong></p>

<ol>
<li>应用以具有半透明主题的 SplashActivity 启动</li>
<li>SplashActivity 显示在 MainActivity 之上，但不会完全遮挡 MainActivity</li>
<li>短暂延迟或初始化完成后，SplashActivity 结束，MainActivity 显露出来</li>
</ol>


<p><strong>弃用原因：</strong></p>

<p>这种方法导致<strong>14% 的性能下降</strong>。问题在于 Android 处理 Activity 生命周期和渲染的方式。系统并非真正并行启动两个 Activity。相反，它创建了一种顺序依赖关系，GPU 被迫组合两个独立的 Activity 缓冲区，这会在 RAM 和电池方面造成巨大的开销，有时甚至会禁用窗口过渡动画。</p>

<p>正如 Android 文档中关于半透明 Activity 的说明 <a href="https://medium.com/androiddevelopers/the-android-lifecycle-cheat-sheet-part-iv-49946659b094">[3]</a>：</p>

<blockquote><p>“窗口管理器会保持原先的屏幕表面按 Z 轴顺序排列，并将新的屏幕表面混合在其上方。原先的 Activity 仍然可以通过新窗口中任何透明或部分透明的像素看到。”</p></blockquote>

<p>正是这种混合操作导致了性能下降。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#the-winning-approach-the-gated-splash-screen-mechanism">制胜之道：门控启动画面机制</a></h3>

<p>我最终找到了一种更复杂的方法，它采用了<strong>门控启动画面机制</strong>。此方法使用“ViewTreeObserver.OnPreDrawListener”来阻止所有 UI 渲染，直到满足特定条件为止。</p>

<p><strong>工作原理：</strong></p>

<ol>
<li>启动时，会立即将 <code>OnPreDrawListener</code> 附加到 Activity 的 <code>decorView</code> 上。</li>
<li>监听器的 <code>onPreDraw()</code> 方法返回 <code>false</code>，从而有效阻止所有绘制操作。</li>
<li>监听器仅在所有条件都满足时才返回 <code>true</code>，允许内容渲染。</li>
</ol>


<p><strong>关键实现：</strong></p>

<pre><code class="kotlin">// The gate mechanism

gate.onPreDraw() → returns false = BLOCK all drawing

gate.onPreDraw() → returns true = ALLOW drawing to proceed
</code></pre>

<p>这种方法完全符合 Android 官方文档中关于延长启动画面在屏幕上停留时间的建议 <a href="https://developer.android.com/develop/ui/views/launch/splash-screen">[1]</a>:</p>

<blockquote><p>“如果你需要加载少量数据，例如从本地磁盘异步加载应用内设置，可以使用 ViewTreeObserver.OnPreDrawListener 暂停应用以绘制其第一帧。”</p></blockquote>

<p>EventSplash 库扩展了这一概念，在应用启动时提供对用户可见内容的帧完美控制，防止任何内容闪烁，确保无缝体验。</p>

<p><img src="https://sankalpchauhan.com/static/6810168ee26fb4ae7c236e03fbdd71bc/e5715/view-hirearchy.png" alt="DecorView 将包含我们的 SplashView 和 ContentView" /></p>

<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#the-experiment-measuring-real-world-impact">实验：测量实际影响</a></h2>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#test-environment">测试环境</a></h3>

<ul>
<li><strong>设备</strong>：小米 POCO F1，Android 10</li>
<li><strong>构建</strong>：发布配置</li>
<li><strong>方法</strong>：每个配置 35 次冷启动，每次运行之间暂停 2 秒</li>
<li><strong>指标</strong>：自定义 PerfTracker 库，用于测量页面加载时间、FCP 和 FPT</li>
<li><strong>脚本</strong>：通过 <code>perf_loop.sh</code> 自动执行可重复性</li>
</ul>


<p>所有测试代码和脚本均可在 <a href="https://github.com/sankalpchauhan-me/fast-splash-experiment">GitHub 代码库</a> （链接：<a href="https://github.com/sankalpchauhan-me/fast-splash-experiment%EF%BC%89%E8%8E%B7%E5%8F%96%EF%BC%8C%E4%BB%A5%E7%A1%AE%E4%BF%9D%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7%E3%80%82">https://github.com/sankalpchauhan-me/fast-splash-experiment%EF%BC%89%E8%8E%B7%E5%8F%96%EF%BC%8C%E4%BB%A5%E7%A1%AE%E4%BF%9D%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7%E3%80%82</a></p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#implementation-approaches-tested">测试的实现方法</a></h3>

<ol>
<li><strong>默认阻塞闪屏</strong>：简单的 <code>SplashActivity</code> 和基本路由（保守的基准）</li>
<li><strong>默认非阻塞闪屏</strong>：EventSplash 库和简单的叠加层</li>
<li><strong>Lottie 阻塞闪屏</strong>：传统方法和复杂的动画</li>
<li><strong>Lottie 非阻塞闪屏</strong>：EventSplash 与 Lottie 动画并行运行</li>
</ol>


<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#results-conservative-claims-with-dramatic-potential">结果：保守的声明，但效果显著潜力</a></h2>

<p><img src="https://sankalpchauhan.com/static/b4c51a8a6d8ebb0f3f12161c0441e89d/e5715/performance_comparison.png" alt="性能对比" /></p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#the-honest-comparison-default-splash-performance">真实对比：默认闪屏性能</a></h3>

<p>为了进行<strong>同类比较</strong>，我们重点关注在默认的闪屏实现中，阻塞方法只是简单地为了路由目的而扩大 Activity：</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 方法 </th>
<th style="text-align:center;"> 页面加载时间 (毫秒) </th>
<th style="text-align:center;"> FCP (毫秒) </th>
<th style="text-align:center;"> FPT (毫秒) </th>
<th style="text-align:center;"> 用户影响 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> <strong>默认阻塞</strong> </td>
<td style="text-align:center;"> 366 </td>
<td style="text-align:center;"> 744 </td>
<td style="text-align:center;"> 2,195 </td>
<td style="text-align:center;"> 明显的延迟 </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>默认非阻塞</strong> </td>
<td style="text-align:center;"> 37 </td>
<td style="text-align:center;"> 164 </td>
<td style="text-align:center;"> 1,295 </td>
<td style="text-align:center;"> 流畅、响应迅速 </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>提升</strong> </td>
<td style="text-align:center;"> <strong>90%</strong> </td>
<td style="text-align:center;"> <strong>78%</strong> </td>
<td style="text-align:center;"> <strong>41%</strong> </td>
<td style="text-align:center;"> <strong>显著提升</strong> </td>
</tr>
</tbody>
</table>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#the-lottie-animation-advantage">Lottie 动画的优势</a></h3>

<p>当我们引入复杂的 Lottie 动画时，架构上的差异会更加明显发音：</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 方法 </th>
<th style="text-align:center;"> 页面加载时间 (毫秒) </th>
<th style="text-align:center;"> FCP (毫秒) </th>
<th style="text-align:center;"> FPT (毫秒) </th>
<th style="text-align:center;"> 备注 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> <strong>Lottie 阻塞</strong> </td>
<td style="text-align:center;"> 2,228 </td>
<td style="text-align:center;"> 2,347 </td>
<td style="text-align:center;"> 3,524 </td>
<td style="text-align:center;"> <em>包含动画时长</em> </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>Lottie 非阻塞</strong> </td>
<td style="text-align:center;"> 109 </td>
<td style="text-align:center;"> 312 </td>
<td style="text-align:center;"> 1,467 </td>
<td style="text-align:center;"> <em>动画并行运行</em> </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>提升</strong> </td>
<td style="text-align:center;"> <strong>95%</strong> </td>
<td style="text-align:center;"> <strong>87%</strong> </td>
<td style="text-align:center;"> <strong>58%</strong> </td>
<td style="text-align:center;"> <strong>显著提升</strong> </td>
</tr>
</tbody>
</table>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#understanding-the-lottie-numbers">理解 Lottie 数值</a></h3>

<p><strong>重要提示</strong>：Lottie 阻塞数值在设计上包含动画时长，用户必须等待整个动画完成后才能看到任何主要内容。在非阻塞方法中，<strong>动画和内容加载并行运行</strong>，因此当 Lottie 动画完成时，FPT 通常已经完成或接近完成。</p>

<p>这种并行执行是其关键的架构优势：<strong>无需牺牲性能即可获得精美的动画</strong>。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#performance-improvements-breakdown">性能改进细分</a></h3>

<p><img src="https://sankalpchauhan.com/static/620f7ce36b7f1d75840820adb257fa7f/e5715/improvement_chart.png" alt="改进图表" />
改进图表</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#recap-what-happened">回顾：发生了什么</a></h3>

<p>即使与保守的默认启动画面相比，非阻塞方法也实现了<strong>90% 的页面加载速度提升次</strong>。用户体验从“明显的延迟”转变为“流畅且响应迅速”。</p>

<p>对于像 Lottie 这样的复杂动画，其优势更加显著，因为传统方法迫使用户等待整个动画序列，然后才会出现任何有意义的内容。</p>

<p><img src="https://sankalpchauhan.com/6f6ac6fcfed426f343bb76cd31f4694e/comparison.mp4.gif" alt="旧用户体验与新用户体验对比" /></p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#why-the-technical-mechanism">原因：技术机制</a></h3>

<p>性能提升源于<strong>并行执行</strong>。传统方法<strong>顺序</strong>运行启动画面和主内容，而基于视图的方法<strong>并发</strong>运行它们：</p>

<p><strong>传统（顺序）</strong>：</p>

<pre><code class="css">Splash Activity → Animation → Destroy → Main Activity → Content Load → Display
</code></pre>

<p><strong>非阻塞（并行）</strong>：</p>

<pre><code class="css">Main Activity + Content Load (background)
     ↓
Splash View (overlay) → Remove overlay → Display loaded content
</code></pre>

<p>这种架构差异彻底消除了阻塞瓶颈。</p>

<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#deep-dive-understanding-the-technical-implementation">深入探究：理解技术实现</a></h2>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#traditional-splash-activity-implementation">传统的 Splash Activity 实现</a></h3>

<pre><code class="kotlin">class SplashActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        installSplashScreen()
        enableEdgeToEdge()
        setContent {
            Loader { // Blocks until animation completes
                startActivity(Intent(this@SplashActivity, MainActivity::class.java))
            }
        }
    }

    @Composable
    fun Loader(onComplete: () -&gt; Unit) {
        val composition by rememberLottieComposition(LottieCompositionSpec.RawRes(R.raw.sale_tags))
        val progress by animateLottieCompositionAsState(composition)

        // Animation blocks main content loading
        if (progress == 1.0f) {
            onComplete.invoke()
        }
    }
}
</code></pre>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#event-splash-non-blocking-implementation">EventSplash：非阻塞实现</a></h3>

<pre><code class="kotlin">class EventSplash(
    private val activity: ComponentActivity,
    private val config: EventSplashConfig,
) {
    private val decorView: ViewGroup = activity.window.decorView as ViewGroup
    private var composeView: ComposeView? = null

    // Gate prevents premature display until main content ready
    private val gate = object : ViewTreeObserver.OnPreDrawListener {
        override fun onPreDraw(): Boolean {
            return if (isReady) {
                decorView.viewTreeObserver.removeOnPreDrawListener(this)
                true
            } else false
        }
    }

    init {
        decorView.viewTreeObserver.addOnPreDrawListener(gate)
        setupSplashCompose() // Non-blocking overlay
        isReady = true
    }

    private fun setupSplashCompose() {
        val view = ComposeView(activity).apply {
            layoutParams = ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)
            setContent {
                getProvider(config).Content(onFinish = { dismiss() })
            }
        }
        composeView = view
        decorView.addView(view) // Overlay on main content
    }
}
</code></pre>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#usage-comparison">使用情况比较</a></h3>

<p><strong>传统方法</strong>:</p>

<pre><code class="kotlin">// Requires separate activity, blocks main content
class MainActivity : ComponentActivity() {
    // Main content only loads after splash completes
}
</code></pre>

<p><strong>EventSplash 方法</strong>:</p>

<pre><code class="kotlin">class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // Non-blocking: splash displays while content loads
        EventSplashApi.attachTo(this).with(getSaleConfig()).show()

        setContent {
            // Main content loads immediately in parallel
            MainAppContent()
        }
    }
}
</code></pre>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#recap-implementation-differences">回顾：实现差异</a></h3>

<p>传统方法需要单独的 Activity 生命周期，而 EventSplash 会注入一个与主内容加载过程共存的视图叠加层。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#why-architectural-advantages">原因：架构优势</a></h3>

<ol>
<li><strong>单一 Activity 上下文</strong>：消除 Activity 转换开销</li>
<li><strong>并行处理</strong>：主内容在启动画面显示时加载</li>
<li><strong>减少内存占用</strong>：没有重复的 Activity 对象</li>
<li><strong>减少 Choreographer.doFrame 循环</strong>：减少渲染管线压力</li>
<li><strong>优化视图层级</strong>：使用单一装饰视图，而非多个独立的 Activity</li>
</ol>


<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#the-choreographer-do-frame-problem">Choreographer.doFrame 问题</a></h2>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#understanding-frame-rendering-issues">理解帧渲染问题</a></h3>

<p>Android 的渲染系统依赖于 <code>Choreographer.doFrame</code> 来协调动画、输入和绘制 <a href="https://developer.android.com/topic/performance/vitals/render">[4]</a>。文档警告：</p>

<blockquote><p>“如果 Systrace 显示 Choreographer#doFrame 的布局部分工作过多或过于频繁，则意味着你遇到了布局性能问题”</p></blockquote>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#why-splash-activities-cause-jank">为什么闪屏 Activity 会导致卡顿</a></h3>

<p>传统的闪屏实现会造成多个性能瓶颈：</p>

<ol>
<li><strong>双重布局传递</strong>：每个 Activity 都需要单独的视图填充和布局</li>
<li><strong>上下文切换开销</strong>：操作系统必须管理多个 Activity 上下文</li>
<li><strong>内存压力</strong>：重复的视图层次结构会消耗额外的 RAM</li>
<li><strong>帧时序问题</strong>：Activity 转换会触发额外的 doFrame 周期</li>
</ol>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#perfetto-analysis-insights">Perfetto 分析洞察</a></h3>

<p>使用 Perfetto 分析轨迹时，传统的启动画面会显示：</p>

<ul>
<li><code>Choreographer.doFrame</code> 执行时间延长</li>
<li>布局膨胀多次峰值</li>
<li>垃圾回收压力增加</li>
<li>主线程可用性延迟</li>
</ul>


<p>基于视图的方法通过在整个启动过程中维护单一渲染上下文来消除这些问题。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#critical-consideration-concurrent-processing-isnt-free">⚠️ 关键考虑：并发处理并非免费</a></h3>

<p>虽然我们的结果显示性能显著提升，但<strong>非阻塞方法也带来了一系列挑战</strong>，必须仔细考虑。同时运行启动动画和主内容加载会带来额外的资源压力，而顺序加载方法则不会出现这种压力。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#memory-pressure-the-primary-concern">内存压力：主要问题</a></h3>

<p><strong>峰值内存使用量增加</strong>：</p>

<pre><code class="nix">// Memory usage pattern comparison
Traditional Approach:
Splash: 50MB → 0MB → Main Content: 120MB = Peak: 120MB

Non-blocking Approach:  
Splash + Main Content: 50MB + 120MB = Peak: 170MB
</code></pre>

<p><strong>实际影响</strong>：</p>

<ul>
<li><strong>简单的闪屏叠加</strong>在并发执行期间会增加 20-50MB 的内存</li>
<li><strong>Lottie 动画</strong>在渲染期间可能会消耗 50-100MB 以上的内存</li>
<li><strong>综合峰值使用量</strong>可能比顺序加载方法高出 40-70%</li>
<li><strong>低端设备</strong>（1-2GB RAM）容易受到内存压力的影响</li>
</ul>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#low-memory-killer-risk">低内存杀手风险</a></h3>

<p>Android 的低内存终止守护进程会监控系统内存，并可能在压力下终止应用 <a href="https://source.android.com/docs/core/perf/lmkd">[5]</a>:</p>

<blockquote><p>“内存压力是指系统内存不足的状态，需要 Android 通过限制或终止不重要的进程来释放内存”</p></blockquote>

<p><strong>风险因素</strong>:</p>

<ul>
<li>启动过程中终止应用进程会导致糟糕的用户体验</li>
<li>后台应用被更频繁地终止</li>
<li>并发分配导致的内存碎片</li>
<li>在预算设备上尤其成问题</li>
</ul>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#cpu-and-battery-implications">CPU 和电池影响</a></h3>

<p><strong>CPU 开销增加</strong>：</p>

<ul>
<li><code>Choreographer.doFrame</code> 处理多个并发操作</li>
<li>主线程因 UI 工作重叠而变得更加繁忙</li>
<li>GPU 渲染管线同时处理启动画面和内容</li>
</ul>


<p><strong>功耗问题</strong>：研究表明，“智能手机上的 UI 渲染需要强大的 CPU 和 GPU 才能满足用户感知的流畅度，并且这占了相当一部分的功耗”<a href="https://www.sciencedirect.com/science/article/abs/pii/S1383762122001540">[6]</a>。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#device-compatibility-challenges">设备兼容性挑战</a></h3>

<p><strong>低端设备注意事项</strong>:</p>

<ul>
<li>单核或双核处理器难以并行化</li>
<li>有限的 RAM 使得内存压力至关重要</li>
<li>较慢的存储速度加剧加载延迟</li>
<li>优势可能无法转化为低端设备的优势</li>
</ul>


<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#when-not-to-use-non-blocking-approach">何时不应使用非阻塞方法</a></h2>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#scenarios-where-traditional-approach-may-be-better">传统方法可能更佳的场景：</a></h3>

<ol>
<li><strong>资源极其受限的设备</strong>（&lt; 2GB RAM）</li>
<li><strong>电池关键型应用</strong>，功耗至关重要</li>
<li><strong>简单的启动画面</strong>，没有复杂的动画</li>
<li><strong>启动处理繁重的应用</strong>，已经给应用带来了压力系统</li>
<li><strong>遗留代码库</strong>，重构风险大于收益</li>
</ol>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#risk-mitigation-strategies">风险缓解策略</a></h3>

<p><strong>自适应实施</strong>：</p>

<pre><code class="kotlin">class AdaptiveSplashStrategy {
    fun chooseSplashApproach(): SplashConfig {
        return when {
            isLowEndDevice() -&gt; SimpleSplashConfig()
            isBatteryLow() -&gt; ReducedAnimationConfig()
            isHighPerformanceDevice() -&gt; FullLottieConfig()
            else -&gt; DefaultConfig()
        }
    }

    private fun isLowEndDevice(): Boolean {
        val activityManager = getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
        return activityManager.isLowRamDevice || 
               Runtime.getRuntime().maxMemory() &lt; 256 * 1024 * 1024
    }
}
</code></pre>

<p><strong>内存监控</strong>：</p>

<pre><code class="kotlin">private fun monitorMemoryPressure() {
    val memoryInfo = ActivityManager.MemoryInfo()
    activityManager.getMemoryInfo(memoryInfo)

    if (memoryInfo.lowMemory) {
        // Fallback to simpler splash
        simplifyOrDismissSplash()
    }
}
</code></pre>

<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#industry-context-and-validation">行业背景和验证</a></h2>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#alignment-with-industry-best-practices">与行业最佳做法保持一致实践</a></h3>

<p>EventSplash 方法符合最新的行业趋势和官方建议。像 Turo 这样的公司通过消除专用的启动活动也取得了类似的效果。正如他们的案例研究 <a href="https://medium.com/androiddevelopers/turo-reduced-its-app-startup-time-by-77-using-android-developer-tools-and-best-practices-bcf82f596bcf">[7]</a> 中所述：</p>

<blockquote><p>“最初，我们使用专用的 SplashActivity 来运行所有启动工作，然后再将应用路由到 HomeActivity。然而，最新的指南建议不要采用这种方法。因此，我们移除了多余的 SplashActivity，并将所有启动逻辑转移到了根 Activity。”</p></blockquote>

<p>Turo 使用类似的原理实现了<strong>77% 的启动时间缩短</strong>。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#validation-through-official-documentation">通过官方文档验证</a></h3>

<p>Android 官方文档明确建议使用“ViewTreeObserver.OnPreDrawListener”进行启动画面管理，<a href="https://developer.android.com/develop/ui/views/launch/splash-screen">[1]</a>，这进一步验证了该方法，而这正是 EventSplash 的核心实现。</p>

<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#best-practices-and-common-pitfalls">最佳实践和常见陷阱</a></h2>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#dos">建议✅</a></h3>

<ul>
<li>在性能强大的设备上，<strong>使用基于视图的启动画面实现</strong>自定义动画</li>
<li>根据设备性能<strong>实施自适应策略</strong></li>
<li>使用真实设备**测量性能，并跨设备层级发布版本</li>
<li>监控内存使用情况**并实施内存泄漏预防</li>
<li>针对最坏情况进行冷启动优化</li>
<li>在低端设备上进行广泛测试**以确保广泛的兼容性</li>
<li><strong>为启动画面实施适当的生命周期管理</strong></li>
</ul>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#donts">注意事项❌</a></h3>

<ul>
<li><strong>不要想当然地认为一刀切</strong>：设备性能差异巨大</li>
<li><strong>不要忽视内存压力</strong>：监控并适应系统限制</li>
<li><strong>不要在未考虑替代方案的情况下使用单独的 SplashActivity</strong></li>
<li><strong>不要用启动画面动画阻碍主内容加载</strong></li>
<li><strong>不要忽略 Play 管理中心内的 Android Vitals 指标</strong></li>
<li><strong>不要只在高端设备</strong>或调试版本上进行测试</li>
<li><strong>不要在启动画面中创建复杂的视图层次结构</strong></li>
<li><strong>不要在启动画面中执行繁重的操作</strong></li>
<li><strong>不要忘记清理启动画面</strong>并清除缓存</li>
</ul>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#common-pitfalls">常见陷阱</a></h3>

<ol>
<li><strong>内存泄漏</strong>：未能清除 LottieCompositionCache</li>
<li><strong>设备能力假设</strong>：未适应低端设备限制</li>
<li><strong>生命周期问题</strong>：未正确处理 Activity 状态变化</li>
<li><strong>动画冲突</strong>：闪屏动画干扰主内容</li>
<li><strong>测试偏差</strong>：仅在快速设备或调试版本上进行测试</li>
<li><strong>指标误解</strong>：关注动画时长而非用户感知的性能</li>
<li><strong>资源监控疏忽</strong>：未监控内存和 CPU 使用模式</li>
</ol>


<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#making-informed-architectural-decisions">制定明智的架构决策</a></h2>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#decision-framework">决策框架</a></h3>

<p>在选择启动画面方案时，请考虑以下因素：</p>

<p><strong>设备受众特征</strong>：</p>

<ul>
<li>你的用户中有多少比例使用低端设备？</li>
<li>你支持的最低 RAM 配置是多少？</li>
<li>你是否瞄准了拥有廉价设备的新兴市场？</li>
</ul>


<p><strong>应用特性</strong>：</p>

<ul>
<li>你的主要内容加载复杂度如何？</li>
<li>你是否对网络依赖性很强？</li>
<li>你当前的内存占用是多少？</li>
</ul>


<p><strong>业务需求</strong>：</p>

<ul>
<li>自定义启动动画对你的品牌有多重要？</li>
<li>你能实现渐进式增强吗？</li>
<li>你的开发和测试能力如何？</li>
</ul>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#recommended-strategy">推荐策略</a></h3>

<p><strong>渐进式增强方法</strong>：</p>

<pre><code class="kotlin">EventSplashApi.attachTo(this)
    .withFallback(SimpleSplashConfig())
    // Low-end devices
    .withStandard(ImageSplashConfig())
    // Mid-range devices
    .withEnhanced(LottieConfig())
    // High-end devices
    .adaptToDevice()
    // Automatic selection
    .show()
</code></pre>

<p>此方法提供：</p>

<ul>
<li>适用于所有设备的<strong>基本功能</strong></li>
<li>在资源允许的情况下<strong>增强体验</strong></li>
<li>根据设备性能<strong>自动适配</strong></li>
<li>在内存压力下<strong>优雅降级</strong></li>
</ul>


<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#insights-recommendations">见解与建议</a></h2>

<p>非阻塞启动画面方法<strong>显著提升性能</strong>（保守测试中页面加载速度提升 90%，复杂动画下最高可达 95%），但也存在一些不足。<strong>并发处理会增加峰值内存使用量和 CPU 开销</strong>，这在低端设备上可能会造成问题。</p>

<p><strong>关键见解</strong>：其优势显著且可衡量，但也伴随着资源成本，必须通过自适应的实施策略进行管理。</p>

<p><strong>诚挚建议</strong>：使用非阻塞方法并结合设备感知回退机制。即使是保守估计，也能显​​示出显著的性能提升，其架构优势也令人信服。然而，该实现必须足够复杂，才能支持所有 Android 设备。</p>

<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#conclusion">结论</a></h2>

<p>_本案例研究表明，性能优化需要在保持诚实声明的同时平衡相互竞争的约束条件。非阻塞、基于视图的方法提供了显著且可衡量的优势，但成功实施需要深入了解其收益和成本。</p>

<p>通过摆脱传统的“SplashActivity”模式，采用更复杂、更并发的架构，我们可以构建速度更快、响应更灵敏的 Android 应用，并在整个生态系统中可靠地运行。</p>

<p><strong>我们的目标不仅仅是构建更快的应用，而是构建使用体验即时、愉悦的应用，因为最终，性能是用户能够注意到并欣赏的功能。</strong></p>

<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#references">参考</a></h2>

<ol>
<li><a href="https://developer.android.com/develop/ui/views/launch/splash-screen">闪屏 | 视图 | Android 开发者</a></li>
<li><a href="https://developer.android.com/topic/performance/vitals/launch-time">应用启动时间 | 应用质量 | Android 开发者</a></li>
<li><a href="https://medium.com/androiddevelopers/the-android-lifecycle-cheat-sheet-part-iv-49946659b094">Android 生命周期速查表 — 第四部分：ViewModel、半透明 Activity 和启动模式 | 作者：Jose Alcérreca</a></li>
<li><a href="https://developer.android.com/topic/performance/vitals/render">渲染缓慢 | 应用质量 | Android 开发者</a></li>
<li><a href="https://source.android.com/docs/core/perf/lmkd">低内存终止守护进程 (lmkd) | Android 开源项目</a></li>
<li><a href="https://www.sciencedirect.com/science/article/abs/pii/S1383762122001540">移动 UI 渲染功耗研究</a></li>
<li><a href="https://medium.com/androiddevelopers/turo-reduced-its-app-startup-time-by-77-using-android-developer-tools-and-best-practices-bcf82f596bcf">Turo 利用 Android 开发者工具和最佳实践将其应用启动时间缩短了 77%</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为什么你的App总是忘记所有事情]]></title>
    <link href="https://alexhilton.github.io/blog/2025/07/11/app-keep-forgetting/"/>
    <updated>2025-07-11T15:20:20+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/07/11/app-keep-forgetting</id>
    <content type="html"><![CDATA[<p>本文译自「Why Your App Keeps Forgetting Everything」，原文链接<a href="https://medium.com/mobile-app-development-publication/why-your-app-keeps-forgetting-everything-aa9ad8dd8f6b">https://medium.com/mobile-app-development-publication/why-your-app-keeps-forgetting-everything-aa9ad8dd8f6b</a>，由Android Dev Nexus发布于2025年6月13日。</p>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OqqSvUytY9D0D4EIX_Cn0A.png" title="auto auto" ></a></p>

<!-- more -->


<p>不知你有没有发现了一个让许多 Android 开发者困惑的关键问题：ViewModel 和 savedInstanceState 解决的是不同的问题，并且拥有不同的生命周期。</p>

<p>让我来解释一下你的测试中究竟发生了什么，以及为什么这两种机制都存在。</p>

<h2>Android 中的两种“死亡”类型</h2>

<p>Android 应用可以通过两种截然不同的方式“死亡”：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1-DtrKgBiEVyWj0RgbaNoQ.png" alt="" /></p>

<h3>1. 配置变更（屏幕旋转等）</h3>

<ul>
<li>Activity/Fragment：死亡并重建</li>
<li>ViewModel：幸存！🎉</li>
<li>savedInstanceState：也幸存，但此时你并不需要它</li>
</ul>


<h3>2. 进程死亡（应用最小化、内存不足等）</h3>

<ul>
<li>Activity/Fragment：死亡</li>
<li>ViewModel：也死亡！💀</li>
<li>savedInstanceState：幸存并成为你的生命线</li>
</ul>


<h2>测试结果不撒谎</h2>

<pre><code class="Kotlin">// 进程死亡时会发生什么:

// 最小化应用程序之前:
class MyViewModel : ViewModel() {
    var userData = "Important data"
    var counter = 42
}
// 重新打开应用程序后:
// - 新的 ViewModel 实例已创建（旧数据已消失）
// - 但是 onCreate() 接收了已保存数据的 savedInstanceState 包
// - 你需要手动从 savedInstanceState 恢复 ViewModel
</code></pre>

<p>你猜测的完全正确：ViewModel 需要额外的步骤来存储/恢复数据，即使进程终止。</p>

<h2>完整的解决方案：两者结合</h2>

<p>以下是现代 Android 开发处理这个双层系统的方法：</p>

<pre><code class="Kotlin">class MainActivity : AppCompatActivity() {
    private lateinit var viewModel: MyViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        viewModel = ViewModelProvider(this)[MyViewModel::class.java]

        // 检查我们是否正在从进程死亡中恢复
        if (savedInstanceState != null &amp;&amp; viewModel.isEmpty()) {
            // 从 savedInstanceState 恢复 ViewModel
            val userData = savedInstanceState.getString("user_data", "")
            val counter = savedInstanceState.getInt("counter", 0)
            viewModel.restoreFromSavedState(userData, counter)
        }
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        // 保存关键的 ViewModel 数据以避免进程死亡
        outState.putString("user_data", viewModel.userData)
        outState.putInt("counter", viewModel.counter)
    }
}

class MyViewModel : ViewModel() {
    var userData: String = ""
    var counter: Int = 0

    fun isEmpty(): Boolean = userData.isEmpty() &amp;&amp; counter == 0

    fun restoreFromSavedState(userData: String, counter: Int) {
        this.userData = userData
        this.counter = counter
    }
}
</code></pre>

<h2>当每个机制生效时</h2>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dmQnYfNrJik_bbpuNT7bzQ.png" alt="" /></p>

<p>让我来向你展示一下不同场景下的具体情况：</p>

<h3>场景 1：屏幕旋转</h3>

<pre><code class="Bash">Before rotation: 
- ViewModel: Alive with data ✅ 
- savedInstanceState: Gets saved but not really needed 

After rotation: 
- ViewModel: Same instance, data intact ✅ 
- savedInstanceState: Available but redundant 
- Result: ViewModel data is immediately available
</code></pre>

<h3>场景2：应用程序最小化→重新打开（进程死亡）</h3>

<pre><code class="Bash">Before minimizing: 
- ViewModel: Alive with data ✅ 
- onSaveInstanceState(): Saves critical data to Bundle
After reopening:
- ViewModel: NEW instance, no data ❌
- savedInstanceState: Contains saved data ✅
- Result: Must restore ViewModel from savedInstanceState
</code></pre>

<h3>场景 3：应用程序最小化 → 重新打开（进程存活）</h3>

<pre><code class="Bash">Before minimizing: 
- ViewModel: Alive with data ✅
After reopening:
- ViewModel: Same instance, data intact ✅
- savedInstanceState: null (no recreation happened)
- Result: ViewModel data is immediately available
</code></pre>

<h2>那么，为什么存在这个双层系统？</h2>

<p>ViewModel 处理常见情况：</p>

<ul>
<li>复杂的 UI 状态，你不希望在频繁旋转屏幕时丢失。</li>
<li>任何需要耗费大量资源重新创建的内容。</li>
</ul>


<p>savedInstanceState 处理特殊情况：</p>

<ul>
<li>进程死亡难以预测。但当它发生时，用户希望其状态能够持久保存。</li>
<li>小而关键的数据片段（例如用户输入、滚动位置）。</li>
<li>简单的 UI 状态，对用户体验至关重要。</li>
</ul>


<h2>Bundle 大小的现实检验</h2>

<p>以下是一些可以帮你免去调试麻烦的事情：Bundle 并非无限大的存储空间。你大约有 1MB 的空间可用，超过这个限制会导致
崩溃，让你质疑自己的人生选择。</p>

<p>保持 onSavedInstanceState 数据精简。保存用户写到一半的电子邮件草稿，而不是整个联系人列表。</p>

<h2>现代方法：SavedStateHandle</h2>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ThuE7YpnrtfFQe2fwDlbDg.png" alt="" /></p>

<p>Google 意识到这种手动操作非常繁琐，因此他们创建了 SavedStateHandle ：</p>

<pre><code class="Kotlin">class MyViewModel(private val savedStateHandle: SavedStateHandle) : ViewModel() {

    // 这将自动保留配置更改和进程终止！
    var userData: String
        get() = savedStateHandle.get&lt;String&gt;("user_data") ?: ""
        set(value) = savedStateHandle.set("user_data", value)

    var counter: Int
        get() = savedStateHandle.get&lt;Int&gt;("counter") ?: 0
        set(value) = savedStateHandle.set("counter", value)

    // 无需手动恢复！
}
</code></pre>

<h2>对于以下情况，为什么仍然需要手动 onSaveInstanceState？</h2>

<h3>1. 不属于 ViewModel 的 UI 特定状态</h3>

<pre><code class="Kotlin">override fun onSaveInstanceState(outState: Bundle) {
    super.onSaveInstanceState(outState)
    // 这些不属于你的业务逻辑层
    outState.putInt("scroll_position", recyclerView.computeVerticalScrollOffset())
    outState.putBoolean("is_toolbar_expanded", collapsingToolbar.isExpanded)
    outState.putParcelable("dialog_state", currentDialog?.onSaveInstanceState())
}
</code></pre>

<h3>2. Fragment 参数和 Activity Extras</h3>

<pre><code class="Kotlin">// 这些需要在进程终止后继续存在，但不是 ViewModel 状态
class DetailFragment : Fragment() {
    companion object {
        fun newInstance(itemId: String) = DetailFragment().apply {
            arguments = Bundle().apply {  // 这在内部使用 savedInstanceState
                putString("item_id", itemId)
            }
        }
    }
}
</code></pre>

<h3>3. 视图状态过于特定于 UI</h3>

<pre><code class="Kotlin">// 诸如 EditText 光标位置、焦点状态等。
override fun onSaveInstanceState(outState: Bundle) {
    super.onSaveInstanceState(outState)
    outState.putInt("edit_text_selection_start", editText.selectionStart)
    outState.putInt("edit_text_selection_end", editText.selectionEnd)
}
</code></pre>

<h2>把手弄脏（动手试一试）</h2>

<p>你可以强制终止进程进行测试：</p>

<pre><code class="bash"># Kill your app process 
adb shell am kill com.yourpackage.name 
# Or use "Don't keep activities" in Developer Options
</code></pre>

<p>这将帮助你验证状态恢复是否正确进行。</p>

<h2>关键洞察</h2>

<p>ViewModel 非常适合配置更改，但需要帮助应对进程死亡。</p>

<p>现代方法是在 ViewModel 中使用 SavedStateHandle，它可以自动处理这两种情况。如果你尚未使用它，则需要手动执行 savedInstanceState → ViewModel 的恢复过程。</p>

<p>这个双层系统看似复杂，但实际上非常优雅：常见情况（配置更改）的快速恢复，以及罕见情况（进程死亡）的可靠恢复。</p>

<p>祝你编码愉快，愿你的状态始终持久！🚀</p>
]]></content>
  </entry>
  
</feed>
