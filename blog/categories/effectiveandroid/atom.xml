<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2025-04-12T17:34:50+08:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Compose Multiplatform支持热重载(Hot Reload)了]]></title>
    <link href="https://alexhilton.github.io/blog/2025/04/12/compose-hot-reload/"/>
    <updated>2025-04-12T17:11:47+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/04/12/compose-hot-reload</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自Compose Hot Reload is Now Available，原文链接<a href="https://medium.com/@wisemuji/compose-hot-reload-is-now-available-3a9aee58b0fe">Compose Hot Reload is Now Available</a>，由<a href="https://medium.com/@wisemuji">Suhyeon Kim</a>，发布于2025年3月19日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FMBFWn5vJOuaM41zKE6aTg.jpeg" title="auto auto" ></a></p>

<!-- more -->


<p><strong>译注：</strong>  需要注意的是Google通过Android Studio(after Giraffe)里面的<a href="https://developer.android.com/develop/ui/compose/tooling/iterative-development">Live Edit特性</a>提供了对Android上面的Jetpack Compose的实时更新支持。但它仅支持Jetpack Compose (for Adnroid)，并不支持CMP，也即不支持JetBrains的Compose。也正因为如此JetBrains才会开发面向CMP的Hot Reload。</p>

<p>在Compose UI开发过程中，你是否经常需要构建运行？Compose 热重载现已在Maven Central中推出，可为Compose多平台（桌面）应用中的UI代码提供实时更新。我们无需重启应用即可立即查看UI代码的更改。</p>

<p>让我们来一探究竟！</p>

<h2>热重载(Hot Reload)是什么鬼？</h2>

<p>许多声明式UI框架都提供了类似概念，热重载，即可以在开发过程中提供对UI更改的近乎即时的反馈（尽管它们的名称不同！）。</p>

<p>例如隔壁的两家：</p>

<ul>
<li>Flutter热加载：<a href="https://docs.flutter.dev/tools/hot-reload">https://docs.flutter.dev/tools/hot-reload</a></li>
<li>React Native快速刷新：<a href="https://reactnative.dev/docs/fast-refresh">https://reactnative.dev/docs/fast-refresh</a></li>
</ul>


<p>热重载允许开发者实时查看代码更改，无需重启应用或重新编译整个项目。在大多数情况下，热重载会保留应用的状态，因此开发者可以继续与应用交互，而不会丢失进度或上下文。这可以帮助开发者快速演示代码更改对UI的影响，从而提高工作效率，而无需等待漫长的构建。</p>

<h2>Compose的热重载</h2>

<p>看一下官方的介绍<a href="https://github.com/JetBrains/compose-hot-reload">https://github.com/JetBrains/compose-hot-reload</a>：</p>

<blockquote><p>在Compose多平台应用中更改你的UI代码，并实时查看结果。
无需重启应用。</p></blockquote>

<p>目前，Compose Hot Reload 适用于针对桌面 JVM 的多平台项目（未来是否有可能扩展？我不确定。:D）。Compose Hot Reload 的最新版本是 v1.0.0-alpha02，于昨天（2025 年 3 月 17 日）发布。现在，开发者可以在Compose多平台应用中查看其UI代码的更改，而无需重启应用。这意味着开发者可以立即预览更改，而无需缓慢的构建和重启。</p>

<p><strong>译注：</strong> 现在（2025年4月9日）最新版本是 v1.0.0-alpha04，主要是Bugfix，目前开发中的版本是 v1.0.0-alpha05 。</p>

<h2>如何上手</h2>

<p>要开始使用Compose Hot Reload，请查看<a href="https://github.com/JetBrains/compose-hot-reload">Compose Hot Reload</a>的 GitHub 代码库。</p>

<p><strong>注意：</strong> 以下内容基于 v1.0.0-alpha02 编写。</p>

<h3>依赖要求</h3>

<ul>
<li>一个以桌面为目标的Compose Multiplatform 项目（参见<a href="https://github.com/JetBrains/compose-hot-reload#faq">其FAQ</a>）</li>
<li>Kotlin 2.1.20-Beta2 或更高版本</li>
</ul>


<p>对于 Android 应用，有一个小的解决方法：
首先，你需要从Jetpack Compose插件切换到Compose Multiplatform 插件，
然后添加一个单独的 Gradle 模块并配置桌面目标。</p>

<h3>将 Gradle 插件应用到你的项目中</h3>

<p>将 org.jetbrains.compose.hot-reload Gradle 插件添加到你的构建脚本：</p>

<pre><code class="Kotlin">plugins {
    kotlin("multiplatform") version "2.1.20-RC" // &lt;- Use Kotlin 2.1.20-RC or higher!
    kotlin("plugin.compose") version "2.1.20-RC" // &lt;- Use Compose Compiler Plugin 2.1.20-RC or higher!
    id("org.jetbrains.compose")
    id("org.jetbrains.compose.hot-reload") version "1.0.0-alpha02" // &lt;- add this additionally
}
</code></pre>

<h3>启用“OptimizeNonSkippingGroups”：</h3>

<p>将以下内容添加到你的 build.gradle.kts ：</p>

<pre><code class="Kotlin">import org.jetbrains.kotlin.compose.compiler.gradle.ComposeFeatureFlag
// ...
composeCompiler {
    featureFlags.add(ComposeFeatureFlag.OptimizeNonSkippingGroups)
}
</code></pre>

<h3>为UI热重载提供入口点</h3>

<p>在项目的桌面源代码集中，使用 DevelopmentEntryPoint 包装窗口内容。</p>

<pre><code class="Kotlin">import org.jetbrains.compose.reload.DevelopmentEntryPoint
// ...
fun main() {
    singleWindowApplication(...) {
        DevelopmentEntryPoint { // add this line
            App()
        }
    }
}
</code></pre>

<p>这就是我们需要折腾的全部内容。现在让我们看看它是如何工作的。</p>

<h2>Demo演示</h2>

<p>要了解Compose 热重载的实际效果，我们来看看我的示例项目<a href="https://github.com/wisemuji/compose-would-you-rather-game">“Would You Rather Game”</a>。这个项目是一个简单的 Compose 多平台桌面应用，用户可以在其中回答有趣的“Would You Rather”问题。Compose 热重载插件最近已实现。</p>

<p>你可以参考 Compose 热重载的setup提交：<a href="https://github.com/wisemuji/compose-would-you-rather-game/commit/937375cea9010733ee751dc2d464a0df21318cee">setup提交</a>。</p>

<p>如果你在项目上运行desktopRun，你会注意到桌面应用程序旁边会出现一个小的Compose图标。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*TXn4jUzxwcSh5IfqRqFNkA.png" alt="HotReload Icon" /></p>

<p>这将触发 Compose Hot Reload Tooling 模式，如下所示：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*37gLudPijGvh3A-rKdK_kw.png" alt="HotReload Demo" /></p>

<h3>UI更改示例</h3>

<p>假设我们想要更改<a href="https://github.com/wisemuji/compose-would-you-rather-game/blob/4e9bfc7172c7145f95190fd383169bbcdc25856f/composeApp/src/commonMain/kotlin/ui/game/GameScreen.kt#L226">GameScreen.kt</a>中的动画。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b4xJXpWH9oA5YohC1zsWng.gif" alt="Full Demo" /></p>

<p>看到没有！一旦我们保存文件，更改就会立即显示在正在运行的应用程序中。无需重启应用！</p>

<h2>热重载当前支持的场景</h2>

<p>目前，几乎所有代码更改都支持热重载（除了从类中删除超类型）。</p>

<p><a href="https://hashnode.com/@sellmair">Sebastian Sellmair 的视频和博客文章</a>通过多个演示展示了这些功能，并详细解释了重载的底层工作原理。</p>

<h2>局限性</h2>

<p>由于它仅支持基于 JVM 的桌面应用，因此目前尚不支持 Android 和其他平台。
此外，构建性能方面可能存在一些问题。在我的本地环境中，更改大约需要 3 到 5 秒，感觉比其他声明式UI框架中的热重载慢不少。估计它会在后面得到改善。</p>

<p>由于这是一个 Alpha 版本，因此无法保证稳定性。开发者应该预料到可能会出现一些潜在的错误和迁移挑战，正如 JetBrains 团队所指出的：“Alpha 版本意味着使用风险自负，迁移问题也需谨慎。我们打算将这个想法产品化，但尚未最终成型。” 由于该功能仍在积极开发中，因此我们应该在未来的版本中持续关注更新。</p>

<h2>提供反馈</h2>

<p>如果你遇到任何问题或有改进建议，你可以通过<a href="https://slack-chats.kotlinlang.org/t/27038699/with-compose-hot-reload-now-being-available-on-maven-central"> Kotlinlang Slack - Compose Hot Reload </a>分享你的想法。</p>

<blockquote><p>尤其欢迎提：</p>

<ul>
<li>设置时遇到的问题</li>
<li>重新加载特定代码段时遇到的问题</li>
<li>关于如何改进/功能请求的想法</li>
</ul>


<p>目前不太感兴趣的内容：</p>

<ul>
<li>构建性能：目前，“Gradle 重编译器”的速度将与你的项目速度一样快。强烈建议
启用 Gradles 配置缓存，并保持项目非常干净。其他“重编译器”也会有所帮助！（IntelliJ、Amper 等）</li>
</ul>
</blockquote>

<h2>总结</h2>

<p>我相信 Compose 中的 Hot Reload 是开发 Compose UI的一大变革。
它可以让开发人员在无需重启应用的情况下看到更改，从而加快UI开发速度，但它仍处于实验阶段。目前，它最适合个人或早期项目，你可以使用 alpha 版本进行开发。在你自己的 Compose Multiplatform 项目中试用它，体验即时UI反馈的好处！</p>

<p>我迫不及待地想看到即将到来的更新！XD</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://github.com/JetBrains/compose-hot-reload">https://github.com/JetBrains/compose-hot-reload</a></li>
<li><a href="https://blog.sellmair.io/say-hello-to-compose-hot-reload-firework">https://blog.sellmair.io/say-hello-to-compose-hot-reload-firework</a></li>
<li><a href="https://www.youtube.com/watch?v=8Z-Vuo3wTd0">Firework: Introducing Compose Hot Reload</a></li>
<li><a href="https://www.youtube.com/watch?v=I_FMnPaEBEA">How ‘Hot Reload’ is implemented for Compose</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实战：探索Jetpack Compose中的SearchBar]]></title>
    <link href="https://alexhilton.github.io/blog/2025/04/09/searchbar-in-jetpack-compose/"/>
    <updated>2025-04-09T22:40:46+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/04/09/searchbar-in-jetpack-compose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自Exploring Jetpack Compose: SearchBar，原文链接：<a href="https://joebirch.co/android/exploring-the-searchbar-composable/">https://joebirch.co/android/exploring-the-searchbar-composable/</a>，作者是Joe Birch。</p></blockquote>

<p>在应用内搜索内容是一项常见功能，事实上，你可以在设备上的大多数应用程序中发现此功能。在 Android 上，我们看到的此功能的常见 UI 组件是浮动搜索栏，放置在屏幕的显眼位置。在某些情况下，这还会向用户提供搜索建议，以简化搜索过程。Jetpack Compose Material3 软件包提供了对提供此功能的 SearchBar 可组合项的访问，在这篇博文中，我们将学习如何在我们自己的应用中使用它。</p>

<p><a href=""><img src="https://joebirch.co/wp-content/uploads/2025/03/Group.png" title="auto auto" ></a></p>

<!-- more -->


<p>SearchBar 可组合项允许我们显示一个浮动的搜索组件，该组件展开后会显示可选的推荐。如上所述，这是我们在许多应用中看到的常见模式，此可组合项提供了开箱即用的解决方案。SearchBar 可组合项提供了足够的自定义功能来控制组件的外观和感觉，同时使用基于插槽(slot)的方法让我们提供输入字段以供使用。</p>

<pre><code class="Kotlin">@Composable
fun SearchBar(
    inputField: @Composable () -&gt; Unit,
    expanded: Boolean,
    onExpandedChange: (Boolean) -&gt; Unit,
    modifier: Modifier = Modifier,
    shape: Shape = SearchBarDefaults.inputFieldShape,
    colors: SearchBarColors = SearchBarDefaults.colors(),
    tonalElevation: Dp = SearchBarDefaults.TonalElevation,
    shadowElevation: Dp = SearchBarDefaults.ShadowElevation,
    windowInsets: WindowInsets = SearchBarDefaults.windowInsets,
    content: @Composable ColumnScope.() -&gt; Unit,
)
</code></pre>

<p>该组件为我们处理了大部分内部工作——其中两个关键部分需要我们自己提供。</p>

<ul>
<li>inputField – 这是表示内容输入的搜索字段的输入可组合项</li>
<li>content – 这是搜索栏展开时用于显示推荐的内容区域</li>
</ul>


<p>除了这些字段之外，还有一组其他属性用于确定 SearchBar 的当前状态。例如，当搜索栏处于展开状态时，可组合项的内容将显示在输入字段下方。为了能够管理这一点，我们需要为可组合项提供一些参数，用于管理此状态。首先，expanded 参数用于描述 SearchBar 是否处于展开状态（这将决定是否显示内容区域），以及 onExpandedChange 参数，用于为实现提供展开状态的更新值（然后可用于反映我们自己的状态实现）。</p>

<pre><code class="Kotlin">var expanded by remember { mutableStateOf(false) }

SearchBar(
    modifier = Modifier.fillMaxWidth(),
    expanded = expanded,
    onExpandedChange = {
        expanded = it
    }
)
</code></pre>

<p>除了管理这种展开状态外，我们还需要提供用于 SearchBar 输入区域的 inputField。除了遵循可组合项的基于插槽的方法之外，这还允许可组合项遵循状态提升的概念，使我们能够完全管理 SearchBar 输入字段的状态概念。</p>

<pre><code class="Kotlin">var expanded by remember { mutableStateOf(false) }
var query by remember { mutableStateOf&lt;String?&gt;(null) }

SearchBar(
    modifier = Modifier.fillMaxWidth(),
    expanded = expanded,
    onExpandedChange = {
        expanded = it
    },
    inputField = {
        // ...
    }
)
</code></pre>

<p>为了简化此操作，SearchBarDefaults 类为我们提供了对 InputField 可组合项的访问 - 这使我们能够访问专门为 SearchBar 实现的可组合项。不需要使用此特定可组合项，但它是专门为基于搜索的输入字段提供的便利可组合项。此可组合项采用一些关键参数，用于将其配置为在 SearchBar 中使用：</p>

<ul>
<li>expanded 和 onExpandedChange - 用于管理字段的展开状态</li>
<li>query 和 onQueryChange - 用于管理字段中显示的查询的状态</li>
</ul>


<p>除了这些核心属性外，你还会注意到对标准字段参数（如占位符、leadingIcon 和 trailingIcon）的支持。除了用于提供信息之外，我们还可以在下面的示例中看到我如何使用 trailingIcon 允许 SearchBar 在单击取消按钮时恢复到折叠状态。</p>

<pre><code class="Kotlin">SearchBarDefaults.InputField(
    onSearch = { expanded = false },
    expanded = expanded,
    onExpandedChange = { expanded = it },
    placeholder = { Text("What are you looking for?") },
    leadingIcon = { Icon(Icons.Default.Search, contentDescription = null) },
    trailingIcon = {
        if (expanded) {
            IconButton(onClick = {
                expanded = false
            }) {
                Icon(Icons.Default.Close, contentDescription = null)
            }
        }
    },
    query = query ?: "",
    onQueryChange = {
        query = it
    }
)
</code></pre>

<p>然后可以将此 InputField 可组合项的实现插入到 SearchBar 可组合项的 inputField 参数中。</p>

<pre><code class="Kotlin">var expanded by remember { mutableStateOf(false) }
var query by remember { mutableStateOf&lt;String?&gt;(null) }

SearchBar(
    modifier = Modifier.fillMaxWidth(),
    expanded = expanded,
    onExpandedChange = {
        expanded = it
    },
    inputField = {
        SearchBarDefaults.InputField(
            onSearch = { expanded = false },
            expanded = expanded,
            onExpandedChange = { expanded = it },
            placeholder = { Text("What are you looking for?") },
            leadingIcon = { Icon(Icons.Default.Search, contentDescription = null) },
            trailingIcon = {
                if (expanded) {
                    IconButton(onClick = {
                        expanded = false
                    }) {
                        Icon(Icons.Default.Close, contentDescription = null)
                    }
                }
            },
            query = query ?: "",
            onQueryChange = {
                query = it
            }
        )
    }
)
</code></pre>

<p>此时，我们将能够组合 SearchBar 并看到在我们的 UI 中显示的浮动组件。</p>

<p><img src="https://joebirch.co/wp-content/uploads/2025/03/sea.png" alt="SearchBar" /></p>

<p>此时我们剩下要实现的就是 SearchBar 的内容，这是 SearchBar 处于展开状态时显示的内容。此参数利用了 ColumnScope，因此此处提供的任何可组合项都将垂直堆叠。此内容区域的预期形式是用户可以选择的推荐列表，因此我们将继续编写几个 ListItem 可组合项，每个可组合项都用于向用户显示搜索推荐。当点击其中任何一项时，查询将更新为选定值，并且 SearchBar 的展开状态将重置。</p>

<pre><code class="Kotlin">var expanded by remember { mutableStateOf(false) }
var query by remember { mutableStateOf&lt;String?&gt;(null) }

SearchBar(
    ...
) {
    listOf("Result 1", "Result 2", "Result 3", "Result 4").forEach { text -&gt;
        ListItem(
            headlineContent = { Text(text) },
            colors = ListItemDefaults.colors(containerColor = Color.Transparent),
            modifier = Modifier.clickable {
                query = text
                expanded = false
            }.fillMaxWidth().padding(horizontal = 16.dp, vertical = 8.dp)
        )
    }
}
</code></pre>

<p>有了此功能，我们现在就能够看到在浮动搜索栏下方显示的推荐。</p>

<p><img src="https://joebirch.co/wp-content/uploads/2025/03/recs.png" alt="Recommendations" /></p>

<p>有了上述内容，我们就可以实现一个浮动搜索栏，向用户显示搜索建议。使用 Material3 SearchBar 可组合项，实现在这两种不同状态之间转换的可组合项非常容易。也许你已经在应用中使用了 SearchBar，或者一直在寻找类似的功能，但无论如何，我期待看到更多应用通过 Jetpack Compose 中更广泛的组件支持来节省时间！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实战：在Compose中优雅地实现提示]]></title>
    <link href="https://alexhilton.github.io/blog/2025/03/28/hints-in-compose/"/>
    <updated>2025-03-28T22:05:00+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/03/28/hints-in-compose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自<a href="https://proandroiddev.com/hints-in-compose-10b6470acc58">Hints in Compose</a>，原文由<a href="https://medium.com/@vitoksmile">Viktor Mykhailiv</a>发布于2025年2月13日，文章内容巨详细，TL;DR;。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0jBirMqQV-aXKXw5gekEkQ.jpeg" title="auto auto" ></a></p>

<!-- more -->


<p>有时我们的应用需要突出显示某些 UI 组件，例如在首次登录（首次使用）时，或者当我们添加新内容（“新功能”）时。</p>

<p>在本文中，我将指导如何构建自定义解决方案来显示提示/工具提示，指向 Compose（Compose Multiplatform 和 Jetpack Compose）中的特定 UI 元素。</p>

<h2>布局层次</h2>

<p>要突出显示 UI 元素，首先我们应该了解“提示”(Hints)的主要概念。
假设我们有一个带有 TopBar、BottomNavigation 和主要操作按钮的应用程序。我们想要突出显示 TopBar 的操作、主要按钮和 BottomNavigation 中的一个项目。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7K0zoXqZM0ajYYZARn6I5w.png" alt="Layout hierarchy" /></p>

<p>对于我们的“提示”，我们需要绘制一个暗淡的背景（也是为了拦截触摸事件），计算突出显示的 UI 元素的位置，剪掉（屏蔽）我们的元素形状以免变暗，最后绘制一个提示（例如带有背景的文本）。</p>

<h2>1. 暗淡的背景</h2>

<p>要在所有内容之上绘制一个暗淡的背景作为覆盖或弹出窗口，我们可以：</p>

<h3>a. 使用自定义可组合项包装我们应用（根组件）的所有内容（例如带有 Modifier.background 的 Box）</h3>

<pre><code class="Kotlin">@Composable
fun AppContent() {
   HintOverlay {
      MaterialTheme {
         Scaffold {
            // 我的应用内容
         }
      }
   }
}
</code></pre>

<h3>b. 使用对话框</h3>

<p>通过使用对话框，我们可以在所有内容之上显示一个覆盖层（例如，在 Android 上，对话框显示在自己的窗口中）。
使用对话框时，Compose Multiplatform 中的 scrimColor 会出现问题。我们无法从 Compose 通用目标配置 scrimColor ，但每个目标（Android 除外）都为 scrimColor 提供了一个实际值。作为一种可能的解决方案，我们可以创建一个例外类来提供对话框属性并为每个目标提供实际实现。</p>

<h3>c. 使用 Popup</h3>

<p>Popup 在这里看起来更好，因为它默认不绘制 scrimColor，并且覆盖层显示在所有内容之上。</p>

<p>我会采用第三种方法，不强制手动使用 HintOverlay。</p>

<p>我还想为覆盖层背景添加 Brush 支持，而不仅仅是 Color 。</p>

<pre><code class="Kotlin">val LocalHintOverlayColor = staticCompositionLocalOf&lt;Color&gt; { Color(0x44000000) }

val LocalHintOverlayBrush = staticCompositionLocalOf&lt;Brush?&gt; { null }

@Composable
fun HintOverlay() {
    Popup {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .overlayBackground()
        ) {
            Text(
                modifier = Modifier.align(Alignment.Center),
                text = "Draw hints here",
                color = Color.White,
            )
        }
    }
}

/**
 * 从 [LocalHintOverlayBrush] 或 [LocalHintOverlayColor] 设置 `background`。
 */
private fun Modifier.overlayBackground(): Modifier = composed {
    LocalHintOverlayBrush.current?.let { background(it) }
        ?: background(LocalHintOverlayColor.current)
}
</code></pre>

<p>我可以使用CompositionLocalProvider 设置 Brush 来覆盖覆盖的背景。</p>

<pre><code class="Kotlin">CompositionLocalProvider(
    LocalHintOverlayBrush provides Brush.linearGradient(
        listOf(
            Color.Red.copy(alpha = 0.5f),
            Color.Blue.copy(alpha = 0.5f),
        )
    ),
) {
    HintOverlay()
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KrHuSNZT0zE-Eddz1GBA2A.png" alt="Dimmed background" /></p>

<h2>2. 计算锚点坐标</h2>

<p>要获取 Compose 中 UI 元素的坐标，我们可以使用OnGloballyPositionedModifier ，当内容的全局位置可能发生变化时，会使用布局的最终​​ LayoutCoordinates 调用该方法。</p>

<p>使用示例：</p>

<pre><code class="Kotlin">Column(
    Modifier.onGloballyPositioned { coordinates -&gt;
        // 这将是Column的大小。
        coordinates.size
        // Column相对于应用程序窗口的位置。
        coordinates.positionInWindow()
        // Column相对于 Compose 根的位置。
        coordinates.positionInRoot()
        // 这些将是提供给布局的对齐线（此处的Column为空）。
        coordinates.providedAlignmentLines
        // 这将是与 Column 的父级相对应的 LayoutCoordinates 实例。
        coordinates.parentLayoutCoordinates
    }
) {
    Box(Modifier.size(20.dp).background(Color.Green))
    Box(Modifier.size(20.dp).background(Color.Blue))
}
</code></pre>

<p>对于我们的提示，我们需要创建一个状态来保存锚点的坐标和大小，并引入一个修改器来更新状态：</p>

<pre><code class="Kotlin">@Stable
class HintAnchorState internal constructor() {

    internal var size: IntSize by mutableStateOf(IntSize.Zero)

    internal var offset: Offset by mutableStateOf(Offset.Zero)
}

@Composable
fun rememberHintAnchorState(): HintAnchorState {
    return remember { HintAnchorState() }
}

fun Modifier.hintAnchor(state: HintAnchorState): Modifier {
    return onGloballyPositioned {
        state.size = it.size
        state.offset = it.positionInWindow()
    }
}
</code></pre>

<p>因此，我们只需订阅所需 UI 元素的大小和坐标变化即可更新锚点的状态。
现在我们需要将此 hintAnchor 修饰符应用于我们的内容：</p>

<pre><code class="Kotlin">val topAppBarActionHintAnchor = rememberHintAnchorState()
val actionHintAnchor = rememberHintAnchorState()
val bottomNavigationHintAnchor = rememberHintAnchorState()

IconButton(
    modifier = Modifier
        .hintAnchor(topAppBarActionHintAnchor),
    onClick = {},
)

Button(
    modifier = Modifier
        .hintAnchor(actionHintAnchor)
        .padding(4.dp),
    onClick = {},
) {
    Text("Action")
}

BottomNavigationItem(
    modifier = Modifier
        .hintAnchor(topAppBarActionHintAnchor),
    //... 传入其他需要的参数
)
</code></pre>

<blockquote><p><strong>注意：</strong> 修饰符顺序在 Compose 中始终很重要，我们在 hintAnchor 后设置 4.dp，以便在此按钮周围留出额外空间（锚点的尺寸将比实际按钮的尺寸大 4.dp）。</p></blockquote>

<p>HintOverlay 可组合项需要进行一些更改才能使用 HintAnchorState为此锚点绘制提示。</p>

<pre><code class="Kotlin">@Composable
fun HintOverlay(
    anchors: () -&gt; List&lt;HintAnchorState&gt;,
) {
    Box(
        modifier = Modifier
            .fillMaxSize()
            .overlayBackground(anchors)
    )
}

/**
 * 从 [LocalHintOverlayBrush] 或 [LocalHintOverlayColor] 设置“background”。
 */
private fun Modifier.overlayBackground(
    anchors: () -&gt; List&lt;HintAnchorState&gt;,
): Modifier = composed {
    val backgroundBrush = LocalHintOverlayBrush.current
    val backgroundColor = LocalHintOverlayColor.current

    drawWithCache {
        onDrawWithContent {
            if (backgroundBrush != null) {
                drawRect(backgroundBrush)
            } else {
                drawRect(backgroundColor)
            }

            anchors().forEach { anchor -&gt;
                drawRect(
                    color = Color.Red,
                    topLeft = anchor.offset,
                    size = anchor.size.toSize(),
                    style = Stroke(width = 5f),
                )
            }

            drawContent()
        }
    }
}
</code></pre>

<p>现在我们只需在锚点周围画一个红色矩形：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EqvV4AHsimwvwZxajIgtXg.png" alt="Anchors" /></p>

<p>但如果我们在移动设备上运行，我们会在 Android 上得到错误的数字：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2wennrPOIcKArOK4MuayAQ.png" alt="With Window Insets" /></p>

<p>该问题与 WindowInsets 有关。让我们减去这些 insets 来修复它：</p>

<pre><code class="Kotlin">fun Modifier.hintAnchor(state: HintAnchorState): Modifier = composed {
    val statusBarInsets = WindowInsets.statusBars.getTop(LocalDensity.current).toFloat()

    onGloballyPositioned {
        state.size = it.size
        state.offset = it.positionInWindow()
            // 修复 Android 上的 WindowInsets
            .minus(Offset(x = 0f, y = statusBarInsets))
    }
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LlrCLPAEgpk7q--X7i3UsA.png" alt="Fixed window insets" /></p>

<h2>3. 剪辑出锚点的形状</h2>

<p>要剪辑形状，我们将使用 Path 和 PathOperation 。修改 hintAnchor Modifier 以接受 Shape ，它将用于在锚点周围设置所需的形状。</p>

<pre><code class="Kotlin">fun Modifier.hintAnchor(
    state: HintAnchorState,
    shape: Shape = RectangleShape,
): Modifier {
    state.shape = shape
    //..onGloballyPositioned
}

@Stable
class HintAnchorState internal constructor() {

    //...其他的状态放这里

    internal var shape: Shape by mutableStateOf(RectangleShape)
}
</code></pre>

<p>根据提供的形状，我们可以创建一个轮廓，用于将锚点的形状从背景中剪掉：</p>

<pre><code class="Kotlin">internal fun Modifier.overlayBackground(
    anchors: () -&gt; List&lt;HintAnchorState&gt;,
): Modifier = composed {
    val backgroundBrush = LocalHintOverlayBrush.current
    val backgroundColor = LocalHintOverlayColor.current
    val layoutDirection = LocalLayoutDirection.current
    val density = LocalDensity.current

    drawWithCache {
        // 准备背景路径
        val path = Path().apply {
            lineTo(size.width, 0f)
            lineTo(size.width, size.height)
            lineTo(0f, size.height)
            lineTo(0f, 0f)
            close()
        }

        anchors().forEach { anchor -&gt;
            // 为锚点准备路径
            val anchorPath = Path()
            anchorPath.addOutline(
                anchor.shape.createOutline(
                    size = anchor.size.toSize(),
                    layoutDirection = layoutDirection,
                    density = density,
                )
            )
            anchorPath.translate(anchor.offset)
            anchorPath.close()

            // 裁剪掉锚点
            path.op(path, anchorPath, PathOperation.Xor)
        }

        onDrawWithContent {
            // 我们不仅仅绘制路径，而不是像以前一样绘制矩形
            if (backgroundBrush != null) {
                drawPath(path, backgroundBrush)
            } else {
                drawPath(path, backgroundColor)
            }

            drawContent()
        }
    }
}
</code></pre>

<p>让我们传递 CircleShape 和 RoundedCornerShape 来看看提示现在是什么样子：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i2dWMv3Wa9at-fzGiKm8KQ.png" alt="Clip" /></p>

<p>此时，我们知道如何绘制背景覆盖层、计算锚点的位置以及如何剪裁背景。</p>

<h2>4. 绘制提示</h2>

<p>在实际绘制之前，我们应该定义提示需要呈现哪些信息。</p>

<p>为了不强制只提供文本，我们采用slot方法。通过定义slot，我们允许使用任何所需的composables。</p>

<p>我将介绍一个新的类 Hint 来保存我们的Composable内容：</p>

<pre><code class="Kotlin">@Stable
class Hint internal constructor() {

    internal var content: @Composable () -&gt; Unit by mutableStateOf({})
}

@Composable
fun rememberHint(content: @Composable () -&gt; Unit): Hint {
    return remember {
        Hint().also { it.content = content }
    }
}
</code></pre>

<p>并将此 Hint 添加为 HintAnchorState 的一部分：</p>

<pre><code class="Kotlin">@Stable
class HintAnchorState internal constructor(
    internal val hint: Hint,
) {
    //...其他的状态放这里
}

@Composable
fun rememberHintAnchorState(hint: Hint): HintAnchorState {
    return remember(hint) {
        HintAnchorState(hint)
    }
}
</code></pre>

<p>在 HintOverlay 内部，我们可以采用最简单的解决方案 — BoxWithConstraints ：</p>

<pre><code class="Kotlin">@Composable
fun HintOverlay(
    anchors: () -&gt; List&lt;HintAnchorState&gt;,
) {
    //...
    BoxWithConstraints(
        modifier = Modifier
            .fillMaxSize()
            .overlayBackground(anchors)
    ) {
        anchors().forEach { anchor -&gt;
            Box(
                modifier = Modifier
                    .graphicsLayer {
                        translationX = anchor.offset.x
                        translationY = anchor.offset.y + anchor.size.height
                    },
            ) {
                anchor.hint.content()
            }
        }
    }
}
</code></pre>

<p>修改应用程序内容：</p>

<pre><code class="Kotlin">val topAppBarHint = rememberHint {
    OutlinedButton(onClick = {}) { Text("Hint for TopAppBar") }
}
val topAppBarActionHintAnchor = rememberHintAnchorState(topAppBarHint)

val actionHint = rememberHint {
    Text("Hint for Action")
}
val actionHintAnchor = rememberHintAnchorState(actionHint)

val bottomNavigationHint = rememberHint {
    Row(
        verticalAlignment = Alignment.CenterVertically,
    ) {
        Spacer(Modifier.size(32.dp).background(Color.Magenta, CircleShape))
        Spacer(Modifier.size(8.dp))
        Text("Hint for BottomNavigation")
    }
}
val bottomNavigationHintAnchor = rememberHintAnchorState(bottomNavigationHint)
</code></pre>

<p>结果如下：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mMenE2fp2jph6YUBlxX4pA.png" alt="Hint for action" /></p>

<p>让我们引入一个应用程序特定的代码来绘制提示背景。</p>

<pre><code class="Kotlin">@Composable
fun rememberHintContainer(content: @Composable () -&gt; Unit): Hint {
    return rememberHint {
        Box(
            modifier = Modifier
                .padding(top = 8.dp)
                .background(Color.Yellow, shape = RoundedCornerShape(16.dp))
                .padding(16.dp),
        ) {
            CompositionLocalProvider(
                LocalTextStyle provides TextStyle(
                    color = Color.Black,
                    fontSize = 12.sp,
                    fontWeight = FontWeight.Light,
                ),
            ) {
                content()
            }
        }
    }
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xn8pxlU_nUQvywbtqVwUtw.png" alt="Hint2" /></p>

<p>我们遇到了 2 个问题：</p>

<ol>
<li>水平对齐，提示应与其锚点居中对齐。</li>
<li>BottomNavigation 的提示超出了屏幕范围。</li>
</ol>


<p>让我们改用自定义布局并修复这些问题。</p>

<p>要测量和布局多个可组合项，请使用 Layout。此composable允许我们手动测量和布局子项。所有更高级别的布局（如 Column 和 Row）都是使用 Layout 实现的。</p>

<pre><code class="Kotlin">@Composable
internal fun HintsContainer(
    modifier: Modifier,
    anchors: () -&gt; List&lt;HintAnchorState&gt;,
) {
    val anchors = anchors()

    Layout(
        modifier = modifier
            .overlayBackground(anchors),
        content = {
            anchors.forEach { it.hint.content() }
        },
    ) { measurables, constraints -&gt;
        // 测量每一个提示
        val placeables = measurables.map { measurable -&gt;
            measurable.measure(
                constraints.copy(minWidth = 0, minHeight = 0)
            )
        }

        // 将布局尺寸设置得尽可能大
        layout(constraints.maxWidth, constraints.maxHeight) {
            // 将每个提示相对于其锚点放置
            placeables.forEachIndexed { index, placeable -&gt;
                val anchor = anchors[index]

                // 将此提示居中对齐
                val x = (anchor.offset.x.toInt() - (placeable.width - anchor.size.width) / 2)
                    // 修复超出屏幕的坐标
                    .coerceAtLeast(0)
                    .coerceAtMost(constraints.maxWidth - placeable.width)

                // 把这个提示放在它的锚点下面
                var y = (anchor.offset.y.toInt() + anchor.size.height)
                    // 如果超出屏幕，则修复 y 坐标
                    .coerceAtMost(constraints.maxHeight - placeable.height)
                if (y &lt; anchor.offset.y + anchor.size.height) {
                    // 提示与锚点重叠，请将此提示放在其锚点上方
                    y = anchor.offset.y.toInt() - placeable.height
                }

                placeable.placeRelative(x = x, y = y)
            }
        }
    }
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*syuJkuAd-_BgiYfFP8bKgQ.png" alt="Hint3" /></p>

<p>因为我们允许传递任何可组合项作为提示，所以调用者可以完全控制提示的外观，例如，我们可以只使用 Text ，或者使用包含许多子项的复杂 Row 。</p>

<h2>5. 如何控制提示？</h2>

<p>我们静态地添加了提示以将其显示在屏幕上。但真正产品应用程序并非如此。让我们引入 HintController 来控制何时显示提示。</p>

<pre><code class="Kotlin">@Stable
class HintController internal constructor() {

    internal var hint by mutableStateOf&lt;HintAnchorState?&gt;(null)

    fun show(hint: HintAnchorState) {
        this.hint = hint
    }
}

@Composable
fun rememberHintController(): HintController {
    val controller = remember { HintController() }

    controller.hint?.let { hint -&gt;
        HintOverlay(anchor = hint)
    }

    return controller
}
</code></pre>

<p>修改应用程序内容，以便在我们点击锚点时显示提示：</p>

<pre><code class="Kotlin">val hintController = rememberHintController()

IconButton(
    modifier = Modifier
        .hintAnchor(topAppBarActionHintAnchor, CircleShape),
    onClick = {
        hintController.show(topAppBarActionHintAnchor)
    },
)

BottomNavigationItem(
    modifier = Modifier
        .hintAnchor(
            bottomNavigationHintAnchor,
            shape = RoundedCornerShape(50f),
        ),
    onClick = {
        hintController.show(bottomNavigationHintAnchor)
    },
)

Button(
    modifier = Modifier
        .hintAnchor(actionHintAnchor, RoundedCornerShape(16.dp))
        .padding(4.dp),
    onClick = {
        hintController.show(actionHintAnchor)
    },
)
</code></pre>

<blockquote><p>注意：我们不再需要显示的 HintOverlay ，它现在变得内置了。</p></blockquote>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jIOTXOSnHVeL_jjyEx1gdg.png" alt="Control" /></p>

<p>现在我们可以逐一显示提示，但还有两个部分缺失：如何关闭提示，以及如何覆盖覆盖颜色。</p>

<p>对提示控制器进行更改以允许传递覆盖颜色：</p>

<pre><code class="Kotlin">@Composable
fun rememberHintController(overlay: Brush): HintController {
    return rememberHintController(overlay = LocalHintOverlayBrush provides overlay)
}

@Composable
fun rememberHintController(overlay: Color = HintOverlayColorDefault): HintController {
    return rememberHintController(overlay = LocalHintOverlayColor provides overlay)
}

@Composable
private fun rememberHintController(overlay: ProvidedValue&lt;*&gt;): HintController {
    val controller = remember { HintController() }

    controller.hint?.let { hint -&gt;
        CompositionLocalProvider(overlay) {
            HintOverlay(anchor = hint)
        }
    }

    return controller
}
</code></pre>

<p>为了消除我们的提示，让我们引入以下变化：</p>

<pre><code class="Kotlin">@Stable
class HintController internal constructor() {

    internal var hint by mutableStateOf&lt;HintAnchorState?&gt;(null)

    fun show(hint: HintAnchorState) {
        this.hint = hint
    }

    fun dismiss() {
        hint = null
    }
}
</code></pre>

<p>我们使用 Popup 作为覆盖层的容器，如果用户点击 Android 上的返回按钮(BACK)，Popup 就会被关闭。</p>

<pre><code class="Kotlin">@Composable
internal fun HintOverlay(
    anchor: HintAnchorState,
    onDismiss: () -&gt; Unit,
) {
    Popup(
        onDismissRequest = onDismiss,
        // 设置可聚焦以处理按压back事件
        properties = remember { PopupProperties(focusable = true) },
    ) {
        //...在这里画出我们的提示
    }
}

@Composable
internal fun HintsContainer(
    modifier: Modifier,
    anchor: HintAnchorState,
    onDismiss: () -&gt; Unit,
) {
    Layout(
        modifier = modifier
            .overlayBackground(anchor)
            .clickable(
                interactionSource = null,
                // 禁用ripple
                indication = null,
                onClick = onDismiss,
            )
    )
}
</code></pre>

<p>结果演示视频 <a href="https://youtu.be/eo49PKlhO5Y">https://youtu.be/eo49PKlhO5Y</a></p>

<p>现在，HintController 允许我们按时间显示一个提示，但如果我们想按顺序显示多个提示，则没有实际的队列。</p>

<p>可以扩展 HintController 并添加暂停修饰符以知道提示的显示时间（例如，在显示提示后立即执行某项操作）。</p>

<pre><code class="Kotlin">@Stable
class HintController internal constructor() {

    private var queue = mutableStateListOf&lt;HintAnchorState&gt;()

    internal val hint: HintAnchorState? get() = queue.firstOrNull()

    private val pendingRequests = mutableMapOf&lt;HintAnchorState, Continuation&lt;Unit&gt;&gt;()

    suspend fun show(hint: HintAnchorState) {
        suspendCoroutine { continuation -&gt;
            pendingRequests[hint] = continuation
            queue.add(hint)
        }
    }

    suspend fun show(vararg hint: HintAnchorState) {
        show(hint.toList())
    }

    suspend fun show(hints: List&lt;HintAnchorState&gt;) {
        suspendCoroutine { continuation -&gt;
            pendingRequests[hints.last()] = continuation
            queue.addAll(hints)
        }
    }

    internal fun onDismissed(hint: HintAnchorState) {
        pendingRequests[hint]?.let { continuation -&gt;
            continuation.resume(Unit)
            pendingRequests.remove(hint)
        }
        queue.remove(hint)
    }

    fun dismiss() {
        pendingRequests.values
            .forEach { continuation -&gt;
                continuation.resumeWithException(CancellationException("Hint was dismissed"))
            }
        pendingRequests.clear()
        queue.clear()
    }
}
</code></pre>

<p>现在为了在应用程序内部显示提示，我们需要一个 CoroutineScope ：</p>

<pre><code class="Kotlin">val coroutineScope = rememberCoroutineScope()
val hintController = rememberHintController()

// 现在我们可以从提示本身中忽略所有待处理的提示
val topAppBarHint = rememberHintContainer {
    OutlinedButton(
        onClick = {
            hintController.dismiss()
        }
    ) { Text("Hint for TopAppBar") }
}

// 显示 1 条提示
BottomNavigationItem(
    onClick = {
        coroutineScope.launch {
            hintController.show(bottomNavigationHintAnchor)
            scaffoldState.snackbarHostState.showSnackbar("One hint was shown")
        }
    },
)

// 连续显示多个提示
Button(
    onClick = {
        coroutineScope.launch {
            hintController.show(
                topAppBarActionHintAnchor,
                actionHintAnchor,
                bottomNavigationHintAnchor,
            )
            scaffoldState.snackbarHostState.showSnackbar("Many hints were shown")
        }
    },
)
</code></pre>

<blockquote><p><strong>注意：</strong> 如果我们通过调用 hintController.dismiss() 来关闭提示，则 hintController.show 之后的代码将不会被调用。</p></blockquote>

<pre><code class="Kotlin">coroutineScope.launch {
    hintController.show(topAppBarActionHintAnchor)
    // 如果通过调用 hintController.dismiss 关闭了之前的提示，则不会显示 Snackbar
    scaffoldState.snackbarHostState.showSnackbar("One hint was shown")
}
</code></pre>

<p>最终结果如这个视频演示 <a href="https://youtu.be/tyZUNJLEVxQ">https://youtu.be/tyZUNJLEVxQ</a>：我们可以显示单个提示，也可以显示提示列表。</p>

<p>由于该项目使用 Compose Multiplatform，我们可以针对不同的目标运行该应用程序：</p>

<ul>
<li>Android结果演示 <a href="https://youtu.be/BVBCipnbIUc">https://youtu.be/BVBCipnbIUc</a></li>
<li>iOS结果演示 <a href="https://youtu.be/Z1uasddgqwo">https://youtu.be/Z1uasddgqwo</a></li>
</ul>


<h2>总结</h2>

<p>Compose 和 Kotlin Multiplatform 是一个强大的组合，它允许我们使用 Kotlin 来实现 UI 和业务逻辑。CMP 库仅与Jetpack Compose Android 项目完全兼容。</p>

<p>可以在 GitHub 上查看我的repo：<a href="https://github.com/vitoksmile/ComposeHints">https://github.com/vitoksmile/ComposeHints</a>。</p>

<p>感谢你的阅读，期待在 GitHub 上获得你的Star :)。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实战：在Compose中绘制睡眠时间线]]></title>
    <link href="https://alexhilton.github.io/blog/2025/03/26/draw-sleep-timeline-graph-in-compose/"/>
    <updated>2025-03-26T21:41:40+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/03/26/draw-sleep-timeline-graph-in-compose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自<a href="https://proandroiddev.com/sleep-timeline-graph-in-compose-15c99f9a4af0">Draw sleep timeline graph in Compose</a>，原文由<a href="https://medium.com/@vitoksmile">Viktor Mykhailiv</a>发布于2025年1月31日。</p></blockquote>

<p><strong>译者按：</strong> 我们在前面的<a href="https://juejin.cn/column/7367555191338467337">降Compose十八掌</a>系列中讲解过在Compose自定义绘制的方法，可以先温习一下<a href="https://juejin.cn/post/7381826917086920742">上一篇文章</a>。这篇文章是提升自定义绘制技巧的一个非常好的实战例子。</p>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OUAsgvNoNx9VpSk9Eyqgzg.jpeg" title="auto auto" ></a></p>

<!-- more -->


<p>当内置组件不能完全满足我们的应用需求时，自定义绘图非常有用。本文提供了创建自定义睡眠时间线图表的指南，类似于你在<a href="https://play.google.com/store/apps/details?id=com.fitbit.FitbitMobile">Fitbit 应用</a>中找到的图表。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cA9uPgAG29Gu2AhajArq9w.jpeg" alt="Screenshots from Fitbit Android app" /></p>

<h2>在 Compose 中如何绘图？</h2>

<p>要开始在 Compose 中绘图，我们可以使用绘图Modifier或 Canvas可组合函数，这为我们提供了 DrawScope — 一种声明式、无状态的API，用于绘制形状和路径，而无需消费者维护底层状态。DrawScope实现还提供了尺寸信息，并且变幻是相对于本地平移完成的。</p>

<blockquote><p><strong>注意：</strong> Jetpack Compose（仅限 Android）和 Compose Multiplatform（桌面、Android、iOS、Web）具有类似的绘图 API。下面的屏幕截图是在桌面（macOS）上制作的，但所有平台上的结果都是相同的（查看最后一张屏幕截图）。</p></blockquote>

<pre><code class="Kotlin">Canvas(modifier = Modifier.fillMaxSize()) {
    rotate(degrees = 45F) {
        drawRect(
            color = Color.Gray,
            topLeft = Offset(x = size.width / 3F, y = size.height / 3F),
            size = size / 3F
        )
    }
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_qkChFEn25kC_cfgiRXgKg.png" alt="Compose中的自定义绘制" /></p>

<h2>啥是睡眠时间表？</h2>

<p>我们可以在 Health Connect 中读取或写入睡眠数据。睡眠数据显示为会话，可分为以下睡眠阶段：</p>

<ul>
<li>清醒：用户在睡眠周期内清醒。</li>
<li>浅睡眠：用户处于浅睡眠周期。</li>
<li>深睡眠：用户处于深睡眠周期。</li>
<li>REM：用户处于 REM 睡眠周期。</li>
</ul>


<p>这些值表示用户在一定时间范围内经历的睡眠类型。SleepSessionRecord 数据类型包含两部分：</p>

<ol>
<li>整个睡眠过程，涵盖整个睡眠时间。</li>
<li>睡眠过程中的各个阶段，例如浅睡眠或深睡眠。</li>
</ol>


<pre><code class="Kotlin">val record = remember {
    SleepSessionRecord(
        startTime = Instant.parse("2025-01-28T21:10:10Z"),
        endTime = Instant.parse("2025-01-29T07:32:13Z"),
        startZoneOffset = UtcOffset(hours = 2),
        endZoneOffset = UtcOffset(hours = 2),
        stages = listOf(
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-28T21:10:10Z"),
                endTime = Instant.parse("2025-01-28T23:15:13Z"),
                type = SleepSessionStageType.Light,
            ),
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-28T23:15:13Z"),
                endTime = Instant.parse("2025-01-29T01:56:32Z"),
                type = SleepSessionStageType.Deep,
            ),
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-29T01:56:13Z"),
                endTime = Instant.parse("2025-01-29T03:16:22Z"),
                type = SleepSessionStageType.Light,
            ),
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-29T03:16:22Z"),
                endTime = Instant.parse("2025-01-29T04:32:13Z"),
                type = SleepSessionStageType.REM,
            ),
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-29T04:32:13Z"),
                endTime = Instant.parse("2025-01-29T05:12:56Z"),
                type = SleepSessionStageType.Deep,
            ),
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-29T05:12:56Z"),
                endTime = Instant.parse("2025-01-29T07:32:13Z"),
                type = SleepSessionStageType.Light,
            ),
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-28T22:11:56Z"),
                endTime = Instant.parse("2025-01-28T22:17:13Z"),
                type = SleepSessionStageType.Awake,
            ),
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-28T22:39:56Z"),
                endTime = Instant.parse("2025-01-28T22:51:13Z"),
                type = SleepSessionStageType.Awake,
            ),
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-29T04:47:56Z"),
                endTime = Instant.parse("2025-01-29T04:54:13Z"),
                type = SleepSessionStageType.Awake,
            ),
        ),
    )
}
</code></pre>

<h2>需要一点数学计算</h2>

<p>在睡眠期间，我们可以在不同时刻多次处于同一阶段。我们需要计算相对于睡眠的起点和终点。</p>

<p>要在 Compose 中绘制矩形，我们需要 topOffset 和 size。</p>

<p><img src="" alt="Math" /></p>

<pre><code class="Kotlin">private fun calculate(
    canvasSize: Size,
    recordStartTime: Instant,
    recordEndTime: Instant,
    stages: List&lt;SleepSessionRecord.Stage&gt;,
): List&lt;SleepStageDrawPoint&gt; {
    val totalDuration = (recordEndTime - recordStartTime).inWholeSeconds.toFloat()
        .coerceAtLeast(1f)

    return stages.map { stage -&gt;
        val stageOffset =
            (stage.startTime - recordStartTime).inWholeSeconds / totalDuration
        val stageDuration =
            (stage.endTime - stage.startTime).inWholeSeconds.toFloat() / totalDuration

        SleepStageDrawPoint(
            topLeft = Offset(x = canvasSize.width * stageOffset, y = 0f),
            size = canvasSize.copy(width = canvasSize.width * stageDuration),
        )
    }
}
</code></pre>

<h2>绘制</h2>

<p>让我们构建自定义 Canvas 来绘制睡眠过程的一个阶段，例如深度睡眠。</p>

<pre><code class="Kotlin">@Composable
fun SleepSessionCanvas(
    modifier: Modifier,
    record: SleepSessionRecord,
) {
    Spacer(
        modifier = modifier.drawWithCache {
            val points = calculate(
                canvasSize = size,
                recordStartTime = record.startTime,
                recordEndTime = record.endTime,
                stages = record.stages.filter { it.type == SleepSessionStageType.Deep },
            )

            onDrawWithContent {
                // 画背景
                drawRoundRect(
                    color = Color.LightGray,
                    topLeft = Offset(x = 0f, y = size.height / 4f),
                    size = size.copy(height = size.height / 2f),
                    cornerRadius = CornerRadius(size.height / 2f),
                )

                // 绘制阶段点
                points.forEach { point -&gt;
                    drawRect(
                        topLeft = point.topLeft,
                        size = point.size,
                        color = Color(0xFF673AB7),
                    )
                }
            }
        }
    )
}
</code></pre>

<p>如果我们使用之前定义的睡眠会话运行项目，我们将看到 3 个矩形：1 个灰色矩形表示背景，2 个紫色矩形表示深度睡眠阶段。</p>

<pre><code class="Kotlin">SleepSessionCanvas(
    modifier = Modifier
        .fillMaxWidth()
        .height(320.dp)
        .padding(16.dp),
    record = record,
)
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ANITvvaUEuuwwcACzY21qA.png" alt="深度睡眠阶段" /></p>

<p>为了绘制睡眠过程的所有阶段（清醒、快速眼动、浅睡眠和深睡眠），我们需要进行一些调整，将每个阶段类型垂直绘制为列组件，办法是逐行绘制并对下一行应用一些偏移量（offset）。</p>

<pre><code class="Kotlin">@Composable
fun SleepSessionCanvas(
    modifier: Modifier,
    record: SleepSessionRecord,
    stageHeight: Dp = 48.dp,
    stagesSpacing: Dp = 16.dp,
) {
    val colors = remember {
        mapOf(
            SleepSessionStageType.Awake to Color(0xFFFF9800),
            SleepSessionStageType.Light to Color(0xFF2196F3),
            SleepSessionStageType.Deep to Color(0xFF673AB7),
            SleepSessionStageType.REM to Color(0xFF795548),
        )
    }

    val stageHeightPx = with(LocalDensity.current) { stageHeight.toPx() }
    val stagesSpacingPx = with(LocalDensity.current) { stagesSpacing.toPx() }

    Spacer(
        modifier = modifier
            .requiredHeight(stageHeight * colors.size + stagesSpacing * (colors.size - 1))
            .drawWithCache {
                val stages = listOf(
                    SleepSessionStageType.Awake,
                    SleepSessionStageType.REM,
                    SleepSessionStageType.Light,
                    SleepSessionStageType.Deep,
                ).map { type -&gt;
                    type to calculate(
                        canvasSize = size.copy(height = stageHeightPx),
                        recordStartTime = record.startTime,
                        recordEndTime = record.endTime,
                        stages = record.stages.filter { it.type == type },
                    )
                }

                onDrawWithContent {
                    var offset = 0f
                    stages.forEach { (type, points) -&gt;
                        translate(top = offset) {
                            // 画背景
                            drawRoundRect(
                                color = Color.LightGray,
                                topLeft = Offset(x = 0f, y = stageHeightPx / 4),
                                size = size.copy(height = stageHeightPx / 2),
                                cornerRadius = CornerRadius(stageHeightPx / 2),
                            )

                            // 绘制阶段点
                            points.forEach { point -&gt;
                                drawRect(
                                    topLeft = point.topLeft,
                                    size = point.size,
                                    color = colors.getValue(type),
                                )
                            }
                        }
                        offset += stageHeightPx + stagesSpacingPx
                    }
                }
            }
    )
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iXIS4tbsvx5AhTtRqlWi7A.png" alt="最终的图形" /></p>

<h3>添加文本</h3>

<p>要在 Compose 中绘制文本，我们通常可以使用 Text 可组合项。但是，在我们的示例中，我们处于 DrawScope 中，我们可以使用 DrawScope.drawText()方法。</p>

<p>绘制文本与其他绘制命令略有不同。通常，我们为绘制命令提供绘制形状/图像的大小（宽度和高度）。对于文本，有几个参数可以控制渲染文本的大小，例如字体大小、字体、连字符和字母间距。我们需要使用 TextMeasurer 来获取文本的测量大小，具体取决于上述因素。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QB1QvINWUWMlpRoPSzrcUQ.png" alt="Desktop效果" /></p>

<p><img src="https://miro.medium.com/v2/resize:fit:2000/format:webp/1*U_LBREiTciw2F3ghYiHqCw.jpeg" alt="Android和iOS效果" /></p>

<p>请到我的Github repo中查找完整示例代码：<a href="https://github.com/vitoksmile/Sleep-timeline-graph">https://github.com/vitoksmile/Sleep-timeline-graph</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[高效地在Jetpack Compose中设计UI组件]]></title>
    <link href="https://alexhilton.github.io/blog/2025/03/16/effective-compose-components/"/>
    <updated>2025-03-16T20:37:18+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/03/16/effective-compose-components</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自<a href="https://proandroiddev.com/designing-effective-ui-components-in-jetpack-compose-cb8d18f7f888">Designing Effective UI Components in Jetpack Compose</a>，原文作者是Jaewoong Eum，原文发布于2025年2月7日。</p></blockquote>

<p><strong>译者按：</strong> 本文适合有一定Jetpack Compose经验的开发者阅读，假定读者熟悉Jetpack Compose的基本使用方法，以及熟悉常见 的Slot设计模式。否则理解上可能会有一些困难。</p>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PwVzAjyhIPGIgrT0" title="auto auto" ></a></p>

<!-- more -->


<p>自<a href="https://android-developers.googleblog.com/2021/07/jetpack-compose-announcement.html"> Google 宣布 Jetpack Compose 1.0 稳定版</a>以来，许多公司都已采用 Jetpack Compose 来利用其众多优势。随着 Compose 在 Android 生态系统中的广泛采用，库和 SDK 也开始集成对 Compose 的支持。</p>

<p>传统上，在基于 XML 的项目中，UI 组件以自定义视图的形式提供，并通过属性（attributes）提供可自定义的选项。虽然这种方法可以轻松地将组件集成到 XML 布局中，但它带来了一些挑战，例如在多个组件之间应用主题样式时不一致，以及由于底层 View 类公开的方法而导致的 API 滥用。</p>

<p>与传统的自定义视图相比，Jetpack Compose 提供了一种完全不同的组件设计策略。其声明式结构允许更直观、更灵活的 API 设计。这种转变不仅有利于库和 SDK 开发人员，也有利于构建共享 UI 组件的大型团队，使他们能够实施更好的做法、减少误用并增强整体开发人员体验。</p>

<p>在本文中，你将发现在 Jetpack Compose 中设计 UI 组件的有效策略，借鉴<a href="https://getstream.io/video/sdk/android/"> Stream Video SDK </a>的最佳实践。</p>

<h2>Modifier的最佳实践</h2>

<p><a href="https://developer.android.com/develop/ui/compose/modifiers">Modifier </a>是 Jetpack Compose 中一个功能强大的 API，可让你以链式和可组合的方式装饰和增强 UI 元素。但是，应谨慎使用它，因为它的属性可以传播到其他可组合函数，如果管理不当，可能会导致意想不到的效果。</p>

<p>Modifier函数的顺序尤其重要，因为每个函数都会修改前一个函数返回的Modifier或从可组合项外部传递的Modifier。此顺序直接影响最终输出。在本节中，我们将探讨三个关键原则和最佳实践，它们可以指导你在 Jetpack Compose 中设计有效且可预测的 UI 组件 API。</p>

<h3>1. 将Modifier应用到组件最顶层的布局</h3>

<p>Jetpack Compose 中的Modifier会通过布局层次结构向下传递，但理想情况下，它们应仅应用于可组合函数中最顶层的布局节点。在层次结构中的任意级别应用Modifier可能会导致意外行为，并增加用户误用的可能性，从而使组件更难以预测且更难以有效使用。</p>

<p>例如，假设你想要创建一个代表圆形按钮的组件，如下例所示：</p>

<pre><code class="Kotlin">@Composable
fun RoundedButton(
  modifier: Modifier = Modifier,
  onClick: () -&gt; Unit
) {
  Button(
    modifier = modifier.clip(RoundedCornerShape(32.dp)),
    onClick = onClick
  ) {
    Text(
      modifier = Modifier.padding(10.dp),
      text = "Rounded"
    )
  }
}
</code></pre>

<p>但是，你不应将 Modifier 应用于 Text ，而应应用于 Button ，后者是布局层次结构中最顶层的可组合函数，如下所示：</p>

<pre><code class="Kotlin">@Composable
fun RoundedButton(
  modifier: Modifier = Modifier,
  onClick: () -&gt; Unit
) {
  Button(
    modifier = Modifier.clip(RoundedCornerShape(32.dp)),
    onClick = onClick
  ) {
    Text(
      modifier = modifier.padding(10.dp), // 别这么干
      text = "Rounded"
    )
  }
}
</code></pre>

<p>自定义可组合函数 RoundedButton 的主要用途是表示 Button ，而不是 Text 。因此，你应避免转移所创建主要组件的焦点或用途。</p>

<p>此外，如果布局层次结构变得复杂，并且你在可组合函数的中间级别应用Modifier，则用户可能很难预测提供的Modifier参数最终会影响哪个组件。这种不明确性可能会导致混淆和误用。</p>

<p>如果你想让用户灵活地修改按钮的内部内容，你可以使用插槽来实现，如下例所示：</p>

<pre><code class="Kotlin">@Composable
fun RoundedButton(
  modifier: Modifier = Modifier,
  onClick: () -&gt; Unit,
  content: @Composable RowScope.() -&gt; Unit
) {
  Button(
    modifier = modifier.clip(RoundedCornerShape(32.dp)),
    onClick = onClick
  ) {
    content()
  }
}
</code></pre>

<h3>2. 对Modifier使用单个参数</h3>

<p>你可能想知道是否可以接受多个 Modifier 参数以应用于布局层次结构中的特定组件，同时限制组件的结构，如下例所示：</p>

<pre><code class="Kotlin">@Composable
fun RoundedButton(
  modifier: Modifier = Modifier,
  textModifier: Modifier = Modifier,
  onClick: () -&gt; Unit,
) {
  Button(
    modifier = modifier.clip(RoundedCornerShape(32.dp)),
    onClick = onClick
  ) {
    Text(
      modifier = textModifier.padding(10.dp),
      text = "Rounded"
    )
  }
}
</code></pre>

<p>但是，Modifier 本质上被设计为一个单一的、可链接的参数，使用户能够定义 Composable 函数的外部行为和外观。在 Composable 中引入多个 Modifier 参数会增加不必要的复杂性，增加误用的风险，并且偏离了 Jetpack Compose 保持 API 直观和可预测的原则。</p>

<p>最好使用基于插槽的方法，让用户能够灵活地自定义内部内容。例如，你可以定义一个插槽（slot），让用户提供自定义内容，同时仍保留单个Modifier以进行外部自定义，而不是添加多个Modifier参数。</p>

<pre><code class="Kotlin">@Composable
fun RoundedButton(
  modifier: Modifier = Modifier,
  onClick: () -&gt; Unit,
  content: @Composable RowScope.() -&gt; Unit
) {
  Button(
    modifier = modifier.clip(RoundedCornerShape(32.dp)),
    onClick = onClick
  ) {
    content()
  }
}
</code></pre>

<h3>3. 避免跨组件重复使用Modifier</h3>

<p>设计组件时的另一个重要考虑因素是避免重复使用提供的 Modifier 实例。一些开发人员可能会担心为每个组件创建新的 Modifier 实例可能会导致内存使用量增加或对性能产生负面影响，尤其是在具有大量Modifier的复杂布局层次结构中。</p>

<p>然而，由于 Jetpack Compose 中Modifier实现的优化性质，这种担忧通常是没有根据的。Modifier旨在应用于可组合函数中的单个布局节点，以确保行为清晰且可预测。如果在布局层次结构中不同级别的多个可组合项中使用相同的Modifier，则可能导致意外的副作用和不可预测的行为，从而损害组件的一致性和可用性。</p>

<p>例如，考虑这样一种情况，其中相同的 Modifier 参数在整个布局层次结构中重复使用，如下例所示：</p>

<pre><code class="Kotlin">@Composable
fun MyButtons(
  modifier: Modifier = Modifier,
  onClick: () -&gt; Unit,
) {
  Column(modifier = modifier) {
    Button(
      modifier = modifier,
      onClick = onClick
    ) {
      Text(
        modifier = modifier.padding(10.dp),
        text = "Rounded"
      )
    }

    Button(
      modifier = modifier,
      onClick = onClick
    ) {
      Text(
        modifier = modifier.padding(10.dp),
        text = "Not Rounded"
      )
    }
  }
}
</code></pre>

<p>乍一看，代码似乎运行正常。但是，当你在调用点修改Modifier时，你会注意到意外的行为，可能会以意想不到的方式改变整个布局。</p>

<pre><code class="Kotlin">MyButtons(
  modifier = Modifier
    .clip(RoundedCornerShape(32.dp))
    .background(Color.Blue)
) {}
</code></pre>

<p>为了确保行为正确并避免意外问题，你应避免在多个组件中重复使用Modifier。在本节中，你了解了在设计 Compose 组件时管理Modifier的最佳实践。接下来，让我们通过实现主题来深入了解如何提供一致的 UI 样式。</p>

<h2>主题确保 UI 一致性</h2>

<p>现在，假设你需要提供多种 Compose 组件，这些组件应共享一致的样式。如果这些组件是独立提供的，那么维护这些组件之间一致样式的责任就完全落在用户身上。这可能非常具有挑战性，因为每个组件可能会公开不同的 API 来自定义其样式，从而使同步变得繁琐且容易出错。</p>

<p>在这种情况下，你可以从 Compose Material 库提供的<a href="https://developer.android.com/develop/ui/compose/designsystems/material3#material-theming"> MaterialTheme API </a>中汲取灵感。关键在于确保组件样式一致，同时允许用户无缝自定义并在各个组件之间保持一致的样式。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*AyJL0G8NsCGWX9_Q" alt="Theming Consistency" /></p>

<p>Compose 的<a href="https://getstream.io/video/sdk/"> Stream Video SDK </a>通过提供名为<a href="https://getstream.io/video/docs/android/ui-components/video-theme/"> VideoTheme </a>的专用主题 API 展示了最佳实践。此 VideoTheme API 可确保 SDK 提供的所有 Compose 组件的样式一致，包括颜色、尺寸、排版、形状、涟漪效果等。</p>

<pre><code class="Kotlin">setContent {
    VideoTheme(
        colors = StreamColors.defaultColors().copy(appBackground = Color.Black),
        dimens = StreamDimens.defaultDimens().copy(callAvatarSize = 72.dp),
        shapes = StreamShapes.defaultShapes().copy(
            avatar = RoundedCornerShape(8.dp),
            callButton = RoundedCornerShape(16.dp),
            callControls = RectangleShape,
            callControlsButton = RoundedCornerShape(8.dp)
        )
    ) {
        CallContent(
            modifier = Modifier.fillMaxSize(),
            call = call,
            onBackPressed = { finish() },
        )
    }
}
</code></pre>

<p>通过将 Stream SDK 提供的组件与 VideoTheme 包装在一起（如上例所示），自定义样式将自动一致地应用于所有组件。这种方法使用户能够轻松保持其 UI 的一致性，同时调整主题以满足其应用程序的设计要求。</p>

<h3>实现自定义主题</h3>

<p>让我们深入研究如何实现自定义主题。第一步是定义设计规范，这些规范将在你的组件之间共享或为用户提供自定义功能。考虑包括颜色、形状和尺寸等方面，因为这些通常是确保设计系统一致性的最重要因素。</p>

<p>例如，在 Stream SDK 中，组件所需的所有颜色集均在<a href="https://github.com/GetStream/stream-video-android/blob/c12db8cb6367e10682be3ab323d50dfcc59032f3/stream-video-android-ui-compose/src/main/kotlin/io/getstream/video/android/compose/theme/StreamColors.kt#L24"> StreamColors </a>类中预定义，为用户提供了一种无缝的方式来保持其整个 UI 的一致性。以下是 Stream SDK 如何通过结构良好的颜色集确保一致性的示例：</p>

<pre><code class="Kotlin">public data class StreamColors(
    val brandPrimary: Color,
    val brandPrimaryLt: Color,
    val brandPrimaryDk: Color,
    val brandSecondary: Color,
    val brandSecondaryTransparent: Color,
    val brandCyan: Color,
    val brandGreen: Color,
    val brandYellow: Color,
    ..
  )
</code></pre>

<p>接下来，你应该创建一个<a href="https://developer.android.com/develop/ui/compose/compositionlocal"> CompositionLocal </a>来保存设计规范。这将允许你的组件和用户通过使用 StreamTheme.colors 调用在自定义主题的上下文中无缝访问这些规范。</p>

<p><strong>译注：</strong> CompositionLocal是Compose中用于在上下文函数调用中，隐式的传递常量性质参数的方法，可以参考这篇文章<a href="https://juejin.cn/post/7434543407636267071">用Compose中的CompositionLocal来暗渡陈仓</a>，以了解CompositionLocal的详细用法。</p>

<pre><code class="Kotlin">/**
 * Local providers for various properties we connect to our components, for styling.
 */
private val LocalColors = compositionLocalOf&lt;StreamColors&gt; {
    error("No colors provided! Make sure to wrap all usages of Stream components in a VideoTheme.")
}

public interface StreamTheme {
    /**
     * Retrieves the current [StreamColors] at the call site's position in the hierarchy.
     */
    public val colors: StreamColors
        @Composable @ReadOnlyComposable
        get() = LocalColors.current
}
</code></pre>

<p>然后，你需要利用<a href="https://developer.android.com/develop/ui/compose/compositionlocal"> CompositionLocal </a>将这些设计规范封装在自定义主题中。这种方法允许你在整个可组合层次结构中高效地提供和传播你的设计规范。</p>

<pre><code class="Kotlin">public fun VideoTheme(
    isInDarkMode: Boolean = isSystemInDarkTheme(),
    colors: StreamColors = StreamColors.defaultColors(),
    content: @Composable () -&gt; Unit,
) {
    CompositionLocalProvider(
        LocalColors provides colors,
    ) {
        content()
    }
}
</code></pre>

<p>现在，你的所有组件都应假设它们都包含在自定义主题（例如本例中的 VideoTheme）中，并使用提供的设计规范来确保整个组件集的样式一致。这种方法不仅使你的组件 API 能够采用统一的样式，还允许用户利用这些设计规范进行自定义，从而同时提高灵活性和一致性。</p>

<pre><code class="Kotlin">@Composable
fun VideoRendererCallContent(
    call: Call,
    video: ParticipantState.Video,
    onRendered: (View) -&gt; Unit = {},
) {
    VideoRenderer(
        modifier = Modifier
            .fillMaxSize()
            .background(VideoTheme.colors.baseSheetTertiary), // use pre-defined color styles
        call = call,
        video = video,
        onRendered = onRendered,
    )
}

@Composable
fun MyScreen() { 

  VideoRendererCallContent(..)

  // some complicated components
}

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

         setContent {
            VideoTheme {
               MyScreen()
            }
         }
}
</code></pre>

<p>这种方法不仅对于实现 API（库或 SDK）有效，对于构建应用程序也同样有效，因为它能够使用结构良好、预定义的设计规范轻松维护设计一致性。对于实际示例和实际用例，你可以在<a href="https://github.com/GetStream/stream-video-android/blob/c12db8cb6367e10682be3ab323d50dfcc59032f3/stream-video-android-ui-compose/src/main/kotlin/io/getstream/video/android/compose/theme/VideoTheme.kt"> GitHub </a>上探索实际最佳实践。</p>

<h2>可定制性</h2>

<p>在实现 UI 组件时，尤其是对于库或 SDK，为 UI 和 UX 行为提供强大的自定义和灵活性至关重要。这可确保用户可以轻松重复使用组件并根据其特定要求进行调整。你可以采用各种策略在 Jetpack Compose 中有效地实现这种级别的可定制性。</p>

<h3>1. 利用样式类</h3>

<p>如果你希望为特定组件提供更具针对性的定制，请考虑提供专用的样式类。此类可以定义并允许用户轻松修改组件的 UI 和 UX 行为以满足他们的特定需求。</p>

<p>一个很好的例子是 TextStyle ，它是 Compose UI 库提供的默认类：</p>

<pre><code class="Kotlin">@Immutable
class TextStyle internal constructor(
  ..
) {
    constructor(
        color: Color = Color.Unspecified,
        fontSize: TextUnit = TextUnit.Unspecified,
        fontWeight: FontWeight? = null,
        fontStyle: FontStyle? = null,
        fontSynthesis: FontSynthesis? = null,
        fontFamily: FontFamily? = null,
        ..
     )
}
</code></pre>

<p>如上面的代码所示，TextStyle 类封装了 Text 可组合项的所有样式属性。只需将 TextStyle 实例传递给 Text 可组合项，你就可以轻松自定义其设计，如下例所示：</p>

<pre><code class="Kotlin">Text(
    modifier = Modifier
        .fillMaxWidth()
        .padding(top = 16.dp),
    text = "Stats",
    style = TextStyle(
        fontSize = 16.sp,
        lineHeight = 24.sp,
        fontWeight = FontWeight(600),
        color = Color.White,
        textAlign = TextAlign.Center,
    ),
)
</code></pre>

<p>使用样式类的优点是，它们允许组件开发人员将所有设计规范整合到一个集中的类中。这种方法可以防止设计元素分散在多个布局中，从而使代码库更简洁、更易于管理。</p>

<p>对于用户来说，样式类提供了一种直接且直观的修改设计的方法。此外，用户可以在多个布局中重复使用相同的样式实例，从而更方便地在不同布局中应用一致的自定义。</p>

<p>一个潜在的缺点是，由于<a href="https://getstream.io/blog/jetpack-compose-stability/#jetpack-compose-phases">重组机制（Recomposition）</a>，每当输入发生变化时，Compose 运行时都会比较样式类的所有属性，以确定是否需要重组。与直接在可组合函数中定义单个参数相比，这使其成本略高。然而，从 API 设计的角度来看，改进的用户体验和简化的 API 管理通常超过了这一成本，因此在许多情况下，这是一种值得的权衡。</p>

<h3>2. 借助插槽（Slots）的灵活性</h3>

<p>增强自定义灵活性的另一种有效策略是提供接受可组合函数的插槽，让用户根据自己的需求定义特定的实现。通过提供默认实现，你可以确保用户无需付出额外努力即可利用所提供的功能，同时仍然可以根据需要进行自定义。</p>

<p>例如，Stream Video SDK 提供的 CallContent 组件是一个高级 API，它集成了多个子组件，包括顶部应用栏、视频渲染器、布局结构、网格参与者等。虽然 CallContent API 包含默认实现以方便使用，但它还通过允许通过插槽参数进行自定义来确保灵活性，如以下代码所示：</p>

<pre><code class="Kotlin">fun CallContent(
    call: Call,
    modifier: Modifier = Modifier,
    style: VideoRendererStyle = RegularVideoRendererStyle(),
    appBarContent: @Composable (call: Call) -&gt; Unit = {
        CallAppBar(..)
    },
    videoRenderer: @Composable (..) -&gt; Unit = {
        ParticipantVideo(..)
    },
    videoContent: @Composable RowScope.(call: Call) -&gt; Unit = {
        ParticipantsLayout(..)
    },
) {
  ..
}
</code></pre>

<p>这种方法允许用户实现自己的顶部应用栏、视频渲染器、布局结构、网格参与者等自定义版本。此外，另一种有效的策略是将相似类型的组件分组，并通过插槽使它们可自定义，这通常称为复合组件模式。</p>

<p>复合组件模式涉及创建一个父组件来管理子组件集合，通过为每个子组件公开插槽来提供自定义。此模式允许用户替换或自定义单个子组件，同时保持整体结构和功能的一致性。</p>

<p>想象一下视频通话屏幕上的控制面板包含多个操作按钮，如下图所示：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:886/format:webp/0*mNh-EWJlyCobHHed" alt="Control Panel" /></p>

<p>有些用户可能喜欢不同的操作按钮顺序，例如将麦克风按钮放在第一位，而其他用户可能希望根据其特定用例添加、删除或自定义按钮。在这种情况下，复合组件模式被证明在满足这些不同的要求方面非常有效，例如下面的代码：</p>

<pre><code class="Kotlin">@Composable
public fun ControlActions(
    call: Call,
    modifier: Modifier = Modifier,
    actions: List&lt;(@Composable () -&gt; Unit)&gt;
) {
    Box(
        modifier = modifier,
    ) {
        LazyRow(
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(
                VideoTheme.dimens.spacingM,
                Alignment.CenterHorizontally,
            ),
        ) {
            items(actions) { action -&gt;
                action.invoke()
            }
        }
    }
}
</code></pre>

<p>上面的代码演示了一个接受 Composable 函数列表的单个插槽，然后使用 Row 或 LazyRow 进行渲染。这种方法允许你提供高度灵活的组件 API，同时保持对组件布局预期结构的控制。</p>

<p>之后，你还可以提供默认实现，如下所示，以增加便利性。</p>

<pre><code class="Kotlin">@Composable
public fun buildDefaultCallControlActions(
    onCallAction: (CallAction) -&gt; Unit,
): List&lt;@Composable () -&gt; Unit&gt; {

    return listOf(
        {
            ToggleCameraAction(
                onCallAction = onCallAction,
            )
        },
        {
            ToggleMicrophoneAction(
                onCallAction = onCallAction,
            )
        },
        {
            FlipCameraAction(
                onCallAction = onCallAction,
            )
        },
    )
}

@Composable
public fun ControlActions(
    call: Call,
    modifier: Modifier = Modifier,
    onCallAction: (CallAction) -&gt; Unit = { DefaultOnCallActionHandler.onCallAction(call, it) },
    actions: List&lt;(@Composable () -&gt; Unit)&gt; = buildDefaultCallControlActions(onCallAction)
) {
}
</code></pre>

<p>如需了解更多<a href="https://getstream.io/video/docs/android/ui-components/call/call-controls/"> ControlActions </a>的真实示例，你可以探索<a href="https://github.com/GetStream/stream-video-android/blob/c12db8cb6367e10682be3ab323d50dfcc59032f3/stream-video-android-ui-compose/src/main/kotlin/io/getstream/video/android/compose/ui/components/call/controls/ControlActions.kt#L48"> GitHub </a>上的实现。</p>

<h3>3. 使用主题进行定制</h3>

<p>设计 Compose 组件时的另一个常见挑战是，随着组件层次结构的变大，提供清晰、直接的可定制性变得更加困难。例如，假设你想为组件多个部分使用的视频渲染器提供可定制性，但 UI 层次结构嵌套很深且很复杂，如下例所示：</p>

<pre><code class="Kotlin">@Composable
fun CallContent() {
    ParticipantsLayout {
      ParticipantsRegularGrid {
        OrientationVideoRenderer {
          LazyVerticalGrid {
            VideoRenderer() // &lt;-- users want to customize this renderer style
          }
        }
      }

      FloatingVideoRenderer {
        VideoRenderer() // &lt;-- users want to customize this renderer style
      }
    }
}
</code></pre>

<p>在这种情况下，将插槽或样式参数从最顶层的组件一直传递到 VideoRenderer 组件并不理想。随着你在不同组件之间添加更多可定制性，最顶层的组件 (CallContent) 可能会因大量插槽和样式参数而变得过载。这不仅使你的 API 更难维护，而且还增加了用户混淆或误用的可能性，因为不清楚哪个参数用于什么用途。</p>

<p>为了解决这个问题，你可以利用自定义主题和<a href="https://developer.android.com/develop/ui/compose/compositionlocal"> CompositionLocal</a>来实现可定制性，同时保持 API 更清晰、更易于管理，如下例所示：</p>

<pre><code class="Kotlin">@Immutable
public data class VideoRendererStyle(
    val backgroundColor: Color = Color.Black,
    ..
)

private val LocalVideoRendererStyle = compositionLocalOf&lt;VideoRendererStyle&gt; {
    error("No VideoRendererStyle provided! Make sure to wrap all usages of Stream components in a VideoTheme.")
}

@Composable
public fun VideoTheme(
    videoRendererStyle: VideoRendererStyle = VideoRendererStyle(),
    content: @Composable () -&gt; Unit,
) {
    CompositionLocalProvider(
        LocalVideoRendererStyle provides videoRendererStyle,
    ) {
        content()
    }
}
</code></pre>

<p>现在，你可以通过在不同的组件中使用提供的样式来确保组件样式的一致性，而无需将它们作为参数反复传递。此外，用户可以通过创建自己的自定义主题轻松自定义样式，如下例所示：</p>

<pre><code class="Kotlin">setContent {
    VideoTheme(
        videoRendererStyle = VideoRendererStyle(backgroundColor = Color.Blue)
    ) {
      ..
    } 
}
</code></pre>

<p>如果你希望更广泛地应用此策略并高效地管理更多样式，则可以将它们合并为一个类，例如 StreamStyles ，并提供统一的样式类，而不是 CompositionLocal 中的多个单独样式。有些同学可能会担心 CompositionLocal 带来的性能影响，因为它会在值更改时触发布局层次结构的重组，但主题通常不会在应用程序中频繁更新。它们通常是静态的，以确保设计一致性，因此在这种情况下使用 CompositionLocal 是一种合适且有效的选择。</p>

<h2>预览（Preview）的兼容性</h2>

<p>提供预览非常重要，尤其是在构建组件 API 时，因为它们允许开发人员直接在 Android Studio 中可视化和验证他们的 UI 设计。
一些同学依靠<a href="https://developer.android.com/develop/ui/compose/tooling#live-edit-literals"> Live Literals </a>来动态展示预览中的变化，而其他同学则使用屏幕截图测试来确保其组件的视觉一致性。因此，在实现 Compose 组件时，必须确保它们与 Android Studio 中的预览功能完全兼容，如下面的屏幕截图所示：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*R74xLmTnWswi86ww" alt="Preview" /></p>

<p>有时，你的组件可能会产生副作用，例如在发出网络请求或处理动态状态后渲染图像，这可能会导致预览出现故障。在这种情况下，你可以利用<a href="https://developer.android.com/develop/ui/compose/tooling/previews#localinspectionmode"> LocalInspectionMode</a>。</p>

<p>LocalInspectionMode 允许你确定可组合项是否在预览模式下呈现，从而使你可以呈现专门用于预览目的的专用布局。这种方法可确保预览保持功能，即使你的组件依赖于复杂的逻辑或外部资源。你可以从<a href="https://github.com/skydoves/landscapist"> Landscapist </a>中找到一个用于网络图像加载的 Jetpack Compose 库的真实示例，它演示了处理预览的最佳实践。</p>

<p>下面的可组合函数会检查它是否处于预览模式。如果是，它会渲染静态图像，而不是执行诸如获取网络数据之类的副作用。这种方法允许用户为 GlideImage 可组合函数构建自己的预览，而不会在预览渲染期间遇到运行时错误。</p>

<pre><code class="Kotlin">@Composable
public fun GlideImage(
  imageModel: () -&gt; Any?,
  modifier: Modifier = Modifier,
  previewPlaceholder: Painter? = null,
  ..
) {
  if (LocalInspectionMode.current &amp;&amp; previewPlaceholder != null) {
      Image(
        modifier = modifier,
        painter = previewPlaceholder,
        ..
      )
      return
  }

  // complex logic about requesting network data and render it
  ..
)
</code></pre>

<p>为了增强项目中的整体预览策略，请考虑探索<a href="https://getstream.io/blog/effective-compose-preview/">设计有效的 UI 以增强 Compose 预览</a>。此资源提供了有价值的见解和技术，可有效优化你的 Compose 预览。</p>

<h2>结论</h2>

<p>在本文中，我们探讨了在 Jetpack Compose 中制作有效 UI 组件的策略，重点关注最佳实践，例如高效处理Modifier、确保设计与主题一致、实施可定制性策略以及增强预览兼容性。设计直观且强大的 API 始终是一项挑战，但努力终将获得回报，因为用户体验和开发者满意度显著提升。</p>

<p>如果你对本文有任何疑问或反馈，可以在 Twitter<a href="https://twitter.com/github_skydoves"> @github_skydoves </a>或<a href="https://github.com/skydoves"> GitHub </a>上找到作者。如果你想随时了解 Stream 的最新动态，请在 Twitter 上关注我们<a href="https://twitter.com/getstream_io"> @getstream_io</a>，获取更多精彩的技术内容。</p>

<p>老规矩，祝你编码愉快！ &ndash; <a href="https://github.com/skydoves">Jaewoong</a></p>

<p>最初<a href="https://getstream.io/blog/designing-effective-compose/">发布于 GetStream.io</a>。</p>
]]></content>
  </entry>
  
</feed>
