<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2023-12-11T20:59:16+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[让你从此不再惧怕ANR]]></title>
    <link href="http://toughcoder.net/blog/2023/12/08/android-anr-made-easy/"/>
    <updated>2023-12-08T22:12:55+08:00</updated>
    <id>http://toughcoder.net/blog/2023/12/08/android-anr-made-easy</id>
    <content type="html"><![CDATA[<blockquote><p>这篇文章是基于官方的<a href="https://developer.android.com/topic/performance/anrs/diagnose-and-fix-anrs">Diagnose and fix ANRs</a>翻译而来，但也不是严格的翻译，原文的内容都在，又加上了自己的理解以及自己的经验，以译注的形式对原文的作一些补充。</p></blockquote>

<hr />


<p>当一个Android应用的UI线程被阻塞时间过长，系统就会发出一个臭名昭著的“应用程序未响应”(ANR, Application Not Responding&#8221;)错误。本文将讲述不同类型的ANR，如何分析以及如何解决。文中列出的所有的超时时间范围都是基于<a href="https://source.android.com/">AOSP</a>和Pixel设备；这些时间范围可能会依OEM厂商而不同。</p>

<p><a href=""><img src="https://ts1.cn.mm.bing.net/th/id/R-C.b5cd953e9f33003456314ae6608fcecc?rik=pPBn5R3rPZ83ew&amp;riu=http%3a%2f%2fiotts.com.cn%2fblog%2fimages%2fAndroid_a.jpg&amp;ehk=qj91EEfUUgZ32njo8AfBJIdOoPJYInW%2b7chI6g6Jxqs%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" title="auto auto" ></a></p>

<!-- more -->


<p>需要注意的是，当分析ANR的根因时，区分<strong>系统原因</strong>和<strong>应用本身的原因</strong>是很有帮助的。
当整个系统处于一个糟糕状态时，下面这些问题可能会引发ANR：</p>

<ul>
<li>系统服务内部的一些瞬时问题(Transient issues)就会导致通常很快的binder call变得非常慢。</li>
<li>系统服务的问题以及较高的系统负载会导致应用程序的线程无法被正常的调度。</li>
</ul>


<blockquote><p><strong>译注：</strong><a href="https://learn.microsoft.com/en-us/azure/architecture/best-practices/transient-faults">瞬时问题Transient issue</a>是指一些服务运行时出现了一些瞬时的小错误比如服务器的网络抽风(闪断又闪连)，或者一个系统服务的I/O错误，但可能会导致客户无法正常的获得响应。这里要这样来理解，服务(servers)一般都是长时间运行的，它是有可能会发生一些小错误的，瞬时的很快就恢复了，但如果客户恰好在此时来请求就不会得到响应。尽管这对于服务来说是一个可以忽略的小错误，毕竟它是长时间运行的，几秒钟的小错误不影响它本身的运行，但对客户侧的影响却是较大，对客户侧来说就是请求得不到响应。</p></blockquote>

<p>如果可以的话，区分系统问题还是应用问题的好方法就是使用<a href="https://perfetto.dev/docs/">Perfetto traces</a>:</p>

<ul>
<li>通过查看在Perfetto跟踪的是运行中还是未运行的线程的状态来判断应用的主线程有没有被正常的调度。</li>
<li>查看系统进程system_server的线程，看有没有锁竞争之类的问题。</li>
<li>对于耗时的(跨进程调用)binder calls，查看一下是否存在应答进程，以及为何它会耗时。</li>
</ul>


<blockquote><p><strong>译注：</strong>很多重要的系统服务都在system_server进程里面，如负责创建调度所有组件的<a href="https://android.googlesource.com/platform/frameworks/base/+/4f868ed/services/core/java/com/android/server/am/ActivityManagerService.java">AMS(Activity Manager Service)</a>，包管理<a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/services/core/java/com/android/server/pm/PackageManagerService.java">PMS(Package Manager Service)</a>，窗口管理<a href="https://android.googlesource.com/platform/frameworks/base/+/android-4.3_r2.1/services/java/com/android/server/wm/WindowManagerService.java">WMS(Window Manager Service)</a>等等，system_server进程本来的load其实不轻。再加上很多OEM定制化的功能也必须要在AMS处做事情（如hook或者拦截），导致system_server并不比应用程序少引发问题，而一旦system_server有耗时操作或者在等待锁，会导致整个系统处于极度卡顿状态，这时事件的派发，组件的创建，生命周期的调度，以及WMS的焦点处理等等正常的逻辑都不可能得到及时的流转和响应。这种时候任何一个应用都可能随时发生ANR，但应用本身却都是idle状态，问题是在system_server这一侧。</p>

<p><a href="https://developer.android.com/reference/android/os/Binder">Binder</a>是安卓系统的核心基础通信机制，组件件间的通信，Intent，ContentResolver，应用与AMS，PMS和WMS等等之间的交互都是通过binder call来进行的，常规情况下大部分时候binder call都没有问题会很快问题，但如果binder另一头的某个服务发生了问题，即使是瞬时问题，也会导致binder call被阻塞或者变慢，这时就可能引发应用侧的ANR。</p>

<p>需要厘清概念，系统服务(services)与进程并不是同一回事，也不是一一对应的关系。系统服务是安卓系统架构上的模块，都分布于框架层，支撑着系统的运转。而进程则是CPU（准确的说是操作系统内核）运行和调度的基本单元（进程则再细分为线程）。一个系统服务可能独立占用一个进程，比如像<a href="https://cs.android.com/android/platform/superproject/+/master:packages/providers/MediaProvider/src/com/android/providers/media/MediaService.java">Media Service(mediaserver)</a>，<a href="https://source.android.com/docs/core/camera">CameraService(cameraserver)</a>，也可能会生成几个进程；当然 也有可能几个服务都在同一个进程里面，比如前面提到的与应用程序最为密切相关的三大服务AMS, WMS和PMS。当一个服务必须要有独立进程的时候，就会为它创建独立的进程，比如像CameraService，在Android O以前是没有独立进程的，它活在mediaserver里，后来才有独立的进程cameraserver。</p>

<p>服务是架构上的逻辑概念，而进程和线程是从硬件（CPU）角度看到的代码的执行。ANR是由于进程（准确的说是线程，进程由至少一个线程组成）卡顿或者被阻塞导致的。调试的手段也都是从代码执行的角度，把线程的栈帧转储出来(stack trace dump)，以查看是被哪 个函数阻塞了。</p></blockquote>

<h2>输入派发超时(Input dispatch timeout)</h2>

<p>输入派发无响应发生在应用的主线程无法及时地响应一个输入事件，如滑动手势或者物理按键。因为当输入派发超时发生时应用是在前台的，所以这类超时总是对用户可见的，所以想办法规避是很重要的。</p>

<p><strong>默认超时时间：5秒</strong></p>

<p>输入派发超时无响应通常是由于主线程的问题引起的。如果主线程因为等待获取某个锁而阻塞，锁的持有线程也包含在内。遵循以下最佳实践以防止输入派发未响应：</p>

<ul>
<li>主线程不要进行可能会阻塞或者耗时的操作。可以考虑使用<a href="https://developer.android.com/reference/android/os/StrictMode">严格模式StrictMode</a>来捕捉主线程的一些异常的行为。</li>
<li>尽可能的减少主线程和其他线程之间的锁竞争。</li>
<li>在主线程尽可能减少非UI相关的操作，比如当处理广播(Broadcasts)时或者处理服务时(Services)。</li>
</ul>


<h3>常见的根因</h3>

<p>这里列出一些输入派发无响应常见的根因以及修复建议。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 根因 </th>
<th style="text-align:left;"> 表象 </th>
<th style="text-align:left;"> 修复建议 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 耗时跨进程调用slow binder call </td>
<td style="text-align:left;"> 主线程执行了一个耗时同步binder call </td>
<td style="text-align:left;"> 把这个调用放到非主线程，或者优化一下这个调用，如果你负责这个API的话 </td>
</tr>
<tr>
<td style="text-align:left;"> 很多连续的binder calls </td>
<td style="text-align:left;"> 主线程执行了很多连续的跨进程调用 </td>
<td style="text-align:left;"> 不要在一个密集的循环中执行binder call </td>
</tr>
<tr>
<td style="text-align:left;"> 阻塞式的I/O </td>
<td style="text-align:left;"> 主线程执行了阻塞式的I/O，如数据库操作或者网络请求 </td>
<td style="text-align:left;"> 把所有阻塞式I/O调用放到非主线程里 </td>
</tr>
<tr>
<td style="text-align:left;"> 锁竞争 </td>
<td style="text-align:left;"> 主线程因为等待获取某个锁而阻塞 </td>
<td style="text-align:left;"> 减少主线程与其他线程之间的锁竞争，优化其他线程中的耗时代码 </td>
</tr>
<tr>
<td style="text-align:left;"> 耗时的帧 </td>
<td style="text-align:left;"> 在一帧里面做太多的渲染，导致严重的丢帧 </td>
<td style="text-align:left;"> 减少帧渲染的工作。不要用超过O(n<sup>2</sup>)的算法。用一些高效的组件来进行滑动和分页，比如<a href="https://developer.android.com/jetpack">Jetpack</a>中的<a href="https://developer.android.com/topic/libraries/architecture/paging/v3-overview">Paging library</a> </td>
</tr>
<tr>
<td style="text-align:left;"> 被其他组件阻塞 </td>
<td style="text-align:left;"> 其他的组件比如广播接收器(BroadcastReceiver)正在运行并阻塞着主线程 </td>
<td style="text-align:left;"> 主线程尽量不要做非UI操作，另起一个线程运行broadcast receivers </td>
</tr>
<tr>
<td style="text-align:left;"> GPU挂起 </td>
<td style="text-align:left;"> GPU挂起是一个系统问题或者硬件问题，会导致渲染被阻塞，因此也会引发输入派发ANR </td>
<td style="text-align:left;"> 很不幸的是在应用程序侧是无法搞定这个问题的。唯一的可能就是联系对应厂商。</td>
</tr>
</tbody>
</table>


<p><br /></p>

<h3>如何调试</h3>

<p>通过查看在Google Play Console和Firebase Crashlytics中的ANR簇标来开始调试。簇集会包含疑似引发ANR的最多的栈帧。</p>

<p><strong>注意：</strong>忽略簇集是&#8221;navivePollOnce&#8221;和&#8221;main thread idle&#8221;的输入派发ANR。这类标志通常是关联着栈帧转储太晚的ANRs，没有可操作的提示所以要忽略掉。一般来说，真正的ANR会在其他簇集里，所以问题并不会被掩盖。详细信息可参见<strong>nativePollOnce部分</strong>。</p>

<blockquote><p><strong>译注：</strong>这篇文档是谷歌官方的，所以它自然会使用谷歌官方的应用后台(Google Play Console)和统计分析(Firebase Crashlytics)工具，对于大部分国内的开发者来说这两个东西可能比较陌生。但没关系，原理是相通的，国内也有很多应用异常统计工具和后台，或者一些本地工具抓取的日志，形式是不限的，只要能收集到类似的栈帧(stack traces)就可以用于分析调试ANR。栈帧(stack frame或者stack trace)就是线程里面的函数调用栈，比如a()->b()->c()->d()这样的函数调用，所有的异常统计工具或者日志工具都能抓取出来某一时刻每个线程的栈帧，这也称之为栈帧转储(stack frame dump)。</p></blockquote>

<p>下面的流程图展示如何确定一个输入派发超时ANR的根因：</p>

<p><img src="https://developer.android.com/static/topic/performance/images/debug-input-dispatch-anr.png" alt="" />
图1. 如何调试一个输入派发无响应ANR</p>

<p>Play vitals能够探测并帮助调试这些常见ANRs原因中的一部分。比如说，如果vitals探测到一个ANR是因为锁竞争，它会总结这些问题并在ANR Insights部分给出建议的修复方法。</p>

<p><img src="https://developer.android.com/static/topic/performance/images/play-vitals-anr-detection.png" alt="" />
图2. Google Play vitals ANR探测</p>

<blockquote><p><strong>译注：</strong>输入派发超时ANR发生的时候应用一定是在前台的，并且用户正在交互。因此重点要看主线程里面的可能的耗时操作，对于系统侧的问题以及关键的生命周期方法则一般不太相干，因为这时生命周期一般都走完了，处理常规的交互阶段。</p></blockquote>

<h2>找不到有焦点的窗口(No focused window)</h2>

<p>像触摸等的事件通过命中测试后会直接发送到相关窗口，而像硬件按键事件则需要一个目标（窗口）。这个目标就是指有焦点的窗口。每一个显示器每一时刻只有一个有焦点的窗口，并且常常就是用户当前正在使用的那个。如果找不到有焦点的窗口，输入服务会触发一个&#8221;No focused window ANR&#8221;。找不到焦点窗口ANR是输入派发无响应中的一种。</p>

<p><strong>默认超时时间：5秒。</strong></p>

<h3>常见的原因</h3>

<p>无焦点窗口ANRs通常由以下原因导致：</p>

<ul>
<li>应用启动做了太多耗时操作，还没有渲染出来第一帧。</li>
<li>应用的主窗口无法获取焦点。如果一个窗口被使用了标志位<a href="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams#FLAG_NOT_FOCUSABLE">FLAG_NOT_FOCUSABLE</a>，那么用户 就无法发送按键事件或者触摸事件到这个窗口上面。</li>
</ul>


<pre><code class="Kotlin">override fun onCreate(savedInstanceState: Bundle) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)
    window.addFlags(WindowManager.LayoutParams.FLAG_FLAG_NOT_FOCUSABLE)
}
</code></pre>

<blockquote><p><strong>译注：</strong>No focused window说明应用应在前台而未在前台，或者不应该在前台而在前台，这类ANR最容易发生在生命周期方法执行太慢导致input与window焦点状态不同步导致的。所以重点要看应用的关键生命周期回调方法是否有耗时操作，比如onCreate()/onDestroy()，onStart()/onStop()，以及特别的onResume()/onPause()。可以与上面的输入派发超时进行对比，可以发现这两类ANR分析的侧重点并不一样。</p></blockquote>

<h2>广播接收器超时(Broadcast receiver timeout)</h2>

<p>广播接收器ANR发生在当一个广播接收器无法及时的响应一个广播。对于一个同步的接收器，或者没有调用<a href="https://developer.android.com/reference/android/content/BroadcastReceiver#goAsync(">goAsync</a>)的receivers，超时的意思是<a href="https://developer.android.com/reference/android/content/BroadcastReceiver#onReceive(android.content.Context,%20android.content.Intent">onReceive()</a>)方法未能及时的执行完。对于异步接收器，或者调用了goAsync的receivers，超时的意思是<a href="https://developer.android.com/reference/kotlin/android/content/BroadcastReceiver.PendingResult#finish">PendingResult.finish</a>未能及时的被调用。</p>

<p>广播接收器ANRs经常发生在这些线程中：</p>

<ul>
<li>主线程，问题会是应用启动太慢</li>
<li>运行broadcast receiver的线程，问题会是onReceive执行太慢</li>
<li>广播的后台线程，问题会是执行goAsync的代码太耗时了</li>
</ul>


<p>遵循这些最佳实践来避免广播接收器ANRs：</p>

<ul>
<li>保证快速应用启动，因为应用启动时间也会被计算在ANR的超时时间里，如果应用是被唤醒来处理广播。</li>
<li>如果使用了goAsync，要确保PengingResult.finish早点被调用。这跟同步receivers一样都受超时时间影响。</li>
<li>如果使用了goAsync，要确保工作线程没有开启耗时操作或者阻塞性的操作。</li>
<li>考虑在非主线程里面调用<a href="https://developer.android.google.cn/reference/android/content/Context#registerReceiver(android.content.BroadcastReceiver,%20android.content.IntentFilter">registerReceiver</a>)以免阻塞主线程中的代码执行。（这里的意思是要为广播提供一个非主线程的Handler，这是广播处理回调onReceiver运行的线程。如不提供Handler将会在主线程中运行 &mdash;译注）</li>
</ul>


<blockquote><p><strong>译注：</strong>广播接收器是一个独立的组件，用于任何时候接收广播事件并进行处理，包括应用还未运行时。因此，如果应用还未有运行，那么要响应广播，必须先把应用唤起(创建进程，并创建Application实例)，然后才能创建receiver实例来处理广播。所以应用冷启动时间是会被计算在超时时限内的，从而慢的冷启动肯定会影响广播处理。通常开发者都会只关注应用启动后的情况，比如渲染性能或者用户体验，会忽略其他组件如BroadcastReceiver，Service以及ContentProvider是与Activity一样的平台级别的组件，它们都能单独的运行，但它们毕竟都是在同一个应用里面，要运行在同一进程和同一个Application实例下面，所以在运行这些组件前AMS是需要先唤起应用，应用的启动会影响着所有的四大组件。另外要注意，尽管可以用&#8221;android:process&#8221;给组件(通常是给Service和ContentProvider)指定单独的进程，但冷启动的影响也是存在的，同样需要创建进程和Application实例，并且其实主进程也是被会唤起的。</p></blockquote>

<h3>超时时限(Broadcast receiver timeout)</h3>

<p>广播接收超时时限取决于前台Intent标志是否启用以及系统平台的版本：</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> Intent类型 </th>
<th style="text-align:left;"> Android 13以及更低版本 </th>
<th style="text-align:left;"> Android 14及更高的版本 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 优先级是前台的Intent(启用了FLAG_RECEIVER_FOREGROUND) </td>
<td style="text-align:left;"> 10秒 </td>
<td style="text-align:left;"> 10~20秒，取决于进程是否是CPU挨饿 </td>
</tr>
<tr>
<td style="text-align:left;"> 优先级是后台Intent(未启用FLAG_RECEIVER_FOREGROUND) </td>
<td style="text-align:left;"> 60秒 </td>
<td style="text-align:left;"> 60~120秒，取决于进程是否是CPU挨饿 </td>
</tr>
</tbody>
</table>


<p>想要知道是否启用了FLAG_RECEIVER_FOREGROUND，可以通过在ANR标题中寻找&#8221;flg=&ldquo;然后查看是否存在<strong>0x10000000</strong>。如果这他二进制位是1就说明前台标志被启用了。</p>

<p>受制于短时广播超时时间(10~20秒)的标题例子：</p>

<pre><code class="bash">Broadcast of Intent { act=android.inent.action.SCREEN_ON flg=0x50200010 }
</code></pre>

<p>受制于长广播超时(60~120秒)的标题例子:</p>

<pre><code class="bash">Broadcast of Intent { act=android.intent.action.TIME_SET flg=0x25200010 }
</code></pre>

<h3>广播的超时时间是如何计算的</h3>

<p>广播耗时时长测量从system_server把广播派发给应用时开始，到当应用完成广播的处理时结束。如果应用程序的进程没在运行，还需要把应用冷启动时间计算在ANR的超时时间里面。因此，缓慢的应用启动也可能会导致广播接收超时ANR。</p>

<p>下面这张图展示了广播接收器的时间线与应用进程的对齐关系：</p>

<p><img src="https://developer.android.com/static/topic/performance/images/broadcast-receiver-anr-timeline.png" alt="" />
图3. 广播接收器时间线</p>

<p>ANR超时时间测量当接收器处理完广播时就结束，具体这个什么时候算结束取决于是同步接收器还是异步接收器：</p>

<ul>
<li>对于同步接收器，当onReceive方法返回时测量就结束了。</li>
<li>对于异步接收器，当PendingResult.finish被调用时就结束。</li>
</ul>


<p><img src="https://developer.android.com/static/topic/performance/images/sync-async-measurement-end.png" alt="" />
图4. 同步接收器和异步接收器的ANR超时测量结束时间点</p>

<h3>常见的根因</h3>

<p>这里列出广播接收超时ANR的一些常见根因以及修复建议。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 根因 </th>
<th style="text-align:left;"> 适用于 </th>
<th style="text-align:left;"> 表象 </th>
<th style="text-align:left;"> 建议的修复方式 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 缓慢的应用启动 </td>
<td style="text-align:left;"> 所有接收器 </td>
<td style="text-align:left;"> 应用在冷启动耗时太多 </td>
<td style="text-align:left;"> 优化应用的冷启动 </td>
</tr>
<tr>
<td style="text-align:left;"> onReceive未被调度 </td>
<td style="text-align:left;"> 所有接收器 </td>
<td style="text-align:left;"> 广播接收器线程正忙于其他操作无法执行onReceive </td>
<td style="text-align:left;"> 不要在接收器的线程里面做长时间的耗时操作(放到其他工作线程里去) </td>
</tr>
<tr>
<td style="text-align:left;"> 缓慢的onReceive </td>
<td style="text-align:left;"> 所有的接收器，主要是同步接收器 </td>
<td style="text-align:left;"> 开始执行onReceive了，但因为被阻塞了或者执行的太慢，无法及时的完成并返回 </td>
<td style="text-align:left;"> 优化缓慢的onReceive代码 </td>
</tr>
<tr>
<td style="text-align:left;"> 异步接收器未被调度 </td>
<td style="text-align:left;"> goAsync()接收器 </td>
<td style="text-align:left;"> onReceive要在一个被阻塞的工作线程池中执行，所以始终得不到执行 </td>
<td style="text-align:left;"> 优化阻塞的代码或者binder call，或者用不同的线程来当作广播的工作线程 </td>
</tr>
<tr>
<td style="text-align:left;"> 工作线程太慢或者被阻塞 </td>
<td style="text-align:left;"> goAsync()接收器 </td>
<td style="text-align:left;"> 当处理广播时，在工作线程池中有耗时操作或者阻塞代码。因此，PendingResult.finish()无法及时被调用 </td>
<td style="text-align:left;"> 优化缓慢的异步接收器代码 </td>
</tr>
<tr>
<td style="text-align:left;"> 忘记调用PendingResult.finish() </td>
<td style="text-align:left;"> goAsync()接收器 </td>
<td style="text-align:left;"> 代码的逻辑中没有调用finish() </td>
<td style="text-align:left;"> 保证finish()被调用到 </td>
</tr>
</tbody>
</table>


<p><br /></p>

<h3>如何调试</h3>

<p>基于簇集标签(cluster signature)和ANR报告，可以定位到广播接收器运行的线程，然后再定位到未执行的代码或者运行缓慢的代码。</p>

<blockquote><p><strong>注意：</strong>不要忽略&#8221;nativePollOnce&#8221;或者&#8221;main thread idle&#8221;的簇集标签。Google Play Console和Firebase Crashlytics的ANR标签里面的栈帧通常都是从主线程中获取生成的。但是，广播接收器可能运行在非主线程或者调用了goAsync()（也即转成了异步接收器&mdash;译注）。因此，这些簇集标签仍然有实际价值，可以查看一下栈帧里面的相关线程。</p></blockquote>

<p>下面的流程图展示了如何确定一个广播接收超时ANR的根因：</p>

<p><img src="https://developer.android.com/static/topic/performance/images/debug-broadcast-receiver-timeout-anr.png" alt="" />
图5. 如何调试一个广播超时ANR</p>

<h3>找到接收器的代码</h3>

<p>Google Play Console会在ANR簇集标签里面显示接收器的类名和广播Intent。寻找以下信息：</p>

<ul>
<li>cmp=&lt;receiver class&gt;</li>
<li>act=&lt;broadcast_intent&gt;</li>
</ul>


<p>这里是一个广播超时ANR标签的例子：</p>

<pre><code class="bash">com.example.app.MyClass.myMethod
Broadcast of Intent { act=android.accounts.LOGIN_ACCOUNTS_CHANGED
cmp=com.example.app/com.example.app.MyAccountReceiver }
</code></pre>

<h3>寻找运行onReceive方法的线程</h3>

<p>如果使用Context.registerReceiver()时指定了自定义的handler，那就会运行在此handler所依附的线程里。此外，就是在主线程里。</p>

<h3>实例：异步接收器未被调度</h3>

<p>这部分将逐步的演示如何调试一个广播接收超时ANR。</p>

<p>比如说ANR标签是像酱紫的：</p>

<pre><code class="bash">com.example.app.MyClass.myMethod
Broadcast of Intent {
act=android.accounts.LOG_ACCOUNTS_CHANGED cmp=com.example.app/com.example.app.MyReceiver }
</code></pre>

<p>从标签中可以看出，广播intent是android.accounts.LOG_ACCOUNTS_CHANGED，接收器类型是com.example.app.MyReceiver。</p>

<p>从接收器的代码，可以发现线程池&#8221;BG Thread [0,1,2,3]&ldquo;在主要负责处理这个广播。查看栈帧，可以发现所有四个后台线程(background threads)的模式是一样的：它们都执行了一个阻塞式的调用getDataSync。因为所有的后台线程都被占用着，这个广播无法被及时处理，最后发生了ANR。</p>

<pre><code class="bash">BG Thread #0 (tid=26) Waiting

at jdk.internal.misc.Unsafe.park(Native method:0)
at java.util.concurrent.locks.LockSupport.park(LockSupport.java:211)
at com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture:563)
at com.google.common.util.concurrent.ForwardingFuture.get(ForwardingFuture:68)
at com.example.app.getDataSync(&lt;MyClass&gt;:152)

...

at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:644)
at com.google.android.libraries.concurrent.AndroidExecutorsModule.lambda$withStrictMode$5(AndroidExecutorsModule:451)
at com.google.android.libraries.concurrent.AndroidExecutorsModule$$ExternalSyntheticLambda8.run(AndroidExecutorsModule:1)
at java.lang.Thread.run(Thread.java:1012)
at com.google.android.libraries.concurrent.ManagedPriorityThread.run(ManagedPriorityThread:34)
</code></pre>

<p>有几种方法可以修复这个问题：</p>

<ul>
<li>查出为何getDataSync会如此之慢，然后优化</li>
<li>不要在四后台线程中都执行getDataSync</li>
<li>更为通用的做法是，保证后台线程池中不要执行长时间的耗时操作</li>
<li>为goAsync任务设计一个专用线程池</li>
<li>使用一个无数量限制的线程池，而不是限量为4的后台线程池</li>
</ul>


<h3>实例：应用启动缓慢</h3>

<p>应用启动缓慢可能会导致几个不同类型的ANR，以广播接收超时ANR和执行服务超时ANR最为显著。如果你在主线程的帧中看到了ActivityThread.handleBindApplication，那么这个ANR的根因很有可能就是启动慢造成的。</p>

<blockquote><p><strong>译注：</strong>四大组件(Activity, Service, BroadcastReceiver和ContentProvidier)都是平台能直接识别的组件，均可由AMS直接启动运行，但它们都是应用的一部分，如果应用尚未运行，那么AMS必须先要创建进程，并创建Application实例，这都需要花费时间，会耗费更久，甚至引发ANR，如果冷启动过程中有耗时操作。所以优化应用启动是性能优化的基石。</p></blockquote>

<h2>执行服务超时(Exceute service timeout)</h2>

<p>当应用程序的主线程无法及时的启动一个Service时就会发生执行服务超时ANR。具体来说，就是一个服务无法在一定时限范围内完成onCreate()或者onStartCommand()或者onBind()的执行。</p>

<p><strong>默认超时时间：</strong>前台服务(Foreground Service)是20秒; 后台服务(Background Service)是200秒。ANR超时时间包括应用冷启动，以及onCreate()，onBind()和onStartCommand的调用。</p>

<p>遵循如下最佳实战来规避执行服务ANR：</p>

<ul>
<li>确保应用启动很快，因为如果一个应用被唤起来运行服务组件，启动时间也会被计算在超时时间内。</li>
<li>确保服务的onCreate()，onBind()和onStartCommand()执行的都很快。</li>
<li>不要在主线程里执行来自其他组件的耗时操作或者阻塞式操作，这些操作会阻碍服务的快速启动。</li>
</ul>


<h3>常见的根因</h3>

<p>下表列出执行服务超时ANR的常见根因和修复建议：。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 根因 </th>
<th style="text-align:left;"> 表象 </th>
<th style="text-align:left;"> 建议的修复 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 缓慢的应用启动 </td>
<td style="text-align:left;"> 应用冷启动时间过长 </td>
<td style="text-align:left;"> 优化应用启动速度 </td>
</tr>
<tr>
<td style="text-align:left;"> 缓慢的onCreate()，onStartCommand和onBind </td>
<td style="text-align:left;"> 服务组件的onCreate()，onStartCommand()和onBind()在主线程执行了耗时操作 </td>
<td style="text-align:left;"> 优化代码，或者把耗时操作从这些关键的方法中移出去 </td>
</tr>
<tr>
<td style="text-align:left;"> 未被调度(在执行onStart()之前主线程就被阻塞了) </td>
<td style="text-align:left;"> 在服务启动之前，主线程就被其他组件级阻塞了 </td>
<td style="text-align:left;"> 把其他组件的工作移出主线程。优化其他组件的阻塞代码 </td>
</tr>
</tbody>
</table>


<p><br /></p>

<h3>如何调试</h3>

<p>从Google Play Console和Firebase Crashlytics中的簇集标签和ANR报告，基于主线程当时的运行状态，通常就能确定ANR的根因。</p>

<p><strong>注意：</strong>忽略标签是&#8221;nativePollOnce&#8221;和&#8221;main thread idle&#8221;的执行服务ANR簇集。这些簇集通常是栈帧捕获的太晚，无实际参考意义。真实的ANR栈帧可能会在其他的簇集里，所以问题并不会被掩藏。详细参见nativePollOnce部分。</p>

<p>下面的流程图描述了如何调试一个执行服务超时ANR。</p>

<p><img src="https://developer.android.com/static/topic/performance/images/debug-execute-service-anr.png" alt="" />
图6. 如何调试一个执行服务ANR</p>

<p>如果发现某个执行报务ANR是有实际操作意义的，遵循以下步骤来解决问题：</p>

<ol>
<li>找到ANR簇集标签中的服务组件。在Google Play Console里，服务组件类型会显示在ANR标签里。在后面的这个例子里，类型就是com.example.app/MyService。</li>
</ol>


<pre><code class="bash">com.google.common.util.concurrent.Uninterruptibles.awaitUninterruptibly
Executing service com.example.app/com.example.app.MyService
</code></pre>

<ol>
<li>确定应用启动过程中，服务组件或者其他地方是否有耗时或者阻塞操作，通过检查主线程中的下面这些重要的方法调用</li>
</ol>


<table>
<thead>
<tr>
<th style="text-align:left;"> 主线程栈帧中的方法调用 </th>
<th style="text-align:left;"> 背后的含义 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> android.app.ActivityThread.handleBindApplication </td>
<td style="text-align:left;"> 应用正在启动，ANR由启动太慢引起 </td>
</tr>
<tr>
<td style="text-align:left;"> <ServiceClass>.onCreate()<br/>[&hellip;.]<br/>android.app.ActivityThread.handleCreateService </td>
<td style="text-align:left;"> 服务正在被创建中，所以ANR是由缓慢的onCreate()引起的 </td>
</tr>
<tr>
<td style="text-align:left;"> <ServiceClass>.onBind()<br/>[&hellip;.]<br/>android.app.ActivityThread.handleBindService </td>
<td style="text-align:left;"> 服务正在被绑定中，所以ANR是由缓慢的onBind()引起的 </td>
</tr>
<tr>
<td style="text-align:left;"> <ServiceClass>.onStartCommand()<br/>[&hellip;.]<br/>android.app.ActivityThread.handleServiceArgs </td>
<td style="text-align:left;"> 服务正在被启动中，所以ANR是由缓慢的onStartCommand()引起的 </td>
</tr>
</tbody>
</table>


<p><br />
举个粟子，如果在类MyService里的onStartCommand执行缓慢，主线程栈帧会像酱婶儿的：</p>

<pre><code class="bash">at com.example.app.MyService.onStartCommand(FooService.java:25)
at android.app.ActivityThread.handleServiceArgs(ActivityThread.java:4820)
at android.app.ActivityThread.-$$Nest$mhandleServiceArgs(unavailable:0)
at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2289)
at android.os.Handler.dispatchMessage(Handler.java:106)
at android.os.Looper.loopOnce(Looper.java:205)
at android.os.Looper.loop(Looper.java:294)
at android.app.ActivityThread.main(ActivityThread.java:8176)
at java.lang.reflect.Method.invoke(Native method:0)
</code></pre>

<p>如果没有发现重要的方法调用，还有其他一些可能：</p>

<ul>
<li> 服务正在运行或者在关闭中，意思是说栈帧捕获的太晚了，可以忽略此类ANR或者视为假阳性。</li>
<li><p> 另外一个组件正在运行，比如广播接收器。这种情况下主线程可能被这个组件阻塞着，导致服务无法启动。</p></li>
<li><p>如果能看到关键的方法 调用并确定ANR发生的地点，检查主线程的栈帧以找到缓慢的操作并把它们从关键的方法中移出去。</p></li>
</ul>


<p>关于服务的更多信息，可以看下面这些链接：</p>

<ul>
<li><a href="https://developer.android.com/guide/components/services">服务概览</a></li>
<li><a href="https://developer.android.com/guide/components/foreground-services">前台服务</a></li>
<li><a href="https://developer.android.com/reference/android/app/Service">服务</a></li>
</ul>


<h2>内容提供程序无响应(Content Provider not responding)</h2>

<p>当一个远端内内容提供程序响应查询(query)时花费超过时限，内容提供程序ANR就会发生，且会被杀掉。</p>

<p><strong>默认超时时间：</strong>内容提供程序通过ContentProviderClient.setDetectNotResponding指定的。ANR超时时限包括远端内容提供程序执行查询的时间，以及如果远端应用还未启还包括它的冷启动时间，加在一起的总时间。</p>

<p>遵循下面这些最佳实践来规避内容提供程序ANR：</p>

<ul>
<li>确保应用启动很快，因为如果应用未运行时会被唤起，冷启动时间也会被计算在超时时间内。</li>
<li>确保内容提供程序的查询能很快执行完。</li>
<li>不要执行大量的并发阻塞式的binder call，因为这会阻塞应用的所有的binder线程。</li>
</ul>


<blockquote><p><strong>译注：</strong><a href="https://developer.android.com/reference/android/content/ContentProvider">内容提供程序Content provider</a>都是要经过跨进程调用(binder call)，尽管可能并没有真正的在另外一个进程里。因为我们使用<a href="https://developer.android.com/guide/topics/providers/content-provider-basics">ContentProvider</a>的时候都是通过另一个API ContentResolver来完成，而ContentResolver是通过binder call来与ContentProvider通信的，无论是否真的跨进程。所以，ContentProvider就像一个服务器一样是远端的一侧提供内容，而应用程序(使用者)是客户端一侧需要内容。内容提供程序可能同时服务着不同的客户请求，比如像系统通用的内容提供程序ContactsProvider或者MediaProvider可能同时会有大量的应用请求查询，每一个请求都需要执行binder call，因此内容提供程序可能会同时执行着大量的binder call(它需要查询结果，并把结果以binder call的形式返回给请求方)。所以对于内容提供程序来说，查看binder call的运行状态对于解决ANR问题以及排查性能问题都是非常有帮助的。</p></blockquote>

<h3>常见根因</h3>

<p>下表列出了内容提供程序ANR的常见根因和修复建议。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 根因 </th>
<th style="text-align:left;"> 表象 </th>
<th style="text-align:left;"> 信号 </th>
<th style="text-align:left;"> 建议的修复方式 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 缓慢的查询 </td>
<td style="text-align:left;"> 内容提供程序执行耗时太长或者被阻塞 </td>
<td style="text-align:left;"> binder线程里有android.content.ContentProvider\$Transport.query栈帧 </td>
<td style="text-align:left;"> 优化查询或者查出什么东西在阻塞着binder线程 </td>
</tr>
<tr>
<td style="text-align:left;"> 应用启动太慢 </td>
<td style="text-align:left;"> 内容提供程序启动耗时太久 </td>
<td style="text-align:left;"> 主线程里有ActivityThread.handleBindApplication栈帧 </td>
<td style="text-align:left;"> 优化应用启动 </td>
</tr>
<tr>
<td style="text-align:left;"> Binder线程耗尽了，所有的binder线程都被占用着 </td>
<td style="text-align:left;"> 所有的binder线程都被占用着服务着其他的同步请求，因此内容提供程序binder调用无法执行 </td>
<td style="text-align:left;"> 应用未启动起来，所有的binder线程都被占用，内容提供程序也未能启动起来 </td>
<td style="text-align:left;"> 减小binder线程的负载。也就是说执行更少一些的外发同步binder调用或者在处理到来的调用时少做一些操作。</td>
</tr>
</tbody>
</table>


<p><br /></p>

<h3>如何调试</h3>

<p>要想调试一个内容提供程序ANR，使用Google Play Console或者Firebase Crashlytics中的簇集标签和ANR报告，并用来查看主线程以及binder线程都在做什么。</p>

<p>下面的流程图描述如何调试一个内容提供程序ANR：</p>

<p><img src="https://developer.android.com/static/topic/performance/images/debug-content-provider-anr.png" alt="" />
图7.如何调试一个内容提供程序ANR</p>

<p>下面的代码块展示了当被一个缓慢的内容提供程序查询阻塞时，binder线程的状态。在这个例子里，内容提供程序的查询正在等待一个打开数据库的锁。</p>

<pre><code class="bash">binder:11300_2 (tid=13) Blocked

Waiting for osm (0x01ab5df9) held by at com.google.common.base.Suppliers$NonSerializableMemoizingSupplier.get(Suppliers:182)
at com.example.app.MyClass.blockingGetOpenDatabase(FooClass:171)
[...]
at com.example.app.MyContentProvider.query(MyContentProvider.java:915)
at android.content.ContentProvider$Transport.query(ContentProvider.java:292)
at android.content.ContentProviderNative.onTransact(ContentProviderNative.java:107)
at android.os.Binder.execTransactInternal(Binder.java:1339)
at android.os.Binder.execTransact(Binder.java:1275)
</code></pre>

<p>下面的代码块展示了当被缓慢的应用启动阻塞时，binder线程的状态。在这个例子里，应用启动因为dagger初始化时的锁竞争而变得很慢。</p>

<pre><code class="bash">main (tid=1) Blocked

[...]
at dagger.internal.DoubleCheck.get(DoubleCheck:51)
- locked 0x0e33cd2c (a qsn)at dagger.internal.SetFactory.get(SetFactory:126)
at com.myapp.Bar_Factory.get(Bar_Factory:38)
[...]
at com.example.app.MyApplication.onCreate(DocsApplication:203)
at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1316)
at android.app.ActivityThread.handleBindApplication(ActivityThread.java:6991)
at android.app.ActivityThread.-$$Nest$mhandleBindApplication(unavailable:0)
at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2235)
at android.os.Handler.dispatchMessage(Handler.java:106)
at android.os.Looper.loopOnce(Looper.java:205)
at android.os.Looper.loop(Looper.java:294)
at android.app.ActivityThread.main(ActivityThread.java:8170)
at java.lang.reflect.Method.invoke(Native method:0)
at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:552)
at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:971)
</code></pre>

<h2>缓慢的作业响应(Slow job response)</h2>

<p>当应用响应JobService.onStartJob()或者JobService.onStopJob耗时太久，或者用JobService.setNotification()提供通知时耗时太久，都会引发缓慢的作业响应ANR发生。这说明应用的主线程因为其他操作而被阻塞了。</p>

<p>如果问题是与JobService.onStartJob()或者JobService.onStopJob()有关系，就要检查下主线程的情况。如果问题与JobService.setNotification()有关系，要保证它尽可能的快速的被调用到。在提供通知之前 不要做很多其他事情。</p>

<blockquote><p><strong>译注：</strong><a href="https://developer.android.com/reference/android/app/job/JobService">JobService</a>是Android 5.0 API 21时增加的一个专门用于后台作业的一个Service的子类。上面提到的是都是它的一些回调，与一些其他的回调类似，这些回调必须快速执行完毕，因为<a href="https://developer.android.com/reference/android/app/job/JobScheduler">JobSchedule</a>内部需要做一些资源回收之类的工作，所以这些回调不允许被阻塞。</p></blockquote>

<h2>隐秘的ANRs</h2>

<p>有时候搞不清楚为啥ANR会发生，或者在簇集标签和ANR报告中找不到足够的信息去调试。遇到这些情况，还是可以采取一些步骤以确定这些ANR是否是值得处理的。</p>

<h3>消息队列是空闲(Message queue idle)的或者正处理轮询中(nativePollOnce)</h3>

<p>如果你在栈帧信息中发现android.os.MessageQueue.nativePollOnce，这通常说明疑似无响应的线程实际上是空闲的或者在等待队列中的消息。在Google Play Console里面，ANR的细节是酱紫的：</p>

<pre><code class="bash">Native method - android.os.MessageQueue.nativePollOnce
Executing service com.example.app/com.example.app.MyService
</code></pre>

<p>举个粟子，如果主线程是空闲的，栈帧是酱紫的：</p>

<pre><code class="bash">"main" tid=1 NativeMain threadIdle

#00  pc 0x00000000000d8b38  /apex/com.android.runtime/lib64/bionic/libc.so (__epoll_pwait+8)
#01  pc 0x0000000000019d88  /system/lib64/libutils.so (android::Looper::pollInner(int)+184)
#02  pc 0x0000000000019c68  /system/lib64/libutils.so (android::Looper::pollOnce(int, int*, int*, void**)+112)
#03  pc 0x000000000011409c  /system/lib64/libandroid_runtime.so (android::android_os_MessageQueue_nativePollOnce(_JNIEnv*, _jobject*, long, int)+44)
at android.os.MessageQueue.nativePollOnce (Native method)
at android.os.MessageQueue.next (MessageQueue.java:339)  at android.os.Looper.loop (Looper.java:208)
at android.app.ActivityThread.main (ActivityThread.java:8192)
at java.lang.reflect.Method.invoke (Native method)
at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run (RuntimeInit.java:626)
at com.android.internal.os.ZygoteInit.main (ZygoteInit.java:1015)
</code></pre>

<p>疑似无响应线程可能是空闲的会有几个原因：</p>

<ul>
<li>延迟的栈转储：在ANR被 触发和栈帧转储之间的短时间内，线程状态恢复了。在Android 13版本的Pixels设备上这个延迟大约在100ms，但也可能超过1秒。Android 14版本的Pixels设备上这个延迟小于10ms。</li>
<li>线程归因错误：用于构建ANR标签的线程并不是实际上触发ANR的无响应线程。这种情况下，尝试确定一下这个ANR是否是如下的类型：

<ul>
<li>广播接收超时</li>
<li>内容提供程序无响应</li>
<li>找不到带焦点的窗口</li>
<li>系统侧问题：由于系统负载太重或者系统服务有问题而导致应用进程无法被调度。</li>
</ul>
</li>
</ul>


<h3>没有栈帧(No stack frames)</h3>

<p>有一些ANR报告里面没有包含与ANR相关的栈帧，这说明在生成ANR报告时栈帧转储失败了。有很多可能的原因会导致栈帧丢失：</p>

<ul>
<li>转储栈帧太耗时了，所以超时了</li>
<li>在栈帧转储完成之前进程就挂了或者被杀掉了</li>
</ul>


<pre><code class="bash">[...]

--- CriticalEventLog ---
capacity: 20
timestamp_ms: 1666030897753
window_ms: 300000

libdebuggerd_client: failed to read status response from tombstoned: timeout reached?

----- Waiting Channels: pid 7068 at 2022-10-18 02:21:37.&lt;US_SOCIAL_SECURITY_NUMBER&gt;+0800 -----

[...]
</code></pre>

<p>簇集标签或者ANR报告里面没有栈帧的ANR是没有实际分析意义的。如果要调试，可以去看其他的簇集信息，因为如果一个问题足够明显的话，那么它通常会有它自己的簇集标签存在。其他的可行方案就是查看<a href="https://perfetto.dev/docs/">Perfetto traces</a>.</p>

<h2>已知问题(Known issues)</h2>

<p>在应用的进程里用计时器来测量广播的处理时间或者ANR的触发是行不通的，因为系统是以异步的方式在监控着ANR。</p>

<blockquote><p><strong>译注：</strong>这里的意思是不要想着取巧，应用开发者的重点应该放在你的业务逻辑和性能优化上面，借助平台提供的工具和方法来优化应用的代码逻辑。而像尝试在应用侧自己统计超时这种事情是行不通的，因为系统以比较复杂的异步的方式在统计着超时，应用侧不可能做到与系统侧一样的测量方法，所以自己的统计就变得毫无意义（要么不可行，要么不准确）。还是老老实实的优化好自己的代码吧。</p></blockquote>

<h2>更多的官方资料</h2>

<ul>
<li><a href="https://developer.android.com/topic/performance/anrs/find-unresponsive-thread">Find the unresponsive thread</a></li>
<li><a href="https://developer.android.com/topic/performance/anrs/keep-your-app-responsive">Keep your app responsive</a></li>
<li><a href="https://developer.android.com/guide/topics/resources/layout-resource">Layout resource</a></li>
<li><a href="https://developer.android.com/topic/performance/vitals/anr">ANRs</a></li>
</ul>


<h2>其他优质博文</h2>

<ul>
<li><a href="https://juejin.cn/post/7181731795439157306">钉钉 ANR 治理最佳实践 | 定位 ANR 不再雾里看花</a></li>
<li><a href="https://juejin.cn/post/6940061649348853796">今日头条 ANR 优化实践系列 - 设计原理及影响因素</a></li>
<li><a href="https://juejin.cn/post/7053819042268151838">Android ANR全解析&amp;华为AGC性能管理解决ANR案例集</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实战技巧：为Android应用设置独立的多语言]]></title>
    <link href="http://toughcoder.net/blog/2023/11/27/android-set-per-app-langauges/"/>
    <updated>2023-11-27T22:40:38+08:00</updated>
    <id>http://toughcoder.net/blog/2023/11/27/android-set-per-app-langauges</id>
    <content type="html"><![CDATA[<p>通常情况下多语言的设置都在系统设置中，应用需要做的就是提供本应用所使用的字串的多语言翻译，使用时使用R.string.app_name类似的引用，然后系统会根据用户在系统设置中的选项来选择合适的具体的语言。并且这是一个<strong>全局选项</strong>，也就是说选择一个多语言后整个手机都变了。但有些时候，应用想要自己能够设置一个独自的多语言，也就是说想要给自己的应用设置一个不同于全局的多语言。今天就来研究一下这个话题。</p>

<p><a href=""><img src="https://i2.wp.com/techvidvan.com/tutorials/wp-content/uploads/sites/2/2021/08/Android-Localization-1.jpg?fit=1200%2C628&amp;ssl=1"></a></p>

<!--  more -->


<p>这样做的目的是为了提供更好的用户体验，因为一些仅支持某些特定语言的应用，可能会与系统全局选项冲突，或者只在某些固定地区发行的应用，单独的个性化的局部设置会更好一些。这个谷歌已经通过<a href="https://developer.android.com/jetpack">Jetpack</a>中的<a href="https://developer.android.com/jetpack/androidx/releases/appcompat">appcomat</a>库给与了比较好的支持，详细的可以<a href="https://developer.android.com/guide/topics/resources/app-languages">参考这个文档</a>，以及<a href="https://github.com/android/user-interface-samples/tree/main/PerAppLanguages">官方的Sample</a>。我们在官方文档基础之上再叠加试验和理解，做进一步的总结。</p>

<p>主要分为两种方法，一是系统支持单独给应用设置多语言；二是应用中独自设置，这个也是更为通用的解法。</p>

<p><strong>注意</strong>：这里的方法都是让某一个应用内部使用的多语言改变为相应的设置（一般情况下是与系统全局设置不一样的），但是需要注意仅仅局限于应用启动后的应用内部界面使用的语言。对于像桌面上应用的入口仍是系统全局设置为准，因为这个入口并不属于应用自己管辖范围内的。</p>

<h2>系统设置中支持为应用设置单独多语言</h2>

<p>谷歌官方的表述是从Android 13（Android T, SDK 33)开始，就支持了在系统中有一个入口，可以为每个应用单独设置多语言选项。这一部分里面描述的方法也都是支持这个系统入口的情况才能生效的。需要注意，虽然谷歌官方说从Android 13开始就支持了，但这个也要取决 于厂商的定制，目前看大部分国内厂商会把这个功能和入口给屏蔽掉，那么这里后面描述的方法也就都不会生效了。</p>

<h3>入口在哪里</h3>

<p>需要通过系统设置来进行，有两个入口：</p>

<p><img src="https://developer.android.com/static/images/about/versions/13/app-languages.png" height="480" width="320" alt="" /></p>

<ul>
<li>Settings（设置）> Additional Settings (更多设置) > Languages &amp; Input (语言和输入) > (App Languages) 应用语言 > select an app（选择一个应用）</li>
<li>Settings（设置）> Apps (应用)> select an app（选择一个应用） > Language（语言）</li>
</ul>


<p>具体的方法，又分为两种，一是自动式的，二是手动式的。</p>

<h3>自动添加</h3>

<p>说是自动，其实也是利用IDE（即Android Studio）和编译打包时自动根据res下面的多语言生成一份配置而已。在build.gradle或者build.gradle.kts中的android下面添加generateLocaleConfig = true：</p>

<pre><code class="kotlin">    android {
        androidResources {
            generateLocaleConfig = true
        }
    }
</code></pre>

<p>然后在resl中增加一个名为resources.properties的文件，加入默认值配置：</p>

<pre><code>unqualifiedResLocale=en-US
</code></pre>

<h3>手动添加</h3>

<p>在res/xml中增加文件locales_config.xml，加入需要支持的多语言选项，如：</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;locale-config xmlns:android="http://schemas.android.com/apk/res/android"&gt;   &lt;locale android:name="en-US"/&gt;   &lt;locale android:name="en-GB"/&gt;   &lt;locale android:name="fr"/&gt;   &lt;locale android:name="ja"/&gt;   &lt;locale android:name="zh-Hans-MO"/&gt;   &lt;locale android:name="zh-Hant-MO"/&gt;&lt;/locale-config&gt;
</code></pre>

<p>然后在AndroidManifest.xml中的appllication加上这一个属性：</p>

<pre><code class="xml">&lt;manifest&gt;
    ...
    &lt;application
        ...
        android:localeConfig="@xml/locales_config"&gt;
    &lt;/application&gt;
&lt;/manifest&gt;
</code></pre>

<p>因为还没有找到支持如此设置的手机，所以上述方法未经验证。</p>

<h2>在应用内部设置多语言</h2>

<p>这个是更为通用的做法，具体的UI就是可以随便弄了，弄个List或者DrowDownMenu都可以。重点是让设置生效的时候需要用到一个API，叫做<a href="https://developer.android.com/reference/androidx/appcompat/app/AppCompatDelegate#setApplicationLocales(androidx.core.os.LocaleListCompat">setApplicationLocales()</a>)和<a href="https://developer.android.com/reference/androidx/appcompat/app/AppCompatDelegate#getApplicationLocales(">getApplicationLocales()</a>)。并且在appcompat 1.6.0以后的版本，有比较方便的API可以直接使用。</p>

<pre><code class="Kotlin">val appLocale: LocaleListCompat = LocaleListCompat.forLanguageTags("xx-YY")// Call this on the main thread as it may require Activity.restart()AppCompatDelegate.setApplicationLocales(appLocale)
</code></pre>

<p>如果要还原使用系统设置中的全局多语言配置，可以用LocaleListCompat.getEmptyLocaleList()当作参数。</p>

<p><strong>特别注意</strong>：此方法要想生效，宿主Activity必须是继承自appcompat中的AppCompatActivity，而不是其他 。</p>

<p>为了兼容以前的版本（Android 12，API level 32以前），还需要在AndroidManifest中添加一个额外的Service：</p>

<pre><code class="xml">&lt;application  ...  &lt;service    android:name="androidx.appcompat.app.AppLocalesMetadataHolderService"    android:enabled="false"    android:exported="false"&gt;    &lt;meta-data      android:name="autoStoreLocales"      android:value="true" /&gt;  &lt;/service&gt;  ...&lt;/application&gt;
</code></pre>

<p>需要注意，这个Service在appcomat库中已经定义好了，只需要在manfiest里添加一下就可以了。</p>

<p>另外需要注意的是，一般情况下，应用自己肯定 会保存一下当前用户所选择的语言。但如果系统也支持应用语言选择入口的话，那么通过系统入口也是可能会修改应用的多语文选项的，这时，就需要把系统的选项与应用内部的选项进行同步。可以通过<a href="https://developer.android.com/reference/androidx/appcompat/app/AppCompatDelegate#getApplicationLocales(">AppCompatDelegate.getApplicationLocales</a>)来获取当前生效的语言选项，它是由appcompat库来维护的，肯定是最新的，所以应用自己保存的选项如果与这个API的结果不一致，就要重置为这个API的结果。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/guide/topics/resources/app-languages">Per-app language preferences</a></li>
<li><a href="https://github.com/android/user-interface-samples/tree/main/PerAppLanguages">user-interface-samples/PerAppLanguages</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Weather App With Jetpack Compose]]></title>
    <link href="http://toughcoder.net/blog/2023/09/19/weather-app-with-jetpack-compose/"/>
    <updated>2023-09-19T21:10:56+08:00</updated>
    <id>http://toughcoder.net/blog/2023/09/19/weather-app-with-jetpack-compose</id>
    <content type="html"><![CDATA[<p>现在满屏的Compose，近期也看了一些教程，似懂非懂，总感觉还缺点什么，于是有必要使用这些新技术来构造一个真实的Android App，以加深理解。第一个实例就是想做一个天气查询和展示的应用，使用<a href="https://developer.android.com/jetpack/compose">Jetpack Compose</a>以及Google推荐的<a href="https://developer.android.com/modern-android-development">MAD（Modern Android Development）</a>。</p>

<p><a href=""><img src="http://images.shejidaren.com/wp-content/uploads/2013/09/weather-app.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>核心目的</h2>

<p>学习使用Jetpack Compose构建UI，和学习新的架构方式（MVVM）。其实我们不是只读式的学习，更重要的是要在一个真实的项目中去实践这些知识。</p>

<p>Follow官方的教程和建议，先由最简单的版本，一步步的使用这些轮子打造我们的天气应用。</p>

<p><strong>特别注意</strong>：此行不是为了做一个天气App，而是以MAD的方式来构建App，每一步都要<a href="https://m3.material.io/">符合设计规范</a>和<a href="https://developer.android.com/topic/architecture">架构原则</a>，不留破窗。</p>

<h2>技术栈</h2>

<p><img src="https://innovationm.co/wp-content/uploads/2021/05/Jetpack-compose.png" alt="" /></p>

<p>使用MAD，Jpetpack和Compose，以及<a href="https://developer.android.com/jetpack/androidx/releases/compose-material3">Material Design</a>。</p>

<h2>Weather API</h2>

<p>使用 <a href="https://dev.qweather.com/docs/start/">和风API</a>。</p>

<h2>第一个版本</h2>

<p>本着<a href="http://toughcoder.net/blog/2023/08/08/understanding-minimum-viable-product/">MVP的原则</a>，第一个版本尽量简单，实现核心需求即可，第一个版本的目标：查询预定列表中的城市天气，并展示其详细天气信息。</p>

<p>流程图：</p>

<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script>




<div class="mermaid">
flowchart TD
    A([Start]) &#45;&#45;> C{Has preferred city?}
    C &#45;&#45;> |No| E([Show City list])
    E &#45;&#45;> F([Pick a city])
    F &#45;&#45;> J([Save as prefered])
    J &#45;&#45;> D
    C &#45;&#45;> |Yes| D([Show detail page])
    D &#45;&#45;> G{data need refresh?}
    G &#45;&#45;> |Yes| H([Get weather data])
    H &#45;&#45;> D
    G &#45;&#45;> |No| I([End])
</div>


<h3>第一步：构建UI</h3>

<p>第一版本中的第一步，不用网络，全用fake data，把需要的两个页面构建出来，目的在于搭建基础设施，并把流程跑通。</p>

<h3>第二步：接入Weather API</h3>

<p>获取真实的天气数据，并完善天气详情页面。</p>

<h2>Reference</h2>

<ul>
<li><a href="https://juejin.cn/post/7176875120839884860">从 0 到 1 搞一个 Compose Desktop 版本的天气应用（附源码）</a></li>
<li><a href="https://juejin.cn/column/7127467629022806030">天气App系列文章</a></li>
<li><a href="https://github.com/harsh2907/JetWeather">A weather app built on MVVM architecture with jetpack compose and other jetpack libraries</a></li>
<li><a href="https://github.com/Felix-Kariuki/JetWeather">A weather app built using Jetpack compose</a></li>
<li><a href="https://github.com/Mercandj/android-dev-challenge-compose-4">Weather app done in Jetpack Compose for the #AndroidDevChallenge 2021 🌦 ☀️. Neumorphism UI.</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jetpack Compose Road Map]]></title>
    <link href="http://toughcoder.net/blog/2023/09/08/jetpack-compose-road-map/"/>
    <updated>2023-09-08T23:04:44+08:00</updated>
    <id>http://toughcoder.net/blog/2023/09/08/jetpack-compose-road-map</id>
    <content type="html"><![CDATA[<p>Jetpack Compose是由Google在2019年Google I/O大会提出的新一代声明式UI框架，它基于Kotlin编程语言与Android Studio可以无缝衔接，在Google的大力推动下，现在已经变成了Android App的标准UI构建方式。网络上更是更是满屏的相关内容，如果说没有用过Compose都不好意思说自己会Android开发。是时候恶补一下了。</p>

<p><a href=""><img src="https://www.somagnews.com/wp-content/uploads/2021/02/Jetpack-Compose.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>快速上手体验</h2>

<p>可以follow下Google官方的<a href="https://developer.android.com/jetpack/compose/tutorial">Quick start</a>教程来快速体验一下。</p>

<p>可以<a href="https://developer.android.com/jetpack/compose/documentation">参考官方文档</a>以进一步了解。</p>

<h2>理解Compose</h2>

<h3>全用代码撸UI</h3>

<p>体验过Compose可以发现，它与原生的Android app UI开发完全不同，最大的区别就是全是Kotlin代码，不用再去摆弄xml了。</p>

<h3>本质是DSL</h3>

<p>其实Compose与Kotlin最初搞的<a href="https://github.com/Kotlin/anko">anko</a>是类似的东西，它的核心是利用Kotlin的语言特性来实现了一套写UI的DSL。在Compose里面所有的花括号其实都是一个函数，而且Compose里面的DSL都是用的大写字母开头的驼峰式，如<strong>Text {}</strong>，让人误以为这是一个类，但其实它是一个函数，容易让人误解不说，还不符合Kotlin语言的开发规范。这一点上当初的anko就相当的好，它的DSL命令都与函数的命名是一致（小写开头的驼峰式）。</p>

<p><strong>注意</strong>，如果Compose用起来感觉相当的别扭，这说明缺少前置知识，要把Kotlin的一些高级特性熟悉一下，比如<a href="http://toughcoder.net/blog/2023/02/14/understanding-kotlin-based-dsl/">DSL</a>，委拖机制以及扩展函数，只有把这些概念熟悉了以后，再写Compose会顺手很多。记住，Compose里面的所有东西都是函数调用，当成函数来写就可以了。</p>

<p>Compose其实就是一坨DSL，一层层的嵌套，本质上是一坨函数调用。极容易写出『箭头式』的代码，如这种：</p>

<pre><code class="kotlin">@Composable
private fun Greetings(
    modifier: Modifier = Modifier,
    names: List&lt;String&gt; = List(100) { "Compose #${it + 1}" }
) {
    // A surface container using the 'background' color from the theme
    Surface(modifier, color = MaterialTheme.colorScheme.background) {
        LazyColumn(modifier.padding(vertical = 4.dp)) {
            items(items = names) {
                   Greeting(it)
            }
        }
    }
}
</code></pre>

<p>当view的嵌套比较深的时候，更明显，这就需要我们要及时的抽出公共的Composable组件，其实就相当于抽出函数，以让嵌套不那么深。</p>

<p>其实Android的原生UI开发方式（也即View与xml）是相当强大的，特别是在复用，如animation，drawable，color，string和dimens的复用和适配已经相当完善了。这方面Compose还是略显笨拙，因为还必须代码，甚至还可能重复的代码。对于常规的页面，比如列表（横竖或者格子）和基础UI组件（图片，文字和按扭）组合而成的页，用Compose是完全不成问题的。但对于成百上千个各种小组件时，View的结构与交互都非常复杂的页面时，如某宝某东某团的页面，或者页面有重型的组件，如Webview，如video，graphics或者游戏，Compose肯定 力不从心。这也是为何国内，特别是一些大厂其实对Compose这玩意儿并不怎么感冒，真正在产品里使用的可能还是那些国外头部app。</p>

<h3>到处是函数</h3>

<p>Compose是用函数式编程方法，所有的Composable都是顶层的函数，也即是定义在类外面的函数，通常称为顶层函数。</p>

<p>标准库以及Material库中提供的所有轮子也都是函数，虽然它们的名字是大写的驼峰式，看起来像类一样，但其实它们都是函数。所有的Composable都接收尾部lambda，它其实是函数的最后一个参数，接收的是类型为Composable的函数，因此可以用尾部lambda的方式来实现这个参数。</p>

<p>还有一点就是，很多参数接收的也是一个函数，比如像接收Icon和Text的地方，其实是一个函数，而并不是直接把具体对象传过去，像这些地方的参数实际上需要的是一个能产生目标对象的Producer。这也是标准的函数式编程思想，也就是说尽可能的传递函数而非对象，目的在于这样更为灵活，可以让参数的使用尽可能的延时生成对象，也就是仅当真实需要的时候才会运行这个函数生成对象。而在中间过程中，或者说假如出错了，进入到错误显示的逻辑或者直接退出 了，那么其实就不需要生产对象了。</p>

<p>而传统的OO方式，是在构建流程的一开始就把对象创建好，并作为参数传过去，但其实可能完全没有必要。</p>

<h2>进阶之路</h2>

<p>最好的资源莫过于官方推出的教程。
<a href="https://developer.android.com/courses/jetpack-compose/course">jetpack compose course</a>是Google官方推出的一系列教程，有视频讲解，有实战codelab，还有测试quiz。相当的丰富，可以看得出Google对Compose还是相当上心的。</p>

<h2>项目实战</h2>

<p>有一些非常优秀的真实的用Compose构建 出来的App可以供学习和参考，<a href="https://developer.android.com/jetpack/compose/samples">有些是官方的</a>，有些则是民间的，不但开源，而且还有配套的博客来说明构建 的过程，是非常难得的参考 资料。</p>

<ul>
<li><a href="https://github.com/android/compose-samples/tree/main/Jetchat">Jetchat</a> 纯Compose构建UI，适合初学者上手</li>
<li><a href="https://github.com/android/compose-samples/tree/main/Jetsurvey">Jetsurvey</a>纯Compose构建UI，适合上手</li>
<li><a href="https://github.com/android/sunflower/tree/main">Sunflower</a> 除UI外，还有网络要用到Jetpack组件</li>
<li><a href="https://github.com/android/nowinandroid/tree/main">Now in Android</a> 集大成者，Compose，加上Jetpack再上架构思维，适合高级玩家</li>
<li><a href="https://github.com/ellisonchan/ComposeMovie">电影App</a> 一个电影的简单app，配套<a href="https://blog.csdn.net/allisonchen/article/details/115052707">博客在这里</a></li>
<li><a href="https://jetpackcompose.cn/docs/">Jetpack Compose博物馆</a> 不但有教程，还有数个实例</li>
<li><a href="https://github.com/wangchenyan/wanandroid-compose">WanAndroid</a> <a href="https://www.wanandroid.com/">WanAndroid</a>的一个客户端，<a href="https://www.jianshu.com/p/cc11f2c93778">配套博客</a></li>
<li><a href="https://github.com/Mercandj/android-dev-challenge-compose-4">Compose Weather App</a> <a href="https://www.jetpackcompose.net/compose-weather-app">配套博客</a></li>
<li><a href="https://github.com/microsoft/surface-duo-compose-samples/tree/main">Surface Dual Compose Samples</a> Compose是一个跨平台的UI构建工具，不光能为Android构建，为其他平台也能构建App，<a href="https://learn.microsoft.com/zh-cn/dual-screen/android/jetpack/compose/samples">如Surface</a></li>
</ul>


<h2>参考资料</h2>

<ul>
<li><a href="https://coolshell.cn/articles/17757.html">如何重构“箭头型”代码</a></li>
<li><a href="https://developer.android.com/jetpack/compose/mental-model">Thinking in Compose</a></li>
<li><a href="https://www.jetpackcompose.net/">Jetpack Compose Tutorial</a></li>
<li><a href="https://www.jetpackcompose.app/">The #1 destination for all things Jetpack Compose</a></li>
<li><a href="https://www.theinsaneapp.com/2021/08/jetpack-compose-sample-examples-projects-and-android-apps.html">70+ Jetpack Compose Projects For Beginners And Experts</a></li>
<li><a href="https://developersbreach.com/compose/">Collection of Android Compose UI samples</a></li>
<li><a href="https://c1ctech.com/android-jetpack-compose-example/">Android Jetpack Compose Example</a></li>
<li><a href="https://blog.mindorks.com/jetpack-compose-tutorial/">Jetpack Compose Tutorial - Step by Step Guide</a></li>
<li><a href="https://foso.github.io/Jetpack-Compose-Playground/compose_projects/">Compose Projects</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Scoped Storage Puzzles]]></title>
    <link href="http://toughcoder.net/blog/2023/05/03/android-scope-storage-puzzles/"/>
    <updated>2023-05-03T17:58:43+08:00</updated>
    <id>http://toughcoder.net/blog/2023/05/03/android-scope-storage-puzzles</id>
    <content type="html"><![CDATA[<p>安卓对于文件存储这块，其实是相当混乱的，在早期的版本中对存储甚至是没有所谓的管理的，有多种方法可以操作文件存储，比如通过Java原生的方式(File/InputStream/OutputStream)，以及通过ContentProvider的方式(openFile/openOutputStream)。文件的路径也是相当混乱的，有公共存储区域，App的沙盒，外部存储中的App沙盒，但其实整个文件系统中的文件都是可读的，除了系统目录，其他应用的沙盒(内部和外部）以外也都是可写的。这就造成了，安卓的文件系统特别的混乱，加之应用使用不规范，对存储造成极大的滥用，外部存储空间产生大量的垃圾文件，应用卸载后仍然存在，这也催生了一系列的清理软件。</p>

<p><a href=""><img src="https://co-well.vn/wp-content/uploads/2020/05/Android-01-2048x1280.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>但随着用户隐私问题越来越被重视，谷歌也开始收紧了存储权限管理。</p>

<h2>存储权限的变迁史</h2>

<h3>强制动态申请权限</h3>

<p>从Android 6.0（Android M, API 23）开始，存储权限除了在AndroidManifest中静态声明以外，还需要在运行时动态的申请，用户授权了后才可以使用。但这并没有本质的变化，只要用户授权了，就跟以前一样，所有文件可读，大量位置的文件也都可写，App依然可以随便乱搞。</p>

<h3><a href="https://developer.android.com/training/data-storage#scoped-storage">Scoped Storage</a></h3>

<p>后来到了Android 10 (Android Q, API 29)时提出了scoped storage的概念，并把权限进一步的收紧，仅留下几个公共的文件夹可写，其他地方均不可写。并且写媒体文件时(Image/Video/Audio)，要用MediaStore API的方式，直接以Java的文件方式将不再可用。Android 10并未强制开启scoped storage，通过在Manifest中设置requestLegacyStorageManage=true，依然可以像以往那样搞，但到了Android 11时，就强制开启了scoped storage。
<img src="https://koenig-media.raywenderlich.com/uploads/2020/06/PreparingScopedStorage-twitter.png" alt="" /></p>

<h3>强制Scoped Storage</h3>

<p>到了Android 11(Android R, API 30)时，就强制了，只有应用自己的沙盒可自由读写。创建媒体文件必须 通过MediaStore API。只有少数公共区域可读可写（Documents/Downloads/Pictures）等，并且这些区域只有自己创建的文件是可见和可读的。这就导致了，应用能乱搞的区间相当有限了。</p>

<h3>细分文件种类权限</h3>

<p>到了Android 13(Android T, API 33)，更加变态了，把原来的<a href="https://developer.android.com/reference/android/Manifest.permission#WRITE_EXTERNAL_STORAGE">WRITE_EXTERNAL_STORAGE</a>/<a href="https://developer.android.com/reference/android/Manifest.permission#READ_EXTERNAL_STORAGE">READ_EXTERNAL_STORAGE</a>权限细分为对具体文件种类的操作，拆分为Image/Audio/Video三种媒体文件类型的读写。</p>

<p><strong>注意</strong>：只有当targetSdk=33时，并且运行的设备是Android 13时，才需要做权限的细分处理。也许后面的版本就会强制了，如果强制那无论taregtSdk是多少都会强制使用细分 权限。</p>

<h2>存储问题的适配</h2>

<p>前面简单的介绍了安卓存储权限的变化过程，重点还是要了解一下如何适配。因为现在已经是2023年了，Android 13(Android T)，API 33也快要普及了，所以就直接总结下现在应该怎么做。</p>

<h3>动态申请存储权限</h3>

<p>对于现在来说，动态申请权限已经是必备的技能之一了，不用多说了。就是先在应用的入口处，或者将要使用存储的地方去申请</p>

<h3>在manifest中声明<a href="https://developer.android.com/reference/android/R.attr#requestLegacyExternalStorage">requestLegacyExternalStorage=true</a></h3>

<h3>用MediaStore API来操作媒体文件(Image/Audio/Video)</h3>

<p>首先要声明具体的权限，然后用<a href="https://developer.android.com/training/data-storage/shared/media">MediaStore API</a>来操作。</p>

<h3>申请另外一个权限MANAGE_EXTERNAL_STORAGE</h3>

<p><strong>注意</strong>: 这个不管你的targetSDK是多少，只要目标运行设备是Android 11，就必须 这样做。</p>

<p>从Android 11开始，要想看到公共区域(Documents/Downloads)中的所有文件，还必须申请另外一个权限<a href="https://developer.android.com/reference/android/Manifest.permission#MANAGE_EXTERNAL_STORAGE">MANAGE_EXTERNAL_STORAGE</a>。因为理论上来说，公共区域你只能看见你自己创建的文件就够了，想看所有文件就越权了。但对于有些应用来说，如文件浏览器，或者请记录阅读器来说，肯定要能看到所有的文件。这个权限需要再次单独申请，用户授权后即可以看到公共区域的所有的文件了。</p>

<p>需要注意，这个权限像常规权限那样去申请是没用的，它的状态永远是denied的，所以，逻辑要这样写：</p>

<ol>
<li>先正常申请存储相关的权限</li>
<li>正常权限有了后，判断Environment.isExternalStorageManager()，如果 是false则需要再次申请另外一个叫做access all files的权限，通过<a href="https://developer.android.com/reference/android/provider/Settings#ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION">ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION</a>或者<a href="https://developer.android.com/reference/android/provider/Settings#ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION">ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION</a></li>
</ol>


<pre><code class="java">       // after read/write permission granted
       if (!Environment.isExternalStorageManager()) {
            requestAllFilesAccess();
        }
        // ...

   private void requestAllFilesAccess() {
        Intent intent = new Intent(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION);
        intent.addCategory(Intent.CATEGORY_DEFAULT);
        Uri uri = Uri.fromParts("package", getPackageName(), null);
        intent.setData(uri);
        try {
            startActivity(intent);
        } catch (ActivityNotFoundException e) {
            Log.d(LOG_TAG, "Exception: " + e.getMessage());
        }
    }
</code></pre>

<p>需要注意，有可能会有Activity not found exception，注意try-catch下。</p>

<p>因为这个权限又会导致失控，只要申请了就可以在公共区域随意创建文件了，所以谷歌对这个权限管控也是比较严的。虽然你在研发测试阶段可以申请这个权限，但是在发布阶段，要给应用商店一个使用此权限的合理理由，否则Play store会拒绝上线的（当然，如果 不在Play Store上面发布也就无所谓了）。</p>

<h3>合理使用公共区域</h3>

<p>作为App，最应该做的就是从业务上区分文件的属性，然后合理的选择存储空间进行存储。对于App本身运行相关的文件，如配置，如算法的模型，如数据库，缓存和日志等等应用本身运行密切相关的文件，一定不可以放在公共区域，一定要放在应用自己的沙盒内（通过<a href="https://developer.android.com/reference/android/content/Context#getFilesDir(">context.getFilesDir</a>), <a href="https://developer.android.com/reference/android/content/Context#getCacheDir(">context.getCacheDir</a>), <a href="https://developer.android.com/reference/android/content/Context#getExternalFilesDir(java.lang.String">context.getExternalFilesDir</a>), <a href="https://developer.android.com/reference/android/content/Context#getExternalCacheDir(">context.getExternalCacheDir</a>), <a href="https://developer.android.com/reference/android/content/Context#openFileOutput(java.lang.String,%20int">context.openFileOutput</a>)）等来读写，应用自己的沙盒也是属于App的自由空间，你可以随意玩。</p>

<p>对于用户生成的文件则要放在公共区域，比如说相机产出的图片和视频，编辑软件产生的文档，这些属于用户生成文件，它的所有权是用户的，可能会通过其他软件再次编辑或者分享，这些肯定要放在公共区域的。对于媒体类Image/Audio/Video则要使用<a href="https://developer.android.com/training/data-storage/shared/media">MediaStore API</a>的方式来创建和管理。对于其他文档类型，在获得了WRITE权限 后也可以在（Documents/Downloads）中创建和管理的，绝大多数情况下，这就够了。</p>

<p>总的来说，在用户隐私越来越被重视的今天，安卓现在存储管理策略在保护用户隐私的前提下是能够满足开发者使用的。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://apilevels.com/">Android API Levels</a></li>
<li><a href="https://developer.android.com/guide/topics/providers/document-provider">Open files using storage access framework</a></li>
<li><a href="https://developer.android.com/about/versions/11/privacy/storage">Storage updates in Android 11</a></li>
<li><a href="https://developer.android.com/training/permissions/requesting">Request runtime permissions</a></li>
<li><a href="https://www.geeksforgeeks.org/external-storage-in-android-with-example/">External Storage in Android with Example</a></li>
<li><a href="https://developer.android.com/training/data-storage/manage-all-files">Manage all files on a storage device</a></li>
<li><a href="https://stackoverflow.com/questions/62782648/android-11-scoped-storage-permissions">Android 11 Scoped storage permissions</a></li>
<li><a href="https://ourcodeworld.com/articles/read/1559/how-does-manage-external-storage-permission-work-in-android">How does MANAGE_EXTERNAL_STORAGE permission work in Android?</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
