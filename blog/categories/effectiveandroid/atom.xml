<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2023-02-16T08:21:32+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Introduction to Android Jetpack]]></title>
    <link href="http://toughcoder.net/blog/2023/02/15/introduction-to-android-jetpack/"/>
    <updated>2023-02-15T15:31:39+08:00</updated>
    <id>http://toughcoder.net/blog/2023/02/15/introduction-to-android-jetpack</id>
    <content type="html"><![CDATA[<p><a href="https://developer.android.com/jetpack">Android Jetpack</a>是一个由谷歌官方提供的安卓开发套件（套件是一组组件的意思），目的是帮助安卓开发者解决兼容性问题，减少重复代码，提升体验和性能，最重要的是提升开发效率。安卓以碎片化著名，不同的版本，不同的OEM厂商导致整个安卓设备碎片化严重，对App生态来说是很不友好，加之安卓本身的原因导致像流畅度，体验和性能始终逊水果不止一筹。后来谷歌推出一系列的Android SDK之外的一系列开发组件如<a href="https://developer.android.com/topic/libraries/support-library">support library</a>来解决兼容性(App compat)和新的开发组件(RecyclerView, CardView, Pager等)，后来这些东西就演变成了现在的Android Jetpack。</p>

<p><a href=""><img src="https://mobikul.com/wp-content/uploads/2020/07/navigation.png" title="auto auto" ></a></p>

<!-- more -->


<h2>缘起</h2>

<p>最开始是一坨support library，有v4有v7还有v13，它们是针对 不同的SDK版本使用的不同的兼容性组件。后来到了2017年的Google I/O，又推出了一系列叫做Android Architecture Components，然后到了2018年的Google I/O大会，把所有这一坨融合了在一起，进行了大统一，起了个新名字叫做Android Jetpack，各个组件包名统一为androidx.&#42;。这便是Android Jetpack的由来。</p>

<p>之后2019年Google I/O，已经初具格局，之后Android Jetpack就定型了，不断的向前演进，更新的频次也很快，每当有的新的技术，新的编程范式都会有所呈现，甚至有点超过Android SDK本身了。Android SDK与安卓本身是绑定在一起的，受制于底层SoC的发展，因为它毕竟是一个操作系统。但Android Jetpack却不一样，它是纯的三方软件，可以以相当快的速度在迭代，软件开发最前沿的东西都能快速得到尝试，只要它符合Android Jetpack本身的定位，会很快被纳入其中。</p>

<h2>Android Jetpack到底是个啥</h2>

<p>前面说了好多废话，下面来看一下Android Jetpack到底是个啥，它就是一套软件开发组件，由谷歌官方提供，能解决Android App开发中的比较蛋疼的问题（如兼容性和碎片化），并有很多能提升体验，提升性能提升效率的组件。</p>

<p>它提供了四大技术组件：</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 技术方向 </th>
<th style="text-align:left;"> 组件 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> Foundation components </td>
<td style="text-align:left;"> <a href="https://developer.android.com/jetpack/androidx/releases/appcompat">App compat</a><br/>Multidex<br/><a href="https://developer.android.com/training/testing/">Test</a><br/><a href="https://developer.android.com/kotlin/ktx">Android KTX</a> </td>
<td style="text-align:left;"> 兼容性组件<br/>测试框架<br/>Kotlin支持 </td>
</tr>
<tr>
<td style="text-align:left;"> Architecture components </td>
<td style="text-align:left;"> <a href="https://developer.android.com/topic/libraries/data-binding/">Data binding 数据驱动View</a><br/><a href="https://developer.android.com/topic/libraries/architecture/lifecycle">Lifecycles 生命周期</a><br/><a href="https://developer.android.com/topic/libraries/architecture/livedata">LiveData 监听数据变化</a><br/><a href="https://developer.android.com/guide/navigation">Navigation 内部页面跳转</a><br/><a href="https://developer.android.com/topic/libraries/architecture/paging/v3-overview">Paging 分页</a><br/><a href="https://developer.android.com/training/data-storage/room">Room 数据库封装</a><br/><a href="https://developer.android.com/topic/libraries/architecture/viewmodel">ViewModel MVVM式架构</a><br/><a href="https://developer.android.com/topic/libraries/architecture/workmanager/">WorkManager 耗时后台任务</a> </td>
<td style="text-align:left;"> 在架构层面能起到作用的组件<br/>增强模块化，可测试性和可维护性 </td>
</tr>
<tr>
<td style="text-align:left;"> Behavior components </td>
<td style="text-align:left;"> <a href="https://developer.android.com/training/camerax">CameraX</a><br/><a href="https://developer.android.com/develop/ui/views/components/settings">Preference</a><br/> </td>
<td style="text-align:left;"> 更好的与Android系统进行交互 </td>
</tr>
<tr>
<td style="text-align:left;"> UI components </td>
<td style="text-align:left;"> <a href="https://developer.android.com/develop/ui/views/animations">Animations and Transitions</a><br/><a href="https://developer.android.com/develop/ui/views/text-and-emoji/emoji-compat">Emoji</a><br/><a href="https://developer.android.com/guide/fragments">Fragments</a><br/><a href="https://developer.android.com/develop/ui/views/graphics/palette-colors">Palette 调色板</a><br/><a href="https://developer.android.com/develop/ui/views/layout/declaring-layout">Layouts</a> </td>
<td style="text-align:left;"> 更丰富更强大的UI部件，<br/>体验好，兼容性好，易于使用 </td>
</tr>
</tbody>
</table>


<h2>为何要用它</h2>

<p>自从2019年起统一成了Android Jetpack后，它相较之前分散的support library在整个生态中的地位不一样了，现基本上与Android SDK有着同等的重要性，甚至很多东西都会优先被放到Jetpack里面。</p>

<p>毕竟它是由谷歌官方主推的东西，是由正统的Android专家写出来的，质量是有保证的。并且现在它的迭代速度也很快，生态上已形成闭环，如果能解决项目上的问题，当然首选Android Jetpack。</p>

<h2>Jetpack Compose又是个啥</h2>

<p>在2019年的Google I/O与Jetpack一起发布的还有一个叫做<a href="https://developer.android.com/jetpack/compose">Compose</a>的东西，它是一个符合<a href="https://m3.material.io/develop/android/jetpack-compose">Material Design</a>的全新的写UI的方式，基于Kotlin语言。
需要注意的是Compose是一种构建原生UI的方式，它用Kotlin DSL的方式来构建 UI，而不是原始的View和XML，它有点类似于早先的anko。</p>

<p>需要特别注意的是，它并不像Android Jetpack那样是一种三方组件，而是一种构建原生UI的方式，它的野心也比较大，并不局限于构建Android UI，现在也支持构建 Desktop UI了，重点理解它是一种构建UI界面的工具，至于底下的平台可以适配到任何平台。结合Kotlin，Kotlin也在做<a href="https://kotlinlang.org/docs/multiplatform-mobile-getting-started.html">KMM Kotlin Multiplatform Mobile</a>，也即跨平台的Kotlin，以后的Compose可以生成任何平台的目标文件。</p>

<p>所以，学习Compose的曲线就要比Jetpack要陡峭得多了，因为Jetpack其实就是额外的一些三方组件，但Compose是一种全新的构建UI的方式，需要系统的学习才能掌握它。并且除非你从头搭建app，否则Compose很难与现有的UI构建方式(View和XML)融合在一起。其实这种东西并不新鲜，从<a href="https://reactnative.dev/">React Native</a>到<a href="https://flutter.dev/">Flutter</a>都是这种可以构建跨平台UI的工具(虽然RN和Flutter并不仅仅是UI，它们号称跨平台构建App，UI是跨平台最大的挑战，因为每个平台的原生UI构建方式都不一样，非UI部分，做一层API的桥接就可以做到)。</p>

<p>而且感觉Compose想要挑战RN和Flutter难度也不小，因为RN和Flutter出生就是为了跨平台开发，而Compose是生于安卓UI，它们的出发点的高度并不一样，是因为有了Kotlin KMM的支持，所以有想跨平台的野心。其实Compose是被<a href="https://developer.apple.com/cn/xcode/swiftui/">水果Swift UI</a>逼出来的，所以它的定位与Swift UI是一样的。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://blog.mindorks.com/what-is-android-jetpack-and-why-should-we-use-it/">What is Android Jetpack and why should we use it?</a></li>
<li><a href="https://stackoverflow.com/questions/50251658/what-exactly-is-android-jetpack">What exactly is Android Jetpack?</a></li>
<li><a href="https://www.geeksforgeeks.org/foundation-components-of-android-jetpack/?ref=lbp">Foundation Components of Android Jetpack</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introduction to WebSocket]]></title>
    <link href="http://toughcoder.net/blog/2023/01/14/introduction-to-websocket/"/>
    <updated>2023-01-14T18:02:12+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/14/introduction-to-websocket</id>
    <content type="html"><![CDATA[<p><a href="https://javascript.info/websocket">WebSocket</a>是HTML5带来的新时代网络通信协议，它让前端的能力再一次得到提升，因为通信不再是单向的了。最初<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">在浏览器和JavaScript</a>中有很好的支持，现在各种编程语言和平台都支持WebSocket协议了。今天就来学习一下它。</p>

<p><a href=""><img src="https://cdn.educba.com/academy/wp-content/uploads/2019/05/What-is-WebSocket.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>缘起</h2>

<p>在以往的前端中通过Ajax或者Jsonp可以让前端像一般的桌面客户端一样，有了更好的交互方式，但总的来说仍然局限于单向通信，因为底层的协议仍是HTTP，只能由客户端发起请求，服务器来响应。对于更新潮的需求，比如服务器向客户端推送消息，用HTTP来实现就略显笨拙了，常规的方法就是<a href="https://en.wikipedia.org/wiki/Comet_(programming">建立长链接</a>)或者让客户端来轮询（polling），但这显然效率不高。于是就有了<a href="https://en.wikipedia.org/wiki/WebSocket">WebSocket</a>，它支持双向通信（全双工通信信道），除了客户端主动发起请求外，服务器也可以主动向客户端推送消息。通信效率和交互性又一次得到了大大的提升。</p>

<p>就协议本身来说，它与HTTP一样，都是基于TCP实现的，对于协议本身想要深入了解的，可以去看<a href="https://www.rfc-editor.org/rfc/rfc6455">协议规范</a>。</p>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.b0ueeCtwidYP_RDzAWPVOgHaF_?pid=ImgDet&amp;rs=1" alt="" /></p>

<p>另外，需要注意，WebSocket协议的地址的schema是<strong>wss://xxxx</strong>。</p>

<h2>WebSocket in Android</h2>

<p>安卓平台也已经有了现成的WebSocket协议可以使用了，已经比较成熟了，直接使用就行了。</p>

<ul>
<li><a href="https://github.com/TooTallNate/Java-WebSocket">Java-WebSocket</a> 是一个WebSocket协议的纯Java实现，适用于所有JVM平台</li>
<li><a href="https://socket.io/">Socket.IO</a> 这个不单单是WebSocket，它在WebSocket协议基础之上又进行了进一步的封装，在API的易用性面以及错误处理和状态处理上面有了不少的提升。各种语言平台基本都有支持了。</li>
</ul>


<h2>测试服务器</h2>

<p>光有客户端还不够，还需要有测试服务器，整理一下如何搭建测试服务器。</p>

<h3>公有的测试服务器</h3>

<p>在线的免费的可公开使用的简单WebSocket服务器，一般都是echo式的，也即把请求的数据直接当成回复推给client，这个可以当作chat类的测试server。</p>

<ul>
<li><a href="wss://echo.websocket.org">wss://echo.websocket.org</a></li>
<li><a href="https://socketsbay.com/test-websockets">wss://socketsbay.com/wss/v2/1/demo/</a></li>
<li><a href="https://glitch.com/~websocket-echo">WebSocket on Glitch</a></li>
</ul>


<p><img src="https://quarkus.pro/guides/images/websocket-guide-architecture.png" alt="" /></p>

<h3>自已搭建服务器</h3>

<p>此外，就是用WebSocket服务端的组件来自己搭建服务器，当然也都有现成的组件，配置一下就可以了，只不过需要运行在自己的Server上面。</p>

<ul>
<li><a href="https://socket.io/">Socket.IO</a> 对的，这货Server端Client端全套都提供了</li>
<li><a href="https://github.com/uNetworking/uWebSockets">uWebSockets</a> 核心库是用C/C++实现的，可以与Node.js无缝衔接</li>
<li><a href="https://github.com/theturtle32/WebSocket-Node">WebSocket-Node</a> 基于Node.js，用纯JavaScript实现的</li>
<li><a href="http://websocketd.com/">websocketd</a> 一个独立的WebSocket Daemon，不依赖于其他的组件，功能强大，配置简单，方便使用，只需要提供一个Shell脚本就可以了</li>
<li><a href="https://github.com/jmalloc/echo-server">echo-server</a> 基于Go实现的，支持HTTP协议和WebSocket协议的echo server</li>
<li><a href="https://pypi.org/project/echo-server/">python echo server</a> 基于Python的echo server，不确定是否支持WebSocket</li>
<li><a href="https://echo.labstack.com/">Echo</a> 基于Go的Echo Web Frameworks</li>
<li><a href="https://github.com/websockets/websocket-echo-server">WebSocket echo server</a> 基于Node.js</li>
</ul>


<h2>参考资料</h2>

<ul>
<li><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html">WebSocket 教程</a></li>
<li><a href="https://github.com/nkzawa/socket.io-android-chat">socket.io-android-chat</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/23467317">WebSocket 与 Socket.IO</a></li>
<li><a href="https://juejin.cn/post/6844903577438126094">Android WebSocket 编程</a></li>
<li><a href="https://www.jianshu.com/p/7b919910c892">Android WebSocket实现即时通讯功能</a></li>
<li><a href="https://www.jianshu.com/p/4e80b931cdea">Socket.io</a></li>
<li><a href="https://www.lob.com/blog/websocket-org-is-down-here-is-an-alternative">Websocket.org Is Down, Here Is an Alternative</a></li>
<li><a href="https://blog.postman.com/introducing-postman-websocket-echo-service/">Introducing Postman’s WebSocket Echo Service</a></li>
<li><a href="https://www.piesocket.com/blog/echo-websocket-org-alternative">An Alternative To Echo.WebSocket.Org – Live WebSocket Server
</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android逆向技术高阶大法]]></title>
    <link href="http://toughcoder.net/blog/2022/01/23/android-reverse-engineering-tricks/"/>
    <updated>2022-01-23T11:39:55+08:00</updated>
    <id>http://toughcoder.net/blog/2022/01/23/android-reverse-engineering-tricks</id>
    <content type="html"><![CDATA[<p>安卓应用是一个客户端，与传统软件类似，需要把软件打包，然后通过某种渠道（应用市场）分发给用户，这是常规的发布方式，它的更新节奏很慢，从你在应用市场上更新后，到用户真正的执行升级，这中间很慢的，而且很多用户根本不会升级新版本，这对于互联网来说是极不友好的。传统的互联网，用户刷新一下网页后，就能看得到更新了，但对于客户端，这行不通，要想实现小时级别的发布和分钟级别的问题修复，正规的发布渠道是做不到的。于是各路大神和专家开始研究客户端的前端化，也就是运用各种技术能让发布，特别是一些问题修复性的小规模发布可以更快的传递到用户手中。</p>

<p><a href=""><img src="https://images.xiaozhuanlan.com/photo/2017/3709753fdbe5d81e50abb1090511b92a.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>这与正向方法不一样，谷歌或者水果针对 应用市场有明确 的流程的，这是常规发布也即是正向方式。今天我们来聊一聊非正向方法，非常规方式，来实现小模块的发布和热修复。</p>

<h2>核心技术原理</h2>

<p>任何一项技术都离不开编程语言和操作系统上的支持，对于插件化技术来说，最为核心的原理就是Java支持反射，这是一种运行时修改代码的技术，另外就是动态代理，这是插件化可行的根本技术支撑。</p>

<p>说到底，Java仍是一种解释型语言，它的核心是JVM，即也虚拟机，我们所熟悉的Java编程语言，本质上是套在JVM上的一层语法规则，换了一种语言规则也是可行的。就好比Kotlin，Scala和Groovy它们的语法与Java相差很大，但它们编译过后的字节码是完全符合JVM规范的，可以直接运行在JVM之上。</p>

<p>其他的纯解释型语言，如Python和JavaScript，它们在运行时可以动态的加载一段源码，这即是动态化，可以实现真正的插件化，运行时直接加载运行一段代码。Java略变态一些，但它本质上是JVM，而JVM通过反射和动态代理，在一定程度上支持了类似的动态化，就是通过ClassLoader来动态加载一些编译好的Class。</p>

<p>此为插件化的核心原理。</p>

<p>动态代理机制，可以读这几篇文章：</p>

<ul>
<li><a href="https://www.cnblogs.com/bryan31/p/15266725.html">动态代理大揭秘，带你彻底弄清楚动态代理</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1264804593397984">动态代理</a></li>
<li><a href="https://www.cnblogs.com/techyc/p/3455950.html">Java的动态代理(dynamic proxy) </a></li>
<li><a href="https://www.cnblogs.com/gonjan-blog/p/6685611.html">java动态代理实现与原理详细分析</a></li>
<li><a href="https://www.cnblogs.com/codingblock/p/6580364.html">小白也能看懂的插件化DroidPlugin原理（一）&ndash; 动态代理</a></li>
</ul>


<h2>Hook大法</h2>

<p>有了核心原理，才有可行的方案。Hook主要研究三方面内容，一是研究ClassLoader，因为不同的dex分属于不同的层级，它们的ClassLoader不一样，反射的第一步就是要能加载到想要的Class，这个要靠找到合适的ClassLoader；二是动态代理机制，hook的核心原理就是用动态代理机制，创建一个Mock对象用以替换掉原来的，所以接口Interface是关键，原系统设计中必须使用大量接口，并且是以标准方式使用的（没有强制向下转型downcast），这样你创建出来的动态代理去替换才是安全的；三就是学习安卓系统核心组件 的流程，以找到最佳的hook地点。</p>

<p>其实，第3条才是对大部分人最为有益的。</p>

<p>具体如何做hook，可以参考以下文章：</p>

<ul>
<li><a href="https://cloud.tencent.com/developer/article/1562137">Android 插件化原理解析——Service的插件化</a></li>
<li><a href="https://weishu.me/2016/03/07/understand-plugin-framework-ams-pms-hook/">Android 插件化原理解析——Hook机制之AMS&amp;PMS</a></li>
<li><a href="https://mp.weixin.qq.com/s/40NTVRw127JcJh_rL5HtwA">探索Android开源框架 - 10. 插件化原理</a></li>
<li><a href="https://www.cnblogs.com/codingblock/p/6642476.html">小白也能看懂的插件化DroidPlugin原理（二）&ndash; 反射机制和Hook入门</a></li>
</ul>


<p>由于安卓版本升级的原因，上面这几个文章都失效了，例子行不通了。但是这几遍对于原理解释的还是相当清楚的。</p>

<p>以下文章对于新版本也是适用的。</p>

<ul>
<li><a href="https://www.codenong.com/js57705d332677/">基于Android9.0的Hook Activity 的启动（插件化）</a></li>
<li><a href="https://www.jianshu.com/p/eb4121b037e2">Android Hook Activity 的几种姿势</a></li>
<li><a href="https://juejin.cn/post/6844903769650511879">Activity插件化原理第一种方案：Hook Instrumentation</a></li>
<li><a href="https://juejin.cn/post/6844903773823827975">Activity插件化原理第二种方案：Hook IActivityManager</a></li>
<li><a href="https://blog.csdn.net/qq_24675479/article/details/79334567">拦截Activity的启动流程绕过AndroidManifest检测</a></li>
</ul>


<p>需要注意的是，hook这件事情，最基础的技术很简单，就通过反射来替换对象，把系统中的对象替换为仿造的，仿造有三种方式，一是直接创建，这需要类是比较简单的情况，并不需要开放出来，通过反射一切皆可创建；二是继续，这个对于复杂对象也能仿造，如Instrumentation，但是需要类是开放出来的；三是接口，通过动态代理 创建仿造对象（也即代理 ）。核心技术就这些。其他的，全是对于系统代码的理解，找到可行的关键点来进行hook。</p>

<p>另外就是，谷歌对逆向方法限制越来越严了，反射系统的东西，会有限制，有时仅是打印日志，但指不定哪天就不给反射了。</p>

<pre><code>Accessing hidden field Landroid/app/ActivityManager;-&gt;IActivityManagerSingleton:Landroid/util/Singleton; (light greylist, reflection)
</code></pre>

<h2>插件化原理</h2>

<p>学习一门技术最好的方式就是去研读优秀的开源库的源码，对于插件化，现在有很多比较成熟 的开源框架存在了，可以挑几个比较有代表性的来研究 一下。</p>

<h3><a href="http://droidpluginteam.github.io/DroidPlugin/">DroidPlugin</a></h3>

<p>这个基于动态代理创建的插件方法，较为流行，里面有大量的hook技术，网络上也有很多解析此框架的<a href="https://blog.csdn.net/zhejiang9/article/details/89407283">文章</a>，可以帮助理解。</p>

<p>它用了大量的hook，优点就是插件本身可以是正常的apk，无太多的限制，就用常规的app开发方式开发就好，这是它的最大优势，因为对插件无限制，所以框架本身就需要做大量的hook，是学习hook技法的良好例子。</p>

<h3><a href="https://github.com/singwhatiwanna/dynamic-load-apk">DL : Apk动态加载框架</a></h3>

<p>这个是以静态代理为基础创建的插件框架，并没有大量的hook，可以参看它的解析<a href="https://www.jianshu.com/p/30114b7176a3">文章</a>。</p>

<p>任大神的框架适配性较好，基本上是纯软件层的技术（静态代理），没怎么hook。当然缺点也相当明显，就是对于插件的开发要求很苛刻，必须实现框架本身自定义的一坨东西，与安卓标准的app开发差异较大，且越来越大，并且对于打包和开发过程并无工具支持，在实际应用过程中较为麻烦。退一步讲，并未有真正达到插化的目的，它对插件的限制较大。</p>

<p>现在已经基本没人用了，不过这属于开山之作。</p>

<h3><a href="https://github.com/iqiyi/Qigsaw">Qigsaw</a></h3>

<p>这个与其他插件框架的最大差别在于，它最接近于官方的东西（<a href="https://developer.android.com/guide/app-bundle/">App bundle</a>），它的重点在于项目模块化和打包上面，对于常规理解上的『插件』所做的事情特别少，hook特别少，安装和加载插件的过程比较很简单，接近原生，核心在于它的打包过程。<a href="https://www.bookstack.cn/read/Qigsaw/c47ca9c7359b0d0d.md">这里</a>有详细的介绍。</p>

<p>另外，包建强的书<a href="https://item.jd.com/12408095.html">《Android插件化开发指南》</a>也可以读一读的，书的好处在于，它毕竟是一个整体，从基础的技术原理到hook原理都有讲，还是相当不错的。不过书比较旧了 ，要结合<a href="https://www.cnblogs.com/Jax/p/9316422.html">作者的勘误</a>，以及网上的文章一起来消化理解。</p>

<h2>热修复原理</h2>

<p>除了插件化，另外一个大厂热衷的技术便是热修复，这也是大厂头部应用的标配技术。其实插件化，也能实现热修复，比如某个插件，一般是厂里的一个业务，出问题了，紧急打包发布一个修复的版本，然后更新插件。不过，这略显笨重，相当于用牛刀去杀鸡了，总之就是效率不高。</p>

<p>真正的热修复技术讲究效率，且要小巧，针对 点对点式的修复。它的核心原理就是替换，用反射去替换类（修改dex classloader中的dex顺序），以及对方法的替换（侵入虚拟机中的method表，进行替换），还分冷生效（类替换一般是冷生效，也即下次启动时生效）和热生效（方法替换一般是热的，下次调用此方法时就生效了，因为它并不涉及classloader，无需要重新加载类），还有插桩式的，在代码中直接插桩，先检查有没有patch，有patch就先运行patch（这个思路最简单，适配性也好，但实行难度大，需要对现有代码进行插桩）。</p>

<p>这几篇文章有比较详细的讨论。</p>

<ul>
<li><a href="https://www.cnblogs.com/popfisher/p/8543973.html">Android热修复技术原理详解</a></li>
<li><a href="https://www.jianshu.com/p/6ae1e09ebbf5">Android热修复技术，你会怎么选？</a></li>
<li><a href="https://www.jianshu.com/p/8891f95f6e8e">探索Android开源框架 - 11. 热修复原理</a></li>
</ul>


<h3>具体的热修复工具</h3>

<h4>xposed派系</h4>

<p>也即原生的<a href="https://github.com/rovo89/Xposed">Xposed</a>和<a href="https://github.com/rovo89/XposedBridge">Xposed framework</a>
以及大阿里的衍生版本<a href="https://github.com/alibaba/dexposed">dexposed</a>。</p>

<p>针对 方法可以热生效的hook，当年Dalvik时代，这个东西还是相当牛逼的，时过境迁虽然Art上无法用了，但不妨用来学习。</p>

<h4><a href="https://github.com/alibaba/AndFix">Andfix</a></h4>

<p>原产自支付宝的与Xposed类似的方法级的hook工具，支持Dalvik与Art，值得使用和学习。</p>

<h4><a href="https://github.com/panhongwei/AndroidMethodHook">AndroidMethodHook</a></h4>

<p>可以用来学习sophix，sophix是大阿里的东西，把andfix以及dexposed商业化了，不再开源免费用了。这个项目比较接近它们，可以用来学习。</p>

<h4><a href="https://github.com/Tencent/tinker">Tinker</a></h4>

<p>微信出品的Tinker，核心技术还是用dex替换实现的class替换，冷生效。</p>

<p>它的重点在于补丁dex的差量生成，以及发布平台，还做成了收费平台，变成一种服务。所以，你看核心技术是由目标平台（安卓）决定的，原理大家也都懂，各家也都大差不差的，也都有开源现成的方案可以用，但这远远不够，整个链路是值得深挖的，这也是能产生商业价值的地方。</p>

<h4><a href="https://github.com/dodola/HotFix">HotFix</a></h4>

<p><a href="https://zhuanlan.zhihu.com/p/20308548">安卓App热补丁动态修复技术介绍</a></p>

<h4><a href="https://github.com/jasonross/Nuwa">Nuwa</a></h4>

<p><a href="https://www.cnblogs.com/fanfu1/p/5506149.html">安卓热更新之Nuwa实现步骤</a></p>

<h4><a href="https://github.com/Meituan-Dianping/Robust">Robust</a></h4>

<p><a href="https://tech.meituan.com/2017/03/17/android-autopatch.html">Android热更新方案Robust开源，新增自动化补丁工具</a></p>

<p>这个与Nuwa一样，都用了代码插桩，当然插桩过程，是用了字节码工具（如ASM），进行编译时自动化处理，最终字节码（APK）是受影响的，但源码层面是无感知的。</p>

<h2>瓶颈在哪里</h2>

<p>插件化这项技术，它的成本特别高，但收益有限，需要庞大的研发体系来支持，并且只有长期投入，才能产出一些价值。因此，现在来说只有头部大厂才真正玩得转。</p>

<h3>技术本身并不是瓶颈</h3>

<p>这项技术的可行性是由Java决定的，因此一直是可行的。但每年的Android版本，都会对核心组件进行不同程度的强化和升级，这会导致之前的一些方案可能一下子就失效了。另外，手机厂商可能也会做一些修改，不过一般都比较小。</p>

<p>安卓 版本升级，会对插件化有影响，甚至会让现有方案全部失效，但这个还真不是这项技术的瓶颈。因为安卓 升级较慢，正常一年一个版本，但是对核心组件大变化，通常几年才有一次，这个速度对比三方技术的演进还是相当慢的。前面说了这项技术头部大厂最为受益，因此他们会有专门的专家级别的人物在研究，谷歌出了政策，很快就会对策出来，一般用不了多久，插件化技术大拿们就能给出针对 新版本的解决方案。</p>

<p>由于开源和技术分享，很快便会在业界普及。因此，单就技术本身，绝不是瓶颈，并且由于开源的发展，核心业务本身都是开源的，大家都能很快使用最先进的技术。</p>

<h3>网络和平台能力才是瓶颈</h3>

<p>插件化这个事情，想要真正的用好，光有核心业务还是不够的。核心业务现在都有现成的开源库，拿过来就可以用，但这远远不够。</p>

<p>就从一个插件从开发人员手中到用户手中，并成功安装生效，这一过程拆来看需要多少东西吧：</p>

<ol>
<li>插件的开发，需要一些辅助工具。理想的情况下，一个插件模块的开发，应该与常规应用开发是一样的，但毕竟它的构建目标是一个插件，而非标准的app，所以你需要针对核心业务插件框架适用的一些开发工具。这个一般开源框架中都有提供，但不见得有那么好。</li>
<li>构建和打包。如果是一个合格的插件化框架，一定会有怎么构建 打包的配套设施。</li>
<li>测试和调试。这里面的难点在于，如何能尽可能的模拟真实的流程，并且能方便的来实施测试和验证结果</li>
<li>发布上线控制。一些细节就是如何精准推送，如何做灰度发布，以及发现问题后如何快速回滚（你看，这哪一项涉及插件化技术）</li>
<li>下载。客户端的一个最大的问题就是，客户端在客户那里，我们发布的东西都在服务器上，如何能让插件顺利的送达到用户手中。别小看这个，网络问题永远是出错误原因里面最多的一个，而且容易被测试忽略，因为研发人员自己的网络环境一般简单且稳定。（一个最简单的测试就是，当你在电梯里，地铁里，高铁时，厕所里，山上，河里，村里，手机里面的应用还有几个能正常联网的？）</li>
<li>安装和生效。这个也是插件化的核心业务，框架都会支持的。难点在于校验，就是客户端拿到的插件是不是符合预期的，文件有没有损坏，有没被篡改。</li>
<li>降级。这个通常插件化框架不会提供。降级的意思就是如果插件安装更新失败了，你怎么办？能否回滚，如果这个插件彻底废了，有没有H5页面可以用？</li>
</ol>


<p>我们粗略来看，就能分出上面7个步骤，其实还有更细的。上面这些里，插件化开源框架一定能解决的是2和6，1和3会在一定程度上支持。而其他的只有靠自己了，当然 也可能会有一些开源软件可以用，但它们并不纯是为了插件化而做的。这些东西都属于研发效率平台，甚至是涉及软件流程，基本上都属于商业公司的核心业务机密了，基本上是不可能开源的，而且不同的公司文化制度流程都不一样，即使开源给你了，也不一定用得上。但这恰恰又是最能体现一个公司结合技术实力的地方，小公司或者综合能力差的公司，即使有现成的插件化框架方案给你，你也用不好，因为配套设施不行。再次佐证，插件化这东西只有头部大厂才能玩得转，并产生正收益。</p>

<p>这些才是真正的瓶颈。</p>

<h2>这是逆向工程技术</h2>

<p>插件化需要用到大量的反射和动态代理技术去hook安卓系统，从而实现官方并不直接支持的特性，这属于逆向工程，与官方倡导的方向并不一致。</p>

<p>而且，只有在国内圈子里面才比较流行，国外的一些大厂和专家似乎并不愿意花时间和精力搞这些事情。很难简单的用好与坏来评价，只能说文化不同。</p>

<p>逆向工程技术局限性较大，很难长久发展， 一旦官方把某个关键地方堵住（不能说是漏洞，而一些关键的对象和接口），很多插件框架可能就废掉了，当然了道高一尺，魔高一丈，总还是能找到可以hook的地方，仍总感觉怪怪的。</p>

<p>常规的技术，如编程范式（函数式编程，Reactive，RxJava），编程语言，平台框架和轮子（如Picasso，如OkHttp），这些是纯正的技术，不受制于任何平台，不但能长久发展，更能反过来推动官方进步（如OkHttp已被谷歌内置为安卓内部作为HTTP协议的实现）。</p>

<p>综合来说，除非你需要专门研究插件化，并能得到收益之外（对业务，对公司，对个人），对于插件化技术，了解一下就够了，而且这东西并不能真正的提升软件质量（它带来的问题比它解决的要多很多）。不如把时间花在业务上面，花在编程范式，花在编程语言，花在流行的框架和轮子上面，这更能提升软件质量，且是终生受益的。毕竟，假如代码质量够好，发出去的版本都可控，都能达到预期，也就没必要折腾插件化了（即使是对大厂头部应用来说，版本的发布仍主要是靠正常的apk发布，插件迭代一般用在正常版本来不及时使用比如电商的双11期间）。</p>

<p><strong>研发工具（如Instant Run），调试工具（如获取 一些运行时的信息，在线调试），测试工具（如Mock），不侵入源码式编程（动态插桩，AOP和依赖注入）</strong>才是反射和动态代理以及Hook的最终归宿，是值得我们深入研究和学习的方向。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.kancloud.cn/alex_wsc/android/504478">动态注入技术（hook技术）</a></li>
<li><a href="https://www.jianshu.com/p/b30ea19c444b">Android插件化原理解析——Hook机制之动态代理</a></li>
<li><a href="https://blog.csdn.net/yulong0809/article/details/56842027">插件化知识详细分解及原理 之代理，hook，反射</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/109157321">盘点Android常用Hook技术</a></li>
<li><a href="https://www.jianshu.com/p/4f6d20076922">理解 Android Hook 技术以及简单实战</a></li>
<li><a href="https://tech.meituan.com/2018/02/02/android-anti-hooking.html">Android Hook技术防范漫谈</a></li>
<li><a href="https://juejin.cn/post/6844903941105270798">Android插件化——高手必备的Hook技术</a></li>
<li><a href="https://blog.csdn.net/gdutxiaoxu/article/details/81459830">Android Hook 机制之简单实战</a></li>
<li><a href="https://juejin.cn/post/6998085562573783076">字节跳动开源 Android PLT hook 方案 bhook</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转安卓运行速度优化]]></title>
    <link href="http://toughcoder.net/blog/2022/01/14/android-cpu-optimization-made-easy/"/>
    <updated>2022-01-14T23:14:55+08:00</updated>
    <id>http://toughcoder.net/blog/2022/01/14/android-cpu-optimization-made-easy</id>
    <content type="html"><![CDATA[<p>早在许多年以前写过<a href="http://toughcoder.net/blog/2015/09/11/android-performance-profiling-made-easy/">一篇安卓性能优化文章</a>，时过境迁，很多事情都有了变化，所以再专门针对程序运行速度和渲染的优化，这两方面非常直接的影响应用程序的操作流畅度，也可以称作流畅度优化方法，但更为专业的方式就是CPU优化，因为就是要提高代码的运行速度。</p>

<p><a href=""><img src="https://bs-uploads.toptal.io/blackfish-uploads/uploaded_file/file/192945/image-1582543505866-a62a10ab903703bc995fcaab8ccd0bd0.png" title="auto auto" ></a></p>

<!-- more -->


<h2>需要优化的地方</h2>

<p>总的来说，就是应用程序运行要快，大体可以分为三块：</p>

<h3>应用启动要快</h3>

<p>从用户点击了桌面的图标到用户能完整见到页面，这个过程要快。其实也不是快，而是没有能从用户感知得到的卡，或者黑屏或者白屏。</p>

<h3>渲染要快</h3>

<p>也就是说View的渲染要快，无明显的Jank，也即卡顿和丢帧。</p>

<h3>操作要流畅</h3>

<p>主要是针对动画，滑动，转场的时候要流畅，也并不一定就是要真的快，而是说从用户感知的角度来看没有明显的卡顿和丢帧。</p>

<h3>业务逻辑要快</h3>

<p>也就是说要快速的完成你的业务逻辑，这个其实没有办法一概而论，取决 于具体的业务逻辑和实际的使用场景，比如网络不好的时候肯定啥都慢啊。</p>

<p>我们常说的性能优化，一般重点是在启动，渲染和操作流畅度上面下功夫，因为这些东西的优化方法更为通用一些，用户感知也更明显一些。也将是我们后面要讨论的重点内容。而至于像业务逻辑，每个具体的应用程序都不一样，所以没有办法一概而论，而常规的一些小的优化技巧也不会起决定性使用。比如说I/O优化方法，缓存的使用，以及像内存优化等等，确实能帮助你的业务逻辑。但如果业务逻辑就是特别复杂，或者代码写的很差劲，明明一个网络请求就能搞定的事儿，非要弄四五个请求，那你再怎么优化细节，比如把每个请求速度都优化到最好，I/O优化到最好，也是没有多大提升的。</p>

<h2>运行速度分析方法</h2>

<p>前面提到的启动优化，渲染优化和操作流畅度优化，其实都是针对CPU的优化，也即代码执行的优化，只不过重点分析那三个场景而已。</p>

<p>具体的分析方法主要就有两方面，一是用Profiler抓取trace，另外就是可以在代码中加入打点数据。</p>

<p>可以先行用代码代码打点的方式进行粗略的量化，比如说看onCreate执行了多久，看onResume执行了多久，这有两方面好处，一是可以粗略的定位问题，二是方便监控，比如你优化前与优化后的对比，能知道到底是否真的有提升。</p>

<p>精细化分析的方法就是抓trace，然后看具体哪里耗时了，具体使用方法可参后面的罗列的资源都相当详细，就不重复了。</p>

<p>需要注意的就是分析trace时除了用<a href="https://developer.android.com/studio/profile/android-profiler">Profiler</a>以外，还可以用<a href="https://ui.perfetto.dev/#!/">Perfecto</a>，这个功能更为强大。</p>

<h2>优化方法</h2>

<p>具体的优化方法，就没有银弹了，做的事情特别多，代码特别复杂，逻辑特别多特别复杂，优化起来难度自然很大。</p>

<p>核心的原则就是少，少即是多，少做事，特别是主线程，能lazy则lazy，能异步则异步，涉及I/O时，要多用BufferedStream，巧用缓存，buffer尽可能要是8k大小（8192），有重I/O的场景要用nio库。View tree要尽可能精简和扁平，某些特殊条件才会显示的页面就用ViewStub先占着等等。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://juejin.cn/post/6950608825942868004">Android 性能优化总结</a></li>
<li><a href="https://developer.android.com/studio/profile/cpu-profiler">Inspect CPU activity with CPU Profiler</a></li>
<li><a href="https://developer.android.com/topic/performance/tracing">Overview of system tracing</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/27331842">手把手教你使用Systrace（一）</a></li>
<li><a href="https://source.android.google.cn/devices/tech/debug/systrace">Understanding Systrace</a></li>
<li><a href="https://developer.android.com/studio/profile/measuring-performance">Overview of measuring app performance</a></li>
<li><a href="https://developer.android.com/studio/profile/benchmarking-overview">Benchmark your app</a></li>
<li><a href="https://blog.csdn.net/u011578734/article/details/109497064">性能分析工具Systrace的使用详解</a></li>
<li><a href="https://juejin.cn/post/6844903912395243533">Android Systrace 使用方法</a></li>
<li><a href="https://juejin.cn/post/6844903734263152653">Android性能优化之CPU Profiler</a></li>
<li><a href="https://www.jianshu.com/p/38fbf61c48c5">CPU Profiler 使用指南</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让你不再惧怕内存优化]]></title>
    <link href="http://toughcoder.net/blog/2022/01/13/android-app-memory-optimization-made-easy/"/>
    <updated>2022-01-13T23:37:36+08:00</updated>
    <id>http://toughcoder.net/blog/2022/01/13/android-app-memory-optimization-made-easy</id>
    <content type="html"><![CDATA[<p>之前曾经写过一篇关于<a href="http://toughcoder.net/blog/2015/09/11/android-performance-profiling-made-easy/">如何做性能优化的文章</a>，现在针对内存这一专项再做精细化的讨论。对于安卓应用开发来说，内存究竟会遇到什么样的问题，有什么方法可以用来测试和分析，以及有什么样的策略可以去实践优化，今天就来好好聊聊这个话题。</p>

<p><a href=""><img src="https://blog.singsys.com/wp-content/uploads/2017/09/memoryLeak.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>缘起</h2>

<p>现代计算机是基于冯*诺依曼架构的，计算机的软件是运行在内存之中的，进程（也即运行中的程序）会耗费一定的内存，才能够正常执行。
在软件开发的中世纪，C和C++盛行的时代，是由软件开发人员（下称猿）自己管理内存，也就是说猿自己申请内存，并处理申请不到内存的情况，并在使用完成后自己负责释放内存，这无疑会加大程序开发难度，产生一些难以调试的问题，如内存越界或者内存踩踏。到了近现代，自动内存管理成为主流，研发人员不再用自己去手动管理内存了，尽管用，可劲儿造，由GC（也即是Garbage Collector内存回收器）来善后。</p>

<p>这极大的解放了研发人员的双手，可以让他们把更多的精力放在接收产品经理的需求上面了，三天一小需求，一周一大需求，产品迭代速度相当快，业务发展迅速，老板相当高兴啊，这干掉BAT指日可待，赶英超美就在明天，IPO触手可及。然而，现实是极其骨感的。</p>

<h2>内存问题会引发什么问题</h2>

<p>对于安卓 应用程序来说，内存优化很重要，因为Java VM本身就是比较耗资源的，当应用复杂到一定程度的时候，就会出现由内存使用不当造成的问题。如，测试同学反馈说应用越用越卡，经常crash，用户也反馈说应用越来越不好用了。老板把老猿叫进办公室一顿骂，然后老板让老猿尽快来解决一下问题。</p>

<p>老猿只得把需求放一边，花时间看一看这些问题，然后说凭我多年经验来看，这怕是内存出了问题。</p>

<p>前面提过，现代编程语言一般都有GC，帮助研发人员管理内存。但由于各种原因，还是会出现内存相关的问题。</p>

<p>特别是对于安卓猿来说，实现应用的编程语言是Java（准确说是JVM，Java和Kotlin 以及像Scala都是基于JVM的编程语言），天生支持GC，导致很多人对内存管理知之甚少。当应用程序复杂到一定程度，当源码庞大到一定的量级时，性能问题，特别是内存性能问题便随之而来。</p>

<p>具体可能是内存出现问题的场景有：</p>

<ol>
<li>OOM导致的crash。OOM，也即OutOfMemoryError，可能发生在任何地方，当Heap中可用内存不足时，便可能会遇到此类crash</li>
<li>应用程序越用越慢，出现黑屏或者白屏。</li>
<li>UI操作出现卡顿，不流畅。造成UI卡，不流畅的原因很多，当排除了其他原因时，就是内存问题了</li>
<li>应用程序莫名闪退</li>
</ol>


<h2>内存问题的具体类型及其原因</h2>

<p>要想做好内存优化，则必须先弄懂内存问题的根本原因，然后再对内存问题进行归类，最后是通过技术手段来解决。</p>

<h3>内存问题的根本原因</h3>

<p>安卓应用程序是由Java构建的，而Java是支持GC的编程语言，所以安卓猿是不需要自己手动的去做内存管理的，只管不停的创建对象即可，Java虚拟机（JVM）会帮助我们管理内存，当有不用的对象时会自动被GC。</p>

<p>但是Java应用程序（当然也包括安卓）还是会遇到内存问题，主要是两类，一类是内存不合理使用，如内存使用过多，频繁创建大量对象，内存碎片等等；二是内存泄露。很多人会把二者混为一谈，网络上绝大多数文章一谈性能优化，一谈内存优化，必然说到内存泄露，但其实并不严谨。内存泄露确实是最常见的内存优化内容，也确实是内存使用不合理的最常见问题，但内存问题并不局限于内存泄露。</p>

<h3>内存使用不合理</h3>

<p>主要分为三个方面：</p>

<ol>
<li>浪费内存，简单来理解就是用一个人住着一千平米的大平层</li>
<li>大量创建小对象，产生碎片，内存碎片会造成JVM中的内存管理效率变低，当后面申请大块内存的时候效率就变差，它需要把小对象（碎片）进行转移压缩，以腾出更大的空间给大的对象使用。简单理解，这个时候JVM的效率就会变差，你的应用程序性能变差，甚至可能引起卡顿。</li>
<li>频繁创建对象，特别是较大的对象，造成内存抖动，也即应用程序使用的内存忽多忽少，会频繁的触发GC，从而影响JVM的运行效率。</li>
</ol>


<h3>内存泄露</h3>

<p>JVM是支持自动GC的，也就是说JVM帮助你管理内存，当有不再使用的对象时，会被JVM自动回收，此称之为GC（Garbage Collection）。但如果对象长期处于『使用』状态，并且超出了它本应该存的周期，无法被及时GC，这就会造成泄露。一般来说，这也没啥影响，但是如果泄露的对象太多，或者泄露的时间够长，就会把系统配额Java Heap空间耗尽，应用程序便会因没有内存创建对象而OOM，就会crash。即使没有crash，因为剩余空间较少，会频繁触发GC，从而导致应用程序卡顿严重。</p>

<p>内存泄露的根本原因是<strong>对象的生命周期错乱</strong>，对象存活了超过了其本该的生命周期，或者简言之，一个本该是较短的生命周期的对象被一个更长生命周期的对象所引用着，就会导致它本该生命周期结束时无法被GC，便产生了泄露。</p>

<p>这是要重点关注对象的生命周期，只有管理好了对象的生命周期，才能彻底的解决内存泄露问题。</p>

<h3>安卓应用中的生命周期</h3>

<h4>短生命周期的对象</h4>

<p>安卓应用程序里面，有一些是短生命周期的，或者说有明显生命周期，且不是由研发人猿自己控制的，如框架层控制的那一坨东西。</p>

<ul>
<li>Activity</li>
<li>Fragment</li>
<li>View</li>
</ul>


<p>特别是Activity，它也是内存泄露的头号对象，90%的内存泄露都是Activity对象。这货完全由系统框架控制，并且有明显的生命周期，而且还有重建实例的情况（涉及状态恢复时），所以它的生命周期其实相当短暂，并且它跟进程和主线程没有任何关系，Activity退出 了（走了onDestroy）进程仍还在，主线程也仍还在。而，又因为它是应用程序的第1级入口，应用程序所有的对象，以及GUI所有的东西，全部都由Activity直接或者间接持有，换句话说，Activity泄露了，你整个应用程序的对象也基本上全泄露了。</p>

<h4>长生命周期对象</h4>

<p>这里所谓的长生命周期，是指它们的生命周期是与进程绑定的，除非进程退出，或者明显的执行一些退出，否则一直随进程而存在：</p>

<ul>
<li>Looper，或者说消息队列，这玩意儿除非主动quit，否则一直存在。主线程的Looper与进程同在，自己创建的Looper要手动退出才算终结。</li>
<li>被static修饰的成员变量，这东西的生命周期是跟进程一样的</li>
<li>单例，单例必须由static来修饰，所以与进程生命周期是一样的，进程在，则单例在</li>
<li>线程池，或者一个长时间运行的thread，除非主动去shutdown</li>
<li>RxJava的Schedulers，这玩意跟looper一样，都是长时间运行的消息队列，且与进程绑定的</li>
<li>系统框架，手机还在开机系统框架就在运行，所以它的生命周期远远长于某一个应用程序</li>
<li>Application和ApplicationContext，这东西与进程生命周期是一样的，相当于单例了</li>
</ul>


<h4>业务逻辑中的生命周期</h4>

<p>业务逻辑就纯属于应用程序的本身逻辑了，无法一概而论，但一般来说，主页面的生命周期肯定是长于某个子页面的。那么子页面在其退出后，理论上它的绝大多数对象应该要被回收。</p>

<h2>如何发现内存问题</h2>

<p>生活中不是缺少美，而是缺少发现。</p>

<p>对于内存优化，第一步就是要通过各种测试手段发现问题。最理想的情况是建立一种监控手段，这样最能保住革命果实，以及非常及时的发现问题。</p>

<p>这里指的是一般性的粗略手段来发现你的应用有内存问题了，可能需要优化了。并且这些测试方法最好能做成定期监控，这样一旦内存性能有回撤时，能尽快发现。</p>

<h3>『队长，我们暴露了』</h3>

<p>很多时候都是问题主动找上门来了。</p>

<h4>前方有雷区</h4>

<p>很不幸，你的应用程序中弹身亡（crash了），还是OOM。这是Java语言中的一个运行时的错误，可能在创建任何对象时发生，但一般来说创建比较大的对象时，这里的大是指对内存需求大，如图片，或者大块数组时，更容易发生。</p>

<p>当你的应用程序出现了OOM的时候，就是一个特别明显的信号，告诉你要重视内存优化了。</p>

<h4>遇到终结者了，是lowmemorykiller</h4>

<p>有时候，没有明显的错误，但是应用却闪退了，特别是在后台，或者跳到其他应用页面时。</p>

<p>这个会比较隐蔽，通常会引发其他表象的问题。最明显的问题就是，当跳转到其他页面，再返回时，发现原来的页面状态不存在了，比如你的应用要访问一个URL，跳转到了网页浏览器，但从浏览器返回时，要么你的应用不在了，要么你的应用的原先状态不在了。这其中的原因就是当你的应用不在前台了，就被系统回收了，其中一个占大头的原因就是占用内存太多，被系统的lmk（lowmemorykiller）干掉了。</p>

<p>因为系统要保证整个设备的正常运转，所以会把占用内存太多的先杀掉，以释放内存。</p>

<p>当你的应用频繁的遇到被lowmemory killer干掉时，也是一个明显的信号，要重视内存优化了。</p>

<h4>读懂系统GC日志</h4>

<p>有些时候不像前面那样严重，但是查看logcat日志时，能发现大量的GC日志，就像这样的</p>

<pre><code>259857:01-08 20:00:17.836 10083 26337 26347 I test.test: NativeAlloc concurrent copying GC freed 141174(6852KB) AllocSpace objects, 29(12MB) LOS objects, 49% free, 24MB/48MB, paused 180us total 308.126ms
279178:01-08 20:00:19.618 10083 26337 26347 I test.test: Background young concurrent copying GC freed 469755(20MB) AllocSpace objects, 40(3608KB) LOS objects, 41% free, 28MB/48MB, paused 396us total 124.817ms
</code></pre>

<p>这是系统在进行GC，通常来说这没有什么问题。但如果在短时间内，比如某个页面，点了某个按扭后大量出现此类日志，也是一个明显的信号，告诉你要重视内存优化了。</p>

<h3>主动出击，以攻为守</h3>

<p>作为一个优秀的猿，不能坐着等问题上来，要能主动的去创造问题。每当完成一个需求后，或者写了一大坨代码以后，就需要主动的去查看一下内存方面是否有需要优化的地方。我们可以通过如下测试方法，来看内存是否有问题，是否需要做优化。重点就是看应用程序在一定时间内，使用的内存是否一直在增长， 有没有抖动，并且在GC后，或者退出 后是否仍不回落。</p>

<h4>meminfo</h4>

<p>具命令是adb shell dumpsys meminfo <package>，这个命令还是比较常见的，网上有很多资料可以用，可以看后面罗列的参考文章中来详细了解它的具体用法以及各个字段的意义，这里就重复了。</p>

<ul>
<li><a href="https://developer.android.com/studio/command-line/dumpsys">dumpsys</a></li>
<li><a href="https://blog.csdn.net/feelabclihu/article/details/105534175">dumpsys meminfo 的原理和应用</a></li>
<li><a href="https://www.cnblogs.com/helloTerry1987/p/13109971.html">adb shell dumpsys meminfo 详解</a></li>
<li><a href="https://www.jianshu.com/p/37539308ff32">dumpsys meminfo 含义</a></li>
</ul>


<p>需要关注一下重点，就是，可以重点看Java Heap一栏的数据变化，这是Java层的占用内存情况。另外就是每次运行meminfo其实会对进程产生影响。所以，这个命令可以用来粗维度的监控，查看一些信息，做一些定性的分析。</p>

<p>它最大的优点是方便，且只要是进程都可以查看，不用有源码。</p>

<h4>Android Studio的Memory Profiler</h4>

<p>在远古时代安卓SDK中会有DDMS，里面是一套调试工具，但现在都集成到Android Studio的Profiler里面了，通常会在下方的工具栏里面，如果 没有就到菜单View->Tools Window->Profiler把它调出来。然后选择要调试的进程，默认它会把CPU，Network，Memory和功耗都显示，这里可以双击Memory那一坨，就会进入专门的内存页面。</p>

<p>它会以时间轴的方式来图形化的展示内存使用情况，非常的直观和方便。通过这个可以直观的看到两个问题，就是嫌疑内存泄露以及内存抖动。</p>

<p>嫌疑内存泄露就是看到曲线一直在增长，且通过显示GC，或者退出后，或者停止某项目操作后，仍不回落的，这就非常有可能有泄露的存在，泄露是超出了它本该的生命周期，比如某一操作结束了，退出 了某一页面，甚至退出应用了，内存仍没有回落，就可能有问题。</p>

<p>另外就是内存抖动，就是能看到内存曲线 有毛刺，短时间内忽上忽下的，这就是内存抖动。</p>

<h4><a href="https://square.github.io/leakcanary/">leakcanary</a></h4>

<p>这货也是非常流行的，专门用于检测内存泄露的工具，它的功能较为强大，除了可以监控以外，还可以给出详细的trace。具体使用可以参考官方的文档，并不难。</p>

<p>但它最大的问题在于，必须参与项目构建。假如你想研究一下竞品的情况，就没有办法了。</p>

<h2>如何调试内存问题</h2>

<p>通过前面提到的手段，我们可以发现内存有一些问题了，需要进行内存方面的优化了，但这还不够，还需要一些精细化的调试方法来具体定位问题，这样才能更好的去进行优化。</p>

<p>那么有哪些具体的调试方法呢？</p>

<h3>Allocation tracer</h3>

<p>这个是前面提到的Android Studio Profier里面的工具。用Profiler可以发现问题，但还需要进一步的深入的分析问题。这就需要Allocation tracer了。</p>

<p>具体做法就是，当你发现某一系列操作后内存一直增长，或者看到有抖动现象时，就可以抓取这段时间的Heap dump，然后详细分析，现在Android Studio都集成好了，只需要点几下，就能抓到，并把结果列出来，可以看到具体创建哪些对象，以及它们的引用关系是怎样的。</p>

<p>可以参考 以下资源来详细了解如何使用此工具：</p>

<ul>
<li><a href="https://developer.android.com/studio/profile/android-profiler">The Android Profiler</a></li>
<li><a href="https://developer.android.com/studio/profile/memory-profiler">Inspect your app&rsquo;s memory usage with Memory Profiler</a></li>
<li><a href="https://juejin.cn/post/6844904080691691533">Android 内存优化篇 - 使用profile 和 MAT 工具进行内存泄漏检测</a></li>
</ul>


<h3><a href="https://www.eclipse.org/mat/">MAT</a></h3>

<p>这是专门用于Java heap内存分析的工具，相当强大。但不能直接使用。</p>

<p>需要先想办法抓取进程的heap dump，然后转换为Java标准的格式（因为安卓的Heap与Java SE的并不一样，安卓 SDK中有转换工具），然后再用MAT打开即可，它的功能要远强大于前面的提到的Allocation tracer。所以，如果要深度的分析和优化，还是要用MAT。</p>

<p>关于MAT的具体使用方法，可以参考以下资源：</p>

<ul>
<li><a href="http://wiki.eclipse.org/MemoryAnalyzer">官方文档</a></li>
<li><a href="https://blog.csdn.net/shulianghan/article/details/106958491">【Android 内存优化】使用 Memory Analyzer ( MAT ) 工具</a></li>
<li><a href="https://androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT/">Android 内存优化(1) - MAT 使用入门</a></li>
</ul>


<h3>leakcanary</h3>

<p>除了能监控以外，它还能分析具体的内存泄露，并给出trace，所以当发现问题后，具体定位问题的时候，也可以使用此工具，还是相当强大的。</p>

<p>它的使用相当简单，直接把它加入到dependencies，然后构建 就好了。</p>

<p>至于它的分析结果也是相当直观的，会以Notification的方式通知你，点开后有一个页面展示出引用关系链，然后判断是否是泄露，即可。</p>

<p>详细可以参阅它的<a href="https://square.github.io/leakcanary/getting_started/">官方文档</a>就可以了。</p>

<h2>如何优化内存</h2>

<p>内存优化，一大半在于测试，监控和调试分析，约占70%，这部分是重头，因为只有找到具体的代码位置，才好去修复问题，并且修复后还要验证问题是否真的修复了。不能光在那里看代码，想当然的认为把几个内部类改为static，或者传递引用了ApplicationContext，就能优化了内存。</p>

<p>对于性能优化，当然也包括内存优化，必须用测试手段进行量化，以此来验证是否真有有改善。</p>

<p>本节内容，假设已通过前面提到的测试方法发现了内存问题，并通过调试手段定位到了具体位置。优化的手段也要针对 具体的问题来进行：</p>

<h3>避免内存泄露</h3>

<p>内存优化的大头是要避免泄露，所以重点来谈谈如何避免内存泄露。</p>

<p>前面提到了，内存泄露的根本原因是生命周期混乱，较长生命周期的对象，甚至是超长生命周期的对象，持有了较短生命周期的对象，这一定会导致泄露。所以，要想真的解决内存泄露问题，必须设计好对象的生命周期，这是根本解决之法。</p>

<h4>要尽可能的，缩小对象的生命周期</h4>

<p>对象的生周期不应该超出它本该存在的范围，并且应该尽可能的减少对象的生命周期，这个可能在设计阶段考虑到。但一般较难执行，代码复杂了，很难控得住。</p>

<h4>对于超过Activity生命周期的对象要及时清理</h4>

<p>前面提到过的超长生命周期的东西，如Looper，如Frameworks，如单例，如RxJava的Schedulers，如线程池，这些东西的生命周期远长于Activity，所以，一定要在对应的地方，及时清除对Activity的引用持有。</p>

<p>后面的参考 资料里面也有大量的实用建议可以参考，这里就不重复了。避免内存泄露应该要被总结成为编程规范，然后在团队内部推行，当然也可以设计一些源码静态检测工具，来强制执行。当然，再好的工具和规范也需要人来遵守，任何事情能够在编码阶段防止发生，成本是最小的，收益 是最大的。</p>

<h4>WeakReference和SoftReference不是救命稻草</h4>

<p>千万不要用WeakReference和SoftReference这东西来修复内存泄露问题，它们根本就不是用来修复内存泄露问题的。</p>

<p>再说一遍，内存泄露是由<strong>生命周期混乱</strong>造成的。</p>

<p>如果强行使用WeakReference来代替原来的强引用，就会造成想使用对象的时候它却被回收了，这时你的正常逻辑就没法走了，而且如何正确的处理这种异常case，也是很难恰当 的处理的。</p>

<p>WeakReference这东西最最合理，最为适合的场景就是缓存里面，也就是说它本身是用于一种可有可无的引用关系，这样一旦被GC了，也不会影响原有逻辑，因为对象本来就可能在（Cache Hit），也可能不在缓存里面（Cache Miss），使用者必须处理在或者不在两种case。因为缓存的清理可能不够及时（必须由编码人员手动设置条件去清理，比如在退出的时候），当JVM需要GC时，因为都是WeakReference，GC就可以快速的回收对象释放内存。</p>

<h4>不要到处给对象引用置为null</h4>

<p>很多有过C++经验的同学，可能会习惯在对象使用完成后，手动把对象置为null。但其实这是完全没有必要的，只会造成不必要的混乱，JVM会自己去追踪每个对象，它到底还有没有被引用持有着。我们要把精力重点放在对象生命周期的把控上面，简单的置为null，不会缩减对象的生命周期，所以它对解决和防止泄露方面没有任何帮助。</p>

<h3>内存使用优化方式</h3>

<p>除了避免内存泄露，其他一些方式也是有很多技术可以用于优化的。</p>

<h4>减少内存浪费</h4>

<p>内存浪费，就是使用了没必要的内存，虽然可能不会引发问题，但是还是会增加风险，比如同样都是后台进程，你的应用占用内存稍大了一些，被杀的风险就高了一些。</p>

<p>减少内存浪费，核心的方法就是按需申请，特别像图片这种内存占用大户，一定要按需要来加载，何为需要就是目标View的大小，具体可以看官方教程<a href="https://developer.android.com/topic/performance/graphics/load-bitmap">Loading Large Bitmaps Efficiently</a>。以及尽可能的<a href="https://developer.android.com/topic/performance/graphics/manage-memory">要复用bitmap</a>。</p>

<p>再如资源图片，设置合理的分辨率，没有必要啥都上高清，且要为低精度设备提供单独的一套资源。</p>

<p>以及像不是要求那么清晰的场景就用RGB_565，而非RGBA_8888等等，这些都是在编码的时候就可以提高内存使用的方法。</p>

<h4>使用缓存</h4>

<p>缓存是计算机史上最伟大的发明，甚至是人类史上最伟大的发明，它无处不在从硬件到软件都会使用缓存，并且它在各种东西的设计之中都是很重要的一部分。</p>

<p>前面提到的内存抖动问题，就需要用缓存来解决，以避免频繁创建对象。特别是涉及图片的场景，比如流行的图片加载开源库里面都有专门的缓存的机制，有些是二级，有些是三级。当需要设计缓存时，可以重点参考图片加载库中的缓存设计。</p>

<p>另外，SDK中也有标准的缓存组件可以用，<a href="https://developer.android.com/reference/android/util/LruCache">LruCache</a>，这是针对内存层面的缓存，可以看<a href="https://www.jianshu.com/p/e09870b60046">这篇文章</a>来详细了解使用方法。</p>

<h4>合理复用对象</h4>

<p>这里的意思是使用像<a href="https://en.wikipedia.org/wiki/Flyweight_pattern">享元这样的设计模式</a>，来合理的复用对象。</p>

<p>需要注意的是享元(Flyweight Pattern)的适用场景，它适用于创建对象的成本较高，比如创建对象需要的一些资源较昂贵，不同的对象仅是有不同的属性，或者说对象本身在使用的时候的表现是不同的。</p>

<p>一个典型的例子就是绘图的形状，比如一个页面有大量的不同的形状需要绘制，有方的，有圆的，有白色的，有彩色的，有实边的有虚线的。常规的思路是一个基类叫Shape，里面有各种属性，还有一个draw方法，子类可以定义不同的属性，各自实现draw方法。然后根据需求创建一大坨具体的对象，遍历调用draw方法。这是面向对象编程（OOP）中的非常标准的多态（Polymophsim）。事实上，你只需要创建一个对象就够了，它会根据不同的属性画出不同的效果。这就是设计模式中的享元模式，具体可以参考<a href="https://refactoring.guru/design-patterns/flyweight">这篇文章</a>来详细了解。</p>

<h2>认识几种不同的内存类型</h2>

<p>通过各种工具查看的内存时，如通过meminfo以及像Memory profiler，但可以发现有不同种类，需要重点关注以几种：</p>

<h3>Java Heap</h3>

<p>也即通常意义上的heap内存（堆内存），名字可能会是Java，Java Heap，或者Java allocate，但都是一样就是指纯Java代码中通过new创建对象时使用的内存。</p>

<h3>Native Heap</h3>

<p>因为Java是支持JNI与C/C++接通，也即native方法，那么通过native方法创建的对象是计算在Native之中的，它与Java层是分开的，当然通过native方法（malloc或者new）创建的对象，要记得去释放，否则是一定会泄露的。</p>

<p>因为Android的大部分是由C/C++实现的，Java层仅是封装，Frameworks层大部分功能都由JNI转到native层去实现的，因此native这部分的内存也是很多的，并且由于Frameworks本身会大量调用JNI native层，所以即使你的应用程序根本没有用到JNI，但是还是会看到Native内存使用。</p>

<h3>Graphics</h3>

<p>主要是涉及OpenGL ES的相关内存占用，如GL Surfaces，如Texture或者如Framebuffer等，它们所占用的内存。</p>

<p>这里需要特别注意的是，即使你的应用没有用到OpenGL相关的东西，但仍可能会有此部分内存占用，这是由于硬件加速本身也是通过OpenGL ES实现的。</p>

<h3>ion内存</h3>

<p>这个是为了效率，直接从kernel层开出shared buffer，以加速内存使用效率，这个是偏底层的，普通app是用不到的。</p>

<p>可以参考一下这个<a href="https://www.cnblogs.com/willhua/p/10029280.html">The Android ION memory allocator</a>。</p>

<h3>共享内存</h3>

<p>可以理解为Linux中的匿名共享内存，可以用来实现IPC通信，但它并不会被Profiler计算在Java或者Native里面。非死不可出品的Fresco当初牛逼的地方就在于把Bitmap放在匿名共享内存里面，从而不占用应用自己的Heap空间。</p>

<p>可以参考这两个文章：</p>

<ul>
<li><a href="https://juejin.cn/post/6844904053961392141">Ashmem(Android共享内存)使用方法和原理</a></li>
<li><a href="https://developpaper.com/android-shared-memory/">Android shared memory</a></li>
</ul>


<h2>学无止境</h2>

<p>深入学习GC相关知识，如JVM的GC如何演进。</p>

<p>也可以学习一下其他编程语言的GC机制。</p>

<h2>不要过早优化，更不能过度优化</h2>

<p>性能优化这个事情是要在架构设计和产品设计阶段就需要考虑的事情，比如是否要加入缓存。</p>

<p>但如果前期想太多，会造成严重的扭曲，会让你陷入无限的复杂问题里面，难以自拔（本是问题1，但是变成了问题A，问题B，直到问题z，最初的问题1却被忽略了），反倒不是好事情。</p>

<p>最为想理的情况就是小步迭代，先提出能满足需求的最小版本，然后逐步迭代。比如说做一个新的feature的时候，先用最简单的架构和设计来实现，然后考虑补充细节，处理异常case，再考虑可能的扩展，然后考虑性能优化。</p>

<h2>剩下的是态度</h2>

<p>不是说一线开发的态度，而是老板们的态度。</p>

<p>性能问题是直接影响体验，所以只有重视体验的老板才会重视性能问题。而且这也不是研发猿的问题，需要测试，产品都要能重视性能问题，才能最终把性能做好。产品同学不能只顾着提需求，也要平衡性能，并且给研发同学一定的时间去注重性能问题，而测试同学更加重要，需要不断精进你的测试方法，帮助研发同学更好的解决问题，并且要有监控手段，比如说A版本做了性能优化专项，那么为了保留革命果实，需要有一种监控手段，以防性能出现重大回撤。</p>

<p>很多事情不能怪研发，就像有一位技术相当不错的同事说过的话，当时大家聊起性能优化的事情，他说：『道理大家都懂，但当左边是产品经理在那里崔需求，右边是设计师在那说按扭还差几个象素，测试同学在那崔你赶紧发版本啊，我还等着测完回家呢！当你处在这种条件下，谁TMD的还管性能啊，先实现了再说吧，甚至代码格式都懒得改了。』</p>

<p>所以，这是整个工程体系的事情，只有整个研发体系都注重性能，性能才会好，体验才会好，而这就需要一个老板的支持了，否则，性能不可能好，产品汪们只顾着提需求，设计师只顾着画面精美，研发同学光实现需求都做不完，哪有精力去搞性能啊！测试同学也不能只用粗浅的测试方法，只说性能不好，具体哪不好，不应该都让研发自己去调试，去发现问题。另外，也需要做好性能监控机制，以保住革命果实。要不然，A版本辛辛苦苦搞了一轮性能优化，也有大幅改善，然后到了B版本，或者几个月后，再来一轮。</p>

<p>这就是很骨感的现实。所以，在现实生活中只有大厂头部应用 才真的重视性能和体验，并且才能把性能和体验做好。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/topic/performance/memory-overview">Overview of memory management</a></li>
<li><a href="https://developer.android.com/studio/profile">Profile your app performance</a></li>
<li><a href="https://www.jianshu.com/p/258229426da4">Android内存管理机制</a></li>
<li><a href="https://www.jianshu.com/p/51e28a2c609c">最全的Android内存优化技巧</a></li>
<li><a href="https://jsonchao.github.io/2019/08/18/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/">Android性能优化之内存优化</a></li>
<li><a href="https://jsonchao.github.io/2019/12/29/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/">深入探索Android内存优化</a></li>
<li><a href="https://juejin.cn/post/6844904096541966350">Android性能优化之内存优化</a></li>
<li><a href="https://juejin.cn/post/6844904099998089230">深入探索 Android 内存优化（炼狱级别-上）</a></li>
<li><a href="https://juejin.cn/post/6872919545728729095">深入探索 Android 内存优化（炼狱级别-下）</a></li>
<li><a href="https://juejin.cn/post/6844904191282905096">内存优化深入版</a></li>
<li><a href="https://pspdfkit.com/blog/2019/android-large-memory-requirements/">Dealing with Large Memory Requirements on Android</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
