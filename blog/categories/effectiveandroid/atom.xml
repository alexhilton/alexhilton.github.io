<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io//blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io//"/>
  <updated>2024-10-29T22:58:53+08:00</updated>
  <id>https://alexhilton.github.io//</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[让Activity更加优雅地跳转]]></title>
    <link href="https://alexhilton.github.io//blog/2024/10/14/activity-result-launcher/"/>
    <updated>2024-10-14T22:24:55+08:00</updated>
    <id>https://alexhilton.github.io//blog/2024/10/14/activity-result-launcher</id>
    <content type="html"><![CDATA[<p>有过Android开发经验的小伙伴对<a href="https://developer.android.com/reference/android/app/Activity#startActivityForResult(android.content.Intent,%20int">startActivityForResult</a>)以及<a href="https://developer.android.com/reference/android/app/Activity#onActivityResult(int,%20int,%20android.content.Intent,%20android.app.ComponentCaller">onActivityResult</a>)一定不陌生，正是这一对API让组件 的复用变成可能。今天就来学习一下如何在函数式的范式中驾驭Activity的跳转。</p>

<p><a href=""><img src="https://akexorcist.dev/content/images/size/w2000/2021/12/activity_result_api-header.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>缘起</h2>

<p>系统组件复用，特别是Activity的复用，是Android系统中非常重要的一个设计理念。组件复用打破了应用程序之间的壁垒，在整个系统范围内可以共享和复用一些公共的组件，比如像打开网页，拍照片，查看图片等等，开发者不必再用原始API去实现一套，直接使用startActivityForResult和onActivityResult就可以取到需要的资源。</p>

<p>这套API最大的问题在于它并不是常规的异步式的回调，调用了startActivityForResult后，结果的处理，必须要在Activity的继承体系内覆写onActivityResult，并且因为Activity实例只能由系统创建，这就导致了组件复用的逻辑必须都在Activity内部。这就导致了Activity的体积通常会相当的臃肿，上千行，甚至大几千行的Activity随处可见。理想的情况下Activity，作为一个系统的容器和接口，应该越薄越好，但要能把逻辑移出Activity才行。</p>

<p>另一方面，onActivityResult无法在函数式的情境中使用，因为它会跑到函数外面去，比如在Jetpack Compose中就无法直接使用startActivityForResult和onActivityResult。</p>

<p>为了解决这两个问题，就需要使用到Jetpack中的<a href="https://developer.android.com/reference/androidx/activity/result/package-summary">Activity Result API</a>了。</p>

<h2>Activity Result API的使用方法</h2>

<p>在Jetpack的AndroidX中的<a href="https://developer.android.com/jetpack/androidx/releases/activity">Activity</a>和<a href="https://developer.android.com/jetpack/androidx/releases/fragment">Fragment</a>中，可以像常规的回调那样向系统注册一个处理result的回调，一旦系统派发了activity result就能被系统回调到。</p>

<p><strong>注意：</strong> 这里提到的方法都在AndroidX中的<a href="https://developer.android.com/reference/androidx/activity/ComponentActivity">ComponentActivity</a>和<a href="https://developer.android.com/reference/androidx/fragment/app/Fragment">Fragment</a>里面，也就是说要继承AndroidX中的组件才可以。</p>

<h3>注册一个activity result回调</h3>

<p>这套API的方式是在ComponentActivity和Fragment中，提供了一个<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultCaller#public-methods_1">registerForActivityResult</a>方法用于注册activity result的回调。参数是一个<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContract">ActivityResultContract</a>实例和一个<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultCallback">ActivityResultCallback</a>实例。返回的是一个<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultLauncher">ActivityResultLauncher</a>，这个launcher可以用来启动目标Activity，也即触发获取资源的流程，相当于原来的startActivityForResult：</p>

<pre><code class="Kotlin">val getContent = registerForActivityResult(GetContent()) { uri: Uri? -&gt;
    // 处理结果
}
</code></pre>

<p>一个ActivityResultContract，如它的名字所示，定义着组件复用的的接口，即输入类型和输出类型。API中定义了<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContracts">大量的现成可用的，也是常见的接口</a>，比如拍照，权限请求等等。当然也可以创建<a href="https://developer.android.com/training/basics/intents/result#custom">自定义接口</a>。</p>

<p>回调ActivityResultCallback是只有一个方法onActivityResult()的接口，此方法的参数由ActivityResultContract来定义。</p>

<h3>启动目标Activity</h3>

<p>当调用registerForActivityResult时，能拿到一个launcher，但此API仅是向系统注册一个回调，这时还没有启动目标（即还没有发起请求）。发起请求需要使用ActivityResultLauncher来完成。</p>

<p>调用其<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultLauncher#launch(I">方法launch</a>)就会发起请求，启动目标Activity，开启获取结果的流程。如果给launch传递了参数，会依据ActivityResultContract做进一步的匹配（其实这些输入最终会转化为Intent对象提供给startActivityForResult）。用户在目标Activity页面完成了操作后，就会返回到当前页面，回调ActivityResultCallback的方法onActivityResult就会被执行：</p>

<pre><code class="Kotlin">val getContent = registerForActivityResult(GetContent()) { uri: Uri? -&gt;
    // 处理结果，即返回的Uri
}

override fun onCreate(savedInstanceState: Bundle?) {
    // ...

    val selectButton = findViewById&lt;Button&gt;(R.id.select_button)

    selectButton.setOnClickListener {
        // 接口是获取内空，这里传mime type作为参数，那么就是要获取一个图片内容
        getContent.launch("image/*")
    }
}
</code></pre>

<p>如果需要多个组件复用，那就传递不同的参数多次调用registerForActivityResult。并且registerForActivityResult可以在任何时候调用，在onCreate之前调用也是安全的，所以可以在声明ActivityResultLauncher的时候就直接调用，这样可以直接初始化。</p>

<p>但是要特别注意，使用launcher来启动Activity则必须在onCreate之后。</p>

<p>还有一点需要特别注意，因为launch之后，onActivityResult之前这段时间会离开当前的Activity，这个时间内Activity可能会被系统回收，也即触发了状态恢复。所以处理结果时，也即onActivityResult中的逻辑，如果有依赖其他状态，这些状态需要在onSaveInstanceState中进行保存。</p>

<h3>处理结果</h3>

<p>结果的处理就在ActivityResultCallback中的方法onActivityResult，这里使用返回的参数就可以了。</p>

<h2>在Activity之外使用</h2>

<p>如前面所述，使用这套Result API的最大的好处在于把结果的处理从Activity中解耦出来，因此，最为理想的方式是能在独立的class中做这些事情。</p>

<p>这就需要使用<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultRegistry">ActivityResultRegistry</a>，它才是核心，另外三个类（launcher，contract和callback）都是一些封装，事实上Activity和Fragment里面的方法registerForActivityResult其实也是使用这个registry来实现的。从Activity中可以拿到registry的实例，以此作为参数，就可以在自定义的class中使用Result APIs了。</p>

<p>比如单独封装获取图片的流程可以这样写：</p>

<pre><code class="Kotlin">class MyLifecycleObserver(private val registry : ActivityResultRegistry)
        : DefaultLifecycleObserver {
    lateinit var getContent : ActivityResultLauncher&lt;String&gt;

    override fun onCreate(owner: LifecycleOwner) {
        getContent = registry.register("key", owner, GetContent()) { uri -&gt;
            // Handle the returned Uri
        }
    }

    fun selectImage() {
        getContent.launch("image/*")
    }
}

class MyFragment : Fragment() {
    lateinit var observer : MyLifecycleObserver

    override fun onCreate(savedInstanceState: Bundle?) {
        // ...

        observer = MyLifecycleObserver(requireActivity().activityResultRegistry)
        lifecycle.addObserver(observer)
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        val selectButton = view.findViewById&lt;Button&gt;(R.id.select_button)

        selectButton.setOnClickListener {
            // 触发获取图片的流程
            observer.selectImage()
        }
    }
}
</code></pre>

<p>这个示例把获取图片的流程（发起和结果处理）都封装在了一个单独的类中，同时又是明是监听了Activity组件的生命周期。谷歌是强烈建议同时要<a href="https://developer.android.com/reference/kotlin/androidx/lifecycle/LifecycleObserver">监听生命周期</a>（通过扩展LifecycleObserver），这是因为<a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner">LifecycleOwner</a>会在destroy时自动帮你反注册ActivityResultLauncher，不然的话就要手动的<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultLauncher#unregister(">反注册</a>)。</p>

<h2>自定义Contract</h2>

<p>尽管谷歌已经在<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContracts">ActivityResultContracts</a>中已经预定义了大量的contracts可以使用，但仍然会有一些特殊的场景因预定义的contract无法满足需求而需要自定义一个contract。这个contract实际上就是约定了组件复用的接口，就像普通的interface一样，定义好输入与输出的类型就可以了，所以需要给contract提供输入输出的类型，如果不需要输入或者输出就使用Void?或者Unit。</p>

<p>此外还需要实现一个<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContract#createIntent(android.content.Context,kotlin.Any">createIntent方法</a>)，这个方法接收一个Context和其他输入（即contract约定的输入，最终是由ActivityResultLauncher中方法launch时提供）作为参数并返回一个Intent对象，此Intent会是startActivityForResult的输入参数。同时还需要实现另外一个<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContract#parseResult(kotlin.Int,android.content.Intent">方法parseIntent</a>)，此方法将<a href="https://developer.android.com/reference/android/app/Activity#onActivityResult(int,%20int,%20android.content.Intent,%20android.app.ComponentCaller">Activity的标准钩子onActivityResult</a>)中的参数resultCode和Intent转化为contract中约定的输出（此输出会作为回调ActivityResultCallback函数方法onActivityResult的输入参数）。</p>

<pre><code class="Kotlin">class PickRingtone : ActivityResultContract&lt;Int, Uri?&gt;() {
    override fun createIntent(context: Context, ringtoneType: Int) =
        Intent(RingtoneManager.ACTION_RINGTONE_PICKER).apply {
            putExtra(RingtoneManager.EXTRA_RINGTONE_TYPE, ringtoneType)
        }

    override fun parseResult(resultCode: Int, result: Intent?) : Uri? {
        if (resultCode != Activity.RESULT_OK) {
            return null
        }
        return result?.getParcelableExtra(RingtoneManager.EXTRA_RINGTONE_PICKED_URI)
    }
}
</code></pre>

<p>如果现有的contracts不满足需求，且也无具体的输入输出要求，那么可以用一个万用contract，即<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContracts.StartActivityForResult">StartActivityForResult</a>。这个万用contract的输入是一个Intent，输出是一个<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResult">ActivityResult</a>，在回调方法onActivityResult中可以直接从ActivityResult实例中取出resultCode和目标返回的Intent对象：</p>

<pre><code class="Kotlin">val startForResult = registerForActivityResult(StartActivityForResult()) { result: ActivityResult -&gt;
    if (result.resultCode == Activity.RESULT_OK) {
        val intent = result.data
        // 处理目标返回的Intent
    }
}

override fun onCreate(savedInstanceState: Bundle) {
    // ...

    val startButton = findViewById(R.id.start_button)

    startButton.setOnClickListener {
        // 传入想要启动的Intent对象
        startForResult.launch(Intent(this, ResultProducingActivity::class.java))
    }
}
</code></pre>

<p>从这里我们可以看出，这套Result API本质上仍是依赖于原始的startActivityForResult和onActivityResult。</p>

<h2>在Compose中使用Result API</h2>

<p>接下来我们看看如何在Jetpack Compose使用这套API，这套API与Activity彻底解耦且支持函数式写法，所以可以在Compose中使用。这套API的核心是ActivityResultRegistry，有了它其他几个就可以使用起来了，而它的实例可以直接从Activity中取出来，所以这套API在Compose中完全可以用起来，与前面讲到的在Activity之外的逻辑完全一样：获取此对象用于register一个contract，同时得到一个launcher对象，在回调中处理结果，在合适的时机触发launch。</p>

<p>幸运的是完全用不着自己折腾，Compose中已经做好了封装，直接使用<a href="https://developer.android.com/reference/kotlin/androidx/activity/compose/package-summary#rememberlauncherforactivityresult">rememberLauncherForActivityResult</a>即可：</p>

<pre><code class="Kotlin">@Composable
fun GetContentExample() {
    var imageUri by remember { mutableStateOf&lt;Uri?&gt;(null) }
    val launcher = rememberLauncherForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? -&gt;
        imageUri = uri
    }
    Column {
        Button(onClick = { launcher.launch("image/*") }) {
            Text(text = "Load Image")
        }
        Image(
            painter = rememberAsyncImagePainter(imageUri),
            contentDescription = "My Image"
        )
    }
}
</code></pre>

<p>今天我们学习了Jetpack中提供的新式处理activity result的方法，这不仅能让在函数式编程范式中复用组件变成可能，也可以把很多逻辑从Activity中抽离出来，能给Activity瘦身，让组件跳转变得更为优雅。</p>

<h2>References</h2>

<ul>
<li><a href="https://blog.dogukangun.de/the-usage-of-activity-result-launcher-9c3d2241ec8">The Usage of Activity Result Launcher</a></li>
<li><a href="https://developer.android.com/training/basics/intents/result">Get a result from an activity</a></li>
<li><a href="https://stackoverflow.com/questions/64721218/jetpack-compose-launch-activityresultcontract-request-from-composable-function">Jetpack Compose: Launch ActivityResultContract request from Composable function</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/libraries">Compose and other libraries</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[喜迎国庆，用Compose赶制一面五星红旗]]></title>
    <link href="https://alexhilton.github.io//blog/2024/10/11/waving-flag-with-compose/"/>
    <updated>2024-10-11T22:38:22+08:00</updated>
    <id>https://alexhilton.github.io//blog/2024/10/11/waving-flag-with-compose</id>
    <content type="html"><![CDATA[<p>我们学习Jetpack Compose已经有一段时间了，通过前面的学习已能掌握足够的技巧以在实战中应用。恰逢普天庆国庆，利用我们学过的知识，使用Jetpack Compose来画一个迎风飘扬的五星红旗吧！废话不多说，先来看一眼效果图。</p>

<p><a href=""><img src="file:///Users/alexhilton/Downloads/compose_libs/red_flag.gif" title="auto auto" ></a></p>

<!-- more -->


<h2>五星红旗的设计标准</h2>

<p>需要特别注意，五星红旗有明确的设计标准的，在<a href="https://www.gov.cn/xinwen/2020-12/24/content_5572913.htm">国旗法中有明确的制法说明</a>。</p>

<p>总结一下要点：宽与高之比为3比2，五颗星都在左上四分之一小矩形内，最大五角星直径约为高的十分之一，四个小五角星的一个角要指向大五角星的中心。</p>

<h2>如何画五角星</h2>

<p>五星红旗并不是特别复杂，拆解一下，其组成图案就是矩形和五角星了，矩形是基本的图形可以直接画。需要研究一下五角星怎么画。</p>

<p>画对称多边形的方法都要借助圆，因为几何图形最容易画的同时也是最标准的就是圆了，再借助角度从圆上取点，把点连成线就是多边形。多边形的顶角度数不一样，因此把圆分成多少份，就能画出不同的多边形了。</p>

<p>五角星也要借助圆，把五角星五个顶点连线就是一个正五边形了，所以在圆上取5个等分点，也即每隔72度取一个点，然后把这5个点每隔一点连成线，就是五角星了。如下图所示：</p>

<p><img src="https://www.algebra.com/cgi-bin/plot-formula.mpl?expression=drawing%28330%2C330%2C-6.6%2C6.6%2C-6.6%2C6.6%2Cgrid%280%29%2C%0D%0Ared%28circle%280%2C0%2C6%29%29%2Cline%280%2C6%2C3.527%2C-4.854%29%2Clocate%285.8%2C1.9%2CP%29%2C%0D%0Aline%280%2C6%2C-3.527%2C-4.854%29%2Cline%28-3.527%2C-4.854%2C5.706%2C1.854%29%2C%0D%0Aline%28-5.706%2C1.854%2C5.706%2C1.854%29%2Cline%28-5.706%2C1.854%2C3.527%2C-4.854%29%2C%0D%0Ared%28arrow%280%2C0%2C6.562%2C2.132%29%29%2Cred%28arc%280%2C0%2C4.4%2C4.4%2C-18%2C0%29%29%2C%0D%0Alocate%282.2%2C1%2Cred%2890%5Eo-72%5Eo=18%5Eo%29%29%2Cred%28arc%280%2C0%2C8%2C8%2C-90%2C-18%29%29%2C%0D%0Alocate%282.8%2C3.5%2Cred%2872%5Eo%29%29%2Cgreen%28arrow%280%2C0%2C3.879%2C5.34%29%29%2C%0D%0Agreen%28arc%280%2C0%2C2.2%2C2.2%2C-90%2C-54%29%29%2Clocate%280.1%2C2%2Cgreen%2836%5Eo%29%29%0D%0A%29" alt="图2. 五角星画法" /></p>

<p>这种画法对手工尺规作图很友好，对程序来说，就没那么友好了。程序化的API需要明确的坐标点，把点串连成路径（Path）。这里需要的五角星是填充的，所以如果能知道5个顶点，和凹进来的五个点，只要把这10个点串起来，就能组成一个闭合的图形，得到我们想要五角星了。</p>

<p>五角星的外面五个点和内部五个点能组成两个正五边形，这两个正五边形的外接圆是两个同心圆，外顶点与内顶点刚好相差36度，正五边形的顶点之间是72度。所以，我们通过画两个半径不同的同心圆，每个圆分成5份，大圆的点与小圆的点交错开，就能画出一个五角星了。圆心和半径是关键的参数，通过圆心与半径，就能精细调整五角星的形状。</p>

<p><img src="https://mathalino.com/sites/default/files/images/005-planegeom-pentagram.jpg" alt="图3. 填充式五角星" /></p>

<p>因为五角星是填充色，所以我们把最外层的五个点与内层的五个点连串一起组成一个闭合的图形。通过前面的<a href="https://juejin.cn/post/7381826917086920742">降Compose十八掌之『利涉大川』| Canvas</a>学习，我们知道可以用路径（Path）来画图形，一共10个点把圆分成10分，所以角度是36度，半径是一大一小交错开来：</p>

<pre><code class="Kotlin">   val path = Path().apply {
        val pointNumber = 5
        val angle = PI.toFloat() / pointNumber
        val innerRadius = radius * cos(angle) / 2f

        for (i in pointNumber * 2 downTo 0) {
            val r = if (i % 2 == 1) radius else innerRadius
            val omega = angle * i

            val x = center.x + r * sin(omega)
            val y = center.y + r * cos(omega)
            lineTo(x, y)
        }
    }

    drawPath(
        path = path,
        color = color,
        style = Fill
    )
</code></pre>

<h2>画五星红旗</h2>

<p>根据制法以及画五角星的方法，我们总结一下设计要点：</p>

<ol>
<li>用一个高height作为主要参数，那么宽就是其1.5倍，其他的参数都与height有关系，所以改变height就可以完全控制整个旗子的大小；</li>
<li>大五星圆心x是宽的1/6，y是height的1/4，可以看出比例是一致的，所以可以先计算y，再乘1.5就是x；</li>
<li>大五星的外接圆直径约是height的3/10，半径就是高度的3/20，这样大五星就完全确定了；</li>
<li>小五星的直径是高的1/10，半径就是1/20；从上到下命名为a，b，c，d；</li>
<li>小五星a的圆心x在宽的1/3，y在高的1/10</li>
<li>小五星b的圆心x在宽的2/5，y在高的1/5</li>
<li>小五星c的圆心x在宽的2/5，y在高的7/20</li>
<li>小五星d的圆心x在宽的1/3，y在高的9/20</li>
<li>小五星的角要对着大五星的圆心，也就是要把小五星旋转一下。一个办法对Path做变幻，但其实不用那么复杂。我们在画五角星时，选择点时加上一个偏移角度beta就可以了，这样尖角就有旋转角度了。这个旋转角度可以用小五星的圆心与alpha的圆心来求得，就是这两个圆心连线与水平x轴的夹角，用反正切atan来求。</li>
</ol>


<p>综上，就可以写代码啦：</p>

<pre><code class="Kotlin">@Composable
fun FiveStarsRedFlag(height: Dp = 200.dp) {
    val stickWidth = 10.dp
    val flagWidth = height.times(1.5f)
    val flagHeight = height
    val canvasWidth = flagWidth.plus(stickWidth)
    val canvasHeight = height.times(2f)

    Canvas(modifier = Modifier.size(canvasWidth, canvasHeight)) {
        // The background
        drawRect(color = Color.Red, size = Size(flagWidth.toPx(), flagHeight.toPx()))

        // The stick
        drawRect(color = Color.LightGray, size = Size(stickWidth.toPx(), canvasHeight.toPx()))

        val centerY = flagHeight.toPx() / 4f
        val centerX = flagWidth.toPx() / 6f
        val radius = flagHeight.toPx() * 3f / 20f
        val smallRadius = flagHeight.toPx() / 20f
        val alphaCenter = Offset(centerX, centerY)

        // 大五角星 alpha
        drawStar(
            alphaCenter = alphaCenter,
            center = alphaCenter,
            radius = radius,
            color = Color.Yellow
        )

        // 小五星 a
        drawStar(
            alphaCenter = alphaCenter,
            center = Offset(flagWidth.toPx() / 3f, flagHeight.toPx() / 10f),
            radius = smallRadius,
            color = Color.Yellow
        )

        // 小五星 b
        drawStar(
            alphaCenter = alphaCenter,
            center = Offset(flagWidth.toPx() * 0.4f, flagHeight.toPx() / 5f),
            radius = smallRadius,
            color = Color.Yellow
        )

        // 小五星 c
        drawStar(
            alphaCenter = alphaCenter,
            center = Offset(flagWidth.toPx() * 0.4f, flagHeight.toPx() * 7 / 20f),
            radius = smallRadius,
            color = Color.Yellow
        )

        // 小五星 d
        drawStar(
            alphaCenter = alphaCenter,
            center = Offset(flagWidth.toPx() / 3f, flagHeight.toPx() * 9 / 20f),
            radius = smallRadius,
            color = Color.Yellow
        )
   }
}

fun DrawScope.drawStar(alphaCenter: Offset, center: Offset, radius: Float, color: Color) {
    val pointNumber = 5
    val angle = PI.toFloat() / pointNumber
    val innerRadius = radius * cos(angle) / 2f

    val beta = if (alphaCenter == center) {
        0f
    } else {
        PI.toFloat() / 2f - atan((center.y - alphaCenter.y) / (center.x - alphaCenter.x))
    }

    val path = Path().apply {
        for (i in 0 .. pointNumber * 2) {
            val r = if (i % 2 == 1) radius else innerRadius
            val omega = angle * i + beta

            val x = center.x + r * sin(omega)
            val y = center.y + r * cos(omega)
            lineTo(x, y)
        }
        close()
    }

    drawPath(
        path = path,
        color = color,
        style = Fill
    )
}
</code></pre>

<p>为了检查画图结果是否符合设计，我们可以画出制法中的那样的格子：</p>

<pre><code class="Kotlin">        if (DEBUG) {
            val strokeWidth = 0.8.dp.toPx()

            // Slice
            drawLine(
                Color.Black,
                Offset(stickWidth.toPx(), flagHeight.toPx() / 2f),
                Offset(flagWidth.toPx(), flagHeight.toPx() / 2f),
                strokeWidth = strokeWidth * 2f
            )

            drawLine(
                Color.Black,
                Offset(flagWidth.toPx() / 2f, 0f),
                Offset(flagWidth.toPx() / 2f, flagHeight.toPx()),
                strokeWidth = strokeWidth * 2f
            )

            // Grid
            for (i in 1 until 10) {
                drawLine(
                    Color.Black,
                    Offset(stickWidth.toPx(), flagHeight.toPx() * i / 20f),
                    Offset(flagWidth.toPx() / 2f, flagHeight.toPx() * i / 20f),
                    strokeWidth = strokeWidth
                )
            }

            for (i in 1 until 14) {
                drawLine(
                    Color.Black,
                    Offset(stickWidth.toPx() + flagWidth.toPx() * i / 30f, 0f),
                    Offset(stickWidth.toPx() + flagWidth.toPx() * i / 30f, flagHeight.toPx() / 2f),
                    strokeWidth = strokeWidth
                )
            }
       }
</code></pre>

<p>拿带格子的效果图，与制法设计图对比，可以发现一模一样，完全符合设计。</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/flag_with_grid.png" alt="图4. 带格子的效果图" /></p>

<p>好了，到这里，我们的五星红旗就画完了。未完，别走啊，我们还要让旗子飘扬起来。</p>

<h2>让五星红旗飘扬起来</h2>

<p>旗子飘扬的真实形态是三维的曲面，比如用三角函数曲面计算每一个坐标点x, y, z，就像<a href="https://juejin.cn/post/7206950454098247736">这篇文章</a>中的做法那样。</p>

<p>但在Compose中无法实现，因为Compose，虽然也可以做三维的变幻，但都是针对整个图层的，没有办法针对图形中的每个坐标点去单独做变幻，这也是与三维图形库如OpenGL ES的最大区别。</p>

<p>在Compose中要想每个坐标点都不一样，只能绘制曲线，曲线 的点再由动画动态的去改变，这样就会有类似波动一样的效果，但都局限在二维。为此，我们需要用Path来画背景，上边和下边都用曲线，曲线的点用动画来不断的波动，这样就能有点波动的感觉了：</p>

<pre><code class="Kotlin">    val infiniteTransition = rememberInfiniteTransition(label = "infinite transition")

    val amplitude = with(LocalDensity.current) { height.div(8f).toPx() }
    val heightPx = with(LocalDensity.current) { height.toPx() }

    val waveDuration = 2000
    val ya by infiniteTransition.animateFloat(
        initialValue = amplitude / 2f,
        targetValue = -amplitude / 2f,
        animationSpec = infiniteRepeatable(tween(waveDuration), RepeatMode.Reverse),
        label = "ya"
    )
    val yb by infiniteTransition.animateFloat(
        initialValue = -amplitude / 2f,
        targetValue = amplitude / 2f,
        animationSpec = infiniteRepeatable(tween(waveDuration), RepeatMode.Reverse),
        label = "yb"
    )
    val yc by infiniteTransition.animateFloat(
        initialValue = amplitude / 2f,
        targetValue = -amplitude / 2f,
        animationSpec = infiniteRepeatable(tween(waveDuration), RepeatMode.Reverse),
        label = "yc"
    )

    val ye by infiniteTransition.animateFloat(
        initialValue = heightPx + amplitude / 2f,
        targetValue = heightPx - amplitude / 2f,
        animationSpec = infiniteRepeatable(tween(waveDuration), RepeatMode.Reverse),
        label = "ye"
    )
    val yf by infiniteTransition.animateFloat(
        initialValue = heightPx - amplitude / 2f,
        targetValue = heightPx + amplitude / 2f,
        animationSpec = infiniteRepeatable(tween(waveDuration), RepeatMode.Reverse),
        label = "yf"
    )
    val yg by infiniteTransition.animateFloat(
        initialValue = heightPx + amplitude / 2f,
        targetValue = heightPx - amplitude / 2f,
        animationSpec = infiniteRepeatable(tween(waveDuration), RepeatMode.Reverse),
        label = "yg"
    )

    Canvas(
        modifier = Modifier.size(canvasWidth, height)
    ) {
        val stickOffset = Offset(stickWidth.toPx(), 0f)

        // The background
        val pathBG = Path().apply {
            moveTo(0f, 0f)
            cubicTo(flagWidth.toPx() / 3f, ya, flagWidth.toPx() * 2f / 3f, yb, flagWidth.toPx(), yc)

            lineTo(flagWidth.toPx(), ye)

            cubicTo(flagWidth.toPx() * 2f / 3f, yf, flagWidth.toPx() / 3f, yg, 0f, size.height)

            lineTo(0f, 0f)

            translate(stickOffset)
        }
        drawPath(path = pathBG, color = Color.Red, style = Fill)
   }
</code></pre>

<p>也可以用GraphicsLayer，再添加一点点Y轴和Z轴的旋转，就更像那么回事了：</p>

<pre><code class="Kotlin">val rotateY by infiniteTransition.animateFloat(
        initialValue = -3f,
        targetValue = 6f,
        animationSpec = infiniteRepeatable(tween(3000), RepeatMode.Reverse),
        label = "rotateY"
    )
Canvas(
        modifier = Modifier
            .size(canvasWidth, height)
            .graphicsLayer {
                transformOrigin = TransformOrigin(0f, 0f)
                rotationZ = 2f
                rotationY = rotateY
            }
    ) { ... }
</code></pre>

<p>至此，我们的五星红旗就算做完了，当然了可对背景的左边和右边也加上波动，就会更像一些了，完整代码可以<a href="https://github.com/alexhilton/EffectiveCompose/blob/main/app/src/main/java/net/toughcoder/effectivecompose/WavingFlag.kt">看这里</a>。</p>

<p>让我们小结一下，看似简单的一个五星红旗，实现起来其实并不容易，用到了好多数学知识，书到用时方恨少，数学真的太重要了，无处不在。UI开发会涉及大量的数学（特别是几何）知识，要想做好UI必须 要有良好的数学功底，难度并不小。</p>

<h2>仅供娱乐，请勿参考</h2>

<p>以上的实现方式其实仅供娱乐，在真实的项目中不建议这样一笔一笔的用Canvas来画。建议的实现方式应该是找一个（或者让设计师提供）现成的五星红旗图形资源，然后当成图片来展示 出来。</p>

<p>这样做的好处是把设计与代码实现分离开来，当需要调整设计效果时，不必去修改代码，毕竟替换一个资源比起修改代码的风险要小很多，虽然说可能也只是调整一个整数（颜色），但毕竟是改代码了，风险还是有的。再者，分离开来能让设计工作由更为专业的人士来做，而不必受到（或者考虑）代码实现的限制。还有就是，用代码一笔一笔的画，无论研发效率还是运行效率其实都不高，远不如显示一张图片性能好。</p>

<h2>最后</h2>

<p>祝愿伟大的祖国繁荣昌盛，国泰民安！祝愿所有的朋友国庆快乐，天天开心！</p>

<h2>References</h2>

<ul>
<li><a href="https://codepen.io/jonkemp/pen/EVgaLR">Five-pointed star using CSS</a></li>
<li><a href="https://stackoverflow.com/questions/14580033/algorithm-for-drawing-a-5-point-star">Algorithm for drawing a 5 point star</a></li>
<li><a href="https://www.instructables.com/How-to-draw-a-5-point-star/">How to Draw a 5-point Star</a></li>
<li><a href="https://codepen.io/udit007/pen/XWJooNQ">Waving Flag animation with CSS</a></li>
<li><a href="https://codepen.io/christopheschwyzer/pen/nMoWBa">CSS3 Waving Flags</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[搞定在Jetpack Compose中优雅地申请运行时权限]]></title>
    <link href="https://alexhilton.github.io//blog/2024/09/27/handle-permissions-in-compose/"/>
    <updated>2024-09-27T08:36:47+08:00</updated>
    <id>https://alexhilton.github.io//blog/2024/09/27/handle-permissions-in-compose</id>
    <content type="html"><![CDATA[<p>随着安全与隐私问题越来越被人们所重视，操作系统对应用程序的限制也越来越严格。一个非常明显的控制就是对于运行时权限（Runtime permissions）的管控是越来越严格，很多原本不需要权限的地方也需要了权限。这就要求应用程序必须能够灵活的处理运行时权限。Jetpack Compose作为一个独立于平台的声明式UI框架，本身并没有权限的概念，权限是平台强相关的，本文将研究一下如何在Compose中优雅的申请运行时权限。</p>

<p><a href=""><img src="https://img-blog.csdnimg.cn/9f802deb822f45a794a15fd9de4bc42d.png" title="auto auto" ></a></p>

<!-- more -->


<p><strong>注意：</strong> 这里提到的权限都是运行时权限，也就是需要在访问某些API之前动态地向用户申请授权许可。</p>

<h2>运行时权限申请用例</h2>

<p>有过Android开发经验的同学对运行时权限申请一定不陌生。自从Android Marshmallow（6.0，API Level 23）开始，对于一些敏感的权限，除了在应用的Manifest中声明以外，还需要在运行时动态的<a href="https://developer.android.com/training/permissions/requesting">向用户申请使用权限</a>，只有在用户同意授权后才可以使用相关的功能，当然用户也可能会拒绝。自此，运行时的权限申请就变成了应用开发的一个标配了。</p>

<p>比如以相机权限为例，第一步，要先在AndroidManifest中声明权限使用：</p>

<pre><code class="xml">&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"&gt;
    &lt;uses-permission android:name="android.permission.CAMERA" /&gt;
    &lt;application
        ...
    &lt;/application&gt;
&lt;/manifest&gt;
</code></pre>

<p>之后第二步，在要使用相机的入口地方，也就是要访问相机API的入口处先进行权限检查，如果已授予，则走正常的逻辑（如打开相机），否则进行权限申请：</p>

<pre><code class="Kotlin">    // 调用相机的入口处
    if (ContextCompat.checkSelfPermission(context, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED) {
        happyWithCamera()
    } else {
        // 提示用户需要权限，然后申请权限
        ActivityCompat.requestPermissions(context,  arrayOf(Manifest.permission.CAMERA), 1024)
    }
</code></pre>

<p>权限申请会离开当前的页面，进入到系统的权限处理逻辑。然后第三步，在系统权限回调中（类似于onActivityResult）检查用户权限授予结果，如果已授予则走第二步中的正常逻辑，否则，弹窗提示用户，解释权限对于应用程序的必要性，视权限的必要程度和交互逻辑，可以再次申请权限或者走无权限的逻辑（假如部分功能还可用）或者直接退出：</p>

<pre><code class="Kotlin">// 系统权限回调，类似于onActivityResult
@Override
public void onRequestPermissionResult(int reqCode, @NonNull String[] perms, @NonNull int[] results) {
    super.onRequestPermissionResult(reqCode, perms, results)
    if (reqCode == 1024) {
        if (results.length &gt; 1 &amp;&amp; results[0] == PackageManager.PERMISSION_GRANTED) {
            // 用户授权了，可以使用相机了
            happyWithCamera()
        } else {
            // 权限被用户拒绝，有三种做法：
            // 1. 如果是必须的权限，可再次申请；
            // 2. 如果已被拒绝多次，或者不想再次申请，那就提示用户然后退出
            // 3. 如果是非必须权限，那就走剩余的流程
        }
    }
}
</code></pre>

<p>如果是多个权限，处理的方式也是一样的，因为申请权限以及权限回调中都是数组，也即是可以处理多个权限。</p>

<p>对于在何时着手处理权限，要视权限对业务逻辑的重要程度，如果是必须的权限（如Location于地图应用，Camera于相机应用）那应该在应用启动时，加载任何页面之前作为第一件事情去做；如果不是，非主要业务逻辑，如微信或者支付宝的扫码功能，绝大多数应用都有扫码功能但都非其主要业务逻辑，那应该在用户启动扫码功能时去处理相机权限。</p>

<h2>以原生方式申请运行时权限</h2>

<p>让我们回到Compose世界，因为在Jetpack Compose中没有权限的概念，因此要把原生的权限处理方式在Composable中完成。第一步权限的声明仍需要在应用程序的Manifest中来做，这一步是没有变化的。</p>

<p>第二步和第三步有些麻烦，Compose是由一坨坨的composable函数组成的，我们只能调用其他的函数，没有办法处理权限回调，这是Activity的一个public方法，不是可以设置的常规回调，因为我们没有办法创建Activity的实例。另外前面的例子中请求权限会用到Activity，而在Compossable中不应该去尝试获取Activity，虽然是可以拿到实例的，但作为一个独立的UI框架不应该去拿平台强相关的且生命周期不可控的对象实例。</p>

<p>这里就可以通过一个叫做<a href="https://developer.android.com/reference/androidx/activity/result/ActivityResultLauncher">ActivityResultLancher</a>来对Activity的跳转和onActivityResult进行封装，创建一个ActivityResultLancher实例，设置一个onResult回调来处理onActivityResult，这个launcher也可以用来启动新的Activity。本质上与覆写Activity的方法也是一样的，但最重要的是我们可以自主的创建ActivityResultLancher对象，这样就可以在纯函数式的composable中使用了。ActivityResultLancher可以应对很多跳转场景，由<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContract">ActivityResultContract</a>对象来定义，已经有很多预定义类型了，对于申请权限要使用<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContracts.RequestPermission">RequestPermission</a>。</p>

<p>仍是以相机权限为例，假定是一个相机权限强必须的拍照应用，可以在应用的入口处定义PermissionInterceptor来处理权限：</p>

<pre><code class="Kotlin">class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            HelloComposeTheme {
                // A surface container using the 'background' color from the theme
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    PermissionInterceptor(
                        content = {
                            Text("Happy with Camera!")
                        },
                        noPermission = {
                            Text("To use this app, you must grant CAMERA permission!")
                        }
                    )
                }
            }
        }
    }
}

@SuppressLint("LaunchDuringComposition")
@Composable
fun PermissionInterceptor(
    modifier: Modifier = Modifier,
    content: @Composable BoxScope.()-&gt;Unit,
    noPermission: @Composable BoxScope.()-&gt;Unit
) {
    val context = LocalContext.current
    val permission = Manifest.permission.CAMERA

    var isGranted by remember { mutableStateOf&lt;Boolean?&gt;(null) }
    val permissionLauncher = rememberLauncherForActivityResult(
        ActivityResultContracts.RequestPermission()
    ) { granted -&gt;
        isGranted = granted
    }

    Box(modifier = modifier, contentAlignment = Alignment.Center) {
        if (isGranted == true ||
            ContextCompat.checkSelfPermission(
                context,
                permission
            ) == PackageManager.PERMISSION_GRANTED) {
            content()
        } else if (isGranted == null) {
            LaunchedEffect(permissionLauncher) {
                permissionLauncher.launch(permission)
            }
        } else {
            noPermission()
        }
    }
}
</code></pre>

<p>需要注意是如果是像上面例子这样在应用的入口处时就检查并申请权限，需要把launcher包裹在副作用函数LauncherEffect中，否则会有『IllegalStateException: Launcher has not been initialized』，这是因为初始化工作并未做完，但如果是用户点击之后才会触发权限申请则不需要。</p>

<p>在实际项目中，可能不止一个权限需要申请。申请多个动态权限，流程逻辑也一样的，需要传入<a href="https://developer.android.com/reference/androidx/activity/result/contract/ActivityResultContracts.RequestMultiplePermissions">RequestMultiplePermissions</a>，以及参数和结果都是数组：</p>

<pre><code class="Kotlin">@Composable
fun MultiplePermissionsInterceptor(
    modifier: Modifier = Modifier,
    content: @Composable BoxScope.()-&gt;Unit,
    noPermission: @Composable BoxScope.()-&gt;Unit
) {
    val context = LocalContext.current
    val permissions = arrayOf(
                        Manifest.permission.CAMERA,
                        Manifest.permission.ACCESS_COARSE_LOCATION,
                        Manifest.permission.ACCESS_FINE_LOCATION
                    )
    var isGranted by remember { mutableStateOf&lt;Boolean?&gt;(null) }
    val permissionLauncher = rememberLauncherForActivityResult(
        ActivityResultContracts.RequestMultiplePermissions()
    ) { granted -&gt;
        isGranted = granted.all { it.value }
    }

    Box(modifier = modifier, contentAlignment = Alignment.Center) {
        if (isGranted == true ||
            permissions.all {
                ContextCompat.checkSelfPermission(
                    context,
                    it
                ) == PackageManager.PERMISSION_GRANTED
            }
        ) {
            content()
        } else if (isGranted == null) {
            LaunchedEffect(permissionLauncher) {
                permissionLauncher.launch(permissions)
            }
        } else {
            noPermission()
        }
    }
}
</code></pre>

<h2>使用Accompanist-permissions</h2>

<p>事实上谷歌也在着手解决Compose中的权限处理问题，在<a href="https://google.github.io/accompanist/permissions/">accompanist库中有处理权限</a>的API。</p>

<blockquote><p><a href="https://google.github.io/accompanist/">Accompanist</a>是一个由谷歌提供的Jetpack Compose的补充库，也就是说一些开发者强烈需求的API，但还未正式放入Compose中，但谷歌也有意要提供，那么就会先放放Accompanist中，等开发完成试用很好，可能就会移入到Jetpack Compose中变成正式的API。Accompanist中能找到很多新奇的东西，比如像下拉刷新，流式布局，权限处理，WebView等等。但需要注意的是Accompanist多半是试验性的，API很不稳定，说变就变，说没就没，使用之前要三思。</p></blockquote>

<h3>配置accompanist-permission</h3>

<p>Accompanist是一个独立的库，而且拆分的很细，权限处理是一个独立的包：</p>

<pre><code class="Kotlin">dependencies {
    // Accompanist permission
    val accompanistVersion = "0.32.0"
    implementation("com.google.accompanist:accompanist-permissions:$accompanistVersion")
}
</code></pre>

<h3>使用Accompanist-permission</h3>

<p>既然是API自然在封装上会做的更好，使用起来更加的方便。Accompanist使用<a href="https://google.github.io/accompanist/api/permissions/com.google.accompanist.permissions/remember-permission-state.html">rememberPermissionState</a>和<a href="https://google.github.io/accompanist/api/permissions/com.google.accompanist.permissions/remember-multiple-permissions-state.html">rememberMultiplePermissionsState</a>返回一个状态<a href="https://google.github.io/accompanist/api/permissions/com.google.accompanist.permissions/-permission-state/index.html">PermissionState</a>，这个状态既可以检查权限申请结果，也可以去申请权限，体验丝般顺滑：</p>

<pre><code class="Kotlin">@OptIn(ExperimentalPermissionsApi::class)
@Composable
fun AccompanistInterceptor(
    modifier: Modifier = Modifier,
    content: @Composable BoxScope.()-&gt;Unit,
    noPermission: @Composable BoxScope.()-&gt;Unit
) {
    val permissionState = rememberPermissionState(permission = Manifest.permission.CAMERA)

    Box(modifier = modifier, contentAlignment = Alignment.Center) {
        if (permissionState.status.isGranted) {
            content()
        } else if (permissionState.status.shouldShowRationale) {
            noPermission()
        } else {
            LaunchedEffect(permissionState) {
                permissionState.launchPermissionRequest()
            }
        }
    }
}
</code></pre>

<p>处理多个权限时用带有multiple字样的接口就可以了：</p>

<pre><code class="Kotlin">@OptIn(ExperimentalPermissionsApi::class)
@Composable
fun MultipleAccompanistInterceptor(
    modifier: Modifier = Modifier,
    content: @Composable BoxScope.()-&gt;Unit,
    noPermission: @Composable BoxScope.()-&gt;Unit
) {
    val permissions = listOf(
                        Manifest.permission.CAMERA,
                        Manifest.permission.ACCESS_COARSE_LOCATION,
                        Manifest.permission.ACCESS_FINE_LOCATION
                    )
    val permissionState = rememberMultiplePermissionsState(permissions = permissions)

    Box(modifier = modifier, contentAlignment = Alignment.Center) {
        if (permissionState.allPermissionsGranted) {
            content()
        } else if (permissionState.shouldShowRationale) {
            noPermission()
        } else {
            LaunchedEffect(permissionState) {
                permissionState.launchMultiplePermissionRequest()
            }
        }
    }
}
</code></pre>

<blockquote><p><strong>注意：</strong> 因为Accompanist库是实验性质的，所以它的API都要求带上注解&#64;OptIn(ExperimentalPermissionsApi::class)。</p></blockquote>

<p>扩展阅读：</p>

<ul>
<li><a href="https://medium.com/@rzmeneghelo/how-to-request-permissions-in-jetpack-compose-a-step-by-step-guide-7ce4b7782bd7">How to Request Permissions in Jetpack Compose: A Step-by-Step Guide</a></li>
<li><a href="https://www.paleblueapps.com/rockandnull/how-to-request-permissions-in-jetpack-compose/">Jetpack Compose Permissions: A Quick and Easy Guide</a></li>
<li><a href="https://blog.stackademic.com/the-best-way-of-managing-runtime-permissions-using-permissionhandler-in-jetpack-compose-adb8057577d4">The best way to manage the Runtime permissions using PermissionHandler in Jetpack Compose</a></li>
<li><a href="https://www.composables.com/tutorials/permissions">A comprehensive guide to Android runtime permissions using Jetpack Compose</a></li>
<li><a href="https://stackoverflow.com/questions/73898807/how-to-handle-runtime-permissions-in-jetpack-compose-properly-by-accompanist">How to handle runtime permissions in jetpack compose properly by accompanist?</a></li>
</ul>


<h2>总结</h2>

<p>本文详细了介绍了目标平台是Android时，Compose的两种运行时权限申请方式。推荐使用Accompanist库中的permission模块，虽然这会引入一个新的依赖，虽然它只是实验性的，毕竟用起来方便啊。当然，如果想要精细化的处理权限的各种结果就直接用原生方式，也并没有麻烦多少。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/training/permissions/requesting">Request runtime permissions</a></li>
<li><a href="https://betterprogramming.pub/jetpack-compose-request-permissions-in-two-ways-fd81c4a702c">2 Ways to Request Permissions in Jetpack Compose</a></li>
<li><a href="https://www.howtodoandroid.com/runtime-permission-on-jetpack-compose/">Best ways to handle runtime permission on jetpack compose</a></li>
<li><a href="https://www.freecodecamp.org/news/requesting-location-permissions-in-jetpack-compose/">How to Request Location Permissions in Jetpack Compose</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[轻松解决Jetpack Compose中的一些痛点问题]]></title>
    <link href="https://alexhilton.github.io//blog/2024/09/21/compose-best-practices/"/>
    <updated>2024-09-21T10:59:35+08:00</updated>
    <id>https://alexhilton.github.io//blog/2024/09/21/compose-best-practices</id>
    <content type="html"><![CDATA[<p>暑去秋来，金桂飘香，不知不觉中我们已经练完了<a href="https://juejin.cn/column/7367555191338467337">『降Compose十八掌』</a>，相信通过这一系列文章能够对Jetpack Compose有足够的理解，并能在实际项目中进行运用。今天将继续Compose之旅，总结一下Compose使用过程中经常会遇到的一些痛点问题，并学会如何优雅的解决这些问题。</p>

<p><a href=""><img src="https://innovationm.co/wp-content/uploads/2021/05/Jetpack-compose.png" title="auto auto" ></a></p>

<!-- more -->


<h2>定义slot时要注明布局作用域</h2>

<p>先来看一个比较常规的问题，Compose开发过程中，非常鼓励开发者把可以复用的部分抽象成为一个函数，然后接收一个尾部lambda作为参数进行差异化的定制。这种范式叫做<a href="https://developer.android.com/develop/ui/compose/layouts/basics#slot-based-layouts">slot模式</a>，slot模式的好处在于能够大大加强代码复用，开发者在构建UI的时候，像搭积木那样把一个一个的slot叠在一起。Compose自己的API中都大量的采用了这种模式。</p>

<p>为了让slot更加的通用，我们需要<strong>明确传入的lambda与slot之间的约定</strong>，这就要求我们对lamdba的类型进行严格的限制。</p>

<p>首先要添加注解&#64;Composable，这个是显而易见的，因为slot是为了绘制一些自定义UI元素而准备的，所以肯定是要加上&#64;Composable，否则在lambda中无法写UI，因为非Composable不能调用Compose的方法。</p>

<p>另外，不是那么明显的就是这个lamdba的类型，要指定<a href="https://kotlinlang.org/docs/lambdas.html#function-literals-with-receiver">其Receiver</a>，以限定它所在的布局。比如说slot是用在一个Column里面的，那么要给lamdba指定ColumnScope作为receiver，这样在实现lambada的时候就知道是作为Column的一部分，并且可以使用Column布局的特有相关参数，如左右居中和垂直排列：</p>

<pre><code class="Kotlin">@Composable
MyLayout(
     modifier: Modifier,
     content: @Composable ColumnScope.()-&gt;Unit
) {
     Column() {
          // 共用的一部分

          content()
     }
}

// 调用的地方
MyLayout { // this = ColumnScope
     // 隐式this指针指向一个ColumnScope对象，就像在一个Column中一样
     // 定制的部分
}
</code></pre>

<p>UI元素很多都会涉及到居中，对齐的调整，以及内部元素的排列，而对齐和排列又会明确的受到所在父布局的影响，比如说Box与Column的对齐和排列方式就是不同的。所以在使用slot时一定要明确 标注它所在的布局，以让调用者能够明确地知道lambda所在的布局作用域。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://chrisbanes.me/posts/slotting-in-with-compose-ui/">Slotting in with Compose UI</a></li>
<li><a href="https://www.valueof.io/blog/compose-slot-api-example-composable-content-lambda">Practical Compose Slot API example</a></li>
<li><a href="https://proandroiddev.com/designing-slot-apis-in-jetpack-compose-4a981ddbc776">Designing Slot APIs in Jetpack Compose</a></li>
<li><a href="https://tech.pic-collage.com/%E5%88%9D%E6%8E%A2-jetpack-compose-slot-api-8d3f153f77e3">初探 Jetpack Compose — Slot API</a></li>
</ul>


<h2>如何在ViewModel中使用平台相关的资源</h2>

<p>我们在<a href="https://juejin.cn/post/7411812014047461387">降Compose十八掌之『神龙摆尾』| Architecture</a>中讨论过，ViewModel作为Domain层，目的是把逻辑尽可能的从UI层中抽出来，让UI尽可能的只做UI渲染。ViewModel也要做到平台独立，这样才方便移植和测试。ViewModel中吐出来的数据要是加工过的可以直接方便地在UI层展示的数据，如字符串或者图片。</p>

<p>但有一个问题，资源文件如何管理都是平台强相关的。对于要展示给用户的文案，也不可能直接把字符串传给UI，因为UI语言都要能够本地化以适应不同的国家和地区，当然了如果说不需要考虑多语言的问题，比如我的应用只给某一个语言使用，那当然也可以直接把处理好的字符串当作UiState传给UI层。</p>

<p>最为理想的解决方案就是ViewModel层定义一些<strong>状态码</strong>，对应着不同的提示语言，由UI负责一一对应的，把状态码再转成字符串。对于其他的资源也可以采用类似方式处理。这是从ViewModel输出到UI层的情况。</p>

<p>还会反过来，对于需要从UI层输入到ViewModel的资源，也是要<strong>去除平台的相关性</strong>，比如转成ViewModel中定义的状态码，或者转成原始数据类型String，或者转成平台无关的输入输出流等等。</p>

<h3>字符串资源</h3>

<p>对于Android平台来说，可以用一个简单的方式来解决字符串资源问题，因为资源的引用是一个整数，所以可以直接把资源的ID当作字段传给UI，Compose拿到后直接用函数stringResource取出来就可以了：</p>

<pre><code class="Kotlin">data class UiState(
     val loading: Boolean = false,
     @StringRes val errorMsg: Int = 0
)

class HomeViewModel {
     val timeout = UiState(false, R.string.error_message_timeout)
     _state.update(timeout)
}

// 在Compose中
HomeScreen() {
    Text(stringResource(uiState.errorMsg))
}
</code></pre>

<p>虽然说这并不太通用，因为换成其他平台时可能不是用资源ID来获取资源，但转成状态码的方式也会很容易，所以问题不大。</p>

<p>如果是输入的话，在Compose中直接读取资源变成String传给ViewModel就好了。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://stackoverflow.com/questions/47628646/how-should-i-get-resourcesr-string-in-viewmodel-in-android-mvvm-and-databindi">How should I get Resources(R.string) in viewModel in Android (MVVM and databinding)</a></li>
<li><a href="https://medium.com/@margin555/using-string-resources-in-a-viewmodel-e334611b73da">Using String Resources in a ViewModel</a></li>
</ul>


<h3>图片资源</h3>

<p>图片资源一般来说都是UI自己指定，但有些时候可能会有逻辑，比如一些需要经过运算才能得到的复杂的状态，其代表的Icon，由ViewModel来直接指定要好一些。图片资源也可以直接使用资源ID，然后在Compose中使用painterResource来获取：</p>

<pre><code class="Kotlin">data class UiState(
     @DrawableRes val icon: Int = 0
)

// in ViewModel
val state = UiState(R.drawable.ic_windy)

// in Compose
Icon(painterResource(uiState.icon))
</code></pre>

<p>如果是输入的话，可以在Compose中把图片资源转成输入流传给ViewModel去处理。</p>

<h3>其他资源</h3>

<p>其他资源如dimen或者color，也可以如法炮制。</p>

<p>输入的话，对于普通的资源像字符串资源，dimen或者color等读出来转成基础数据类型String，Int或者Array传给ViewModel就好。而像比较麻烦的资源，如Assets中的资源，就转成输入流传给ViewModel处理。</p>

<h2>如何在常规函数中调用Composables</h2>

<p>在Compose的开发过程中最为令人不爽的地方在于Compose 的API，只能在被注解&#64;Composable标注的函数中调用，其他地方是无法调用的。一般来说，这个问题也不大，因为Compose的入口是肯定是一个composable啊，一坨坨的composables的调用最终<a href="https://juejin.cn/post/7407643004490956810">会生成UI树</a>。</p>

<p>但有些地方却跑出了Composable之外，比如像很多UI元素的事件响应，比如<a href="https://developer.android.com/develop/ui/compose/components/button">Button</a>，它的事件响应onClick接收的就是一个普通的lambda：</p>

<pre><code class="Kotlin">@Composable
fun MainContent(
    modifier: Modifier = Modifier,
    serviceOn: Boolean,
    context: Context
) {
    Column() {
        Button(
            onClick = { AccessibilityHelper.gotoChronosSettings(context) },
        ) {
            Text(stringResource(if (serviceOn) R.string.turn_off_service else R.string.enable_service))
        }
    }
}
</code></pre>

<p>在Button的onClick里面可以执行一些普通函数调用，比如调用ViewModel等，但是不可以调用Compose的API，因为它是非Composable的，已经跑到了Composable之外。有些场景，这会带来比较大的不方便。</p>

<p>响应点击按扭的方式可能有很多，有些是执行一些普通函数调用，但有些时候也会修改UI，大部分时候也会创建新UI，比如说会弹出对话框。对于修改UI，可以直接通过修改状态的值，状态的值发生改变会触发重组，进而UI状态就会改变（通过读取状态的值显示 不同的UI）。</p>

<p>对话框<a href="https://developer.android.com/develop/ui/compose/components/dialog">Dialog</a>也是一个Composable，它只能被Composable调用，无法在Button的onClick中直接调用Dialog。解决的办法依旧是借助状态，用一个Boolean型值的状态，当其为true时显示Dialog，在Button的onClick中更改此状态为true，状态变了触发重组，在重组时值为true就会显示Dialog了：</p>

<pre><code class="Kotlin">@Composable
fun InputSettingsEntry(
    label: String,
    description: String,
    value: String,
    onChange: (String)-&gt;Unit
) {
    var showing by remember { mutableStateOf(false) }
     Button(onClick = { showing = true }) {
          Text(value)
     }

    if (showing) {
        InputDialog(
            title = label,
            message = description,
            value = value,
            onDismiss = { showing = false },
            onConfirm = {
                onChange(it)
                showing = false
            }
        )
    }
}
</code></pre>

<p>另外，其实Dialog本身的一些事件响应也都是非Composable的，都是通过状态来控制Dialog的显示与否。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://stackoverflow.com/questions/66952179/not-able-to-show-alertdialog-from-onclick-in-jetpack-compose">Not able to show AlertDialog from onClick in Jetpack Compose</a></li>
<li><a href="https://medium.com/@esthcarelle/alert-dialog-with-jetpack-compose-a-step-by-step-guide-04dc3e9dfc1d">Alert Dialog with Jetpack compose: A Step-by-Step Guide</a></li>
</ul>


<h2>总结</h2>

<p>Jetpack Compose博大精深，看似简单就是一坨函数，但在实际项目使用中会遇到各种细节问题。遇到问题也不用慌，用我们的<a href="https://juejin.cn/column/7367555191338467337">『降Compose十八掌』</a>都能解决，没事就多读一读，理解了Compose的思想与原理，做到心中无剑，很多问题都能迎刃而解。</p>

<h2>References</h2>

<ul>
<li><a href="https://climbtheladder.com/10-android-jetpack-compose-best-practices/">10 Android Jetpack Compose Best Practices</a></li>
<li><a href="https://getstream.io/blog/jetpack-compose-guidelines/">6 Jetpack Compose Best Practices for Optimizing Your App Performance</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『神龙摆尾』| Architecture]]></title>
    <link href="https://alexhilton.github.io//blog/2024/09/12/architecture-in-compose/"/>
    <updated>2024-09-12T22:27:58+08:00</updated>
    <id>https://alexhilton.github.io//blog/2024/09/12/architecture-in-compose</id>
    <content type="html"><![CDATA[<p>通过前面的<a href="https://juejin.cn/column/7367555191338467337">一系列文章</a>，我们已经掌握了足够的Jetpack Compose的开发基础。为了更好的在实际项目中使用Compose，我们还需要了解一下现代应用开发的架构原则，以及使用Jetpack Compose时如何更好的遵循这些原则。这篇文章将聚焦于架构原则这一话题，进行一些探讨和总结。</p>

<p><a href=""><img src="https://www.sixt.tech/assets/jetpack-compose/jetpack-compose.png" title="auto auto" ></a></p>

<!-- more -->


<h2>现代Android应用开发的架构方式</h2>

<p>Jetpack Compose是一个声明式的UI框架，用它来开发应用程序，因此根本上仍是在做应用程序开发，所以需要遵循现代应用程序的架构原则。</p>

<p>一提到架构自然会想到Bob大叔的<a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">The Clean Architecture</a>，这里面的最主要的核心思想就是分层，把不同的概念按照抽象的层次进行分离，层与层之间有特定的依赖规则，也即只能从控制层往业务逻辑依赖。分层最大的益处就是方便移植和替换，降低维护成本，这也是架构的意义所在。</p>

<p><img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg" alt="图1. The Clean Architecture" /></p>

<p>对于移动应用开发，谷歌也给出比较实用的<a href="https://developer.android.com/topic/architecture#common-principles">现代应用架构原则</a>，其中有四个核心原则：</p>

<ol>
<li>远离系统组件，系统组件（Activity，Service和Fragment等）仅能作为一个入口和必要的依赖对象，以及协调和连接不同的对象。深层次的原因是系统组件实例不可控，系统随时会重新创建实例，所以应该把对系统组件的依赖降到最低；</li>
<li>由数据来驱动UI，且数据最好是不可变的（Immutable data）。这个原则要求把逻辑尽可能的放在数据层而非UI层，UI层就是展示数据层，处理用户事件和UI自己的逻辑，但不应该做的业务逻辑处理。比如说新闻类应用，数据层把一坨列表传过来，UI就展示，如果列表为空，那显示加载错误，用户点击刷新就让数据层刷新数据。但不应该对列表中的数据做更新或者更改，比如说把不同的列表融合为一个，这些都是业务逻辑，应该由数据层来做。这样的好处是能让UI层尽可能的简单，方便移植，方便测试。而且这符合响应式的数据流，可以使用响应式编程范式（MVVM或者MVI）；</li>
<li>单一数据源（Single Source Of Truth），也就是说任何数据都应该只由它的生产者来修改，其他模块只是使用不能修改，因此每一层返回的数据都应该是不可修改类型（Immutable objects）;</li>
<li>单向数据流动（Unidirectional Data Flow），UI层展示数据，获得用户事件，调用业务逻辑层处理事件，业务逻辑层再去数据层请求新的数据，新的数据再来驱动刷新UI，而不可以业务逻辑层修改数据后一边去刷新UI，一边再去让数据层修改数据，这会导致难以调试的bug。</li>
</ol>


<p><img src="https://developer.android.com/static/topic/libraries/architecture/images/mad-arch-overview.png" alt="图2. 现代应用典型架构" /></p>

<p>下面我们围绕Jetpack Compose来深入探讨一下如何把这些架构原则落到实处。</p>

<h2>使用Jetpack Compose落实架构原则</h2>

<p>Jetpack Compose是声明式UI框架，所以它只能出现在UI层，用UI元素展示数据， 以及获取用户事件。其余的部分，如业务逻辑层（ViewModels）和数据层（Models and Data）都与Compose没有关系，也不应该受到Compose的影响。这就是架构分层带来的好处，不同层之间通过约定 的接口进行协作，每一层都可以用不同的技术栈去实现，不会对其他层造成影响。</p>

<p><img src="https://developer.android.com/static/topic/libraries/architecture/images/mad-arch-overview-ui.png" alt="图3. 应用架构中的UI层的角色" /></p>

<h3>典型的项目结构</h3>

<p>按照架构原则，一个典型的项目模块结构应该是酱紫的：</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/project_org.png" alt="图4. 典型项目模块结构" /></p>

<p>Activity（对应着Activity实例）和AndroidApp（对应着Application实例）是应用程序的入口，可能需要在里面做一些必要的初始化工作，比如有些三方的库可能需要在Application#onCreate中去做初始化工作。ui package对应着UI层，负责UI的展示；package model对应着Model层，里面定义着供UI层使用的数据类型，以及获取 这些数据的接口；package data对应着数据层（data layer），实现着model中的接口定义。当然也可以把model与data合并成一个package，不过，单独把数据的定义和数据层的接口拿出来放在一个包里，会更清晰一些，因为UI层只需关心有哪些接口可以获得什么数据，它只需要知道model就够了。</p>

<p>Jetpack Compose的入口应该用一个名字为App的函数，在这里做初始化工作，比如创建数据层的实例，进行弹窗，创建导航等等。此处作为一个桥接，用以把Android的组件与Compose连接起来，创建必要的实例并把各实例协调起来。当然也可以直接把这些事情放入Activity中，但独立出来更方便测试和移植，让系统组件变得更为简单。Activity直接调用App即可：</p>

<pre><code class="Kotlin">class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            AeolusApp(Modifier.fillMaxWidth())
        }
    }
}

@Composable
fun AeolusApp(
    modifier: Modifier = Modifier
) {
    AeolusTheme {
        // A surface container using the 'background' color from the theme
        Surface(
            modifier = modifier,
            color = MaterialTheme.colorScheme.background
        ) {
            CurrentLocationPermission {
                val dataContainer = DataContainerImpl(LocalContext.current)
                AeolusNavGraph(appContainer = dataContainer)
            }
        }
    }
}
</code></pre>

<h3>创建导航</h3>

<p>导航是把所有的UI页面组织在一起形成一个逻辑清晰的交互整体，可以参照之前的文章<a href="https://juejin.cn/post/7398728505872908315">降Compose十八掌之『密云不雨』| Navigation</a>来创建导航。</p>

<p>需要注意的就是页面应该命名为Screen，其ViewModel应该作为参数传递给Screen，Screen和ViewModel的实例创建都在导航中来完成。</p>

<h3>ViewModel应该保持独立</h3>

<p>ViewModel作为UI层与数据层的中间层而存在，目的是让UI层专注于数据展示。为了更好的可移植性，ViewModel不应该有平台相关的依赖，比如<a href="https://juejin.cn/post/7409869765177147430">平台的生命周期</a>或者Context，它只应该依赖model层。并且为了方便依赖注入，应该把Model层的数据接口对象（通常是Repository）作为参数传递给ViewModel：</p>

<pre><code class="Kotlin">class FavoritesViewModel(
    private val locationRepo: LocationRepository,
    private val weatherRepo: WeatherRepository
) : ViewModel() {
}
</code></pre>

<p>具体的Repository对象可以在导航创建ViewModel时创建，或者用依赖注入框架（如Hilt）来注入实例。</p>

<h3>并发原则</h3>

<p>现代的应用肯定都会用并发，无论是协程还是Flow，为了能让并发更加的结构化和可控，应该遵循以下原则：</p>

<ol>
<li>Model层的方法都应该是suspend，对于所有Model层公开出来的方法都应该用suspend来修饰。</li>
<li>Repository（即Data层）的每个方法的实现都要指定明确的Dispatcher，最好接收一个Dispatcher作为构造参数，以方便进行注入或者测试。</li>
<li>ViewModel要把所有对Model的方法调用包裹在协程作用域viewModelScope中。</li>
</ol>


<h3>层与层之间的交互要定义接口</h3>

<p>比如Model层提供给ViewModel的能力要定义为接口，然后在Data层中去实现这些接口。接口的最大好处是方便替换具体的实现，比如换个实现方式时，或者Mock测试时都能很方便的进行替换，甚至还可以使用动态代理在运行时进行替换。</p>

<h3>对外部的依赖要作为构造器参数传入</h3>

<p>作为构造参数传入外部依赖，而不是在内部直接创建，这样做的好处在于方便替换实例，无论是日后更换一种实现实例，还是Mock测试，都可以在不修改类本身的情况下进行实例替换。甚至可以使用依赖注入框架（如Hilt）做到让具体使用的实例可配置化。</p>

<h2>Compose与ViewModel的交互原则</h2>

<p>这部分我们具体谈一谈Compose与ViewModel在交互时的一些原则和建议。ViewModel暴露UiState给Compose展示，Compose则把事件（Event）给ViewModel去处理（可以是MVI式的把事件封装成Intent塞给ViewModel，也可以直接调用ViewModel的接口）。</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/state-unidirectional-flow.png" alt="图5. Compose与ViewModel的UDF" /></p>

<p>比如说一个典型的登录场景，其Composable和ViewModel应该像这样的：</p>

<pre><code class="Kotlin">class MyViewModel : ViewModel() {
    private val _uiState = mutableStateOf&lt;UiState&gt;(UiState())
    val uiState: State&lt;UiState&gt;
        get() = _uiState
    // ...
}

data class UiState(
    loading: Boolean = false,
    signedIn: Boolean = false,
    error: String = ""
)

@Composable
fun MyComposable(viewModel: MyViewModel) {
    val uiState = viewModel.uiState.collectAsStateWithLifecycle()
    if (uiState.loading) {
        // show loading
    } else if (uiState.signedIn) {
        // show signed in status
    } else {
        // show uiState.error
    }
}
</code></pre>

<h3>一定要定义专用的UiState数据对象</h3>

<p>从ViewModel给UI的数据要封装成一个不可变的数据对象（data class）作为UiState，即使其数据与从Model处获得的数据没有变化，也应该定义并做基本转换。</p>

<p>原因就是让UI层和Model不会相互影响，假如直接把Model的数据传给UI，那假如以后Model层的数据有变动，这就会影响到UI。架构分层的目的就是要封装和隔离，每一层都应该定义自己的输出数据类型，把依赖和耦合降到最低。</p>

<h3>当数据特别多时，分成多个UiState对象</h3>

<p>如果页面较复杂，需要的字段特别多，这时应该把页面分成几个区域，同时UiState也应该分成几个不同的对象，而不是大一统的装在一个对象里面。</p>

<p>原因在于Compose会把从ViewModel处获得的UiState装在一个状态里面，从<a href="https://juejin.cn/post/7376094685495001139">前面的文章中</a>我们知道，状态是用于触发重组的，状态发生变化就会触发重组。因为数据多半部分变化的，甚至有些业务逻辑总是某几个字段在变化。因为字段都放在了一个对象中，那么即使只有一个字段变了，对于Compose来说，也是状态变化了，就要进行重组。</p>

<p>把字段按其变化的性质进行拆分，用几个UiState来表示，这样能把变化降到最低，只让真正有变化的UiState触发重组进而刷新UI。</p>

<h3>Compose中要尽可能拆解为无状态函数</h3>

<p>这里的意思是说我们应该把从ViewModel处获得的UiState拆解开来，变成具体的参数用无状态函数去展示，而不应该全都把UiState当成参数传给每一个composables。比如说对于一个新闻页面，对于标题元素就应该只接受两个String作为参数，而不应该把整个NewsUiState作为参数：</p>

<pre><code class="Kotlin">@Composable
fun Header(title: String, subtitle: String) {
    // 只有当title和subtitle发生变化时才会重组
}

@Composable
fun Header(news: NewsUiState) {
    // 只要状态变了就会重组，哪怕有关的title和subtitle没有变化
}
</code></pre>

<p>这样做的目的也是为了尽可能减少重组。</p>

<h3>ViewModel塞给UI的数据要能够直接展示</h3>

<p>UI层负责数据展示，不应该有过多的逻辑，特别是不能有涉及非UI直接相关的逻辑。ViewModel存在的意义就是为了把非UI相关的业务逻辑全从UI中拿走，把UI做的尽可能薄一些，这里薄的意思是逻辑要少。背后的核心原因在于方便测试和移植，众所周知UI是与每个平台强相关的，每个平台的UI构建方式都不一样，并且UI是极难做单元测试的，依赖太多很难Mock。</p>

<p>UI层很薄，仅是数据的展示，逻辑都放在ViewModel中，但ViewModel依赖很少，没有对平台和依赖，它的依赖对象都是可以Mock的，那么ViewModel就很容易做测试，只要测试保证ViewModel没什么问题，那么就基本上可以认为UI也不会有问题，毕竟光做展示一般不会出问题。</p>

<p>这里的最重要的一点就是要保证ViewModel递给UI的数据要是经过逻辑处理后的，可以直接展示的数据。举个粟子，比如说展示时间间隔的字段，类似于『100 ms』，『10 seconds』，『2 mins 10ms』或者『1 hour 10 mins』 这种，那么就不可以直接把一个Int或者Long传给UI，让UI去换算，而是让ViewModel做换算，把结果String传给UI，UI用一个Text直接显示String。这样一来就可测试了，我们Mock几个不同的字段值给ViewModel，再检查它吐出来的UiState中的时长String字段是否符合预期，就能保证这段逻辑没有问题。对于UI可以不用测试了，一个Text显示一个String出错的可能性不大，可以忽略了。</p>

<h2>总结</h2>

<p>架构最难的地方在于它是<strong>形而上学（Metaphysics）</strong>的，不会像算法或者设计模式那样有非常明确的和具体的实施步骤，仅是有一些抽象的指导原则。在实际的项目中就要从实际的业务场景出发，使用可用的技术工具，把指导原则进行落地，要<strong>把『神似』而非『形似』</strong>作为目标。切忌生搬硬套网上一些所谓的应用架构框架，假如真的有通用的架构框架，那谷歌为啥不写在SDK里面？不同的业务，不同的规模，不同的技术栈，不同的版本策略都会影响架构的方式。比如像第一部分提到的四大原则，难道只有用MVVM或者MVI才能做到么？即使用了MVVM，你在ViewModel直接把未处理的数据丢给UI，UI中仍有大量的处理数据的if-else，ViewModel把数据改了后两头更新，这明显不符合架构原则，最后仍是维护一坨巨大的shi山难解的Bug满天飞。所以对于网上的各种架构框架看看就好，一定不能生搬硬套。</p>

<p>可以通过谷歌提供的一些非常好的<a href="https://github.com/android/architecture-samples/tree/main">案例</a>来学习架构，仔细研读这些案例的源码，以深刻理解架构指导原则的内在涵义。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/topic/architecture">Guide to app architecture</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/architecture">Architecting your Compose UI</a></li>
<li><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">The Clean Architecture</a></li>
<li><a href="https://www.geeksforgeeks.org/separation-of-concerns-soc/">Separation of Concerns (SoC)</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
