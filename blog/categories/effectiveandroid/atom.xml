<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2018-05-19T18:28:34+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[让你不再俱怕Fragment State Loss]]></title>
    <link href="http://toughcoder.net/blog/2016/11/28/fear-android-fragment-state-loss-no-more/"/>
    <updated>2016-11-28T20:57:36+08:00</updated>
    <id>http://toughcoder.net/blog/2016/11/28/fear-android-fragment-state-loss-no-more</id>
    <content type="html"><![CDATA[<p>使用过<a href="http://www.android-doc.com/reference/android/app/Fragment.html">Fragment</a>的人我相信对臭名昭著的状态丢失问题（<a href="https://www.google.com.hk/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8#q=IllegalStateException%3A%20Can%20not%20perform%20this%20action%20after%20onSaveInstanceState">IllegalStateException: Can not perform this action after onSaveInstanceState</a>）一定不会陌生。曾经被这个问题困扰了很久，相信很多同学也是。花些时间来好好把它研究一下，以弄懂为何会有这样的问题产生，然后就可以解决问题，或者合理的规避问题。</p>

<p><a href=""><img src="https://img.alicdn.com/imgextra/i2/715978679/TB2lTose0uO.eBjSZFCXXXULFXa_!!715978679.png"></a></p>

<!-- more -->


<h2>什么是状态恢复</h2>

<p>安卓的状态恢复是一个比较令人困惑的特性，它源于拙劣的系统设计。当一个页面正在显示的时候，如果系统发生了一些变化，变化又足以影响页面的展示，比如屏幕旋转了，语言发生了变化等。安卓的处理方式就是把页面（Activity）强制杀掉，再重新创建它，重建时就可以读取到新的配置了。又或者，当离开了一个页面，再回到页面时，如果页面（Activity）因为资源不足被回收了，那么当再回到它时，系统也会重新创建这个页面。</p>

<p>状态恢复，是为了保持更好的用户体验，让用户感觉认为页面，是一直存在的，类似于处理器调用函数的保护现场和恢复现场。</p>

<p>Activity有二个钩子onSaveInstanceState和onRestoreInstanceState就是用来保存状态和恢复状态的。</p>

<p>当从Honeycomb引入了Fragment后，为了想让开发者更多的使用Fragment，或者想让Fragment更容易的使用，状态保存与恢复的时候也必须要把Fragment保存与恢复。Fragment本质上就是一个View tree，强行附加上一些生命周期钩子。所以，为了让页面能恢复成先前的样子，View是必须要重新创建的，因此Fragment是必须要恢复的。</p>

<p>Fragment的作用域是Activity，<a href="http://www.android-doc.com/reference/android/app/FragmentManager.html">FragmentManager</a>管理着一个Activity所有的Fragment，这些Fragment被放入一个栈中。每个Fragment有一个<a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/android/support/v4/app/Fragment.java#FragmentState">FragmentState</a>，它相当于Fragment的snapshot，保存状态时FragmentManager把每个Fragment的FragmentState存储起来，最终存储到Activity的savedInstanceState中。</p>

<h2>为什么会有这个异常</h2>

<p>既然状态的保存与恢复都必须要把Fragment带上，那么一旦当Fragment的状态已保存过了，那么就不应该再改变Fragment的状态。因此FragmentManager的每一个操作前，都会调用一个方法来检查状态是否保存过了：</p>

<pre><code class="java">private void checkStateLoss() {
    if (mStateSaved) {
        throw new IllegalStateException(
                    "Can not perform this action after onSaveInstanceState");
    }
    if (mNoTransactionsBecause != null) {
        throw new IllegalStateException(
                    "Can not perform this action inside of " + mNoTransactionsBecause);
    }
}
</code></pre>

<p>Fragment状态保存是在Activity#onSaveInstanceState时做的，会调用FragmentManager#saveAllState方法，来进行Fragment的状态保存，同时设置mStateSaved为true，以标识状态已被保存过。</p>

<h2>发生的场景以及如何应对</h2>

<h3>FragmentTransaction#commit()</h3>

<p>栈信息是这样子的：</p>

<blockquote><p>java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState
   at android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:1341)
   at android.support.v4.app.FragmentManagerImpl.enqueueAction(FragmentManager.java:1352)
   at android.support.v4.app.BackStackRecord.commitInternal(BackStackRecord.java:595)
   at android.support.v4.app.BackStackRecord.commit(BackStackRecord.java:574)</p></blockquote>

<p>或者是这样的:</p>

<blockquote><p>java.lang.IllegalStateException: Activity has been destroyed                                                                               <br/>
at android.app.FragmentManagerImpl.enqueueAction(FragmentManager.java:1456)                                                                                 <br/>
at android.app.BackStackRecord.commitInternal(BackStackRecord.java:707)                                                                              <br/>
at android.app.BackStackRecord.commit(BackStackRecord.java:671)                                                                                  <br/>
at net.toughcoder.miscellaneous.FragmentTestActivity</p></blockquote>

<p>原因就是commit操作发生在了状态保存之后。Activity#onSaveInstanceState的调用是不受开发者控制的，并且不同的安卓版本之间存在差异。具体的可以参考大神的<a href="http://www.androiddesignpatterns.com/2013/08/fragment-transaction-commit-state-loss.html">文章</a>。</p>

<p>解决之道，如大神提的一样，就是保证Fragment的操作发生在Activity可见周期之内，换句话说，Fragment的操作应该发生在Activity#onResume与Activity#onPause之间，为什么限制这么死呢？一方面为了防止上面问题发生；另外，Fragment本质上是View，View的操作理应该是页面处于活动状态时才应该进行。</p>

<p>关键的点就是小心控制异步任务，在onPause或者最迟在onStop中要终止所有的异步任务。</p>

<p>另外，大招就是使用commitAllowStateLoss。</p>

<h3>Activity#onBackPressed</h3>

<p>还有一种情况，也会出现此异常，而且是在Activity中完全 没有Fragment的情况下：</p>

<blockquote><p>java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState
                                                                                   at android.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:1434)
                                                                                   at android.app.FragmentManagerImpl.popBackStackImmediate(FragmentManager.java:577)
                                                                                   at android.app.Activity.onBackPressed(Activity.java:2751)
                                                                                   at net.toughcoder.miscellaneous.FragmentStateLossActivity.onBackPressed(FragmentStateLossActivity.java:90)
                                                                                   at net.toughcoder.miscellaneous.FragmentStateLossActivity$1.run(FragmentStateLossActivity.java:59)
                                                                                   at android.os.Handler.handleCallback(Handler.java:751)
                                                                                   at android.os.Handler.dispatchMessage(Handler.java:95)
                                                                                   at android.os.Looper.loop(Looper.java:154)
                                                                                   at android.app.ActivityThread.main(ActivityThread.java:6077)
                                                                                   at java.lang.reflect.Method.invoke(Native Method)
                                                                                   at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:865)
                                                                                   at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:755)</p></blockquote>

<p>或者是这样的：</p>

<blockquote><p>java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState
                                                                                     at android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:1500)
                                                                                     at android.support.v4.app.FragmentManagerImpl.popBackStackImmediate(FragmentManager.java:584)
                                                                                     at android.support.v4.app.FragmentActivity.onBackPressed(FragmentActivity.java:169)
                                                                                     at net.toughcoder.miscellaneous.FragmentStateLossActivity.onBackPressed(FragmentStateLossActivity.java:90)
                                                                                     at net.toughcoder.miscellaneous.FragmentStateLossActivity$1.run(FragmentStateLossActivity.java:59)
                                                                                     at android.os.Handler.handleCallback(Handler.java:751)
                                                                                     at android.os.Handler.dispatchMessage(Handler.java:95)
                                                                                     at android.os.Looper.loop(Looper.java:154)
                                                                                     at android.app.ActivityThread.main(ActivityThread.java:6077)
                                                                                     at java.lang.reflect.Method.invoke(Native Method)
                                                                                     at com.android.internal.os.ZygoteInit$MethodAndArgsCaller.run(ZygoteInit.java:865)
                                                                                     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:755)</p></blockquote>

<p>这二个异常都是发生在没有使用Fragment的Activity中。相当的诡异，根本没有用Fragment为何还会抛出State loss的异常。只能从栈信息中的方法开始分析：</p>

<p><a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/android/app/Activity.java#Activity.onBackPressed%28%29">Activity的onBackPressed</a>:</p>

<pre><code class="java">public void onBackPressed() {
    if (mActionBar != null &amp;&amp; mActionBar.collapseActionView()) {
        return;
    }

    if (!mFragments.popBackStackImmediate()) {
        finishAfterTransition();
    }
}
</code></pre>

<p>以及<a href="http://grepcode.com/file/repo1.maven.org/maven2/com.google.android/support-v4/r7/android/support/v4/app/FragmentActivity.java#FragmentActivity.onBackPressed%28%29">FragmentActivity的onBackPressed</a>:</p>

<pre><code class="java">public void onBackPressed() {
    if (!mFragments.popBackStackImmediate()) {
        supportFinishAfterTransition();
    }
}
</code></pre>

<p>从其源码中不难看出，响应BACK键时，一定会去pop fragment。前面提到过，<a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/android/support/v4/app/FragmentManager.java#FragmentManagerImpl.popBackStackImmediate%28%29">FragmentManager</a>在改变Fragment的状态前（增加，移除，改变生命周期状态都是改变状态）都会检查state loss：</p>

<pre><code class="java">@Override
public boolean popBackStackImmediate() {
    checkStateLoss();
    executePendingTransactions();
    return popBackStackState(mActivity.mHandler, null, -1, 0);
}
</code></pre>

<p>前面说了，checkStateLoss其实就是检查mStateSaved这个变量是否为true。那么都哪里给它设置为true了呢？对于正统的Activity和Fragment（android.app.*），是在<a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/android/support/v4/app/FragmentManager.java#FragmentManagerImpl.saveAllState%28%29">onSaveInstanceState</a>时，且只有这时才设置：</p>

<pre><code class="java">Parcelable saveAllState() {
    // Make sure all pending operations have now been executed to get
    // our state update-to-date.
    execPendingActions();

    mStateSaved = true;
    // other codes.
}
</code></pre>

<p>但是对于support包中的Fragment（android.support.v4.app.*）除了在onSaveInstanceState中设置以外，在<a href="http://grepcode.com/file/repository.grepcode.com/java/ext/com.google.android/android/5.1.1_r1/android/support/v4/app/FragmentManager.java#FragmentManagerImpl.dispatchStop%28%29">onStop</a>中也把mStateSaved置为true：</p>

<pre><code class="java">public void dispatchStop() {
    // See saveAllState() for the explanation of this.  We do this for
    // all platform versions, to keep our behavior more consistent between
    // them.
    mStateSaved = true;

    moveToState(Fragment.STOPPED, false);
}
</code></pre>

<p>所以，无论你用的是哪个Fragment，如果onBackPressed发生在onSavedInstanceState之后，那么就会上面的crash。
Stack Overflow上面有类似的讨论，比较全面和票数较高就是<a href="http://stackoverflow.com/questions/7469082/getting-exception-illegalstateexception-can-not-perform-this-action-after-onsa/10261438#10261438">这个</a>和<a href="http://stackoverflow.com/questions/7575921/illegalstateexception-can-not-perform-this-action-after-onsaveinstancestate-wit">这个</a>。</p>

<p>二个讨论中，针对此场景的获得最多赞同的解法是，覆写Activity的onSaveInstanceState，然后不要调用super：</p>

<pre><code class="java">@Override
public void onSaveInstanceState() {
    // DO NOT call super
}
</code></pre>

<p>从上面的分析来看，这个对于android.app.*中的Fragment是能解决问题的，因为是在Activity的onSaveInstanceState（super.onSaveInstanceState）中才把mStateSaved置为true，所以不调super，它就仍是false，当再pop时，也就不会抛出异常的。</p>

<p>但是这明显是一个拙劣的workaround，首先，你在防止系统保存fragment的状态，可能会引发一引起其他的问题；再有就是，对于support包，这还是不管用，你仍然能够遇到state loss exception，因为在其onStop时也会把mStateSaved置为true。</p>

<p>上面分析得出，问题产生的原因是onBackPressed发生在了onSavedInstance之后，那么的解法是，同样设置一个标志，如果状态已保存过，就不要再处理onBackPressed：</p>

<pre><code class="java">public class FragmentStateLossActivity extends Activity {
    private static final String TAG = "Fragment state loss";
    private boolean mStateSaved;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_fragment_state_loss);
        mStateSaved = false;
    }

    @Override
    protected void onSaveInstanceState(Bundle outState) {
        // Not call super won't help us, still get crash
        super.onSaveInstanceState(outState);
        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) {
            mStateSaved = true;
        }
    }

    @Override
    protected void onResume() {
        super.onResume();
        mStateSaved = false;
    }

    @Override
    protected void onPause() {
        super.onPause();
    }

    @Override
    protected void onStop() {
        super.onStop();
        mStateSaved = true;
    }

    @Override
    protected void onStart() {
        super.onStart();
        mStateSaved = false;
    }

    @Override
    protected void onDestroy() {
        super.onDestroy();
    }

    @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (!mStateSaved) {
            return super.onKeyDown(keyCode, event);
        } else {
            // State already saved, so ignore the event
            return true;
        }
    }

    @Override
    public void onBackPressed() {
        if (!mStateSaved) {
            super.onBackPressed();
        }
    }
}
</code></pre>

<p>为了更彻底的杜绝问题，应该是状态保存过后，都不应该处理KEY事件。</p>

<p>其实，这也是合理的，onBackPressed一般是由BACK触发的，与KEY事件一样，都属于用户交互事件，用户交互事件都应该在Activity处于活动期间来响应，特别是过了onStop以后，再处理这样的事件也是没有意义的。</p>

<p>通常情况下，是不会发生这样的问题的，因为一般情况下是由BACK键触发onBackPressed，onBackPressed中调用finish()，finish才会触发销毁生命周期（save instance，pause，stop，destroy），自然不会产生onBackPressed发生在它们之后，也就没有此异常。但假如，有人为处理BACK事件，或者涉及Webview的BACK处理时，就有可能异步处理BACK，从而产生这个异常。</p>

<p>其实，从根儿上来讲，这是Android的设计不完善导致的，再看下pop back的实现：</p>

<pre><code class="java">@Override
public boolean popBackStackImmediate() {
    checkStateLoss();
    executePendingTransactions();
    return popBackStackState(mActivity.mHandler, null, -1, 0);
}
</code></pre>

<p>难道第一句不应该是先判断此栈是否为空吗？如果为空（压根儿就没有用Fragment），为什么要check state loss，为什么还要去executePendingTransactions()? 但是，它又不得不这样做，因为Fragment的很多操作是异步的，到这个时候，有可能某些Fragment已被用户commit，但是还没有真正的添加到stack中去，因为只有把所有的pending transactions执行完了，才能知道到底有没有Fragment，但是执行pending transactions就会改变fragment的状态，就必须要check state loss。</p>

<p>看来万恶之源就是Fragment的transactions都是异步的。Anyway，Fragment的设计是有很多缺陷的，因为这并不是系统设计之初就考虑到的东西，所以，不可能像水果里的ViewController那样健壮好用。作为我们开发者，要么就干脆不用它，要么就把它研究透彻再使用，否则将会陷入无尽痛苦之中。</p>

<h2>参考资料</h2>

<ul>
<li><a href="http://www.androiddesignpatterns.com/2013/08/fragment-transaction-commit-state-loss.html">Fragment Transactions &amp; Activity State Loss</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解Android Gradle构建系统]]></title>
    <link href="http://toughcoder.net/blog/2016/11/15/understanding-android-gradle/"/>
    <updated>2016-11-15T22:27:59+08:00</updated>
    <id>http://toughcoder.net/blog/2016/11/15/understanding-android-gradle</id>
    <content type="html"><![CDATA[<p>Gradle是一个新型的强大的构建系统。Android很早就开始支持Gradle了，到现在已经完全切换到Gradle构建。它的优势也是比较明显的，更强大的配置，方便的依赖管理，简洁的语法（Groovy DSL），跟啰嗦的XML相对，这是很大的进步。</p>

<p><a href=""><img src="https://img.alicdn.com/imgextra/i1/715978679/TB2s0nGcygSXeFjy0FcXXahAXXa_!!715978679.jpg"></a></p>

<!-- more -->


<h3>基本概念</h3>

<p>为了方便讨论和理解，需要对一些概念进行定义：</p>

<ul>
<li>项目：可以理解为一个安卓应用。或者说一个可构建的所有配置，代码和资源的集合。</li>
<li>模块：最小的可构建单元
项目可以只有一个模块，或者说一个模块也可以作为一个项目。项目通常都由一个或者几个，甚至多个模块组成。每一个模块都要有相应的build.gradle来描述它是如何构建的。项目根目录下面也会有一个build.gradle，用于对应用于整个项目的配置，比如依赖库的repositories，Android Gradle Plugin的版本指定。</li>
</ul>


<h3>项目结构</h3>

<p>典型的项目结构是酱紫的：</p>

<pre><code>|-project
| |-app
| | |-build.gradle
| |-library1
| | |-build.gradle
| |-build.gradle
| |-settings.gradle
| |-gradle/wrapper/gradle-wrapper.properties
| |-local.properties
| |-gradle.properties
</code></pre>

<ul>
<li>gradle.properties 是用来配置gradle本身的运行的参数，比如是否并行，Gradle的JVM参数，因为Gradle也是基于JVM的。</li>
<li>local.properties是用于配置本机操作环境的安卓参数，这里就二个，一个是sdk.dir就是配置安卓SDK的本机路径；另一个就是ndk.dir是配置NDK的本机路径，当然，如果不需要在构建时编译JNI代码，是不用配置ndk.dir的</li>
<li>gradle/wrapper/gradle-wrapper.properties是用于配置Gradle本身的版本信息，比如使用哪个版本的Gradle</li>
<li>build.gradle是整个构建系统的核心文件，类似make的Makefile以及maven的pom.xml，里面描述如何构建一个目标（应用，或者库）。这个文件 是我们修改最多的</li>
<li>settings.gradle是项目结构的配置文件，它指定了项目中包含了哪些模块，比如上面这个例子，settings.gradle应该这样写：</li>
</ul>


<pre><code class="`"> include ':app', ':library1'
</code></pre>

<p> 当然，这是典型的项目结构，但是没有完全这样，因为Gradle的配置是相当灵活且强大的，也就是说真实的文件夹结构，跟Gradle中的项目结构是没有关系的，只不过默认的情况下（也即没有特别的指定和定制）模块的名字就是子目录的名字，项目的结构就按文件夹结构来确定的。</p>

<p> 但是可以不用这样，下面详细说</p>

<h3>配置非文件夹结构的项目</h3>

<p>意思就是每一个模块，不一定非在项目所在文件夹里，换句话说，你可以在项目中引用随便在哪里的模块，举个例子：</p>

<p>你的项目project是在，Documents/project/，想引用一个库是在Downloads/library/，不必非把library拷贝到project下面，只需要在project/settings.gradle中配置一下就可以了：</p>

<pre><code class="groovy">include ':app', ':library'

project(':library').projectDir = new File(settingsDir, '../../../Downloads/library')
</code></pre>

<p>这样就可能在项目project中引入了模块library。</p>

<h3>分清楚二个版本</h3>

<ul>
<li>gradle的版本，在./gradle/wrapper/gradle-wrapper.properties中通过distributionUrl来指定</li>
</ul>


<p> Gradle是一个构建系统，像make和cmake，ant和maven一样。安卓的项目里推荐使用gradle wrapper，实际上就是在项目中指定gradle的版本，这样有一个好处就是，这个项目换了操作系统环境，也不受影响。我们都知道软件的不同的版本对软件的使用是有影响的。所以如果像make或者cmake一样，使用操作系统环境中的gradle，那么同一个项目会因为不同的环境而带来一些诡异的配置相关的问题。</p>

<p> Gradle跟Android或者Google没有关系，它是由Gradle Inc.在开发和维护的。所以Gradle的升级要到<a href="http://www.gradle.org/">gradle.org</a>。</p>

<ul>
<li>Android Gradle Plugin的版本，通过buildScript DSL中的dependencies DSL来指定</li>
</ul>


<pre><code class="groovy">buildscript {
  repositories {
    mavenLocal()
    mavenCentral()
    jcenter()
  }
  dependencies {
    classpath 'com.android.tools.build:gradle:2.2.2'
  }
}
</code></pre>

<p> Gradle是一个构建系统，有它自身的规则，可以用来构建任何语言的任何项目。但每一个语言和平台都有自己的特性，如果直接使用Gradle也不是不可以，但是要做很多重复性的工作。Gradle是有插件机制的，也就是每个语言或者平台实现一些Gradle插件，以让开发者更加方便来构建，而不从头一条指令一条的写。Android Gradle Plugin就是专门用来构建安卓应用开发相关的插件。这个是由Google开发并维护，与SDK一起发布的。</p>

<h3>常见命令</h3>

<p>除了在Android Studio中直接操作以外，gradle是支持命令行的。而且命令行有时候会更方便。执行的方式是./gradlew <task-name>。gradlew实际上就是一个Shell脚本，它的作用是运行gradle/wrapper/中的Gradle二进制文件。task（任务）是Gradle构建中的可执行单元，与makefile中的target有些类似，可以理解为一个应用的构建，就是执行一些定义好的task。常见的task有：</p>

<ul>
<li>assemble - 构建项目的所有目标输出</li>
<li>assembleDebug - 只构建调试环境下的输出</li>
<li>assembRelease - 构建发布环境下的输出</li>
<li>uninstallDebug/uninstallRelease - 从设备上卸载调试的应用，或者卸载发布环境的应用</li>
<li>clean - 清理编译过程中产生的输出，包括最终输出。通常就是把build目录删除</li>
</ul>


<p>可以用gradle tasks来查看支持的所有任务。</p>

<h3>Dependency managament</h3>

<p>在每个模块的build.gradle中dependencies {} DSL中定义该模块的依赖树。</p>

<pre><code class="groovy">dependencies {
  // 本地lib的依赖
  compile fileTree(dir: 'libs', include: ['*.jar'])  

  // 对其他模块的依赖
  compile (project(':library'))

  // 从远程的repo中下载依赖
  compile "com.android.support:support-v4:23.1.0"
  compile 'com.android.support:appcompat-v7:23.0.0'
  compile 'com.squareup.picasso:picasso:2.5.2'
}
</code></pre>

<p>有几种不的指定编译方式：</p>

<ul>
<li>compile - 把所需要的依赖会编译进目标，类似于C++中的静态库的概念</li>
<li>provided - 只在编译时依赖一下，不会打于目标中，运行时环境应该提供相同的库，否则会找不到依赖，类似于动态库的概念</li>
<li>compileProvided</li>
</ul>


<h3>常见的tricks</h3>

<ul>
<li>gradle.org访问缓慢或者根本无法访问</li>
</ul>


<p> ./gradle/wrapper/gradle-wrapper.properties中的distributionUrl=https://services.gradle.org/distributions/gradle-2.14.1-all.zip，这个地址下载十分缓慢，或者根本无法下载，导致gradle sync花费很长时间，甚至卡死无法完成。改成国内的镜像会好很多distributionUrl=http://mirrors.taobao.net/mirror/gradle/gradle-2.14.1-all.zip</p>

<p> 如果没有可用的镜像网站，还有一个解决办法就是，去其他网站下载Gradle的二进制文件，然后解压放到~/.gradle/wrapper/dists/。（如果是windows的话，应该是在C:\Users\<username>.gradle\wrapper\dists）。</p>

<ul>
<li>transitive false</li>
</ul>


<pre><code class="groovy">dependencies {    
  compile ('com.squareup.picasso:picasso:2.5.2') {
    transitive false
  }
}
</code></pre>

<p> 依赖是一个树状结构，比如项目中依赖了rxlifecircle，但rxlifecircle本身也有依赖，解析依赖时，会把所有依赖以及依赖的依赖都下载下来，这就构成了依赖树，当然，也会涉及冲突的处理，比如二个库都依赖了另外一个库，但是不同的版本，这个Gradle本身是有策略的。</p>

<p> 可以用./gradlew -q dependencies &ndash;configuration compile命令来查看依赖树
* 指定依赖的具体类型@aar or @jar</p>

<pre><code class="groovy">dependencies {
  compile "com.android.support:support-v4:23.1.0"
  compile 'com.android.support:appcompat-v7:23.0.0'
  compile 'com.squareup.picasso:picasso:2.5.2@jar'
}
</code></pre>

<p> 默认情况，Gradle认为依赖库都是Java 的jar类型。也就说当其在repo中寻找依赖时会去找jar。所以，如果是aar的依赖库，就需要指定其具体类型，通过在版本号后面加上@aar或者@jar来指定其具体的类型。</p>

<ul>
<li>在Android Studio中没问题，但是运行命令行时，会报错误:</li>
</ul>


<blockquote><p>FAILURE: Build failed with an exception.</p>

<p>* What went wrong:
A problem occurred configuring root project &lsquo;pailitao-sdk&rsquo;.
Could not resolve all dependencies for configuration &lsquo;:classpath&rsquo;.</p>

<p>  > Could not find com.android.tools.build:gradle:2.2.2.</p>

<p>  Searched in the following locations:
     file:/Users/alexhilton/.m2/repository/com/android/tools/build/gradle/2.2.2/gradle-2.2.2.pom
     file:/Users/alexhilton/.m2/repository/com/android/tools/build/gradle/2.2.2/gradle-2.2.2.jar
     <a href="https://repo1.maven.org/maven2/com/android/tools/build/gradle/2.2.2/gradle-2.2.2.pom">https://repo1.maven.org/maven2/com/android/tools/build/gradle/2.2.2/gradle-2.2.2.pom</a>
     <a href="https://repo1.maven.org/maven2/com/android/tools/build/gradle/2.2.2/gradle-2.2.2.jar">https://repo1.maven.org/maven2/com/android/tools/build/gradle/2.2.2/gradle-2.2.2.jar</a>
  Required by:
     :pailitao-sdk:unspecified</p>

<p>* Try:</p>

<p>Run with &ndash;stacktrace option to get the stack trace. Run with &ndash;info or &ndash;debug option to get more log output.</p></blockquote>

<p> 这个问题的根本原因是Android Gradle Plugin没有找到。查看要目录的build.gradle，在repositories里面加上jcenter()，或者把mavenCenteral()改成jcenter()就可以解决了。</p>

<ul>
<li>如何直接构建子项目，比如project下面有app和library二个子项目：</li>
</ul>


<pre><code class="`"> |-project
 | |-app
 | |-library
</code></pre>

<p> 在根目录执行命令./gradlew assembleDebug或者assembleRelease，会构建整个应用。假如只想构建library呢？可以执行这样的命令：<strong>./gradlew :library:assembleRelease</strong>也即，前面是子项目，后面跟命令。</p>

<ul>
<li>Gradle refresh failed:
com.android.build.gradle.internal.model.defaultandroidproject   unsupported major.minor version 51.0</li>
</ul>


<p> 这个错误的原因是Android Studio运行的JVM版本太低了，看一下Android Studio的关于，里面会有JVM的版本信息，如果是1.6就会上面的错误。如果是Mac，到app/info.list里面把JVM的版本改成1.7+</p>

<ul>
<li>Gradle sync failed: &ldquo;java.lang.OutOfMemoryError: GC overhead limit exceeded&rdquo;</li>
</ul>


<p> 明显是Gradle运行时，内存爆了。解决方法就是加大它的内存配额。在相应的build.gradle中加入:</p>

<pre><code class="groovy">dexOptions {
  incremental true
  javaMaxHeapSize 4g
}
</code></pre>

<ul>
<li>Error:(2, 0) No service of type Factory available in ProjectScopeServices.</li>
</ul>


<p>查看根目录的build.gradle通常都指定有github的插件，把1.3升级到1.4.1就可以解决，参考<a href="http://www.jianshu.com/p/c4f4894ad215">这篇文章</a>。</p>

<ul>
<li>解决默认情况下只编译子模块的release模式</li>
</ul>


<p>默认情况下，当有compile project(&lsquo;:library&rsquo;)形式的依赖时，只会编译library的release模式，这对调试是非常不方便的，因为release模式通常会开启混淆，这时可以在子模块中加入默认的打包配置来强制默认打debug包：</p>

<pre><code class="groovy">android {
  defaultPublishConig 'debug'
}
</code></pre>

<h3>进阶之Gradle</h3>

<p>对于日常的开发，了解基本的就够用了，但若想做一些额外的事情，比如自定义一些task等就需要深入研究Gradle本身了。这个建议直接看Gradle的<a href="https://docs.gradle.org/current/userguide/userguide.html">文档</a>比较好。</p>

<h3>进阶之Groovy</h3>

<p>Gradle的文件是用Groovy语言来描述的，所以如果想要实现高级功能，也必须熟悉Groovy语言。同样还是要参考相应的文档。</p>

<h3>参考资料</h3>

<ul>
<li><a href="http://tools.android.com/tech-docs/new-build-system/user-guide">Gradle Plugin User Guide</a></li>
<li><a href="http://stackoverflow.com/questions/16976214/gradle-build-only-one-module">Gradle build only one module</a></li>
<li><a href="http://stackoverflow.com/questions/24309950/create-aar-file-in-android-studio">Create aar file in Android Studio</a></li>
<li><a href="https://guides.codepath.com/android/Building-your-own-Android-library">Building your own Android library</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[说说Android的MVP模式]]></title>
    <link href="http://toughcoder.net/blog/2015/11/29/understanding-android-mvp-pattern/"/>
    <updated>2015-11-29T15:53:46+08:00</updated>
    <id>http://toughcoder.net/blog/2015/11/29/understanding-android-mvp-pattern</id>
    <content type="html"><![CDATA[<p>安卓应用开发是一个看似容易，实则很难的一门苦活儿。上手容易，看几天Java，看看四大组件咋用，就能整出个不太难看的页面来。但是想要做好，却是很难。系统框架和系统组件封装了很多东西，开发者弄几个Activity，用LinearLayout把布局组合在一起，添加点事件监听，一个应用就成型了。红海竞争，不管多么复杂的UX和业务逻辑都是一个月快速上线，二周一个迭代，领导和产品早上改需求，晚上改设计，再加上产品经理和设计师都按照iOS来设计，这一系列原因导致很多安卓应用不但体验差，不稳定，性能低，而且内部代码相当之混乱，即使BAT也是如此。</p>

<p><a href=""><img src="https://img.alicdn.com/imgextra/i1/715978679/TB2VTfHmVXXXXajXFXXXXXXXXXX_!!715978679.jpg"></a></p>

<!-- more -->


<p>反观国外市场（谷歌应用市场）上面的大部分应用都还是比较好的，表现在符合安卓设计规范，性能和稳定上表现不俗，体验上更符合安卓系统，而且会发现他们的代码也是很有设计思想的。GitHub上面的很多安卓开源项目也都是源自国外的优秀开发者以及他们的项目。</p>

<p>安卓应用也是软件，代码结构合理，层次清晰不但容易维护而且还容易做自动化测试和单元测试，这是开发者的美好愿望，也是提升效率的必然之路。</p>

<p>安卓由于系统架构特性，UI组件Activity中融合了View的处理，事件处理和逻辑处理，随着业务的越来越复杂，导致Activity也越来越雍肿，几千行的Activity随处可见，Fragment也不能解决问题，千行以上的Fragment也不在少数，这个时候就完全不要谈什么可维护性，可测试性了。能完成需求就算高手了。</p>

<p>MVP便应运而生，就来解决这些问题的。</p>

<h2>什么是<a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter">MVP</a>模式</h2>

<p>MVP是针对有GUI存在的应用程序，比如像安卓，像水果以及PC的客户端软件中用以划分组织代码的一种设计模式，是由MVC模式升级演进出来的，目的在于，对于GUI层来说，把UI展示与逻辑分开。</p>

<ul>
<li>Model &ndash; 为UI层提供的数据，或者保存UI层传下来的数据</li>
<li>View &ndash; 单纯的展示数据，响应用户操作并都转发给Presenter来做具体的处理</li>
<li>Presenter &ndash; 逻辑控制层，从Model处取数据，运算和转化，最后用View来展示；并处理View传过来的用户事件，并做处理</li>
</ul>


<p><img class="<a" src="href="https://img.alicdn.com/imgextra/i4/715978679/TB2ZW_jiXXXXXciXpXXXXXXXXXX_!!715978679.png">https://img.alicdn.com/imgextra/i4/715978679/TB2ZW_jiXXXXXciXpXXXXXXXXXX_!!715978679.png</a>&#8221;></p>

<p>需要注意的是MVP仅用于应用中的GUI部分，它并不是整个应用的架构方式。一个应用的主要的架构应该包括基础组件，业务逻辑层和GUI展示层，而MVP仅是用于展示层的设计模式。另外，它是一个方法论的东西，没有固定的实现方式，只要能体现出它的方法就可以算是MVP。</p>

<p>虽然是方法论，但是也有一些指导性的原则来约束实现：</p>

<ul>
<li>Model与View不能直接通信，只能通过Presenter</li>
<li>Presenter类似于中间人的角色进行协调和调度</li>
<li>Model和View是接口，Presenter持有的是一个Model接口和一个View接口</li>
<li>Model和View都应该是被动的，一切都由Presenter来主导</li>
<li>Model应该把与业务逻辑层的交互封装掉，换句话说Presenter和View不应该知道业务逻辑层</li>
<li>View的逻辑应该尽可能的简单，不应该有状态。当事件发生时，调用Presenter来处理，并且不传参数，Presenter处理时再调用View的方法来获取。</li>
</ul>


<p>从这里可以看的出来，其实，MVP的目的就是把GUI的逻辑都集中在Presenter层，又把View层和Model与其用接口分离，让View尽可能的简单，这样可以加强移植性。因为View层是肯定不能移植的，不同的平台GUI的窗口部件肯定不一样，Model也是不太好移植的，因为每个平台的IO也都是不一样的。但是，MVP中的P肯定是可以移植的，因为它里面只有逻辑，且View和Model都是接口，所以很容易移植。同时，因为View和Model都是接口，这个Presenter也非常好测试，只要实现一个View的接口和Model的接口，就可以单独的测试Presenter了。</p>

<p>严格来讲，View只是被动的显示，提供方法由Presenter来调用，数据等都是由Presenter来提供，内部不能任何的逻辑与状态，逻辑和状态都应该是在Presenter中。UI事件发生时，调用Presenter的方法来处理，不能传参数，也不能有返回值，在Presenter中处理后再调用View来更新数据和状态。</p>

<h2>MVP与<a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">MVC</a>的区别</h2>

<p>MVC之中逻辑是放在了Model里，Controller负责桥接View和Model，View发生变化时通知Controller，Controller再通知Model，Model进行逻辑处理，更新数据，然后通知View来刷新。可以看到MVC中三者之间都有联系，如果处理不好，或者当View比较复杂时，三者之间都会双向关联。MVC在命令行应用，以及WEB中有大量的应用，但对于客户端（PC和移动端）的GUI应用，MVC往往解决不了复杂性，移植性上以及可测试性上也没有优势。</p>

<p><img class="<a" src="href="https://img.alicdn.com/imgextra/i2/715978679/TB2fYnMiXXXXXa3XXXXXXXXXXXX_!!715978679.png">https://img.alicdn.com/imgextra/i2/715978679/TB2fYnMiXXXXXa3XXXXXXXXXXXX_!!715978679.png</a>&#8221;></p>

<p>MVP的改进在于：</p>

<ul>
<li>逻辑放在Presenter中</li>
<li>View和Model抽象成为接口</li>
</ul>


<p>这样就带了二个好处：</p>

<ul>
<li>代码更加容易移植</li>
<li>代码更加容易加入Unit Testing</li>
</ul>


<h2>如何在安卓中实践MVP</h2>

<p>MVP是一个方法论的东西，也就是没有任何固定的具体的实现形式，只要能够把View跟Model解除联系，把逻辑都放在Presenter中，那么就能算得上是MVP，一些具体的实践的指导性原则：</p>

<ul>
<li>View是一个接口，负责被动的把处理好的数据显示出来</li>
<li>Model也是一个接口，负责获取数据和存储数据</li>
<li>View调用Presenter处理用户事件也是一个接口，称为事件Delegate</li>
<li>Presenter持有的是View的接口和Model接口</li>
</ul>


<p> 安卓的Activity是一个比较奇葩的角色，在MVP中，既可以用作V，因为一个应用的根布局总是由Activity来创建的。当然也可以当作P，因为Activity是一个应用的入口，也是出口，再加上一些关键的系统事件也都是通过Activity的方法来通知的（比如configChange, saveInstance）。其实，都可以。因为MVP是方法论，并没有固定的形式，只要是把数据处理的逻辑都封装在Presenter里，让其去控制View和Model，让Activity来承担View还是Presenter，其实都可以。</p>

<h2>MVP不是银弹，仅是展示层的一种范式而已</h2>

<p>最重要的一点就是要明白，MVP不会拯救你的应用，不要以为使用了MVP就能让代码更容易维护，更少的Bug，添加新功能会更容易。MVP仅是GUI层的一种编程范式而已，且因为它是方法论的东西，对实现方式并没有固定的形式，所以会被滥用，如果没有深刻理解MVP的思想，更加会导致灾难性的结果。</p>

<p>软件，移动应用也不例外，如果功能简单，业务简单，那么代码怎么写其实也都无大碍，但当功能越来越多，业务越来越复杂的时候，就必须要采取必要的方法来应对复杂度和软件的可开发性，可维护性。比如，说的夸张一点，一个helloworld式的应用，你怎么写都可以。但当功能复杂到一个Activity几千行代码的时候，你再怎么MVP，MVC或者MVVM都不能解决问题，再怎么把Activity当成P或者当成V都没有用。</p>

<p>要知道MVP仅是解决GUI应用程序中展示层的问题，并且它带来的最大的好处是方便测试和移植，因为逻辑都在P里面，P持有的又仅是View和Model的接口，所以P是可测试的，Mock一个View的实现，和Mock一个Model的实现，就可以完全脱离平台和框架的限制来自由的测试P。同样，移到一个新的框架和平台后，只需要实现View和Model就可以了，P是不需要改变的。</p>

<h2>分层和模块化才是解决应用越来越复杂之道</h2>

<h3>分层</h3>

<p>所谓分层，也就是应用程序的架构方法，把应用程序分成好多层，可以参考Bob大叔的<a href="http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html">The Clean Architecture</a>。</p>

<p><img class="<a" src="href="https://img.alicdn.com/imgextra/i1/715978679/TB2usPAiXXXXXXsXpXXXXXXXXXX_!!715978679.png">https://img.alicdn.com/imgextra/i1/715978679/TB2usPAiXXXXXXsXpXXXXXXXXXX_!!715978679.png</a>&#8221;></p>

<p>至少应该分层三层，最底层是平台适配层，把用到的平台的组件，控件，工具，比如UI组件，数据库等等，进行封装；中间层就是业务层，就是你应用的核心的业务逻辑，或者说你的应用解决了用户什么样子的问题，这一层是不会随着平台和UI的改变而改变的。比如新闻阅读类，那么从服务器拉取数据，解析数据，缓存数据，为上层提供数据这些事情都属于业务层；最上面就是展示层或者叫做UI层。展示层是可以调用业务层的方法和数据。这样分层，可以让展示层只是负责与用户交互，展示业务数据，展示层会变得简单很多，同时业务层因为不涉及具体的平台和UI的细节，就非常容易移植，当移植到新平台或者要做UI改版也是非常容易做的。</p>

<h3>模块化</h3>

<p>另外一个就是模块化，其实这是软件开发的一个非常基本的方法，也是非常有用的一个方法。模块划分的方法非常简单就是按照功能来划分。让模块处理好自己的事情，暴露统一的接口给外部，定义好输入与输出。输入就以参数和方法形式暴露，输出最好以Delegate方式，这样能把耦合降到最低。再由一个统一的顶层类来管理各个模块，顶层直接调用各模块，各模块通过Delegate方式来回调管理者。</p>

<p>对于业务层，模块化相对比较容易，因为这里并不涉及UI和平台的特性，业务层都应该是独立的，可移植的，全都是自己写的类。</p>

<p>但对于展示层，通常没有那么的容易，因为有平台的限制。比如说安卓，根布局必须由Activity来创建。首先，模块的划分也要以功能为界限。然后，就是Activity的布局，要把布局按功能区域来管理，然后把每个功能模块的top container传给模块，具体内部如何布局，如何填充数据，就由模块自己负责。Activity就起管理各个模块的作用。再有，模块间的通信，可以都通过Activity来，比如模块1有模块2的入口按扭，但是模块1与模块2之间没有交集，这个时候的处理方式就是模块1Delegate给Activity，然后Activity再调用模块2来显示和隐藏。如果模块多到Activity的管理工作也变得庞大复杂时就要拆出子Controller来管理模块，也就是三层，甚至还可以四层。模块的原则就是做好封装，让外层管理变得简单，这样外层管理的复杂度就会降下来，就好比公司人员的组织架构一样。</p>

<p><img class="<a" src="href="https://img.alicdn.com/imgextra/i3/715978679/TB2fZ2siXXXXXadXpXXXXXXXXXX_!!715978679.png">https://img.alicdn.com/imgextra/i3/715978679/TB2fZ2siXXXXXadXpXXXXXXXXXX_!!715978679.png</a>&#8221;></p>

<p><img class="<a" src="href="https://img.alicdn.com/imgextra/i3/715978679/TB2KuvqiXXXXXaPXpXXXXXXXXXX_!!715978679.png">https://img.alicdn.com/imgextra/i3/715978679/TB2KuvqiXXXXXaPXpXXXXXXXXXX_!!715978679.png</a>&#8221;></p>

<pre><code class="xml">&lt;LinearLayout&gt;
  &lt;LinearLayout id="module1" /&gt;
  &lt;RelativeLayout id="module2" /&gt;
  &lt;ListView id="module3" /&gt;
&lt;/LinearLayout&gt;
</code></pre>

<pre><code class="java">public class DemoActivity extends Activity implements Module1Delegate, Module2Delegate {
  @Override
  public void onCreate(Bundle bundle) {
    setContentView(R.layout.demo_activity);
    Module1 module1 = new Module1(findViewById(R.id.module1), this);
    Module2 module2 = new Module2(findViewById(R.id.module2), this);
    Module3 module3 = new Module3(findViewById(R.id.module3));
    module1.render();
    module2.render();
  }

  @Override
  public void onModule1() {
    Log.e("Demo", "module1 say hello to the world.");
  }

  @Override
  public void onModule2(boolean show) {
    if (show) {
      module3.show();
    } else {
      module3.hide();
    }
  }
</code></pre>

<p>其实，还可以做的更彻底一些，那就是Activity中的布局都由ViewStub来组装，然后由各个子模块来决定如何布局。</p>

<p>对于多层全屏层叠的应用来说，要简单一些，对于每一层都可以由Activity或者Fragment来实现，如果业务层已经抽离出来，就都可以直接调用业务层来获取数据，因此也不会有传递数据的麻烦。</p>

<p>做好了分层和模块化，我相信，能解决绝大多数应用遇到的问题。至于模块内部用什么MVP，MVC，MVVM，其实真的无大害，因为模块内部的实现方式不影响其他模块，也不影响外部管理和level更高的类。</p>

<h2>把基本的原则做到就够了</h2>

<p>编程是一项社会活动，所以人和人与人之间的关系才是核心，优秀的人，你发现他也没有用什么MVP，什么MVC，什么高大上的设计模式和算法，但是他的代码是很清晰，很容易看懂。有些即使号称用什么高大上的，最先进的设计模式，但是代码仍是一坨坨的，可能连他自己都看不懂。</p>

<p>把基本的抽象和封装真正做到位了，就够了，代码水平可以的话，再能做到命名见名知义，小而活的方法，小而活的类，一个方法只做一件事，一个类只做一件事情。做到这些，也就够了。</p>

<p>至于什么高大上的MVP，什么XP，什么TDD，什么结对，其实都是浮云，如果你的水平比较高，代码sense较高，那么用不用这些方法差别不大。</p>

<p>MVP的核心目的是方便UT，因为把展示层的逻辑都集中在P，而P又不依赖于具体的View和Model，所以可以随便Mock一个View和一个Model来测试P，甚至P可以独立于平台的限制来单独的测试。所以，如果你不搞UT，以不以MVP方式来实现，其实没啥影响，甚至网上不少人还专门为MVP而弄出几个抽象的类，把Activity啥的封装了一下，号称<a href="http://blog.csdn.net/qibin0506/article/details/49992897">MVP框架</a>，毫无实用价值。软件方法，切忌生搬硬套，一定要先理解透彻方法，再理解透彻你的问题和环境限制，然后灵活运动，什么叫理解透彻呢？就是你能给别人讲明白时。这说起来还是太抽象，只能在实际运用中慢慢领悟。</p>

<p>再有就是<a href="https://en.wikipedia.org/wiki/Unit_testing">Unit Testing</a>这玩意儿，实际的意义也没有那么大，要知道写测试代码通常要比生产代码花更多的精力，前提还是你的代码写的可测，可测性比可读性还要难一点，说白了这对开发者水平的要求相当的高，不是看了一遍书，学习一下JUnit就能搞得好的。还有就是如果你的需求经常变动，移动互联时代这是家常便饭，那么做UT会让开发量double甚至tripple，因为之前写的UT全没有用。</p>

<p>还想说一点就是，软件开发方法这东西必须是由上向下推动，也就是由老板带头来推动，否则技术小组长或者开发者自己是很难推得动的。特别是像UT，Code Review或者结对之类的会“降低开发效率”的方法。这些方法短期内不会提升效率和质量，只会降低需求的产出率，平均开发水平比较高的团队也至少要几个月后才能真正的适应这些方法，然后才有可能提高效率和提高质量。如果不是老板主动推动，谁能受得了呢？KPI咋整？</p>

<h2>结论</h2>

<p>MVP或者MVVM带来最大的好处是：</p>

<ul>
<li>方便移植</li>
<li>方便UT</li>
</ul>


<p>另外，要注意MVP仅是展示层的方法论。应用整体还是要进行分层和模块化。如果分层和模块化进行的彻底，并且在移植和UT没有强烈的需求，其实MVP与不P真的不重要。</p>

<h2>参考资源</h2>

<ul>
<li><a href="http://rocko.xyz/2015/02/06/Android%E4%B8%AD%E7%9A%84MVP/">Android中的MVP</a></li>
<li><a href="http://blog.csdn.net/vector_yi/article/details/24719873">MVP模式在Android开发中的应用</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android技巧：学习使用GridLayout]]></title>
    <link href="http://toughcoder.net/blog/2015/11/25/android-tricks-introduct-to-gridlayout/"/>
    <updated>2015-11-25T19:12:19+08:00</updated>
    <id>http://toughcoder.net/blog/2015/11/25/android-tricks-introduct-to-gridlayout</id>
    <content type="html"><![CDATA[<p><a href="http://developer.android.com/intl/zh-cn/reference/android/widget/GridLayout.html">GridLayout</a>是一个非常强大的网格类布局，它不但能像<a href="http://developer.android.com/intl/zh-cn/reference/android/widget/TableLayout.html">TableLayout</a>那样，实现网格类布局，但它更为强大的地方在于每个Cell的大小可以横向或者纵向拉伸，每个Cell的对齐方式也有很多种，而且不像TableLayout，需要一个<a href="http://developer.android.com/intl/zh-cn/reference/android/widget/TableRow.html">TableRow</a>，GridLayout可以通过指定Cell的坐标位置就能实现Cell的拉伸，从而实现，大小不一致的风格卡片式布局。</p>

<p><a href=""><img src="https://img.alicdn.com/imgextra/i1/715978679/TB21iP.mVXXXXc3XXXXXXXXXXXX_!!715978679.png" width="320" height="240"></a></p>

<!-- more -->


<h2>基本概念</h2>

<p>GridLayout把页面分成m行和n列，使用m+1条线和n+1条线，把页面共分成n*m个Cell。指定位置时行坐标是从0到m，列坐标是从0到n。每一个子View占一个或多个Cell。比如(0, 0)到(0, 1)就是占第一个Cell的区域。(0, 0), (0, 2)就是占第一行的2个Cell的区域(横向拉伸).</p>

<h2>使用方法</h2>

<p>主要介绍一下如何添加Cell，以及设置Cell的位置和拉伸。其他的跟普通的ViewGroup没什么区别的，也没啥好说的。</p>

<h3>GridLayout的基本设置</h3>

<p>首先需要给GridLayout设置行数和列数:</p>

<ul>
<li>android:columnCount 整数，最多的列数</li>
<li>android:rowCount 整数，最多的行数</li>
</ul>


<p>在添加Cell就需要注意，不能超过设置的最大行数和列数，否则在添加Cell时会有异常。</p>

<h3>元素Cell的位置控制</h3>

<p>添加Cell时需要指定其位置</p>

<ul>
<li>android:layout_column 整数n，在哪一列开始显示n=[0, 最大列-1]</li>
<li>android:layout_columnSpan 整数k，指定元素横跨几列，需要注意保证n+k &lt;= 最大列数</li>
<li>android:layout_row 指定从哪一行开始显示，规则同列数</li>
<li>android:layout_rowSpan 纵向跨几行，规则同列</li>
</ul>


<h3>行高和列宽的确定</h3>

<p>每一行的高度是由这一行中Cell的最大高度决定的，以及每一列的宽度是由每一列中最大的宽度决定的，小于行高和列宽的元素可以设置其对齐方式和填充方式。</p>

<h3>填充方式</h3>

<p>通过Cell的android:layout_gravity参数来指定，Cell的填充方式，注意仅当Cell元素本身的尺寸小于它所占格子的大小时才有效，比如元素本身尺寸小于行高和列宽，或者当它占多行，或者占多列时：</p>

<ul>
<li>center &ndash; 不改变元素的大小，仅居中</li>
<li>center_horizontal &ndash; 不改变大小，水平居中</li>
<li>center_vertical &ndash; 不改变大小，垂直居中</li>
<li>top &ndash; 不改变大小，置于顶部</li>
<li>left &ndash; 不改变大小，置于左边</li>
<li>bottom  &ndash; 不改变大小，置于底部</li>
<li>right  &ndash; 不改变大小，置于右边</li>
<li>start  &ndash; 不改变大小，置于开头（这个是与RTL从右向左读的文字有关的，如果使用start/end，那么当LTR文字时start=left,end=right，当RTL时start=right,end=left，也就是说系统会自动处理了)</li>
<li>end  &ndash; 不改变大小，置于结尾</li>
<li>fill &ndash; 拉伸元素控件，填满其应该所占的格子</li>
<li>fill_vertical &ndash; 仅垂直方向上拉伸填充</li>
<li>fill_horizontal &ndash; 仅水平方向上拉伸填充</li>
<li>clip_vertical &ndash; 垂直方向上裁剪元素，仅当元素大小超过格子的空间时</li>
<li>clip_horizontal &ndash; 水平方向上裁剪元素，仅当元素大小超过格子的空间时</li>
</ul>


<p>需要注意的是这些值是可以组合的，比如：</p>

<pre><code class="xml">android:layout_gravity="center_vertical|clip_horizontal"
</code></pre>

<h2>Cell之间的间距如何控制</h2>

<h3>默认间距</h3>

<p>可以使用默认的间距android:useDefaultMargins=&ldquo;true&#8221;或者GridLayout#setUseDefaultMargins()。这个属性默认值是&#8221;false&#8221;。</p>

<h3>另外一种方式就是跟普通布局管理器一样，给每个Cell设置其margins</h3>

<p>通常如果不满意系统的默认间距，就可以设置useDefaultMargins=&ldquo;false&#8221;，然后通过给Cell设置margin来控制间距。</p>

<h2>居中方法</h2>

<ul>
<li><p>仅有一个Cell或者仅有一行，或者仅有一列时</p>

<p>当仅有一个子View时或者仅有一行或者一列的时候，可以把每个Cell设置其android:layout_gravitiy=&ldquo;center&rdquo;(相应代码为<a href="http://developer.android.com/intl/zh-cn/reference/android/view/Gravity.html">LayoutParams#Gravity</a>为<a href="http://developer.android.com/intl/zh-cn/reference/android/view/Gravity.html#CENTER">CENTER</a>)，就可以让其在GridLayout中居中。</p></li>
</ul>


<p>让一行居中：</p>

<p><img class="<a" src="href="https://img.alicdn.com/imgextra/i3/715978679/TB2e.2djVXXXXcNXXXXXXXXXXXX_!!715978679.png">https://img.alicdn.com/imgextra/i3/715978679/TB2e.2djVXXXXcNXXXXXXXXXXXX_!!715978679.png</a>&#8221;></p>

<pre><code class="xml">    &lt;GridLayout
        android:layout_width="wrap_content"
        android:layout_height="200dip"
        android:useDefaultMargins="true"
        android:background="@android:color/white"
        android:rowCount="1"
        android:columnCount="2"&gt;
        &lt;Button android:layout_column="0"
            android:layout_row="0"
            android:text="Left Button"
            android:layout_gravity="fill_horizontal|center_vertical"/&gt;
        &lt;Button android:layout_column="1"
            android:layout_row="0"
            android:text="Right Button"
            android:layout_gravity="fill_horizontal|center_vertical"/&gt;
    &lt;/GridLayout&gt;
</code></pre>

<pre><code>让一个元素居中：
</code></pre>

<p>   <img class="<a" src="href="https://img.alicdn.com/imgextra/i1/715978679/TB25SeTjVXXXXXbXFXXXXXXXXXX_!!715978679.png">https://img.alicdn.com/imgextra/i1/715978679/TB25SeTjVXXXXXbXFXXXXXXXXXX_!!715978679.png</a>&#8221;></p>

<pre><code class="xml">    &lt;GridLayout
        android:layout_width="200dip"
        android:layout_height="200dip"
        android:useDefaultMargins="true"
        android:background="@android:color/white"
        android:rowCount="1"
        android:columnCount="1"&gt;
        &lt;Button android:layout_column="0"
            android:layout_row="0"
            android:text="Left Button"
            android:layout_gravity="center"/&gt;
    &lt;/GridLayout&gt;
</code></pre>

<ul>
<li><p>其他情况</p>

<p> 其他情况，设置子View的Gravity就不再起作用了，这时最好的办法就是让GridLayout的高度是WRAP_CONTENT，然后让GridLayout在其父布局中居中。</p></li>
</ul>


<p><img class="<a" src="href="https://img.alicdn.com/imgextra/i1/715978679/TB2EivsjVXXXXXGXXXXXXXXXXXX_!!715978679.png">https://img.alicdn.com/imgextra/i1/715978679/TB2EivsjVXXXXXGXXXXXXXXXXXX_!!715978679.png</a>&#8221;></p>

<pre><code class="xml">     &lt;LinearLayout
        android:layout_width="match_parent"
        android:orientation="vertical"
        android:gravity="center"
        android:background="@android:color/darker_gray"
        android:layout_height="200dip"&gt;
        &lt;GridLayout
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:useDefaultMargins="true"
            android:background="@android:color/white"
            android:rowCount="2"
            android:columnCount="2"&gt;
            &lt;Button android:layout_column="0"
                android:layout_row="0"
                android:text="Left Button"
                android:layout_gravity="fill_horizontal|center_vertical"/&gt;
            &lt;Button android:layout_column="1"
                android:layout_row="0"
                android:text="Right Button"
                android:layout_gravity="fill_horizontal|center_vertical"/&gt;
            &lt;Button android:layout_column="1"
                android:layout_row="1"
                android:text="Right Button 2"
                android:layout_gravity="fill_horizontal|center_vertical"/&gt;
        &lt;/GridLayout&gt;
    &lt;/LinearLayout&gt;
</code></pre>

<h2>适用场景</h2>

<p>GridLayout虽然强大，可以当作LinearLayout使用，也可以当作RelativeLayout使用，甚至也能当FrameLayout使用。但是，我们不可以滥用，对于任意布局都一样，不能是它能实现需求就使用它，而是要根据实际的需求，选择最简单，最方便的，同时也要考虑性能。</p>

<p>通常对于类似于网格的布局就可以考虑用GridLayout来实现，或者用LinearLayout横七竖八的套了好几层时也要考虑使用GridLayout。</p>

<h2>GridLayout vs GridView or RecyclerView</h2>

<p>当要实现网格布局，或者非均匀风格布局时，可能首先想到的就是GridView，但是这也要看实际的情况而定。GridView，ListView以及RecyclerView是用于无限长度列表或者网格的场景，它们最大的特点是无限长度，因此这几个组件的重点在于如何复用Cell以提升性能，以及处理手势事件（Fling）等。所以，每当遇到列表或者网格的时候，先想一下这个长度大概会是多少，如果是在百个以内，且不会随时增长，这时就可以考虑使用静态（非动态复用）的组件比如LinearLayout或者GridLayout来实现。</p>

<h2>实例</h2>

<p>说的太多都是废话，来一个实例感觉一下子是最直接的：</p>

<p><img class="<a" src="href="https://img.alicdn.com/imgextra/i4/715978679/TB2Or2jjVXXXXb9XXXXXXXXXXXX_!!715978679.png">https://img.alicdn.com/imgextra/i4/715978679/TB2Or2jjVXXXXb9XXXXXXXXXXXX_!!715978679.png</a>&#8221;></p>

<pre><code class="xml">&lt;GridLayout
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_centerInParent="true"
            android:background="@android:color/white"
            android:alignmentMode="alignMargins"
            android:useDefaultMargins="true"
            android:columnCount="4"
            android:rowCount="5"
            android:visibility="visible"&gt;
            &lt;Button android:layout_column="0"
                android:layout_row="0"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:padding="10dip"
                android:text="1"/&gt;
            &lt;Button android:layout_column="1"
                android:layout_row="0"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:padding="10dip"
                android:text="2"/&gt;
            &lt;Button android:layout_column="2"
                android:layout_row="0"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:padding="10dip"
                android:text="3"/&gt;
            &lt;Button android:layout_column="0"
                android:layout_row="1"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:padding="10dip"
                android:text="4"/&gt;
            &lt;Button android:layout_column="1"
                android:layout_row="1"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:padding="10dip"
                android:text="5"/&gt;
            &lt;Button android:layout_column="2"
                android:layout_row="1"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:padding="10dip"
                android:text="6"/&gt;
            &lt;Button android:layout_column="0"
                android:layout_row="2"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:padding="10dip"
                android:text="7"/&gt;
            &lt;Button android:layout_column="1"
                android:layout_row="2"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:padding="10dip"
                android:text="8"/&gt;
            &lt;Button android:layout_column="2"
                android:layout_row="2"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:padding="10dip"
                android:text="9"/&gt;
            &lt;Button android:layout_column="0"
                android:layout_row="3"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:padding="10dip"
                android:text="0"/&gt;
            &lt;Button android:layout_column="1"
                android:layout_row="3"
                android:layout_gravity="fill_horizontal"
                android:layout_columnSpan="2"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:padding="10dip"
                android:text="Delete"/&gt;
            &lt;Button android:layout_column="0"
                android:layout_row="4"
                android:layout_columnSpan="2"
                android:layout_gravity="fill_horizontal"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:padding="10dip"
                android:text="Clear"/&gt;
            &lt;Button android:layout_column="2"
                android:layout_row="4"
                android:layout_columnSpan="2"
                android:layout_gravity="fill_horizontal"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:padding="10dip"
                android:text="="/&gt;
            &lt;Button android:layout_column="3"
                android:layout_row="0"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_gravity="fill"
                android:padding="10dip"
                android:text="+"/&gt;
            &lt;Button android:layout_column="3"
                android:layout_row="1"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_gravity="fill"
                android:padding="10dip"
                android:text="-"/&gt;
            &lt;Button android:layout_column="3"
                android:layout_row="2"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_gravity="fill"
                android:padding="10dip"
                android:text="*"/&gt;
            &lt;Button android:layout_column="3"
                android:layout_row="3"
                android:layout_columnSpan="1"
                android:layout_gravity="fill"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:padding="10dip"
                android:text="/"/&gt;
        &lt;/GridLayout&gt;
</code></pre>

<h2>参考资料</h2>

<ul>
<li><a href="http://www.cnblogs.com/skywang12345/p/3154150.html">Android 布局之GridLayout</a></li>
<li><a href="http://android-developers.blogspot.com/2011/11/new-layout-widgets-space-and-gridlayout.html">New Layout Widgets: Space and GridLayout</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[安卓开发技术：监听软键盘的显示与隐藏]]></title>
    <link href="http://toughcoder.net/blog/2015/10/09/android-trick-detect-soft-keyboard-show-slash-hide/"/>
    <updated>2015-10-09T22:08:08+08:00</updated>
    <id>http://toughcoder.net/blog/2015/10/09/android-trick-detect-soft-keyboard-show-slash-hide</id>
    <content type="html"><![CDATA[<p>自从2007年乔帮主横空出世推出iPhone后，智能手机就都变成了触摸屏，且屏幕越来越大。输入自然也就通过软件来解决，现在来说绝大多数智能设备都是通过软键盘来做用户输入。在日常的开发过程中难免会跟软键盘打交道，比如强制显示或者强制隐藏等，也有些时候想要在键盘隐藏或者显示的时候做一点事情，这就需要准确的知道键盘的事件，这篇文章就来详细讨论一下Android下面如何做到监听键盘的事件。</p>

<p><a href=""><img src="https://img.alicdn.com/imgextra/i1/715978679/TB2DVP1mVXXXXa5XpXXXXXXXXXX_!!715978679.jpg"></a></p>

<!-- more -->


<h2>硬键盘显示隐藏的事件监听</h2>

<p>对于有硬键盘的设备，是会产生运行时的配置变更(<a href="http://developer.android.com/guide/topics/resources/runtime-changes.html#HandlingTheChange">Runtime Config Changes</a>)，因此可以通过<a href="http://developer.android.com/reference/android/app/Activity.html#onConfigurationChanged(android.content.res.Configuration">Activity#onConfigurationChanged</a>)回调来处理：</p>

<p>首先，要在AndroidManifest中给activity加上<a href="http://developer.android.com/guide/topics/manifest/activity-element.html#config">configChanges=&ldquo;keyboardHidden&rdquo;</a>。</p>

<p>然后，在代码中，处理：</p>

<pre><code class="java">@Override
public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);

    // Checks whether a hardware keyboard is available
    if (newConfig.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_NO) {
        Toast.makeText(this, "keyboard visible", Toast.LENGTH_SHORT).show();
    } else if (newConfig.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES) {
        Toast.makeText(this, "keyboard hidden", Toast.LENGTH_SHORT).show();
    }
}
</code></pre>

<p>需要注意的是，要用<a href="http://developer.android.com/reference/android/content/res/Configuration.html#hardKeyboardHidden">Configuration#hardKeyboardHidden</a>而不是<a href="http://developer.android.com/reference/android/content/res/Configuration.html#keyboardHidden">Configuration#keyboardHidden</a>，因为只有当硬键盘状态变化时才会回调onConfigurationChanged。</p>

<h2>软键盘显示隐藏事件监听</h2>

<p>现在的Android设备很少才会有硬键盘，绝大多数都是软键盘，而SDK和API中却没有软键盘隐藏变化的相关事件，没有直接支持不代表做不到。我们通过其他的方式还是可以做到监听软键盘显示与隐藏状态变化的。</p>

<h3>override onKeyPreIme</h3>

<p>当<a href="http://developer.android.com/reference/android/widget/EditText.html">EditText</a>获得焦点时，或者用户点击时，都会把软键盘弹起来（2.x版本长按MENU也可以强制弹出软键盘）。但是，隐藏软键盘一般都是BACK键，或者键盘自身提供隐藏的按扭，再有就是用代码强制隐藏。对于BACK键还是可以处理的，因为这属于事件(<a href="http://developer.android.com/reference/android/view/KeyEvent.html">KeyEvent</a>)，是能监听到的。</p>

<h4>核心原理</h4>

<p>子例化EditText，并覆写方法<a href="http://developer.android.com/reference/android/widget/TextView.html#onKeyPreIme(int,%20android.view.KeyEvent">onKeyPreIme</a>)。这个方法能在输入法前面拦掉事件，从而可以做一些事情：</p>

<pre><code class="java">public class KeyPreImeEditText extends EditText {
    public KeyPreImeEditText(Context context) {
        super(context);
    }

    public KeyPreImeEditText(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public KeyPreImeEditText(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    @Override
    public boolean onKeyPreIme(int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK) {
            Log.e("keyboard", "onKeyPreIme we got back");
        }
        return super.onKeyPreIme(keyCode, event);
    }
}
</code></pre>

<h4>优点</h4>

<p>简单粗暴，都是SDK支持的方法和事件，所以不会有兼容性等蛋疼的问题。</p>

<h4>缺点</h4>

<p>这仅在输入法前拦截到BACK事件，而前面提到BACK仅是能让软键盘隐藏掉的一个方式而已，所以这个方法是不能够完全做到监听软键盘隐藏状态变化的。这个方法仅适用于想拦截BACK，做一些其他事情的场景。</p>

<h3>override根布局的onMeasure</h3>

<p>另外的思路就是观察软键盘引起的布局变化，比如软键盘弹起时Activity的整体布局都会发生变化。</p>

<h4>核心原理</h4>

<p>子例化Activity的根布局（比如<a href="http://developer.android.com/reference/android/widget/LinearLayout.html">LinearLayout</a>或者<a href="http://developer.android.com/reference/android/widget/RelativeLayout.html">RelativeLayout</a>，然后覆写其<a href="http://developer.android.com/reference/android/view/View.html#onMeasure(int,%20int">onMeasure</a>)方法，在其中判断View的当前高度与其本应有的高度，如果当前高度小于本应有的高度，则表明软键盘在：</p>

<pre><code class="java">public class KeyboardAwareLinearLayout extends LinearLayout {
    public KeyboardAwareLinearLayout(Context context) {
        super(context);
    }

    public KeyboardAwareLinearLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public KeyboardAwareLinearLayout(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        final int proposedHeight = MeasureSpec.getSize(heightMeasureSpec);
        final int actualHeight = getHeight();

        if (actualHeight &gt; proposedHeight) {
            Log.e("keyboard", "guess keyboard is shown");
        } else {
            Log.e("keyboard", "guess keyboard has been hidden");
        }
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    }
}
</code></pre>

<h4>优点</h4>

<p>能够真正实现对软键盘隐藏和显示的监听，也不算复杂。</p>

<h4>缺点</h4>

<p>这个基于的原理是键盘对Activity的布局产生影响的情况，而这又受到其他条件控制。activity的属性<a href="http://developer.android.com/guide/topics/manifest/activity-element.html#wsoft">windowSoftInputMode</a>控制着软键盘与布局之间的影响关系，对于adjustPan以及全屏模式的adjustResize这种方法就失效了，因为这二种情况软键盘弹起时，布局是不会发生变化的，二种height值是一样的，自然无法分辨。</p>

<h3>监听GlobalLayout</h3>

<p>与上面的思路差不多，只不是监听GlobalLayout变化，然后根据布局高度与屏幕高度之差来判断。</p>

<p><strong>注意</strong>：要记得把注册的GlobalLayoutListener再反注册掉。</p>

<h4>计算根布局的高度差</h4>

<p>判断的依据是根布局与DectorView之间的差值，在正常情况下应该等于status bar高度与action bar高度之和。当软键盘弹起时则会大于此值。</p>

<h5>核心原理</h5>

<pre><code class="java">private boolean mKeyboardUp;

private void setListenerToRootView() {
        final View rootView = getWindow().getDecorView().findViewById(android.R.id.content);
        rootView.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
            @Override
            public void onGlobalLayout() {
                final int headerHeight = getActionBarHeight() + getStatusBarHeight();
                int heightDiff = rootView.getRootView().getHeight() - rootView.getHeight();
                if (heightDiff &gt; headerHeight) {
                    Log.e("keyboard", "keyboard is up");
                    if (!mKeyboardUp) {
                        mKeyboardUp = true;
                    }
                } else if (mOpen) {
                    Log.e("keyboard", "keyboard is hidden");
                    mKeyboardUp = false;
                }
            }
        });
    }
</code></pre>

<p>这段代码需要好好解释下：</p>

<ul>
<li>android.R.id.content 通过这个id可以获得一个View的根布局，而不必要知道它具体的id。可以参考<a href="http://stackoverflow.com/questions/7776768/android-what-is-android-r-id-content-used-for">这个讨论</a>。</li>
<li>rootView 这个View是Activity的根布局，除去了actionbar的部分，是一个FrameLayout，注意这个并不是setContentView中设置的布局。rootView的第一个子View(rootView.getChildAt(0))就是setContentView()设置的布局。可以参考<a href="http://stackoverflow.com/questions/4486034/get-root-view-from-current-activity">这个讨论</a>。</li>
</ul>


<h5>优点</h5>

<p>不用子例化，不依赖于现有代码中的成员，可以直接插入到任何代码中。</p>

<h5>缺点</h5>

<p>本质上这跟上一个方法是一样的。因此对于adjustPan和全屏的adjustResize二种情况是无效的。针对这二种情况heightDiff不会变化。</p>

<h4>计算根布局的的底部空隙</h4>

<p>其实所有的方法都是为了发现软键盘对布局的影响，从而判断软键盘的显示和隐藏。还有一种方法就判断根布局的可视区域与屏幕底部的差值，如果这个差大于某个值，可以认定键盘弹起了。</p>

<h5>核心原理</h5>

<pre><code class="java">private boolean isKeyboardShown(View rootView) {
        final int softKeyboardHeight = 100;
        Rect r = new Rect();
        rootView.getWindowVisibleDisplayFrame(r);
        DisplayMetrics dm = rootView.getResources().getDisplayMetrics();
        int heightDiff = rootView.getBottom() - r.bottom;
        return heightDiff &gt; softKeyboardHeight * dm.density;
}
</code></pre>

<p>得到的Rect就是根布局的可视区域，而rootView.bottom是其本应的底部坐标值，如果差值大于我们预设的值，就可以认定键盘弹起了。这个预设值是键盘的高度的最小值。这个rootView实际上就是DectorView，通过任意一个View再getRootView就能获得。</p>

<h5>优点</h5>

<p>适用所有情况，包括adjustPan和全屏的adjustResize也能准确判断出来。</p>

<h3>结论</h3>

<p>如果真的需要监听软键盘显示与隐藏的事件就可以通过上面的提到的最后一种方式来实现，简单方便且可靠，唯一要注意的就是要反注册掉所注册的GlobalLayoutListener.</p>

<h2>参考资料</h2>

<ul>
<li><a href="http://stackoverflow.com/questions/4312319/howto-capture-the-virtual-keyboard-show-hide-event-in-android">http://stackoverflow.com/questions/4312319/howto-capture-the-virtual-keyboard-show-hide-event-in-android</a></li>
<li><a href="http://felhr85.net/2014/05/04/catch-soft-keyboard-showhidden-events-in-android/">Catch soft keyboard show/hidden events in Android</a></li>
<li><a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/39761461">android:windowSoftInputMode属性详解</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
