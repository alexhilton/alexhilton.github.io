<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2025-02-06T21:17:16+08:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Compose多平台 (CMP) 开发的四个实用技巧]]></title>
    <link href="https://alexhilton.github.io/blog/2025/02/04/tips-to-migrate-to-kmp/"/>
    <updated>2025-02-04T17:21:07+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/02/04/tips-to-migrate-to-kmp</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自<a href="https://proandroiddev.com/4-useful-tips-for-compose-kotlin-multiplatform-kmp-8809ba1cac51">Four useful tips for Compose Kotlin Multiplatform (KMP)</a></p></blockquote>

<p><strong>译注：</strong> 这篇文章虽然比较短，但提到的问题还是比较具体和典型的，针对CMP项目的一些配置还是很有借鉴意义的。</p>

<p><a href=""><img src="https://dev-to-uploads.s3.amazonaws.com/uploads/articles/j9tap6mygsqvxh6aauc8.png" title="auto auto" ></a></p>

<!-- more -->


<h2>简介</h2>

<p>正如我在上一篇文章<a href="https://medium.com/@lizarraga.iosu/a-complete-migration-of-a-multi-module-app-to-compose-kotlin-multiplatform-kmp-682905266bde">《将多模块应用程序完全迁移到 Compose Kotlin Multiplatform (KMP)》</a>中所说，上个月我一直在将现有的多模块应用程序迁移到 Compose Multiplatform，除此之外，我还从头开始创建一个新的 Compose Multiplatform 多模块项目。在这两个项目中，我都遇到了相同的“问题”或者说“阻碍”，因此，如果您正在迁移或从头开始启动 CMP 项目，那么本文就是为你量身定做的。</p>

<h2>提示 1：预览</h2>

<p>KMP 不支持 commonMain 目录Compose组件的预览，因此我想到了在 androidMain 目录中创建它们，并且它们的预览运行得很好。</p>

<blockquote><p><strong>译注：</strong>此文原文发布于2024年12月初，彼时非Android侧的源码确实无法Preview，后来JetBrains解决了这个问题，通过一个<a href="https://plugins.jetbrains.com/plugin/16541-compose-multiplatform-ide-support">支持桌面Compose的插件</a>。</p></blockquote>

<p>例如：</p>

<pre><code class="bash">commonMain/com/example/feature/component/FeatureScreen.kt
androidMain/com/example/feature/component/FeatureScreenPreview.kt
</code></pre>

<h2>提示 2：BackHandler</h2>

<p>KMP 不支持 BackHandler 操作，因此我创建了一个用于屏幕的expect函数，并在 androidMain 中的actual函数上添加了 BackHandler 操作，并将 iosMain 留空（因为我在 iOS 中没有找到类似的操作）。</p>

<p>例如：</p>

<pre><code class="Kotlin">// commonMain/ com.example.feature.component.FeatureScreen.kt
@Composable
expect fun FeatureScreen(
    viewModel: FeatureScreenViewModel,
)

@Composable
internal fun Content(
    viewModel: FeatureScreenViewModel,
) {
    ...
}
</code></pre>

<pre><code class="Kotlin">// androidMain/ com.example.feature.component.FeatureScreenActual.kt (needs a name different from common)
@Composable
actual fun FeatureScreen(
    viewModel: WorkScreenViewModel,
) {
    BackHandler { viewModel.onIntent(WorkIntent.Back) }

    Content(
        viewModel = viewModel,
    )
}
// extra: I have joined the preview in this same class to have it better organized.
</code></pre>

<pre><code class="Kotlin">// iosMain/ com.example.feature.component.FeatureScreenActual.kt (needs a name different from common)
@Composable
actual fun FeatureScreen(
    viewModel: WorkScreenViewModel,
) {
    Content(
        viewModel = viewModel,
    )
}
</code></pre>

<h2>提示 3：测试模拟</h2>

<p>我喜欢使用 <a href="https://mockk.io/">mockk</a> 库进行模拟测试，在撰写本文时，KMP 尚不支持该库，因此我决定在 androidUnitTest 目录中创建 UnitTest，并将库依赖项添加到 androidUnitTest.dependencies {} 块中。</p>

<p>对于此类测试，我使用了支持 KMP 的 kotlin-test jetbrains 库。</p>

<p>例如：</p>

<pre><code class="Kotlin">mockk = { group = "io.mockk", name = "mockk", version.ref = "mockk-version" }
kotlin-test = { group = "org.jetbrains.kotlin", name = "kotlin-test", version.ref = "kotlin-version" }
</code></pre>

<pre><code class="Kotlin">// feature build.gradle.kts
kotlin {
    ...

    sourceSets {
        androidUnitTest.dependencies {
            implementation(libs.mockk)
        }

        commonTest.dependencies {
            implementation(libs.kotlin.test)
        }
    }
}
</code></pre>

<pre><code class="bash">androidUnitTest/com/example/feature/usecase/UseCaseTest.kt
</code></pre>

<h2>提示 4：UI 测试</h2>

<p><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-test.html">官方的 Compose 多平台 UI 测试指南</a>指出，必须使用commonTest 目录进行 UI 测试，但我更喜欢使用androidInstrumentedTest目录，因为使用这种方法，我可以将单元测试与 UI 测试分开，并且我可以直接从同一个测试类执行它们，并从目录运行所有 UI 测试。</p>

<p>例如：</p>

<pre><code class="Kotlin">mockk-android = { group = "io.mockk", name = "mockk-android", version.ref = "mockk-version" }
ui-test-junit4-android = { group = "androidx.compose.ui", name = "ui-test-junit4-android", version.ref = "uiTestJunit4AndroidVersion" }
ui-test-manifest = { group = "androidx.compose.ui", name = "ui-test-manifest", version.ref = "uiTestManifestVersion" }
kotlin-test = { group = "org.jetbrains.kotlin", name = "kotlin-test", version.ref = "kotlin-version" }
</code></pre>

<pre><code class="Kotlin">// feature build.gradle.kts
plugins {
    ...
    alias(libs.plugins.compose.multiplatform)
    alias(libs.plugins.compose)
}

kotlin {
    ...

    sourceSets {
        androidInstrumentedTest.dependencies {
            implementation(libs.mockk.android)
            implementation(libs.ui.test.junit4.android)
        }

        commonTest.dependencies {
            implementation(libs.kotlin.test)
            @OptIn(ExperimentalComposeLibrary::class)
            implementation(compose.uiTest)
        }
    }
}

...

dependencies {
    debugImplementation(libs.ui.test.manifest)
}
</code></pre>

<pre><code class="bash">androidInstrumentedTest/com/example/feature/component/ScreenAndroidTest.kt
</code></pre>

<h2>结论</h2>

<p>在本文中，我们看到了一些 Compose Multiplatform 技巧，希望您觉得它们有用。感谢您阅读本文，欢迎提供任何反馈。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于Android 16你想知道的都在这里]]></title>
    <link href="https://alexhilton.github.io/blog/2025/01/02/android-16-is-comming/"/>
    <updated>2025-01-02T22:14:32+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/01/02/android-16-is-comming</id>
    <content type="html"><![CDATA[<p>2025年的Android新版本来的比2024年稍早了一些。今年Google非常反常地提前就发布了Android的<a href="https://developer.android.com/about/versions/16">新版本Android 16 Baklava</a>，整体的计划比往年提前了2～3个月。另外，谷歌把<a href="https://www.androidfaithful.com/android-16-code-name/">Android 16的代码命名为「Baklava」</a>,这与先前的字母表顺序的点心食物命名方式截然不同，不过「Baklava」巴克拉瓦，又称果仁蜜饼，是一种口味浓郁、甜蜜的土耳其酥皮点心。</p>

<p><a href=""><img src="https://www.android-user.de/wp-content/uploads/2024/11/20241101-Android-16-Baklava-Beitragsbild.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>谷歌的发布计划</h2>

<p>从<a href="https://developer.android.com/about/versions/16">官方的消息</a>来看会在24年结束Preview，在25年1月其实是Q1就开始Beta release，并在Q2进入Platform Stability，预计上半年就可能会正式发布，整体的节奏较往年提前了约2～3个月（往年是Q1会有Preview，Q2发布Beta,6~7月左右开始Platform Stability，Q3 9月～10月正式发布）。</p>

<p><img src="file:///Users/alexhilton/Downloads/android-16-release.webp" alt="图1. Android 16的发布计划" /></p>

<p>不过现仍在非常为初始的Preview阶段，后面可能会有变数，官方也没有给具体的计划。但有一点是确定的，那就是今年Android 16的发布肯定较往年会提拉一些，至少提拉2个月。</p>

<p>对于应用开发者来说，更为关心的是API的发布情况，一般情况下API会较系统版本提前一个季度就会正式稳定下来（也即不会再有大的变动），换句话说，今年在Q2就能得到较为稳定的API版本，当然比往年还是有提拉的。</p>

<p><img src="file:///Users/alexhilton/Downloads/android16-api-release.webp" alt="图2. Android 16 API的发布计划" /></p>

<p>发布计划不受我们控制，了解一下就可以了，下面我们看一下如何用条件区分这些新的API。</p>

<h2>区分使用新的API的方式</h2>

<p>如果应用不是运行在最新的版本，那么新的API不应该被执行，因此我们需要用条件来区分不同的API版本，用<a href="https://developer.android.com/reference/android/os/Build.VERSION#SDK_INT">SDK_INT</a>和<a href="https://developer.android.com/reference/android/os/Build.VERSION_CODES">VERSION_CODES</a>就可以做到。当然，需要先在Android Studio中把SDK中的Android 16 Preview版本下载下来才能编译。</p>

<p><img src="file:///Users/alexhilton/Downloads/install-baklava-sdk.png" alt="图3. 升级SDK" /></p>

<pre><code class="Kotlin">if (SDK_INT &gt;= VERSION_CODES.BAKLAVA) {
  // 使用Android 16中才有的API
}
</code></pre>

<p>为了能更细致地区分版本，Android 16新增加了一个新的版本常量<a href="https://developer.android.com/reference/android/os/Build.VERSION#SDK_INT_FULL">SDK_INT_FULL</a>，并在<a href="https://developer.android.com/reference/android/os/Build.VERSION_CODES_FULL">VERSION_CODES_FULL</a>中定义了具体的常量值。它可以粒度更细地检查API的版本，分为Major版本和Minor版本。以往的SDK_INT只能区分大的版本（Major版本），这是它们最大的不同。</p>

<pre><code class="Kotlin">if (SDK_INT_FULL &gt;= VERSION_CODES_FULL.[MAJOR or MINOR RELEASE]) {
  // 用Major版本或者Minor版本才有的API
}
</code></pre>

<p>每个Major版本可能会多个Minor版本，如果不想麻烦，可以用<a href="https://developer.android.com/reference/android/os/Build#getMinorSdkVersion%28int%29">Build.getMinorSdkVersion()</a>来从VERSION_CODES_FULL中取出Minor版本号。</p>

<p><strong>注意：</strong> SDK_INT_FULL，VERSION_CODES_FULL以及getMinorSdkVersion都是Android 16中新增的API，确保把SDK升级到最新才可以编译成功。</p>

<p>接下来我们重点来看一下新一代的Android带来了哪些变化。</p>

<h2>新的功能和新的API</h2>

<p>很不幸，Android 16并没有带来全新的功能。只有一些小的新API。</p>

<h3>用户体验和系统UI</h3>

<p>提供一些的新的API以更好更灵活的控制系统的行为。</p>

<h4>可预见的返回更新</h4>

<p>Android 16增加了新的API以使能手势导航中的可预见返回系统动画，比如从应用返回到桌面的动画。使用新的<a href="https://developer.android.com/reference/android/window/OnBackInvokedDispatcher#PRIORITY_SYSTEM_NAVIGATION_OBSERVER">PRIORITY_SYSTEM_NAVIGATION_OBSERVER</a>向系统注册一个回调<a href="https://developer.android.com/reference/android/window/OnBackInvokedDispatcher#registerOnBackInvokedCallback(int,%20android.window.OnBackInvokedCallback">onBackInvokedCallback</a>)，每当系统处理一个返回导航时就能够收到<a href="https://developer.android.com/reference/android/window/OnBackInvokedCallback#onBackInvoked(">onBackInvoked</a>)回调，而不影响常规的返回导航流程。</p>

<p>Android 16还增加了两个API <a href="https://developer.android.com/reference/android/window/SystemOnBackInvokedCallbacks#finishAndRemoveTaskCallback(android.app.Activity">finishAndRemoveTaskCallback</a>)和<a href="https://developer.android.com/reference/android/window/SystemOnBackInvokedCallbacks#moveTaskToBackCallback(android.app.Activity">moveTaskToBackCallback</a>)。通过向<a href="https://developer.android.com/reference/android/window/OnBackInvokedDispatcher">OnBackInvokedDispatcher</a>注册这些回调，当执行返回手势时系统就能触发具体的行为和播放相关的动画。</p>

<h4>更加丰富的震感反馈</h4>

<p>Android 16增加了<a href="https://developer.android.com/reference/android/os/vibrator/package-summary">震感API</a>，能让应用定义震感效果的振幅和频率的曲线，同时屏蔽设备的差异。</p>

<h3>性能和电池</h3>

<p>Android 16提供了新的API以帮助收集应用的洞察。</p>

<h4>系统触发的分析</h4>

<p><a href="https://developer.android.com/about/versions/15/features#app-start-info">Android 15</a>添加的<a href="https://developer.android.com/reference/android/os/ProfilingManager">ProfilingManager</a>能让应用请求分析数据集。然而，这个分析必须由应用来发起，一些像启动过程以及ANR就很抓取得到（因为应用必须要先正常启动起来后，才能调用ProfilingManager去获取分析数据）。</p>

<p>为了解决这个问题，Android 16在ProfilingManager中增加了系统触发的分析数据。应用可以注册感兴趣的特定场景的trace，诸如冷起动或者ANR，系统会替应用开启和停止trace。trace收集完毕后，结果会传到应用的data目录。</p>

<h3>ApplicationStartInfo中增加Start component</h3>

<p>ApplicationStateInfo是在Android 15增加的，让应用能够看到进程启动原因，启动类型，启动时间等一系列诊断数据。Android 16增加了方法<a href="">getStartComponent</a>以辨识哪种组件类型触发的启动，这对于优化应用启动过程将会非常有帮助。</p>

<h3>更好的（后台）任务反查</h3>

<p>API <a href="https://developer.android.com/reference/android/app/job/JobScheduler#getPendingJobReason(int">JobScheduler#getPendingJobReason()</a>)能返回任何处于待处理的原因。当然，一个任务可能由于很多种原因待处理。</p>

<p>在Android 16中，增加了一个新的API <a href="https://developer.android.com/reference/android/app/job/JobScheduler#getPendingJobReasons(int">JobScheduler#getPendingJobReasons(int jobId)</a>)，用以返回任务处于待处理的多个原因，比如缘于开发者设置了显性的限制或者系统设置的隐性限制。</p>

<p>还增加了一个API <a href="https://developer.android.com/reference/android/app/job/JobScheduler#getPendingJobReasonsHistory(int">JobScheduler#getPendingJobReasonsHistory(int jobId)</a>)，用以返回最近的限制变更列表。</p>

<p>推荐使用这些API来调试为何后台任务没被执行，尤其是当看到特定任务的成功率降低时，或者特定任务完成有延迟时。例如，在后台更新桌面小部件时失败或者预先拉取任务在应用启动前失败等等。</p>

<p>这也能够更好的帮助你明白因为系统定义的限制还是因为显性的限制而导致特定的任务未执行完成。</p>

<h3>自适应刷新频率</h3>

<p>Android 15引入的自适应刷新频率(Adaptive refresh rate ARR)通过离散化的VSync步长能够让屏幕刷新频率适配内容频率。这会降低功耗同时消除潜在的掉帧。</p>

<p>Android 16增加了方法<a href="https://developer.android.com/reference/android/view/Display#hasArrSupport(">hasArrSupport</a>)和方法<a href="https://developer.android.com/reference/android/view/Display#getSuggestedFrameRate(int">getSuggestedFrameRate(int)</a>)以及<a href="https://developer.android.com/reference/android/view/Display#getSupportedRefreshRates(">getSupportedRefreshRates()</a>)，让应用容易利用ARR。Jetpack中的很多组件在内部实现上已经利用ARR以增强平滑的滑动，详细的可<a href="https://developer.android.com/media/optimize/performance/frame-rate">参见了此文章</a>。</p>

<h3>连接</h3>

<p>WiFi可以用来室内定位，Android 16增加了对WiFi位置安全性的支持，通过<a href="https://developer.android.com/reference/android/net/wifi/rtt/SecureRangingConfig">这个特性</a>。</p>

<h3>媒体</h3>

<h4>照片选择增强</h4>

<p><a href="https://developer.android.com/training/data-storage/shared/photopicker">照片选择器(photo picker)</a>提供了一个安全且内置的方式让应用在用户授权的情况下从存储中选择媒体文件。</p>

<p>Android 16带来的增强点有：</p>

<ul>
<li>嵌入式的图片选择器：<a href="https://developer.android.com/reference/android/widget/photopicker/package-summary">新的API</a>能够让应用把图片选择器嵌入到自己的视图中。这会让图片选择看起来更像是应用整体的一部分。后续的Jetpack中会提供可嵌入的图片选择器。</li>
<li>图片选择器支持云搜索：<a href="https://developer.android.com/sdk/api_diff/b-dp2-incr/changes/pkg_android.provider">新的API</a>在图片选择器将支持云搜索。</li>
</ul>


<h3>隐私</h3>

<h4>健康连接更新</h4>

<p>开发者Preview版本中的健康连接增加了ACTIVITY_INTENSITY（活动强度），依据世界健康组织（WHO）给出的指南中定义的一个新的数据类型。每一条记录将必须包括开始时间，结束时间以及活动强度。</p>

<h4>隐私沙盒</h4>

<p>Android 16集成了<a href="https://developers.google.com/privacy-sandbox/overview/android">Android隐私沙盒</a>的最新版本，这是一项为保护用户隐私而持续进行的工作。可以查看<a href="https://developer.android.com/design-for-safety/privacy-sandbox/program-overview">网站内容</a>以了解更多。</p>

<h2>行为变更</h2>

<p>比起新的API，Android 16带来的行为变更更值得我们关注，因为这会直接影响所有应用，无论targetSdkVersion是否是Baklava。</p>

<h3>核心功能</h3>

<h4>JobScheduler配额优化</h4>

<p>从Android 16开始，以基于以下因素来调整常规任务和加急任务的运行时配额：</p>

<ul>
<li>应用处于<a href="https://developer.android.com/topic/performance/appstandby">哪个等待区</a>：在Android 16中，活跃的等待区会减少限制。</li>
<li>如果任务开始执行时应用处于头部状态：在Android 16中，任务启动时，如果应用是用户可见的且应用变成可见后仍在继续执行，会加入到运行时配额中。</li>
<li>如果任务执行时正在运行一个前台服务：在Android 16中，当正在执行一个前台服务时，正在执行的任务将加入到运行时配额中。如果任务是用于用户数据传送，建议<a href="https://developer.android.com/develop/background-work/background-tasks/uidt">考虑替换方案</a>。</li>
</ul>


<p>这些变动将会影响由WorkManager，JobScheduler和DownloadManager调度的任务。如果要调试为何一个任务被终止了，建议通过调用<a href="https://developer.android.com/reference/androidx/work/WorkInfo#getStopReason(">WorkInfo.getStopReason()</a>)来打印日志。</p>

<p>也可以通过Android 16新增加的API <a href="https://developer.android.com/partners/android-16/features#feature-pending-job-reason-history">JobScheduler#getPendingJobReasonsHistory</a>来了解为何任务未执行。</p>

<p>另外，在Android 16上还可以通过adb命令强制调整运行时任务配额，以方便测试：</p>

<pre><code class="Bash"># 取消头部状态配额限制
adb shell am compat enable OVERRIDE_QUOTA_ENFORCEMENT_TO_TOP_STARTED_JOBS &lt;APP_PACKAGE_NAME&gt;

# 设置等待区
adb shell am set-standby-bucket &lt;APP_PACKAGE_NAME&gt; active|working_set|frequent|rare|restricted

# 获取所处的等待区状态
adb shell am get-standby-bucket &lt;APP_PACKAGE_NAME&gt;
</code></pre>

<h3>用户体验和系统UI</h3>

<p>Android 16废弃了无障碍公告(announcement)，一种使用<a href="https://developer.android.com/reference/android/view/View#announceForAccessibility(java.lang.CharSequence">announceForAccessibility</a>)或者派发<a href="https://developer.android.com/reference/android/view/accessibility/AccessibilityEvent#TYPE_ANNOUNCEMENT">TYPE_ANNOUNCEMENT</a>引起的无障碍事件。这些公告会造成Talkback和屏幕发声的混乱，容易被滥用，一些可行的替换方案有：</p>

<ul>
<li>对于像窗口变化之类的极重要的UI变化，可以用<a href="https://developer.android.com/reference/android/app/Activity#setTitle(java.lang.CharSequence">Activity.setTitle(CharSequence)</a>)和<a href="https://developer.android.com/reference/android/view/View#setAccessibilityPaneTitle(java.lang.CharSequence">setAccessibilityPaneTitle(java.lang.CharSequence)</a>)。在Compose中使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/semantics/package-summary#(androidx.compose.ui.semantics.SemanticsPropertyReceiver">Modifier.semantics { paneTitle = &ldquo;paneTitle&rdquo; }</a>.liveRegion)。</li>
<li>告知用户重要UI变化，使用<a href="https://developer.android.com/reference/android/view/View#setAccessibilityLiveRegion(int">setAccessibilityLiveRegion(int)</a>)。在Compose中，用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/semantics/package-summary#(androidx.compose.ui.semantics.SemanticsPropertyReceiver">Modifier.semantics { liveRegion = LiveRegionMode.[Polite|Assertive]}</a>.liveRegion)。这些也要小心使用，因为每当View刷新就会触发一个无障碍事件。</li>
<li>通知用户有错误，发送一个类型为<a href="https://developer.android.com/reference/android/view/accessibility/AccessibilityEvent#CONTENT_CHANGE_TYPE_ERROR">AccessibilityEvent#CONTENT_CHANGE_TYPE_ERROR</a>的无障碍事件，并且设置<a href="https://developer.android.com/reference/android/view/accessibility/AccessibilityNodeInfo#setError(java.lang.CharSequence">AccessibilityNodeInfo#setError(CharSequence)</a>)，或者<a href="https://developer.android.com/reference/android/widget/TextView#setError(java.lang.CharSequence">TextView#setError(CharSequence)</a>)。</li>
</ul>


<p>可以<a href="https://developer.android.com/reference/android/view/View#announceForAccessibility(java.lang.CharSequence">看文档</a>)以了解废弃announceForAccessibility的细节以及推荐的替代方案。</p>

<h2>适配建议</h2>

<p>到目前为止，我们能了解到的Android 16的变化就这么多，总的来看增量变化并不多，新的API 都是一些小的细节上的增强；行为的变更也很少很少，只涉及后台任务和无障碍。新的API不会影响现有的应用，行为变更也不多，可以说对于绝大多数应用来说影响甚微。</p>

<p>现在仍是开发者Preview阶段，只有亲儿子Pixel系列会收到OTA版本，我们了解一下就可以了。即使是应用可能会受到行为变更的影响，也不用着急，建议再等2～3个月，等到有更多的厂商发出Beta版本了，并且API也稳定了时再做适配也不迟。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/about/versions/16/features">Features and APIs</a></li>
<li><a href="https://android-developers.googleblog.com/2024/11/the-first-developer-preview-android16.html">The First Developer Preview of Android 16</a></li>
<li><a href="https://android-developers.googleblog.com/2024/12/second-developer-preview-android16.html">The Second Developer Preview of Android 16</a></li>
<li><a href="https://developer.android.com/about/versions/16/behavior-changes-16">Behavior changes: Apps targeting Android 16 or higher</a></li>
<li><a href="https://developer.android.com/about/versions/16/behavior-changes-all">Behavior changes: all apps</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[群星闪耀的大前端开发]]></title>
    <link href="https://alexhilton.github.io/blog/2024/12/10/a-brief-history-of-cross-platform-development/"/>
    <updated>2024-12-10T22:01:05+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/12/10/a-brief-history-of-cross-platform-development</id>
    <content type="html"><![CDATA[<p>乔帮主发布iPhone以降，把世界推向了智能手机时代，随之而来的是移动互联网大潮，一时间移动应用开发变得炙手可热起来，渐渐的超越了传统桌面端和传统前端，成为了主流。随之而来的就是重复开发的问题，同样的业务需要在Android上面实现一次，在iOS上面实现一次，通常也需要在Mobile Web（移动端H5）实现一次，自此跨端开发成了移动互联时代一个必须要攻克的难题。</p>

<p><a href=""><img src="https://www.ropstam.com/wp-content/uploads/2023/09/Best-Cross-Platform-App-Development-Frameworks.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>大前端开发简史</h2>

<p>工程师的使命是<strong>把不可能变可能，把可能变简单，把简单变优雅</strong>。如果能用同一套代码在不同的端侧都运行，那将是再美好不过的了，毕竟对于端侧业务逻辑一样的，但却要用不同的编程语言，不同的框架，不同的平台，不同的团队各开发一次。如果能够做到「开发一次，多端运行」，将极大的节省人力物力和财力，开发效率也将大大提升。遂业界一直在探索如何跨移动端开发，也即只用一套代码，开发一次，就可以在Android端，iOS端和移动Web端三端运行。</p>

<h3>史前时代：Hybrid app</h3>

<p>最先出来的框架是Hybrid app（<a href="https://phonegap.com/">PhoneGap</a>和<a href="https://cordova.apache.org/docs/en/latest/">Cordova</a>），利用Android端和iOS端都对WebView有较好的支持，因此用移动前端（也即网页）的方式来开发应用，绝大多数的业务逻辑都在网页里，Android端和iOS端都是用WebView去展示网页，对于JavaScript在网页中无法实现的，与平台强相关的事情可以通过JavaScript Bridge来调用平台实现的API，称之为JsBridge。</p>

<p>这种架构非常简单，对于Android和iOS来说，使用一个WebView，再实现一些native API就可以了，其余的都是标准的移动前端。得益于平台对HTML 5的支持，以及像jQuery Mobile等优秀的前端库的加持，无论是开发体验还是使用体验，Hybrid app并不差。最重的是它跨平台性特别好，性价比超高，对于UI部分很重，交互 也不复杂的以展示为主的页面来说，这是性价比超高的实现方式。</p>

<p>这个可以称之为史前时代。</p>

<h3>黑暗时代：不成熟的各种尝试</h3>

<p>Hybrid app方式虽然可行，但在不同的终端上面体验差距很明显。对于性能较好的中高端设备，因为设备整体性能较好，Hybrid app体验尚可，虽然与原生UI相比仍有差距，但属于可接受范围。但对于中低端设备来说，WebView不但性能差，而且兼容性不好，体验严重差于原生UI。另外，如果UI交互变得复杂，或者对体验和实时性操作要求比较高（如文档编辑类等）Hybrid方式与原生更是相距甚远。工程师们开始尝试新的方案。</p>

<p>比如坊间有用json格式来定义UI，定义好格式后，每个端拿到一坨json数据解析，然后生成UI。这其实都算不上是框架，其实就是用json来描述一个页面，解析与构建UI仍是由每个端自己搞，顶多算是一种UI描述格式。但难以通用，并且只能描述UI的静态结构，无法有动态的行为之类的。这种方案也曾有不少大厂用过，它非常适用于局部的，并不复杂的UI，业务逻辑固定，但UI排版样式可能随时会变页面。但要说用它来写整个应用，是不现实的。</p>

<p>这期间Google也做了尝试，搞出一个叫做<a href="https://developers.google.com/j2objc">j2objc的工具</a>，它能把Java代码翻译 成为Objective&#45;C代码，转换后的Objective-C代码无需修改可以直接编译运行。显然，这个工具并不适用于UI，因为UI都是与平台强相关的，需要大量的依赖于平台的SDK，并不是把代码「翻译」过来就完事了。这个工具适用于非UI部分的业务逻辑代码，效果也非常的好，经其转换后的代码可以直接编译运行。据说Google自己也在用，当时的GMS产品Google Inbox等都用j2objc达到了70%代码共用。</p>

<p>这是大前端的一个黑暗时代，虽然大家都在尝试，但始终没有一个比较理想的完整的解决方案。</p>

<h3>黎明的署光：划时代的ReactNative</h3>

<p>Hybrid方式最大的问题在于WebView是性能和体验的瓶颈，WebView之所以是瓶颈 在于它是一个完全的浏览器，它要完全支持JavaScript，HTML和CSS。但随着HTML5和Web前端技术的发展，有很多库可能只用JavaScript来实现。JavaScript独立出来与Node.js结合（严谨的说是JS引挚），同样可以做前端，但却少了HTML和CSS的拖累，沿着这个思路非死不可（彼时叫做Facebook，现在叫做Meta）推出了一个跨移动端平台的开发框架ReactNative。它是基于Facebook的React框架，做了面向移动端的延伸。它的主要实现方法是用React来写页面，这是一个基于JavaScript语言的声明式UI框架，加入了一个虚拟DOM层，用以屏蔽频繁的DOM改动，然后再把虚拟DOM转成一个渲染树，最后由Node开出口子，把渲染树用Native的API去实现，由此实现了原生UI。</p>

<p>ReactNative可以实现跨三端，页面用React写好后，不用修改就可以在Web，Android和iOS上运行。一经发布引发了巨大反响，坊间众人皆拍大腿「卧草，还可以这样玩儿啊！」。</p>

<p>ReactNative是划时代的，因为它确定了跨端框架的基本结构：声明式UI，虚拟DOM和渲染树，用原生API去实现渲染树（映射为Native的组件，或者用Native graphics API去实现渲染树）。后续的跨端框架基本上都是这个路子。</p>

<h3>群星闪耀的当下</h3>

<p>时光荏苒，移动互联大潮已经过了十几年，技术也层出不穷，新的框架在不断的涌现。现如今跨端这一领域百花齐放，群星闪耀，各大框架经过几年的沉淀与发展已经比较成熟。除了<a href="https://reactnative.dev/">ReactNative</a>以外，还有了NativeScript，Flutter以及CMP。这其中<a href="https://nativescript.org/">NativeScript</a>其实与ReactNative差不多，唯一的区别在于它允许用JavaScript家族语言（如<a href="https://www.typescriptlang.org/">TypeScript</a>和<a href="https://coffeescript.org/">CoffeeScript</a>），以及不限制开发框架，可以用Vue.js或者Angular.js来写UI。</p>

<p>当然，最为广泛流行，业界使用最多的当属于Flutter和ReactNative，CMP作为一颗新星也越来越受关注。</p>

<h2>流行框架对比</h2>

<p>这里简要对比一下最为流行的ReactNative和Flutter以及新星CMP，以方便使用者做出更好的选择。</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 框架 </th>
<th style="text-align:center;"> 开发者 </th>
<th style="text-align:center;"> 开发语言 </th>
<th style="text-align:center;"> UI开发库 </th>
<th style="text-align:center;"> 支持的端 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> ReactNative </td>
<td style="text-align:center;"> Meta </td>
<td style="text-align:center;"> JavaScript </td>
<td style="text-align:center;"> React </td>
<td style="text-align:center;"> Android, iOS, Web </td>
</tr>
<tr>
<td style="text-align:center;"> Flutter </td>
<td style="text-align:center;"> Google </td>
<td style="text-align:center;"> Dart </td>
<td style="text-align:center;"> </td>
<td style="text-align:center;"> Android, iOS, Desktop, Web </td>
</tr>
<tr>
<td style="text-align:center;"> CMP </td>
<td style="text-align:center;"> JetBrains </td>
<td style="text-align:center;"> Kotlin </td>
<td style="text-align:center;"> Jetpack Compose </td>
<td style="text-align:center;"> Android, iOS, Desktop, Web </td>
</tr>
</tbody>
</table>


<p>ReactNative和Flutter都相对较成熟和稳定了，使用者也较多，社区很活跃。ReactNative更适合移动端，而Flutter能跨的端和CMP要更多一些。此外，Flutter和CMP与其他框架最大的区别在于它使用Skia库构建了一个渲染引挚，可以直接把渲染树渲染成为平台支持的更为底层的canvas，直接接入native层的graphics API而不是映射成native组件，为此，它的渲染效率更为高效一些，进而性能更优一些，可以把它们想像成为一个浏览器。</p>

<p>技术栈也不一样，ReactNative是基于Node和JavaScript，属于前端技术栈，与前端融合更为紧密一些；而CMP是基于Kotlin和JVM与Android更为紧密一些，属于Java派系；而Flutter自成一派。</p>

<h2>选择是痛苦的</h2>

<p>实事求是的来说<a href="https://flutter.dev/">Flutter</a>是当前最为成熟 也最为完备的一个跨端框架，只不过可能学习成本略大，对于大部分同学来说Dart是一门小众的编程语言。而ReactNative最大的问题就在于React，它太前端化了，对于客户端同学来说写一坨HTML式的标签还是相当难受的。</p>

<p>应该说Flutter已经非常成功了，达到了它应该有高度，实现了它的价值，换句话说它的前景也不是特别明朗了，因为它已经很成熟了，所以有传言谷歌内部也在裁撤Flutter的研发资源。ReactNative也一样，这么多年了，版本还没有到1.0。</p>

<p><img src="https://blog.droidchef.dev/content/images/size/w1000/2022/11/Flutter-vs-Jetpack-Compose-Header--2-.png" alt="图1. Flutter vs CMP" /></p>

<p>而CMP刚刚兴起，使用起来非常的方便和简单，它的安装与配置是所有框架之中最为简便的（只需要安装一个Android Studio的插件，其余的都是编译插件和依赖，并不像Flutter和ReactNative都需要在开发机器上安装其他东西），前途无量，非常值得投入。并且Flutter对于谷歌来说九牛一毛，是非常不起眼的东西，谷歌毕竟家大业大，像谷歌和Meta等巨头现在都在狂卷AI，其他的小业务都不受重视。</p>

<p>但CMP不一样，JetBrains本身就是专门搞开发工具的，这是他们的主业肯定 会好好搞，把CMP与其IDE深度结合，对于开发者使用起来那就相当的方便了。事实上JetBrains已经开始弄了，它的最新的<a href="https://www.jetbrains.com/fleet/">IDE Fleet</a>（一个通用的IDE）将会深度绑定CMP，非常值得期待。</p>

<p>综合考虑，给出的建议就是如果是<strong>一个纯新的项目，特别是MVP阶段，不要犹豫就是用Flutter</strong>。而如果是<strong>现有项目，想要跨端，就选择CMP</strong>，它是对现有项目最为友好的一个。除非你是资源前端且是React粉，否则不要考虑ReactNative。</p>

<h2>框架只能解决一部分问题</h2>

<p>最后想说的是，对于跨端开发，框架只能解决一小部分问题。</p>

<p>跨端开发最难的地方在于合理的架构和团队的协同。架构需要做好层与层的隔离，特别是把与平台强相关的API做好隔离层，以最大限度 的共用代码，如果到处都是粗粒度的平台相关的实现，复杂度将急剧上升，那最后会变成多端的拼盘而非一个跨端项目。人员的协作应该以功能为单位来划分而不能再以端的维度，要彻底消灭端的思维，要以UI，功能和业务逻辑角度来思考问题，这样才能更好的协作。总之跨端对团队的要求更高，否则只会制造更多的问题。</p>

<p>人的问题永远要比技术问题要复杂一些，举个最简单的例子，以往每个端各自为政，Android端某个同学犯了错，顶多就是Android端不能用了，可能最多就3.25。真跨端了以后，再犯错那可就是所有端都搞挂了，可能最少是3.25起步，这里头的差别还是相当大的，如果没有强有力的大一点的老板来推，是很难推得动的。</p>

<p>研发同学都喜欢折腾，光完成业务是很无聊的，也不可能出成绩，都想方设法的搞出点「技术产出」（俗称造轮子）。记得ReactNative刚出来时，坊间很热情都在把其引入到各自的业务中去，但最终的结果是，没有人会真的在业务中重点使用，而是都花心思搞出了一套属于自己的跨端框架，并且向其他团队推广。年终汇报时，PPT很漂亮：「老板您看，我们不光完成了业务，还搞了一套跨端框架，它比ReactNative好在哪里，已经在我们的业务使用了，也给其他团队推广了」。相反，假如你真的使用了跨端，你咋 汇报？「老板，您看，我们用了别人的跨端技术，成功的实现了跨端，原来三个端15个人能做完的事情，现在只需要8个人！」。老板听了，很激动，3.25终于找到人选了，开猿节流也有着落了！</p>

<p>Anyway，总的来说跨端开发更适合业务不复杂，UI交互也不重的中小型App，或者那种UI占比较小非UI逻辑占比大的应用（最典型的就是浏览器），才能发挥出最大的价值。一个比较简单的判断标准就是，如果每个端的研发人员都超过10个人，可能就不太适合用跨平台的开发方式。</p>

<h2>References</h2>

<ul>
<li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/cross-platform-frameworks.html">The Six Most Popular Cross-Platform App Development Frameworks</a></li>
<li><a href="https://developers.google.com/j2objc">What J2ObjC is</a></li>
<li><a href="https://github.com/google/j2objc">A Java to iOS Objective-C translation tool and runtime.</a></li>
<li><a href="https://hackernoon.com/getting-started-with-react-native-for-windows-and-macos">Getting started with React Native for Windows &amp; macOS</a></li>
<li><a href="https://medium.com/@ankit-detroja/react-native-or-flutter-in-2024-7cfb0605698f">React native or Flutter in 2024</a></li>
<li><a href="https://leancode.co/blog/flutter-vs-react-native">Flutter vs. React Native: A Detailed Comparison for 2024</a></li>
<li><a href="https://nateshmbhat.medium.com/flutter-vs-react-native-performance-benchmarks-you-cant-miss-%EF%B8%8F-2e31905df9b4">Flutter Vs React Native : Performance Benchmarks you can’t miss ! 🔥⚡️ [Part -1]</a></li>
<li><a href="https://medium.com/newsoft-official/compose-multiplatform-vs-flutter-771673612c61">Compose Multiplatform VS. Flutter</a></li>
<li><a href="https://infinitelambda.com/flutter-kotlin-multiplatform-native-comparison/">FLUTTER VS KOTLIN MULTIPLATFORM VS NATIVE</a></li>
<li><a href="https://www.miquido.com/blog/kotlin-multiplatform-vs-flutter/">Flutter vs. Kotlin Multiplatform Mobile</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实战：把一个现有的Compose项目转化为CMP项目]]></title>
    <link href="https://alexhilton.github.io/blog/2024/12/09/migrate-existing-project-to-cmp/"/>
    <updated>2024-12-09T22:09:28+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/12/09/migrate-existing-project-to-cmp</id>
    <content type="html"><![CDATA[<p>通过<a href="https://juejin.cn/column/7367555191338467337">前面两篇文章</a>的学习，我们已经对CMP有了一定的了解，接下来要进入实战阶段。在现实的世界中极小数项目会从0开始，今天重点研究一下如何把一个现成的用Jetpack Compose开发的Android项目转成CMP项目。</p>

<p><a href=""><img src="https://www.mouritech.com/wp-content/uploads/2024/01/Compose-Multiplatform.png" title="auto auto" ></a></p>

<!-- more -->


<h2>总体思路</h2>

<p>在前面的文章<a href="https://juejin.cn/post/7439251025385996307">Compose大前端从上车到起飞</a>里面我们学习到了，CMP对Android开发同学是相当友好的，CMP项目与Android项目在项目结构上面是非常相似的。并且因为CMP的开发IDE就是Android Studio，因此，可以直接把一个Android项目改造成为CMP项目，而不是创建一个全新的CMP项目之后把项目代码移动进去。</p>

<p>具体的步骤如下：</p>

<ol>
<li>添加CMP的插件，添加源码集合，配置CMP的依赖</li>
<li>把代码从「androidMain」移动到「commonMain」中去</li>
<li>把资源转换成为CMP方式</li>
<li>添加并适配其他平台</li>
</ol>


<p><strong>小贴士：</strong> 针对 不同的类型的任务需要采取 不同的策略，比如开发功能的时候使用「自上而下」的方式要更为好一些，因为先关注大粒度的组件，类与方法，不被细节拖住，更有利于我们看清架构和优先解决掉重点问题；但当做移植任务时，应该采用「自下而上」，因为依赖是一层套一层，先把下面的移好，上面的自然就会更加容易。</p>

<p>这里选用的项目是先前用纯Jetpack Compose开发的<a href="https://github.com/alexhilton/Aeolus">一款天气应用</a>，项目比较简单，依赖不多，完全是用Jetpack Compose实现的UI，也符合<a href="https://juejin.cn/post/7411812014047461387">现代应用开发架构原则</a>，非常适合当作案例。</p>

<p><strong>注意：</strong> 其实这里的项目并没有严格要求，只要是一个能运行的Android项目即可，其他的（是不是Jetpack Compose实现的，用的是不是Kotlin）并不是最关键的。因为CMP项目对于每个源码集合本身并没有明确的要求，前面的文章也讲了，每个平台的源码集合，其实就是其平台的完整的项目。移植的目的就是把 <strong>可共用共享</strong> 的代码从现有项目中抽出来放进「commonMain」中，即可以是原有的业务逻辑，也可以是新开发的代码。采用新技术或者新工具的一个非常重要的原则 就是要循序渐进，不搞一刀切。如果时间不充裕，完全可以新功能和新代码先用CMP方式开发，老代码暂且不动它，待日后慢慢再移植。当然了，纯Jetpack Compose实现的项目移植过程会相对容易一些。</p>

<p>下面我们进行详细的一步一步的实践。</p>

<h2>配置CMP的插件，源码集合和依赖</h2>

<p>首先要做的是配置Gradle构建插件（这是把Gradle常用的Tasks等打包成为一个构建 插件，是编译过程中使用的）：</p>

<ul>
<li>使用Kotlin Multiplatform（「org.jetbrains.kotlin.multiplatform」）替换Kotlin Android（「org.jetbrains.kotlin.android」），这个主要是Kotlin语言的东西，版本号就是Kotlin的版本号，注意要与其他（如KSP，如Coroutines）版本进行匹配；</li>
<li>添加Compose compiler（「org.jetbrains.kotlin.plugin.compose」）的插件，版本号要与Kotlin版本号保持一致；</li>
<li>以及添加Compose Multiplatform（org.jetbrains.compose」）插件，版本号是CMP的版本号。</li>
</ul>


<p>注意，构建插件配置是修改项目根目录的那个build.gradle.kts：</p>

<pre><code class="Kotlin">// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    id("com.android.application") version "8.1.4" apply false
    id("com.android.library") version "8.1.4" apply false
    id("org.jetbrains.kotlin.multiplatform") version "2.0.21" apply false
    id("com.google.devtools.ksp") version "2.0.21-1.0.28" apply false
    id("org.jetbrains.kotlin.plugin.compose") version "2.0.21" apply false
    id("org.jetbrains.compose") version "1.7.0" apply false
}
</code></pre>

<p>之后是修改module的build.gradle.kts，先是启用需要的插件，然后是添加kotlin相关的配置（即DSL kotlin {&hellip;}），在其中指定需要编译的目标，源码集合以及其依赖，具体的可以仿照着CMP的demo去照抄就好了。对于依赖，可以把其都从顶层DSL dependencies中移动到androidMain.dependencies里面，如果有无法移动的就先放在原来的位置，暂不动它，最终build.gradle.kts会是酱紫：</p>

<pre><code class="Kotlin">plugins {
    id("com.android.application")
    id("com.google.devtools.ksp")
    id("org.jetbrains.kotlin.multiplatform")
    id("org.jetbrains.kotlin.plugin.compose")
    id("org.jetbrains.compose")
}

kotlin {
    androidTarget {
        @OptIn(org.jetbrains.kotlin.gradle.ExperimentalKotlinGradlePluginApi::class)
        compilerOptions {
            jvmTarget.set(org.jetbrains.kotlin.gradle.dsl.JvmTarget.JVM_17)
        }
    }

    sourceSets {
        androidMain.dependencies {
            // Jetpack
            implementation("androidx.core:core-ktx:1.15.0")
            implementation("androidx.appcompat:appcompat:1.7.0")
            implementation("androidx.activity:activity-compose:1.9.3")
            val lifecycleVersion = "2.8.7"
            implementation("androidx.lifecycle:lifecycle-runtime-ktx:$lifecycleVersion")
            implementation("androidx.lifecycle:lifecycle-runtime-compose:$lifecycleVersion")
            implementation("androidx.lifecycle:lifecycle-viewmodel-compose:$lifecycleVersion")
            val navVersion = "2.8.4"
            implementation("androidx.navigation:navigation-runtime-ktx:$navVersion")
            implementation("androidx.navigation:navigation-compose:$navVersion")
            implementation("androidx.datastore:datastore-preferences:1.1.1")

            // Google Play Services
            implementation("com.google.android.gms:play-services-location:21.3.0")

            // Compose
            implementation(compose.preview)
            implementation(project.dependencies.platform("androidx.compose:compose-bom:2024.02.00"))
            implementation("androidx.compose.ui:ui")
            implementation("androidx.compose.ui:ui-graphics")
            implementation("androidx.compose.ui:ui-tooling-preview")
            implementation("androidx.compose.material3:material3")
            implementation("androidx.compose.material:material")

            // Network
            implementation("com.google.code.gson:gson:2.10.1")
            implementation("com.squareup.retrofit2:retrofit:2.9.0")
            implementation("com.squareup.retrofit2:converter-gson:2.9.0")
            implementation("com.squareup.okhttp3:logging-interceptor:4.12.0")

            // Accompanist
            implementation("com.google.accompanist:accompanist-permissions:0.32.0")
        }
        commonMain.dependencies {
            implementation(compose.runtime)
            implementation(compose.foundation)
            implementation(compose.material)
            implementation(compose.ui)
            implementation(compose.components.resources)
            implementation(compose.components.uiToolingPreview)
            val lifecycleVersion = "2.8.3"
            implementation("org.jetbrains.androidx.lifecycle:lifecycle-viewmodel:$lifecycleVersion")
            implementation("org.jetbrains.androidx.lifecycle:lifecycle-runtime-compose:$lifecycleVersion")
        }
    }
}

android { ... }

dependencies { ... }
</code></pre>

<p>最后，把DSL android {&hellip;}中不支持的字段删除掉即可，如kotlinOptions，它用来指定Kotlin JVM target的，现改在DSL kotlin中的androidTarget()中指定了，但要注意Kotlin的JVM target要与android中的compileOptions的sourceCompatibility以及targetCompatibility版本保持一致，比如都是17或者都是11，否则会有编译错误。</p>

<p>需要特别注意的是DSL kotlin中的源码集合名字要与真实的目录一致，否则编译会出错。建议的方式就是依照CMP的demo那样在module中去创建androidMain和commonMain即可。另外，可以把module名字从「app」改为「composeApp」，然后把运行配置从「app」改为「androidApp」，这下就齐活儿了：</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/migrate-struct.png" alt="图1. 重命名后的项目结构" /></p>

<p>CMP的插件和依赖配置好了以后，运行「androidApp」应该就可以正常运行。因为仅是配置一些依赖，这仍是一个完整的Android应用，应该能够正常运行。这时第一步就做完了，虽然看起来貌似啥也没干，但这已经是一个CMP项目了，基础打好了，可以大步向前了。</p>

<p><strong>小贴士：</strong> 通过配置依赖可以发现，CMP的artifact依赖都是以org.jetbrans.*开头的，哪怕是对于Compose本身，纯Android上面Jetpack Compose的依赖是「&#8221;androidx.compose.ui:ui&#8221;」，而CMP中的则是「&#8221;org.jetbrains.compose.ui:ui&#8221;」。虽然都是Jetpack Compose，代码是兼容的，但技术上来讲是两个不同的实现。确切地说JetBrains的Compose是从谷歌的上面fork出来的一个分支，以让其更好的适用于CMP，但完全兼容，标准的Compose代码都是能正常跑的。</p>

<h2>把代码从「androidMain」移动到「commonMain」</h2>

<p>这是最关键的一步了，也是最难啃的硬骨头，具体的难度取决于项目中使用了多少「不兼容」的库和API。Compose和Jetpack中的绝大多数库都是支持的，可以在CMP中使用，可以无缝切换，这是JetBrains和Google共同努力的结果，谷歌现在对CMP/KMP的态度非常的积极，给与「第一优先支持（First class support）」。所以对于依赖于room，navigation，material和viewmodel的代码都可以直接移到common中。</p>

<p>也就是说对于data部分，model部分以及domain部分（即view models）都可以直接先移到common中，因为这些层，从架构角度来说都属于业务逻辑，都应该是平台独立的，它们的主要依赖应该是Jetpack以及三方的库，这些库大多也都可以直接跨平台。</p>

<p>当然，不可能这么顺利，因为或多或少会用到与平台强相关的API，比如最为常见的就是上下文对象（Context）以及像权限管理和硬件资源（如位置信息），这就需要用到平台定制机制（即expect/actual）来进行定制。</p>

<p>可能有同学会很奇怪，为啥UI层还不移动到common中，UI是用Compose写的啊，而Compose是可以直接在CMP上跑的啊。Compose写的UI确实可以直接跑，但UI必然会用到资源，必须 先把资源从android中移到common中，否则UI是跑不起来的。</p>

<h2>把资源转化成为CMP方式</h2>

<p>在前一篇文章<a href="https://juejin.cn/post/7439251025385996307">Compose大前端从上车到起飞</a>有讲过CMP用一个库resources来专门处理资源，规则与Android开发管理资源的方式很像，所以可以把UI用到的资源移动到common中的composeResources里面，就差不多了。</p>

<p>但需要特别注意，不要把全部的资源都从androidMain中移出，只需要把UI层用到的那部分资源移出即可。androidMain中至少要把Android强相关的资源留下，如应用的icon，应用的名字，以及一些关键的需要在manifest中使用的xml等。这是因为这些资源是需要在Android应用的配置文件AndroidManifest中使用的，所以必须还放在android源码集中。</p>

<p>资源文件移动好后，就可以把UI移动到common中了，最后一步就是使用CMP的资源类Res代替Android的资源类R即可。</p>

<p>到此，就完成了从Android项目到CMP项目的转变。</p>

<h2>添加并适配其他平台</h2>

<p>前面的工作做好后，再适配其他的平台就非常容易了，添加其他平台的target和入口（可以仿照CMP的demo），然后实现相关的expect接口即可。由此，一个大前端 项目就彻底大功告成了。</p>

<h2>总结</h2>

<p>CMP对项目结构中源码 集合 的限制 并不多，每个平台相关的sourceSet可以保持其原来的样子，这对现有项目是非常友好的，可以让现有的项目轻松的转成为CMP项目，这也是CMP最大的一个优势。</p>

<h2>References</h2>

<ul>
<li><a href="https://touchlab.co/compose-multiplatform-transition-guide">Jetpack Compose to Compose Multiplatform: Transition Guide</a></li>
<li><a href="https://stackoverflow.com/questions/71510247/how-to-convert-kotlin-project-to-kotlin-multiplatform-mobile-after-the-project-c">How to convert Kotlin project to Kotlin Multiplatform Mobile after the project completion?</a></li>
<li><a href="https://markonovakovic.medium.com/from-android-to-multiplatform-migrating-real-100-jetpack-compose-app-to-fully-multiplatform-app-2d65dc9e212e">From Android to Multiplatform: Migrating real 100% Jetpack Compose App to fully Multiplatform App. Intro</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compose大前端从上车到起飞]]></title>
    <link href="https://alexhilton.github.io/blog/2024/11/24/master-compose-multiplatform/"/>
    <updated>2024-11-24T08:45:46+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/11/24/master-compose-multiplatform</id>
    <content type="html"><![CDATA[<p>在前面的一篇文章<a href="https://juejin.cn/post/7436648335380496434">赶紧上车开启Compose大前端之路</a>中我们学习了CMP的基本概念以及如何创建一个CMP项目。今天将继续学习CMP，深入研究项目的配置方法，了解CMP的内部机制并总结一些CMP开发的最佳实践。</p>

<p><a href=""><img src="https://repository-images.githubusercontent.com/293498508/6469be07-159b-49de-9ffe-56340d5dfd07" title="auto auto" ></a></p>

<!-- more -->


<h2>深入了解项目结构</h2>

<p>CMP的基础结构与一个标准的Android应用的项目结构基本一样，只不过主module名字变成了「composeApp」。项目根目录下的build.gradle.kts是整个项目的配置，主要是指定使用的插件；settings.gradle.kts指定项目的依赖仓库，以及项目包含哪些module；gradle/wrapper/libs.version.toml定义着依赖的版本信息。模块「composeApp」包含着源码集合（source sets）以及一个build.gradle.kts，这是描述这个模块如何构建的脚本。</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/project-view.png" alt="图1. 项目结构" /></p>

<p>对于Android开发同学来说，这样的项目结构非常熟悉，事实上如果把项目视图切换到「Android」，就会发现，这比起常规的Android项目，无非就是多了一些源码集合。</p>

<p>仔细看一下源码集合「androidMain」它就是一个标准的Android项目，里面有AndroidManifest文件，以及一个入口MainActivity，它会调用「commonMain」中定义的composable App()，由此就进入到了「commonMain」中。</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/android-entry.png" alt="图2. Android源码关系" /></p>

<p>虽然并不在源码集合中，iosApp子目录其实是一个标准的Xcode项目，里面全是Xcode项目的配置文件，可以用Xcode直接打开。它是iOS应用的入口，它的调用顺序是iOSApp，到ContentView，这两个是标准的iOS的代码，用的是Swift。然后会进入到「iosMain」中的MainConntroller，这里就到了Kotlin地界了，MainController，再进入到common中的composable App()，由此进入了「commonMain」中。</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/ios-entry.png" alt="图3. iOS源码关系" /></p>

<h2>依赖配置方法</h2>

<p>现代的软件不可能全都是从零开始，有很多现成的代码库可以使用，这就需要为项目配置依赖。CMP中依赖配置方法与常规的Android略不一样，视依赖的使用，以及依赖的平台依赖性，需要分别针对不同的源码集合配置。</p>

<p>需要注意的就是依赖的作用域，如果是在commonMain中配置的，那就会对所有的平台生效；如果是为androidMain配置的依赖，只能在Android中生效，以次类推。</p>

<h3>在源码集合中配置依赖</h3>

<p>最直接的方式就是针对每个源码集合配置其依赖：</p>

<pre><code class="Kotlin">kotlin {
    sourceSets {
        commonMain.dependencies {
            implementation("com.example:my-library:1.0") // 所有平台共享的依赖
        }
    }
}
</code></pre>

<h3>在顶层DSL dependencies中配置</h3>

<p>除了在源码集合处配置依赖，也可以在顶层DSL dependencies中配置，本质都是一样的，只不过是方式略有不同。具体的格式是<strong> &lt;源码集合&gt;&lt;具体的依赖&gt; </strong>，比如上面酱紫写：</p>

<pre><code class="Kotlin">dependencies {
    "commonMainImplementation"("com.example:my-library:1.0")
}
</code></pre>

<p>这与像上面在源码集合commonMain中配置是一样的。在顶层配置依赖的好处在于这里可以配置一些源码集合中找不到的依赖，如testing等等。</p>

<h3>本地module如何相互依赖</h3>

<p>如果是本地的库（module），可以通过project方式引入，同样的如果是共享的库加在common里，如果是某个平台特有的，或者只想在某个平台使用就单独加到它上面：</p>

<pre><code class="Kotlin">kotlin {
    sourceSets {
        commonMain.dependencies {
            implementation(project(":some-other-multiplatform-module"))
        }
    }
}
</code></pre>

<h2>如何共享和定制代码</h2>

<p>CMP的终极目的是要尽可能的共享代码，让一套代码能够跑在多个平台上面。但现实的世界是不完美的，平台的差异是不可忽视的。像存储，I/O，硬件资源等等都是平台强相关的。我们只能尽可能多的共享我们自己写的业务逻辑，对于实现业务逻辑而需要的系统平台相关的API，肯定还是需要每个平台定制化的去实现。</p>

<p>CMP通过Kotlin中的关键字expect和actual来处理平台定制API。</p>

<p>具体的做法就是在common中定义一个用关键字expect修饰的类型（函数，类，接口枚举，属性等），然后在每个平台的源码集合中去具体实现，并用关键字actual来修饰。注意，这里的类型没有限制，可以是函数，可以是类/接口/枚举，也可以是属性，尽管绝大多数情况下都是函数。</p>

<p><img src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/expect-functions-properties.svg" alt="图4. 用expect和actual来定制API" /></p>

<p>可以理解为OO中的接口，但又不完全一样。区别在于，common中的expect函数不能有默认实现代码，并且函数的声明要在同一个包下面。编译的时候，编译器会用平台代码里面的actual去替换common中的expect函数。也就是说这是发生在编译时的行为，所以它要求包名和函数的签名完全一致。</p>

<h2>资源管理</h2>

<p>CMP是能构建跨平台UI的，而UI必然会涉及资源，最常见的资源就是图片和字符串，资源的复杂地方在于它会有限定属性，比如不同屏幕分辨率要用不同的图片，比如不同的地区语言要用不同的字符串，所以资源是相当复杂的，而且平台强相关。</p>

<p>为此CMP提供了一个专门的库用于管理资源，可以屏蔽平台特定，以统一的方式来管理资源。只需要在commonMain中引入依赖即可：</p>

<pre><code class="Kotlin">kotlin {
    sourceSets {
        commonMain.dependencies {
            implementation(compose.components.resources)
        }
    }
}
</code></pre>

<p>资源是放在commonMain中与kotlin同级别的目录中：</p>

<p><img src="https://resources.jetbrains.com/help/img/kotlin-multiplatform-dev/compose-resources-qualifiers.png" alt="图5. 资源文件管理" /></p>

<p>资源可以分为几种类型，图片应该放在子目录drawable中，字体资源放在fonts中，字符串放在values中，其他文件放在files中。</p>

<p>资源文件还可以有限定符以支持定制化，如屏幕分辨率（xhdpi，xxhdpi等），区域语言（en，zh-rCN等）和主题（dark，light等）。可以发现，规则与Android平台资源管理规则是非常接近的。</p>

<p>图片字体等直接添加文件即可，字符串的话放在一个xml文件中，根Tag是resources，每个字符串的Tag是string，如：</p>

<pre><code class="Kotlin">&lt;resources&gt;
    &lt;string name="app_name"&gt;My awesome app&lt;/string&gt;
    &lt;string name="title"&gt;Some title&lt;/string&gt;
&lt;/resources&gt;
</code></pre>

<p>需要注意资源的命名，与Android的资源规则一样，要是小写字符，可以有数字和下划线。</p>

<p>添加好资源后，编译插件会自动生成一个类Res，通过它就可以引用各种资源，如：</p>

<pre><code class="Kotlin">Image(
    painter = painterResource(Res.drawable.my_icon),
    contentDescription = null
)

Text(stringResource(Res.string.app_name))
</code></pre>

<h2>一些开发实践建议</h2>

<p>CMP是为了构建跨平台应用的，那么应该尽最大的可能去共享代码。虽然有平台定制机制，但只应该用它来定制细粒度的具体的API，而不是业务逻辑。比如说，从一个文件中读文本内容，不应该定义一个getFileContent，而是应该定制细粒度的openFile，closeFile和readLine，这是因为读取文件过程真正不同的是处理文件的API，除打开文件，读出每一行以外，其他的逻辑是一样的，应该共享。</p>

<p>还有，在写业务的时候要注意看Compose文档中以及Kotlin文档中API标注的平台范围，尽可能选择标记为「Common」或者「Cmn」的API。</p>

<p>另外，因为Kotlin是基于JVM的语言，标准JDK中的API都可以用，但在CMP的iOS（目标是Native）平台和Web（目标是Wasm）却无法使用JDK的API，所以我们应该多使用Kotlin标准库以及Kotlin扩展库（kotlinx），这些API都做了多平台适配。</p>

<h2>总结</h2>

<p>利益于Gradle中的源码集合，CMP对源码的结构是很宽容的，并没有严格的要求，这对于现有项目来说是相当友好的，因为把现有的项目源码搬进来就可以了，不用改太多，然后通过源码集合来做具体的指定和逻辑上的关系处理。每个源码集合其实都是其平台的一个标准项目，把common作为其依赖而已，关系就这么简单，甚至还可以用其平台的原生方式去写UI，写逻辑，这都是可以的。</p>

<p>虽然这样做貌似会失去共享代码和逻辑的意义，但是这对改造现有项目是十分友好的，比如第一步可能是把Android项目和iOS项目先融合进来，然后再慢慢的把两个平台的共享代码抽离出来入进common。这样做不但能慢慢推进跨端，每个项目各自仍是完整的，如果有紧急 的事情仍可先用原生方式去开发构建。</p>

<h2>References</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/multiplatform-add-dependencies.html">Adding dependencies on multiplatform libraries</a></li>
<li><a href="https://kotlinlang.org/docs/gradle-configure-project.html#configure-dependencies">Configure dependencies</a></li>
<li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/multiplatform-connect-to-apis.html">Use platform-specific APIs</a></li>
<li><a href="https://www.jetbrains.com/help/kotlin-multiplatform-dev/compose-multiplatform-resources.html">Resources overview</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
