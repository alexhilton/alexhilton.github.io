<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2025-10-16T20:12:27+08:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[突破速度障碍：非阻塞启动画面如何将Android 应用启动时间缩短90%]]></title>
    <link href="https://alexhilton.github.io/blog/2025/10/14/non-blocking-splash/"/>
    <updated>2025-10-14T22:41:32+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/10/14/non-blocking-splash</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Breaking the Speed Barrier: How Non-Blocking Splash Screens Cut Android App Launch Time by 90%」，原文链接<a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90">https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90</a>，由Sankalp Chauhan发布于2025年9月28日。</p></blockquote>

<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#overview">概述</a></h2>

<p>正值佳节期间，我们在每个应用上都能看到精美的启动画面和自定义徽标。在开发这些应用时，每个 Android 开发者都会面临启动画面的困境：用户期望获得美观且品牌化的启动体验，但 Google 原生的启动画面 API 却存在明显的局限性。创建自定义 <strong>SplashActivity</strong> 的常见解决方案看似合理，但却会引入隐藏的性能损失，导致应用运行缓慢且响应迟钝。</p>

<p><a href=""><img src="https://sankalpchauhan.com/2db6f13d4b8881938f2fccacd47ff90b/untitled-design-1-.mp4.gif" title="auto auto" ></a></p>

<!-- more -->


<p>为了应对这一挑战，我开发了一个名为<strong>EventSplash</strong>的测试库，该库实现了一种非阻塞启动画面方法。完整的实现和基准测试代码可在 GitHub 上获取：<a href="https://github.com/sankalpchauhan-me/fast-splash-experiment">fast-splash-experiment</a>（链接：<a href="https://github.com/sankalpchauhan-me/fast-splash-experiment%EF%BC%89%E3%80%82">https://github.com/sankalpchauhan-me/fast-splash-experiment%EF%BC%89%E3%80%82</a></p>

<p>本案例研究通过一项对照实验，比较了传统的基于活动的启动画面和创新的基于视图的启动画面方法，并提供了实证证据。使用<strong>保守的同类比较</strong>，结果显示：<strong>页面加载时间缩短 90%</strong>，<strong>首次内容绘制时间提升 78%</strong>，<strong>完全绘制时间缩短 41%</strong>。</p>

<p>我们将探索 Lottie 等复杂动画可能带来的显著优势，同时明确并发处理的利弊权衡和资源成本。</p>

<ul>
<li><strong>首次内容绘制 (FCP)</strong>：屏幕上出现第一个有意义内容的时间</li>
<li><strong>完全绘制时间 (FPT)</strong>：屏幕完全渲染并可交互的时间</li>
<li><strong>冷启动</strong>：应用在进程未运行时启动（性能影响最大）</li>
<li><strong>卡顿</strong>：用户认为性能不佳的卡顿或掉帧</li>
<li><strong>TTID/TTFD</strong>：初始显示时间/完全绘制时间（Android 官方指标）</li>
<li><strong>内存压力</strong>：可用内存极低时的系统状态</li>
<li><strong>低内存终止程序 (LMK)</strong>：在内存压力下终止进程的 Android 守护进程</li>
<li><strong>Choreographer.doFrame</strong>：Android 的帧协调系统，用于管理动画、输入和绘制</li>
</ul>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#the-problem-statement">问题声明</a></h3>

<p>Google 原生的 Android 12+ SplashScreen API 性能出色，但自定义选项有限 <a href="https://developer.android.com/develop/ui/views/launch/splash-screen">[1]</a>。它不支持：</p>

<ul>
<li>视频背景</li>
<li>Lottie 动画</li>
<li>复杂的品牌元素</li>
<li>促销/活动期间的促销内容</li>
<li>自定义过渡效果</li>
</ul>


<p>这迫使开发者不得不进行自定义实现，通常使用专用的“SplashActivity”。虽然这种方法提供了创作自由，但它会创建一个<strong>阻塞序列</strong>，从而延迟应用主内容的显示。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#why-traditional-splash-activities-hurt-performance">为什么传统的闪屏活动会损害性能</a></h3>

<p>Android 文档强调，应用应该针对冷启动进行优化，因为这“也可以提高温启动和热启动的性能”<a href="https://developer.android.com/topic/performance/vitals/launch-time">[2]</a>。然而，传统的闪屏实现方式违背了这一原则。</p>

<p>当你使用单独的“SplashActivity”时，系统必须：</p>

<ol>
<li>创建并初始化启动画面 Activity</li>
<li>扩展启动画面视图</li>
<li>运行启动画面动画直至完成</li>
<li>销毁启动画面 Activity</li>
<li>创建并初始化主 Activity</li>
<li>扩展主内容视图</li>
</ol>


<p>这种顺序流程意味着你的主内容在启动画面完成之前无法开始加载，这是一个影响用户感知性能的根本架构缺陷。</p>

<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#the-journey-exploring-different-approaches">折腾：探索不同的方法</a></h2>

<p>在最终确定 EventSplash 实现方案之前，我探索了几种方法。了解这些探索为最终的设计决策提供了宝贵的背景，并展示了性能优化的迭代本质。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#discarded-approach-the-translucent-activity-overlay">弃用的方法：半透明 Activity 覆盖</a></h3>

<p>最初的想法是使用带有半透明主题的“SplashActivity”覆盖“MainActivity”。理论上，MainActivity 可以在后台加载，而启动画面则显示在最上面。</p>

<p><strong>启动顺序：</strong></p>

<ol>
<li>应用以具有半透明主题的 SplashActivity 启动</li>
<li>SplashActivity 显示在 MainActivity 之上，但不会完全遮挡 MainActivity</li>
<li>短暂延迟或初始化完成后，SplashActivity 结束，MainActivity 显露出来</li>
</ol>


<p><strong>弃用原因：</strong></p>

<p>这种方法导致<strong>14% 的性能下降</strong>。问题在于 Android 处理 Activity 生命周期和渲染的方式。系统并非真正并行启动两个 Activity。相反，它创建了一种顺序依赖关系，GPU 被迫组合两个独立的 Activity 缓冲区，这会在 RAM 和电池方面造成巨大的开销，有时甚至会禁用窗口过渡动画。</p>

<p>正如 Android 文档中关于半透明 Activity 的说明 <a href="https://medium.com/androiddevelopers/the-android-lifecycle-cheat-sheet-part-iv-49946659b094">[3]</a>：</p>

<blockquote><p>“窗口管理器会保持原先的屏幕表面按 Z 轴顺序排列，并将新的屏幕表面混合在其上方。原先的 Activity 仍然可以通过新窗口中任何透明或部分透明的像素看到。”</p></blockquote>

<p>正是这种混合操作导致了性能下降。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#the-winning-approach-the-gated-splash-screen-mechanism">制胜之道：门控启动画面机制</a></h3>

<p>我最终找到了一种更复杂的方法，它采用了<strong>门控启动画面机制</strong>。此方法使用“ViewTreeObserver.OnPreDrawListener”来阻止所有 UI 渲染，直到满足特定条件为止。</p>

<p><strong>工作原理：</strong></p>

<ol>
<li>启动时，会立即将 <code>OnPreDrawListener</code> 附加到 Activity 的 <code>decorView</code> 上。</li>
<li>监听器的 <code>onPreDraw()</code> 方法返回 <code>false</code>，从而有效阻止所有绘制操作。</li>
<li>监听器仅在所有条件都满足时才返回 <code>true</code>，允许内容渲染。</li>
</ol>


<p><strong>关键实现：</strong></p>

<pre><code class="kotlin">// The gate mechanism

gate.onPreDraw() → returns false = BLOCK all drawing

gate.onPreDraw() → returns true = ALLOW drawing to proceed
</code></pre>

<p>这种方法完全符合 Android 官方文档中关于延长启动画面在屏幕上停留时间的建议 <a href="https://developer.android.com/develop/ui/views/launch/splash-screen">[1]</a>:</p>

<blockquote><p>“如果你需要加载少量数据，例如从本地磁盘异步加载应用内设置，可以使用 ViewTreeObserver.OnPreDrawListener 暂停应用以绘制其第一帧。”</p></blockquote>

<p>EventSplash 库扩展了这一概念，在应用启动时提供对用户可见内容的帧完美控制，防止任何内容闪烁，确保无缝体验。</p>

<p><img src="https://sankalpchauhan.com/static/6810168ee26fb4ae7c236e03fbdd71bc/e5715/view-hirearchy.png" alt="DecorView 将包含我们的 SplashView 和 ContentView" /></p>

<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#the-experiment-measuring-real-world-impact">实验：测量实际影响</a></h2>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#test-environment">测试环境</a></h3>

<ul>
<li><strong>设备</strong>：小米 POCO F1，Android 10</li>
<li><strong>构建</strong>：发布配置</li>
<li><strong>方法</strong>：每个配置 35 次冷启动，每次运行之间暂停 2 秒</li>
<li><strong>指标</strong>：自定义 PerfTracker 库，用于测量页面加载时间、FCP 和 FPT</li>
<li><strong>脚本</strong>：通过 <code>perf_loop.sh</code> 自动执行可重复性</li>
</ul>


<p>所有测试代码和脚本均可在 <a href="https://github.com/sankalpchauhan-me/fast-splash-experiment">GitHub 代码库</a> （链接：<a href="https://github.com/sankalpchauhan-me/fast-splash-experiment%EF%BC%89%E8%8E%B7%E5%8F%96%EF%BC%8C%E4%BB%A5%E7%A1%AE%E4%BF%9D%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7%E3%80%82">https://github.com/sankalpchauhan-me/fast-splash-experiment%EF%BC%89%E8%8E%B7%E5%8F%96%EF%BC%8C%E4%BB%A5%E7%A1%AE%E4%BF%9D%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%80%A7%E3%80%82</a></p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#implementation-approaches-tested">测试的实现方法</a></h3>

<ol>
<li><strong>默认阻塞闪屏</strong>：简单的 <code>SplashActivity</code> 和基本路由（保守的基准）</li>
<li><strong>默认非阻塞闪屏</strong>：EventSplash 库和简单的叠加层</li>
<li><strong>Lottie 阻塞闪屏</strong>：传统方法和复杂的动画</li>
<li><strong>Lottie 非阻塞闪屏</strong>：EventSplash 与 Lottie 动画并行运行</li>
</ol>


<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#results-conservative-claims-with-dramatic-potential">结果：保守的声明，但效果显著潜力</a></h2>

<p><img src="https://sankalpchauhan.com/static/b4c51a8a6d8ebb0f3f12161c0441e89d/e5715/performance_comparison.png" alt="性能对比" /></p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#the-honest-comparison-default-splash-performance">真实对比：默认闪屏性能</a></h3>

<p>为了进行<strong>同类比较</strong>，我们重点关注在默认的闪屏实现中，阻塞方法只是简单地为了路由目的而扩大 Activity：</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 方法 </th>
<th style="text-align:center;"> 页面加载时间 (毫秒) </th>
<th style="text-align:center;"> FCP (毫秒) </th>
<th style="text-align:center;"> FPT (毫秒) </th>
<th style="text-align:center;"> 用户影响 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> <strong>默认阻塞</strong> </td>
<td style="text-align:center;"> 366 </td>
<td style="text-align:center;"> 744 </td>
<td style="text-align:center;"> 2,195 </td>
<td style="text-align:center;"> 明显的延迟 </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>默认非阻塞</strong> </td>
<td style="text-align:center;"> 37 </td>
<td style="text-align:center;"> 164 </td>
<td style="text-align:center;"> 1,295 </td>
<td style="text-align:center;"> 流畅、响应迅速 </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>提升</strong> </td>
<td style="text-align:center;"> <strong>90%</strong> </td>
<td style="text-align:center;"> <strong>78%</strong> </td>
<td style="text-align:center;"> <strong>41%</strong> </td>
<td style="text-align:center;"> <strong>显著提升</strong> </td>
</tr>
</tbody>
</table>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#the-lottie-animation-advantage">Lottie 动画的优势</a></h3>

<p>当我们引入复杂的 Lottie 动画时，架构上的差异会更加明显发音：</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 方法 </th>
<th style="text-align:center;"> 页面加载时间 (毫秒) </th>
<th style="text-align:center;"> FCP (毫秒) </th>
<th style="text-align:center;"> FPT (毫秒) </th>
<th style="text-align:center;"> 备注 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> <strong>Lottie 阻塞</strong> </td>
<td style="text-align:center;"> 2,228 </td>
<td style="text-align:center;"> 2,347 </td>
<td style="text-align:center;"> 3,524 </td>
<td style="text-align:center;"> <em>包含动画时长</em> </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>Lottie 非阻塞</strong> </td>
<td style="text-align:center;"> 109 </td>
<td style="text-align:center;"> 312 </td>
<td style="text-align:center;"> 1,467 </td>
<td style="text-align:center;"> <em>动画并行运行</em> </td>
</tr>
<tr>
<td style="text-align:center;"> <strong>提升</strong> </td>
<td style="text-align:center;"> <strong>95%</strong> </td>
<td style="text-align:center;"> <strong>87%</strong> </td>
<td style="text-align:center;"> <strong>58%</strong> </td>
<td style="text-align:center;"> <strong>显著提升</strong> </td>
</tr>
</tbody>
</table>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#understanding-the-lottie-numbers">理解 Lottie 数值</a></h3>

<p><strong>重要提示</strong>：Lottie 阻塞数值在设计上包含动画时长，用户必须等待整个动画完成后才能看到任何主要内容。在非阻塞方法中，<strong>动画和内容加载并行运行</strong>，因此当 Lottie 动画完成时，FPT 通常已经完成或接近完成。</p>

<p>这种并行执行是其关键的架构优势：<strong>无需牺牲性能即可获得精美的动画</strong>。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#performance-improvements-breakdown">性能改进细分</a></h3>

<p><img src="https://sankalpchauhan.com/static/620f7ce36b7f1d75840820adb257fa7f/e5715/improvement_chart.png" alt="改进图表" />
改进图表</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#recap-what-happened">回顾：发生了什么</a></h3>

<p>即使与保守的默认启动画面相比，非阻塞方法也实现了<strong>90% 的页面加载速度提升次</strong>。用户体验从“明显的延迟”转变为“流畅且响应迅速”。</p>

<p>对于像 Lottie 这样的复杂动画，其优势更加显著，因为传统方法迫使用户等待整个动画序列，然后才会出现任何有意义的内容。</p>

<p><img src="https://sankalpchauhan.com/6f6ac6fcfed426f343bb76cd31f4694e/comparison.mp4.gif" alt="旧用户体验与新用户体验对比" /></p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#why-the-technical-mechanism">原因：技术机制</a></h3>

<p>性能提升源于<strong>并行执行</strong>。传统方法<strong>顺序</strong>运行启动画面和主内容，而基于视图的方法<strong>并发</strong>运行它们：</p>

<p><strong>传统（顺序）</strong>：</p>

<pre><code class="css">Splash Activity → Animation → Destroy → Main Activity → Content Load → Display
</code></pre>

<p><strong>非阻塞（并行）</strong>：</p>

<pre><code class="css">Main Activity + Content Load (background)
     ↓
Splash View (overlay) → Remove overlay → Display loaded content
</code></pre>

<p>这种架构差异彻底消除了阻塞瓶颈。</p>

<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#deep-dive-understanding-the-technical-implementation">深入探究：理解技术实现</a></h2>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#traditional-splash-activity-implementation">传统的 Splash Activity 实现</a></h3>

<pre><code class="kotlin">class SplashActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        installSplashScreen()
        enableEdgeToEdge()
        setContent {
            Loader { // Blocks until animation completes
                startActivity(Intent(this@SplashActivity, MainActivity::class.java))
            }
        }
    }

    @Composable
    fun Loader(onComplete: () -&gt; Unit) {
        val composition by rememberLottieComposition(LottieCompositionSpec.RawRes(R.raw.sale_tags))
        val progress by animateLottieCompositionAsState(composition)

        // Animation blocks main content loading
        if (progress == 1.0f) {
            onComplete.invoke()
        }
    }
}
</code></pre>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#event-splash-non-blocking-implementation">EventSplash：非阻塞实现</a></h3>

<pre><code class="kotlin">class EventSplash(
    private val activity: ComponentActivity,
    private val config: EventSplashConfig,
) {
    private val decorView: ViewGroup = activity.window.decorView as ViewGroup
    private var composeView: ComposeView? = null

    // Gate prevents premature display until main content ready
    private val gate = object : ViewTreeObserver.OnPreDrawListener {
        override fun onPreDraw(): Boolean {
            return if (isReady) {
                decorView.viewTreeObserver.removeOnPreDrawListener(this)
                true
            } else false
        }
    }

    init {
        decorView.viewTreeObserver.addOnPreDrawListener(gate)
        setupSplashCompose() // Non-blocking overlay
        isReady = true
    }

    private fun setupSplashCompose() {
        val view = ComposeView(activity).apply {
            layoutParams = ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)
            setContent {
                getProvider(config).Content(onFinish = { dismiss() })
            }
        }
        composeView = view
        decorView.addView(view) // Overlay on main content
    }
}
</code></pre>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#usage-comparison">使用情况比较</a></h3>

<p><strong>传统方法</strong>:</p>

<pre><code class="kotlin">// Requires separate activity, blocks main content
class MainActivity : ComponentActivity() {
    // Main content only loads after splash completes
}
</code></pre>

<p><strong>EventSplash 方法</strong>:</p>

<pre><code class="kotlin">class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // Non-blocking: splash displays while content loads
        EventSplashApi.attachTo(this).with(getSaleConfig()).show()

        setContent {
            // Main content loads immediately in parallel
            MainAppContent()
        }
    }
}
</code></pre>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#recap-implementation-differences">回顾：实现差异</a></h3>

<p>传统方法需要单独的 Activity 生命周期，而 EventSplash 会注入一个与主内容加载过程共存的视图叠加层。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#why-architectural-advantages">原因：架构优势</a></h3>

<ol>
<li><strong>单一 Activity 上下文</strong>：消除 Activity 转换开销</li>
<li><strong>并行处理</strong>：主内容在启动画面显示时加载</li>
<li><strong>减少内存占用</strong>：没有重复的 Activity 对象</li>
<li><strong>减少 Choreographer.doFrame 循环</strong>：减少渲染管线压力</li>
<li><strong>优化视图层级</strong>：使用单一装饰视图，而非多个独立的 Activity</li>
</ol>


<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#the-choreographer-do-frame-problem">Choreographer.doFrame 问题</a></h2>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#understanding-frame-rendering-issues">理解帧渲染问题</a></h3>

<p>Android 的渲染系统依赖于 <code>Choreographer.doFrame</code> 来协调动画、输入和绘制 <a href="https://developer.android.com/topic/performance/vitals/render">[4]</a>。文档警告：</p>

<blockquote><p>“如果 Systrace 显示 Choreographer#doFrame 的布局部分工作过多或过于频繁，则意味着你遇到了布局性能问题”</p></blockquote>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#why-splash-activities-cause-jank">为什么闪屏 Activity 会导致卡顿</a></h3>

<p>传统的闪屏实现会造成多个性能瓶颈：</p>

<ol>
<li><strong>双重布局传递</strong>：每个 Activity 都需要单独的视图填充和布局</li>
<li><strong>上下文切换开销</strong>：操作系统必须管理多个 Activity 上下文</li>
<li><strong>内存压力</strong>：重复的视图层次结构会消耗额外的 RAM</li>
<li><strong>帧时序问题</strong>：Activity 转换会触发额外的 doFrame 周期</li>
</ol>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#perfetto-analysis-insights">Perfetto 分析洞察</a></h3>

<p>使用 Perfetto 分析轨迹时，传统的启动画面会显示：</p>

<ul>
<li><code>Choreographer.doFrame</code> 执行时间延长</li>
<li>布局膨胀多次峰值</li>
<li>垃圾回收压力增加</li>
<li>主线程可用性延迟</li>
</ul>


<p>基于视图的方法通过在整个启动过程中维护单一渲染上下文来消除这些问题。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#critical-consideration-concurrent-processing-isnt-free">⚠️ 关键考虑：并发处理并非免费</a></h3>

<p>虽然我们的结果显示性能显著提升，但<strong>非阻塞方法也带来了一系列挑战</strong>，必须仔细考虑。同时运行启动动画和主内容加载会带来额外的资源压力，而顺序加载方法则不会出现这种压力。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#memory-pressure-the-primary-concern">内存压力：主要问题</a></h3>

<p><strong>峰值内存使用量增加</strong>：</p>

<pre><code class="nix">// Memory usage pattern comparison
Traditional Approach:
Splash: 50MB → 0MB → Main Content: 120MB = Peak: 120MB

Non-blocking Approach:  
Splash + Main Content: 50MB + 120MB = Peak: 170MB
</code></pre>

<p><strong>实际影响</strong>：</p>

<ul>
<li><strong>简单的闪屏叠加</strong>在并发执行期间会增加 20-50MB 的内存</li>
<li><strong>Lottie 动画</strong>在渲染期间可能会消耗 50-100MB 以上的内存</li>
<li><strong>综合峰值使用量</strong>可能比顺序加载方法高出 40-70%</li>
<li><strong>低端设备</strong>（1-2GB RAM）容易受到内存压力的影响</li>
</ul>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#low-memory-killer-risk">低内存杀手风险</a></h3>

<p>Android 的低内存终止守护进程会监控系统内存，并可能在压力下终止应用 <a href="https://source.android.com/docs/core/perf/lmkd">[5]</a>:</p>

<blockquote><p>“内存压力是指系统内存不足的状态，需要 Android 通过限制或终止不重要的进程来释放内存”</p></blockquote>

<p><strong>风险因素</strong>:</p>

<ul>
<li>启动过程中终止应用进程会导致糟糕的用户体验</li>
<li>后台应用被更频繁地终止</li>
<li>并发分配导致的内存碎片</li>
<li>在预算设备上尤其成问题</li>
</ul>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#cpu-and-battery-implications">CPU 和电池影响</a></h3>

<p><strong>CPU 开销增加</strong>：</p>

<ul>
<li><code>Choreographer.doFrame</code> 处理多个并发操作</li>
<li>主线程因 UI 工作重叠而变得更加繁忙</li>
<li>GPU 渲染管线同时处理启动画面和内容</li>
</ul>


<p><strong>功耗问题</strong>：研究表明，“智能手机上的 UI 渲染需要强大的 CPU 和 GPU 才能满足用户感知的流畅度，并且这占了相当一部分的功耗”<a href="https://www.sciencedirect.com/science/article/abs/pii/S1383762122001540">[6]</a>。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#device-compatibility-challenges">设备兼容性挑战</a></h3>

<p><strong>低端设备注意事项</strong>:</p>

<ul>
<li>单核或双核处理器难以并行化</li>
<li>有限的 RAM 使得内存压力至关重要</li>
<li>较慢的存储速度加剧加载延迟</li>
<li>优势可能无法转化为低端设备的优势</li>
</ul>


<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#when-not-to-use-non-blocking-approach">何时不应使用非阻塞方法</a></h2>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#scenarios-where-traditional-approach-may-be-better">传统方法可能更佳的场景：</a></h3>

<ol>
<li><strong>资源极其受限的设备</strong>（&lt; 2GB RAM）</li>
<li><strong>电池关键型应用</strong>，功耗至关重要</li>
<li><strong>简单的启动画面</strong>，没有复杂的动画</li>
<li><strong>启动处理繁重的应用</strong>，已经给应用带来了压力系统</li>
<li><strong>遗留代码库</strong>，重构风险大于收益</li>
</ol>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#risk-mitigation-strategies">风险缓解策略</a></h3>

<p><strong>自适应实施</strong>：</p>

<pre><code class="kotlin">class AdaptiveSplashStrategy {
    fun chooseSplashApproach(): SplashConfig {
        return when {
            isLowEndDevice() -&gt; SimpleSplashConfig()
            isBatteryLow() -&gt; ReducedAnimationConfig()
            isHighPerformanceDevice() -&gt; FullLottieConfig()
            else -&gt; DefaultConfig()
        }
    }

    private fun isLowEndDevice(): Boolean {
        val activityManager = getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
        return activityManager.isLowRamDevice || 
               Runtime.getRuntime().maxMemory() &lt; 256 * 1024 * 1024
    }
}
</code></pre>

<p><strong>内存监控</strong>：</p>

<pre><code class="kotlin">private fun monitorMemoryPressure() {
    val memoryInfo = ActivityManager.MemoryInfo()
    activityManager.getMemoryInfo(memoryInfo)

    if (memoryInfo.lowMemory) {
        // Fallback to simpler splash
        simplifyOrDismissSplash()
    }
}
</code></pre>

<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#industry-context-and-validation">行业背景和验证</a></h2>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#alignment-with-industry-best-practices">与行业最佳做法保持一致实践</a></h3>

<p>EventSplash 方法符合最新的行业趋势和官方建议。像 Turo 这样的公司通过消除专用的启动活动也取得了类似的效果。正如他们的案例研究 <a href="https://medium.com/androiddevelopers/turo-reduced-its-app-startup-time-by-77-using-android-developer-tools-and-best-practices-bcf82f596bcf">[7]</a> 中所述：</p>

<blockquote><p>“最初，我们使用专用的 SplashActivity 来运行所有启动工作，然后再将应用路由到 HomeActivity。然而，最新的指南建议不要采用这种方法。因此，我们移除了多余的 SplashActivity，并将所有启动逻辑转移到了根 Activity。”</p></blockquote>

<p>Turo 使用类似的原理实现了<strong>77% 的启动时间缩短</strong>。</p>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#validation-through-official-documentation">通过官方文档验证</a></h3>

<p>Android 官方文档明确建议使用“ViewTreeObserver.OnPreDrawListener”进行启动画面管理，<a href="https://developer.android.com/develop/ui/views/launch/splash-screen">[1]</a>，这进一步验证了该方法，而这正是 EventSplash 的核心实现。</p>

<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#best-practices-and-common-pitfalls">最佳实践和常见陷阱</a></h2>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#dos">建议✅</a></h3>

<ul>
<li>在性能强大的设备上，<strong>使用基于视图的启动画面实现</strong>自定义动画</li>
<li>根据设备性能<strong>实施自适应策略</strong></li>
<li>使用真实设备**测量性能，并跨设备层级发布版本</li>
<li>监控内存使用情况**并实施内存泄漏预防</li>
<li>针对最坏情况进行冷启动优化</li>
<li>在低端设备上进行广泛测试**以确保广泛的兼容性</li>
<li><strong>为启动画面实施适当的生命周期管理</strong></li>
</ul>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#donts">注意事项❌</a></h3>

<ul>
<li><strong>不要想当然地认为一刀切</strong>：设备性能差异巨大</li>
<li><strong>不要忽视内存压力</strong>：监控并适应系统限制</li>
<li><strong>不要在未考虑替代方案的情况下使用单独的 SplashActivity</strong></li>
<li><strong>不要用启动画面动画阻碍主内容加载</strong></li>
<li><strong>不要忽略 Play 管理中心内的 Android Vitals 指标</strong></li>
<li><strong>不要只在高端设备</strong>或调试版本上进行测试</li>
<li><strong>不要在启动画面中创建复杂的视图层次结构</strong></li>
<li><strong>不要在启动画面中执行繁重的操作</strong></li>
<li><strong>不要忘记清理启动画面</strong>并清除缓存</li>
</ul>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#common-pitfalls">常见陷阱</a></h3>

<ol>
<li><strong>内存泄漏</strong>：未能清除 LottieCompositionCache</li>
<li><strong>设备能力假设</strong>：未适应低端设备限制</li>
<li><strong>生命周期问题</strong>：未正确处理 Activity 状态变化</li>
<li><strong>动画冲突</strong>：闪屏动画干扰主内容</li>
<li><strong>测试偏差</strong>：仅在快速设备或调试版本上进行测试</li>
<li><strong>指标误解</strong>：关注动画时长而非用户感知的性能</li>
<li><strong>资源监控疏忽</strong>：未监控内存和 CPU 使用模式</li>
</ol>


<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#making-informed-architectural-decisions">制定明智的架构决策</a></h2>

<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#decision-framework">决策框架</a></h3>

<p>在选择启动画面方案时，请考虑以下因素：</p>

<p><strong>设备受众特征</strong>：</p>

<ul>
<li>你的用户中有多少比例使用低端设备？</li>
<li>你支持的最低 RAM 配置是多少？</li>
<li>你是否瞄准了拥有廉价设备的新兴市场？</li>
</ul>


<p><strong>应用特性</strong>：</p>

<ul>
<li>你的主要内容加载复杂度如何？</li>
<li>你是否对网络依赖性很强？</li>
<li>你当前的内存占用是多少？</li>
</ul>


<p><strong>业务需求</strong>：</p>

<ul>
<li>自定义启动动画对你的品牌有多重要？</li>
<li>你能实现渐进式增强吗？</li>
<li>你的开发和测试能力如何？</li>
</ul>


<h3><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#recommended-strategy">推荐策略</a></h3>

<p><strong>渐进式增强方法</strong>：</p>

<pre><code class="kotlin">EventSplashApi.attachTo(this)
    .withFallback(SimpleSplashConfig())
    // Low-end devices
    .withStandard(ImageSplashConfig())
    // Mid-range devices
    .withEnhanced(LottieConfig())
    // High-end devices
    .adaptToDevice()
    // Automatic selection
    .show()
</code></pre>

<p>此方法提供：</p>

<ul>
<li>适用于所有设备的<strong>基本功能</strong></li>
<li>在资源允许的情况下<strong>增强体验</strong></li>
<li>根据设备性能<strong>自动适配</strong></li>
<li>在内存压力下<strong>优雅降级</strong></li>
</ul>


<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#insights-recommendations">见解与建议</a></h2>

<p>非阻塞启动画面方法<strong>显著提升性能</strong>（保守测试中页面加载速度提升 90%，复杂动画下最高可达 95%），但也存在一些不足。<strong>并发处理会增加峰值内存使用量和 CPU 开销</strong>，这在低端设备上可能会造成问题。</p>

<p><strong>关键见解</strong>：其优势显著且可衡量，但也伴随着资源成本，必须通过自适应的实施策略进行管理。</p>

<p><strong>诚挚建议</strong>：使用非阻塞方法并结合设备感知回退机制。即使是保守估计，也能显​​示出显著的性能提升，其架构优势也令人信服。然而，该实现必须足够复杂，才能支持所有 Android 设备。</p>

<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#conclusion">结论</a></h2>

<p>_本案例研究表明，性能优化需要在保持诚实声明的同时平衡相互竞争的约束条件。非阻塞、基于视图的方法提供了显著且可衡量的优势，但成功实施需要深入了解其收益和成本。</p>

<p>通过摆脱传统的“SplashActivity”模式，采用更复杂、更并发的架构，我们可以构建速度更快、响应更灵敏的 Android 应用，并在整个生态系统中可靠地运行。</p>

<p><strong>我们的目标不仅仅是构建更快的应用，而是构建使用体验即时、愉悦的应用，因为最终，性能是用户能够注意到并欣赏的功能。</strong></p>

<h2><a href="https://sankalpchauhan.com/breaking-the-speed-barrier-how-non-blocking-splash-screens-cut-android-app-launch-time-by-90#references">参考</a></h2>

<ol>
<li><a href="https://developer.android.com/develop/ui/views/launch/splash-screen">闪屏 | 视图 | Android 开发者</a></li>
<li><a href="https://developer.android.com/topic/performance/vitals/launch-time">应用启动时间 | 应用质量 | Android 开发者</a></li>
<li><a href="https://medium.com/androiddevelopers/the-android-lifecycle-cheat-sheet-part-iv-49946659b094">Android 生命周期速查表 — 第四部分：ViewModel、半透明 Activity 和启动模式 | 作者：Jose Alcérreca</a></li>
<li><a href="https://developer.android.com/topic/performance/vitals/render">渲染缓慢 | 应用质量 | Android 开发者</a></li>
<li><a href="https://source.android.com/docs/core/perf/lmkd">低内存终止守护进程 (lmkd) | Android 开源项目</a></li>
<li><a href="https://www.sciencedirect.com/science/article/abs/pii/S1383762122001540">移动 UI 渲染功耗研究</a></li>
<li><a href="https://medium.com/androiddevelopers/turo-reduced-its-app-startup-time-by-77-using-android-developer-tools-and-best-practices-bcf82f596bcf">Turo 利用 Android 开发者工具和最佳实践将其应用启动时间缩短了 77%</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为什么你的App总是忘记所有事情]]></title>
    <link href="https://alexhilton.github.io/blog/2025/07/11/app-keep-forgetting/"/>
    <updated>2025-07-11T23:20:20+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/07/11/app-keep-forgetting</id>
    <content type="html"><![CDATA[<p>本文译自「Why Your App Keeps Forgetting Everything」，原文链接<a href="https://medium.com/mobile-app-development-publication/why-your-app-keeps-forgetting-everything-aa9ad8dd8f6b">https://medium.com/mobile-app-development-publication/why-your-app-keeps-forgetting-everything-aa9ad8dd8f6b</a>，由Android Dev Nexus发布于2025年6月13日。</p>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OqqSvUytY9D0D4EIX_Cn0A.png" title="auto auto" ></a></p>

<!-- more -->


<p>不知你有没有发现了一个让许多 Android 开发者困惑的关键问题：ViewModel 和 savedInstanceState 解决的是不同的问题，并且拥有不同的生命周期。</p>

<p>让我来解释一下你的测试中究竟发生了什么，以及为什么这两种机制都存在。</p>

<h2>Android 中的两种“死亡”类型</h2>

<p>Android 应用可以通过两种截然不同的方式“死亡”：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*1-DtrKgBiEVyWj0RgbaNoQ.png" alt="" /></p>

<h3>1. 配置变更（屏幕旋转等）</h3>

<ul>
<li>Activity/Fragment：死亡并重建</li>
<li>ViewModel：幸存！🎉</li>
<li>savedInstanceState：也幸存，但此时你并不需要它</li>
</ul>


<h3>2. 进程死亡（应用最小化、内存不足等）</h3>

<ul>
<li>Activity/Fragment：死亡</li>
<li>ViewModel：也死亡！💀</li>
<li>savedInstanceState：幸存并成为你的生命线</li>
</ul>


<h2>测试结果不撒谎</h2>

<pre><code class="Kotlin">// 进程死亡时会发生什么:

// 最小化应用程序之前:
class MyViewModel : ViewModel() {
    var userData = "Important data"
    var counter = 42
}
// 重新打开应用程序后:
// - 新的 ViewModel 实例已创建（旧数据已消失）
// - 但是 onCreate() 接收了已保存数据的 savedInstanceState 包
// - 你需要手动从 savedInstanceState 恢复 ViewModel
</code></pre>

<p>你猜测的完全正确：ViewModel 需要额外的步骤来存储/恢复数据，即使进程终止。</p>

<h2>完整的解决方案：两者结合</h2>

<p>以下是现代 Android 开发处理这个双层系统的方法：</p>

<pre><code class="Kotlin">class MainActivity : AppCompatActivity() {
    private lateinit var viewModel: MyViewModel

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        viewModel = ViewModelProvider(this)[MyViewModel::class.java]

        // 检查我们是否正在从进程死亡中恢复
        if (savedInstanceState != null &amp;&amp; viewModel.isEmpty()) {
            // 从 savedInstanceState 恢复 ViewModel
            val userData = savedInstanceState.getString("user_data", "")
            val counter = savedInstanceState.getInt("counter", 0)
            viewModel.restoreFromSavedState(userData, counter)
        }
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        // 保存关键的 ViewModel 数据以避免进程死亡
        outState.putString("user_data", viewModel.userData)
        outState.putInt("counter", viewModel.counter)
    }
}

class MyViewModel : ViewModel() {
    var userData: String = ""
    var counter: Int = 0

    fun isEmpty(): Boolean = userData.isEmpty() &amp;&amp; counter == 0

    fun restoreFromSavedState(userData: String, counter: Int) {
        this.userData = userData
        this.counter = counter
    }
}
</code></pre>

<h2>当每个机制生效时</h2>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*dmQnYfNrJik_bbpuNT7bzQ.png" alt="" /></p>

<p>让我来向你展示一下不同场景下的具体情况：</p>

<h3>场景 1：屏幕旋转</h3>

<pre><code class="Bash">Before rotation: 
- ViewModel: Alive with data ✅ 
- savedInstanceState: Gets saved but not really needed 

After rotation: 
- ViewModel: Same instance, data intact ✅ 
- savedInstanceState: Available but redundant 
- Result: ViewModel data is immediately available
</code></pre>

<h3>场景2：应用程序最小化→重新打开（进程死亡）</h3>

<pre><code class="Bash">Before minimizing: 
- ViewModel: Alive with data ✅ 
- onSaveInstanceState(): Saves critical data to Bundle
After reopening:
- ViewModel: NEW instance, no data ❌
- savedInstanceState: Contains saved data ✅
- Result: Must restore ViewModel from savedInstanceState
</code></pre>

<h3>场景 3：应用程序最小化 → 重新打开（进程存活）</h3>

<pre><code class="Bash">Before minimizing: 
- ViewModel: Alive with data ✅
After reopening:
- ViewModel: Same instance, data intact ✅
- savedInstanceState: null (no recreation happened)
- Result: ViewModel data is immediately available
</code></pre>

<h2>那么，为什么存在这个双层系统？</h2>

<p>ViewModel 处理常见情况：</p>

<ul>
<li>复杂的 UI 状态，你不希望在频繁旋转屏幕时丢失。</li>
<li>任何需要耗费大量资源重新创建的内容。</li>
</ul>


<p>savedInstanceState 处理特殊情况：</p>

<ul>
<li>进程死亡难以预测。但当它发生时，用户希望其状态能够持久保存。</li>
<li>小而关键的数据片段（例如用户输入、滚动位置）。</li>
<li>简单的 UI 状态，对用户体验至关重要。</li>
</ul>


<h2>Bundle 大小的现实检验</h2>

<p>以下是一些可以帮你免去调试麻烦的事情：Bundle 并非无限大的存储空间。你大约有 1MB 的空间可用，超过这个限制会导致
崩溃，让你质疑自己的人生选择。</p>

<p>保持 onSavedInstanceState 数据精简。保存用户写到一半的电子邮件草稿，而不是整个联系人列表。</p>

<h2>现代方法：SavedStateHandle</h2>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ThuE7YpnrtfFQe2fwDlbDg.png" alt="" /></p>

<p>Google 意识到这种手动操作非常繁琐，因此他们创建了 SavedStateHandle ：</p>

<pre><code class="Kotlin">class MyViewModel(private val savedStateHandle: SavedStateHandle) : ViewModel() {

    // 这将自动保留配置更改和进程终止！
    var userData: String
        get() = savedStateHandle.get&lt;String&gt;("user_data") ?: ""
        set(value) = savedStateHandle.set("user_data", value)

    var counter: Int
        get() = savedStateHandle.get&lt;Int&gt;("counter") ?: 0
        set(value) = savedStateHandle.set("counter", value)

    // 无需手动恢复！
}
</code></pre>

<h2>对于以下情况，为什么仍然需要手动 onSaveInstanceState？</h2>

<h3>1. 不属于 ViewModel 的 UI 特定状态</h3>

<pre><code class="Kotlin">override fun onSaveInstanceState(outState: Bundle) {
    super.onSaveInstanceState(outState)
    // 这些不属于你的业务逻辑层
    outState.putInt("scroll_position", recyclerView.computeVerticalScrollOffset())
    outState.putBoolean("is_toolbar_expanded", collapsingToolbar.isExpanded)
    outState.putParcelable("dialog_state", currentDialog?.onSaveInstanceState())
}
</code></pre>

<h3>2. Fragment 参数和 Activity Extras</h3>

<pre><code class="Kotlin">// 这些需要在进程终止后继续存在，但不是 ViewModel 状态
class DetailFragment : Fragment() {
    companion object {
        fun newInstance(itemId: String) = DetailFragment().apply {
            arguments = Bundle().apply {  // 这在内部使用 savedInstanceState
                putString("item_id", itemId)
            }
        }
    }
}
</code></pre>

<h3>3. 视图状态过于特定于 UI</h3>

<pre><code class="Kotlin">// 诸如 EditText 光标位置、焦点状态等。
override fun onSaveInstanceState(outState: Bundle) {
    super.onSaveInstanceState(outState)
    outState.putInt("edit_text_selection_start", editText.selectionStart)
    outState.putInt("edit_text_selection_end", editText.selectionEnd)
}
</code></pre>

<h2>把手弄脏（动手试一试）</h2>

<p>你可以强制终止进程进行测试：</p>

<pre><code class="bash"># Kill your app process 
adb shell am kill com.yourpackage.name 
# Or use "Don't keep activities" in Developer Options
</code></pre>

<p>这将帮助你验证状态恢复是否正确进行。</p>

<h2>关键洞察</h2>

<p>ViewModel 非常适合配置更改，但需要帮助应对进程死亡。</p>

<p>现代方法是在 ViewModel 中使用 SavedStateHandle，它可以自动处理这两种情况。如果你尚未使用它，则需要手动执行 savedInstanceState → ViewModel 的恢复过程。</p>

<p>这个双层系统看似复杂，但实际上非常优雅：常见情况（配置更改）的快速恢复，以及罕见情况（进程死亡）的可靠恢复。</p>

<p>祝你编码愉快，愿你的状态始终持久！🚀</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解Android中的内存泄漏以及如何让LeakCanary来帮忙]]></title>
    <link href="https://alexhilton.github.io/blog/2025/03/01/understanding-memory-leaks/"/>
    <updated>2025-03-01T11:05:54+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/03/01/understanding-memory-leaks</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自<a href="https://proandroiddev.com/understanding-memory-leaks-in-android-how-leakcanary-can-help-4768df60f646">Understanding Memory Leaks in Android &amp; How LeakCanary Can Help</a>，原文发布于2024年12月27日。</p></blockquote>

<p><strong>译者注：</strong> 关于内存优化，笔者也曾经写过两篇文章，侧重于内存问题的深入分析，如有兴趣可以作为拓展阅读：<a href="https://juejin.cn/post/7277489569958756364">让你不再惧怕内存优化</a>和<a href="https://juejin.cn/post/7287913786038992915">Android应用性能剖析全攻略</a>。</p>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sx4veSpq_Z1oYBsP5Q7nwQ.jpeg" title="auto auto" ></a></p>

<!-- more -->


<p>作为 Android 开发者，管理内存是构建高性能应用的一个最关键方面。开发者面临的一个最常见问题是内存泄漏。这些泄漏会对应用的性能和用户体验产生负面影响，导致运行缓慢、崩溃甚至电池耗尽你。但别担心——有一种解决方案可以让发现和修复内存泄漏变得更容易，那就是LeakCanary。</p>

<p>在这篇文章中，我们将首先探讨什么是内存泄漏、为什么会发生内存泄漏，然后介绍 LeakCanary 作为检测和修复 Android 应用程序中这些泄漏的强大工具。</p>

<h2>什么是内存泄漏？</h2>

<p>当你的应用保留不再需要的内存时，就会发生内存泄漏。简单来说，当不再使用的对象没有从内存中正确清除时，就会发生内存泄漏，从而导致你的应用消耗了不必要的内存。随着时间的推移，这可能会导致性能下降，在极端情况下，还会导致应用崩溃。</p>

<h2>内存泄漏为何如此危险？</h2>

<p>内存泄漏乍一看似乎无害，但它可能会给你的 Android 应用带来严重问题：</p>

<ol>
<li><strong>内存使用量增加：</strong> 当内存未释放时，应用会不断消耗更多资源，导致内存消耗过高。</li>
<li><strong>性能下降：</strong> 随着时间的推移，内存中保存的对象越来越多，应用会变得越来越慢，导致延迟和用户体验不佳。</li>
<li><strong>应用崩溃：</strong> 如果内存消耗达到临界水平，你的应用可能会崩溃甚至强制关闭。</li>
<li><strong>电池耗尽：</strong> 内存泄漏可能导致进程在后台运行，从而比预期更快地耗尽设备电池。</li>
</ol>


<h2>Android 中内存泄漏的常见原因</h2>

<ol>
<li><strong>保存对上下文的引用：</strong> 如果你在静态变量或单例中保存对 Activity 或 Context 的引用，它将永远不会被垃圾回收，因为系统仍会考虑正在使用的 Activity 或 Context。</li>
<li><strong>内部类和匿名类：</strong> 它们隐式保存对外部类（通常是 Activity 或 Fragment）的引用，从而防止它们被垃圾回收。</li>
<li><strong>未关闭的资源：</strong> 完成后不关闭 Cursor、Stream 或数据库连接等资源可能会导致内存堆积。</li>
<li><strong>事件侦听器：</strong> 如果你向 UI 元素添加侦听器（例如 OnClickListener），但在不再需要它们后没有将其删除，这些对象可能会泄漏内存。</li>
</ol>


<h2>LeakCanary 如何帮助检测 Android 中的内存泄漏</h2>

<p>现在我们了解了内存泄漏可能导致的问题，让我们来讨论一下可以帮助我们检测内存泄漏的工具：LeakCanary。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xas01FOk-1FlwDFe.png" alt="LeakCanary" /></p>

<p>LeakCanary 是一个适用于 Android 的开源内存泄漏检测库。它旨在自动识别开发过程中应用中的内存泄漏，让你在影响用户之前修复它们。</p>

<ul>
<li>当发生内存泄漏时，LeakCanary 会自动触发堆转储，对其进行分析，并向开发人员提供一份报告，指出泄漏发生的位置。这使开发人员能够更轻松地发现和解决内存泄漏，以免导致性能问题。</li>
</ul>


<h3>LeakCanary 如何工作？</h3>

<p>LeakCanary 的工作原理是监控应用的内存并分析堆转储以识别不应该存在的对象。当检测到内存泄漏时，它会生成一份报告，显示泄漏发生的位置，从而帮助你找出根本原因。</p>

<ol>
<li><strong>堆转储：</strong> 当 LeakCanary 检测到潜在泄漏时，它会进行堆转储（应用内存的快照），并将其与垃圾回收后的堆进行比较。如果它发现不应保留的对象，它会将其标记为泄漏。</li>
<li><strong>泄漏的对象：</strong> LeakCanary 会向你显示哪些对象被保存在内存中以及引用链中，帮助你识别导致泄漏的对象以及它仍被保留的原因。</li>
<li><strong>通知：</strong> 每当 LeakCanary 发现内存泄漏时，它都会在应用的调试版本中通知你。你可以快速访问报告并开始解决问题。</li>
</ol>


<p>LeakCanary 自动检测以下对象的泄漏：</p>

<ul>
<li>销毁的 Activity 实例</li>
<li>销毁的 Fragment 实例</li>
<li>销毁的 fragment View 实例</li>
<li>清除的 ViewModel 实例</li>
<li>销毁的 Service 实例</li>
</ul>


<h3>如何将 LeakCanary 集成到 Android 项目中？</h3>

<p>要将 LeakCanary 集成到 Android 项目中，请按照以下步骤操作：</p>

<ul>
<li><strong>添加 LeakCanary 依赖项：</strong> 在 build.gradle 文件（应用程序级别）中，添加以下内容：</li>
</ul>


<pre><code class="Groovy">dependencies {
    debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.9.1'
}
</code></pre>

<ul>
<li><strong>初始化 LeakCanary：</strong> LeakCanary 在调试构建类型中自动初始化。但是，你可以在 Application 类中手动初始化它：</li>
</ul>


<pre><code class="Java">public class MyApplication extends Application {
    @Override
    public void onCreate() {
        super.onCreate();
        if (LeakCanary.isInAnalyzerProcess(this)) {
            return; // LeakCanary is in heap analysis process
        }
        LeakCanary.install(this); // Initialize LeakCanary
    }
}
</code></pre>

<ul>
<li><strong>在调试模式下运行应用程序</strong>，LeakCanary 将在开发阶段检测内存泄漏。</li>
</ul>


<h3>如何在生产版本中使用 LeakCanary？</h3>

<p>虽然 LeakCanary 专为调试和开发而设计，但在生产环境中使用它时应谨慎。它可能会影响应用性能，并可能不必要地暴露与内存相关的数据。但是，如果你出于某种原因需要在生产环境中启用它，则可以有条件地仅在某些构建版本中添加 LeakCanary：</p>

<pre><code class="Groovy">dependencies {
    releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:2.9.1' // No-op for release
    debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.9.1'
}
</code></pre>

<p>这样，LeakCanary 仅在调试版本中处于活动状态，而无操作版本则用于生产。</p>

<h3>你将采取什么步骤来修复 LeakCanary 报告的内存泄漏？</h3>

<p>当 LeakCanary 报告内存泄漏时，请按照以下步骤解决：</p>

<ol>
<li><p><strong>分析泄漏报告：</strong> LeakCanary 提供一份详细的报告，其中包含一个对象引用链，显示泄漏发生的位置。</p></li>
<li><p><strong>识别泄漏对象：</strong> 查找意外保存在内存中的对象（如 Activity、Fragment 或 Context）。</p></li>
<li><p><strong>修复泄漏：</strong></p>

<ul>
<li>避免将 Activity 或 Context 引用存储在静态变量或长寿命对象中。</li>
<li>确保关闭 Cursor、Stream 等资源。</li>
<li>在不再需要时删除侦听器和回调。</li>
</ul>
</li>
<li><strong>测试修复：</strong> 进行更改后，重新运行你的应用以确认内存泄漏已解决。</li>
</ol>


<h3>LeakCanary 有哪些局限性？</h3>

<p>虽然 LeakCanary 是一款出色的工具，但它也有一些局限性：</p>

<ul>
<li><strong>并非所有泄漏都能被检测到：</strong> LeakCanary 专注于 Java 堆内存泄漏，但它可能无法检测本机内存泄漏或低级问题。</li>
<li><strong>对性能的影响：</strong> 由于堆分析过程，在开发过程中运行 LeakCanary 可能会稍微减慢你的应用速度。</li>
<li><strong>不能取代良好的内存管理：</strong> 虽然 LeakCanary 有助于检测泄漏，但开发人员仍应遵循内存管理的最佳实践，以防止泄漏发生。</li>
</ul>


<h2>结论</h2>

<p>内存管理对于确保 Android 应用高效运行至关重要。LeakCanary 是一款功能强大的工具，可帮助你在内存泄漏影响应用性能之前检测并解决内存泄漏问题。通过遵循最佳实践并将 LeakCanary 集成到你的开发过程中，你可以确保你的应用保持优化状态并且不会出现与内存相关的问题。</p>

<p>检查你是否已在 Android 应用程序中完成以下所有操作：</p>

<ol>
<li><a href="https://developers.google.com/maps/documentation/places/android-sdk/memory-best-practices#rel-unused">释放未使用的资源。</a></li>
<li><a href="https://developers.google.com/maps/documentation/places/android-sdk/memory-best-practices#unreg">不再需要时取消注册监听器。</a></li>
<li><a href="https://developers.google.com/maps/documentation/places/android-sdk/memory-best-practices#cancel-tasks">不需要时取消任务。</a></li>
<li><a href="https://developers.google.com/maps/documentation/places/android-sdk/memory-best-practices#fwd-lifecyc">发生命周期方法以释放资源。</a></li>
<li><a href="https://developers.google.com/maps/documentation/places/android-sdk/memory-best-practices#latest-versions">使用最新版本的 SDK。</a></li>
</ol>


<h2>参考</h2>

<ul>
<li><a href="https://developers.google.com/maps/documentation/places/android-sdk/memory-best-practices">https://developers.google.com/maps/documentation/places/android-sdk/memory-best-practices</a></li>
<li><a href="https://square.github.io/leakcanary/">https://square.github.io/leakcanary/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[选择Retrofit还是Ktor：给Android开发者的指南]]></title>
    <link href="https://alexhilton.github.io/blog/2025/02/26/retrofit-vs-ktor/"/>
    <updated>2025-02-26T22:50:55+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/02/26/retrofit-vs-ktor</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自<a href="https://proandroiddev.com/when-to-use-retrofit-and-when-to-use-ktor-a-guide-for-android-developers-918491dcf69a">When to Use Retrofit and When to Use Ktor: A Guide for Android Developers</a></p></blockquote>

<p>作为 Android 开发人员，为你的项目选择正确的 HTTP 客户端是一项关键的决定。当今最受欢迎的两个选项莫过于 Retrofit 和 Ktor。虽然Retrofit 多年来一直是事实上的标准，但 Ktor 因其现代架构和灵活性而势头强劲。</p>

<p><a href=""><img src="https://robotqa.com/blog/wp-content/uploads/2024/06/202406120818248.png" title="auto auto" ></a></p>

<!-- more -->


<p>在本文中，我们将探讨你应该选择 Retrofit 或 Ktor 的场景，以及它们的优势如何满足你的应用要求。</p>

<h2>了解基础知识</h2>

<p>先来了解一下基础知识：</p>

<h3>Retrofit</h3>

<p>Retrofit 是 Square 开发的适用于 Android 和 Java 的类型安全 HTTP 客户端。它将 API 调用抽象为声明式接口，并使用 Gson 或 Moshi 等库无缝地将 JSON 解析为 Java/Kotlin 对象。</p>

<h3>Ktor</h3>

<p>Ktor 由 JetBrains 开发，是一款基于 Kotlin 的异步框架，用于构建联网应用程序。它不仅仅是一个 HTTP 客户端，而是一个多用途框架，让你能够使用同一个库构建后端服务并发出网络请求。</p>

<h2>何时使用 Retrofit？</h2>

<h3>1. 你需要简单和可读性</h3>

<p>如果你更喜欢使用预定义接口以直观的方式进行 API 调用，Retrofit 是一个绝佳的选择。</p>

<p>例子：</p>

<pre><code class="Kotlin">interface ApiService {
    @GET("posts")
    suspend fun getPosts(): List&lt;Post&gt;
}
</code></pre>

<p>使用 Retrofit，你可以预先定义 API 结构并专注于业务逻辑。</p>

<h3>2. 你的团队已经熟悉 Retrofit</h3>

<p>如果你的团队已有使用 Retrofit 的经验，那么坚持使用它可以降低学习曲线并加速开发。</p>

<h3>3. 你需要开箱即用的功能</h3>

<p>Retrofit 提供强大的功能，例如：</p>

<ul>
<li>自动解析 JSON 响应。</li>
<li>内置对 OkHttp 拦截器的支持。</li>
<li>轻松实现重试、缓存和日志记录。</li>
</ul>


<h3>4. 你在多语言环境中工作</h3>

<p>Retrofit 非常适合涉及 Java 和 Kotlin 的项目，因此它对于遗留代码库来说是一个绝佳的选择。</p>

<h3>5.你需要一个庞大的社区和资源</h3>

<p>Retrofit 的成熟意味着丰富的文档、教程和社区支持，这使其成为许多团队更安全的选择。</p>

<h2>何时使用 Ktor？</h2>

<h3>1. 你需要高度可定制性</h3>

<p>Ktor 允许你构建 HTTP 客户端，并对请求构建、日志记录和自定义管道进行细粒度的控制。</p>

<p>例子：</p>

<pre><code class="Kotlin">val client = HttpClient {
    install(JsonFeature) {
        serializer = KotlinxSerializer()
    }
}
</code></pre>

<h3>2. 你想利用 Kotlin Multiplatform</h3>

<p>Ktor 的多平台支持是其突出的功能之一。如果你正在为 Android、iOS 和其他平台构建应用程序，Ktor 可确保你在所有平台上使用相同的网络逻辑。</p>

<h3>3. 你正在构建轻量级或模块化应用程序</h3>

<p>Ktor 的模块化设计使其成为轻量级应用程序或网络堆栈需要精简和集中的项目的理想选择。</p>

<h3>4.你需要异步通信</h3>

<p>Ktor 原生使用协程，这使得处理并发比传统的基于回调的方法更简单、更高效。</p>

<h3>5. 你需要统一的后端和前端代码</h3>

<p>借助 Ktor，你可以使用相同的框架构建服务器端 API 和移动应用程序，从而简化开发并确保一致性。</p>

<h2>你应该选择哪一个？</h2>

<p>用一张表格来总结一下两者各自的特点：</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 特点 </th>
<th style="text-align:center;"> Retrofit </th>
<th style="text-align:center;"> Ktor </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> 易于使用 </td>
<td style="text-align:center;"> 高 </td>
<td style="text-align:center;"> 中等 </td>
</tr>
<tr>
<td style="text-align:center;"> Kotlin-first 设计 </td>
<td style="text-align:center;"> 否 </td>
<td style="text-align:center;"> 是 </td>
</tr>
<tr>
<td style="text-align:center;"> 跨平台支持 </td>
<td style="text-align:center;"> 否 </td>
<td style="text-align:center;"> 是 </td>
</tr>
<tr>
<td style="text-align:center;"> 可定制性 </td>
<td style="text-align:center;"> 中等 </td>
<td style="text-align:center;"> 高 </td>
</tr>
<tr>
<td style="text-align:center;"> 学习曲线 </td>
<td style="text-align:center;"> 低 </td>
<td style="text-align:center;"> 中等 </td>
</tr>
<tr>
<td style="text-align:center;"> 社区支持 </td>
<td style="text-align:center;"> 规模很大 </td>
<td style="text-align:center;"> 快速发展 </td>
</tr>
<tr>
<td style="text-align:center;"> 与协程集成 </td>
<td style="text-align:center;"> 通过添加suspend </td>
<td style="text-align:center;"> 是（集成了原生协程） </td>
</tr>
<tr>
<td style="text-align:center;"> 后端能力 </td>
<td style="text-align:center;"> 否 </td>
<td style="text-align:center;"> 是 </td>
</tr>
</tbody>
</table>


<h3>如果符合以下情况则选择 Retrofit：</h3>

<ul>
<li>你正在开发一个 Kotlin 或 Java 项目，其中简单性和快速开发是首要任务。</li>
<li>你的项目依赖于久经考验的工具和广泛的社区支持。</li>
<li>你需要对 REST API 进行最低限度的配置。</li>
</ul>


<h3>以下情况请选择 Ktor：</h3>

<ul>
<li>你正在构建一个 Kotlin Multiplatform 项目。</li>
<li>你需要一个现代、灵活的网络堆栈。</li>
<li>你需要同时支持前端和后端开发。</li>
</ul>


<h2>结论</h2>

<p>在 Retrofit 和 Ktor 之间进行选择取决于你的项目需求和你的团队对这些工具的熟悉程度。Retrofit 是传统 Android 项目的可靠选择，而 Ktor 则在现代 Kotlin 优先和多平台应用程序中表现出色。了解这些差异将有助于你为下一个 Android 应用做出正确的选择。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一文带你理解OkHttp中的Gzip压缩]]></title>
    <link href="https://alexhilton.github.io/blog/2025/02/25/understanding-okhttp-gzip-compression/"/>
    <updated>2025-02-25T22:28:09+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/02/25/understanding-okhttp-gzip-compression</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自<a href="ttps://medium.com/tech-insider/okhttps-gzip-compression-904919638458">OkHttp’s Gzip Compression</a>，原文发布于2020年5月1日。本文假定读者对HTTP有基本的了解，以及使用过OkHttp，否则理解起来可能会一点困难。</p></blockquote>

<p><strong>译注：</strong> OkHttp确实会自动添加gzip并处理响应。但如果显示的给请求添加除了gzip之外的字段，如&#8221;Accept-Encoding: gzip, deflate, br&#8221;，那么就需要手动处理响应。其实一般时候我们并不需要手动设置，除非是模拟浏览器时（比如用了浏览器的UA），或者某些服务器强制deflate字段。更多的信息可以<a href="https://stackoverflow.com/questions/51901333/okhttp-3-how-to-decompress-gzip-deflate-response-manually-using-java-android">看这里</a>。</p>

<p><a href=""><img src="https://img-blog.csdnimg.cn/879e064594104e0ab5671f6710ffea24.png" title="auto auto" ></a></p>

<!-- more -->


<p>压缩是一种简单有效的节省带宽和加快移动用户交互速度的方法。当用户点击你的页面屏幕时，会调用你的服务器来提供请求的响应。响应越大，屏幕上显示数据的时间就越长。通过压缩，即使你的访问者的互联网连接速度非常慢并且你的 API 响应过于繁重，他们也能享受快速加载。</p>

<h2>这是如何工作的呢？</h2>

<p><strong>Gzip 会找到相似的字符串，并用一些占位符临时替换这些字符串，以缩小整体大小。</strong>如果你使用大量重复文本，并且有大量空格， 这也没有问题。你可以使用 Gzip 压缩你的响应主体以及请求主体。由于文件小得多，此操作可大大减少传输时间。</p>

<p><strong>注意：</strong>如果你尝试使用postman，它会默认在header的隐藏部分中添加 Accept-Encoding: gzip字段。</p>

<blockquote><p>重要提示：OkHttp 也会自动在请求中添加字段 Accept-Encoding 并自动识别响应中的 Content-Encoding，因此会自行解压缩响应数据，因此无需单独设置，但假设当我们必须将压缩的请求数据发送到服务器时，我们就必须编写自己的拦截器。</p></blockquote>

<p>这种压缩的棘手之处在于请求者和服务器都知道可以发送压缩文件。你必须告诉服务器您接受这种编码，然后它才会提供。该协议分为两部分：</p>

<ul>
<li>请求者发送一个header，告知服务器它接受压缩内容：Accept-Encoding：gzip</li>
<li>服务器使用此header确认你的请求：Content-Encoding：gzip</li>
</ul>


<p>说得够多的了，我想你还有耐心，所以让我们看一些代码。</p>

<h2>编写自己的拦截器</h2>

<p>先决条件：了解 OkHttp 中的<a href="https://square.github.io/okhttp/features/interceptors/">拦截器（Interceptors）</a>。</p>

<ol>
<li>解开 Gzip 响应：在请求header中添加 Accept-Encoding: gzip，并在获取响应时在其响应header中查找 Content-Encoding: gzip。如果存在则解压缩，否则直接返回响应。</li>
</ol>


<pre><code class="Java">import java.io.IOException;

import okhttp3.Headers;
import okhttp3.Interceptor;
import okhttp3.Request;
import okhttp3.Response;
import okhttp3.ResponseBody;
import okio.GzipSource;
import okio.Okio;

public class GzipInterceptor implements Interceptor {
    @Override
    public Response intercept(Chain chain) throws IOException {
        Request.Builder newRequest = chain.request().newBuilder();
        newRequest.addHeader("Accept-Encoding", "gzip");
        Response response = chain.proceed(newRequest.build());

        if (isGzipped(response)) {
            return unzip(response);
        } else {
            return response;
        }
    }

    private Response unzip(final Response response) throws IOException {

        if (response.body() == null) {
            return response;
        }

        GzipSource gzipSource = new GzipSource(response.body().source());
        String bodyString = Okio.buffer(gzipSource).readUtf8();

        ResponseBody responseBody = ResponseBody.create(response.body().contentType(), bodyString);

        Headers strippedHeaders = response.headers().newBuilder()
                .removeAll("Content-Encoding")
                .removeAll("Content-Length")
                .build();
        return response.newBuilder()
                .headers(strippedHeaders)
                .body(responseBody)
                .message(response.message())
                .build();

    }

    private Boolean isGzipped(Response response) {
        return response.header("Content-Encoding") != null &amp;&amp; response.header("Content-Encoding").equals("gzip");
    }
}
</code></pre>

<ol>
<li>创建 Gzip 请求：如果你的请求过大，那么我们可以使用它来压缩我们的请求。为了通知服务器，我们将在请求header中添加 Content-Encoding: gzip。</li>
</ol>


<pre><code class="Java">import java.io.IOException;

import okhttp3.Interceptor;
import okhttp3.MediaType;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okio.BufferedSink;
import okio.GzipSink;
import okio.Okio;

public class GzipInterceptor implements Interceptor {
    @Override public Response intercept(Interceptor.Chain chain) throws IOException {
        Request originalRequest = chain.request();

        if (originalRequest.body() == null || originalRequest.header("Content-Encoding") != null) {
            return chain.proceed(originalRequest);
        }

        Request compressedRequest = originalRequest.newBuilder()
                .header("Content-Encoding", "gzip")
                .method(originalRequest.method(), gzip(originalRequest.body()))
                .build();
        return chain.proceed(compressedRequest);
    }

    private RequestBody gzip(final RequestBody body) {
        return new RequestBody() {
            @Override public MediaType contentType() {
                return body.contentType();
            }

            @Override public long contentLength() {
                return -1; // 事先不知道请求内容的长度
            }

            @Override public void writeTo(BufferedSink sink) throws IOException {
                BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));
                body.writeTo(gzipSink);
                gzipSink.close();
            }
        };
    }
}
</code></pre>

<p>好了，就到这里吧，如果你愿意的话，可以赞一下。</p>

<p>参考资料：</p>

<ol>
<li><a href="https://square.github.io/okhttp/">https://square.github.io/okhttp/</a></li>
<li><a href="https://www.apphp.com/tutorials/index.php?page=gzip-and-deflate-compression-in-web-development">https://www.apphp.com/tutorials/index.php?page=gzip-and-deflate-
compression-in-web-development</a></li>
<li><a href="https://www.youtube.com/watch?v=Mjab_aZsdxw">https://en.wikipedia.org/wiki/Gzip</a></li>
<li><a href="https://www.youtube.com/watch?v=Mjab_aZsdxw">https://www.youtube.com/watch?v=Mjab_aZsdxw</a></li>
</ol>

]]></content>
  </entry>
  
</feed>
