<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2025-03-16T20:39:50+08:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[高效地在Jetpack Compose中设计UI组件]]></title>
    <link href="https://alexhilton.github.io/blog/2025/03/16/effective-compose-components/"/>
    <updated>2025-03-16T20:37:18+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/03/16/effective-compose-components</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自<a href="https://proandroiddev.com/designing-effective-ui-components-in-jetpack-compose-cb8d18f7f888">Designing Effective UI Components in Jetpack Compose</a>，原文作者是Jaewoong Eum，原文发布于2025年2月7日。</p></blockquote>

<p><strong>译者按：</strong> 本文适合有一定Jetpack Compose经验的开发者阅读，假定读者熟悉Jetpack Compose的基本使用方法，以及熟悉常见 的Slot设计模式。否则理解上可能会有一些困难。</p>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PwVzAjyhIPGIgrT0" title="auto auto" ></a></p>

<!-- more -->


<p>自<a href="https://android-developers.googleblog.com/2021/07/jetpack-compose-announcement.html"> Google 宣布 Jetpack Compose 1.0 稳定版</a>以来，许多公司都已采用 Jetpack Compose 来利用其众多优势。随着 Compose 在 Android 生态系统中的广泛采用，库和 SDK 也开始集成对 Compose 的支持。</p>

<p>传统上，在基于 XML 的项目中，UI 组件以自定义视图的形式提供，并通过属性（attributes）提供可自定义的选项。虽然这种方法可以轻松地将组件集成到 XML 布局中，但它带来了一些挑战，例如在多个组件之间应用主题样式时不一致，以及由于底层 View 类公开的方法而导致的 API 滥用。</p>

<p>与传统的自定义视图相比，Jetpack Compose 提供了一种完全不同的组件设计策略。其声明式结构允许更直观、更灵活的 API 设计。这种转变不仅有利于库和 SDK 开发人员，也有利于构建共享 UI 组件的大型团队，使他们能够实施更好的做法、减少误用并增强整体开发人员体验。</p>

<p>在本文中，你将发现在 Jetpack Compose 中设计 UI 组件的有效策略，借鉴<a href="https://getstream.io/video/sdk/android/"> Stream Video SDK </a>的最佳实践。</p>

<h2>Modifier的最佳实践</h2>

<p><a href="https://developer.android.com/develop/ui/compose/modifiers">Modifier </a>是 Jetpack Compose 中一个功能强大的 API，可让你以链式和可组合的方式装饰和增强 UI 元素。但是，应谨慎使用它，因为它的属性可以传播到其他可组合函数，如果管理不当，可能会导致意想不到的效果。</p>

<p>Modifier函数的顺序尤其重要，因为每个函数都会修改前一个函数返回的Modifier或从可组合项外部传递的Modifier。此顺序直接影响最终输出。在本节中，我们将探讨三个关键原则和最佳实践，它们可以指导你在 Jetpack Compose 中设计有效且可预测的 UI 组件 API。</p>

<h3>1. 将Modifier应用到组件最顶层的布局</h3>

<p>Jetpack Compose 中的Modifier会通过布局层次结构向下传递，但理想情况下，它们应仅应用于可组合函数中最顶层的布局节点。在层次结构中的任意级别应用Modifier可能会导致意外行为，并增加用户误用的可能性，从而使组件更难以预测且更难以有效使用。</p>

<p>例如，假设你想要创建一个代表圆形按钮的组件，如下例所示：</p>

<pre><code class="Kotlin">@Composable
fun RoundedButton(
  modifier: Modifier = Modifier,
  onClick: () -&gt; Unit
) {
  Button(
    modifier = modifier.clip(RoundedCornerShape(32.dp)),
    onClick = onClick
  ) {
    Text(
      modifier = Modifier.padding(10.dp),
      text = "Rounded"
    )
  }
}
</code></pre>

<p>但是，你不应将 Modifier 应用于 Text ，而应应用于 Button ，后者是布局层次结构中最顶层的可组合函数，如下所示：</p>

<pre><code class="Kotlin">@Composable
fun RoundedButton(
  modifier: Modifier = Modifier,
  onClick: () -&gt; Unit
) {
  Button(
    modifier = Modifier.clip(RoundedCornerShape(32.dp)),
    onClick = onClick
  ) {
    Text(
      modifier = modifier.padding(10.dp), // 别这么干
      text = "Rounded"
    )
  }
}
</code></pre>

<p>自定义可组合函数 RoundedButton 的主要用途是表示 Button ，而不是 Text 。因此，你应避免转移所创建主要组件的焦点或用途。</p>

<p>此外，如果布局层次结构变得复杂，并且你在可组合函数的中间级别应用Modifier，则用户可能很难预测提供的Modifier参数最终会影响哪个组件。这种不明确性可能会导致混淆和误用。</p>

<p>如果你想让用户灵活地修改按钮的内部内容，你可以使用插槽来实现，如下例所示：</p>

<pre><code class="Kotlin">@Composable
fun RoundedButton(
  modifier: Modifier = Modifier,
  onClick: () -&gt; Unit,
  content: @Composable RowScope.() -&gt; Unit
) {
  Button(
    modifier = modifier.clip(RoundedCornerShape(32.dp)),
    onClick = onClick
  ) {
    content()
  }
}
</code></pre>

<h3>2. 对Modifier使用单个参数</h3>

<p>你可能想知道是否可以接受多个 Modifier 参数以应用于布局层次结构中的特定组件，同时限制组件的结构，如下例所示：</p>

<pre><code class="Kotlin">@Composable
fun RoundedButton(
  modifier: Modifier = Modifier,
  textModifier: Modifier = Modifier,
  onClick: () -&gt; Unit,
) {
  Button(
    modifier = modifier.clip(RoundedCornerShape(32.dp)),
    onClick = onClick
  ) {
    Text(
      modifier = textModifier.padding(10.dp),
      text = "Rounded"
    )
  }
}
</code></pre>

<p>但是，Modifier 本质上被设计为一个单一的、可链接的参数，使用户能够定义 Composable 函数的外部行为和外观。在 Composable 中引入多个 Modifier 参数会增加不必要的复杂性，增加误用的风险，并且偏离了 Jetpack Compose 保持 API 直观和可预测的原则。</p>

<p>最好使用基于插槽的方法，让用户能够灵活地自定义内部内容。例如，你可以定义一个插槽（slot），让用户提供自定义内容，同时仍保留单个Modifier以进行外部自定义，而不是添加多个Modifier参数。</p>

<pre><code class="Kotlin">@Composable
fun RoundedButton(
  modifier: Modifier = Modifier,
  onClick: () -&gt; Unit,
  content: @Composable RowScope.() -&gt; Unit
) {
  Button(
    modifier = modifier.clip(RoundedCornerShape(32.dp)),
    onClick = onClick
  ) {
    content()
  }
}
</code></pre>

<h3>3. 避免跨组件重复使用Modifier</h3>

<p>设计组件时的另一个重要考虑因素是避免重复使用提供的 Modifier 实例。一些开发人员可能会担心为每个组件创建新的 Modifier 实例可能会导致内存使用量增加或对性能产生负面影响，尤其是在具有大量Modifier的复杂布局层次结构中。</p>

<p>然而，由于 Jetpack Compose 中Modifier实现的优化性质，这种担忧通常是没有根据的。Modifier旨在应用于可组合函数中的单个布局节点，以确保行为清晰且可预测。如果在布局层次结构中不同级别的多个可组合项中使用相同的Modifier，则可能导致意外的副作用和不可预测的行为，从而损害组件的一致性和可用性。</p>

<p>例如，考虑这样一种情况，其中相同的 Modifier 参数在整个布局层次结构中重复使用，如下例所示：</p>

<pre><code class="Kotlin">@Composable
fun MyButtons(
  modifier: Modifier = Modifier,
  onClick: () -&gt; Unit,
) {
  Column(modifier = modifier) {
    Button(
      modifier = modifier,
      onClick = onClick
    ) {
      Text(
        modifier = modifier.padding(10.dp),
        text = "Rounded"
      )
    }

    Button(
      modifier = modifier,
      onClick = onClick
    ) {
      Text(
        modifier = modifier.padding(10.dp),
        text = "Not Rounded"
      )
    }
  }
}
</code></pre>

<p>乍一看，代码似乎运行正常。但是，当你在调用点修改Modifier时，你会注意到意外的行为，可能会以意想不到的方式改变整个布局。</p>

<pre><code class="Kotlin">MyButtons(
  modifier = Modifier
    .clip(RoundedCornerShape(32.dp))
    .background(Color.Blue)
) {}
</code></pre>

<p>为了确保行为正确并避免意外问题，你应避免在多个组件中重复使用Modifier。在本节中，你了解了在设计 Compose 组件时管理Modifier的最佳实践。接下来，让我们通过实现主题来深入了解如何提供一致的 UI 样式。</p>

<h2>主题确保 UI 一致性</h2>

<p>现在，假设你需要提供多种 Compose 组件，这些组件应共享一致的样式。如果这些组件是独立提供的，那么维护这些组件之间一致样式的责任就完全落在用户身上。这可能非常具有挑战性，因为每个组件可能会公开不同的 API 来自定义其样式，从而使同步变得繁琐且容易出错。</p>

<p>在这种情况下，你可以从 Compose Material 库提供的<a href="https://developer.android.com/develop/ui/compose/designsystems/material3#material-theming"> MaterialTheme API </a>中汲取灵感。关键在于确保组件样式一致，同时允许用户无缝自定义并在各个组件之间保持一致的样式。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*AyJL0G8NsCGWX9_Q" alt="Theming Consistency" /></p>

<p>Compose 的<a href="https://getstream.io/video/sdk/"> Stream Video SDK </a>通过提供名为<a href="https://getstream.io/video/docs/android/ui-components/video-theme/"> VideoTheme </a>的专用主题 API 展示了最佳实践。此 VideoTheme API 可确保 SDK 提供的所有 Compose 组件的样式一致，包括颜色、尺寸、排版、形状、涟漪效果等。</p>

<pre><code class="Kotlin">setContent {
    VideoTheme(
        colors = StreamColors.defaultColors().copy(appBackground = Color.Black),
        dimens = StreamDimens.defaultDimens().copy(callAvatarSize = 72.dp),
        shapes = StreamShapes.defaultShapes().copy(
            avatar = RoundedCornerShape(8.dp),
            callButton = RoundedCornerShape(16.dp),
            callControls = RectangleShape,
            callControlsButton = RoundedCornerShape(8.dp)
        )
    ) {
        CallContent(
            modifier = Modifier.fillMaxSize(),
            call = call,
            onBackPressed = { finish() },
        )
    }
}
</code></pre>

<p>通过将 Stream SDK 提供的组件与 VideoTheme 包装在一起（如上例所示），自定义样式将自动一致地应用于所有组件。这种方法使用户能够轻松保持其 UI 的一致性，同时调整主题以满足其应用程序的设计要求。</p>

<h3>实现自定义主题</h3>

<p>让我们深入研究如何实现自定义主题。第一步是定义设计规范，这些规范将在你的组件之间共享或为用户提供自定义功能。考虑包括颜色、形状和尺寸等方面，因为这些通常是确保设计系统一致性的最重要因素。</p>

<p>例如，在 Stream SDK 中，组件所需的所有颜色集均在<a href="https://github.com/GetStream/stream-video-android/blob/c12db8cb6367e10682be3ab323d50dfcc59032f3/stream-video-android-ui-compose/src/main/kotlin/io/getstream/video/android/compose/theme/StreamColors.kt#L24"> StreamColors </a>类中预定义，为用户提供了一种无缝的方式来保持其整个 UI 的一致性。以下是 Stream SDK 如何通过结构良好的颜色集确保一致性的示例：</p>

<pre><code class="Kotlin">public data class StreamColors(
    val brandPrimary: Color,
    val brandPrimaryLt: Color,
    val brandPrimaryDk: Color,
    val brandSecondary: Color,
    val brandSecondaryTransparent: Color,
    val brandCyan: Color,
    val brandGreen: Color,
    val brandYellow: Color,
    ..
  )
</code></pre>

<p>接下来，你应该创建一个<a href="https://developer.android.com/develop/ui/compose/compositionlocal"> CompositionLocal </a>来保存设计规范。这将允许你的组件和用户通过使用 StreamTheme.colors 调用在自定义主题的上下文中无缝访问这些规范。</p>

<p><strong>译注：</strong> CompositionLocal是Compose中用于在上下文函数调用中，隐式的传递常量性质参数的方法，可以参考这篇文章<a href="https://juejin.cn/post/7434543407636267071">用Compose中的CompositionLocal来暗渡陈仓</a>，以了解CompositionLocal的详细用法。</p>

<pre><code class="Kotlin">/**
 * Local providers for various properties we connect to our components, for styling.
 */
private val LocalColors = compositionLocalOf&lt;StreamColors&gt; {
    error("No colors provided! Make sure to wrap all usages of Stream components in a VideoTheme.")
}

public interface StreamTheme {
    /**
     * Retrieves the current [StreamColors] at the call site's position in the hierarchy.
     */
    public val colors: StreamColors
        @Composable @ReadOnlyComposable
        get() = LocalColors.current
}
</code></pre>

<p>然后，你需要利用<a href="https://developer.android.com/develop/ui/compose/compositionlocal"> CompositionLocal </a>将这些设计规范封装在自定义主题中。这种方法允许你在整个可组合层次结构中高效地提供和传播你的设计规范。</p>

<pre><code class="Kotlin">public fun VideoTheme(
    isInDarkMode: Boolean = isSystemInDarkTheme(),
    colors: StreamColors = StreamColors.defaultColors(),
    content: @Composable () -&gt; Unit,
) {
    CompositionLocalProvider(
        LocalColors provides colors,
    ) {
        content()
    }
}
</code></pre>

<p>现在，你的所有组件都应假设它们都包含在自定义主题（例如本例中的 VideoTheme）中，并使用提供的设计规范来确保整个组件集的样式一致。这种方法不仅使你的组件 API 能够采用统一的样式，还允许用户利用这些设计规范进行自定义，从而同时提高灵活性和一致性。</p>

<pre><code class="Kotlin">@Composable
fun VideoRendererCallContent(
    call: Call,
    video: ParticipantState.Video,
    onRendered: (View) -&gt; Unit = {},
) {
    VideoRenderer(
        modifier = Modifier
            .fillMaxSize()
            .background(VideoTheme.colors.baseSheetTertiary), // use pre-defined color styles
        call = call,
        video = video,
        onRendered = onRendered,
    )
}

@Composable
fun MyScreen() { 

  VideoRendererCallContent(..)

  // some complicated components
}

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

         setContent {
            VideoTheme {
               MyScreen()
            }
         }
}
</code></pre>

<p>这种方法不仅对于实现 API（库或 SDK）有效，对于构建应用程序也同样有效，因为它能够使用结构良好、预定义的设计规范轻松维护设计一致性。对于实际示例和实际用例，你可以在<a href="https://github.com/GetStream/stream-video-android/blob/c12db8cb6367e10682be3ab323d50dfcc59032f3/stream-video-android-ui-compose/src/main/kotlin/io/getstream/video/android/compose/theme/VideoTheme.kt"> GitHub </a>上探索实际最佳实践。</p>

<h2>可定制性</h2>

<p>在实现 UI 组件时，尤其是对于库或 SDK，为 UI 和 UX 行为提供强大的自定义和灵活性至关重要。这可确保用户可以轻松重复使用组件并根据其特定要求进行调整。你可以采用各种策略在 Jetpack Compose 中有效地实现这种级别的可定制性。</p>

<h3>1. 利用样式类</h3>

<p>如果你希望为特定组件提供更具针对性的定制，请考虑提供专用的样式类。此类可以定义并允许用户轻松修改组件的 UI 和 UX 行为以满足他们的特定需求。</p>

<p>一个很好的例子是 TextStyle ，它是 Compose UI 库提供的默认类：</p>

<pre><code class="Kotlin">@Immutable
class TextStyle internal constructor(
  ..
) {
    constructor(
        color: Color = Color.Unspecified,
        fontSize: TextUnit = TextUnit.Unspecified,
        fontWeight: FontWeight? = null,
        fontStyle: FontStyle? = null,
        fontSynthesis: FontSynthesis? = null,
        fontFamily: FontFamily? = null,
        ..
     )
}
</code></pre>

<p>如上面的代码所示，TextStyle 类封装了 Text 可组合项的所有样式属性。只需将 TextStyle 实例传递给 Text 可组合项，你就可以轻松自定义其设计，如下例所示：</p>

<pre><code class="Kotlin">Text(
    modifier = Modifier
        .fillMaxWidth()
        .padding(top = 16.dp),
    text = "Stats",
    style = TextStyle(
        fontSize = 16.sp,
        lineHeight = 24.sp,
        fontWeight = FontWeight(600),
        color = Color.White,
        textAlign = TextAlign.Center,
    ),
)
</code></pre>

<p>使用样式类的优点是，它们允许组件开发人员将所有设计规范整合到一个集中的类中。这种方法可以防止设计元素分散在多个布局中，从而使代码库更简洁、更易于管理。</p>

<p>对于用户来说，样式类提供了一种直接且直观的修改设计的方法。此外，用户可以在多个布局中重复使用相同的样式实例，从而更方便地在不同布局中应用一致的自定义。</p>

<p>一个潜在的缺点是，由于<a href="https://getstream.io/blog/jetpack-compose-stability/#jetpack-compose-phases">重组机制（Recomposition）</a>，每当输入发生变化时，Compose 运行时都会比较样式类的所有属性，以确定是否需要重组。与直接在可组合函数中定义单个参数相比，这使其成本略高。然而，从 API 设计的角度来看，改进的用户体验和简化的 API 管理通常超过了这一成本，因此在许多情况下，这是一种值得的权衡。</p>

<h3>2. 借助插槽（Slots）的灵活性</h3>

<p>增强自定义灵活性的另一种有效策略是提供接受可组合函数的插槽，让用户根据自己的需求定义特定的实现。通过提供默认实现，你可以确保用户无需付出额外努力即可利用所提供的功能，同时仍然可以根据需要进行自定义。</p>

<p>例如，Stream Video SDK 提供的 CallContent 组件是一个高级 API，它集成了多个子组件，包括顶部应用栏、视频渲染器、布局结构、网格参与者等。虽然 CallContent API 包含默认实现以方便使用，但它还通过允许通过插槽参数进行自定义来确保灵活性，如以下代码所示：</p>

<pre><code class="Kotlin">fun CallContent(
    call: Call,
    modifier: Modifier = Modifier,
    style: VideoRendererStyle = RegularVideoRendererStyle(),
    appBarContent: @Composable (call: Call) -&gt; Unit = {
        CallAppBar(..)
    },
    videoRenderer: @Composable (..) -&gt; Unit = {
        ParticipantVideo(..)
    },
    videoContent: @Composable RowScope.(call: Call) -&gt; Unit = {
        ParticipantsLayout(..)
    },
) {
  ..
}
</code></pre>

<p>这种方法允许用户实现自己的顶部应用栏、视频渲染器、布局结构、网格参与者等自定义版本。此外，另一种有效的策略是将相似类型的组件分组，并通过插槽使它们可自定义，这通常称为复合组件模式。</p>

<p>复合组件模式涉及创建一个父组件来管理子组件集合，通过为每个子组件公开插槽来提供自定义。此模式允许用户替换或自定义单个子组件，同时保持整体结构和功能的一致性。</p>

<p>想象一下视频通话屏幕上的控制面板包含多个操作按钮，如下图所示：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:886/format:webp/0*mNh-EWJlyCobHHed" alt="Control Panel" /></p>

<p>有些用户可能喜欢不同的操作按钮顺序，例如将麦克风按钮放在第一位，而其他用户可能希望根据其特定用例添加、删除或自定义按钮。在这种情况下，复合组件模式被证明在满足这些不同的要求方面非常有效，例如下面的代码：</p>

<pre><code class="Kotlin">@Composable
public fun ControlActions(
    call: Call,
    modifier: Modifier = Modifier,
    actions: List&lt;(@Composable () -&gt; Unit)&gt;
) {
    Box(
        modifier = modifier,
    ) {
        LazyRow(
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(
                VideoTheme.dimens.spacingM,
                Alignment.CenterHorizontally,
            ),
        ) {
            items(actions) { action -&gt;
                action.invoke()
            }
        }
    }
}
</code></pre>

<p>上面的代码演示了一个接受 Composable 函数列表的单个插槽，然后使用 Row 或 LazyRow 进行渲染。这种方法允许你提供高度灵活的组件 API，同时保持对组件布局预期结构的控制。</p>

<p>之后，你还可以提供默认实现，如下所示，以增加便利性。</p>

<pre><code class="Kotlin">@Composable
public fun buildDefaultCallControlActions(
    onCallAction: (CallAction) -&gt; Unit,
): List&lt;@Composable () -&gt; Unit&gt; {

    return listOf(
        {
            ToggleCameraAction(
                onCallAction = onCallAction,
            )
        },
        {
            ToggleMicrophoneAction(
                onCallAction = onCallAction,
            )
        },
        {
            FlipCameraAction(
                onCallAction = onCallAction,
            )
        },
    )
}

@Composable
public fun ControlActions(
    call: Call,
    modifier: Modifier = Modifier,
    onCallAction: (CallAction) -&gt; Unit = { DefaultOnCallActionHandler.onCallAction(call, it) },
    actions: List&lt;(@Composable () -&gt; Unit)&gt; = buildDefaultCallControlActions(onCallAction)
) {
}
</code></pre>

<p>如需了解更多<a href="https://getstream.io/video/docs/android/ui-components/call/call-controls/"> ControlActions </a>的真实示例，你可以探索<a href="https://github.com/GetStream/stream-video-android/blob/c12db8cb6367e10682be3ab323d50dfcc59032f3/stream-video-android-ui-compose/src/main/kotlin/io/getstream/video/android/compose/ui/components/call/controls/ControlActions.kt#L48"> GitHub </a>上的实现。</p>

<h3>3. 使用主题进行定制</h3>

<p>设计 Compose 组件时的另一个常见挑战是，随着组件层次结构的变大，提供清晰、直接的可定制性变得更加困难。例如，假设你想为组件多个部分使用的视频渲染器提供可定制性，但 UI 层次结构嵌套很深且很复杂，如下例所示：</p>

<pre><code class="Kotlin">@Composable
fun CallContent() {
    ParticipantsLayout {
      ParticipantsRegularGrid {
        OrientationVideoRenderer {
          LazyVerticalGrid {
            VideoRenderer() // &lt;-- users want to customize this renderer style
          }
        }
      }

      FloatingVideoRenderer {
        VideoRenderer() // &lt;-- users want to customize this renderer style
      }
    }
}
</code></pre>

<p>在这种情况下，将插槽或样式参数从最顶层的组件一直传递到 VideoRenderer 组件并不理想。随着你在不同组件之间添加更多可定制性，最顶层的组件 (CallContent) 可能会因大量插槽和样式参数而变得过载。这不仅使你的 API 更难维护，而且还增加了用户混淆或误用的可能性，因为不清楚哪个参数用于什么用途。</p>

<p>为了解决这个问题，你可以利用自定义主题和<a href="https://developer.android.com/develop/ui/compose/compositionlocal"> CompositionLocal</a>来实现可定制性，同时保持 API 更清晰、更易于管理，如下例所示：</p>

<pre><code class="Kotlin">@Immutable
public data class VideoRendererStyle(
    val backgroundColor: Color = Color.Black,
    ..
)

private val LocalVideoRendererStyle = compositionLocalOf&lt;VideoRendererStyle&gt; {
    error("No VideoRendererStyle provided! Make sure to wrap all usages of Stream components in a VideoTheme.")
}

@Composable
public fun VideoTheme(
    videoRendererStyle: VideoRendererStyle = VideoRendererStyle(),
    content: @Composable () -&gt; Unit,
) {
    CompositionLocalProvider(
        LocalVideoRendererStyle provides videoRendererStyle,
    ) {
        content()
    }
}
</code></pre>

<p>现在，你可以通过在不同的组件中使用提供的样式来确保组件样式的一致性，而无需将它们作为参数反复传递。此外，用户可以通过创建自己的自定义主题轻松自定义样式，如下例所示：</p>

<pre><code class="Kotlin">setContent {
    VideoTheme(
        videoRendererStyle = VideoRendererStyle(backgroundColor = Color.Blue)
    ) {
      ..
    } 
}
</code></pre>

<p>如果你希望更广泛地应用此策略并高效地管理更多样式，则可以将它们合并为一个类，例如 StreamStyles ，并提供统一的样式类，而不是 CompositionLocal 中的多个单独样式。有些同学可能会担心 CompositionLocal 带来的性能影响，因为它会在值更改时触发布局层次结构的重组，但主题通常不会在应用程序中频繁更新。它们通常是静态的，以确保设计一致性，因此在这种情况下使用 CompositionLocal 是一种合适且有效的选择。</p>

<h2>预览（Preview）的兼容性</h2>

<p>提供预览非常重要，尤其是在构建组件 API 时，因为它们允许开发人员直接在 Android Studio 中可视化和验证他们的 UI 设计。
一些同学依靠<a href="https://developer.android.com/develop/ui/compose/tooling#live-edit-literals"> Live Literals </a>来动态展示预览中的变化，而其他同学则使用屏幕截图测试来确保其组件的视觉一致性。因此，在实现 Compose 组件时，必须确保它们与 Android Studio 中的预览功能完全兼容，如下面的屏幕截图所示：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*R74xLmTnWswi86ww" alt="Preview" /></p>

<p>有时，你的组件可能会产生副作用，例如在发出网络请求或处理动态状态后渲染图像，这可能会导致预览出现故障。在这种情况下，你可以利用<a href="https://developer.android.com/develop/ui/compose/tooling/previews#localinspectionmode"> LocalInspectionMode</a>。</p>

<p>LocalInspectionMode 允许你确定可组合项是否在预览模式下呈现，从而使你可以呈现专门用于预览目的的专用布局。这种方法可确保预览保持功能，即使你的组件依赖于复杂的逻辑或外部资源。你可以从<a href="https://github.com/skydoves/landscapist"> Landscapist </a>中找到一个用于网络图像加载的 Jetpack Compose 库的真实示例，它演示了处理预览的最佳实践。</p>

<p>下面的可组合函数会检查它是否处于预览模式。如果是，它会渲染静态图像，而不是执行诸如获取网络数据之类的副作用。这种方法允许用户为 GlideImage 可组合函数构建自己的预览，而不会在预览渲染期间遇到运行时错误。</p>

<pre><code class="Kotlin">@Composable
public fun GlideImage(
  imageModel: () -&gt; Any?,
  modifier: Modifier = Modifier,
  previewPlaceholder: Painter? = null,
  ..
) {
  if (LocalInspectionMode.current &amp;&amp; previewPlaceholder != null) {
      Image(
        modifier = modifier,
        painter = previewPlaceholder,
        ..
      )
      return
  }

  // complex logic about requesting network data and render it
  ..
)
</code></pre>

<p>为了增强项目中的整体预览策略，请考虑探索<a href="https://getstream.io/blog/effective-compose-preview/">设计有效的 UI 以增强 Compose 预览</a>。此资源提供了有价值的见解和技术，可有效优化你的 Compose 预览。</p>

<h2>结论</h2>

<p>在本文中，我们探讨了在 Jetpack Compose 中制作有效 UI 组件的策略，重点关注最佳实践，例如高效处理Modifier、确保设计与主题一致、实施可定制性策略以及增强预览兼容性。设计直观且强大的 API 始终是一项挑战，但努力终将获得回报，因为用户体验和开发者满意度显著提升。</p>

<p>如果你对本文有任何疑问或反馈，可以在 Twitter<a href="https://twitter.com/github_skydoves"> @github_skydoves </a>或<a href="https://github.com/skydoves"> GitHub </a>上找到作者。如果你想随时了解 Stream 的最新动态，请在 Twitter 上关注我们<a href="https://twitter.com/getstream_io"> @getstream_io</a>，获取更多精彩的技术内容。</p>

<p>老规矩，祝你编码愉快！ &ndash; <a href="https://github.com/skydoves">Jaewoong</a></p>

<p>最初<a href="https://getstream.io/blog/designing-effective-compose/">发布于 GetStream.io</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[不使用Jetpack Compose的10个理由]]></title>
    <link href="https://alexhilton.github.io/blog/2025/03/06/reasons-not-to-use-jetpack-compose/"/>
    <updated>2025-03-06T22:25:19+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/03/06/reasons-not-to-use-jetpack-compose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自<a href="https://sonique6784.medium.com/10-reasons-to-not-use-jetpack-compose-719de5d37c9e">10 reasons to NOT use Jetpack Compose</a>，原文发布于2024年9月24日。</p></blockquote>

<p><strong>译者按：</strong> 软件开发行业从不缺少优秀的工具，当然也没有银弹。身为开发者要学会选择合适的工具，避免出现手里拿着锤子，看什么都是钉子。那么就需要搞清楚两个事情，一个是面临的到底是什么样的问题，以及每种工具它的合适场景是什么。没有对与错，只有合适不合适。这篇文章就是帮助大家更清晰地了解到Jetpack Compose适用的场景，帮助Android开发者做出最合适的选择。</p>

<h2>简介</h2>

<p>Jetpack Compose 是一款出色的 UI 工具包，受到 Android 社​​区的热烈欢迎。它提供了一种为你的 Android 应用构建令人愉悦的 UI 的现代方式。</p>

<p><a href=""><img src="https://www.sixt.tech/assets/jetpack-compose/jetpack-compose.png" title="auto auto" ></a></p>

<!-- more -->


<p>我确实喜欢 Jetpack Compose，但与任何技术一样，它也有一些注意事项。在本文中，我们将了解在什么情况下使用 View 系统更为明智以及原因。</p>

<h2>1. 尽可能减少依赖</h2>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BSFMClR4UbDbGhkXdfHhqg.png" alt="Compose Dependencies" /></p>

<p>如果你需要尽可能少的依赖项，这可能是出于兼容性或安全性目的，那么使用 View 系统可能会更好。View 系统不需要额外的导入。它位于 Android 系统内部，与 Jetpack Compose 不同，后者需要大量依赖项，这会增加包占用空间和运行时的内存使用量，并为额外的风险打开大门。</p>

<h2>2. 性能</h2>

<p>View 系统自 Android 的第一个版本以来就一直存在，它非常成熟，15 年来已经进行了大量优化，对于复杂的布局，其性能通常比 Jetpack Compose 更好。Jetpack Compose 在每次迭代中都在改进，有时已经比 View 更好，请关注这个领域，View 可能很快就会失去性能之王的桂冠！</p>

<h2>3. Espresso测试</h2>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xEebB2vruLxuGrxeoePu0g.png" alt="Espresso测试" /></p>

<p>如果你有大量基于 View 的 Espresso 测试，或者想要使用 Android Studio 中的测试记录功能，最好避免使用 Jetpack Compose，或者只考虑将 Jetpack Compose 用于新的页面。无法轻松将于View 的 Espresso 测试迁移到 Compose。此外<a href="https://developer.android.com/studio/test/other-testing-tools/espresso-test-recorder">记录 Espresso 测试功能</a>不适用于 Compose。但是，可以<a href="https://developer.android.com/develop/ui/compose/testing">手动编写 Espresso </a>来测试 Compose。</p>

<h2>4. 稳定性和成熟度</h2>

<p>我们在「性能」部分简要提到了这一点。Jetpack Compose 已有 3 年历史，每次发布都会有所改进，但有时可能会出现错误。此外，许多 Compose 功能仍处于实验阶段，需要注解才能使用。使用实验性功能可能会给你的业务带来潜在的问题。</p>

<pre><code class="Kotlin">// 有些特性，如Modifier，Layout和Material Design是实验性质的，需要显式的用OptInt。
@OptIn(ExperimentalMaterialApi::class)
@OptIn(@ExperimentalFoundationApi::class)
@OptIn(ExperimentalComposeUiApi::class)
@OptIn(ExperimentalLayoutApi::class)
</code></pre>

<p>如果你需要非常高的成熟度和稳定性，你可能希望坚持使用View 系统。</p>

<h2>5. 功能缺失</h2>

<p>View 系统是 Android 历史的一部分。许多 Android 功能首先在 View 上可用，然后移植到 Compose，通常 Compose 可能只提供一个包装器（例如 Google Maps）。因此，你可能希望保留 View 系统，直到这些功能在 Compose 上可用。请注意，你可以使用 AndroidView 访问那些仅限 View 的功能，Compose 最终会实现这一点。</p>

<h2>6. 广泛应用于现有应用中</h2>

<p>在你的职业生涯中，你很可能需要处理 View。许多大公司即使采用了 Jetpack Compose，仍然使用 View。将 View 页面迁移到 Compose 可能会带来高昂的成本，而对最终客户而言，价值相对较低。大多数公司选择逐步采用 Compose，使用 View 系统来维护较旧的 UI。你可能需要 View 技能才能有效地将 View 转换为 Compose。</p>

<h2>7.APK 大小</h2>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MyanicOBr--xVFZUqSaxEg.png" alt="APK大小" /></p>

<p>如果你担心软件包的大小，你可以重新考虑是否采用 Jetpack Compose。它将使你的软件包大小至少<a href="https://www.reddit.com/r/androiddev/comments/1c5vjhi/i_see_your_enterprisegrade_jetpack_compose_11mb/">增加几MB</a>，虽然你可以启用<a href="https://r8.googlesource.com/r8/+/refs/heads/master/compatibility-faq.md#r8-full-mode"> R8 完整模式</a>以进一步减小大小。但是，View 系统的占用的额外空间几乎为零，因为组件是系统的一部分，不需要额外的库。</p>

<h2>8. 与旧设备的兼容性</h2>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C-GWYdBlBQfjl4jHLexP7Q.png" alt="老旧设备你" /></p>

<p>Jetpack Compose 最高可兼容 Android API 21（Lollipop🍭 、Android 5.0）。如果你想要针对性地适配以前的 Android 版本，则必须使用 View。</p>

<h2>9. 嵌入和物联网设备</h2>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WMYdpUZ4oDT6Axy2GSp0CQ.png" alt="物联网设备" /></p>

<p>单一用途的设备（自助服务终端、支付终端、自助结账）通常只运行一个应用，并且 CPU 和 RAM 资源有限。对于这些设备来说，Jetpack Compose 可能太重了，可能需要 Android 开发人员使用 View 系统来适应设备规格。这些设备也可能运行比较旧的Android版本，如 4.0 版。</p>

<h2>10. 你不想学习新东西</h2>

<p>也许你已经接近职业生涯的尾声，或者想要转到其他领域，那么在某些情况下，学习 Jetpack Compose 是没有意义的。学习曲线有点陡峭，因为与 View 相比，这是一种非常新的 UI 开发方法。不过，学习它可能很有用，因为其他框架（如 React 和 Flutter）也使用了某些类似的原理。</p>

<h2>结论</h2>

<p>Jetpack Compose 是一款出色的 UI 工具包，无疑是 Android 的未来，但它并不是唯一的 UI 工具包，View 已经证明它工作得很好，虽然有些人认为它是遗留的，但最好选择适合你的需求和限制的框架。
无论你选择哪种框架，玩得开心！Android 开发丰富多样，作为 Android 开发人员，我们的职责就是利用这些优势。</p>

<p>感谢你阅读本文，希望你喜欢并学到一些东西。请帮忙点赞，以表示你的支持！</p>

<p>本文由<a href="http://androiddev.news/"> Android 开发者新闻</a>赞助，在<a href="https://play.google.com/store/apps/details?id=sonique.fr.adn"> Play 商店下载</a>应用程序。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解Android中的内存泄漏以及如何让LeakCanary来帮忙]]></title>
    <link href="https://alexhilton.github.io/blog/2025/03/01/understanding-memory-leaks/"/>
    <updated>2025-03-01T11:05:54+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/03/01/understanding-memory-leaks</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自<a href="https://proandroiddev.com/understanding-memory-leaks-in-android-how-leakcanary-can-help-4768df60f646">Understanding Memory Leaks in Android &amp; How LeakCanary Can Help</a>，原文发布于2024年12月27日。</p></blockquote>

<p><strong>译者注：</strong> 关于内存优化，笔者也曾经写过两篇文章，侧重于内存问题的深入分析，如有兴趣可以作为拓展阅读：<a href="https://juejin.cn/post/7277489569958756364">让你不再惧怕内存优化</a>和<a href="https://juejin.cn/post/7287913786038992915">Android应用性能剖析全攻略</a>。</p>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sx4veSpq_Z1oYBsP5Q7nwQ.jpeg" title="auto auto" ></a></p>

<!-- more -->


<p>作为 Android 开发者，管理内存是构建高性能应用的一个最关键方面。开发者面临的一个最常见问题是内存泄漏。这些泄漏会对应用的性能和用户体验产生负面影响，导致运行缓慢、崩溃甚至电池耗尽你。但别担心——有一种解决方案可以让发现和修复内存泄漏变得更容易，那就是LeakCanary。</p>

<p>在这篇文章中，我们将首先探讨什么是内存泄漏、为什么会发生内存泄漏，然后介绍 LeakCanary 作为检测和修复 Android 应用程序中这些泄漏的强大工具。</p>

<h2>什么是内存泄漏？</h2>

<p>当你的应用保留不再需要的内存时，就会发生内存泄漏。简单来说，当不再使用的对象没有从内存中正确清除时，就会发生内存泄漏，从而导致你的应用消耗了不必要的内存。随着时间的推移，这可能会导致性能下降，在极端情况下，还会导致应用崩溃。</p>

<h2>内存泄漏为何如此危险？</h2>

<p>内存泄漏乍一看似乎无害，但它可能会给你的 Android 应用带来严重问题：</p>

<ol>
<li><strong>内存使用量增加：</strong> 当内存未释放时，应用会不断消耗更多资源，导致内存消耗过高。</li>
<li><strong>性能下降：</strong> 随着时间的推移，内存中保存的对象越来越多，应用会变得越来越慢，导致延迟和用户体验不佳。</li>
<li><strong>应用崩溃：</strong> 如果内存消耗达到临界水平，你的应用可能会崩溃甚至强制关闭。</li>
<li><strong>电池耗尽：</strong> 内存泄漏可能导致进程在后台运行，从而比预期更快地耗尽设备电池。</li>
</ol>


<h2>Android 中内存泄漏的常见原因</h2>

<ol>
<li><strong>保存对上下文的引用：</strong> 如果你在静态变量或单例中保存对 Activity 或 Context 的引用，它将永远不会被垃圾回收，因为系统仍会考虑正在使用的 Activity 或 Context。</li>
<li><strong>内部类和匿名类：</strong> 它们隐式保存对外部类（通常是 Activity 或 Fragment）的引用，从而防止它们被垃圾回收。</li>
<li><strong>未关闭的资源：</strong> 完成后不关闭 Cursor、Stream 或数据库连接等资源可能会导致内存堆积。</li>
<li><strong>事件侦听器：</strong> 如果你向 UI 元素添加侦听器（例如 OnClickListener），但在不再需要它们后没有将其删除，这些对象可能会泄漏内存。</li>
</ol>


<h2>LeakCanary 如何帮助检测 Android 中的内存泄漏</h2>

<p>现在我们了解了内存泄漏可能导致的问题，让我们来讨论一下可以帮助我们检测内存泄漏的工具：LeakCanary。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xas01FOk-1FlwDFe.png" alt="LeakCanary" /></p>

<p>LeakCanary 是一个适用于 Android 的开源内存泄漏检测库。它旨在自动识别开发过程中应用中的内存泄漏，让你在影响用户之前修复它们。</p>

<ul>
<li>当发生内存泄漏时，LeakCanary 会自动触发堆转储，对其进行分析，并向开发人员提供一份报告，指出泄漏发生的位置。这使开发人员能够更轻松地发现和解决内存泄漏，以免导致性能问题。</li>
</ul>


<h3>LeakCanary 如何工作？</h3>

<p>LeakCanary 的工作原理是监控应用的内存并分析堆转储以识别不应该存在的对象。当检测到内存泄漏时，它会生成一份报告，显示泄漏发生的位置，从而帮助你找出根本原因。</p>

<ol>
<li><strong>堆转储：</strong> 当 LeakCanary 检测到潜在泄漏时，它会进行堆转储（应用内存的快照），并将其与垃圾回收后的堆进行比较。如果它发现不应保留的对象，它会将其标记为泄漏。</li>
<li><strong>泄漏的对象：</strong> LeakCanary 会向你显示哪些对象被保存在内存中以及引用链中，帮助你识别导致泄漏的对象以及它仍被保留的原因。</li>
<li><strong>通知：</strong> 每当 LeakCanary 发现内存泄漏时，它都会在应用的调试版本中通知你。你可以快速访问报告并开始解决问题。</li>
</ol>


<p>LeakCanary 自动检测以下对象的泄漏：</p>

<ul>
<li>销毁的 Activity 实例</li>
<li>销毁的 Fragment 实例</li>
<li>销毁的 fragment View 实例</li>
<li>清除的 ViewModel 实例</li>
<li>销毁的 Service 实例</li>
</ul>


<h3>如何将 LeakCanary 集成到 Android 项目中？</h3>

<p>要将 LeakCanary 集成到 Android 项目中，请按照以下步骤操作：</p>

<ul>
<li><strong>添加 LeakCanary 依赖项：</strong> 在 build.gradle 文件（应用程序级别）中，添加以下内容：</li>
</ul>


<pre><code class="Groovy">dependencies {
    debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.9.1'
}
</code></pre>

<ul>
<li><strong>初始化 LeakCanary：</strong> LeakCanary 在调试构建类型中自动初始化。但是，你可以在 Application 类中手动初始化它：</li>
</ul>


<pre><code class="Java">public class MyApplication extends Application {
    @Override
    public void onCreate() {
        super.onCreate();
        if (LeakCanary.isInAnalyzerProcess(this)) {
            return; // LeakCanary is in heap analysis process
        }
        LeakCanary.install(this); // Initialize LeakCanary
    }
}
</code></pre>

<ul>
<li><strong>在调试模式下运行应用程序</strong>，LeakCanary 将在开发阶段检测内存泄漏。</li>
</ul>


<h3>如何在生产版本中使用 LeakCanary？</h3>

<p>虽然 LeakCanary 专为调试和开发而设计，但在生产环境中使用它时应谨慎。它可能会影响应用性能，并可能不必要地暴露与内存相关的数据。但是，如果你出于某种原因需要在生产环境中启用它，则可以有条件地仅在某些构建版本中添加 LeakCanary：</p>

<pre><code class="Groovy">dependencies {
    releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:2.9.1' // No-op for release
    debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.9.1'
}
</code></pre>

<p>这样，LeakCanary 仅在调试版本中处于活动状态，而无操作版本则用于生产。</p>

<h3>你将采取什么步骤来修复 LeakCanary 报告的内存泄漏？</h3>

<p>当 LeakCanary 报告内存泄漏时，请按照以下步骤解决：</p>

<ol>
<li><p><strong>分析泄漏报告：</strong> LeakCanary 提供一份详细的报告，其中包含一个对象引用链，显示泄漏发生的位置。</p></li>
<li><p><strong>识别泄漏对象：</strong> 查找意外保存在内存中的对象（如 Activity、Fragment 或 Context）。</p></li>
<li><p><strong>修复泄漏：</strong></p>

<ul>
<li>避免将 Activity 或 Context 引用存储在静态变量或长寿命对象中。</li>
<li>确保关闭 Cursor、Stream 等资源。</li>
<li>在不再需要时删除侦听器和回调。</li>
</ul>
</li>
<li><strong>测试修复：</strong> 进行更改后，重新运行你的应用以确认内存泄漏已解决。</li>
</ol>


<h3>LeakCanary 有哪些局限性？</h3>

<p>虽然 LeakCanary 是一款出色的工具，但它也有一些局限性：</p>

<ul>
<li><strong>并非所有泄漏都能被检测到：</strong> LeakCanary 专注于 Java 堆内存泄漏，但它可能无法检测本机内存泄漏或低级问题。</li>
<li><strong>对性能的影响：</strong> 由于堆分析过程，在开发过程中运行 LeakCanary 可能会稍微减慢你的应用速度。</li>
<li><strong>不能取代良好的内存管理：</strong> 虽然 LeakCanary 有助于检测泄漏，但开发人员仍应遵循内存管理的最佳实践，以防止泄漏发生。</li>
</ul>


<h2>结论</h2>

<p>内存管理对于确保 Android 应用高效运行至关重要。LeakCanary 是一款功能强大的工具，可帮助你在内存泄漏影响应用性能之前检测并解决内存泄漏问题。通过遵循最佳实践并将 LeakCanary 集成到你的开发过程中，你可以确保你的应用保持优化状态并且不会出现与内存相关的问题。</p>

<p>检查你是否已在 Android 应用程序中完成以下所有操作：</p>

<ol>
<li><a href="https://developers.google.com/maps/documentation/places/android-sdk/memory-best-practices#rel-unused">释放未使用的资源。</a></li>
<li><a href="https://developers.google.com/maps/documentation/places/android-sdk/memory-best-practices#unreg">不再需要时取消注册监听器。</a></li>
<li><a href="https://developers.google.com/maps/documentation/places/android-sdk/memory-best-practices#cancel-tasks">不需要时取消任务。</a></li>
<li><a href="https://developers.google.com/maps/documentation/places/android-sdk/memory-best-practices#fwd-lifecyc">发生命周期方法以释放资源。</a></li>
<li><a href="https://developers.google.com/maps/documentation/places/android-sdk/memory-best-practices#latest-versions">使用最新版本的 SDK。</a></li>
</ol>


<h2>参考</h2>

<ul>
<li><a href="https://developers.google.com/maps/documentation/places/android-sdk/memory-best-practices">https://developers.google.com/maps/documentation/places/android-sdk/memory-best-practices</a></li>
<li><a href="https://square.github.io/leakcanary/">https://square.github.io/leakcanary/</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[选择Retrofit还是Ktor：给Android开发者的指南]]></title>
    <link href="https://alexhilton.github.io/blog/2025/02/26/retrofit-vs-ktor/"/>
    <updated>2025-02-26T22:50:55+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/02/26/retrofit-vs-ktor</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自<a href="https://proandroiddev.com/when-to-use-retrofit-and-when-to-use-ktor-a-guide-for-android-developers-918491dcf69a">When to Use Retrofit and When to Use Ktor: A Guide for Android Developers</a></p></blockquote>

<p>作为 Android 开发人员，为你的项目选择正确的 HTTP 客户端是一项关键的决定。当今最受欢迎的两个选项莫过于 Retrofit 和 Ktor。虽然Retrofit 多年来一直是事实上的标准，但 Ktor 因其现代架构和灵活性而势头强劲。</p>

<p><a href=""><img src="https://robotqa.com/blog/wp-content/uploads/2024/06/202406120818248.png" title="auto auto" ></a></p>

<!-- more -->


<p>在本文中，我们将探讨你应该选择 Retrofit 或 Ktor 的场景，以及它们的优势如何满足你的应用要求。</p>

<h2>了解基础知识</h2>

<p>先来了解一下基础知识：</p>

<h3>Retrofit</h3>

<p>Retrofit 是 Square 开发的适用于 Android 和 Java 的类型安全 HTTP 客户端。它将 API 调用抽象为声明式接口，并使用 Gson 或 Moshi 等库无缝地将 JSON 解析为 Java/Kotlin 对象。</p>

<h3>Ktor</h3>

<p>Ktor 由 JetBrains 开发，是一款基于 Kotlin 的异步框架，用于构建联网应用程序。它不仅仅是一个 HTTP 客户端，而是一个多用途框架，让你能够使用同一个库构建后端服务并发出网络请求。</p>

<h2>何时使用 Retrofit？</h2>

<h3>1. 你需要简单和可读性</h3>

<p>如果你更喜欢使用预定义接口以直观的方式进行 API 调用，Retrofit 是一个绝佳的选择。</p>

<p>例子：</p>

<pre><code class="Kotlin">interface ApiService {
    @GET("posts")
    suspend fun getPosts(): List&lt;Post&gt;
}
</code></pre>

<p>使用 Retrofit，你可以预先定义 API 结构并专注于业务逻辑。</p>

<h3>2. 你的团队已经熟悉 Retrofit</h3>

<p>如果你的团队已有使用 Retrofit 的经验，那么坚持使用它可以降低学习曲线并加速开发。</p>

<h3>3. 你需要开箱即用的功能</h3>

<p>Retrofit 提供强大的功能，例如：</p>

<ul>
<li>自动解析 JSON 响应。</li>
<li>内置对 OkHttp 拦截器的支持。</li>
<li>轻松实现重试、缓存和日志记录。</li>
</ul>


<h3>4. 你在多语言环境中工作</h3>

<p>Retrofit 非常适合涉及 Java 和 Kotlin 的项目，因此它对于遗留代码库来说是一个绝佳的选择。</p>

<h3>5.你需要一个庞大的社区和资源</h3>

<p>Retrofit 的成熟意味着丰富的文档、教程和社区支持，这使其成为许多团队更安全的选择。</p>

<h2>何时使用 Ktor？</h2>

<h3>1. 你需要高度可定制性</h3>

<p>Ktor 允许你构建 HTTP 客户端，并对请求构建、日志记录和自定义管道进行细粒度的控制。</p>

<p>例子：</p>

<pre><code class="Kotlin">val client = HttpClient {
    install(JsonFeature) {
        serializer = KotlinxSerializer()
    }
}
</code></pre>

<h3>2. 你想利用 Kotlin Multiplatform</h3>

<p>Ktor 的多平台支持是其突出的功能之一。如果你正在为 Android、iOS 和其他平台构建应用程序，Ktor 可确保你在所有平台上使用相同的网络逻辑。</p>

<h3>3. 你正在构建轻量级或模块化应用程序</h3>

<p>Ktor 的模块化设计使其成为轻量级应用程序或网络堆栈需要精简和集中的项目的理想选择。</p>

<h3>4.你需要异步通信</h3>

<p>Ktor 原生使用协程，这使得处理并发比传统的基于回调的方法更简单、更高效。</p>

<h3>5. 你需要统一的后端和前端代码</h3>

<p>借助 Ktor，你可以使用相同的框架构建服务器端 API 和移动应用程序，从而简化开发并确保一致性。</p>

<h2>你应该选择哪一个？</h2>

<p>用一张表格来总结一下两者各自的特点：</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 特点 </th>
<th style="text-align:center;"> Retrofit </th>
<th style="text-align:center;"> Ktor </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> 易于使用 </td>
<td style="text-align:center;"> 高 </td>
<td style="text-align:center;"> 中等 </td>
</tr>
<tr>
<td style="text-align:center;"> Kotlin-first 设计 </td>
<td style="text-align:center;"> 否 </td>
<td style="text-align:center;"> 是 </td>
</tr>
<tr>
<td style="text-align:center;"> 跨平台支持 </td>
<td style="text-align:center;"> 否 </td>
<td style="text-align:center;"> 是 </td>
</tr>
<tr>
<td style="text-align:center;"> 可定制性 </td>
<td style="text-align:center;"> 中等 </td>
<td style="text-align:center;"> 高 </td>
</tr>
<tr>
<td style="text-align:center;"> 学习曲线 </td>
<td style="text-align:center;"> 低 </td>
<td style="text-align:center;"> 中等 </td>
</tr>
<tr>
<td style="text-align:center;"> 社区支持 </td>
<td style="text-align:center;"> 规模很大 </td>
<td style="text-align:center;"> 快速发展 </td>
</tr>
<tr>
<td style="text-align:center;"> 与协程集成 </td>
<td style="text-align:center;"> 通过添加suspend </td>
<td style="text-align:center;"> 是（集成了原生协程） </td>
</tr>
<tr>
<td style="text-align:center;"> 后端能力 </td>
<td style="text-align:center;"> 否 </td>
<td style="text-align:center;"> 是 </td>
</tr>
</tbody>
</table>


<h3>如果符合以下情况则选择 Retrofit：</h3>

<ul>
<li>你正在开发一个 Kotlin 或 Java 项目，其中简单性和快速开发是首要任务。</li>
<li>你的项目依赖于久经考验的工具和广泛的社区支持。</li>
<li>你需要对 REST API 进行最低限度的配置。</li>
</ul>


<h3>以下情况请选择 Ktor：</h3>

<ul>
<li>你正在构建一个 Kotlin Multiplatform 项目。</li>
<li>你需要一个现代、灵活的网络堆栈。</li>
<li>你需要同时支持前端和后端开发。</li>
</ul>


<h2>结论</h2>

<p>在 Retrofit 和 Ktor 之间进行选择取决于你的项目需求和你的团队对这些工具的熟悉程度。Retrofit 是传统 Android 项目的可靠选择，而 Ktor 则在现代 Kotlin 优先和多平台应用程序中表现出色。了解这些差异将有助于你为下一个 Android 应用做出正确的选择。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一文带你理解OkHttp中的Gzip压缩]]></title>
    <link href="https://alexhilton.github.io/blog/2025/02/25/understanding-okhttp-gzip-compression/"/>
    <updated>2025-02-25T22:28:09+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/02/25/understanding-okhttp-gzip-compression</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自<a href="ttps://medium.com/tech-insider/okhttps-gzip-compression-904919638458">OkHttp’s Gzip Compression</a>，原文发布于2020年5月1日。本文假定读者对HTTP有基本的了解，以及使用过OkHttp，否则理解起来可能会一点困难。</p></blockquote>

<p><strong>译注：</strong> OkHttp确实会自动添加gzip并处理响应。但如果显示的给请求添加除了gzip之外的字段，如&#8221;Accept-Encoding: gzip, deflate, br&#8221;，那么就需要手动处理响应。其实一般时候我们并不需要手动设置，除非是模拟浏览器时（比如用了浏览器的UA），或者某些服务器强制deflate字段。更多的信息可以<a href="https://stackoverflow.com/questions/51901333/okhttp-3-how-to-decompress-gzip-deflate-response-manually-using-java-android">看这里</a>。</p>

<p><a href=""><img src="https://img-blog.csdnimg.cn/879e064594104e0ab5671f6710ffea24.png" title="auto auto" ></a></p>

<!-- more -->


<p>压缩是一种简单有效的节省带宽和加快移动用户交互速度的方法。当用户点击你的页面屏幕时，会调用你的服务器来提供请求的响应。响应越大，屏幕上显示数据的时间就越长。通过压缩，即使你的访问者的互联网连接速度非常慢并且你的 API 响应过于繁重，他们也能享受快速加载。</p>

<h2>这是如何工作的呢？</h2>

<p><strong>Gzip 会找到相似的字符串，并用一些占位符临时替换这些字符串，以缩小整体大小。</strong>如果你使用大量重复文本，并且有大量空格， 这也没有问题。你可以使用 Gzip 压缩你的响应主体以及请求主体。由于文件小得多，此操作可大大减少传输时间。</p>

<p><strong>注意：</strong>如果你尝试使用postman，它会默认在header的隐藏部分中添加 Accept-Encoding: gzip字段。</p>

<blockquote><p>重要提示：OkHttp 也会自动在请求中添加字段 Accept-Encoding 并自动识别响应中的 Content-Encoding，因此会自行解压缩响应数据，因此无需单独设置，但假设当我们必须将压缩的请求数据发送到服务器时，我们就必须编写自己的拦截器。</p></blockquote>

<p>这种压缩的棘手之处在于请求者和服务器都知道可以发送压缩文件。你必须告诉服务器您接受这种编码，然后它才会提供。该协议分为两部分：</p>

<ul>
<li>请求者发送一个header，告知服务器它接受压缩内容：Accept-Encoding：gzip</li>
<li>服务器使用此header确认你的请求：Content-Encoding：gzip</li>
</ul>


<p>说得够多的了，我想你还有耐心，所以让我们看一些代码。</p>

<h2>编写自己的拦截器</h2>

<p>先决条件：了解 OkHttp 中的<a href="https://square.github.io/okhttp/features/interceptors/">拦截器（Interceptors）</a>。</p>

<ol>
<li>解开 Gzip 响应：在请求header中添加 Accept-Encoding: gzip，并在获取响应时在其响应header中查找 Content-Encoding: gzip。如果存在则解压缩，否则直接返回响应。</li>
</ol>


<pre><code class="Java">import java.io.IOException;

import okhttp3.Headers;
import okhttp3.Interceptor;
import okhttp3.Request;
import okhttp3.Response;
import okhttp3.ResponseBody;
import okio.GzipSource;
import okio.Okio;

public class GzipInterceptor implements Interceptor {
    @Override
    public Response intercept(Chain chain) throws IOException {
        Request.Builder newRequest = chain.request().newBuilder();
        newRequest.addHeader("Accept-Encoding", "gzip");
        Response response = chain.proceed(newRequest.build());

        if (isGzipped(response)) {
            return unzip(response);
        } else {
            return response;
        }
    }

    private Response unzip(final Response response) throws IOException {

        if (response.body() == null) {
            return response;
        }

        GzipSource gzipSource = new GzipSource(response.body().source());
        String bodyString = Okio.buffer(gzipSource).readUtf8();

        ResponseBody responseBody = ResponseBody.create(response.body().contentType(), bodyString);

        Headers strippedHeaders = response.headers().newBuilder()
                .removeAll("Content-Encoding")
                .removeAll("Content-Length")
                .build();
        return response.newBuilder()
                .headers(strippedHeaders)
                .body(responseBody)
                .message(response.message())
                .build();

    }

    private Boolean isGzipped(Response response) {
        return response.header("Content-Encoding") != null &amp;&amp; response.header("Content-Encoding").equals("gzip");
    }
}
</code></pre>

<ol>
<li>创建 Gzip 请求：如果你的请求过大，那么我们可以使用它来压缩我们的请求。为了通知服务器，我们将在请求header中添加 Content-Encoding: gzip。</li>
</ol>


<pre><code class="Java">import java.io.IOException;

import okhttp3.Interceptor;
import okhttp3.MediaType;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okio.BufferedSink;
import okio.GzipSink;
import okio.Okio;

public class GzipInterceptor implements Interceptor {
    @Override public Response intercept(Interceptor.Chain chain) throws IOException {
        Request originalRequest = chain.request();

        if (originalRequest.body() == null || originalRequest.header("Content-Encoding") != null) {
            return chain.proceed(originalRequest);
        }

        Request compressedRequest = originalRequest.newBuilder()
                .header("Content-Encoding", "gzip")
                .method(originalRequest.method(), gzip(originalRequest.body()))
                .build();
        return chain.proceed(compressedRequest);
    }

    private RequestBody gzip(final RequestBody body) {
        return new RequestBody() {
            @Override public MediaType contentType() {
                return body.contentType();
            }

            @Override public long contentLength() {
                return -1; // 事先不知道请求内容的长度
            }

            @Override public void writeTo(BufferedSink sink) throws IOException {
                BufferedSink gzipSink = Okio.buffer(new GzipSink(sink));
                body.writeTo(gzipSink);
                gzipSink.close();
            }
        };
    }
}
</code></pre>

<p>好了，就到这里吧，如果你愿意的话，可以赞一下。</p>

<p>参考资料：</p>

<ol>
<li><a href="https://square.github.io/okhttp/">https://square.github.io/okhttp/</a></li>
<li><a href="https://www.apphp.com/tutorials/index.php?page=gzip-and-deflate-compression-in-web-development">https://www.apphp.com/tutorials/index.php?page=gzip-and-deflate-
compression-in-web-development</a></li>
<li><a href="https://www.youtube.com/watch?v=Mjab_aZsdxw">https://en.wikipedia.org/wiki/Gzip</a></li>
<li><a href="https://www.youtube.com/watch?v=Mjab_aZsdxw">https://www.youtube.com/watch?v=Mjab_aZsdxw</a></li>
</ol>

]]></content>
  </entry>
  
</feed>
