<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2015-10-13T08:22:03+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[安卓开发技术：监听软键盘的显示与隐藏]]></title>
    <link href="http://toughcoder.net/blog/2015/10/09/android-trick-detect-soft-keyboard-show-slash-hide/"/>
    <updated>2015-10-09T22:08:08+08:00</updated>
    <id>http://toughcoder.net/blog/2015/10/09/android-trick-detect-soft-keyboard-show-slash-hide</id>
    <content type="html"><![CDATA[<p>自从2007年乔帮主横空出世推出iPhone后，智能手机就都变成了触摸屏，且屏幕越来越大。输入自然也就通过软件来解决，现在来说绝大多数智能设备都是通过软键盘来做用户输入。在日常的开发过程中难免会跟软键盘打交道，比如强制显示或者强制隐藏等，也有些时候想要在键盘隐藏或者显示的时候做一点事情，这就需要准确的知道键盘的事件，这篇文章就来详细讨论一下Android下面如何做到监听键盘的事件。</p>

<p><a href=""><img src="http://static.yingyonghui.com/screenshots/1793/1793110_5.jpg"></a></p>

<!-- more -->


<h2>硬键盘显示隐藏的事件监听</h2>

<p>对于有硬键盘的设备，是会产生运行时的配置变更(<a href="http://developer.android.com/guide/topics/resources/runtime-changes.html#HandlingTheChange">Runtime Config Changes</a>)，因此可以通过<a href="http://developer.android.com/reference/android/app/Activity.html#onConfigurationChanged(android.content.res.Configuration">Activity#onConfigurationChanged</a>)回调来处理：</p>

<p>首先，要在AndroidManifest中给activity加上<a href="http://developer.android.com/guide/topics/manifest/activity-element.html#config">configChanges=&ldquo;keyboardHidden&rdquo;</a>。</p>

<p>然后，在代码中，处理：</p>

<pre><code class="java">@Override
public void onConfigurationChanged(Configuration newConfig) {
    super.onConfigurationChanged(newConfig);

    // Checks whether a hardware keyboard is available
    if (newConfig.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_NO) {
        Toast.makeText(this, "keyboard visible", Toast.LENGTH_SHORT).show();
    } else if (newConfig.hardKeyboardHidden == Configuration.HARDKEYBOARDHIDDEN_YES) {
        Toast.makeText(this, "keyboard hidden", Toast.LENGTH_SHORT).show();
    }
}
</code></pre>

<p>需要注意的是，要用<a href="http://developer.android.com/reference/android/content/res/Configuration.html#hardKeyboardHidden">Configuration#hardKeyboardHidden</a>而不是<a href="http://developer.android.com/reference/android/content/res/Configuration.html#keyboardHidden">Configuration#keyboardHidden</a>，因为只有当硬键盘状态变化时才会回调onConfigurationChanged。</p>

<h2>软键盘显示隐藏事件监听</h2>

<p>现在的Android设备很少才会有硬键盘，绝大多数都是软键盘，而SDK和API中却没有软键盘隐藏变化的相关事件，没有直接支持不代表做不到。我们通过其他的方式还是可以做到监听软键盘显示与隐藏状态变化的。</p>

<h3>override onKeyPreIme</h3>

<p>当<a href="http://developer.android.com/reference/android/widget/EditText.html">EditText</a>获得焦点时，或者用户点击时，都会把软键盘弹起来（2.x版本长按MENU也可以强制弹出软键盘）。但是，隐藏软键盘一般都是BACK键，或者键盘自身提供隐藏的按扭，再有就是用代码强制隐藏。对于BACK键还是可以处理的，因为这属于事件(<a href="http://developer.android.com/reference/android/view/KeyEvent.html">KeyEvent</a>)，是能监听到的。</p>

<h4>核心原理</h4>

<p>子例化EditText，并覆写方法<a href="http://developer.android.com/reference/android/widget/TextView.html#onKeyPreIme(int,%20android.view.KeyEvent">onKeyPreIme</a>)。这个方法能在输入法前面拦掉事件，从而可以做一些事情：</p>

<pre><code class="java">public class KeyPreImeEditText extends EditText {
    public KeyPreImeEditText(Context context) {
        super(context);
    }

    public KeyPreImeEditText(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public KeyPreImeEditText(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    @Override
    public boolean onKeyPreIme(int keyCode, KeyEvent event) {
        if (keyCode == KeyEvent.KEYCODE_BACK) {
            Log.e("keyboard", "onKeyPreIme we got back");
        }
        return super.onKeyPreIme(keyCode, event);
    }
}
</code></pre>

<h4>优点</h4>

<p>简单粗暴，都是SDK支持的方法和事件，所以不会有兼容性等蛋疼的问题。</p>

<h4>缺点</h4>

<p>这仅在输入法前拦截到BACK事件，而前面提到BACK仅是能让软键盘隐藏掉的一个方式而已，所以这个方法是不能够完全做到监听软键盘隐藏状态变化的。这个方法仅适用于想拦截BACK，做一些其他事情的场景。</p>

<h3>override根布局的onMeasure</h3>

<p>另外的思路就是观察软键盘引起的布局变化，比如软键盘弹起时Activity的整体布局都会发生变化。</p>

<h4>核心原理</h4>

<p>子例化Activity的根布局（比如<a href="http://developer.android.com/reference/android/widget/LinearLayout.html">LinearLayout</a>或者<a href="http://developer.android.com/reference/android/widget/RelativeLayout.html">RelativeLayout</a>，然后覆写其<a href="http://developer.android.com/reference/android/view/View.html#onMeasure(int,%20int">onMeasure</a>)方法，在其中判断View的当前高度与其本应有的高度，如果当前高度小于本应有的高度，则表明软键盘在：</p>

<pre><code class="java">public class KeyboardAwareLinearLayout extends LinearLayout {
    public KeyboardAwareLinearLayout(Context context) {
        super(context);
    }

    public KeyboardAwareLinearLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public KeyboardAwareLinearLayout(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        final int proposedHeight = MeasureSpec.getSize(heightMeasureSpec);
        final int actualHeight = getHeight();

        if (actualHeight &gt; proposedHeight) {
            Log.e("keyboard", "guess keyboard is shown");
        } else {
            Log.e("keyboard", "guess keyboard has been hidden");
        }
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    }
}
</code></pre>

<h4>优点</h4>

<p>能够真正实现对软键盘隐藏和显示的监听，也不算复杂。</p>

<h4>缺点</h4>

<p>这个基于的原理是键盘对Activity的布局产生影响的情况，而这又受到其他条件控制。activity的属性<a href="http://developer.android.com/guide/topics/manifest/activity-element.html#wsoft">windowSoftInputMode</a>控制着软键盘与布局之间的影响关系，对于adjustPan以及全屏模式的adjustResize这种方法就失效了，因为这二种情况软键盘弹起时，布局是不会发生变化的，二种height值是一样的，自然无法分辨。</p>

<h3>监听GlobalLayout</h3>

<p>与上面的思路差不多，只不是监听GlobalLayout变化，然后根据布局高度与屏幕高度之差来判断。</p>

<p><strong>注意</strong>：要记得把注册的GlobalLayoutListener再反注册掉。</p>

<h4>计算根布局的高度差</h4>

<p>判断的依据是根布局与DectorView之间的差值，在正常情况下应该等于status bar高度与action bar高度之和。当软键盘弹起时则会大于此值。</p>

<h5>核心原理</h5>

<pre><code class="java">private boolean mKeyboardUp;

private void setListenerToRootView() {
        final View rootView = getWindow().getDecorView().findViewById(android.R.id.content);
        rootView.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
            @Override
            public void onGlobalLayout() {
                final int headerHeight = getActionBarHeight() + getStatusBarHeight();
                int heightDiff = rootView.getRootView().getHeight() - rootView.getHeight();
                if (heightDiff &gt; headerHeight) {
                    Log.e("keyboard", "keyboard is up");
                    if (!mKeyboardUp) {
                        mKeyboardUp = true;
                    }
                } else if (mOpen) {
                    Log.e("keyboard", "keyboard is hidden");
                    mKeyboardUp = false;
                }
            }
        });
    }
</code></pre>

<p>这段代码需要好好解释下：</p>

<ul>
<li>android.R.id.content 通过这个id可以获得一个View的根布局，而不必要知道它具体的id。可以参考<a href="http://stackoverflow.com/questions/7776768/android-what-is-android-r-id-content-used-for">这个讨论</a>。</li>
<li>rootView 这个View是Activity的根布局，除去了actionbar的部分，是一个FrameLayout，注意这个并不是setContentView中设置的布局。rootView的第一个子View(rootView.getChildAt(0))就是setContentView()设置的布局。可以参考<a href="http://stackoverflow.com/questions/4486034/get-root-view-from-current-activity">这个讨论</a>。</li>
</ul>


<h5>优点</h5>

<p>不用子例化，不依赖于现有代码中的成员，可以直接插入到任何代码中。</p>

<h5>缺点</h5>

<p>本质上这跟上一个方法是一样的。因此对于adjustPan和全屏的adjustResize二种情况是无效的。针对这二种情况heightDiff不会变化。</p>

<h4>计算根布局的的底部空隙</h4>

<p>其实所有的方法都是为了发现软键盘对布局的影响，从而判断软键盘的显示和隐藏。还有一种方法就判断根布局的可视区域与屏幕底部的差值，如果这个差大于某个值，可以认定键盘弹起了。</p>

<h5>核心原理</h5>

<pre><code class="java">private boolean isKeyboardShown(View rootView) {
        final int softKeyboardHeight = 100;
        Rect r = new Rect();
        rootView.getWindowVisibleDisplayFrame(r);
        DisplayMetrics dm = rootView.getResources().getDisplayMetrics();
        int heightDiff = rootView.getBottom() - r.bottom;
        return heightDiff &gt; softKeyboardHeight * dm.density;
}
</code></pre>

<p>得到的Rect就是根布局的可视区域，而rootView.bottom是其本应的底部坐标值，如果差值大于我们预设的值，就可以认定键盘弹起了。这个预设值是键盘的高度的最小值。这个rootView实际上就是DectorView，通过任意一个View再getRootView就能获得。</p>

<h5>优点</h5>

<p>适用所有情况，包括adjustPan和全屏的adjustResize也能准确判断出来。</p>

<h3>结论</h3>

<p>如果真的需要监听软键盘显示与隐藏的事件就可以通过上面的提到的最后一种方式来实现，简单方便且可靠，唯一要注意的就是要反注册掉所注册的GlobalLayoutListener.</p>

<h2>参考资料</h2>

<ul>
<li><a href="http://stackoverflow.com/questions/4312319/howto-capture-the-virtual-keyboard-show-hide-event-in-android">http://stackoverflow.com/questions/4312319/howto-capture-the-virtual-keyboard-show-hide-event-in-android</a></li>
<li><a href="http://felhr85.net/2014/05/04/catch-soft-keyboard-showhidden-events-in-android/">Catch soft keyboard show/hidden events in Android</a></li>
<li><a href="http://blog.csdn.net/zhaokaiqiang1992/article/details/39761461">android:windowSoftInputMode属性详解</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Studio技能之快捷键]]></title>
    <link href="http://toughcoder.net/blog/2015/09/07/tricks-of-android-studio-shortcuts/"/>
    <updated>2015-09-07T23:10:27+08:00</updated>
    <id>http://toughcoder.net/blog/2015/09/07/tricks-of-android-studio-shortcuts</id>
    <content type="html"><![CDATA[<p>Android Studio是谷歌新一代的Android开发IDE，老一代的Eclipse+ADT已被无情的废弃。</p>

<p>Android Studio基于JetBrains的IntelliJ IDEA，这是一个在Java界享有不错声誉的IDE，它以“Intelligent”著称。AS是谷歌基于IntelliJ开发的，加上了一套专门为Android定制的插件系统。早期的时候AS＝IntelliJ + Android插件。但是现在没那么简单了，貌似AS中有的东西，在插件中却没有，具体的搞不太清楚了。</p>

<p>说了这么多都是废话。这里总结一下AS使用过程中常用的快捷键。</p>

<p><a href=""><img src="http://i.imgur.com/sSQV4G0.png" width="480" height="320"></a></p>

<!-- more -->


<h2>键盘的map（keymap)</h2>

<p>本质上讲AS就是IntelliJ，所以核心的东西是一样的，比如配置和快捷键，IntelliJ中快捷键是可以配置的，不但可以配置具体快捷键的组合，而且可以配置一套组合，或者叫作风格，也就是说可以按照喜好还定义不同的组合。支持的有：</p>

<ul>
<li>Mac OS X 10.5+</li>
<li>Mac OS X</li>
<li>Emacs</li>
<li>Visual Studio</li>
<li>Default for XWin</li>
<li>Default for GNOME</li>
<li>Default for KDE</li>
<li>Eclipse</li>
<li>Eclipse (Mac OS X)</li>
<li>NetBeans 6.5</li>
<li>JBuilder</li>
</ul>


<p>这里预定义的集合是相应的系统或者IDE所惯用的快捷键，所以如果你熟悉其中某些IDE，可以直接使用对应的风格，以更快的适应AS。</p>

<p><em>注意</em>： 这里介绍的快捷键是基于<strong>Mac OS X</strong>这个风格的。</p>

<p><em>注意</em>： 另外，对于所有JetBrains的产品比如PyCharm或者WebStorm，都是一样的。</p>

<p><em>注意</em>： 这里默认是Mac平台，如果是Windows或者Linux，把CMD换成Ctrl就可以了。</p>

<h2>选择的快捷键</h2>

<ul>
<li>可以用鼠标来选择，这个是显而易见的</li>
<li><strong>Shift + Up/Down/Left/Right</strong> 来选择</li>
<li><strong>Shift + 鼠标</strong>来选择，这个更灵活</li>
<li><strong>CMD + w</strong>&mdash; Expand selection, 比如选择光标所在的一个词，再按一次会选择更多，甚至一行。这个键比较强大，根据光标所在的内容不同表现也不略微不同，可以慢慢体会。</li>
<li><strong>Shift + CMD + w</strong> &mdash; Shrink selection，减少选择</li>
<li><strong>CMD + a</strong> &mdash; select all</li>
</ul>


<h2>基本快捷键</h2>

<ul>
<li><strong>CMD + s</strong>&mdash; 保存文件</li>
<li><strong>CMD + x</strong>&mdash; 剪切</li>
<li><strong>CMD + v</strong>&mdash; 粘贴</li>
<li><strong>CMD + z</strong>&mdash; Undo</li>
<li><strong>CMD + f</strong>&mdash; 查找</li>
<li><strong>CMD + r</strong>&mdash; 查找和替换</li>
<li><strong>ESC</strong> &mdash; 用于关闭打开的对话框，或者退出正在进行的重构</li>
</ul>


<h2>导航类快捷键</h2>

<ul>
<li><strong>CMD + F12</strong> &mdash; 打开类的outline，类似于Eclipse的Ctrl + o，还可以快速索引</li>
<li><strong>CMD + b</strong>&mdash; 打开函数或者一个类的定义</li>
<li><strong>CMD + u</strong>&mdash; 打开当前类的父类中的方法(super method)</li>
<li><strong>CMD + e</strong>&mdash; 打开一个最近打开的文件，也就是从最近打开过的文件中快速索引</li>
<li><strong>Shift + CMD + n</strong> &mdash; 快速打开一个文件</li>
<li><strong>CMD + n</strong>&mdash; 快速打开一个类</li>
<li><strong>CMD + fn + Left/Right</strong> &mdash; 移动到文件的第一行和最后一行</li>
<li><strong>CMD + Left/Right</strong> &mdash; 移到一行的开头或结尾，类似PC上的HOME/END</li>
<li><strong>CMD + 1(数字1）</strong>&mdash; 打开或者关闭Project侧边栏</li>
<li><strong>Option + CMD + Left/Right</strong> &mdash; 回到上一个/下一个编辑处</li>
<li><strong>CMD + g</strong>&mdash; 去到某一行</li>
<li><strong>Ctrl + h</strong>&mdash; 打开类的层次关系</li>
<li><strong>Ctrl + Option + h</strong>&mdash; 打开方法的调用路径，也就是当前方法被调用的层次关系</li>
<li><strong>Option + CMD + Up/Down</strong> &mdash; 在类层次关系中移动，打开父类或子类</li>
<li><strong>CMD + ;</strong> &mdash; 打开Project structure</li>
<li><strong>Option + F7</strong> &mdash; 查找使用(Find usages)</li>
<li><strong>CMD + F7</strong> &mdash; 在当前文件中查找使用</li>
<li><strong>CMD + Shift + i</strong> &mdash; 不离开当前窗口快速预览某个方法或者类的实现</li>
<li><strong>CMD + Shift + a</strong> &mdash; 可以索引快捷键设置，当忘记快捷键时，非常有用</li>
<li><strong>CMD + p</strong> &mdash; 显示当前方法的参数</li>
</ul>


<h2>代码相关</h2>

<ul>
<li><strong>CMD + o</strong> &mdash; 从父类中override一个方法</li>
<li><strong>Option + Enter</strong> &mdash; quick fix快速修复编译错误，比如导入类，实现父类方法等</li>
<li><strong>CMD + Option + l</strong> &mdash; 重新格式化代码，也就是按照预定义的代码格式来格式化代码</li>
<li><strong>CMD + Option + o</strong> &mdash; 优化导入语句</li>
<li><strong>CMD + Option + i</strong> &mdash; 调整缩进，或者叫做自动更正缩进</li>
<li><strong>Shift + CMD + &lsquo;+&rsquo;</strong> &mdash; 打开一个文件中的所有代码折叠</li>
<li><strong>Shift + CMD + &lsquo;-&rsquo;</strong> &mdash; 进行代码折叠</li>
<li><strong>Ctrl + Option + Space</strong> &mdash; 智能补全</li>
<li><strong>Shift + F6</strong> &mdash; 重构，重命名一个变量</li>
<li><strong>CMD + F6</strong> &mdash; 修改函数的签名</li>
<li><strong>Option + CMD + m</strong> &mdash; 提炼方法(Extract method)</li>
<li><strong>Option + CMD + f</strong> &mdash; 提炼成员变量</li>
<li><strong>Option + CMD + c</strong> &mdash; 提炼常量</li>
<li><strong>Shift + CMD + u</strong> &mdash; 把变量名方法名或者类名进行大小写转换</li>
</ul>


<h2>行操作&ndash;基本单位都是行</h2>

<ul>
<li><strong>CMD + y</strong>&mdash; 以行为单位进行删除，可以先选择多行，如果没有选择，就是当前行</li>
<li><strong>CMD + d</strong>&mdash; 以行为单位进行复制，可以先选择多行，如果没有选择，就是当前行</li>
<li><strong>CMD + Shift + Up/Down</strong> &mdash; 把行向上移动或向下移动，这个在调整代码的时候非常实用</li>
<li><strong>CMD + /</strong> &mdash; 注释掉所选择的行</li>
<li><strong>Ctrl + Shift + j</strong> &mdash; 把二行合为一行，把下行合到当前上来</li>
</ul>


<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/sdk/installing/studio-tips.html">官方指导</a></li>
<li><a href="http://www.androidgreeve.com/2013/12/android-studio-shortcuts-you-should-know.html">Android Studio shortcuts you should know</a></li>
<li><a href="http://zlv.me/posts/2015/07/13/14_android-studio-tips/">倍数提高工作效率的Android Studio奇技</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[优秀代码赏析：CircleImageView]]></title>
    <link href="http://toughcoder.net/blog/2015/08/25/understanding-circleimageview/"/>
    <updated>2015-08-25T23:29:26+08:00</updated>
    <id>http://toughcoder.net/blog/2015/08/25/understanding-circleimageview</id>
    <content type="html"><![CDATA[<h2>核心功能</h2>

<p>实现一个圆形的ImageView，或者说让一个View来显示一个圆形的图片。</p>

<h2>核心思路</h2>

<p>这个库短小精悍，全部代码才200多行，核心代码也就几十行，却实现了一个看似不简单的功能。</p>

<p>要想实现圆形的图片，常规一般的人的思路，用图像处理的方式来解决，就好比显示圆角矩形图片那样。但是这个库的作者的思路十分的巧妙，它的核心思路就是把图片画在一个圆上面。</p>

<p><a href=""><img src="https://camo.githubusercontent.com/e17a2a83e3e205a822d27172cb3736d4f441344d/68747470733a2f2f7261772e6769746875622e636f6d2f68646f64656e686f662f436972636c65496d616765566965772f6d61737465722f73637265656e73686f742e706e67"></a></p>

<!-- more -->


<p>首先要解释一下Shader（着色器）的概念，它的作用就是如何填充一个几何图形，图像学里面画一个可见的几何图形分二步，一个画形，另一个就是着色。比如我们常用的shape或者text，除了形状外，还有颜色，这也是一种着色方式，只不过是我们熟悉的颜色罢了。Shader最为常见的就是颜色，另外还可以是其他几何图形，纹理和图片。比如PhotoShop里面画东西时刷子的样式有无数种，矩形，三角，球，毛状的，其他图像等等，这也都是Shader。在Android中支持的Shader有颜色，也还有图片（Bitmap），也就是说可以把一个图片当成着色器，来画在几何形状上面，这也就是这个库的精妙所在。</p>

<h2>关键代码解析</h2>

<h3>准备资源</h3>

<p>这里的资源包括二个，一个是图片资源，另一个就是边缘的颜色。圆形外面还有一个border。图片资源跟标准的ImageView是一样的，可以是资源，可以是URI，可以是Drawable也可以是Bitmap。这些东西都要要转化成为Bitmap，再生成BitmapShader放在Paint对象里。</p>

<p><img class="<a" src="href="http://7u2scv.com1.z0.glb.clouddn.com/tcci_prepare.png">http://7u2scv.com1.z0.glb.clouddn.com/tcci_prepare.png</a>&#8221;></p>

<h3>绘制</h3>

<p>这个类的绘制是相当简单的，onDraw的关键代码只有二行，只做了二件事：</p>

<p><img class="<a" src="href="http://7u2scv.com1.z0.glb.clouddn.com/tcci_draw.png">http://7u2scv.com1.z0.glb.clouddn.com/tcci_draw.png</a>&#8221;></p>

<ul>
<li>用BitmapShader画一个圆</li>
<li>用border颜色画一个圆的边缘</li>
</ul>


<h3>缩放</h3>

<p>仅支持CenterCrop，缩放方式。也就是把图片等比缩放(也就是长和宽都按同一比例来缩放，以保证图片不变形)，以让最小的边刚好占满View的区域，大的一边如果超出会进行Crop。</p>

<p><img class="<a" src="href="http://7u2scv.com1.z0.glb.clouddn.com/tcci_centercrop.png">http://7u2scv.com1.z0.glb.clouddn.com/tcci_centercrop.png</a>&#8221;></p>

<p>为了进行CenterCrop，就要计算出View区域长宽与图片长宽的最大比例，然后把图片长和宽都以此为比例来缩放。再把超出的一边进行Crop。</p>

<p><img class="<a" src="href="http://7u2scv.com1.z0.glb.clouddn.com/tccircleimage.png">http://7u2scv.com1.z0.glb.clouddn.com/tccircleimage.png</a>&#8221;></p>

<p>详细的来解释下，如图所示，vw为目标View的区域的宽度，vh为目标区域高度，bw为图像的宽，bh为图像的高，只能是二种情况：过宽或者过高，图示第一种情况，明显是过高，所以缩放比例为vh/bh，按此比例缩放后nbw = bw*vh/bh > vw，所以要进行裁剪，左右各裁剪掉(nbw - vw)/2；对于第二情况也是如此。至于作者在translate时，为何都多加了个0.5个像素，是为了做round(四舍五入)，前面计算dx和dy时会做除2，而移动必须是以整数像素为单位，所以要做下round。</p>

<h2>项目地址</h2>

<p><a href="https://github.com/hdodenhof/CircleImageView">https://github.com/hdodenhof/CircleImageView</a></p>

<h2>如何使用</h2>

<p>优秀的库都是非常的易学易用，这个也不例外，简单来个例子：</p>

<pre><code class="xml">&lt;de.hdodenhof.circleimageview.CircleImageView
            xmlns:app="http://schemas.android.com/apk/res-auto"
            android:layout_width="160dp"
            android:layout_height="160dp"
            android:layout_centerInParent="true"
            android:src="@drawable/hugh"
            app:border_width="2dp"
            app:border_color="@color/dark" /&gt;
</code></pre>

<p>就像使用标准ImageView那样使用就好了，仅是多了特有的前缀来指定它需要的参数。更详细的可以参考官方的<a href="https://github.com/hdodenhof/CircleImageView/tree/master/sample">Sample</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实战技巧：Android异步指南]]></title>
    <link href="http://toughcoder.net/blog/2015/05/25/effective-android-asynchrony/"/>
    <updated>2015-05-25T23:49:19+08:00</updated>
    <id>http://toughcoder.net/blog/2015/05/25/effective-android-asynchrony</id>
    <content type="html"><![CDATA[<p>异步向来都是提高性能的必要手段，当然也是引发问题的常见根源。Android之中更是如此，主线程事关应用的流畅程度，所以把更多能放在工作线程中事，放到工作线程中去，是提升App性能之必经之路。Android中使用线程有多种方式，我们该如何选择，以及在使用过程中要注意哪些问题，今天就来探讨一下。</p>

<p><a href=""><img src="http://image.slidesharecdn.com/scandev-120418025620-phpapp02/95/threading-in-android-1-728.jpg?cb=1334718039"></a></p>

<!-- more -->


<h2>Bitmap处理</h2>

<p>在Android中显示图片，<a href="http://developer.android.com/reference/android/graphics/Bitmap.html">Bitmap</a>是必须要学会的。Bitmap是Android中抽象出来代表图片的类，把图片文件或者数据转化成Bitmap进而再放置到视图系统中显示。Bitmap的处理也常常会引发OOM问题。</p>

<p>关于Bitmap的处理，遵守二个原则，就是按需解析和及时释放。现在的图片文件都很大，但很多时候我们需要展示的区域（目标View的大小）却不是很大，这个时候就需要在解析的时候，适当的降低帧率，以减小所需要申请的内存。及时释放时也需要注意，要确定不用了，再释放，如果有View仍在显示时，在另外的地方把Bitmap释放了，那会引发异常的。</p>

<p>对于Bitmap的使用，<a href="http://developer.android.com/training/displaying-bitmaps/index.html">官方文档</a>有着比较详细的教程。现在的Android文档是很齐全的，相比较2010年代时2.0和2.1时多了很多最佳实践，所以不要浪费。</p>

<p>除内存外，Bitmap的处理也是比较耗时的，因为它经常涉及IO，以及压缩和处理，即使不耗时，因为它跟UI没关系，所以也是可以放在工作线程中去做的。Android中记住一个准则就是主线程做的事情越少越好，越少你的应用就越流畅。至于如何具体的去做也建议参考<a href="http://developer.android.com/training/displaying-bitmaps/process-bitmap.html">官方教程</a>。</p>

<h2>异步的方式</h2>

<p>在Android中异步实现的方式非常多：</p>

<ul>
<li>Thread</li>
<li>AsyncTask</li>
<li>Executors</li>
<li>Handler, Looper</li>
</ul>


<p>各种方式的使用方法参阅相关文档或者查阅网上浆料就可以了。这里主要说一下区别和适用的场景：</p>

<h3>Thread</h3>

<p>这是Java的简单粗暴的方式，优点就是简单，方便。对于某些简单的，一次性的，不需要与主线程通信和操作UI，不是很频繁（一次启动执行一次），的费时操作，直接使用Thread方式还是相当方便的。</p>

<h3>AsyncTask</h3>

<p>这是Android中专门针对平台本身的特性而封装的一个类，它的优势在于与主线程通信方便，能非常方便的操作UI。所以使用AsyncTask的理由就是当你需要在异步操作完成时直接操作UI时，除此外，你不应该使用它。</p>

<p>使用AsyncTask时，最好使用AsyncTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);以免任务不能及时获得执行，详细原因可以看<a href="http://blog.csdn.net/hitlion2008/article/details/8194510">这篇文章</a>。</p>

<h3>Executors</h3>

<p>当有大量的任务，或者重复性的任务需要执行时，就要使用线程池来复用和管理线程。</p>

<h3>Handler与Looper</h3>

<p>这是Android事件循环的基础类，也是AsyncTask的实现方式，是线程间通信的利器。所以如果你有复杂的线程通信（通常是工作线程和主线程之间），可以使用这二个类来自行进行定义。</p>

<h3>其他的高级工具</h3>

<p>对于多线程，已经有足够的工具供我们使用比如java.util.concurrent.*，以及Universal Image Loader，或者EventBus，所以当设计时首先要看现在的工具能否满足我们的需求。而不是自己去实现，子曰：不能重复造轮子，就是就是这个道理。</p>

<h2>异步时要注意Activity的生命周期</h2>

<p>异步时最容易出错的就是忽略Activity的生命周期。比如，当异步执行完成了，Activity却退出了前台，或者已经结束，如果异步完成时要操作UI，那么这种情况下肯定会报错，具体的错误取决于场景。这个问题的解法就是在异步操作完成后要用Activity.isFinishing()来判断下Activity是否还是alive的。或者设置一个变量来查看Activity是否还在前台。</p>

<p>另外，即使异步操作中不涉及UI，那么当Activity转入后台，或者退出时，也要及时的终止工作线程，否则也会造成Activity的对象无法及时销毁而最终导致内存泄露。这个问题需要在设计异步task时把可取消考虑进去，当Activity退出前台时发送消息给线程，让其终止执行。对于常见的费时操作，比如IO，网络，复杂计算等在都要考虑取消，每一个小步骤执行前都要判断取消标志位，以及时终止操作。通常这需要在Activity中持有任务的引用，或者使用Executors来管理任务，或者有一个类似的对象来管理异步任务，当Activity退出时，来终止任务。或者使用EventBus这类工具来降低耦合。</p>

<h2>有用的资源</h2>

<p>关于Android中的异步已经有了一本专门的书了<a href="http://shop.oreilly.com/product/0636920029397.do">《Efficient Android Threading》</a>，内容还是比较丰富的，可以看一看。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android布局技巧：使用TextView的drawable属性]]></title>
    <link href="http://toughcoder.net/blog/2015/05/20/android-layout-trick-drawable-of-textview/"/>
    <updated>2015-05-20T23:07:29+08:00</updated>
    <id>http://toughcoder.net/blog/2015/05/20/android-layout-trick-drawable-of-textview</id>
    <content type="html"><![CDATA[<p>在布局中Icon+文字组成一个视觉上的元素是非常普遍的需求，或者是成为一个可点击的整体，或者是展示某种信息。比如顶部导航栏（ActionBar或者是自已定义实现的类似功能的）都会有一个返回，通常都是一个向左的Icon加上一个文字标签。</p>

<p><a href=""><img src="http://www.gaditek.com/blog/wp-content/uploads/2013/08/Android-App-Development-Tips-Tricks-for-Beginners.jpg" title="auto auto" ></a></p>

<p>这种需求实现起来也是非常的简单，初学安卓的同学也能很快的写出来，一个ImageView加上一个TextView，外面再包一层LinearLayout或者RelativeLayout。Okay，这没有问题，但有更好的实现方式，这需要三个View对象，一个外层group，一个ImageView一个TextView，可以仅使用一个TextView对象，达到同样的效果。</p>

<!-- more -->


<h2>TextView的drawable属性</h2>

<p>TextView有一些属性可以在Text的四周设置一个drawable对象，图片,shape等合法的drawable都可以用。</p>

<ul>
<li> drawableStart API 14才有</li>
<li> drawableLeft</li>
<li> drawableTop</li>
<li> drawableBottom</li>
<li> drawableRight</li>
<li> drawableEnd  API 14才有</li>
<li> drawablePadding 用以设置drawable与text之间的空间</li>
</ul>


<p><a href="http://developer.android.com/reference/android/widget/TextView.html#attr_android:drawableStart">它们的含义</a>就像其名字所暗示的那样，left/top/right/bottom就是在文字的上下左右放置drawable。而drawableStart和drawableEnd则有特殊的意义，虽然它们是API 14加上去的，但是要在API 17后才能真正的生效，它们的作用是当语言方向发生变化时，会换边，LTR语言drawableStart在左边，而drawableEnd在右边；但对于RTL语言来说就会反过来drawableStart在右，drawableEnd在左。可以看<a href="http://stackoverflow.com/questions/13907618/whats-the-different-between-drawableleft-and-drawablestart-in-edittext">这个解释</a>。</p>

<p><img class="<a" src="href="http://7u2scv.com1.z0.glb.clouddn.com/tctextview-drawable.png">http://7u2scv.com1.z0.glb.clouddn.com/tctextview-drawable.png</a>&#8221;></p>

<pre><code class="xml">&lt;TextView android:text="Text along with Image\nsecond\nthird\nforth\nfifth" android:layout_width="400dip"
        android:layout_height="wrap_content"
        android:drawableStart="@drawable/ic_launcher"
        android:drawableLeft="@drawable/ic_launcher"
        android:textSize="16sp"
        android:paddingTop="10dip"
        android:paddingBottom="10dip"
        android:paddingLeft="10dip"
        android:gravity="center"
        android:drawablePadding="5dip"/&gt;;
</code></pre>

<h2>TextView的drawable的一些注意事项</h2>

<ol>
<li>. TextView的padding作用在drawable之外</li>
<li>. TextView的高度或宽度为wrap_content时将是文字和drawable中较大的那一个，再加上padding和margin</li>
<li>. gravity只对文字起作用，对drawable不起作用</li>
<li>. drawable会在其所在的维度居中显示，比如drawableLeft是上下垂直居中的，以此类推</li>
</ol>


<h2>局限性</h2>

<p>有些时候它也有一些局限性而没有办法用它：</p>

<ol>
<li>. 当drawable本身没有高度时（比如shape），这个drawable高度就会依赖于文字，因为padding是加在drawable之外，所以只会依赖于文字的高度。有些时候这不是想要的结果。</li>
<li>. 当Icon需要与文字分开单独控制时，很显示这要分成二个View。</li>
<li>. 当需要对Icon进行特殊的个性化时，比如添加背景，特效等。</li>
<li>. 其他一些造成无法使用的。</li>
<li>. 除上述情况外，就要考虑使用drawable了。</li>
</ol>


<h2>why bother?</h2>

<p>有同学可能会问，有什么区别，为啥费这么大劲折腾，也就省了二个view对象而已嘛？这位同学可以坐下了，孤来说明下：首先，作为开发者要有永不止境的学习和优化的意识，即使带来的效果是微小的，能用一个对象搞定的，为啥用三个呢？其次，对于整体不复杂的页面，这样带来的效果确实不明显，但是对于超复杂的页面，页面的布局有上百个View时，比如Launcher或者淘宝系的应用，就会带来明显的收益。还有，汇集小溪而成大河，把所有小的点都优化到了极致，那么整体肯定会得到质的飞跃。</p>

<p>子曰：学无止境，技术和优化也无止境啊，各位同学可以多用用Google系的应用，以及国外的优质应用(Facebook, Twitter等），你会发现，虽然应用也很复杂，比如Google+它的页面里展示的元素也非常多，但是为什么用起来是那么流畅。就在于Google里的Android开发都是专家级的人物，他们牛在什么地方，就牛在他们总能用最好的方式来实现，就在于他们总能找到一个对象就能解决我们靠三个对象才能搞定的方法。</p>
]]></content>
  </entry>
  
</feed>
