<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2025-06-02T21:59:19+08:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[揭秘原生View与Jetpack Compose之间的传送门]]></title>
    <link href="https://alexhilton.github.io/blog/2025/06/02/android-vies-in-compose/"/>
    <updated>2025-06-02T21:44:19+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/06/02/android-vies-in-compose</id>
    <content type="html"><![CDATA[<p>芳菲随春去，碧绿入夏来，不知不觉中<a href="https://juejin.cn/column/7367555191338467337">Compose专题</a>已经写了近40篇文章了，从Compose各组件的使用方法，到Compose的编程思想，再到内部原理和最佳实践。通过<a href="https://juejin.cn/column/7367555191338467337">这一系列的文章</a>相信对Compose已经有了足够的理解，能够在项目中进行实战和运用。学无止境，今天将继续学习，重点探讨如何在已有的项目中使用Compose。</p>

<p><a href=""><img src="file:///Users/alexhilton/Downloads/portal_2.png" title="auto auto" ></a></p>

<!-- more -->


<h2>缘起</h2>

<p>无疑Jetpack Compose是一个优秀的声明式UI框架，它与原生的View方式最大的区别，在于思考问题的方式上并不一样。声明式框架能把开发者从繁杂的命令式的UI细节中解放出来，重点思考一个好的体验应该是什么样子的，而具体的UI细节由框架来处理。尽管如此，毕竟Compose是近几年来发展起来的，现今大量的项目仍是原生View主导的。此外，Compose也还在发展中，有些特定业务领域如Camera，视频，3D渲染，还没有能力支持。因此，整合原生View和Compose是项目中很现实的一个难题，本文将重点讨论两个议题：一个是如何在原生View中嵌入Compose，另一个就是如何在Compose中嵌入原生View。</p>

<p><strong>注意：</strong> 本文中提到的两个组件ComposeView和AndroidView都仅在Jetpack Compose（for Android）生效，并不适用于跨平台的Compose Multiplatform。</p>

<h2>在原生View中嵌入Compose</h2>

<p>第一个传送门是如何进入Compose的世界。相信现在绝大多数项目都是基于原生View的，借助<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/ComposeView">ComposeView</a>就可以进入到Compose的世界。</p>

<pre><code class="Kotlin">    val composeView = ComposeView(context).apply {
                setContent {
                    // 这里调用Composables
                }
            }
</code></pre>

<p>ComposeView是View的一个子类，能够作为Compose的容器，在<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/platform/ComposeView#setContent(kotlin.Function0">其setContent方法</a>)中提供一个Composable即可。ComposeView与其他View一样，可以用在View tree中，用在Fragment里和Activity里面。实际上作为平台的入口ComponentActivity用的也是ComposeView。</p>

<h3>在View层级中直接嵌入</h3>

<p>ComposeView就是一个普通的Android View，跟其他View的子类是一样的，所以可以把它放在任何可以使用View的地方，比如一个布局里面，作为一个页面的一部分。</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/container"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    tools:context=".MainActivity"&gt;

    &lt;androidx.compose.ui.platform.ComposeView
        android:id="@+id/compose_view"
        android:layout_width="match_parent"
        android:layout_height="wrap_content" /&gt;

    &lt;Button
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="WidgetButton"
        /&gt;
&lt;/LinearLayout&gt;
</code></pre>

<p><strong>注意：</strong> 尽管可以把ComposeView当成普通的View，直接嵌入到布局中，作为页面中的一部分，但这并不是一个好的做法，一来是不能发挥Compose的优势，另外Compose本身是有特定的生命周期的（重组），它需要知道平台的生命周期，以管控它自己的生命周期。而常规的View tree之中是没有平台生命周期的，因为常规的View tree并不关心平台的生命周期，view tree主要受窗口影响（attachToWindow，detachFromWindow），这个与平台组件的生命周期没有关系。</p>

<h3>用在Fragment中</h3>

<p>想要在某个Fragment中集成Compose的方式就是把ComposeView作为Fragment的根View即可：</p>

<pre><code class="Kotlin">class ExampleFragmentNoXml : Fragment() {

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        return ComposeView(requireContext()).apply {
            // 当View的宿主destroy时销毁组合
            setViewCompositionStrategy(ViewCompositionStrategy.DisposeOnViewTreeLifecycleDestroyed)
            setContent {
                MaterialTheme {
                    // 进入到Compose世界
                    Text("Hello Compose!")
                }
            }
        }
    }
}
</code></pre>

<h3>用在Activity中</h3>

<p>这其实是最好的方式，在一个新的页面窗口中使用Compose，这就能与其余view独立开来，是最为理想的。</p>

<pre><code class="Kotlin">class ExampleActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        setContent {
            MaterialTheme {
                Greeting(name = "compose")
            }
        }
    }
}

@Composable
fun Greeting(name: String) {
    Text(text = "Hello $name!")
}
</code></pre>

<h3>使用建议</h3>

<p>虽然ComposeView可以当成一个普通的View来使用，但最为合理的方式就是在一个新的Activity中才使用Compose，也就是说当有一个全新的页面时，考虑使用Compose来开发，这样才能发挥出它的价值。</p>

<p>除非有特别的需求，否则不要把ComposeView作为现有页面的一部分嵌入到View tree中（也就是作为页面的一部分）。</p>

<p>至于在Fragment中使用，如果是一个全新的页面，而非现有布局的一部分，那也可以考虑使用Compose。</p>

<p><strong>注意：</strong> 其根本原因在于，我们使用Jetpack Compose并不是图它能实现什么特别的UI效果，Compose能做的事情View都能做，甚至它不能做的事情View也能做。用Compose是因为它是声明式的UI框架，在开发效率和可扩展性上面有巨大的优势。所以，只应该在想要发挥声明式框架优势的时候，才考虑使用它，并且应该从一个全新的页面开始。</p>

<h2>在Compose中嵌入原生View</h2>

<p>Jetpack Compose提供了足够丰富的组件，足以应对常规的UI，但它毕竟还不是特别的成熟，总会遇到一些场景，发现Compose无法胜任，而且并不是通过自定义组件就能够解决的，比如一些特定领域的UI，如camera，如视频，如3D渲染。或者说，已经有了自定义好的View，并不想重复开发。再或者说对于一些三方的库，它并没有对应的Compose组件。这些场景就需要把原生的View嵌入到Compose之中。</p>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/viewinterop/package-summary#AndroidView(kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Function1,kotlin.Function1,kotlin.Function1">AndroidView</a>)就是专门用于把原生View嵌入到Compose中的一个特殊composable。它就像一个传送门一样，能把原生的View，无论是一个现成的自定义View，还是特定领域的View或者三方库的View，带入到Compose中，变成一个composable。</p>

<h3>AndroidView的使用方法</h3>

<p>AndroidView是一个composable，把它放在想要的位置即可。它有三个参数，一个是常规的Modifier用以约束这个composable的；另两个是lambda，一个是用于创建View的，返回一个View的实例，只会被调用一次；另一个就是用于更新View的，会被调用多次：</p>

<pre><code class="Kotlin">@Composable
fun CustomView() {
    var selectedItem by remember { mutableStateOf(0) }

    // 添加原生View到Compose
    AndroidView(
        modifier = Modifier.fillMaxSize(),
        factory = { context -&gt;
            // 创建View的实例
            MyView(context).apply {
                // 设置View的点击事件，更新状态，这会触发重组
                setOnClickListener {
                    selectedItem = 1
                }
            }
        },
        update = { view -&gt;
            // 更新View的状态
            // 这里读了状态，所以重组时update会被再次调用，view能拿到最新的状态
            view.selectedItem = selectedItem
        }
    )
}

@Composable
fun ContentExample() {
    Column(Modifier.fillMaxSize()) {
        Text("Look at this CustomView!")
        CustomView()
    }
}
</code></pre>

<p><strong>注意：</strong> factory仅会被调用一次，用于创建View实例，update会被调用多次，用于更新view的状态，包括初次组合时，也就是factory执行之后，就会调用update。AndroidView函数会帮助提供View需要的参数context，以及管理View的实例，所以update中会把view当作参数传给我们，所以我们完全没有必要再用额外的状态（remember）去缓存View的实例了。</p>

<h3>使用建议</h3>

<p>虽然AndroidView是一个传送门，可以连接两个世界，但是能不用还是不要用，非必要不使用。如果能用Compose搞定的事情，还是要用Compose来搞，比如用Canvas去实现自定义组件。</p>

<p>需要使用AndroidView的场景只有三个：一是有现成的自定义View，拿过来就可以用，不想二次开发；二是三方库的View；三就是Compose确实搞不定的特定领域，如WebView，如视频，如SurfaceView或者3D渲染（OpenGL ES）等等。除以之外，不建议使用。</p>

<p>还需要特别注意的是，如果原生的View交互比较复杂，不光是点击，还涉及Touch事件处理，处理事件的同时还要不断更新View的状态，那也不应该使用它。比较理想的情况是，嵌入的这个View是一个比较纯粹的生产者，比如它只产生事件，不需要再往回更新状态；或者是一个比较纯粹的消费者，比如它就负责展示，只需要塞数据就行了。</p>

<h2>总结</h2>

<p>网上的教程或者Demo中的世界是很美好的，往往都是一个新建的项目，一个新的页面，直接就进入了Compose世界，也都在讲Compose能做的事情。但现实的世界往往不是这样子的，极少情况下是全新开始的项目，往往需要与遗留代码打交道，需要实现的需求也是多种多样的。本文中介绍了两个传送门，ComposeView和AndroidView可以方便地连接原生View和Compose两个世界，为现实项目中遇到的问题提供了一个可行的解决方案。</p>

<h3>让Compose支持OpenGL ES</h3>

<ul>
<li><a href="https://stackoverflow.com/questions/78796021/how-to-render-opengl-alongside-jetpack-compose-ui-without-covering-other-element">How to render OpenGL alongside Jetpack Compose UI without covering other elements</a></li>
<li><a href="https://www.reddit.com/r/Kotlin/comments/on36sy/experiment_to_make_opengl_work_together_with/?rdt=62185">Experiment to make OpenGL work together with Jetpack Compose</a></li>
<li><a href="https://composables.com/foundation/androidexternalsurface">AndroidExternalSurface</a></li>
<li><a href="https://youtrack.jetbrains.com/issue/CMP-3810/Using-Open-GL-with-Compose-Multiplatform">Using Open GL with Compose Multiplatform</a></li>
</ul>


<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/migrate/interoperability-apis/compose-in-views">Using Compose in Views</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/migrate/interoperability-apis/views-in-compose">Using Views in Compose</a></li>
<li><a href="https://medium.com/@seungbae2/jetpack-compose-androidview-seamless-integration-of-android-views-into-compose-ui-644f217437d3">Jetpack Compose AndroidView: Seamless Integration of Android Views into Compose UI</a></li>
<li><a href="https://stackoverflow.com/questions/59995970/using-custom-views-with-jetpack-compose">Using Custom Views with Jetpack Compose</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Jetpack Compose构建创意动画]]></title>
    <link href="https://alexhilton.github.io/blog/2025/05/31/animations-in-jetpack-compose/"/>
    <updated>2025-05-31T23:19:03+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/05/31/animations-in-jetpack-compose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Animating Inside and Outside the Box with Jetpack Compose」，原文链接<a href="https://medium.com/proandroiddev/animating-inside-and-outside-the-box-with-jetpack-compose-a56eba1b6af6">https://medium.com/proandroiddev/animating-inside-and-outside-the-box-with-jetpack-compose-a56eba1b6af6</a>，由Nirbhay Pherwani发布于2023年12月13日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*YDhqS2nzvjXmvlC58vcDNQ.png" title="auto auto" ></a></p>

<!-- more -->


<h2>缘起</h2>

<p>动画能够让用户界面充满活力、引人入胜。在Android中，Jetpack Compose提供高级工具，让你轻松掌握这项强大功能，打造真正的动态UI。本文将深入探讨 Jetpack Compose 中动画的深层技术。</p>

<p><strong>译注：</strong> 虽然原文是以Jetpack Compose为基础来写的，但其实动画这块并不涉及平台特性，也适用于Compose Multiplatform。</p>

<p>我们将涵盖一系列技巧，从创建流畅的、基于物理的动效（增添真实感）到创建复杂的编排序列（为界面增添叙事质感）。无论你是想提升技能，还是仅仅想探索无限可能，本教程都将提供实用的见解，帮助你的应用不仅运行流畅，还能让用户在每次交互中都感到愉悦。</p>

<p>让我们深入探索这些动画如何改变你的 UI设计方法，使其更加直观、响应迅速，并为用户带来愉悦的体验。</p>

<h2>第 1 部分 — Jetpack Compose中的自定义动画</h2>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C1_mzDHNHOfSZkIiULgRzw.gif" alt="游戏角色的移动" /></p>

<h3>利用自定义动画实现动态交互</h3>

<p>在本节中，我们将探索如何在 Jetpack Compose中使用高级自定义动画来创建动态且可交互的 UI 元素。我们将重点介绍一个真实示例，该示例演示了用户交互如何以有意义的方式影响动画。</p>

<h3>案例 - 交互式游戏角色移动</h3>

<p>我们将通过一个示例来说明这一概念，其中游戏角色（由面部图标表示）沿着由用户可拖动控制点确定的路径移动。</p>

<pre><code class="Kotlin">@Composable
fun GameCharacterMovement() {
    val startPosition = Offset(100f, 100f)
    val endPosition = Offset(250f, 400f)
    val controlPoint = remember { mutableStateOf(Offset(200f, 300f)) }
    val position = remember { Animatable(startPosition, Offset.VectorConverter) }

    LaunchedEffect(controlPoint.value) {
        position.animateTo(
            targetValue = endPosition,
            animationSpec = keyframes {
                durationMillis = 5000
                controlPoint.value at 2500 // 可拖动控制点控制的中间点
            }
        )
    }

    val onControlPointChange: (offset: Offset) -&gt; Unit = {
        controlPoint.value = it
    }

    Box(modifier = Modifier.fillMaxSize()) {

        Icon(
            Icons.Filled.Face, contentDescription = "Localized description", modifier = Modifier
                .size(50.dp)
                .offset(x = position.value.x.dp, y = position.value.y.dp)
        )

        DraggableControlPoint(controlPoint.value, onControlPointChange)
    }
}
</code></pre>

<h4>代码说明</h4>

<ul>
<li>GameCharacterMovement 为代表游戏角色的图标设置动画。动画路径由 controlPoint 控制，该控制点通过用户交互设置和更新。</li>
<li>Animatable 用于将图标的位置从 startPosition 平滑过渡到 endPosition。</li>
<li>LaunchedEffect 监听 controlPoint 值的变化，并在控制点移动时重新触发动画。</li>
<li>animationSpec — 这是一种配置项，用于定义动画的持续时间、延迟和缓动。它决定了动画值如何随时间变化。</li>
<li>keyframes — 允许你在动画的特定时间点指定值，从而控制动画的中间点。这对于创建复杂的、精心设计的动画特别有用。</li>
<li>keyframes 块将动画定义为一系列关键帧。在 2500 毫秒（中间点）时，角色到达控制点，然后继续移动到结束位置。</li>
</ul>


<pre><code class="Kotlin">@Composable
fun DraggableControlPoint(controlPoint: Offset, onControlPointChange: (Offset) -&gt; Unit) {
    var localPosition by remember { mutableStateOf(controlPoint) }
    Box(
        modifier = Modifier
            .offset {
                IntOffset(
                    x = localPosition.x.roundToInt() - 15,
                    y = localPosition.y.roundToInt() - 15
                )
            }
            .size(30.dp)
            .background(Color.Red, shape = CircleShape)
            .pointerInput(Unit) {
                detectDragGestures(onDragEnd = {
                    onControlPointChange(localPosition)
                }) { _, dragAmount -&gt;
                    // adjust based on screen bounds
                    val newX = (localPosition.x + dragAmount.x).coerceIn(0f, 600f)
                    val newY = (localPosition.y + dragAmount.y).coerceIn(0f, 600f)
                    localPosition = Offset(newX, newY)
                }
            }
    )
}
</code></pre>

<h4>代码说明</h4>

<ul>
<li>DraggableControlPoint 是一个可组合项，允许用户以交互方式更改控制点的位置。</li>
<li>拖动控制点会更新 localPosition，并在拖动手势完成（onDragEnd）后将其反馈回 GameCharacterMovement。此交互会改变动画图标的路径。</li>
</ul>


<h3>实际用例</h3>

<ol>
<li>交互式教育应用：在教育应用中，动画可用于提升学习的吸引力。例如，在天文学应用中，拖动行星沿其轨道运行即可查看不同的星座。</li>
<li>交互式故事叙述和游戏：在数字故事叙述或游戏应用中，允许用户通过可拖动元素来影响故事或游戏环境，可以创造更具沉浸感的体验。</li>
</ol>


<h2>第 2 部分 — 在 Jetpack Compose中编排复杂动画</h2>

<h3>同步多个元素以实现和谐效果</h3>

<p>在本部分中，我们将深入探讨在 Jetpack Compose 中编排（Choreographing）复杂动画的艺术。我们专注于创建同步动画，使多个元素能够无缝交互，从而提升整体用户体验。</p>

<h3>A) 连锁反应动画 — 多米诺骨牌效应</h3>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iNeJJU3ixcdcZnQFHHSWYw.gif" alt="多米诺骨牌效应" /></p>

<p>通过设置一系列动画可以在 UI 中创建多米诺骨牌效应，其中一个动画的完成会触发下一个动画的开始。</p>

<pre><code class="Kotlin">@Composable
fun DominoEffect() {
    val animatedValues = List(6) { remember { Animatable(0f) } }

    LaunchedEffect(Unit) {
        animatedValues.forEachIndexed { index, animate -&gt;
            animate.animateTo(
                targetValue = 1f,
                animationSpec = tween(durationMillis = 1000, delayMillis = index * 100)
            )
        }
    }

    Box (modifier = Modifier.fillMaxSize()){
      animatedValues.forEachIndexed { index, value -&gt;
        Box(
            modifier = Modifier
                .size(50.dp)
                .offset(x = ((index+1) * 50).dp, y = ((index+1) * 30).dp)
                .background(getRandomColor(index).copy(alpha = value.value))
        )
      }
    }
}

fun getRandomColor(seed: Int): Color {
    val random = Random(seed = seed).nextInt(256)
    return Color(random, random, random)
}
</code></pre>

<h4>代码说明</h4>

<ul>
<li>animatedValues 是一个Animatable对象的列表，每个值控制一个框的 Alpha（不透明度）。</li>
<li>LaunchedEffect 会触发这些值的一系列动画，从而创建一种交错效果，即每个框在前一个框之后淡入，类似于多米诺骨牌倒下。</li>
<li>getRandomColor 函数会为每个框生成随机的灰色阴影，为序列中的每个组件添加独特的视觉元素。</li>
<li>这些框沿屏幕对角线放置，增强了多米诺骨牌效应。</li>
</ul>


<h3>B) 交互式滚动时间轴</h3>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Kk-V0g5pEqy83NajRy_6lA.gif" alt="交互式滚动时间轴" /></p>

<p>在这个时间轴中，每个元素都会随着用户滚动而淡入并移动到位。我们将使用 LazyColumn来呈现可滚动列表，并使用Animatable来呈现动画。</p>

<pre><code class="Kotlin">@Composable
fun InteractiveTimeline(timelineItems: List&lt;String&gt;) {
    val scrollState = rememberLazyListState()

    LazyColumn(state = scrollState) {
        itemsIndexed(timelineItems) { index, item -&gt;
            val animatableAlpha = remember { Animatable(0f) }
            val isVisible = remember {
                derivedStateOf {
                    scrollState.firstVisibleItemIndex &lt;= index
                }
            }

            LaunchedEffect(isVisible.value) {
                if (isVisible.value) {
                    animatableAlpha.animateTo(
                        1f, animationSpec = tween(durationMillis = 1000)
                    )

                }
            }

            TimelineItem(
                text = item,
                alpha = animatableAlpha.value,
            )
        }
    }
}

@Composable
fun TimelineItem(text: String, alpha: Float) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .background(Color.DarkGray.copy(alpha = alpha))
            .padding(16.dp),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Text(
            text = text,
            color = Color.White,
            modifier = Modifier.fillMaxWidth(),
            textAlign = TextAlign.Center,
            fontSize = 18.sp,
            fontWeight = FontWeight.SemiBold
        )
    }
}
</code></pre>

<h4>代码说明</h4>

<ul>
<li>animatableAlpha 控制每个时间轴项目的 Alpha（不透明度），初始设置为 0（完全透明）。</li>
<li>isVisible 状态源自当前滚动位置，用于确定项目是否可见。</li>
<li>当用户滚动时，LaunchedEffect会触发进入视口的项目的淡入动画。</li>
</ul>


<h4>用例</h4>

<p>此交互式时间轴非常适合那些希望以视觉吸引力十足的方式呈现一系列事件或步骤的应用。动画通过在项目进入视野时吸引用户的注意力来增强用户的参与度。</p>

<p><strong>此类动画不仅引人入胜，还可以用来引导用户关注应用中的一系列事件或操作。</strong></p>

<h2>第 3 部分 — Jetpack Compose中基于物理的真实动画</h2>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lZ_rpGorcFzewpUJN6WPAQ.gif" alt="弹性拖拽动画" /></p>

<h3>利用物理原理增强UI动态效果</h3>

<p>在本节中，我们将探索如何使用 Jetpack Compose将物理原理融入动画，为 UI 增添一层真实感和交互性。我们将重点介绍一个弹性拖拽交互示例。</p>

<h3>拖拽时的弹性效果</h3>

<p>此示例演示了图标上的弹性拖拽交互。垂直拖动时，图标会拉伸并回弹，产生弹性效果，模拟弹簧或橡皮筋​​的行为。</p>

<pre><code class="Kotlin">@Composable
fun ElasticDraggableBox() {
    var animatableOffset by remember { mutableStateOf(Animatable(0f)) }

    Box(modifier = Modifier.fillMaxSize().background(Color(0xFFFFA732)), contentAlignment = Alignment.Center) {
        Box(
            modifier = Modifier
                .offset(y = animatableOffset.value.dp)
                .draggable(
                    orientation = Orientation.Vertical,
                    state = rememberDraggableState { delta -&gt;
                        animatableOffset = Animatable(animatableOffset.value + delta)
                    },
                    onDragStopped = {
                        animatableOffset.animateTo(0f, animationSpec = spring())
                    }
                )
                .size(350.dp),
            contentAlignment = Alignment.Center
        ) {
            Icon(
                Icons.Filled.Favorite,
                contentDescription = "heart",
                modifier = Modifier.size(animatableOffset.value.dp + 150.dp),
                tint = Color.Red
            )
        }
    }
}
</code></pre>

<h4>说明</h4>

<ul>
<li>使用 draggable 修饰符将包含图标的 Box 可组合项设置为可拖动。</li>
<li>animatableOffset 跟踪图标因拖动而产生的垂直偏移。</li>
<li>在拖动过程中，图标的大小会根据拖动量而变化，从而产生拉伸效果。</li>
<li>当拖动停止（onDragStopped）时，animatableOffset 会使用弹簧动画返回到 0f，从而使图标弹回其原始大小和位置。</li>
</ul>


<h2>第 4 节 — Jetpack Compose 中的手势动画</h2>

<h3>通过响应式手势提升用户体验</h3>

<p>在本部分中，我们将探索如何使用 Jetpack Compose 创建由用户手势控制的动画。我们将重点介绍两个示例——一个支持多点触控的可变形图像和一个由手势控制的音频波形。</p>

<h3>A) 多点触控可变形图像</h3>

<p>在本示例中，我们将创建一个图像视图，用户可以使用捏合、缩放和旋转等多点触控（Multi-touch）手势进行交互。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*34WxcBivTWhiCY6KVSVelQ.gif" alt="多点触控可变形图像" /></p>

<pre><code class="Kotlin">@Composable
fun TransformableImage(imageId: Int = R.drawable.android) {
    var scale by remember { mutableStateOf(1f) }
    var rotation by remember { mutableStateOf(0f) }
    var offset by remember { mutableStateOf(Offset.Zero) }

    Box(modifier = Modifier.fillMaxSize().background(Color.DarkGray), contentAlignment = Alignment.Center) {
        Image(
            painter = painterResource(id = imageId),
            contentDescription = "Transformable image",
            contentScale = ContentScale.Crop,
            modifier = Modifier
                .size(300.dp)
                .graphicsLayer(
                    scaleX = scale,
                    scaleY = scale,
                    rotationZ = rotation,
                    translationX = offset.x,
                    translationY = offset.y
                )
                .pointerInput(Unit) {
                    detectTransformGestures { _, pan, zoom, rotate -&gt;
                        scale *= zoom
                        rotation += rotate
                        offset += pan
                    }
                }
        )
    }
}
</code></pre>

<h4>代码说明</h4>

<ul>
<li>Image 可组合项通过 graphicsLayer 进行修改，以应用缩放、旋转和平移等变换。</li>
<li>pointerInput 带有 detectTransformGestures 接口，用于处理多点触控手势，并相应地更新缩放、旋转和偏移。</li>
</ul>


<h3>B) 手势控制波形</h3>

<p>这是一个波形可视化效果，它根据用户手势（例如滑动和捏合）改变外观，以控制幅度和频率等方面。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qKzb1XpUrSGKdCL-OxhtLw.gif" alt="手势控制波形" /></p>

<pre><code class="Kotlin">@Composable
fun GestureControlledWaveform() {
    var amplitude by remember { mutableStateOf(100f) }
    var frequency by remember { mutableStateOf(1f) }

    Canvas(modifier = Modifier
        .fillMaxSize()
        .pointerInput(Unit) {
            detectDragGestures { _, dragAmount -&gt;
                amplitude += dragAmount.y
                frequency += dragAmount.x / 500f 
                // 根据拖拽调整频率
            }
        }
        .background(
            Brush.verticalGradient(
                colors = listOf(Color(0xFF003366), Color.White, Color(0xFF66B2FF))
            )
        )) {
        val width = size.width
        val height = size.height
        val path = Path()

        val halfHeight = height / 2
        val waveLength = width / frequency

        path.moveTo(0f, halfHeight)

        for (x in 0 until width.toInt()) {
            val theta = (2.0 * Math.PI * x / waveLength).toFloat()
            val y = halfHeight + amplitude * sin(theta.toDouble()).toFloat()
            path.lineTo(x.toFloat(), y)
        }

        val gradient = Brush.horizontalGradient(
            colors = listOf(Color.Blue, Color.Cyan, Color.Magenta)
        )

        drawPath(
            path = path,
            brush = gradient
        )
    }
}
</code></pre>

<h4>代码说明</h4>

<ul>
<li>amplitude 和 frequency 是状态变量，分别控制波形的幅度和频率。</li>
<li>Canvas 可组合项用于绘制波形。Canvas 内部的绘制逻辑根据正弦函数计算每个 X 位置的 Y 位置，从而创建波浪效果。</li>
<li>detectDragGestures 修饰符用于根据用户拖动手势更新幅度和频率。水平拖动调整频率，垂直拖动调整幅度。</li>
<li>当用户在屏幕上拖动时，波形的形状会相应变化，从而营造出互动体验。</li>
</ul>


<h4>注意事项</h4>

<ul>
<li>这是一个基本的实现。为了获得更逼真的音频波形，你需要集成实际的音频数据。</li>
<li>可以通过调整拖动过程中幅度和频率的修改方式来微调波形对手势的响应能力。</li>
</ul>


<p>此示例演示了如何在 Compose 中创建基本的交互式波形，并且可以对其进行扩展或修改，以用于更复杂的用例或处理更复杂的手势。</p>

<h2>第 5 节 — Jetpack Compose 中的状态驱动动画模式</h2>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nkfhmC6JjQnshL3y_izhKg.gif" alt="带动画线图" /></p>

<h3>基于数据和状态变化的UI动画</h3>

<p>本部分重点介绍如何创建由数据或UI 状态变化驱动的动画，从而增强应用的交互性和响应能力。我们将探讨两个具体示例——数据图动画和在多状态 UI 中实现状态转换。</p>

<h3>A) 数据驱动的图形动画</h3>

<p>本示例演示了一个动画线图，其中图形的路径（Path）会随着数据集的变化而变化。</p>

<pre><code class="Kotlin">@Composable
fun AnimatedGraphExample() {
    var dataPoints by remember { mutableStateOf(generateRandomDataPoints(5)) }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .background(Color.DarkGray)
    ) {
        AnimatedLineGraph(dataPoints = dataPoints)

        Spacer(modifier = Modifier.height(16.dp))

        Button(
            onClick = {
                dataPoints = generateRandomDataPoints(5)
            },
            modifier = Modifier.align(Alignment.CenterHorizontally),
            colors = ButtonDefaults.buttonColors(containerColor = Color.Green)
        ) {
            Text(
                "Update Data",
                fontWeight = FontWeight.Bold,
                color = Color.DarkGray,
                fontSize = 18.sp
            )
        }
    }
}

@Composable
fun AnimatedLineGraph(dataPoints: List&lt;Float&gt;) {
    val animatableDataPoints = remember { dataPoints.map { Animatable(it) } }
    val path = remember { Path() }

    LaunchedEffect(dataPoints) {
        animatableDataPoints.forEachIndexed { index, animatable -&gt;
            animatable.animateTo(dataPoints[index], animationSpec = TweenSpec(durationMillis = 500))
        }
    }

    Canvas(
        modifier = Modifier
            .fillMaxWidth()
            .height(400.dp)
    ) {
        path.reset()
        animatableDataPoints.forEachIndexed { index, animatable -&gt;
            val x = (size.width / (dataPoints.size - 1)) * index
            val y = size.height - (animatable.value * size.height)
            if (index == 0) path.moveTo(x, y) else path.lineTo(x, y)
        }
        drawPath(path, Color.Green, style = Stroke(5f))
    }
}

fun generateRandomDataPoints(size: Int): List&lt;Float&gt; {
    return List(size) { Random.nextFloat() }
}
</code></pre>

<h4>代码说明</h4>

<ul>
<li>AnimatedGraphExample 可组合项创建了一个可以更新折线图数据点的环境。</li>
<li>该图表绘制在 Canvas 中，其中 drawPath 方法使用来自 animatableDataPoints 的动画值。</li>
<li>对于图表中的每个数据点，我们需要计算其在画布上对应的 x（水平）和 y（垂直）位置。</li>
<li>x 计算 - x 位置是根据数据点的索引和画布的总宽度计算得出的。我们将数据点沿画布的宽度均匀分布。
<code>Kotlin
val x = (size.width / (dataPoints.size - 1)) * index
</code></li>
<li>y 计算——y 位置是根据数据点（animatable.value）的值和画布的高度计算的。
<code>Kotlin
val y = size.height - (animatable.value * size.height)
</code></li>
<li>路径从第一个数据点开始，然后使用 lineTo 绘制一条线到每个后续点，从而创建图形线。</li>
<li>路径基于数据点的动画值绘制，从而在数据发生变化时创建动画效果。</li>
</ul>


<h3>B) 多状态 UI 中的状态转换</h3>

<p>可以使用 Animatable 在多状态 UI 中实现状态转换，从而在不同 UI 状态之间进行动画处理。</p>

<pre><code class="Kotlin">enum class UIState { StateA, StateB, StateC }

@Composable
fun StateTransitionUI() {
    var currentState by remember { mutableStateOf(UIState.StateA) }

    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(getBackgroundColorForState(currentState)),
        contentAlignment = Alignment.Center
    ) {
        AnimatedContent(currentState = currentState)

        Button(
            onClick = { currentState = getNextState(currentState) },
            modifier = Modifier.align(Alignment.BottomCenter)
        ) {
            Text("Next State")
        }
    }
}

@Composable
fun AnimatedContent(currentState: UIState) {
    AnimatedVisibility(
        visible = currentState == UIState.StateA,
        enter = fadeIn(animationSpec = tween(durationMillis = 2000)) + expandVertically(),
        exit = fadeOut(animationSpec = tween(durationMillis = 2000)) + shrinkVertically()
    ) {
        Text("This is ${currentState.name}", fontSize = 32.sp)
    }

    // 与B 和 C 的类似的代码块
}

fun getBackgroundColorForState(state: UIState): Color {
    return when (state) {
        UIState.StateA -&gt; Color.Red
        UIState.StateB -&gt; Color.Green
        UIState.StateC -&gt; Color.Blue
    }
}

fun getNextState(currentState: UIState): UIState {
    return when (currentState) {
        UIState.StateA -&gt; UIState.StateB
        UIState.StateB -&gt; UIState.StateC
        UIState.StateC -&gt; UIState.StateA
    }
}
</code></pre>

<h4>代码说明</h4>

<ul>
<li>在此示例中，AnimatedVisibility 用于为每个状态下内容的出现和消失添加动画效果。这会在状态变化时添加平滑的过渡效果。</li>
<li>对于每个状态（StateA、StateB、StateC），都有一个 AnimatedVisibility 块，用于通过淡入淡出和展开/收缩动画控制其内容的可见性。</li>
<li>AnimatedVisibility 的进入和退出参数分别定义了内容可见或隐藏时的动画。</li>
</ul>


<h2>第 6 节 — 在 Compose中改变（Morphing）形状</h2>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*q82EIocVzR8XBMuG_14mdg.gif" alt="形状变形" /></p>

<p>动画形状之间的变换涉及这些形状的属性的插值。</p>

<pre><code class="Kotlin">@Composable
fun ShapeMorphingAnimation() {
    val animationProgress = remember { Animatable(0f) }

    LaunchedEffect(Unit) {
        animationProgress.animateTo(
            targetValue = 1f,
            animationSpec = infiniteRepeatable(
                animation = tween(2000, easing = LinearOutSlowInEasing),
                repeatMode = RepeatMode.Reverse
            )
        )
    }

    Canvas(modifier = Modifier.padding(40.dp).fillMaxSize()) {
        val sizeValue = size.width.coerceAtMost(size.height) / 2
        val squareRect = Rect(center = center, sizeValue)

        val morphedPath = interpolateShapes(progress = animationProgress.value, squareRect = squareRect)
        drawPath(morphedPath, color = Color.Blue, style = Fill)
    }
}

fun interpolateShapes(progress: Float, squareRect: Rect): Path {
    val path = Path()

    val cornerRadius = CornerRadius(
        x = lerp(start = squareRect.width / 2, stop = 0f, fraction = progress),
        y = lerp(start = squareRect.height / 2, stop = 0f, fraction = progress)
    )

    path.addRoundRect(
        roundRect = RoundRect(rect = squareRect, cornerRadius = cornerRadius)
    )

    return path
}

fun lerp(start: Float, stop: Float, fraction: Float): Float {
    return (1 - fraction) * start + fraction * stop
}
</code></pre>

<h4>代码说明</h4>

<ul>
<li>ShapeMorphingAnimation 设置了一个无限动画，将 animationProgress 的值在 0 和 1 之间切换。</li>
<li>Canvas 可组合项用于绘制形状。在这里，我们根据画布大小定义正方形 (squareRect) 的尺寸。</li>
<li>interpolateShapes 接收当前动画进度和正方形的矩形，在圆形和正方形之间进行插值。它使用 lerp（线性插值）逐步调整圆角矩形的 cornerRadius，该矩形代表我们的变形形状。</li>
<li>当 progress 为 0 时，cornerRadius 是矩形大小的一半，使形状变为圆形。当 progress 为 1 时，cornerRadius 为 0，使形状变为正方形。</li>
</ul>


<h4>实际用例</h4>

<ul>
<li>加载和进度指示器——变形形状可用于创建更具吸引力的加载或进度指示器，以视觉上引人入胜的方式指示进度或加载状态。</li>
<li>UI 中的图标过渡——变形图标可用于根据用户操作提供视觉反馈。例如，点击播放按钮时会变形为暂停按钮，汉堡菜单图标会变形为后退箭头。</li>
<li>数据可视化——在复杂的数据可视化中，变形可以帮助在不同视图或数据状态之间过渡，使用户更容易跟踪和理解随时间或类别变化的变化。</li>
</ul>


<h2>想看雪花特效吗？</h2>

<p>我们将演示一个简单的粒子系统（Particle system）来创建雪花效果。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E26GhhxDZLGTpE8gMvJoHw.gif" alt="雪花特效" /></p>

<pre><code class="Kotlin">data class Snowflake(
    var x: Float,
    var y: Float,
    var radius: Float,
    var speed: Float
)

@Composable
fun SnowfallEffect() {
    val snowflakes = remember { List(100) { generateRandomSnowflake() } }
    val infiniteTransition = rememberInfiniteTransition(label = "")

    val offsetY by infiniteTransition.animateFloat(
        initialValue = 0f,
        targetValue = 1000f,
        animationSpec = infiniteRepeatable(
            animation = tween(durationMillis = 5000, easing = LinearEasing),
            repeatMode = RepeatMode.Restart
        ), label = ""
    )

    Canvas(modifier = Modifier.fillMaxSize().background(Color.Black)) {
        snowflakes.forEach { snowflake -&gt;
            drawSnowflake(snowflake, offsetY % size.height)
        }
    }
}

fun generateRandomSnowflake(): Snowflake {
    return Snowflake(
        x = Random.nextFloat(),
        y = Random.nextFloat() * 1000f,
        radius = Random.nextFloat() * 2f + 2f, // Snowflake size
        speed = Random.nextFloat() * 1.2f + 1f  // Falling speed
    )
}

fun DrawScope.drawSnowflake(snowflake: Snowflake, offsetY: Float) {
    val newY = (snowflake.y + offsetY * snowflake.speed) % size.height
    drawCircle(Color.White, radius = snowflake.radius, center = Offset(snowflake.x * size.width, newY))
}
</code></pre>

<h4>代码说明</h4>

<ul>
<li>SnowfallEffect 设置了一个包含多个雪花（Snowflake 对象）的粒子系统。</li>
<li>每个雪花都具有位置 (x, y)、半径（大小）和速度等属性。</li>
<li>rememberInfiniteTransition 和 animateFloat 用于创建连续的垂直运动效果，模拟降雪。</li>
<li>Canvas 可组合函数用于绘制每片雪花。drawSnowflake 函数根据每片雪花的速度和动画的 offsetY 计算其新的位置。</li>
<li>雪花从底部落下后会重新出现在顶部，从而产生循环降雪效果。</li>
</ul>


<h2>总结</h2>

<p>随着我们对 Jetpack Compose 动画的探索逐渐深入，我们清楚地认识到，动画不仅仅是视觉上的点缀。它们是打造引人入胜、直观且赏心悦目的用户体验的关键工具。</p>

<h3>拥抱互动性</h3>

<p>从动态游戏角色运动到交互式时间轴，我们见证了动画如何让用户交互更具吸引力和信息量。</p>

<h3>打造逼真的体验</h3>

<p>雪花飘落效果和变形形状展现了该工具包将真实感和流畅性带入数字世界的能力。这些动画有助于打造与用户产生共鸣的沉浸式体验。</p>

<h3>简化复杂性</h3>

<p>无论是编排多个元素还是制作状态转换动画，其简单易用性都令人瞩目。</p>

<h2>结束语</h2>

<p>如果你喜欢本文，请随时留下宝贵的反馈或赞赏。我一直期待与其他开发者一起学习、合作、共同成长。</p>

<p>如有任何疑问，请随时给我留言！</p>

<p>在 Medium 上关注我，获取更多文章 — <a href="https://medium.com/@pherwani37">Medium 个人资料</a>（链接：<a href="https://medium.com/@pherwani37%EF%BC%89">https://medium.com/@pherwani37%EF%BC%89</a></p>

<p>在<a href="https://linkedin.com/in/nirbhaypherwani">LinkedIn</a>（链接：<a href="https://linkedin.com/in/nirbhaypherwani%EF%BC%89%E5%92%8C">https://linkedin.com/in/nirbhaypherwani%EF%BC%89%E5%92%8C</a><a href="https://twitter.com/nirbhayph">Twitter</a>（链接：<a href="https://twitter.com/nirbhayph%EF%BC%89%E4%B8%8A%E4%B8%8E%E6%88%91%E8%81%94%E7%B3%BB%EF%BC%8C%E4%BB%A5%E4%BE%BF%E6%88%91%E4%BB%AC%E8%BF%9B%E8%A1%8C%E5%90%88%E4%BD%9C%E3%80%82">https://twitter.com/nirbhayph%EF%BC%89%E4%B8%8A%E4%B8%8E%E6%88%91%E8%81%94%E7%B3%BB%EF%BC%8C%E4%BB%A5%E4%BE%BF%E6%88%91%E4%BB%AC%E8%BF%9B%E8%A1%8C%E5%90%88%E4%BD%9C%E3%80%82</a></p>

<p>祝你动画制作愉快！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解Jetpack Compose中副作用函数的内部原理]]></title>
    <link href="https://alexhilton.github.io/blog/2025/05/01/understanding-side-effect-handlers/"/>
    <updated>2025-05-01T11:05:24+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/05/01/understanding-side-effect-handlers</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Understanding the Internals of Side-Effect Handlers in Jetpack Compose」，原文链接<a href="https://proandroiddev.com/understanding-the-internals-of-side-effect-handlers-in-jetpack-compose-d55fbf914fde">https://proandroiddev.com/understanding-the-internals-of-side-effect-handlers-in-jetpack-compose-d55fbf914fde</a>，由Jaewoong Eum发布于2025年4月10日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*GNgL_XzYpw16hn6BxocOww.jpeg" title="auto auto" ></a></p>

<!-- more -->


<p>近年来，Jetpack Compose生态呈指数级增长，现已被广泛用于构建 Android 应用的产品级UI。现在，我们可以说 Jetpack Compose 代表了 Android UI 开发的未来。</p>

<p>Compose 最大的优势之一是其声明式（declarative）方法——它允许开发者描述 UI 应该显示的内容，而框架则负责处理 UI 在底层状态发生变化时应如何更新。这种模型将焦点从命令式（imperative）UI 转移到更直观、更具响应式的思维方式。</p>

<p>然而，尽管声明式 UI有很多优势，但妥善管理副作用也至关重要。可组合函数可能会因各种原因（例如状态或参数的变化）而被重组，如果副作用处理不当，应用的行为可能会变得不可预测。</p>

<p>在本文中，你将探索 Jetpack Compose 默认提供的副作用处理 API。你还将研究它们的内部工作流程，以更好地了解 Compose 如何在底层管理这些操作。</p>

<h2>副作用（Side Effect）是啥？</h2>

<p>副作用（Side Effect）是指发生在可组合函数作用域之外的应用状态变化。在 Jetpack Compose 中，由于状态变化、参数更新或其他事件触发的重组，可组合函数可能会频繁且不可预测地重新执行（译注：也就是说Compose的重组是不受开发者控制的）。因此，你不能假设一个可组合函数只会被调用一次。</p>

<p>换句话说，在可组合函数内部直接调用业务逻辑（例如从网络获取数据或查询数据库）是有风险的。由于潜在的重组，这些操作可能会无意中运行多次，从而导致错误或性能问题。</p>

<p>为了解决这个问题，Jetpack Compose 提供了一组专门用于以安全可控的方式管理副作用的API。这些 API包括 LaunchedEffect 、 DisposableEffect 、 SideEffect 、 rememberCoroutineScope 等等。在本文中，你将重点介绍三个最常用的处理程序—— LaunchedEffect 、 DisposableEffect 和 SideEffect ——并仔细研究它们的内部实现，以便更好地理解它们的底层工作原理。</p>

<h2>LaunchedEffect</h2>

<p>LaunchedEffect是Jetpack Compose中最常用的副作用处理 API之一。它允许你以可组合生命周期感知的方式（而非 Android 生命周期）启动协程，并确保除非指定的关键参数（keys）之一发生变化，否则不会重新执行提供的代码块。这种行为使得 LaunchedEffect 特别适合执行与特定状态相关的一次性事件，例如显示 Toast或Snackbar、记录事件或触发业务逻辑，正如你在 Now in Android 项目中的示例代码中所见：</p>

<pre><code class="Kotlin">val snackbarHostState = remember { SnackbarHostState() }
val isOffline by appState.isOffline.collectAsStateWithLifecycle()

// 如果用户未连接到互联网，则显示一个Snackbar来通知他们。
val notConnectedMessage = stringResource(R.string.not_connected)
LaunchedEffect(isOffline) {
    if (isOffline) {
        snackbarHostState.showSnackbar(
            message = notConnectedMessage,
            duration = Indefinite,
        )
    }
  }
</code></pre>

<p>需要注意的是，LaunchedEffect 会在底层创建一个新的协程作用域。这意味着它主要用于在可组合函数作用域内执行基于协程的任务，并在可组合函数离开组合时自动取消其协程。因此，LaunchedEffect 最适合用于与协程相关的操作，例如数据获取、延迟效果或事件处理，而不是简单地执行非暂停函数。现在，让我们深入探究一下，以更好地理解 LaunchedEffect 的内部工作原理。</p>

<pre><code class="Kotlin">@Composable
fun LaunchedEffect(
    key1: Any?,
    block: suspend CoroutineScope.() -&gt; Unit
) {
    val applyContext = currentComposer.applyCoroutineContext
    remember(key1) { LaunchedEffectImpl(applyContext, block) }
}

internal class LaunchedEffectImpl(
    parentCoroutineContext: CoroutineContext,
    private val task: suspend CoroutineScope.() -&gt; Unit
) : RememberObserver {
    private val scope = CoroutineScope(parentCoroutineContext)
    private var job: Job? = null

    override fun onRemembered() {
        // 这不应该发生，但为了安全起见留在这里
        job?.cancel("Old job was still running!")
        job = scope.launch(block = task)
    }

    override fun onForgotten() {
        job?.cancel(LeftCompositionCancellationException())
        job = null
    }

    override fun onAbandoned() {
        job?.cancel(LeftCompositionCancellationException())
        job = null
    }
}
</code></pre>

<p>正如你在LaunchedEffect的内部实现中所看到的，它会创建LaunchedEffectImpl并将其存储在内存中，并将给定的键值作为参数，以便在键发生变化时重新创建 LaunchedEffectImpl 实例。</p>

<p>如果你查看内部 LaunchedEffectImpl 类，你会发现它实现了RememberObserver接口，并首先创建一个新的 CoroutineScope。然后，当可组合项进入组合阶段时，提供的 lambda 会在此范围内启动。当可组合项离开组合阶段时，协程范围会自动取消，从而确保资源得到正确清理，并避免潜在的内存泄漏或性能问题。</p>

<p>话虽如此，如果你的任务不涉及任何与协程相关的操作，而只是需要在键发生变化时重新执行，那么使用 LaunchedEffect 可能略显多余。虽然创建协程作用域的开销通常很小，但在实际不使用协程的情况下，它仍然是不必要的。在这种情况下，你可以考虑使用更轻量级的副作用处理library (<a href="https://github.com/skydoves/compose-effects?tab=readme-ov-file#rememberedeffect">RememberedEffect</a>)，它更适合非挂起（non-suspending）任务。</p>

<p>另一个常见的误解是LaunchedEffect能够感知 Android生命周期——但事实并非如此。从内部实现可以看出，LaunchedEffect的作用域完全限定于Jetpack Compose组合生命周期，与 Android组件（Activity和Fragment）的生命周期没有直接关联。</p>

<p>换句话说，它本身并不了解任何有关 Activity、Fragment 或 onStop()或 onDestroy()等生命周期事件的信息。这意味着，如果你在 LaunchedEffect 中启动一个协程，并且 Android 组件（例如 Activity）在可组合项未离开组合的情况下被停止或销毁，则该协程可能会继续运行，除非它明确与Android组件生命周期绑定。</p>

<h2>DisposableEffect</h2>

<p>DisposableEffect是Jetpack Compose 运行时提供的另一个副作用处理API。它允许你与可组合项的生命周期同步执行设置和清理逻辑。与LaunchedEffect不同，它提供了一个 DisposableEffectScope 作为接收器（receiver），使你能够定义一个清理代码块（clean-up code block），该代码块在可组合项离开组合时自动运行。这使得它非常适合管理需要显式卸载的外部资源，例如监听器、回调或广播接收器。</p>

<pre><code class="Kotlin">val lifecycleOwner = LocalLifecycleOwner.current

// 如果 `lifecycleOwner` 发生变化，则释放并重置效果
DisposableEffect(lifecycleOwner) {
  // 创建一个观察者，触发我们记住的回调以发送分析事件
  val observer = LifecycleEventObserver { _, event -&gt;
    if (event == Lifecycle.Event.ON_RESUME) {
      // do something
    } else if (event == Lifecycle.Event.ON_PAUSE || event == Lifecycle.Event.ON_STOP) {
      // do something
    }
  }

  // Add the observer to the lifecycle
  lifecycleOwner.lifecycle.addObserver(observer)

  // 当效果离开 Composition 时，移除观察者
  onDispose {
    lifecycleOwner.lifecycle.removeObserver(observer)
  }
</code></pre>

<p>上面的示例使用 DisposableEffect 将 LifecycleEventObserver注册到lifecycleOwner，使其能够观察生命周期变化并根据当前状态执行特定逻辑。观察者会在onDispose块内被安全地移除，确保在可组合项离开组合时进行适当的清理。现在，让我们深入了解DisposableEffect的内部工作原理。</p>

<pre><code class="Kotlin">@Composable
fun DisposableEffect(
    key1: Any?,
    effect: DisposableEffectScope.() -&gt; DisposableEffectResult
) {
    remember(key1) { DisposableEffectImpl(effect) }
}

private class DisposableEffectImpl(
    private val effect: DisposableEffectScope.() -&gt; DisposableEffectResult
) : RememberObserver {
    private var onDispose: DisposableEffectResult? = null

    override fun onRemembered() {
        onDispose = InternalDisposableEffectScope.effect()
    }

    override fun onForgotten() {
        onDispose?.dispose()
        onDispose = null
    }

    override fun onAbandoned() {
        // 由于未调用 [onRemembered]，因此无需执行任何操作。
    }
}

class DisposableEffectScope {
    inline fun onDispose(
        crossinline onDisposeEffect: () -&gt; Unit
    ): DisposableEffectResult = object : DisposableEffectResult {
        override fun dispose() {
            onDisposeEffect()
        }
    }
}
</code></pre>

<p>如 DisposableEffect 的内部实现所示，它会创建一个 DisposableEffectImpl 实例，并使用提供的键将其存储在内存中。
每当键发生变化时，都会创建一个新的DisposableEffectImpl 实例，以便相应地重新执行该效果。</p>

<p>DisposableEffectImpl类实现了 RememberObserver 接口，并初始创建一个 DisposableEffectResult。当可组合项进入组合阶段时，效果 lambda 会在 DisposableEffectScope 中启动。退出组合时，会自动调用 DisposableEffectResult的onDispose 函数，以确保在可组合项完全从组合中移除之前正确清理资源并防止内存泄漏或性能问题。</p>

<h2>SideEffect</h2>

<p>Jetpack Compose中的SideEffect API 用于安全地将可组合项内发生的状态变化通知给外部非 Compose 管理的对象。它确保效果在重组成功后运行，使其成为触发依赖于界面最终稳定状态的副作用的理想选择。</p>

<p>使用 SideEffect可以避免在重组阶段执行的操作可能会被丢弃的风险，如果你在未采取此保护措施的情况下直接在可组合项中编写效果，则可能会发生这种情况。因此，当你需要将 Compose 状态与外部系统（例如日志记录工具、分析工具或命令式界面组件）同步时，SideEffect 至关重要，如下例所示：</p>

<pre><code class="Kotlin">@Composable
fun rememberFirebaseAnalytics(user: User): FirebaseAnalytics {
    val analytics: FirebaseAnalytics = remember {
        FirebaseAnalytics()
    }

    // 每次成功组合后，使用当前用户的用户类型更新 FirebaseAnalytics，
    // 确保将来的分析事件已附加此元数据
    SideEffect {
        analytics.setUserProperty("userType", user.userType)
    }
    return analytics
}
</code></pre>

<p>现在，让我们探索一下 SideEffect API 的底层工作原理。</p>

<pre><code class="Kotlin">@Composable
fun SideEffect(
    effect: () -&gt; Unit
) {
    currentComposer.recordSideEffect(effect)
}

/** 当我们应用组合变化时安排运行副作用。 */
override fun recordSideEffect(effect: () -&gt; Unit) {
    changeListWriter.sideEffect(effect)
}
</code></pre>

<p>乍一看，上面的代码可能看似简单，但实际上却难以完全理解，这很正常。这是因为 SideEffect API与 Compose运行时底层内部机制紧密相关，尤其是 ChangeList，它用于跟踪和管理用于更新渲染UI的状态驱动变更列表。</p>

<p>根据 Compose源代码中的内部注释，SideEffect API的表示如下：</p>

<blockquote><p>安排效果在当前合成成功完成并应用更改时运行。SideEffect 可用于将副作用应用于合成管理的、未受快照支持的对象，以便在当前合成操作失败时避免这些对象处于不一致的状态。</p>

<p>副作用将始终在合成的应用调度程序上运行，并且应用器永远不会与自身、彼此并发运行，也不会将更改应用于合成树或运行 RememberObserver 事件回调。SideEffect 始终在 RememberObserver 事件回调之后运行。</p></blockquote>

<p>因此，SideEffect API 会在每次成功重组后运行。</p>

<h2>结论</h2>

<p>在本文中，你探索了 Jetpack Compose 中常用的三个主要副作用处理API。由于声明式UI（declarative UI）的特性，状态会影响运行时行为的诸多方面，因此正确地使用副作用函数对于确保任务执行的正确性和可预测性至关重要。</p>

<p>本主题最初在<a href="https://github.com/doveletter/">Dove Letter</a>（译注：链接是<a href="https://github.com/doveletter/%EF%BC%89%E4%B8%AD%E4%BB%8B%E7%BB%8D%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E7%A7%81%E4%BA%BA%E4%BB%A3%E7%A0%81%E5%BA%93%EF%BC%8C%E6%8F%90%E4%BE%9B%E6%9C%89%E5%85%B3">https://github.com/doveletter/%EF%BC%89%E4%B8%AD%E4%BB%8B%E7%BB%8D%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%80%E4%B8%AA%E7%A7%81%E4%BA%BA%E4%BB%A3%E7%A0%81%E5%BA%93%EF%BC%8C%E6%8F%90%E4%BE%9B%E6%9C%89%E5%85%B3</a> Android 和 Kotlin 的每日见解，涵盖 Compose、架构、行业面试问题和实用代码技巧等主题。自上线以来的短短 37 周内，Dove Letter 已拥有超过 700 名个人订阅者和 20 名企业/终身订阅者。如果你渴望深入了解 Android、Kotlin 和 Compose，请务必查看<a href="https://medium.com/@skydoves/learn-kotlin-and-android-with-dove-letter-26265da11903">“通过 Dove Letter 学习 Kotlin 和 Android”</a>（译注：链接是<a href="https://medium.com/@skydoves/learn-kotlin-and-android-with-dove-letter-26265da11903%EF%BC%89%E3%80%82">https://medium.com/@skydoves/learn-kotlin-and-android-with-dove-letter-26265da11903%EF%BC%89%E3%80%82</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[深入理解Jetpack Compose中的函数的执行顺序]]></title>
    <link href="https://alexhilton.github.io/blog/2025/04/26/understanding-execution-order-in-jetpack-compose/"/>
    <updated>2025-04-26T21:21:31+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/04/26/understanding-execution-order-in-jetpack-compose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Understanding Execution Order in Jetpack Compose: DisposableEffect, LaunchedEffect, and Composables」，原文链接<a href="https://proandroiddev.com/understanding-execution-order-in-jetpack-compose-disposableeffect-launchedeffect-and-composables-d2d0b75b7ec8">https://proandroiddev.com/understanding-execution-order-in-jetpack-compose-disposableeffect-launchedeffect-and-composables-d2d0b75b7ec8</a>，由Sahil Thakar发布于2025年4月13日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*44_HTD27S8k-mxkIc_A9zg.png" title="auto auto" ></a></p>

<!-- more -->


<p>大家好，今天我们又来聊聊Jetpack-Compose的小话题。无论对于新手还是经验丰富的开发者来说，这都是一个小话题，但却是很关键的。我们将讨论一下Jetpack Compose中副作用和可组合项（composables）的执行顺序，特别是 DisposableEffect、LaunchedEffect 和可组合函数的执行顺序以及其生命周期交互过程。</p>

<p>我们将仔细探究 DisposableEffect 和 LaunchedEffect 在可组合项之间导航切换时是如何执行的，特别关注它们在返回之前访问过的页面时的行为。（许多经验丰富的开发者会告诉我我知道这一点，但我敢打赌，你们中的很多人并不知道）。</p>

<p>那么，让我们开始吧。</p>

<pre><code class="Kotlin">@Composable
fun MyComposable(cartId: String) {
    val lifecycleOwner = LocalLifecycleOwner.current

    // DisposableEffect observes the lifecycleOwner
    DisposableEffect(lifecycleOwner) {
        Log.e("Init", "DisposableEffect")

        onDispose {
            Log.e("Init", "DisposableEffect - onDispose")
        }
    }

    // LaunchedEffect triggers when cartId changes
    LaunchedEffect(key1 = cartId) {
        Log.e("Init", "LaunchedEffect")
    }

    // Scaffold is the UI container
    Column {
        Log.e("Init", "Column")
        // You can add your screen content here
    }
}

Output:-

E/Init: Column
E/Init: DisposableEffect
E/Init: LaunchedEffect
</code></pre>

<h2>执行顺序迷题：为什么Column先执行？</h2>

<p>答案在于这些副作用 API（DisposableEffect、LaunchedEffect）相对于组合(Composition)的实际执行时间。</p>

<h3>1. 组合阶段优先</h3>

<ul>
<li>Jetpack Compose 首先在组合期间构建UI树。</li>
<li>此时，Column 是一个可组合函数。它会在组合阶段立即执行，以构建 UI。</li>
<li>因此：Column() 首先运行 → 打出日志 “Column”。</li>
</ul>


<h3>2. 副作用在组合期间注册，但在组合完成后执行</h3>

<ul>
<li>DisposableEffect 和 LaunchedEffect 在组合期间注册其工作，
但它们的实际执行发生在组合完成后。</li>
<li>Compose 使用内部调度程序（通过 Recomposer）在提交帧后运行副作用。</li>
</ul>


<p>因此，实际时间线如下所示：</p>

<pre><code class="Bash">组合（Composition） 开始
   → Column() 运行 → 打印日志 "Column"
   → 注册 DisposableEffect 代码块
   → 注册 LaunchedEffect 代码块
组合 结束
→ 副作用函数开始执行
   → DisposableEffect 执行 → 打印日志 "DisposableEffect"
   → LaunchedEffect 启动协程 → 打印日志 "LaunchedEffect"
</code></pre>

<p>这里我们讨论了composables和副作用之间的执行顺序。
那么在 LaunchedEffect和 DisposableEffect副作用函数之间，谁又将先执行呢？</p>

<p>让我们来仔细看看。</p>

<p><strong>副作用函数的执行顺序（组合完成后）：</strong></p>

<ol>
<li>DisposableEffect → 首先运行</li>
<li>LaunchedEffect → 随后运行</li>
</ol>


<p>为啥子呢？</p>

<p>此顺序由Compose运行时定义的：</p>

<ul>
<li>DisposableEffect 是同步的，用于在组合后立即处理设置/清理。</li>
<li>LaunchedEffect 会启动一个协程，而协程的启动是异步的，计划在其他同步效果（例如 DisposableEffect）之后运行。</li>
</ul>


<p>内部机制：Jetpack Compose 维护了明确定义的效果应用顺序。</p>

<ol>
<li>DisposableEffect、SideEffect、SnapshotFlow 等副作用会在组合后立即触发（同步）。</li>
<li>然后，基于协程的效果（例如 LaunchedEffect）会被调度到下一个运行（异步，通过 Recomposer）。</li>
</ol>


<p>现在，让我们看看在可组合项之间导航切换时 DisposableEffect 和 LaunchedEffect 是如何执行的，尤其关注它们在返回之前访问过的屏幕时的行为。</p>

<p>输出结果会让你大吃一惊。</p>

<pre><code class="Kotlin">@Composable
fun MyApp() {
    val navController = rememberNavController()

    NavHost(navController = navController, startDestination = "screenA") {
        composable("screenA") {
            ScreenA(
                cartId = "123",
                onNavigateToB = { navController.navigate("screenB") }
            )
        }
        composable("screenB") {
            ScreenB(
                cartId = "456",
                onNavigateBack = { navController.popBackStack() }
            )
        }
    }
}

@Composable
fun ScreenA(cartId: String, onNavigateToB: () -&gt; Unit) {
    DisposableEffect(Unit) {
        println("😇 ScreenA -&gt; DisposableEffect")
        onDispose {
            println("😇 ScreenA -&gt; DisposableEffect - onDispose")
        }
    }

    LaunchedEffect(cartId) {
        println("😇ScreenA -&gt; LaunchedEffect")
    }

    Column(modifier = Modifier.padding(top = 100.dp)) {
        Button(onClick = onNavigateToB) {
            Text(text = "Navigate To ScreenB")
        }
    }

}

@Composable
fun ScreenB(cartId: String, onNavigateBack: () -&gt; Unit) {
    val lifecycleOwner = LocalLifecycleOwner.current

    DisposableEffect(lifecycleOwner) {
        println("😇 ScreenB -&gt; DisposableEffect")
        onDispose {
            println("😇 ScreenB -&gt; DisposableEffect - onDispose")
        }
    }

    LaunchedEffect(cartId) {
        println("😇 ScreenB -&gt; LaunchedEffect")
    }

    Column{
        Column(modifier = Modifier) {
            Button(onClick = onNavigateBack) {
                Text("Back to Screen A")
            }
        }
    }
}

Output:- 

when ScreenA init
😇 ScreenA -&gt; DisposableEffect
😇 ScreenA -&gt; LaunchedEffect

Navigate To ScreenA -&gt; ScreenB
😇 ScreenB -&gt; DisposableEffect
😇 ScreenB -&gt; LaunchedEffect
😇 ScreenA -&gt; DisposableEffect - onDispose

Navigate back to ScreenB -&gt; ScreenA
😇 ScreenA -&gt; DisposableEffect
😇 ScreenA -&gt; LaunchedEffect
😇 ScreenB -&gt; DisposableEffect - onDispose
</code></pre>

<h2>它（Jetpack Compose导航）内部实际发生了什么？</h2>

<p>Compose Navigation在 NavHost中围绕可组合项的行为遵循以下逻辑：</p>

<ol>
<li>首先进行新目的地（此处为 ScreenA）的组合。

<ul>
<li>导航切换时，Compose会立即为新屏幕创建UI。</li>
<li>新页面（此处为 ScreenA）的 DisposableEffect 和 LaunchedEffect 会在新页面组合期间或之后立即执行。</li>
</ul>
</li>
<li>在新目的地成功组合并提交到 UI 层次结构后，会处理上一个页面的可组合项（此处为 ScreenB）。

<ul>
<li>Compose 会保持上一个可组合项（此处为 ScreenB）短暂处于活动状态，直到新可组合项（此处为 ScreenA）稳定，以确保导航顺畅。</li>
<li>只有在新的可组合项（此处为 ScreenA）完全组合后，Compose 才会清理并移除（dispose）上一个可组合项（此处为 ScreenB）。</li>
</ul>
</li>
</ol>


<p>因此，导航期间的实际生命周期流程是酱婶儿的：</p>

<pre><code class="Bash">导航返回 (ScreenB → ScreenA)
│
├── 1️⃣ Compose 立即创建 ScreenA
│      ├─ ScreenA DisposableEffect executes instantly.
│      └─ ScreenA LaunchedEffect coroutine launched.
│
└── 2️⃣ 在ScreenA成功运行之后:
       └─ ScreenB DisposableEffect onDispose runs.
</code></pre>

<h2>为啥Compose要酱紫 搞？</h2>

<p>Compose Navigation 会谨慎处理页面的组合，以确保丝滑（seamless）的用户体验和稳定性：</p>

<ul>
<li>它不会在确保目标页面 (ScreenA) 已组合并准备就绪之前过早地处理上一个可组合项 (ScreenB)。</li>
<li>这可以避免在导航切换过程中出现视觉故障或空白屏幕。</li>
<li>只有在确保新页面安全到位后，Compose 才会触发处理上一个屏幕的操作。</li>
</ul>


<h2>Jetpack Compose NavHost内部机制（简化版本）：</h2>

<p>在调用 popBackStack() 或 navigate() 时，Compose 的 NavHost 内部的工作方式如下：</p>

<ul>
<li>新的路由组合开始（可组合项创建）。</li>
<li>成功组合并提交帧后，不再位于 NavHost 后栈中的旧可组合项节点将被标记为待处理。</li>
<li>然后，Compose 会在下一帧中运行这些已移除可组合项的处置逻辑 (onDispose)。</li>
</ul>


<p>因此，即使你在视觉上立即导航回原点，销毁式的操作（如onDispose）也会略微延迟执行，以保证界面的整体稳定性。</p>

<p>如果你有任何疑问，请留言，我会尽快回复你。💬✨
我们很快会深入探讨Jetpack Compose，敬请期待！🚀
在此之前，祝你coding愉快！🎉👨‍💻</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jetpack Compose的性能优化建议]]></title>
    <link href="https://alexhilton.github.io/blog/2025/04/22/performance-optimization-in-jetpack-compose/"/>
    <updated>2025-04-22T22:34:25+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/04/22/performance-optimization-in-jetpack-compose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Performance Optimization in Jetpack Compose」，原文链接<a href="https://carrion.dev/en/posts/performance-optimization-compose/">https://carrion.dev/en/posts/performance-optimization-compose/</a>，由Ignacio Carrión，发布于2025年4月8日。</p></blockquote>

<p><a href=""><img src="https://www.itmob.cn/upload/2023/01/banner-jetpack-compose-a452c3e8f1ad489a8560a4f0a9f88e07.jpg" title="auto auto" ></a></p>

<!-- more -->


<p><strong>译者按：</strong> Jetpack Compose是一个优秀的声明式UI框架，对开发者非常友好，可以高效率的撸各种UI页面和UI元素。但它仍然并不是很成熟，有些事情还做不了，而且渲染性能也略输于原生的View方式，毕竟它比原生的View多了一层组合树和渲染树。因此，在享受声明式UI带来的便捷的同时，就需要深入地了解其内部的工作机制，和学习一些高级技巧，以提升运行时的渲染性能。另外，需要 注意虽然这篇文章是针对for Android的Jetpack Compose，但大部分也适用于Compose Multiplatform。</p>

<p>性能优化对于在Jetpack Compose应用中提供流畅的用户体验至关重要。本文探讨了关键技术和最佳实践，以确保你的可组合函数高效且性能卓越。</p>

<h2>理解组合（Composition）和重组（ReComposition）</h2>

<p><strong>译注：</strong> 组合与重组是Compose中非常重要 的概念，如果不熟悉的同学可以复习一下之前的文章<a href="https://juejin.cn/post/7379437165486112805">降Compose十八掌之『潜龙勿用』| Thinking in Compose</a>和<a href="https://juejin.cn/post/7401358349877346338">降Compose十八掌之『损则有孚』| Lifecycle</a>。</p>

<p>Compose 性能的一个基本方面是了解合成和重组的工作原理：</p>

<h3>智能重组（Smart Recomposition）</h3>

<p>Compose 使用智能重组功能，仅更新界面中需要更改的部分。了解触发重组的原因以及如何最小化重组的影响范围对于性能优化至关重要。</p>

<pre><code class="Kotlin">@Composable
fun ExpensiveCalculation(numbers: List&lt;Int&gt;) {
    // 不好：每次重组都会执行昂贵的操作
    val average = numbers.takeIf { it.isNotEmpty() }
        ?.average()
        ?: 0.0

    // 优点：昂贵的操作被缓存，并且仅在输入发生变化时重新计算
    val cachedAverage = remember(numbers) {
        numbers.takeIf { it.isNotEmpty() }
            ?.average()
            ?: 0.0
    }

    Column {
        // 每次重组时都会重新计算
        Text("Current Average: ${"%.2f".format(average)}")

        // 这将使用缓存住的值
        Text("Cached Average: ${"%.2f".format(cachedAverage)}")
    }
}
</code></pre>

<h3>稳定类型（Stable types）和不可变性（Immutability）</h3>

<p>稳定的类型对于Compose的智能重组系统至关重要。当Compose能够保证其 equals() 方法与其属性一致，并且属性本身不会在不触发重组的情况下发生变化时，该类型即被视为稳定类型。</p>

<pre><code class="Kotlin">// 不好：类型不稳定 - 可变属性可能会在不通知Compose的情况下发生变化
data class UserState(
    var name: String, // 可变属性可以偷偷地改变
    var age: Int      // 而且更改不会触发重组
)

// 优点：稳定类型 - 不可变属性和显式稳定性
@Stable  // 告诉Compose此类型具有可预测的相等性
data class UserState(
    val name: String,  // 不可变属性
    val age: Int      // 如要更改需要创建新实例
)
</code></pre>

<p>使用稳定类型有以下几个好处：</p>

<ol>
<li>更高效的重组 - 当Compose确定数据未发生变化时，它可以跳过重组部分UI，换句话说可以减少很多不必要的重组，进而提高性能</li>
<li>可预测的行为 - 数据更改始终会触发正确的UI更新</li>
<li>线程安全（Thread safety） - 不可变数据可以安全地在协程之间共享</li>
</ol>


<p><strong>译注：</strong> 这里说的应该是可以在线程之间安全地共享，协程如果没有线程切换是不会有线程安全问题的。</p>

<h2>性能优化的关键点</h2>

<h3>1. 合理地使用 remember 和 derivedStateOf 进行状态（State）管理</h3>

<p>remember 和 derivedStateOf 函数在状态管理中起到不同的作用：</p>

<pre><code class="Kotlin">@Composable
fun UserProfile(user: User, items: List&lt;Item&gt;) {
    // 缺点：每次重新组合时都重新计算
    val filteredItems = items.filter { it.userId == user.id }

    // 好：使用记忆缓存计算
    val cachedItems = remember(items, user.id) {
        items.filter { it.userId == user.id }
    }

    // 更好的方式：使用 derivedStateOf 进行反应式计算
    val reactiveItems by remember(items) {
        derivedStateOf {
            items.filter { it.userId == user.id }
        }
    }

    // 当 items 发生变化时，reactiveItems 会自动更新
    // 并且仅在过滤结果发生变化时触发重组
    LazyColumn {
        itemsIndexed(
            items = reactiveItems,
            key = { _: Int, item: Item -&gt; item.id }
        ) { _: Int, item: Item -&gt;
            ItemRow(item)
        }
    }
}
</code></pre>

<p><strong>译注：</strong> 对于状态的管理，可以复习一下之前专门讲解副作用(Side effects)的文章<a href="https://juejin.cn/post/7405158681078104127">降Compose十八掌之『龙战于野』| Side Effects</a>。</p>

<h3>2. 合理地使用CompositionLocal</h3>

<p><strong>译注：</strong> 关于CompositionLocal的使用可以看前面写过的文章<a href="https://juejin.cn/post/7434543407636267071">用Compose中的CompositionLocal来暗渡陈仓</a>，下面的示例是想要说明，应该在合理的地方访问CompositionLocal里面的数据，因数对CompositionLocal的访问地方会被触发重组（<a href="https://juejin.cn/post/7401358349877346338">之前的文章有讲过</a>重组的触发是状态使用的地方，而不是定义的地方），如果在所有的地方都 直接访问CompositionLocal，特别是嵌套较深的地方也都 直接访问，那都会触发重组，但大部分其实是不必要的。像下样示例展示的那样，在一定的级别中访问CompositionLocal，然后它的内部嵌套调用直接复用数值，可以避免过度重组。</p>

<pre><code class="Kotlin">// 不好：每个子组件都访问 CompositionLocal
@Composable
fun DeepNestedContent() {
    val theme = LocalTheme.current  // 直接访问
    val strings = LocalStrings.current  // 多个 CompositionLocal 访问
    val dimensions = LocalDimensions.current

    Column {
        Text(
            text = strings.title,
            style = theme.textStyle,
            modifier = Modifier.padding(dimensions.padding)
        )
        // 具有重复 CompositionLocal 访问的更多嵌套内容
    }
}

// 好：提升 CompositionLocal的值以最小化查找
@Composable
fun ParentContent() {
    // 单独访问 CompositionLocal 值
    val theme = LocalTheme.current
    val strings = LocalStrings.current
    val dimensions = LocalDimensions.current

    DeepNestedContent(
        theme = theme,
        strings = strings,
        dimensions = dimensions
    )
}

@Composable
fun DeepNestedContent(
    theme: Theme,
    strings: Strings,
    dimensions: Dimensions
) {
    // 使用传递的参数而不是查找 CompositionLocal 值
    Column {
        Text(
            text = strings.title,
            style = theme.textStyle,
            modifier = Modifier.padding(dimensions.padding)
        )
        // 使用传递的参数进行更多嵌套内容
    }
}
</code></pre>

<h3>3. LazyList 优化技巧</h3>

<p>高效的列表渲染对于流畅的滚动性能至关重要。以下是针对 LazyList 组件的关键优化：</p>

<pre><code class="Kotlin">@Composable
fun &lt;T : Any&gt; OptimizedList(items: List&lt;T&gt;) {
    LazyColumn {
        itemsIndexed(
            items = items,
            // 稳定的key有助于Compose在更新过程中跟踪项目
            key = { _: Int, item: T -&gt; item.hashCode() }
        ) { _: Int, item: T -&gt;
            // 每个item的内容
        }
    }
}
</code></pre>

<p>LazyList 的关键优化点：</p>

<ol>
<li>提供稳定的键，帮助Compose在更新过程中跟踪项目</li>
<li>尽可能使用固定大小以避免重新测量</li>
<li>保持项目可组合项的轻量级</li>
<li>避免在项目内容中进行不必要的分配</li>
<li>记住要为每个项目缓存昂贵的计算</li>
</ol>


<h2>测量和监控性能</h2>

<h3>Layout Inspector和Composition Traces</h3>

<p>Android Studio 中的布局检查器是一款强大的Compose界面性能调试工具。它能够帮助你深入了解应用的视图层次结构、重组计数以及应用于每个可组合项的修饰符。</p>

<p>要将布局检查器与Compose结合使用，请执行以下操作：</p>

<ol>
<li>在调试模式下运行你的应用</li>
<li>在“正在运行的设备”窗口中，你将看到一个用于切换布局检查器的按钮</li>
<li>检查Compose层次结构：

<ul>
<li>查看组件树</li>
<li>检查重组计数</li>
<li>分析修饰符链</li>
<li>检查可组合项参数</li>
</ul>
</li>
</ol>


<p><img src="https://carrion.dev/images/kotlin/layout-inspector.png" alt="Layout Inspector" /></p>

<p>布局检查器中需要监控的关键指标：</p>

<ol>
<li>重组计数 - 数值较高表示存在潜在的优化机会</li>
<li>跳过计数 - 检查可组合项是否在应该跳过重组时跳过</li>
<li>修饰符链复杂度 - 较长的修饰符链可能会影响测量/布局性能</li>
</ol>


<h3>性能测试</h3>

<pre><code class="Kotlin">@Test
fun performanceTest() {
    benchmarkRule.measureRepeated(
        packageName = "com.example.app",
        metrics = listOf(FrameTimingMetric()),
        iterations = 5
    ) {
        composeTestRule.setContent {
            YourComposable()
        }
    }
}
</code></pre>

<h2>最佳实践总结</h2>

<ol>
<li>使用稳定类型(Stable types)和不可变数据结构(Immutable data structures)</li>
<li>使用remember提升高开销计算</li>
<li>在惰性列表(lazy list)中实现合适的键(key)</li>
<li>最小化重组范围</li>
<li>定期分析和测量性能</li>
</ol>


<p>遵循这些优化技巧将有助于确保你的Compose UI保持响应迅速且高效，从而为你的应用提供更好的用户体验。</p>
]]></content>
  </entry>
  
</feed>
