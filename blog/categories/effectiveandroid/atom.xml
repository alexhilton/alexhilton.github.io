<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2024-06-13T20:46:45+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『鸿渐于陆』| State]]></title>
    <link href="http://toughcoder.net/blog/2024/06/04/jetpack-compose-state/"/>
    <updated>2024-06-04T21:05:02+08:00</updated>
    <id>http://toughcoder.net/blog/2024/06/04/jetpack-compose-state</id>
    <content type="html"><![CDATA[<p>Jetpack Compose是一种声明式的UI框架，用以构建GUI应用程序。通过前面的文章我们学会了<a href="https://juejin.cn/post/7371239685702844454">如何使用元素来填充页面</a>，也学会了<a href="https://juejin.cn/post/7373867360020480038">如何装饰元素</a>，但这还不够。UI还必须处理与页面直接相关的数据，因为这是对用户有价值的东西。今天就来学习一下Compose如何处理数据。</p>

<p><a href=""><img src="https://alexzh.com/content/images/size/w2000/2021/02/logo-1.65-1980-4.png" title="auto auto" ></a></p>

<!-- more -->


<h2>什么是状态</h2>

<p>状态（State）其实就是数据，Compose是一种UI框架，UI要显示数据才会有价值。但是呢，Compose毕竟是一种UI框架，它应该只处理需要展示给用户的那部分数据，所以，这里说的数据应该是经过业务逻辑处理过的，需要展示给用户的那部分数据。也就是说只需要处理从ViewModel推送过来的数据即可。</p>

<p>此外，还有一部分只需要在UI内部处理的数据，比如像一些控件的状态，动画中的参数变化等等，这些数据需要完全在UI部分处理掉，都不应该暴露给ViewModel。</p>

<p>因此，对于Compose来说的状态（State），就包括两部分，一部分是从ViewModel推过来的需要展示的数据（具体叫做UiState），以及UI内部逻辑中的状态。</p>

<h2>状态与重组</h2>

<p>本质上来说Compose就是坨函数，更新UI的方式就变成了用新的参数来重新调用这些函数。这些参数便是状态了。任何时候状态发生变化就会发生重组（re-Composition），结果就是UI刷新了，最新的数据呈现给了用户。感知状态变化如何影响着UI的刷新就是状态管理。</p>

<p>有些术语需要说明一下：组合（Composition）描述着UI的生成过程，也即当Compose执行我们所声明的一坨坨函数的时候；初始组合（Initial Composition）首次执行这一坨函数的过程；重组（re-Composition）当状态有更新，重新运行某些函数的过程。</p>

<p>UI要想刷新，呈现最新的数据，这就需要Compose进行重组，而重组是由状态更新触发的，也就是说我们需要用新的数据来重新执行这一坨函数。对于业务逻辑数据，这很好办，可以通过ViewModel推送新的数据，然后重新调用UI函数即可。但这并没有看起来那么容易，因为ViewModel与UI的关系通常不是ViewModel直接持有着UI的对象或者函数，更多的时候是Compose的函数（Composable）中创建持有ViewModel对象，一个函数是没有办法直接调用自身的，这会陷入死循环的（StackOverFlow）。</p>

<pre><code class="Kotlin">@Composable
fun WellnessScreen(
    modifier: Modifier = Modifier,
    wellnessViewModel: WellnessViewModel = viewModel()
) {
    Column(modifier = modifier) {

        WellnessTasksList(
            list = wellnessViewModel.tasks,
            onCheckedTask = { },
            onCloseTask = { }
        )
    }
}
</code></pre>

<p>对于UI逻辑中的数据也是如此，比如说，一个很简单的按扭计数，按照常规的理解，似乎可以这样写：</p>

<pre><code class="Kotlin">@Composable
fun WaterCounter(modifier: Modifier = Modifier) {
    var count = 0

    Column(modifier = modifier.padding(16.dp)) {
        Text(
            text = "You have had $count glasses.",
            modifier = modifier.padding(16.dp)
        )
        Row(
            modifier = modifier.padding(top = 8.dp),
            horizontalArrangement = Arrangement.SpaceEvenly,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Button(onClick = { count++ }, enabled = count &lt; 10) {
                Text("Add one")
            }
            Button(onClick = { count = 0 }, Modifier.padding(start = 8.dp), enabled = count &gt; 0) {
                Text("Clear water count")
            }
        }
    }
}
</code></pre>

<p>但这样写文本中的数字不会变化。</p>

<p>重组要想发生，就必须重新调用Compose的『根函数』，这就需要用到专门的数据结构<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/MutableState">MutableState</a>，Compose会识别并跟踪这些State，当其变化时，会触发重组，并使用State中的最新值。</p>

<pre><code class="Kotlin">interface MutableState&lt;T&gt; : State&lt;T&gt; {
    override var value: T
}
</code></pre>

<h2>管理UI状态</h2>

<p>要想让Compose识别到数据变化，就需要使用状态State，这样当数据变化时会触发重组，Compose会用State中的最新数值来重新运行函数，以刷新UI。比如上面的计数的例子，可以这样修改：</p>

<pre><code class="Kotlin">@Composable
fun WaterCounter(modifier: Modifier = Modifier) {
    var count by remember { mutableStateOf(0) }
    // Other codes not changed
}
</code></pre>

<p>这次，能得到期望的行为：</p>

<p><img src="https://pic2.zhimg.com/v2-d26bd68593ea22ef777f42f83aee37f5_b.webp" alt="state demo" /></p>

<p>有三种方式声明一个状态MutableState：</p>

<ul>
<li>val state = remember { mutableStateOf(default) }</li>
<li>var value by remember { mutableStateOf(default) }</li>
<li>val (vale, setValue) = remember { mutableStateOf(default) }</li>
</ul>


<p>基本上无差别，一般委托方式用的稍多一些。这里<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#remember(kotlin.Function0">remember</a>)的作用是让Compose记住并追踪状态的变化。如果想要让状态能够跨Activity的实例（比如遇到屏幕旋转，语言变化等配置变化导致Activity重启）就需要用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/saveable/package-summary#rememberSaveable(kotlin.Array,androidx.compose.runtime.saveable.Saver,kotlin.String,kotlin.Function0">remeberSaveable</a>)。</p>

<p>这些主要是针对Composable中内部的状态。对于像从ViewModel过来的业务数据，一般都用<a href="https://developer.android.com/reference/kotlin/androidx/lifecycle/compose/package-summary#(androidx.lifecycle.Lifecycle">collectAsState</a>.currentStateAsState())系列方法。</p>

<h2>有状态（Stateful）和无状态（Stateless）</h2>

<p>对于包含了创建State的函数就称作有状态的Composable，而不包含创建状态就是Stateless的。</p>

<p>无状态的Composable是幂等的，调用时直接传入数据，不会产生副作用，也不会触发重组，显然这对开发者来说是最高效的，因为很纯粹，使用起来相当简单，并且完全可复用，<strong>应该尽可能的创建并使用无状态Composables</strong>：</p>

<pre><code class="Kotlin">@Composable
fun CustomButton(text: String, onClick: ()-&gt;Unit) {
     Button(onClick) {
         Text(text)
     }
}
</code></pre>

<h2>状态提升</h2>

<p>因为State是有额外的成本的，因此应该尽可能的减少State的创建，那么就要尽可能的复用State。这就需要把状态提升到使用此State的所有子函数的最小公共函数里面。比如前面的例子，状态count在Text和两个Button中都有使用，那么count至少要提升到它们的公共函数里面。假如，这个count在其他Composable中也有使用，那么就提升到WaterCounter的更上一层，甚至是整个Screen级别。</p>

<p>一般情况下，除了一些仅在局部使用的状态外，放在页面级别的根函数里面是比较好的选择，这样的话只有页面的根函数是Stateful的，其余函数都是Stateless的。</p>

<h2>实战</h2>

<p>纸上来行终觉浅，要想掌握还是要亲手撸。状态管理对于UI框架是相当重要的，因为这是UI发挥作用和产生价值的地方。对于状态管理有一些非常好的CodeLab，可以亲手撸一下，感受一下状态管理到底是啥。</p>

<ul>
<li><a href="https://developer.android.com/codelabs/jetpack-compose-state#0">State in Jetpack Compose</a></li>
</ul>


<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/state">State and Jetpack Compose</a></li>
<li><a href="https://decode.agency/article/jetpack-compose-state/">How to handle state in Jetpack Compose</a></li>
<li><a href="https://www.composables.com/tutorials/state">Everything you need to know about State in Jetpack Compose with examples</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『见龙在田』| Modifier]]></title>
    <link href="http://toughcoder.net/blog/2024/05/30/modifier-made-easy/"/>
    <updated>2024-05-30T20:51:52+08:00</updated>
    <id>http://toughcoder.net/blog/2024/05/30/modifier-made-easy</id>
    <content type="html"><![CDATA[<p>通过<a href="https://juejin.cn/post/7371239685702844454">前面的文章</a>我们学会了如何使用元素来构建和填充我们的UI页面，但这只完成了一半，元素还需要装饰，以及进行动画和事件响应，这才能生成完整的UI。这就要用到Modifier，Jetpack Compose中的灵魂，它被用来装饰和增强Composables，让一个个平凡的元素变成鲜活的，好看的，可交互UI。我们来具体的看一下Modifier的使用方法。</p>

<p><a href=""><img src="https://static.wixstatic.com/media/0d004d_2c19a3d66d7c4007a2f08ce17be24959~mv2.jpg/v1/fill/w_1000,h_500,al_c,q_85,usm_0.66_1.00_0.01/0d004d_2c19a3d66d7c4007a2f08ce17be24959~mv2.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>对于Compose来说，每一个元素叫做Composable，它是一个函数，比如前面学过的布局（如Row）和小部件（如Text）等都是一个Composable，可以把它理解成为一个元素。</p>

<h2>概念和基本使用方法</h2>

<p>Modifier之于元素，犹如CSS之于HTML，但能做的更多，因为除了样式装饰以外，Modifier还能做很多事情，比如响应用户输入。</p>

<p>每一个Composable都可以接收一个Modifier参数，准确地说第一个参数都是Modifier，可以把一个Modifier对象作为第一个参数传给元素；也可以用命名参数如modifier = Modifier.padding(8.dp)。Modifier支持链式调用，它的每个方法都会把当前对象返回：</p>

<pre><code class="Kotlin">@Composable
private fun Greeting(name: String) {
    Column(
        modifier = Modifier
            .padding(24.dp)
            .fillMaxWidth()
    ) {
        Text(text = "Hello,")
        Text(text = name)
    }
}
</code></pre>

<h2>装饰元素的样式</h2>

<p>重点来看一下如何用Modifier装饰元素的样式。需要注意的是Modifier是装饰元素的共性样式如尺寸，背景，边框和位移等等，而像具体元素特性，如Text中的文本样式，是无法用Modifier来修改的。</p>

<h3>尺寸Size</h3>

<p>尺寸对于一个UI元素来说是必要的，就是渲染之后的视觉上的宽度和高度。可以通过Modifier的下列函数来进行尺寸约束：</p>

<ul>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">width</a>.width(androidx.compose.ui.unit.Dp))/<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">height</a>.height(androidx.compose.ui.unit.Dp)) - 指定固定的偏好宽度和偏好高度，参数传入具体的数值如Modifier.width(320.dp).height(480.dp)，就是指定某个元素的宽度是320dp，高度是480dp。偏好（preferred）的意思是可能会被其他约束条件覆盖，而最终值可能会不一样。</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">size</a>.size(androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp)) - 同时指定宽度和高度为某一偏好的数值，只传一个参数就是一个正方形，如Modifier.size(100.dp)，等同于Modifier.width(100.dp).height(100.dp)；传两个参数时分别指定宽和高，如Modifier.size(320.dp, 480.dp)等同于Modifier.width(320.dp).height(480.dp)。</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">wrapContentWidth</a>.wrapContentWidth(androidx.compose.ui.Alignment.Horizontal,kotlin.Boolean))/<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">wrapContentHeight</a>.wrapContentHeight(androidx.compose.ui.Alignment.Vertical,kotlin.Boolean))/<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">wrapContentSize</a>.wrapContentSize(androidx.compose.ui.Alignment,kotlin.Boolean)) - 让元素自己决定尺寸，无视最小尺寸限制（minimum_wdith/minimum_height），类似于XML中的wrap_content，这是比较严格的限制。</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">requiredWidth</a>.requiredWidth(androidx.compose.ui.unit.Dp))/<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">requiredHeight</a>.requiredHeight(androidx.compose.ui.unit.Dp)) - 指定宽度和高度必须为某一数值，不可以被其他限制约束覆盖。带有In的函数可以指定一个范围。</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">requiredSize</a>.requiredSize(androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp)) - 指定宽度和高度必须为某一数值，带有In的函数可以指定范围。</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">widthIn</a>.widthIn(androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp))/<a href="">heightIn</a>/<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">sizeIn</a>.sizeIn(androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp)) - 带有in的函数，可以指定一个范围而非具体数值，比如Modifier.widthIn(10.dp, 100.dp)，就是说限制此元素的宽度为10dp到100dp之间。</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">fillMaxWidth</a>.fillMaxWidth(kotlin.Float))/<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">fillMaxHeight</a>.fillMaxHeight(kotlin.Float)) - 不固定具体的数值，按比例填充最大可用空间，比例为1.0时填满，类似于XML中的match_parent。</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">fillMaxSize</a>.fillMaxSize(kotlin.Float)) - 按比例填充满可用空间。</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/RowScope#(androidx.compose.ui.Modifier">weight</a>.weight(kotlin.Float,kotlin.Boolean)) - 权重比例，仅在父布局是Row或者Column时，且尺寸与父布局约束一致时有效，比如在Row中，对width生效，在Column中对height生效。最终的占比是『权重比例 x 可用空间』，不指定weight则weight是0，比如一个Row中，有三个元素，其中两个元素A和B指定了weight为1和2，另一个没指定，那么A将占Row中剩余可用宽度的1/3，B将占2/3。与View中的LinearLayout中的权重是差不多的。</li>
</ul>


<p>Modifier修饰尺寸的函数比较多，容易学杂了，需要梳理一下：size相当于快捷方式，可以同时约束宽和高；带有In的函数可以为某个约束指定范围。宽高是一种限制性约束，不同的函数的限制严格性是不一样的，带有required是最严格的限制约束，优先级最高，如有冲突，以它为准；wrapContentWidth/wrapContentHeight/wrapContentSize是较严格的限制，仅次于required；width/height/size是中等严格，较wrapContent再次之；weight再次之；fillMax则是最弱的限制。</p>

<h3>间隔</h3>

<p>间隔（padding）是在元素与其边界之间添加的额外的空白空间，<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">Modifier.padding</a>.padding(androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp))不影响元素的尺寸，它是在测量之前就应用生效。</p>

<p>对于有XML经验的同学来说，以往的间隔有两个，一个是margin控制着元素边界之外的间隔，padding控制着边界与元素本身内容间隔。对于Modifier来说，只有一个函数，在不同的位置调用padding函数会有不同的效果，<strong>如果在尺寸之后调用padding，则是调整边界与内容之间的间隔，如果是在尺寸之前调用，则是调整边界与外部的间隔</strong>。另外，就是padding不可以传负值。</p>

<pre><code class="Kotlin">@Composable
fun PaddingDemo(modifier: Modifier = Modifier.fillMaxSize()) {
    Box(modifier = Modifier
        .fillMaxSize()
        .background(Color.LightGray)) {
        Text(
            text = "降龙十八掌",
            style = MaterialTheme.typography.headlineLarge,
            modifier = Modifier
                .padding(16.dp) // As margin: outside space beyond border
                .background(Color.Cyan)
                .size(360.dp, 120.dp)
                .padding(10.dp) // As padding: space between border and content
        )
    }
}
</code></pre>

<p><img src="https://pic2.zhimg.com/80/v2-2e631702c0ecb3e9197b78bcca795781_1440w.webp" alt="padding demo" /></p>

<h3>位移Offset</h3>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">函数Modifier.offset</a>.offset(kotlin.Function1))用来给水平和垂直方向加一个位移，数值可正可负，注意仅是增加位移，并不会改变元素的尺寸。与View中的translateX和translateY是类似的。它有两个函数，只有一个参数时是水平和垂直方向都加上相同的位移；两个参数时是分别指定水平方向和垂直方向。</p>

<pre><code class="Kotlin">@Composable
fun ModifierDemo(modifier: Modifier = Modifier.fillMaxSize()) {
    var offset by remember { mutableStateOf(0) }
    Column(
        modifier = modifier
            .padding(8.dp)
            .clickable { offset += 8 }
    ) {
        Text(
            text = "降龙十八掌",
            style = MaterialTheme.typography.headlineLarge,
            color = MaterialTheme.colorScheme.primary,
            modifier = Modifier
                .offset(offset.dp, offset.dp)
                .background(Color.Cyan)
                .padding(16.dp)
        )
    }
}
</code></pre>

<p><img src="https://pic2.zhimg.com/80/v2-89bf155dba60d2811a2fd164cde81d89_1440w.webp" alt="offset demo" /></p>

<p>因为offset并不改变元素的尺寸，仅是在原位置上进行偏移，所以多用于点击效果，或者点击动画。</p>

<h3>背景Background</h3>

<p>使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">Modifier.background</a>.background(androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Shape))函数来修改元素的背景颜色，唯一需要注意的是padding的影响，background是给尺寸所指定的区域加背景色，所以padding调用的位置会有影响。</p>

<h3>边框Border</h3>

<p>用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">Modifier.bodrer</a>.border(androidx.compose.foundation.BorderStroke,androidx.compose.ui.graphics.Shape))函数可以指定边框的样式，如形状，粗细，线条和颜色。需要注意的是它也是跟尺寸一样的，受padding的影响：</p>

<pre><code class="Kotlin">@Composable
fun BorderWithShape(modifier: Modifier = Modifier.fillMaxSize()) {
    Box {
        Text(
            text = "降龙十八掌",
            style = MaterialTheme.typography.headlineLarge,
            modifier = Modifier
                .padding(10.dp)
                .border(2.dp, SolidColor(Color.Green), RoundedCornerShape(20.dp))
                .padding(10.dp)
        )
    }
}
</code></pre>

<p><img src="https://pic4.zhimg.com/80/v2-59bd2c586c1a0124d178c1bf84f49feb_1440w.webp" alt="border demo" /></p>

<h3>变幻</h3>

<p>Modifier还能对元素进行一些变幻，如透明度（Alpha），旋转（Rotate）和缩放（Scale）。通常用来实现一些非动画的静态特效。</p>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">Modifier.alpha</a>.alpha(kotlin.Float))指定透明度，0是透明，1是完全不透明，默认值是1.0。</p>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">Modifier.rotate</a>.rotate(kotlin.Float))实现旋转，参数是一个角度，顺时针旋转为正值，逆时针旋转为负值，默认值是0度。</p>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">Modifier.scale</a>.scale(kotlin.Float,kotlin.Float))是以元素的几何中心为中心点进行缩放负值会进行水平和垂直方向翻转：</p>

<pre><code class="Kotlin">@Composable
fun TransformationDemo(modifier: Modifier = Modifier.fillMaxSize()) {
    Box(
        modifier = Modifier.fillMaxSize()
            .background(Color.LightGray)
    ) {
        Text(
            text = "降龙十八掌",
            style = MaterialTheme.typography.headlineLarge,
            color = MaterialTheme.colorScheme.primary,
            modifier = Modifier
                .padding(16.dp)
                .alpha(0.618f)
                .rotate(11.8f)
                .scale(0.618f)
                .background(Color.Cyan)
                .size(360.dp, 120.dp)
                .offset(10.dp, 10.dp)
        )
    }
}
</code></pre>

<p><img src="https://pic4.zhimg.com/80/v2-7c306b043b33f57d6eae20fcf59a1303_1440w.webp" alt="transformation demo" /></p>

<h2>事件监听</h2>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">Modifier.clickable</a>.clickable(kotlin.Boolean,kotlin.String,androidx.compose.ui.semantics.Role,kotlin.Function0))函数用来指定点击事件响应。此外，还可以用于指定元素是否可以点击。</p>

<p>另外，还可以通过<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">Modifier.scrollable</a>.scrollable(androidx.compose.foundation.gestures.ScrollableState,androidx.compose.foundation.gestures.Orientation,kotlin.Boolean,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,androidx.compose.foundation.interaction.MutableInteractionSource))来指定元素是否可以滑动。</p>

<h2>最佳实践</h2>

<p>Modifier是非常强大的，也是非常复杂的，前面列出的都是最为常用的一些函数。接下再来学习一下使用Modifier时需要注意的事项。</p>

<h3>顺序很重要</h3>

<p>Modifier有很多很多函数，修改着同一个对象实例，有些函数会相互影响，因此这些<strong>函数的调用顺序</strong>就变得相当重要，特别是涉及尺寸强相关的装饰特性时，如background和border，它们会受到padding以及变幻的影响。比如前面变幻小节的例子，可以试着修改函数的调用顺序，就会发现结果会不一样。在实例使用时，如果出现与预期不一致的结果时，就尝试调整一下Modifiier函数的顺序，看是否是顺序 导致的。</p>

<h3>留意上下文</h3>

<p>在Compose中，有一些Modifier函数只能在特定的元素中使用，这就涉及了Compose上下文（Scope）。比如说像<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/BoxScope#(androidx.compose.ui.Modifier">Modifier.align</a>.align(androidx.compose.ui.Alignment))只能在<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/BoxScope">BoxScope</a>中使用，也就是说只能在Box的子元素中使用。对其他任何布局来说都是不能用的，所以在使用的时候也要注意元素所在的父布局。</p>

<h3>尽可能的复用</h3>

<p>每个元素在渲染的时候都需要一个Modifier对象，通常情况下都是通过Modifier的函数进行对象创建。但对于一些循环的场景，且Modifier对象没啥变化 时，这时就应该复用对象，而非每次都创建。比如说动画，以及像集合性布局的子布局，这时都应该在其父布局缓存Modifier对象，直接传给子元素，而不是让其每次都创建新对象：</p>

<pre><code class="Kotlin">val modifier = Modifier
        .padding(12.dp)
        .background(Color.Gray)
@Composable
fun LoadingWheelAnimation() {
    val animatedState = animateFloatAsState(/*...*/)

    LoadingWheel(
        // 把Modifier对象缓存到上一级的父布局中，以免每帧动画都创建一个Modifier对象
        modifier = reusableModifier,
        animatedState = animatedState
    )
}
</code></pre>

<p>对于集合性布局也最好是能复用Modifier对象：</p>

<pre><code class="Kotlin">val reusableItemModifier = Modifier
    .padding(bottom = 12.dp)
    .size(216.dp)
    .clip(CircleShape)

@Composable
private fun AuthorList(authors: List&lt;Author&gt;) {
    LazyColumn {
        items(authors) {
            AsyncImage(
                // 提升到上一级中时进行缓存，而不是每次都创建
                modifier = reusableItemModifier,
            )
        }
    }
}
</code></pre>

<h3>保持一致性</h3>

<p>一致性对于代码的可维护性和可扩展性是非常重要的，因为每个元素都需要Modifier对象，在Compose中到处都可以看到Modifier，在实际使用中保持一致性就非常重要。比如说Modifier要作为Composable的第一个参数，参数的命名应该是modifier，并且最好要有默认值，可以查阅Compose本身的代码，可以发现其所有的元素都遵循此约定。另外，就是对于共性的装饰要提升到父布局中进行统一设定，比如说根布局统一设定padding，而不是每个子布局进行分别设定，等等。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/modifiers">Compose modifiers</a></li>
<li><a href="https://www.jetpackcompose.net/jetpack-compose-modifiers">6. Jetpack Compose Modifiers</a></li>
<li><a href="https://www.kodeco.com/books/jetpack-compose-by-tutorials/v1.0/chapters/6-using-compose-modifiers">6. Using Compose Modifiers</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『飞龙在天』| Layout]]></title>
    <link href="http://toughcoder.net/blog/2024/05/23/compose-layouts-and-widgets/"/>
    <updated>2024-05-23T20:47:29+08:00</updated>
    <id>http://toughcoder.net/blog/2024/05/23/compose-layouts-and-widgets</id>
    <content type="html"><![CDATA[<p>页面布局是GUI应用开发的核心，决定着一个UI具体如何实现。今天将延着路线图来练习『降Compose十八掌』的第二招式，学习一下如何使用Compose中的布局来构建页面。</p>

<p><a href=""><img src="https://pdfhost.io/api/preview/0d8ea218-1cc8-4b68-a63b-30f534689371" title="auto auto" ></a></p>

<!-- more -->


<h2>基础骨架</h2>

<p>基础骨架是一个应用页面的最关键结构，可以视为一种基础结构，有了基础结构以后，再补充其他具体的细节就能拼凑出来整体页面。<a href="https://developer.android.com/develop/ui/compose/components/scaffold">Scaffold</a>就属于这样的一种基础骨架。</p>

<p>Scaffold并不是Compose设计出来的，它是<a href="https://m3.material.io/">Material Design</a>中的一个基础结构，为复杂的用户界面提供了标准化的平台。它可以把诸如标题栏，内容区域，浮动按扭等不同的UI功能部分组合在一起，形成一个整体连惯的页面。Compose是完全符合Material Design的，因此这里的Scaffold是符合Material Design设计标准的一个实现。</p>

<p>Scaffold主要有四个部分：</p>

<ul>
<li>topBar - 在最顶部的标题栏，可以显示标题，导航按扭，以及菜单。对Android熟悉的同学把它当成ActionBar就可以了。</li>
<li>bottomBar - 在最底部的工具栏，一般用来显示页面内部的下一级的Tab导航，或者当成工具栏放一些实用性操作。</li>
<li>floatingActionButton - 在右下角悬浮的操作按扭。因为右下角空间有限，所以一般把当前页面最主要的操作放在这里。比如说对于文档类，创建『+』按扭就可以放在这里。</li>
<li>content - 内容区域，就是用于显示页面主要内容的地方，无具体形式，需要开发者自己提供其他布局作为内容。唯一需要注意的是，内容Composable lambda有一个参数叫做innerPadding，这个参数的作用是Scaffold对其content区域加的padding，纯大多数情况下，是需要使用此参数的。</li>
</ul>


<p>Scaffold并不难，很好用，看一个&#127792;就知道了：</p>

<pre><code class="Kotlin">@OptIn(ExperimentalMaterial3Api::class)
@Preview
@Composable
fun ScaffoldExample() {
    var presses by remember { mutableIntStateOf(0) }

    Scaffold(
        topBar = {
            TopAppBar(
                colors = mediumTopAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primaryContainer,
                    titleContentColor = MaterialTheme.colorScheme.primary,
                ),
                title = {
                    Text("降Compose十八掌")
                }
            )
        },
        bottomBar = {
            BottomAppBar(
                containerColor = MaterialTheme.colorScheme.primaryContainer,
                contentColor = MaterialTheme.colorScheme.primary,
            ) {
                Text(
                    modifier = Modifier.fillMaxWidth(),
                    textAlign = TextAlign.Center,
                    text = "掌式要义",
                )
            }
        },
        floatingActionButton = {
            FloatingActionButton(onClick = { presses++ }) {
                Icon(Icons.Default.Add, contentDescription = "Add")
            }
        }
    ) { innerPadding -&gt;
        Column(
            modifier = Modifier.padding(innerPadding),
            verticalArrangement = Arrangement.spacedBy(16.dp),
        ) {
            Text(
                modifier = Modifier.padding(8.dp),
                text =
                """
                    “降龙十八掌可说是【武学中的巅峰绝诣】，当真是无坚不摧、无固不破。虽招数有限，但每一招均具绝大威力。
                    北宋年间，丐帮帮主萧峰以此邀斗天下英雄，极少有人能挡得他三招两式，气盖当世，群豪束手。
                    当时共有“降龙廿八掌”，后经萧峰及他义弟虚竹子删繁就简，取精用宏，改为降龙十八掌，掌力更厚。
                    这掌法传到洪七公手上，在华山绝顶与王重阳、黄药师等人论剑时施展出来，王重阳等尽皆称道。”
                """.trimIndent(),
            )
        }
    }
}
</code></pre>

<p>是一个非常标准的Material Design页面。</p>

<p><img src="https://pic4.zhimg.com/80/v2-702cd12966ec61fe985a3d0020114567_1440w.webp" alt="Scaffold Demo" /></p>

<p><strong>注意：</strong>如果仔细看Scaffold函数可以发现，前面提到的四大部分，并不是传入数据，而是传入函数。这是声明式代码与传统方式的最大的区别，也是声明式代码的精髓所在，只是声明一个可以用于产生数据的函数作为参数，而非直接把数据当作参数传过去。这样做的好处在于，框架代码可以在真正需要数据的时候通过调用函数来生成数据，避免了数据提前生成。</p>

<p>小结一下，Scaffold是一个非常强大的基础骨架，适用当作页面基础结构来使用，也就是说只能用它来实现一级页面。</p>

<h2>布局管理器</h2>

<p>有了页面的基础骨架后，就可以往里面填内容了，布局器管理器就是用于组织和管理其他布局和基础部件的约束器，方便对页面元素进行归类和整理。包括三个分类，一是基础布局，是最为基础也最为常用的管理器；二是高级布局，用于一些复杂场景的管理器；三是集合性布局，用于显示数据集合。我们分别来学习。</p>

<h3>基础布局</h3>

<p>最为基础的布局管理器就三个：Row（行式，水平方向依次排列）Column（列式，垂直方向依次排列）和Box（层叠式，在屏幕上层叠）。用一张图就明了：</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/layout-column-row-box.svg" alt="Basic layouts" /></p>

<p>如果有Android基础的同学可以进行类比，Row和Column就相当于LinearLayout，而Box相当于FrameLayout。</p>

<h3>高级布局</h3>

<p>一般情况下通过基础布局的组合能够实现绝大部分的UI页面，如果遇到更复杂的声明，那就要用更为强大的工具。</p>

<h4>约束式布局（ConstraintLayout in Compose）</h4>

<p>ConstraintLayout是谷歌推出的一个更为强大的布局，用约束（constraint）统一了概念，可以任意排列子布局。Compose中也是可以<a href="https://developer.android.com/develop/ui/compose/layouts/constraintlayout">使用ConstraintLayout的</a>，并且它可以替代Row，Column和Box。需要注意它并不是Compose的一部分，需要额外添加依赖：</p>

<pre><code class="Groovy">implementation "androidx.constraintlayout:constraintlayout-compose:1.0.1"
</code></pre>

<pre><code class="Kotlin">@Composable
fun ConstraintLayoutContent() {
    ConstraintLayout {
        // Create references for the composables to constrain
        val (button, text) = createRefs()

        Button(
            onClick = { /* Do something */ },
            // Assign reference "button" to the Button composable
            // and constrain it to the top of the ConstraintLayout
            modifier = Modifier.constrainAs(button) {
                top.linkTo(parent.top, margin = 16.dp)
            }
        ) {
            Text("Button")
        }

        // Assign reference "text" to the Text composable
        // and constrain it to the bottom of the Button composable
        Text(
            "Text",
            Modifier.constrainAs(text) {
                top.linkTo(button.bottom, margin = 16.dp)
            }
        )
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/layout-button-text.png" alt="ConstraintLayout demo" /></p>

<p>ConstraintLayout是非常强大的，可以<a href="https://juejin.cn/post/7259659776459620411">参考前面的一篇文章</a>来了解它的使用方法，在Compose中使用与在View和XML中使用是一样的。</p>

<h4>流式布局（Flow layouts）</h4>

<p><a href="https://developer.android.com/develop/ui/compose/layouts/flow">流式布局</a>非常强大，也非常常用，它们能够自动折成多行或者多列。Row和Column只能一行或者一列，超出了父布局的宽度和高度后，就看不见了。但FlowRow和FlowColumn则可以自动折叠，变为多行或者多列。并且是智能折叠，不会让子元素只显示一半。这个有非常实用的场景，像显示一些新闻的标签时，就可以用FlowRow。</p>

<pre><code class="Kotlin">@Composable
private fun FlowRowSimpleUsageExample() {
    FlowRow(modifier = Modifier.padding(8.dp)) {
        ChipItem("Price: High to Low")
        ChipItem("Avg rating: 4+")
        ChipItem("Free breakfast")
        ChipItem("Free cancellation")
        ChipItem("£50 pn")
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/layouts/flow/flow_row_simple.png" alt="FlowRow demo" /></p>

<h3>集合性布局</h3>

<p><a href="https://developer.android.com/develop/ui/compose/lists">集合性布局</a>用于显示数据集合，通常都是数量比较多。因为集合数据比较多，远超一个屏幕所能显示得完，因此集合性布局的优势在于用少量的子布局，以复用的方式来把集合数据展示出来。主要有三类水平方向的<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/lazy/package-summary#LazyRow(androidx.compose.ui.Modifier,androidx.compose.foundation.lazy.LazyListState,androidx.compose.foundation.layout.PaddingValues,kotlin.Boolean,androidx.compose.foundation.layout.Arrangement.Horizontal,androidx.compose.ui.Alignment.Vertical,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean,kotlin.Function1">LazyRow</a>)，垂直方向的<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/lazy/package-summary#LazyColumn(androidx.compose.ui.Modifier,androidx.compose.foundation.lazy.LazyListState,androidx.compose.foundation.layout.PaddingValues,kotlin.Boolean,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.ui.Alignment.Horizontal,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean,kotlin.Function1">LazyColumn</a>)以及格子式的LazyGrid。使用起来也非常的直观，在其<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/lazy/LazyListScope">LazyListScope</a>中为子元素生成布局就可以了：</p>

<pre><code class="Kotlin">LazyColumn {
    items(
        items = messages, // 这是集合
        key = { message -&gt;
            // 指定一个用于唯一标记集合中每个元素的id
            message.id
        }
    ) { message -&gt;
        // 这里生成集合元素对应的布局
        MessageRow(message)
    }
}
</code></pre>

<p>需要注意的地方就是有很多个扩展函数items，每个集合性布局都有一个，在import的时候一定要选择与布局对应的那个。另外就是为了能让Compose区别不同的数据元素，一定要给集合元素指定一个可以在此范围内唯一标记元素的id。要不然在编辑的时候可能会有问题。</p>

<h2>常见基础部件</h2>

<p>最为常用的就是<a href="https://developer.android.com/develop/ui/compose/text">文本（Text）</a>，<a href="https://developer.android.com/develop/ui/compose/graphics/images/loading">图像（Image）</a>和<a href="https://developer.android.com/develop/ui/compose/graphics/images/material">图标（Icon）</a>了，都不复杂，看个例子就能明白怎么使用。需要说明一下的就是Image是用于显示的图片；而Icon是用于显示小的图标，一般都是矢量图标资源。</p>

<pre><code class="Kotlin">@Composable
fun ArtistCard(artist: Artist) {
    Row(
        modifier = Modifier.padding(16.dp),
        verticalAlignment = Alignment.CenterVertically,
        horizontalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Box {
            Image(painter = painterResource(id = artist.image), contentDescription = "Artist image")
            Icon(
                modifier = Modifier.align(Alignment.BottomEnd),
                imageVector = Icons.Filled.Check, contentDescription = "Check mark",
                tint = MaterialTheme.colorScheme.surfaceTint
            )
        }
        Column {
            Text(
                text = artist.name,
                style = MaterialTheme.typography.titleMedium,
                color = MaterialTheme.colorScheme.primary
            )
            Text(
                text = artist.status,
                style = MaterialTheme.typography.titleSmall,
                color = MaterialTheme.colorScheme.secondary
            )
        }
    }
}
</code></pre>

<p><img src="https://pic1.zhimg.com/80/v2-5cbb58f28d1ef31f076bcbb3c0565ab8_1440w.webp" alt="Widgets" /></p>

<h2>实战练习</h2>

<p>今天学习的内容比较多，Compose的<a href="https://developer.android.com/develop/ui/compose/components">布局非常之多</a>，今天的内容只是深入浅出式的学习了一些基础。另外，强烈建议亲手操练一下，推荐官方出品的实战教程<a href="https://developer.android.com/codelabs/jetpack-compose-basics#0">Jetpack Compose basics</a>和<a href="https://developer.android.com/codelabs/jetpack-compose-layouts#0">Basic layouts in Compose</a>。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/layouts/basics">Compose layout basics</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为安卓猿准备的Google I/O 2024省流版本]]></title>
    <link href="http://toughcoder.net/blog/2024/05/20/google-io-2024-recap/"/>
    <updated>2024-05-20T22:51:35+08:00</updated>
    <id>http://toughcoder.net/blog/2024/05/20/google-io-2024-recap</id>
    <content type="html"><![CDATA[<p>前两天一年一度的谷歌开发者大会Google I/O 2024在大洋彼岸如期举行，在会上谷歌发布了一系列最新的技术。本文将以Android开发为核心来汇总一下大会的内容。</p>

<p><a href=""><img src="https://io.google/2024/app/images/og-image.jpeg" title="auto auto" ></a></p>

<!-- more -->


<h2>Android 15 Beta 2来了</h2>

<p>自从Android站稳了脚跟以后（大概是在Android 4.3之后）基本上就是每年一个大版本的节奏，一般是在春季有预览版本，在秋季正式发布。为了抢在水果的前面，也都会在Google I/O时进行重点的宣传，所以每年的Google I/O一大看点就是新一代的Android。当然了，从去年开始AI变成了焦点，但是回到前几年时Android是绝对的焦点。</p>

<p>今年也不例外，在Google I/O上面也宣传了一下Android 15，并正式发布了第2个Beta版本，从功能和Feature角度来说，这个就非常接近于正式版本了。不过就如我在<a href="https://juejin.cn/post/7359900973991493669">前面一篇文章</a>中提到的那样，Android 15其实没啥亮点，主要集中在安全和隐私方面的加强，其余的改进也都非常的小。</p>

<p>关于Android 15具体的改动，可以看一下<a href="https://juejin.cn/post/7369178977473478693">前排大佬的总结</a>，总结的比较详细，就不重复了。</p>

<p>想体验Android 15 Beta 2的话，如果是谷歌的设备如Pixel系列，应该就有推送了。另外就是现在谷歌都会与厂商联动一起<a href="https://developer.android.com/about/versions/15/devices">发布新版Android的Beta版本</a>，这已经是好几年的传统了。就比如像小米，在15号大半夜（准确地说是16号凌晨）发布了<a href="https://web.vip.miui.com/page/info/mio/mio/detail?postId=44582045&amp;fromPathname=mioHomePage&amp;app_version=dev.240425&amp;ref=share">四款机型的Android 15 Beta OTA包</a>，手头有设备的可以体验一下。</p>

<p><img src="https://cdn.cnbj1.fds.api.mi-img.com/vip/e3f85e4bf27da33a47a6c343532c8f180555ebf855d77401c957163e1b1b2cac?thumb=1&amp;w=5040" alt="" /></p>

<p>再说一下Android 15（targetSdk 35）的适配，如前所述这一版本较上一代没啥变化，如果本身就已经<a href="https://juejin.cn/post/7359900973991493669">适配到了Android 14（targetSdk 34）</a>，就不用再特殊适配了。</p>

<h2>AI霸屏</h2>

<p>从去年开始AI就是巨头们的焦点，今年更是霸屏，整个Keynote全是关于AI的，唯一提到Android的地方，也是说在Android手机上如何使用AI。在大模型这条赛道上Google是追随者，就在Google I/O前两天还被Open AI给抢了热度给恶心了一把，劈柴大叔今年略忧伤，讲Keynote的时候有点无精打彩，完全没了前几年那种激情四射。</p>

<p>今年Google发布了Gemini 1.5 Pro，支持1M的上下文Token，大约可以记得1500份PDF，并且演示了很多大模型的具体应用场景，像搜索，图片处理以及文字和代码生成助手。</p>

<p>当然，Android开发者更应该关注的是在端侧部署的大模型。时至今日，大模型已经进入了平稳提升期，大家都是在做出更强大的模型，比如参数更多，上下文更长等等。但大模型仍有一个短板就是无法在端侧的部署，特别是移动设备，如手机，平板，车机，甚至手表等，因受制于性能。目前来说，端侧使用大模型都还是使用网络API的方式，一方面这会依赖于网络，但更重要的是，这会受制于安全和隐私。端侧大部分的数据，是不能直接，也不太可能全都上传到服务器。因此端则部署大模型还是有价值可挖的，比如说对于设备的运行数据，以及像用户一些不愿分享的数据，就可以直接用端侧的大模型来直接处理。</p>

<p>Google发布了端侧的大模型Gemini Nano，将会集成在Android 15之中，并且它支持多模态，还是值得期待的。不过呢，目前Gemini Nano也没有具体的API，谷歌也只给了一个空头支票，在手机上选择文字，然后端侧大模型就可以求解其中的数学题。说实话，这个举例场景的不够好，写作业的场景，作业题怎么可能出现在手机里，然后还是现成的文字？也说明美帝的学生不够卷，在我朝，早就有了作业帮，猿辅导之类的拍一下题目就能给出详细求解过程。</p>

<p><img src="https://duet-cdn.vox-cdn.com/thumbor/0x0:720x720/1440x1440/filters:focal(360x360:361x361):no_upscale():format(webp)/cdn.vox-cdn.com/uploads/chorus_asset/file/25446163/google_io_cts_720.gif" alt="" /></p>

<p>不过Android生态一向受制于厂商，谷歌能做的事情并不多，估计只在谷歌的官方设备（Pixel）中可以用，其他的还是要靠厂商。这点就比不上水果，相信在6月份，水果应该会拿出更为接地气（有实际场景应用和开放API）的端侧大模型集成方案。</p>

<h2>Android开发工具</h2>

<p>这次谷歌把其大模型Gemini应用到了很多具体的场景中，Android开发官方IDE Android Studio新版本<a href="https://developer.android.com/studio/preview">Koala</a>中就深度绑定了Gemini，可以用来生成代码，分析代码和帮助解决其他编程问题。</p>

<p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjijLoXfb-dz3Mur_G_lCCPvgbTr-b_Fvc6sigTPPlRJbA_0IhNepgqPW9a4UACplpEHc2llUMxOeEFBjxHOINVoHYBMWRJ3FA9B1L4MlEv0lxEg5YFuzv0pvuY47b0466pQeDgwtiPZSiivgr9iZ9GVWL0xxj5pzLysnq6ShNi7hn0LorpNBVa4enXsq4/s1600/code_transforms.gif" alt="" /></p>

<p>除了代码，此外Gemini还能帮忙分析错误报告，以及生成集成有Gemini API代码的项目，可见Gemini已经深度融合进了Android Studio之中。详细的可以<a href="https://android-developers.googleblog.com/2024/05/google-io-2024-whats-new-in-android-development-tools.html">看一看官文档</a>。看着都挺美好 的，但其实最想知道的问题是，是否会对我们东方大国开放使用？</p>

<p>其他的都是一些常规的小的提升，如可穿待设备的不同模式下的预览，Compose的实时编辑以及Compose Glance（桌面小部件）预览， 以及Android Studio Profiler的改进等等。</p>

<h2>Android开发套件</h2>

<p>对于Android相关的开发套件，唯一提到的都是与<a href="https://juejin.cn/post/7367390293812035610">Jetpack Compose</a>相关的，可见谷歌对它的重视。新东西也都中规中矩，主要是在动画上面，如分享页过渡，可复用列表（Lazy list）元素的动画；文本控件支持HTML了；一个新的布局ContextualFlowRow，用以实现复杂的可复用流式布局，这个还是挺有用的；以及性能提升。详细内容可以<a href="https://android-developers.googleblog.com/2024/05/whats-new-in-jetpack-compose-at-io-24.html">看官方博客</a>。</p>

<p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjbUo5RnrBoOsutrYVGiLIWZ16yIsll5cxnaSo9Gm4mXwl29MA_fVpwM0wH_RhRrehS9kJRnRISkEVW3yoTkhyT0GUEWg8kGCByRD2Gf0FOIJj9dyLD6NJYtOt4l-Vd_FEkJVj4DRNeu_G5fzwU34Dhq_Gv3dKozTq3iAcOrcHvS4o2WDHGDchZC-zhZL8/s600/image7.gif" alt="" /></p>

<p>Jetpack Compose对于常规的UI来说已经没有问题，但是对于一些专业领域的UI还是无法胜任，比如像相机，视频和图像的预览和渲染还是无法在Compose中使用。好消息是，现在Google已经着手处理了，这次就基于<a href="https://developer.android.com/jetpack/androidx/releases/camera">CameraX</a>搞了一个<a href="https://developer.android.com/jetpack/androidx/releases/camera#camera_viewfinder_compose_version_10_2">camera-viewfinder-compose</a>，能够在Compose中显示相机预览。</p>

<p>再有就是<a href="https://www.jetbrains.com/kotlin-multiplatform/">Kotlin Multiplatform</a>，这个是Jetbrains在主要搞的东西，谷歌也加大了配合力度（First class support），比如已经把一些Jetpack中的库添加了对KMM的支持。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://juejin.cn/post/73687573358034289020">2024 Google I/O Android 相关内容汇总</a></li>
<li><a href="https://9to5google.com/2024/05/14/google-io-2024-developer-recap/">What’s new for developers at Google I/O 2024</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『亢龙有悔』]]></title>
    <link href="http://toughcoder.net/blog/2024/05/15/compose-made-easy/"/>
    <updated>2024-05-15T20:26:06+08:00</updated>
    <id>http://toughcoder.net/blog/2024/05/15/compose-made-easy</id>
    <content type="html"><![CDATA[<p><a href="https://developer.android.com/develop/ui/compose">Jetpack Compose</a>是新一代的声明式的UI开发框架，由Google在2019年推出，最初是作为Android的新式UI开发框架，但它本质是一个声明式UI开发框架，并不受制于底层的平台，现在的Compose已有跨平台开发能力，但Android上的UI开发仍是最主要的使用领域，深受Android开发者喜爱。计划将用一系列文章，并开辟专栏来学习Compose，此为开篇。</p>

<p><a href=""><img src="https://alexzh.com/content/images/2021/02/logo-1.65-1980-compressed-4.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>注意：最初是叫做Jetpack Compose，作为Jetpack套件中的一个，后来与Jetpack独立开来了，现在Compose发展成为一个独立的声明式的UI开发框架，与Jetpack中其他组件并不是同一个概念，也并不在Jetpack套件里面。所以现在更多的称为Compose，为了方便后续统一称为Compose。</p>

<h2>Hello, Compose!</h2>

<p>老规矩，先来个简单的『Hello, world!』，以快速上手体验：</p>

<p>首先，用Android Studio创建一个新的项目，选择『Phone and Tablet』，选择『Empty Activity』，然后Next。</p>

<p><img src="https://pic2.zhimg.com/80/v2-f1df667c79bf94aa44fe00bccdfbbb65_1440w.webp" alt="create project" /></p>

<p>在项目配置页面填入项目名字和包名等信息，其余的用默认就好。</p>

<p><img src="https://pic3.zhimg.com/80/v2-b76564a9cd826d2dfcc949105eb4bb5a_1440w.webp" alt="config project" /></p>

<p>等一会儿后，项目就创建好了，与常规的Android项目一样的，也有AndroidManifest，是项目运行时的主要配置，以及一个系统组件MainActivity作为入口。打开MainActivity.kt，可以发现里面已经默认用了Compose，并且有东西，我们稍改一下，改成下面的样子：</p>

<pre><code class="Kotlin">class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            HelloComposeTheme {
                // A surface container using the 'background' color from the theme
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    Greeting("Android with Compose!")
                }
            }
        }
    }
}

@Composable
fun Greeting(name: String, modifier: Modifier = Modifier) {
    Text(
        text = "Hello, $name",
        modifier = modifier
    )
}

@Preview(showBackground = true)
@Composable
fun GreetingPreview() {
    HelloComposeTheme {
        Greeting("Android")
    }
}
</code></pre>

<p>然后构建并运行项目，就能得到一个『Hello, Android with Compose!』：</p>

<p><img src="https://pic1.zhimg.com/80/v2-4325b9d9a0a3f1ebb8380dcdc7fe2bec_1440w.webp" height="480" width="320" alt="HelloCompose" /></p>

<p>样子略丑，我们来优化一下，修改Greeting函数：</p>

<pre><code class="Kotlin">@Composable
fun Greeting(name: String, modifier: Modifier = Modifier) {
    Box(modifier = Modifier.fillMaxSize()) {
        Text(
            text = "Hello, $name",
            modifier = modifier
                .padding(16.dp)
                .align(Alignment.Center),
            style = MaterialTheme.typography.headlineLarge,
            color = MaterialTheme.colorScheme.inverseSurface
        )
    }
}
</code></pre>

<p>这下好了一丢丢！</p>

<p><img src="https://pic4.zhimg.com/80/v2-efc8c9e62e38c02e6f18665d71862c97_1440w.webp" height="480" width="320" alt="HelloCompose v2" /></p>

<p>除了在手机或者模拟器运行应用以外，还可以直接用Android Studio进行预览（用&#64;Preview标记的函数才会被预览），不过这不算新功能，因为很久以前打开一个XML文件（如布局），也可以直接在AS里预览的：</p>

<p><img src="https://pic1.zhimg.com/80/v2-aa68d4eb84bf1bd130ca896c05371990_1440w.webp" alt="preview" /></p>

<p>好了，现在我们已经成功学会用Compose来撸安卓UI了。如果有时间还可以试试<a href="https://developer.android.com/develop/ui/compose/tutorial">官方的入门Demo</a>。</p>

<p>注意：不同版本的Android Studio可能会略不一样。详见下节『开发环境配置』。</p>

<h2>配置开发环境</h2>

<p>新一点的Android Studio如Giraffe，如果是新建的项目，默认就是用Compose了，不用再怎么搞（如果是上古时代的AS估计还是View的，建议直接升级AS吧都4202年了）。</p>

<p>如果是现有的项目，想要添加Compose支持，可以这样做，先给android的buildFeatures中添加compose为true，并指定kotlin compiler extension的版本，注意这个并不是kotlin的版本，跟它没关系：</p>

<pre><code class="Kotlin">android {
    buildFeatures {
        compose = true
    }

    composeOptions {
        kotlinCompilerExtensionVersion = "1.5.13"
    }
}
</code></pre>

<p>然后再配置一坨依赖：</p>

<pre><code class="Kotlin">dependencies {
    val composeBom = platform("androidx.compose:compose-bom:2024.05.00")
    implementation(composeBom)

    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.ui:ui-graphics")

    // Material Design 3
    implementation("androidx.compose.material3:material3")

    // Android Studio Preview support
    implementation("androidx.compose.ui:ui-tooling-preview")
    debugImplementation("androidx.compose.ui:ui-tooling")
}
</code></pre>

<p>为了方便管理Compose依赖的版本，谷歌搞了一个叫做『物料清单』（Bill of Materials BOM），简单来说就是把Compose所有library的版本放到一个叫做BOM的library中，我们只需要指定一个BOM，这样，就能指定一坨Compose libraries的版本。详细的内容以及困难解决可以<a href="https://developer.android.com/develop/ui/compose/setup#kotlin">参考官方文档</a>。</p>

<h2>理解Compose的基本原理</h2>

<p>从我们的『HelloCompose』中可以看出Compose的特点，它是纯代码，Compose就是一个坨函数声明，不用再撸XML了；它是声明式的，也就是说你只是告诉框架需要什么，期望的样子是什么；它是响应式的，也就是说拿到最新的数据和状态，然后用相应的UI元素进行展示。这与以往用XML写UI是完全不同的，用XML是命令式的，你要拿到View，设置具体的细节。</p>

<p>用Compose撸UI主要分为两部分，一是元素，如布局和具体的渲染元素如文字图片；另一个则是样式控制，所有元素都能接受一个Modifier对象来控制元素的样式，如大小，位置，偏移，对齐等等。会在后面的文章中对这些概念进行详细的讨论。</p>

<p>另外需要注意，Compose就是一坨函数，上面例子中看到的『setContent』，『HelloComposeTheme』，『Suface』，『 Greeting』，『GreetingPreview』，『Box』，『Text』都是函数，虽然它们不符合Kotlin的函数命令规范。这里面套娃式的结构如：</p>

<pre><code class="Kotlin">    setContent {
        HelloComposeTheme {
            // A surface container using the 'background' color from the theme
            Surface(
                modifier = Modifier.fillMaxSize(),
                color = MaterialTheme.colorScheme.background
            ) {
                 Greeting("Android with Compose!")
            }
       }
    }
</code></pre>

<p>是借助于尾部lambda实现的内部DSL，本质上也都是函数调用，视为函数调用就好了。感觉不熟悉的同学可以看看<a href="https://juejin.cn/post/7321550265610108979">前面的文章</a>以加深理解。</p>

<h2>为啥要使用Compose</h2>

<p>就Android开发来说明明已经有比较完善的View和XML来撸UI，为啥还要搞一个Compose呢？</p>

<p>首先，声明式编程范式是最新式的UI构建方式，较原始方式（View和XML）它更加接近于人的思维。开发者只需要告诉架构『我要什么』以及『该如何响应』就可以了，其他事情都交给框架。像Flutter， React， SwiftUI等都是声明式的。一旦我们熟悉了以后，就会发现声明式UI可以极大的提高开发效率，最重要的是它能提高可扩展性（Scalability）。</p>

<p>再有，Compose与各种最新的libraries粘合的特别好，像<a href="https://developer.android.com/jetpack">Jetpack</a>，<a href="https://m3.material.io/">MaterialDesign</a>等等，都可以直接在Compose中使用，非常的方便。</p>

<p>最后，最重要的原因是Google在大力的布道Compose，已经把Compose设置为默认的UI开发方式，作为<a href="https://developer.android.com/modern-android-development">MAD（Modern Android Development）</a>的一块拼盘，新推出的有关于UI的文章都是基于Compose的。并且Google还在不断大力开发Compose，推出新功能以及提升渲染性能。从前面的例子也可以看出，现在默认新建一个项目就是用的Compose，相反，如果想要弄一个只用View的项目，还比较麻烦，要去除一系列配置参数。</p>

<p>作为开发者，肯定要顺应潮流，迎头敢上（对的，是敢而不是赶）。</p>

<h2>迁移建议</h2>

<p>Compose虽然新式且好用，但我们在做迁移的时候要谨慎。对于新的技术（无论是新的编程语言，新的框架，还是新的编程范式）切忌不要一刀切或者搞大跃进。对于，纯新的功能，或者说纯新的项目，当然可以直接就用Compose来开发；但是对于现有的功能，暂时不要去动它，万不可上来就想着用Compose重写一遍。等到对Compose比较熟悉了，人力较富余时，以及现在功能仍会有新的较大的改动时才考虑去重写。对于比较成熟且稳定的功能，建议就不要去折腾它了，因为不会带来价值和收益。</p>

<p><a href="https://developer.android.com/develop/ui/compose/migrate">官方也有迁移建议</a>，可以看一看。</p>

<h2>优质教程与实例</h2>

<p>Google对Compose还是很上心的，写了<a href="https://developer.android.com/develop/ui/compose/documentation">大量的文档</a>，此外还有<a href="https://developer.android.com/courses/jetpack-compose/course">很多教程（CodeLabs）</a>，以及<a href="https://developer.android.com/samples">很多Demo app</a>。并且Compose作为MAD的一块拼盘，也融合进了MAD里面，特别是<a href="https://developer.android.com/develop/ui/compose/architecture">架构层面</a>的文章中用的都是Compose。</p>

<h2>未完，待续</h2>

<p>本文从快速上手的Demo开始，解释一些核心概念，并给出一些有用的资源链接。相信通过此文，能对Compose有一个很好的了解。后续会继续深入探讨各个话题，以练成降Compose十八掌！</p>
]]></content>
  </entry>
  
</feed>
