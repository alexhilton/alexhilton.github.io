<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2025-04-23T22:53:52+08:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Jetpack Compose的性能优化建议]]></title>
    <link href="https://alexhilton.github.io/blog/2025/04/22/performance-optimization-in-jetpack-compose/"/>
    <updated>2025-04-22T22:34:25+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/04/22/performance-optimization-in-jetpack-compose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Performance Optimization in Jetpack Compose」，原文链接<a href="https://carrion.dev/en/posts/performance-optimization-compose/">https://carrion.dev/en/posts/performance-optimization-compose/</a>，由Ignacio Carrión，发布于2025年4月8日。</p></blockquote>

<p><a href=""><img src="https://www.itmob.cn/upload/2023/01/banner-jetpack-compose-a452c3e8f1ad489a8560a4f0a9f88e07.jpg" title="auto auto" ></a></p>

<!-- more -->


<p><strong>译者按：</strong> Jetpack Compose是一个优秀的声明式UI框架，对开发者非常友好，可以高效率的撸各种UI页面和UI元素。但它仍然并不是很成熟，有些事情还做不了，而且渲染性能也略输于原生的View方式，毕竟它比原生的View多了一层组合树和渲染树。因此，在享受声明式UI带来的便捷的同时，就需要深入地了解其内部的工作机制，和学习一些高级技巧，以提升运行时的渲染性能。另外，需要 注意虽然这篇文章是针对for Android的Jetpack Compose，但大部分也适用于Compose Multiplatform。</p>

<p>性能优化对于在Jetpack Compose应用中提供流畅的用户体验至关重要。本文探讨了关键技术和最佳实践，以确保你的可组合函数高效且性能卓越。</p>

<h2>理解组合（Composition）和重组（ReComposition）</h2>

<p><strong>译注：</strong> 组合与重组是Compose中非常重要 的概念，如果不熟悉的同学可以复习一下之前的文章<a href="https://juejin.cn/post/7379437165486112805">降Compose十八掌之『潜龙勿用』| Thinking in Compose</a>和<a href="https://juejin.cn/post/7401358349877346338">降Compose十八掌之『损则有孚』| Lifecycle</a>。</p>

<p>Compose 性能的一个基本方面是了解合成和重组的工作原理：</p>

<h3>智能重组（Smart Recomposition）</h3>

<p>Compose 使用智能重组功能，仅更新界面中需要更改的部分。了解触发重组的原因以及如何最小化重组的影响范围对于性能优化至关重要。</p>

<pre><code class="Kotlin">@Composable
fun ExpensiveCalculation(numbers: List&lt;Int&gt;) {
    // 不好：每次重组都会执行昂贵的操作
    val average = numbers.takeIf { it.isNotEmpty() }
        ?.average()
        ?: 0.0

    // 优点：昂贵的操作被缓存，并且仅在输入发生变化时重新计算
    val cachedAverage = remember(numbers) {
        numbers.takeIf { it.isNotEmpty() }
            ?.average()
            ?: 0.0
    }

    Column {
        // 每次重组时都会重新计算
        Text("Current Average: ${"%.2f".format(average)}")

        // 这将使用缓存住的值
        Text("Cached Average: ${"%.2f".format(cachedAverage)}")
    }
}
</code></pre>

<h3>稳定类型（Stable types）和不可变性（Immutability）</h3>

<p>稳定的类型对于Compose的智能重组系统至关重要。当Compose能够保证其 equals() 方法与其属性一致，并且属性本身不会在不触发重组的情况下发生变化时，该类型即被视为稳定类型。</p>

<pre><code class="Kotlin">// 不好：类型不稳定 - 可变属性可能会在不通知Compose的情况下发生变化
data class UserState(
    var name: String, // 可变属性可以偷偷地改变
    var age: Int      // 而且更改不会触发重组
)

// 优点：稳定类型 - 不可变属性和显式稳定性
@Stable  // 告诉Compose此类型具有可预测的相等性
data class UserState(
    val name: String,  // 不可变属性
    val age: Int      // 如要更改需要创建新实例
)
</code></pre>

<p>使用稳定类型有以下几个好处：</p>

<ol>
<li>更高效的重组 - 当Compose确定数据未发生变化时，它可以跳过重组部分UI，换句话说可以减少很多不必要的重组，进而提高性能</li>
<li>可预测的行为 - 数据更改始终会触发正确的UI更新</li>
<li>线程安全（Thread safety） - 不可变数据可以安全地在协程之间共享</li>
</ol>


<p><strong>译注：</strong> 这里说的应该是可以在线程之间安全地共享，协程如果没有线程切换是不会有线程安全问题的。</p>

<h2>性能优化的关键点</h2>

<h3>1. 合理地使用 remember 和 derivedStateOf 进行状态（State）管理</h3>

<p>remember 和 derivedStateOf 函数在状态管理中起到不同的作用：</p>

<pre><code class="Kotlin">@Composable
fun UserProfile(user: User, items: List&lt;Item&gt;) {
    // 缺点：每次重新组合时都重新计算
    val filteredItems = items.filter { it.userId == user.id }

    // 好：使用记忆缓存计算
    val cachedItems = remember(items, user.id) {
        items.filter { it.userId == user.id }
    }

    // 更好的方式：使用 derivedStateOf 进行反应式计算
    val reactiveItems by remember(items) {
        derivedStateOf {
            items.filter { it.userId == user.id }
        }
    }

    // 当 items 发生变化时，reactiveItems 会自动更新
    // 并且仅在过滤结果发生变化时触发重组
    LazyColumn {
        itemsIndexed(
            items = reactiveItems,
            key = { _: Int, item: Item -&gt; item.id }
        ) { _: Int, item: Item -&gt;
            ItemRow(item)
        }
    }
}
</code></pre>

<p><strong>译注：</strong> 对于状态的管理，可以复习一下之前专门讲解副作用(Side effects)的文章<a href="https://juejin.cn/post/7405158681078104127">降Compose十八掌之『龙战于野』| Side Effects</a>。</p>

<h3>2. 合理地使用CompositionLocal</h3>

<p><strong>译注：</strong> 关于CompositionLocal的使用可以看前面写过的文章<a href="https://juejin.cn/post/7434543407636267071">用Compose中的CompositionLocal来暗渡陈仓</a>，下面的示例是想要说明，应该在合理的地方访问CompositionLocal里面的数据，因数对CompositionLocal的访问地方会被触发重组（<a href="https://juejin.cn/post/7401358349877346338">之前的文章有讲过</a>重组的触发是状态使用的地方，而不是定义的地方），如果在所有的地方都 直接访问CompositionLocal，特别是嵌套较深的地方也都 直接访问，那都会触发重组，但大部分其实是不必要的。像下样示例展示的那样，在一定的级别中访问CompositionLocal，然后它的内部嵌套调用直接复用数值，可以避免过度重组。</p>

<pre><code class="Kotlin">// 不好：每个子组件都访问 CompositionLocal
@Composable
fun DeepNestedContent() {
    val theme = LocalTheme.current  // 直接访问
    val strings = LocalStrings.current  // 多个 CompositionLocal 访问
    val dimensions = LocalDimensions.current

    Column {
        Text(
            text = strings.title,
            style = theme.textStyle,
            modifier = Modifier.padding(dimensions.padding)
        )
        // 具有重复 CompositionLocal 访问的更多嵌套内容
    }
}

// 好：提升 CompositionLocal的值以最小化查找
@Composable
fun ParentContent() {
    // 单独访问 CompositionLocal 值
    val theme = LocalTheme.current
    val strings = LocalStrings.current
    val dimensions = LocalDimensions.current

    DeepNestedContent(
        theme = theme,
        strings = strings,
        dimensions = dimensions
    )
}

@Composable
fun DeepNestedContent(
    theme: Theme,
    strings: Strings,
    dimensions: Dimensions
) {
    // 使用传递的参数而不是查找 CompositionLocal 值
    Column {
        Text(
            text = strings.title,
            style = theme.textStyle,
            modifier = Modifier.padding(dimensions.padding)
        )
        // 使用传递的参数进行更多嵌套内容
    }
}
</code></pre>

<h3>3. LazyList 优化技巧</h3>

<p>高效的列表渲染对于流畅的滚动性能至关重要。以下是针对 LazyList 组件的关键优化：</p>

<pre><code class="Kotlin">@Composable
fun &lt;T : Any&gt; OptimizedList(items: List&lt;T&gt;) {
    LazyColumn {
        itemsIndexed(
            items = items,
            // 稳定的key有助于Compose在更新过程中跟踪项目
            key = { _: Int, item: T -&gt; item.hashCode() }
        ) { _: Int, item: T -&gt;
            // 每个item的内容
        }
    }
}
</code></pre>

<p>LazyList 的关键优化点：</p>

<ol>
<li>提供稳定的键，帮助Compose在更新过程中跟踪项目</li>
<li>尽可能使用固定大小以避免重新测量</li>
<li>保持项目可组合项的轻量级</li>
<li>避免在项目内容中进行不必要的分配</li>
<li>记住要为每个项目缓存昂贵的计算</li>
</ol>


<h2>测量和监控性能</h2>

<h3>Layout Inspector和Composition Traces</h3>

<p>Android Studio 中的布局检查器是一款强大的Compose界面性能调试工具。它能够帮助你深入了解应用的视图层次结构、重组计数以及应用于每个可组合项的修饰符。</p>

<p>要将布局检查器与Compose结合使用，请执行以下操作：</p>

<ol>
<li>在调试模式下运行你的应用</li>
<li>在“正在运行的设备”窗口中，你将看到一个用于切换布局检查器的按钮</li>
<li>检查Compose层次结构：

<ul>
<li>查看组件树</li>
<li>检查重组计数</li>
<li>分析修饰符链</li>
<li>检查可组合项参数</li>
</ul>
</li>
</ol>


<p><img src="https://carrion.dev/images/kotlin/layout-inspector.png" alt="Layout Inspector" /></p>

<p>布局检查器中需要监控的关键指标：</p>

<ol>
<li>重组计数 - 数值较高表示存在潜在的优化机会</li>
<li>跳过计数 - 检查可组合项是否在应该跳过重组时跳过</li>
<li>修饰符链复杂度 - 较长的修饰符链可能会影响测量/布局性能</li>
</ol>


<h3>性能测试</h3>

<pre><code class="Kotlin">@Test
fun performanceTest() {
    benchmarkRule.measureRepeated(
        packageName = "com.example.app",
        metrics = listOf(FrameTimingMetric()),
        iterations = 5
    ) {
        composeTestRule.setContent {
            YourComposable()
        }
    }
}
</code></pre>

<h2>最佳实践总结</h2>

<ol>
<li>使用稳定类型(Stable types)和不可变数据结构(Immutable data structures)</li>
<li>使用remember提升高开销计算</li>
<li>在惰性列表(lazy list)中实现合适的键(key)</li>
<li>最小化重组范围</li>
<li>定期分析和测量性能</li>
</ol>


<p>遵循这些优化技巧将有助于确保你的Compose UI保持响应迅速且高效，从而为你的应用提供更好的用户体验。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Compose Multiplatform支持热重载(Hot Reload)了]]></title>
    <link href="https://alexhilton.github.io/blog/2025/04/12/compose-hot-reload/"/>
    <updated>2025-04-12T17:11:47+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/04/12/compose-hot-reload</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自Compose Hot Reload is Now Available，原文链接<a href="https://medium.com/@wisemuji/compose-hot-reload-is-now-available-3a9aee58b0fe">Compose Hot Reload is Now Available</a>，由<a href="https://medium.com/@wisemuji">Suhyeon Kim</a>，发布于2025年3月19日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FMBFWn5vJOuaM41zKE6aTg.jpeg" title="auto auto" ></a></p>

<!-- more -->


<p><strong>译注：</strong>  需要注意的是Google通过Android Studio(after Giraffe)里面的<a href="https://developer.android.com/develop/ui/compose/tooling/iterative-development">Live Edit特性</a>提供了对Android上面的Jetpack Compose的实时更新支持。但它仅支持Jetpack Compose (for Adnroid)，并不支持CMP，也即不支持JetBrains的Compose。也正因为如此JetBrains才会开发面向CMP的Hot Reload。</p>

<p>在Compose UI开发过程中，你是否经常需要构建运行？Compose 热重载现已在Maven Central中推出，可为Compose多平台（桌面）应用中的UI代码提供实时更新。我们无需重启应用即可立即查看UI代码的更改。</p>

<p>让我们来一探究竟！</p>

<h2>热重载(Hot Reload)是什么鬼？</h2>

<p>许多声明式UI框架都提供了类似概念，热重载，即可以在开发过程中提供对UI更改的近乎即时的反馈（尽管它们的名称不同！）。</p>

<p>例如隔壁的两家：</p>

<ul>
<li>Flutter热加载：<a href="https://docs.flutter.dev/tools/hot-reload">https://docs.flutter.dev/tools/hot-reload</a></li>
<li>React Native快速刷新：<a href="https://reactnative.dev/docs/fast-refresh">https://reactnative.dev/docs/fast-refresh</a></li>
</ul>


<p>热重载允许开发者实时查看代码更改，无需重启应用或重新编译整个项目。在大多数情况下，热重载会保留应用的状态，因此开发者可以继续与应用交互，而不会丢失进度或上下文。这可以帮助开发者快速演示代码更改对UI的影响，从而提高工作效率，而无需等待漫长的构建。</p>

<h2>Compose的热重载</h2>

<p>看一下官方的介绍<a href="https://github.com/JetBrains/compose-hot-reload">https://github.com/JetBrains/compose-hot-reload</a>：</p>

<blockquote><p>在Compose多平台应用中更改你的UI代码，并实时查看结果。
无需重启应用。</p></blockquote>

<p>目前，Compose Hot Reload 适用于针对桌面 JVM 的多平台项目（未来是否有可能扩展？我不确定。:D）。Compose Hot Reload 的最新版本是 v1.0.0-alpha02，于昨天（2025 年 3 月 17 日）发布。现在，开发者可以在Compose多平台应用中查看其UI代码的更改，而无需重启应用。这意味着开发者可以立即预览更改，而无需缓慢的构建和重启。</p>

<p><strong>译注：</strong> 现在（2025年4月9日）最新版本是 v1.0.0-alpha04，主要是Bugfix，目前开发中的版本是 v1.0.0-alpha05 。</p>

<h2>如何上手</h2>

<p>要开始使用Compose Hot Reload，请查看<a href="https://github.com/JetBrains/compose-hot-reload">Compose Hot Reload</a>的 GitHub 代码库。</p>

<p><strong>注意：</strong> 以下内容基于 v1.0.0-alpha02 编写。</p>

<h3>依赖要求</h3>

<ul>
<li>一个以桌面为目标的Compose Multiplatform 项目（参见<a href="https://github.com/JetBrains/compose-hot-reload#faq">其FAQ</a>）</li>
<li>Kotlin 2.1.20-Beta2 或更高版本</li>
</ul>


<p>对于 Android 应用，有一个小的解决方法：
首先，你需要从Jetpack Compose插件切换到Compose Multiplatform 插件，
然后添加一个单独的 Gradle 模块并配置桌面目标。</p>

<h3>将 Gradle 插件应用到你的项目中</h3>

<p>将 org.jetbrains.compose.hot-reload Gradle 插件添加到你的构建脚本：</p>

<pre><code class="Kotlin">plugins {
    kotlin("multiplatform") version "2.1.20-RC" // &lt;- Use Kotlin 2.1.20-RC or higher!
    kotlin("plugin.compose") version "2.1.20-RC" // &lt;- Use Compose Compiler Plugin 2.1.20-RC or higher!
    id("org.jetbrains.compose")
    id("org.jetbrains.compose.hot-reload") version "1.0.0-alpha02" // &lt;- add this additionally
}
</code></pre>

<h3>启用“OptimizeNonSkippingGroups”：</h3>

<p>将以下内容添加到你的 build.gradle.kts ：</p>

<pre><code class="Kotlin">import org.jetbrains.kotlin.compose.compiler.gradle.ComposeFeatureFlag
// ...
composeCompiler {
    featureFlags.add(ComposeFeatureFlag.OptimizeNonSkippingGroups)
}
</code></pre>

<h3>为UI热重载提供入口点</h3>

<p>在项目的桌面源代码集中，使用 DevelopmentEntryPoint 包装窗口内容。</p>

<pre><code class="Kotlin">import org.jetbrains.compose.reload.DevelopmentEntryPoint
// ...
fun main() {
    singleWindowApplication(...) {
        DevelopmentEntryPoint { // add this line
            App()
        }
    }
}
</code></pre>

<p>这就是我们需要折腾的全部内容。现在让我们看看它是如何工作的。</p>

<h2>Demo演示</h2>

<p>要了解Compose 热重载的实际效果，我们来看看我的示例项目<a href="https://github.com/wisemuji/compose-would-you-rather-game">“Would You Rather Game”</a>。这个项目是一个简单的 Compose 多平台桌面应用，用户可以在其中回答有趣的“Would You Rather”问题。Compose 热重载插件最近已实现。</p>

<p>你可以参考 Compose 热重载的setup提交：<a href="https://github.com/wisemuji/compose-would-you-rather-game/commit/937375cea9010733ee751dc2d464a0df21318cee">setup提交</a>。</p>

<p>如果你在项目上运行desktopRun，你会注意到桌面应用程序旁边会出现一个小的Compose图标。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1288/format:webp/1*TXn4jUzxwcSh5IfqRqFNkA.png" alt="HotReload Icon" /></p>

<p>这将触发 Compose Hot Reload Tooling 模式，如下所示：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*37gLudPijGvh3A-rKdK_kw.png" alt="HotReload Demo" /></p>

<h3>UI更改示例</h3>

<p>假设我们想要更改<a href="https://github.com/wisemuji/compose-would-you-rather-game/blob/4e9bfc7172c7145f95190fd383169bbcdc25856f/composeApp/src/commonMain/kotlin/ui/game/GameScreen.kt#L226">GameScreen.kt</a>中的动画。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*b4xJXpWH9oA5YohC1zsWng.gif" alt="Full Demo" /></p>

<p>看到没有！一旦我们保存文件，更改就会立即显示在正在运行的应用程序中。无需重启应用！</p>

<h2>热重载当前支持的场景</h2>

<p>目前，几乎所有代码更改都支持热重载（除了从类中删除超类型）。</p>

<p><a href="https://hashnode.com/@sellmair">Sebastian Sellmair 的视频和博客文章</a>通过多个演示展示了这些功能，并详细解释了重载的底层工作原理。</p>

<h2>局限性</h2>

<p>由于它仅支持基于 JVM 的桌面应用，因此目前尚不支持 Android 和其他平台。
此外，构建性能方面可能存在一些问题。在我的本地环境中，更改大约需要 3 到 5 秒，感觉比其他声明式UI框架中的热重载慢不少。估计它会在后面得到改善。</p>

<p>由于这是一个 Alpha 版本，因此无法保证稳定性。开发者应该预料到可能会出现一些潜在的错误和迁移挑战，正如 JetBrains 团队所指出的：“Alpha 版本意味着使用风险自负，迁移问题也需谨慎。我们打算将这个想法产品化，但尚未最终成型。” 由于该功能仍在积极开发中，因此我们应该在未来的版本中持续关注更新。</p>

<h2>提供反馈</h2>

<p>如果你遇到任何问题或有改进建议，你可以通过<a href="https://slack-chats.kotlinlang.org/t/27038699/with-compose-hot-reload-now-being-available-on-maven-central"> Kotlinlang Slack - Compose Hot Reload </a>分享你的想法。</p>

<blockquote><p>尤其欢迎提：</p>

<ul>
<li>设置时遇到的问题</li>
<li>重新加载特定代码段时遇到的问题</li>
<li>关于如何改进/功能请求的想法</li>
</ul>


<p>目前不太感兴趣的内容：</p>

<ul>
<li>构建性能：目前，“Gradle 重编译器”的速度将与你的项目速度一样快。强烈建议
启用 Gradles 配置缓存，并保持项目非常干净。其他“重编译器”也会有所帮助！（IntelliJ、Amper 等）</li>
</ul>
</blockquote>

<h2>总结</h2>

<p>我相信 Compose 中的 Hot Reload 是开发 Compose UI的一大变革。
它可以让开发人员在无需重启应用的情况下看到更改，从而加快UI开发速度，但它仍处于实验阶段。目前，它最适合个人或早期项目，你可以使用 alpha 版本进行开发。在你自己的 Compose Multiplatform 项目中试用它，体验即时UI反馈的好处！</p>

<p>我迫不及待地想看到即将到来的更新！XD</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://github.com/JetBrains/compose-hot-reload">https://github.com/JetBrains/compose-hot-reload</a></li>
<li><a href="https://blog.sellmair.io/say-hello-to-compose-hot-reload-firework">https://blog.sellmair.io/say-hello-to-compose-hot-reload-firework</a></li>
<li><a href="https://www.youtube.com/watch?v=8Z-Vuo3wTd0">Firework: Introducing Compose Hot Reload</a></li>
<li><a href="https://www.youtube.com/watch?v=I_FMnPaEBEA">How ‘Hot Reload’ is implemented for Compose</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实战：探索Jetpack Compose中的SearchBar]]></title>
    <link href="https://alexhilton.github.io/blog/2025/04/09/searchbar-in-jetpack-compose/"/>
    <updated>2025-04-09T22:40:46+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/04/09/searchbar-in-jetpack-compose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自Exploring Jetpack Compose: SearchBar，原文链接：<a href="https://joebirch.co/android/exploring-the-searchbar-composable/">https://joebirch.co/android/exploring-the-searchbar-composable/</a>，作者是Joe Birch。</p></blockquote>

<p>在应用内搜索内容是一项常见功能，事实上，你可以在设备上的大多数应用程序中发现此功能。在 Android 上，我们看到的此功能的常见 UI 组件是浮动搜索栏，放置在屏幕的显眼位置。在某些情况下，这还会向用户提供搜索建议，以简化搜索过程。Jetpack Compose Material3 软件包提供了对提供此功能的 SearchBar 可组合项的访问，在这篇博文中，我们将学习如何在我们自己的应用中使用它。</p>

<p><a href=""><img src="https://joebirch.co/wp-content/uploads/2025/03/Group.png" title="auto auto" ></a></p>

<!-- more -->


<p>SearchBar 可组合项允许我们显示一个浮动的搜索组件，该组件展开后会显示可选的推荐。如上所述，这是我们在许多应用中看到的常见模式，此可组合项提供了开箱即用的解决方案。SearchBar 可组合项提供了足够的自定义功能来控制组件的外观和感觉，同时使用基于插槽(slot)的方法让我们提供输入字段以供使用。</p>

<pre><code class="Kotlin">@Composable
fun SearchBar(
    inputField: @Composable () -&gt; Unit,
    expanded: Boolean,
    onExpandedChange: (Boolean) -&gt; Unit,
    modifier: Modifier = Modifier,
    shape: Shape = SearchBarDefaults.inputFieldShape,
    colors: SearchBarColors = SearchBarDefaults.colors(),
    tonalElevation: Dp = SearchBarDefaults.TonalElevation,
    shadowElevation: Dp = SearchBarDefaults.ShadowElevation,
    windowInsets: WindowInsets = SearchBarDefaults.windowInsets,
    content: @Composable ColumnScope.() -&gt; Unit,
)
</code></pre>

<p>该组件为我们处理了大部分内部工作——其中两个关键部分需要我们自己提供。</p>

<ul>
<li>inputField – 这是表示内容输入的搜索字段的输入可组合项</li>
<li>content – 这是搜索栏展开时用于显示推荐的内容区域</li>
</ul>


<p>除了这些字段之外，还有一组其他属性用于确定 SearchBar 的当前状态。例如，当搜索栏处于展开状态时，可组合项的内容将显示在输入字段下方。为了能够管理这一点，我们需要为可组合项提供一些参数，用于管理此状态。首先，expanded 参数用于描述 SearchBar 是否处于展开状态（这将决定是否显示内容区域），以及 onExpandedChange 参数，用于为实现提供展开状态的更新值（然后可用于反映我们自己的状态实现）。</p>

<pre><code class="Kotlin">var expanded by remember { mutableStateOf(false) }

SearchBar(
    modifier = Modifier.fillMaxWidth(),
    expanded = expanded,
    onExpandedChange = {
        expanded = it
    }
)
</code></pre>

<p>除了管理这种展开状态外，我们还需要提供用于 SearchBar 输入区域的 inputField。除了遵循可组合项的基于插槽的方法之外，这还允许可组合项遵循状态提升的概念，使我们能够完全管理 SearchBar 输入字段的状态概念。</p>

<pre><code class="Kotlin">var expanded by remember { mutableStateOf(false) }
var query by remember { mutableStateOf&lt;String?&gt;(null) }

SearchBar(
    modifier = Modifier.fillMaxWidth(),
    expanded = expanded,
    onExpandedChange = {
        expanded = it
    },
    inputField = {
        // ...
    }
)
</code></pre>

<p>为了简化此操作，SearchBarDefaults 类为我们提供了对 InputField 可组合项的访问 - 这使我们能够访问专门为 SearchBar 实现的可组合项。不需要使用此特定可组合项，但它是专门为基于搜索的输入字段提供的便利可组合项。此可组合项采用一些关键参数，用于将其配置为在 SearchBar 中使用：</p>

<ul>
<li>expanded 和 onExpandedChange - 用于管理字段的展开状态</li>
<li>query 和 onQueryChange - 用于管理字段中显示的查询的状态</li>
</ul>


<p>除了这些核心属性外，你还会注意到对标准字段参数（如占位符、leadingIcon 和 trailingIcon）的支持。除了用于提供信息之外，我们还可以在下面的示例中看到我如何使用 trailingIcon 允许 SearchBar 在单击取消按钮时恢复到折叠状态。</p>

<pre><code class="Kotlin">SearchBarDefaults.InputField(
    onSearch = { expanded = false },
    expanded = expanded,
    onExpandedChange = { expanded = it },
    placeholder = { Text("What are you looking for?") },
    leadingIcon = { Icon(Icons.Default.Search, contentDescription = null) },
    trailingIcon = {
        if (expanded) {
            IconButton(onClick = {
                expanded = false
            }) {
                Icon(Icons.Default.Close, contentDescription = null)
            }
        }
    },
    query = query ?: "",
    onQueryChange = {
        query = it
    }
)
</code></pre>

<p>然后可以将此 InputField 可组合项的实现插入到 SearchBar 可组合项的 inputField 参数中。</p>

<pre><code class="Kotlin">var expanded by remember { mutableStateOf(false) }
var query by remember { mutableStateOf&lt;String?&gt;(null) }

SearchBar(
    modifier = Modifier.fillMaxWidth(),
    expanded = expanded,
    onExpandedChange = {
        expanded = it
    },
    inputField = {
        SearchBarDefaults.InputField(
            onSearch = { expanded = false },
            expanded = expanded,
            onExpandedChange = { expanded = it },
            placeholder = { Text("What are you looking for?") },
            leadingIcon = { Icon(Icons.Default.Search, contentDescription = null) },
            trailingIcon = {
                if (expanded) {
                    IconButton(onClick = {
                        expanded = false
                    }) {
                        Icon(Icons.Default.Close, contentDescription = null)
                    }
                }
            },
            query = query ?: "",
            onQueryChange = {
                query = it
            }
        )
    }
)
</code></pre>

<p>此时，我们将能够组合 SearchBar 并看到在我们的 UI 中显示的浮动组件。</p>

<p><img src="https://joebirch.co/wp-content/uploads/2025/03/sea.png" alt="SearchBar" /></p>

<p>此时我们剩下要实现的就是 SearchBar 的内容，这是 SearchBar 处于展开状态时显示的内容。此参数利用了 ColumnScope，因此此处提供的任何可组合项都将垂直堆叠。此内容区域的预期形式是用户可以选择的推荐列表，因此我们将继续编写几个 ListItem 可组合项，每个可组合项都用于向用户显示搜索推荐。当点击其中任何一项时，查询将更新为选定值，并且 SearchBar 的展开状态将重置。</p>

<pre><code class="Kotlin">var expanded by remember { mutableStateOf(false) }
var query by remember { mutableStateOf&lt;String?&gt;(null) }

SearchBar(
    ...
) {
    listOf("Result 1", "Result 2", "Result 3", "Result 4").forEach { text -&gt;
        ListItem(
            headlineContent = { Text(text) },
            colors = ListItemDefaults.colors(containerColor = Color.Transparent),
            modifier = Modifier.clickable {
                query = text
                expanded = false
            }.fillMaxWidth().padding(horizontal = 16.dp, vertical = 8.dp)
        )
    }
}
</code></pre>

<p>有了此功能，我们现在就能够看到在浮动搜索栏下方显示的推荐。</p>

<p><img src="https://joebirch.co/wp-content/uploads/2025/03/recs.png" alt="Recommendations" /></p>

<p>有了上述内容，我们就可以实现一个浮动搜索栏，向用户显示搜索建议。使用 Material3 SearchBar 可组合项，实现在这两种不同状态之间转换的可组合项非常容易。也许你已经在应用中使用了 SearchBar，或者一直在寻找类似的功能，但无论如何，我期待看到更多应用通过 Jetpack Compose 中更广泛的组件支持来节省时间！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实战：在Compose中优雅地实现提示]]></title>
    <link href="https://alexhilton.github.io/blog/2025/03/28/hints-in-compose/"/>
    <updated>2025-03-28T22:05:00+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/03/28/hints-in-compose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自<a href="https://proandroiddev.com/hints-in-compose-10b6470acc58">Hints in Compose</a>，原文由<a href="https://medium.com/@vitoksmile">Viktor Mykhailiv</a>发布于2025年2月13日，文章内容巨详细，TL;DR;。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0jBirMqQV-aXKXw5gekEkQ.jpeg" title="auto auto" ></a></p>

<!-- more -->


<p>有时我们的应用需要突出显示某些 UI 组件，例如在首次登录（首次使用）时，或者当我们添加新内容（“新功能”）时。</p>

<p>在本文中，我将指导如何构建自定义解决方案来显示提示/工具提示，指向 Compose（Compose Multiplatform 和 Jetpack Compose）中的特定 UI 元素。</p>

<h2>布局层次</h2>

<p>要突出显示 UI 元素，首先我们应该了解“提示”(Hints)的主要概念。
假设我们有一个带有 TopBar、BottomNavigation 和主要操作按钮的应用程序。我们想要突出显示 TopBar 的操作、主要按钮和 BottomNavigation 中的一个项目。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7K0zoXqZM0ajYYZARn6I5w.png" alt="Layout hierarchy" /></p>

<p>对于我们的“提示”，我们需要绘制一个暗淡的背景（也是为了拦截触摸事件），计算突出显示的 UI 元素的位置，剪掉（屏蔽）我们的元素形状以免变暗，最后绘制一个提示（例如带有背景的文本）。</p>

<h2>1. 暗淡的背景</h2>

<p>要在所有内容之上绘制一个暗淡的背景作为覆盖或弹出窗口，我们可以：</p>

<h3>a. 使用自定义可组合项包装我们应用（根组件）的所有内容（例如带有 Modifier.background 的 Box）</h3>

<pre><code class="Kotlin">@Composable
fun AppContent() {
   HintOverlay {
      MaterialTheme {
         Scaffold {
            // 我的应用内容
         }
      }
   }
}
</code></pre>

<h3>b. 使用对话框</h3>

<p>通过使用对话框，我们可以在所有内容之上显示一个覆盖层（例如，在 Android 上，对话框显示在自己的窗口中）。
使用对话框时，Compose Multiplatform 中的 scrimColor 会出现问题。我们无法从 Compose 通用目标配置 scrimColor ，但每个目标（Android 除外）都为 scrimColor 提供了一个实际值。作为一种可能的解决方案，我们可以创建一个例外类来提供对话框属性并为每个目标提供实际实现。</p>

<h3>c. 使用 Popup</h3>

<p>Popup 在这里看起来更好，因为它默认不绘制 scrimColor，并且覆盖层显示在所有内容之上。</p>

<p>我会采用第三种方法，不强制手动使用 HintOverlay。</p>

<p>我还想为覆盖层背景添加 Brush 支持，而不仅仅是 Color 。</p>

<pre><code class="Kotlin">val LocalHintOverlayColor = staticCompositionLocalOf&lt;Color&gt; { Color(0x44000000) }

val LocalHintOverlayBrush = staticCompositionLocalOf&lt;Brush?&gt; { null }

@Composable
fun HintOverlay() {
    Popup {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .overlayBackground()
        ) {
            Text(
                modifier = Modifier.align(Alignment.Center),
                text = "Draw hints here",
                color = Color.White,
            )
        }
    }
}

/**
 * 从 [LocalHintOverlayBrush] 或 [LocalHintOverlayColor] 设置 `background`。
 */
private fun Modifier.overlayBackground(): Modifier = composed {
    LocalHintOverlayBrush.current?.let { background(it) }
        ?: background(LocalHintOverlayColor.current)
}
</code></pre>

<p>我可以使用CompositionLocalProvider 设置 Brush 来覆盖覆盖的背景。</p>

<pre><code class="Kotlin">CompositionLocalProvider(
    LocalHintOverlayBrush provides Brush.linearGradient(
        listOf(
            Color.Red.copy(alpha = 0.5f),
            Color.Blue.copy(alpha = 0.5f),
        )
    ),
) {
    HintOverlay()
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KrHuSNZT0zE-Eddz1GBA2A.png" alt="Dimmed background" /></p>

<h2>2. 计算锚点坐标</h2>

<p>要获取 Compose 中 UI 元素的坐标，我们可以使用OnGloballyPositionedModifier ，当内容的全局位置可能发生变化时，会使用布局的最终​​ LayoutCoordinates 调用该方法。</p>

<p>使用示例：</p>

<pre><code class="Kotlin">Column(
    Modifier.onGloballyPositioned { coordinates -&gt;
        // 这将是Column的大小。
        coordinates.size
        // Column相对于应用程序窗口的位置。
        coordinates.positionInWindow()
        // Column相对于 Compose 根的位置。
        coordinates.positionInRoot()
        // 这些将是提供给布局的对齐线（此处的Column为空）。
        coordinates.providedAlignmentLines
        // 这将是与 Column 的父级相对应的 LayoutCoordinates 实例。
        coordinates.parentLayoutCoordinates
    }
) {
    Box(Modifier.size(20.dp).background(Color.Green))
    Box(Modifier.size(20.dp).background(Color.Blue))
}
</code></pre>

<p>对于我们的提示，我们需要创建一个状态来保存锚点的坐标和大小，并引入一个修改器来更新状态：</p>

<pre><code class="Kotlin">@Stable
class HintAnchorState internal constructor() {

    internal var size: IntSize by mutableStateOf(IntSize.Zero)

    internal var offset: Offset by mutableStateOf(Offset.Zero)
}

@Composable
fun rememberHintAnchorState(): HintAnchorState {
    return remember { HintAnchorState() }
}

fun Modifier.hintAnchor(state: HintAnchorState): Modifier {
    return onGloballyPositioned {
        state.size = it.size
        state.offset = it.positionInWindow()
    }
}
</code></pre>

<p>因此，我们只需订阅所需 UI 元素的大小和坐标变化即可更新锚点的状态。
现在我们需要将此 hintAnchor 修饰符应用于我们的内容：</p>

<pre><code class="Kotlin">val topAppBarActionHintAnchor = rememberHintAnchorState()
val actionHintAnchor = rememberHintAnchorState()
val bottomNavigationHintAnchor = rememberHintAnchorState()

IconButton(
    modifier = Modifier
        .hintAnchor(topAppBarActionHintAnchor),
    onClick = {},
)

Button(
    modifier = Modifier
        .hintAnchor(actionHintAnchor)
        .padding(4.dp),
    onClick = {},
) {
    Text("Action")
}

BottomNavigationItem(
    modifier = Modifier
        .hintAnchor(topAppBarActionHintAnchor),
    //... 传入其他需要的参数
)
</code></pre>

<blockquote><p><strong>注意：</strong> 修饰符顺序在 Compose 中始终很重要，我们在 hintAnchor 后设置 4.dp，以便在此按钮周围留出额外空间（锚点的尺寸将比实际按钮的尺寸大 4.dp）。</p></blockquote>

<p>HintOverlay 可组合项需要进行一些更改才能使用 HintAnchorState为此锚点绘制提示。</p>

<pre><code class="Kotlin">@Composable
fun HintOverlay(
    anchors: () -&gt; List&lt;HintAnchorState&gt;,
) {
    Box(
        modifier = Modifier
            .fillMaxSize()
            .overlayBackground(anchors)
    )
}

/**
 * 从 [LocalHintOverlayBrush] 或 [LocalHintOverlayColor] 设置“background”。
 */
private fun Modifier.overlayBackground(
    anchors: () -&gt; List&lt;HintAnchorState&gt;,
): Modifier = composed {
    val backgroundBrush = LocalHintOverlayBrush.current
    val backgroundColor = LocalHintOverlayColor.current

    drawWithCache {
        onDrawWithContent {
            if (backgroundBrush != null) {
                drawRect(backgroundBrush)
            } else {
                drawRect(backgroundColor)
            }

            anchors().forEach { anchor -&gt;
                drawRect(
                    color = Color.Red,
                    topLeft = anchor.offset,
                    size = anchor.size.toSize(),
                    style = Stroke(width = 5f),
                )
            }

            drawContent()
        }
    }
}
</code></pre>

<p>现在我们只需在锚点周围画一个红色矩形：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EqvV4AHsimwvwZxajIgtXg.png" alt="Anchors" /></p>

<p>但如果我们在移动设备上运行，我们会在 Android 上得到错误的数字：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2wennrPOIcKArOK4MuayAQ.png" alt="With Window Insets" /></p>

<p>该问题与 WindowInsets 有关。让我们减去这些 insets 来修复它：</p>

<pre><code class="Kotlin">fun Modifier.hintAnchor(state: HintAnchorState): Modifier = composed {
    val statusBarInsets = WindowInsets.statusBars.getTop(LocalDensity.current).toFloat()

    onGloballyPositioned {
        state.size = it.size
        state.offset = it.positionInWindow()
            // 修复 Android 上的 WindowInsets
            .minus(Offset(x = 0f, y = statusBarInsets))
    }
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LlrCLPAEgpk7q--X7i3UsA.png" alt="Fixed window insets" /></p>

<h2>3. 剪辑出锚点的形状</h2>

<p>要剪辑形状，我们将使用 Path 和 PathOperation 。修改 hintAnchor Modifier 以接受 Shape ，它将用于在锚点周围设置所需的形状。</p>

<pre><code class="Kotlin">fun Modifier.hintAnchor(
    state: HintAnchorState,
    shape: Shape = RectangleShape,
): Modifier {
    state.shape = shape
    //..onGloballyPositioned
}

@Stable
class HintAnchorState internal constructor() {

    //...其他的状态放这里

    internal var shape: Shape by mutableStateOf(RectangleShape)
}
</code></pre>

<p>根据提供的形状，我们可以创建一个轮廓，用于将锚点的形状从背景中剪掉：</p>

<pre><code class="Kotlin">internal fun Modifier.overlayBackground(
    anchors: () -&gt; List&lt;HintAnchorState&gt;,
): Modifier = composed {
    val backgroundBrush = LocalHintOverlayBrush.current
    val backgroundColor = LocalHintOverlayColor.current
    val layoutDirection = LocalLayoutDirection.current
    val density = LocalDensity.current

    drawWithCache {
        // 准备背景路径
        val path = Path().apply {
            lineTo(size.width, 0f)
            lineTo(size.width, size.height)
            lineTo(0f, size.height)
            lineTo(0f, 0f)
            close()
        }

        anchors().forEach { anchor -&gt;
            // 为锚点准备路径
            val anchorPath = Path()
            anchorPath.addOutline(
                anchor.shape.createOutline(
                    size = anchor.size.toSize(),
                    layoutDirection = layoutDirection,
                    density = density,
                )
            )
            anchorPath.translate(anchor.offset)
            anchorPath.close()

            // 裁剪掉锚点
            path.op(path, anchorPath, PathOperation.Xor)
        }

        onDrawWithContent {
            // 我们不仅仅绘制路径，而不是像以前一样绘制矩形
            if (backgroundBrush != null) {
                drawPath(path, backgroundBrush)
            } else {
                drawPath(path, backgroundColor)
            }

            drawContent()
        }
    }
}
</code></pre>

<p>让我们传递 CircleShape 和 RoundedCornerShape 来看看提示现在是什么样子：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i2dWMv3Wa9at-fzGiKm8KQ.png" alt="Clip" /></p>

<p>此时，我们知道如何绘制背景覆盖层、计算锚点的位置以及如何剪裁背景。</p>

<h2>4. 绘制提示</h2>

<p>在实际绘制之前，我们应该定义提示需要呈现哪些信息。</p>

<p>为了不强制只提供文本，我们采用slot方法。通过定义slot，我们允许使用任何所需的composables。</p>

<p>我将介绍一个新的类 Hint 来保存我们的Composable内容：</p>

<pre><code class="Kotlin">@Stable
class Hint internal constructor() {

    internal var content: @Composable () -&gt; Unit by mutableStateOf({})
}

@Composable
fun rememberHint(content: @Composable () -&gt; Unit): Hint {
    return remember {
        Hint().also { it.content = content }
    }
}
</code></pre>

<p>并将此 Hint 添加为 HintAnchorState 的一部分：</p>

<pre><code class="Kotlin">@Stable
class HintAnchorState internal constructor(
    internal val hint: Hint,
) {
    //...其他的状态放这里
}

@Composable
fun rememberHintAnchorState(hint: Hint): HintAnchorState {
    return remember(hint) {
        HintAnchorState(hint)
    }
}
</code></pre>

<p>在 HintOverlay 内部，我们可以采用最简单的解决方案 — BoxWithConstraints ：</p>

<pre><code class="Kotlin">@Composable
fun HintOverlay(
    anchors: () -&gt; List&lt;HintAnchorState&gt;,
) {
    //...
    BoxWithConstraints(
        modifier = Modifier
            .fillMaxSize()
            .overlayBackground(anchors)
    ) {
        anchors().forEach { anchor -&gt;
            Box(
                modifier = Modifier
                    .graphicsLayer {
                        translationX = anchor.offset.x
                        translationY = anchor.offset.y + anchor.size.height
                    },
            ) {
                anchor.hint.content()
            }
        }
    }
}
</code></pre>

<p>修改应用程序内容：</p>

<pre><code class="Kotlin">val topAppBarHint = rememberHint {
    OutlinedButton(onClick = {}) { Text("Hint for TopAppBar") }
}
val topAppBarActionHintAnchor = rememberHintAnchorState(topAppBarHint)

val actionHint = rememberHint {
    Text("Hint for Action")
}
val actionHintAnchor = rememberHintAnchorState(actionHint)

val bottomNavigationHint = rememberHint {
    Row(
        verticalAlignment = Alignment.CenterVertically,
    ) {
        Spacer(Modifier.size(32.dp).background(Color.Magenta, CircleShape))
        Spacer(Modifier.size(8.dp))
        Text("Hint for BottomNavigation")
    }
}
val bottomNavigationHintAnchor = rememberHintAnchorState(bottomNavigationHint)
</code></pre>

<p>结果如下：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mMenE2fp2jph6YUBlxX4pA.png" alt="Hint for action" /></p>

<p>让我们引入一个应用程序特定的代码来绘制提示背景。</p>

<pre><code class="Kotlin">@Composable
fun rememberHintContainer(content: @Composable () -&gt; Unit): Hint {
    return rememberHint {
        Box(
            modifier = Modifier
                .padding(top = 8.dp)
                .background(Color.Yellow, shape = RoundedCornerShape(16.dp))
                .padding(16.dp),
        ) {
            CompositionLocalProvider(
                LocalTextStyle provides TextStyle(
                    color = Color.Black,
                    fontSize = 12.sp,
                    fontWeight = FontWeight.Light,
                ),
            ) {
                content()
            }
        }
    }
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xn8pxlU_nUQvywbtqVwUtw.png" alt="Hint2" /></p>

<p>我们遇到了 2 个问题：</p>

<ol>
<li>水平对齐，提示应与其锚点居中对齐。</li>
<li>BottomNavigation 的提示超出了屏幕范围。</li>
</ol>


<p>让我们改用自定义布局并修复这些问题。</p>

<p>要测量和布局多个可组合项，请使用 Layout。此composable允许我们手动测量和布局子项。所有更高级别的布局（如 Column 和 Row）都是使用 Layout 实现的。</p>

<pre><code class="Kotlin">@Composable
internal fun HintsContainer(
    modifier: Modifier,
    anchors: () -&gt; List&lt;HintAnchorState&gt;,
) {
    val anchors = anchors()

    Layout(
        modifier = modifier
            .overlayBackground(anchors),
        content = {
            anchors.forEach { it.hint.content() }
        },
    ) { measurables, constraints -&gt;
        // 测量每一个提示
        val placeables = measurables.map { measurable -&gt;
            measurable.measure(
                constraints.copy(minWidth = 0, minHeight = 0)
            )
        }

        // 将布局尺寸设置得尽可能大
        layout(constraints.maxWidth, constraints.maxHeight) {
            // 将每个提示相对于其锚点放置
            placeables.forEachIndexed { index, placeable -&gt;
                val anchor = anchors[index]

                // 将此提示居中对齐
                val x = (anchor.offset.x.toInt() - (placeable.width - anchor.size.width) / 2)
                    // 修复超出屏幕的坐标
                    .coerceAtLeast(0)
                    .coerceAtMost(constraints.maxWidth - placeable.width)

                // 把这个提示放在它的锚点下面
                var y = (anchor.offset.y.toInt() + anchor.size.height)
                    // 如果超出屏幕，则修复 y 坐标
                    .coerceAtMost(constraints.maxHeight - placeable.height)
                if (y &lt; anchor.offset.y + anchor.size.height) {
                    // 提示与锚点重叠，请将此提示放在其锚点上方
                    y = anchor.offset.y.toInt() - placeable.height
                }

                placeable.placeRelative(x = x, y = y)
            }
        }
    }
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*syuJkuAd-_BgiYfFP8bKgQ.png" alt="Hint3" /></p>

<p>因为我们允许传递任何可组合项作为提示，所以调用者可以完全控制提示的外观，例如，我们可以只使用 Text ，或者使用包含许多子项的复杂 Row 。</p>

<h2>5. 如何控制提示？</h2>

<p>我们静态地添加了提示以将其显示在屏幕上。但真正产品应用程序并非如此。让我们引入 HintController 来控制何时显示提示。</p>

<pre><code class="Kotlin">@Stable
class HintController internal constructor() {

    internal var hint by mutableStateOf&lt;HintAnchorState?&gt;(null)

    fun show(hint: HintAnchorState) {
        this.hint = hint
    }
}

@Composable
fun rememberHintController(): HintController {
    val controller = remember { HintController() }

    controller.hint?.let { hint -&gt;
        HintOverlay(anchor = hint)
    }

    return controller
}
</code></pre>

<p>修改应用程序内容，以便在我们点击锚点时显示提示：</p>

<pre><code class="Kotlin">val hintController = rememberHintController()

IconButton(
    modifier = Modifier
        .hintAnchor(topAppBarActionHintAnchor, CircleShape),
    onClick = {
        hintController.show(topAppBarActionHintAnchor)
    },
)

BottomNavigationItem(
    modifier = Modifier
        .hintAnchor(
            bottomNavigationHintAnchor,
            shape = RoundedCornerShape(50f),
        ),
    onClick = {
        hintController.show(bottomNavigationHintAnchor)
    },
)

Button(
    modifier = Modifier
        .hintAnchor(actionHintAnchor, RoundedCornerShape(16.dp))
        .padding(4.dp),
    onClick = {
        hintController.show(actionHintAnchor)
    },
)
</code></pre>

<blockquote><p>注意：我们不再需要显示的 HintOverlay ，它现在变得内置了。</p></blockquote>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jIOTXOSnHVeL_jjyEx1gdg.png" alt="Control" /></p>

<p>现在我们可以逐一显示提示，但还有两个部分缺失：如何关闭提示，以及如何覆盖覆盖颜色。</p>

<p>对提示控制器进行更改以允许传递覆盖颜色：</p>

<pre><code class="Kotlin">@Composable
fun rememberHintController(overlay: Brush): HintController {
    return rememberHintController(overlay = LocalHintOverlayBrush provides overlay)
}

@Composable
fun rememberHintController(overlay: Color = HintOverlayColorDefault): HintController {
    return rememberHintController(overlay = LocalHintOverlayColor provides overlay)
}

@Composable
private fun rememberHintController(overlay: ProvidedValue&lt;*&gt;): HintController {
    val controller = remember { HintController() }

    controller.hint?.let { hint -&gt;
        CompositionLocalProvider(overlay) {
            HintOverlay(anchor = hint)
        }
    }

    return controller
}
</code></pre>

<p>为了消除我们的提示，让我们引入以下变化：</p>

<pre><code class="Kotlin">@Stable
class HintController internal constructor() {

    internal var hint by mutableStateOf&lt;HintAnchorState?&gt;(null)

    fun show(hint: HintAnchorState) {
        this.hint = hint
    }

    fun dismiss() {
        hint = null
    }
}
</code></pre>

<p>我们使用 Popup 作为覆盖层的容器，如果用户点击 Android 上的返回按钮(BACK)，Popup 就会被关闭。</p>

<pre><code class="Kotlin">@Composable
internal fun HintOverlay(
    anchor: HintAnchorState,
    onDismiss: () -&gt; Unit,
) {
    Popup(
        onDismissRequest = onDismiss,
        // 设置可聚焦以处理按压back事件
        properties = remember { PopupProperties(focusable = true) },
    ) {
        //...在这里画出我们的提示
    }
}

@Composable
internal fun HintsContainer(
    modifier: Modifier,
    anchor: HintAnchorState,
    onDismiss: () -&gt; Unit,
) {
    Layout(
        modifier = modifier
            .overlayBackground(anchor)
            .clickable(
                interactionSource = null,
                // 禁用ripple
                indication = null,
                onClick = onDismiss,
            )
    )
}
</code></pre>

<p>结果演示视频 <a href="https://youtu.be/eo49PKlhO5Y">https://youtu.be/eo49PKlhO5Y</a></p>

<p>现在，HintController 允许我们按时间显示一个提示，但如果我们想按顺序显示多个提示，则没有实际的队列。</p>

<p>可以扩展 HintController 并添加暂停修饰符以知道提示的显示时间（例如，在显示提示后立即执行某项操作）。</p>

<pre><code class="Kotlin">@Stable
class HintController internal constructor() {

    private var queue = mutableStateListOf&lt;HintAnchorState&gt;()

    internal val hint: HintAnchorState? get() = queue.firstOrNull()

    private val pendingRequests = mutableMapOf&lt;HintAnchorState, Continuation&lt;Unit&gt;&gt;()

    suspend fun show(hint: HintAnchorState) {
        suspendCoroutine { continuation -&gt;
            pendingRequests[hint] = continuation
            queue.add(hint)
        }
    }

    suspend fun show(vararg hint: HintAnchorState) {
        show(hint.toList())
    }

    suspend fun show(hints: List&lt;HintAnchorState&gt;) {
        suspendCoroutine { continuation -&gt;
            pendingRequests[hints.last()] = continuation
            queue.addAll(hints)
        }
    }

    internal fun onDismissed(hint: HintAnchorState) {
        pendingRequests[hint]?.let { continuation -&gt;
            continuation.resume(Unit)
            pendingRequests.remove(hint)
        }
        queue.remove(hint)
    }

    fun dismiss() {
        pendingRequests.values
            .forEach { continuation -&gt;
                continuation.resumeWithException(CancellationException("Hint was dismissed"))
            }
        pendingRequests.clear()
        queue.clear()
    }
}
</code></pre>

<p>现在为了在应用程序内部显示提示，我们需要一个 CoroutineScope ：</p>

<pre><code class="Kotlin">val coroutineScope = rememberCoroutineScope()
val hintController = rememberHintController()

// 现在我们可以从提示本身中忽略所有待处理的提示
val topAppBarHint = rememberHintContainer {
    OutlinedButton(
        onClick = {
            hintController.dismiss()
        }
    ) { Text("Hint for TopAppBar") }
}

// 显示 1 条提示
BottomNavigationItem(
    onClick = {
        coroutineScope.launch {
            hintController.show(bottomNavigationHintAnchor)
            scaffoldState.snackbarHostState.showSnackbar("One hint was shown")
        }
    },
)

// 连续显示多个提示
Button(
    onClick = {
        coroutineScope.launch {
            hintController.show(
                topAppBarActionHintAnchor,
                actionHintAnchor,
                bottomNavigationHintAnchor,
            )
            scaffoldState.snackbarHostState.showSnackbar("Many hints were shown")
        }
    },
)
</code></pre>

<blockquote><p><strong>注意：</strong> 如果我们通过调用 hintController.dismiss() 来关闭提示，则 hintController.show 之后的代码将不会被调用。</p></blockquote>

<pre><code class="Kotlin">coroutineScope.launch {
    hintController.show(topAppBarActionHintAnchor)
    // 如果通过调用 hintController.dismiss 关闭了之前的提示，则不会显示 Snackbar
    scaffoldState.snackbarHostState.showSnackbar("One hint was shown")
}
</code></pre>

<p>最终结果如这个视频演示 <a href="https://youtu.be/tyZUNJLEVxQ">https://youtu.be/tyZUNJLEVxQ</a>：我们可以显示单个提示，也可以显示提示列表。</p>

<p>由于该项目使用 Compose Multiplatform，我们可以针对不同的目标运行该应用程序：</p>

<ul>
<li>Android结果演示 <a href="https://youtu.be/BVBCipnbIUc">https://youtu.be/BVBCipnbIUc</a></li>
<li>iOS结果演示 <a href="https://youtu.be/Z1uasddgqwo">https://youtu.be/Z1uasddgqwo</a></li>
</ul>


<h2>总结</h2>

<p>Compose 和 Kotlin Multiplatform 是一个强大的组合，它允许我们使用 Kotlin 来实现 UI 和业务逻辑。CMP 库仅与Jetpack Compose Android 项目完全兼容。</p>

<p>可以在 GitHub 上查看我的repo：<a href="https://github.com/vitoksmile/ComposeHints">https://github.com/vitoksmile/ComposeHints</a>。</p>

<p>感谢你的阅读，期待在 GitHub 上获得你的Star :)。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实战：在Compose中绘制睡眠时间线]]></title>
    <link href="https://alexhilton.github.io/blog/2025/03/26/draw-sleep-timeline-graph-in-compose/"/>
    <updated>2025-03-26T21:41:40+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/03/26/draw-sleep-timeline-graph-in-compose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自<a href="https://proandroiddev.com/sleep-timeline-graph-in-compose-15c99f9a4af0">Draw sleep timeline graph in Compose</a>，原文由<a href="https://medium.com/@vitoksmile">Viktor Mykhailiv</a>发布于2025年1月31日。</p></blockquote>

<p><strong>译者按：</strong> 我们在前面的<a href="https://juejin.cn/column/7367555191338467337">降Compose十八掌</a>系列中讲解过在Compose自定义绘制的方法，可以先温习一下<a href="https://juejin.cn/post/7381826917086920742">上一篇文章</a>。这篇文章是提升自定义绘制技巧的一个非常好的实战例子。</p>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OUAsgvNoNx9VpSk9Eyqgzg.jpeg" title="auto auto" ></a></p>

<!-- more -->


<p>当内置组件不能完全满足我们的应用需求时，自定义绘图非常有用。本文提供了创建自定义睡眠时间线图表的指南，类似于你在<a href="https://play.google.com/store/apps/details?id=com.fitbit.FitbitMobile">Fitbit 应用</a>中找到的图表。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cA9uPgAG29Gu2AhajArq9w.jpeg" alt="Screenshots from Fitbit Android app" /></p>

<h2>在 Compose 中如何绘图？</h2>

<p>要开始在 Compose 中绘图，我们可以使用绘图Modifier或 Canvas可组合函数，这为我们提供了 DrawScope — 一种声明式、无状态的API，用于绘制形状和路径，而无需消费者维护底层状态。DrawScope实现还提供了尺寸信息，并且变幻是相对于本地平移完成的。</p>

<blockquote><p><strong>注意：</strong> Jetpack Compose（仅限 Android）和 Compose Multiplatform（桌面、Android、iOS、Web）具有类似的绘图 API。下面的屏幕截图是在桌面（macOS）上制作的，但所有平台上的结果都是相同的（查看最后一张屏幕截图）。</p></blockquote>

<pre><code class="Kotlin">Canvas(modifier = Modifier.fillMaxSize()) {
    rotate(degrees = 45F) {
        drawRect(
            color = Color.Gray,
            topLeft = Offset(x = size.width / 3F, y = size.height / 3F),
            size = size / 3F
        )
    }
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_qkChFEn25kC_cfgiRXgKg.png" alt="Compose中的自定义绘制" /></p>

<h2>啥是睡眠时间表？</h2>

<p>我们可以在 Health Connect 中读取或写入睡眠数据。睡眠数据显示为会话，可分为以下睡眠阶段：</p>

<ul>
<li>清醒：用户在睡眠周期内清醒。</li>
<li>浅睡眠：用户处于浅睡眠周期。</li>
<li>深睡眠：用户处于深睡眠周期。</li>
<li>REM：用户处于 REM 睡眠周期。</li>
</ul>


<p>这些值表示用户在一定时间范围内经历的睡眠类型。SleepSessionRecord 数据类型包含两部分：</p>

<ol>
<li>整个睡眠过程，涵盖整个睡眠时间。</li>
<li>睡眠过程中的各个阶段，例如浅睡眠或深睡眠。</li>
</ol>


<pre><code class="Kotlin">val record = remember {
    SleepSessionRecord(
        startTime = Instant.parse("2025-01-28T21:10:10Z"),
        endTime = Instant.parse("2025-01-29T07:32:13Z"),
        startZoneOffset = UtcOffset(hours = 2),
        endZoneOffset = UtcOffset(hours = 2),
        stages = listOf(
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-28T21:10:10Z"),
                endTime = Instant.parse("2025-01-28T23:15:13Z"),
                type = SleepSessionStageType.Light,
            ),
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-28T23:15:13Z"),
                endTime = Instant.parse("2025-01-29T01:56:32Z"),
                type = SleepSessionStageType.Deep,
            ),
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-29T01:56:13Z"),
                endTime = Instant.parse("2025-01-29T03:16:22Z"),
                type = SleepSessionStageType.Light,
            ),
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-29T03:16:22Z"),
                endTime = Instant.parse("2025-01-29T04:32:13Z"),
                type = SleepSessionStageType.REM,
            ),
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-29T04:32:13Z"),
                endTime = Instant.parse("2025-01-29T05:12:56Z"),
                type = SleepSessionStageType.Deep,
            ),
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-29T05:12:56Z"),
                endTime = Instant.parse("2025-01-29T07:32:13Z"),
                type = SleepSessionStageType.Light,
            ),
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-28T22:11:56Z"),
                endTime = Instant.parse("2025-01-28T22:17:13Z"),
                type = SleepSessionStageType.Awake,
            ),
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-28T22:39:56Z"),
                endTime = Instant.parse("2025-01-28T22:51:13Z"),
                type = SleepSessionStageType.Awake,
            ),
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-29T04:47:56Z"),
                endTime = Instant.parse("2025-01-29T04:54:13Z"),
                type = SleepSessionStageType.Awake,
            ),
        ),
    )
}
</code></pre>

<h2>需要一点数学计算</h2>

<p>在睡眠期间，我们可以在不同时刻多次处于同一阶段。我们需要计算相对于睡眠的起点和终点。</p>

<p>要在 Compose 中绘制矩形，我们需要 topOffset 和 size。</p>

<p><img src="" alt="Math" /></p>

<pre><code class="Kotlin">private fun calculate(
    canvasSize: Size,
    recordStartTime: Instant,
    recordEndTime: Instant,
    stages: List&lt;SleepSessionRecord.Stage&gt;,
): List&lt;SleepStageDrawPoint&gt; {
    val totalDuration = (recordEndTime - recordStartTime).inWholeSeconds.toFloat()
        .coerceAtLeast(1f)

    return stages.map { stage -&gt;
        val stageOffset =
            (stage.startTime - recordStartTime).inWholeSeconds / totalDuration
        val stageDuration =
            (stage.endTime - stage.startTime).inWholeSeconds.toFloat() / totalDuration

        SleepStageDrawPoint(
            topLeft = Offset(x = canvasSize.width * stageOffset, y = 0f),
            size = canvasSize.copy(width = canvasSize.width * stageDuration),
        )
    }
}
</code></pre>

<h2>绘制</h2>

<p>让我们构建自定义 Canvas 来绘制睡眠过程的一个阶段，例如深度睡眠。</p>

<pre><code class="Kotlin">@Composable
fun SleepSessionCanvas(
    modifier: Modifier,
    record: SleepSessionRecord,
) {
    Spacer(
        modifier = modifier.drawWithCache {
            val points = calculate(
                canvasSize = size,
                recordStartTime = record.startTime,
                recordEndTime = record.endTime,
                stages = record.stages.filter { it.type == SleepSessionStageType.Deep },
            )

            onDrawWithContent {
                // 画背景
                drawRoundRect(
                    color = Color.LightGray,
                    topLeft = Offset(x = 0f, y = size.height / 4f),
                    size = size.copy(height = size.height / 2f),
                    cornerRadius = CornerRadius(size.height / 2f),
                )

                // 绘制阶段点
                points.forEach { point -&gt;
                    drawRect(
                        topLeft = point.topLeft,
                        size = point.size,
                        color = Color(0xFF673AB7),
                    )
                }
            }
        }
    )
}
</code></pre>

<p>如果我们使用之前定义的睡眠会话运行项目，我们将看到 3 个矩形：1 个灰色矩形表示背景，2 个紫色矩形表示深度睡眠阶段。</p>

<pre><code class="Kotlin">SleepSessionCanvas(
    modifier = Modifier
        .fillMaxWidth()
        .height(320.dp)
        .padding(16.dp),
    record = record,
)
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ANITvvaUEuuwwcACzY21qA.png" alt="深度睡眠阶段" /></p>

<p>为了绘制睡眠过程的所有阶段（清醒、快速眼动、浅睡眠和深睡眠），我们需要进行一些调整，将每个阶段类型垂直绘制为列组件，办法是逐行绘制并对下一行应用一些偏移量（offset）。</p>

<pre><code class="Kotlin">@Composable
fun SleepSessionCanvas(
    modifier: Modifier,
    record: SleepSessionRecord,
    stageHeight: Dp = 48.dp,
    stagesSpacing: Dp = 16.dp,
) {
    val colors = remember {
        mapOf(
            SleepSessionStageType.Awake to Color(0xFFFF9800),
            SleepSessionStageType.Light to Color(0xFF2196F3),
            SleepSessionStageType.Deep to Color(0xFF673AB7),
            SleepSessionStageType.REM to Color(0xFF795548),
        )
    }

    val stageHeightPx = with(LocalDensity.current) { stageHeight.toPx() }
    val stagesSpacingPx = with(LocalDensity.current) { stagesSpacing.toPx() }

    Spacer(
        modifier = modifier
            .requiredHeight(stageHeight * colors.size + stagesSpacing * (colors.size - 1))
            .drawWithCache {
                val stages = listOf(
                    SleepSessionStageType.Awake,
                    SleepSessionStageType.REM,
                    SleepSessionStageType.Light,
                    SleepSessionStageType.Deep,
                ).map { type -&gt;
                    type to calculate(
                        canvasSize = size.copy(height = stageHeightPx),
                        recordStartTime = record.startTime,
                        recordEndTime = record.endTime,
                        stages = record.stages.filter { it.type == type },
                    )
                }

                onDrawWithContent {
                    var offset = 0f
                    stages.forEach { (type, points) -&gt;
                        translate(top = offset) {
                            // 画背景
                            drawRoundRect(
                                color = Color.LightGray,
                                topLeft = Offset(x = 0f, y = stageHeightPx / 4),
                                size = size.copy(height = stageHeightPx / 2),
                                cornerRadius = CornerRadius(stageHeightPx / 2),
                            )

                            // 绘制阶段点
                            points.forEach { point -&gt;
                                drawRect(
                                    topLeft = point.topLeft,
                                    size = point.size,
                                    color = colors.getValue(type),
                                )
                            }
                        }
                        offset += stageHeightPx + stagesSpacingPx
                    }
                }
            }
    )
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iXIS4tbsvx5AhTtRqlWi7A.png" alt="最终的图形" /></p>

<h3>添加文本</h3>

<p>要在 Compose 中绘制文本，我们通常可以使用 Text 可组合项。但是，在我们的示例中，我们处于 DrawScope 中，我们可以使用 DrawScope.drawText()方法。</p>

<p>绘制文本与其他绘制命令略有不同。通常，我们为绘制命令提供绘制形状/图像的大小（宽度和高度）。对于文本，有几个参数可以控制渲染文本的大小，例如字体大小、字体、连字符和字母间距。我们需要使用 TextMeasurer 来获取文本的测量大小，具体取决于上述因素。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QB1QvINWUWMlpRoPSzrcUQ.png" alt="Desktop效果" /></p>

<p><img src="https://miro.medium.com/v2/resize:fit:2000/format:webp/1*U_LBREiTciw2F3ghYiHqCw.jpeg" alt="Android和iOS效果" /></p>

<p>请到我的Github repo中查找完整示例代码：<a href="https://github.com/vitoksmile/Sleep-timeline-graph">https://github.com/vitoksmile/Sleep-timeline-graph</a>。</p>
]]></content>
  </entry>
  
</feed>
