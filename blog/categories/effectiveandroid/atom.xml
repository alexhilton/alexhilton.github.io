<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2022-01-14T23:21:06+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[玩转安卓运行速度优化]]></title>
    <link href="http://toughcoder.net/blog/2022/01/14/android-cpu-optimization-made-easy/"/>
    <updated>2022-01-14T23:14:55+08:00</updated>
    <id>http://toughcoder.net/blog/2022/01/14/android-cpu-optimization-made-easy</id>
    <content type="html"><![CDATA[<p>早在许多年以前写过<a href="http://toughcoder.net/blog/2015/09/11/android-performance-profiling-made-easy/">一篇安卓性能优化文章</a>，时过境迁，很多事情都有了变化，所以再专门针对程序运行速度和渲染的优化，这两方面非常直接的影响应用程序的操作流畅度，也可以称作流畅度优化方法，但更为专业的方式就是CPU优化，因为就是要提高代码的运行速度。</p>

<p><a href=""><img src="https://bs-uploads.toptal.io/blackfish-uploads/uploaded_file/file/192945/image-1582543505866-a62a10ab903703bc995fcaab8ccd0bd0.png" title="auto auto" ></a></p>

<!-- more -->


<h2>需要优化的地方</h2>

<p>总的来说，就是应用程序运行要快，大体可以分为三块：</p>

<h3>应用启动要快</h3>

<p>从用户点击了桌面的图标到用户能完整见到页面，这个过程要快。其实也不是快，而是没有能从用户感知得到的卡，或者黑屏或者白屏。</p>

<h3>渲染要快</h3>

<p>也就是说View的渲染要快，无明显的Jank，也即卡顿和丢帧。</p>

<h3>操作要流畅</h3>

<p>主要是针对动画，滑动，转场的时候要流畅，也并不一定就是要真的快，而是说从用户感知的角度来看没有明显的卡顿和丢帧。</p>

<h3>业务逻辑要快</h3>

<p>也就是说要快速的完成你的业务逻辑，这个其实没有办法一概而论，取决 于具体的业务逻辑和实际的使用场景，比如网络不好的时候肯定啥都慢啊。</p>

<p>我们常说的性能优化，一般重点是在启动，渲染和操作流畅度上面下功夫，因为这些东西的优化方法更为通用一些，用户感知也更明显一些。也将是我们后面要讨论的重点内容。而至于像业务逻辑，每个具体的应用程序都不一样，所以没有办法一概而论，而常规的一些小的优化技巧也不会起决定性使用。比如说I/O优化方法，缓存的使用，以及像内存优化等等，确实能帮助你的业务逻辑。但如果业务逻辑就是特别复杂，或者代码写的很差劲，明明一个网络请求就能搞定的事儿，非要弄四五个请求，那你再怎么优化细节，比如把每个请求速度都优化到最好，I/O优化到最好，也是没有多大提升的。</p>

<h2>运行速度分析方法</h2>

<p>前面提到的启动优化，渲染优化和操作流畅度优化，其实都是针对CPU的优化，也即代码执行的优化，只不过重点分析那三个场景而已。</p>

<p>具体的分析方法主要就有两方面，一是用Profiler抓取trace，另外就是可以在代码中加入打点数据。</p>

<p>可以先行用代码代码打点的方式进行粗略的量化，比如说看onCreate执行了多久，看onResume执行了多久，这有两方面好处，一是可以粗略的定位问题，二是方便监控，比如你优化前与优化后的对比，能知道到底是否真的有提升。</p>

<p>精细化分析的方法就是抓trace，然后看具体哪里耗时了，具体使用方法可参后面的罗列的资源都相当详细，就不重复了。</p>

<p>需要注意的就是分析trace时除了用<a href="https://developer.android.com/studio/profile/android-profiler">Profiler</a>以外，还可以用<a href="https://ui.perfetto.dev/#!/">Perfecto</a>，这个更为强大。</p>

<h2>优化方法</h2>

<p>具体的优化方法，就没有银弹了，你做的事情特别多，代码特别复杂，逻辑特别多复杂，优化起来难度自然大。</p>

<p>核心的原则就是少，少做事，特别是主线程，能lazy则lazy，能异步则异步，涉及I/O时，要多用BufferedStream，巧用缓存，buffer尽可能要是8k大小（8192）。View tree要尽可能精简和扁平，某此特殊条件才会显示的页面就用ViewStub先占着等等。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://juejin.cn/post/6950608825942868004">Android 性能优化总结</a></li>
<li><a href="https://developer.android.com/studio/profile/cpu-profiler">Inspect CPU activity with CPU Profiler</a></li>
<li><a href="https://developer.android.com/topic/performance/tracing">Overview of system tracing</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/27331842">手把手教你使用Systrace（一）</a></li>
<li><a href="https://source.android.google.cn/devices/tech/debug/systrace">Understanding Systrace</a></li>
<li><a href="https://developer.android.com/studio/profile/measuring-performance">Overview of measuring app performance</a></li>
<li><a href="https://developer.android.com/studio/profile/benchmarking-overview">Benchmark your app</a></li>
<li><a href="https://blog.csdn.net/u011578734/article/details/109497064">性能分析工具Systrace的使用详解</a></li>
<li><a href="https://juejin.cn/post/6844903912395243533">Android Systrace 使用方法</a></li>
<li><a href="https://juejin.cn/post/6844903734263152653">Android性能优化之CPU Profiler</a></li>
<li><a href="https://www.jianshu.com/p/38fbf61c48c5">CPU Profiler 使用指南</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让你不再惧怕内存优化]]></title>
    <link href="http://toughcoder.net/blog/2022/01/13/android-app-memory-optimization-made-easy/"/>
    <updated>2022-01-13T23:37:36+08:00</updated>
    <id>http://toughcoder.net/blog/2022/01/13/android-app-memory-optimization-made-easy</id>
    <content type="html"><![CDATA[<p>之前曾经写过一篇关于<a href="http://toughcoder.net/blog/2015/09/11/android-performance-profiling-made-easy/">如何做性能优化的文章</a>，现在针对内存这一专项再做精细化的讨论。对于安卓应用开发来说，内存究竟会遇到什么样的问题，有什么方法可以用来测试和分析，以及有什么样的策略可以去实践优化，今天就来好好聊聊这个话题。</p>

<p><a href=""><img src="https://blog.singsys.com/wp-content/uploads/2017/09/memoryLeak.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>缘起</h2>

<p>现代计算机是基于冯*诺依曼架构的，计算机的软件是运行在内存之中的，进程（也即运行中的程序）会耗费一定的内存，才能够正常执行。
在软件开发的中世纪，C和C++盛行的时代，是由软件开发人员（下称猿）自己管理内存，也就是说猿自己申请内存，并处理申请不到内存的情况，并在使用完成后自己负责释放内存，这无疑会加大程序开发难度，产生一些难以调试的问题，如内存越界或者内存踩踏。到了近现代，自动内存管理成为主流，研发人员不再用自己去手动管理内存了，尽管用，可劲儿造，由GC（也即是Garbage Collector内存回收器）来善后。</p>

<p>这极大的解放了研发人员的双手，可以让他们把更多的精力放在接收产品经理的需求上面了，三天一小需求，一周一大需求，产品迭代速度相当快，业务发展迅速，老板相当高兴啊，这干掉BAT指日可待，赶英超美就在明天，IPO触手可及。然而，现实是极其骨感的。</p>

<h2>内存问题会引发什么问题</h2>

<p>对于安卓 应用程序来说，内存优化很重要，因为Java VM本身就是比较耗资源的，当应用复杂到一定程度的时候，就会出现由内存使用不当造成的问题。如，测试同学反馈说应用越用越卡，经常crash，用户也反馈说应用越来越不好用了。老板把老猿叫进办公室一顿骂，然后老板让老猿尽快来解决一下问题。</p>

<p>老猿只得把需求放一边，花时间看一看这些问题，然后说凭我多年经验来看，这怕是内存出了问题。</p>

<p>前面提过，现代编程语言一般都有GC，帮助研发人员管理内存。但由于各种原因，还是会出现内存相关的问题。</p>

<p>特别是对于安卓猿来说，实现应用的编程语言是Java（准确说是JVM，Java和Kotlin 以及像Scala都是基于JVM的编程语言），天生支持GC，导致很多人对内存管理知之甚少。当应用程序复杂到一定程度，当源码庞大到一定的量级时，性能问题，特别是内存性能问题便随之而来。</p>

<p>具体可能是内存出现问题的场景有：</p>

<ol>
<li>OOM导致的crash。OOM，也即OutOfMemoryError，可能发生在任何地方，当Heap中可用内存不足时，便可能会遇到此类crash</li>
<li>应用程序越用越慢，出现黑屏或者白屏。</li>
<li>UI操作出现卡顿，不流畅。造成UI卡，不流畅的原因很多，当排除了其他原因时，就是内存问题了</li>
<li>应用程序莫名闪退</li>
</ol>


<h2>内存问题的具体类型及其原因</h2>

<p>要想做好内存优化，则必须先弄懂内存问题的根本原因，然后再对内存问题进行归类，最后是通过技术手段来解决。</p>

<h3>内存问题的根本原因</h3>

<p>安卓应用程序是由Java构建的，而Java是支持GC的编程语言，所以安卓猿是不需要自己手动的去做内存管理的，只管不停的创建对象即可，Java虚拟机（JVM）会帮助我们管理内存，当有不用的对象时会自动被GC。</p>

<p>但是Java应用程序（当然也包括安卓）还是会遇到内存问题，主要是两类，一类是内存不合理使用，如内存使用过多，频繁创建大量对象，内存碎片等等；二是内存泄露。很多人会把二者混为一谈，网络上绝大多数文章一谈性能优化，一谈内存优化，必然说到内存泄露，但其实并不严谨。内存泄露确实是最常见的内存优化内容，也确实是内存使用不合理的最常见问题，但内存问题并不局限于内存泄露。</p>

<h3>内存使用不合理</h3>

<p>主要分为三个方面：</p>

<ol>
<li>浪费内存，简单来理解就是用一个人住着一千平米的大平层</li>
<li>大量创建小对象，产生碎片，内存碎片会造成JVM中的内存管理效率变低，当后面申请大块内存的时候效率就变差，它需要把小对象（碎片）进行转移压缩，以腾出更大的空间给大的对象使用。简单理解，这个时候JVM的效率就会变差，你的应用程序性能变差，甚至可能引起卡顿。</li>
<li>频繁创建对象，特别是较大的对象，造成内存抖动，也即应用程序使用的内存忽多忽少，会频繁的触发GC，从而影响JVM的运行效率。</li>
</ol>


<h3>内存泄露</h3>

<p>JVM是支持自动GC的，也就是说JVM帮助你管理内存，当有不再使用的对象时，会被JVM自动回收，此称之为GC（Garbage Collection）。但如果对象长期处于『使用』状态，并且超出了它本应该存的周期，无法被及时GC，这就会造成泄露。一般来说，这也没啥影响，但是如果泄露的对象太多，或者泄露的时间够长，就会把系统配额Java Heap空间耗尽，应用程序便会因没有内存创建对象而OOM，就会crash。即使没有crash，因为剩余空间较少，会频繁触发GC，从而导致应用程序卡顿严重。</p>

<p>内存泄露的根本原因是<strong>对象的生命周期错乱</strong>，对象存活了超过了其本该的生命周期，或者简言之，一个本该是较短的生命周期的对象被一个更长生命周期的对象所引用着，就会导致它本该生命周期结束时无法被GC，便产生了泄露。</p>

<p>这是要重点关注对象的生命周期，只有管理好了对象的生命周期，才能彻底的解决内存泄露问题。</p>

<h3>安卓应用中的生命周期</h3>

<h4>短生命周期的对象</h4>

<p>安卓应用程序里面，有一些是短生命周期的，或者说有明显生命周期，且不是由研发人猿自己控制的，如框架层控制的那一坨东西。</p>

<ul>
<li>Activity</li>
<li>Fragment</li>
<li>View</li>
</ul>


<p>特别是Activity，它也是内存泄露的头号对象，90%的内存泄露都是Activity对象。这货完全由系统框架控制，并且有明显的生命周期，而且还有重建实例的情况（涉及状态恢复时），所以它的生命周期其实相当短暂，并且它跟进程和主线程没有任何关系，Activity退出 了（走了onDestroy）进程仍还在，主线程也仍还在。而，又因为它是应用程序的第1级入口，应用程序所有的对象，以及GUI所有的东西，全部都由Activity直接或者间接持有，换句话说，Activity泄露了，你整个应用程序的对象也基本上全泄露了。</p>

<h4>长生命周期对象</h4>

<p>这里所谓的长生命周期，是指它们的生命周期是与进程绑定的，除非进程退出，或者明显的执行一些退出，否则一直随进程而存在：</p>

<ul>
<li>Looper，或者说消息队列，这玩意儿除非主动quit，否则一直存在。主线程的Looper与进程同在，自己创建的Looper要手动退出才算终结。</li>
<li>被static修饰的成员变量，这东西的生命周期是跟进程一样的</li>
<li>单例，单例必须由static来修饰，所以与进程生命周期是一样的，进程在，则单例在</li>
<li>线程池，或者一个长时间运行的thread，除非主动去shutdown</li>
<li>RxJava的Schedulers，这玩意跟looper一样，都是长时间运行的消息队列，且与进程绑定的</li>
<li>系统框架，手机还在开机系统框架就在运行，所以它的生命周期远远长于某一个应用程序</li>
<li>Application和ApplicationContext，这东西与进程生命周期是一样的，相当于单例了</li>
</ul>


<h4>业务逻辑中的生命周期</h4>

<p>业务逻辑就纯属于应用程序的本身逻辑了，无法一概而论，但一般来说，主页面的生命周期肯定是长于某个子页面的。那么子页面在其退出后，理论上它的绝大多数对象应该要被回收。</p>

<h2>如何发现内存问题</h2>

<p>生活中不是缺少美，而是缺少发现。</p>

<p>对于内存优化，第一步就是要通过各种测试手段发现问题。最理想的情况是建立一种监控手段，这样最能保住革命果实，以及非常及时的发现问题。</p>

<p>这里指的是一般性的粗略手段来发现你的应用有内存问题了，可能需要优化了。并且这些测试方法最好能做成定期监控，这样一旦内存性能有回撤时，能尽快发现。</p>

<h3>『队长，我们暴露了』</h3>

<p>很多时候都是问题主动找上门来了。</p>

<h4>前方有雷区</h4>

<p>很不幸，你的应用程序中弹身亡（crash了），还是OOM。这是Java语言中的一个运行时的错误，可能在创建任何对象时发生，但一般来说创建比较大的对象时，这里的大是指对内存需求大，如图片，或者大块数组时，更容易发生。</p>

<p>当你的应用程序出现了OOM的时候，就是一个特别明显的信号，告诉你要重视内存优化了。</p>

<h4>遇到终结者了，是lowmemorykiller</h4>

<p>有时候，没有明显的错误，但是应用却闪退了，特别是在后台，或者跳到其他应用页面时。</p>

<p>这个会比较隐蔽，通常会引发其他表象的问题。最明显的问题就是，当跳转到其他页面，再返回时，发现原来的页面状态不存在了，比如你的应用要访问一个URL，跳转到了网页浏览器，但从浏览器返回时，要么你的应用不在了，要么你的应用的原先状态不在了。这其中的原因就是当你的应用不在前台了，就被系统回收了，其中一个占大头的原因就是占用内存太多，被系统的lmk（lowmemorykiller）干掉了。</p>

<p>因为系统要保证整个设备的正常运转，所以会把占用内存太多的先杀掉，以释放内存。</p>

<p>当你的应用频繁的遇到被lowmemory killer干掉时，也是一个明显的信号，要重视内存优化了。</p>

<h4>读懂系统GC日志</h4>

<p>有些时候不像前面那样严重，但是查看logcat日志时，能发现大量的GC日志，就像这样的</p>

<pre><code>259857:01-08 20:00:17.836 10083 26337 26347 I test.test: NativeAlloc concurrent copying GC freed 141174(6852KB) AllocSpace objects, 29(12MB) LOS objects, 49% free, 24MB/48MB, paused 180us total 308.126ms
279178:01-08 20:00:19.618 10083 26337 26347 I test.test: Background young concurrent copying GC freed 469755(20MB) AllocSpace objects, 40(3608KB) LOS objects, 41% free, 28MB/48MB, paused 396us total 124.817ms
</code></pre>

<p>这是系统在进行GC，通常来说这没有什么问题。但如果在短时间内，比如某个页面，点了某个按扭后大量出现此类日志，也是一个明显的信号，告诉你要重视内存优化了。</p>

<h3>主动出击，以攻为守</h3>

<p>作为一个优秀的猿，不能坐着等问题上来，要能主动的去创造问题。每当完成一个需求后，或者写了一大坨代码以后，就需要主动的去查看一下内存方面是否有需要优化的地方。我们可以通过如下测试方法，来看内存是否有问题，是否需要做优化。重点就是看应用程序在一定时间内，使用的内存是否一直在增长， 有没有抖动，并且在GC后，或者退出 后是否仍不回落。</p>

<h4>meminfo</h4>

<p>具命令是adb shell dumpsys meminfo <package>，这个命令还是比较常见的，网上有很多资料可以用，可以看后面罗列的参考文章中来详细了解它的具体用法以及各个字段的意义，这里就重复了。</p>

<ul>
<li><a href="https://developer.android.com/studio/command-line/dumpsys">dumpsys</a></li>
<li><a href="https://blog.csdn.net/feelabclihu/article/details/105534175">dumpsys meminfo 的原理和应用</a></li>
<li><a href="https://www.cnblogs.com/helloTerry1987/p/13109971.html">adb shell dumpsys meminfo 详解</a></li>
<li><a href="https://www.jianshu.com/p/37539308ff32">dumpsys meminfo 含义</a></li>
</ul>


<p>需要关注一下重点，就是，可以重点看Java Heap一栏的数据变化，这是Java层的占用内存情况。另外就是每次运行meminfo其实会对进程产生影响。所以，这个命令可以用来粗维度的监控，查看一些信息，做一些定性的分析。</p>

<p>它最大的优点是方便，且只要是进程都可以查看，不用有源码。</p>

<h4>Android Studio的Memory Profiler</h4>

<p>在远古时代安卓SDK中会有DDMS，里面是一套调试工具，但现在都集成到Android Studio的Profiler里面了，通常会在下方的工具栏里面，如果 没有就到菜单View->Tools Window->Profiler把它调出来。然后选择要调试的进程，默认它会把CPU，Network，Memory和功耗都显示，这里可以双击Memory那一坨，就会进入专门的内存页面。</p>

<p>它会以时间轴的方式来图形化的展示内存使用情况，非常的直观和方便。通过这个可以直观的看到两个问题，就是嫌疑内存泄露以及内存抖动。</p>

<p>嫌疑内存泄露就是看到曲线一直在增长，且通过显示GC，或者退出后，或者停止某项目操作后，仍不回落的，这就非常有可能有泄露的存在，泄露是超出了它本该的生命周期，比如某一操作结束了，退出 了某一页面，甚至退出应用了，内存仍没有回落，就可能有问题。</p>

<p>另外就是内存抖动，就是能看到内存曲线 有毛刺，短时间内忽上忽下的，这就是内存抖动。</p>

<h4><a href="https://square.github.io/leakcanary/">leakcanary</a></h4>

<p>这货也是非常流行的，专门用于检测内存泄露的工具，它的功能较为强大，除了可以监控以外，还可以给出详细的trace。具体使用可以参考官方的文档，并不难。</p>

<p>但它最大的问题在于，必须参与项目构建。假如你想研究一下竞品的情况，就没有办法了。</p>

<h2>如何调试内存问题</h2>

<p>通过前面提到的手段，我们可以发现内存有一些问题了，需要进行内存方面的优化了，但这还不够，还需要一些精细化的调试方法来具体定位问题，这样才能更好的去进行优化。</p>

<p>那么有哪些具体的调试方法呢？</p>

<h3>Allocation tracer</h3>

<p>这个是前面提到的Android Studio Profier里面的工具。用Profiler可以发现问题，但还需要进一步的深入的分析问题。这就需要Allocation tracer了。</p>

<p>具体做法就是，当你发现某一系列操作后内存一直增长，或者看到有抖动现象时，就可以抓取这段时间的Heap dump，然后详细分析，现在Android Studio都集成好了，只需要点几下，就能抓到，并把结果列出来，可以看到具体创建哪些对象，以及它们的引用关系是怎样的。</p>

<p>可以参考 以下资源来详细了解如何使用此工具：</p>

<ul>
<li><a href="https://developer.android.com/studio/profile/android-profiler">The Android Profiler</a></li>
<li><a href="https://developer.android.com/studio/profile/memory-profiler">Inspect your app&rsquo;s memory usage with Memory Profiler</a></li>
<li><a href="https://juejin.cn/post/6844904080691691533">Android 内存优化篇 - 使用profile 和 MAT 工具进行内存泄漏检测</a></li>
</ul>


<h3><a href="https://www.eclipse.org/mat/">MAT</a></h3>

<p>这是专门用于Java heap内存分析的工具，相当强大。但不能直接使用。</p>

<p>需要先想办法抓取进程的heap dump，然后转换为Java标准的格式（因为安卓的Heap与Java SE的并不一样，安卓 SDK中有转换工具），然后再用MAT打开即可，它的功能要远强大于前面的提到的Allocation tracer。所以，如果要深度的分析和优化，还是要用MAT。</p>

<p>关于MAT的具体使用方法，可以参考以下资源：</p>

<ul>
<li><a href="http://wiki.eclipse.org/MemoryAnalyzer">官方文档</a></li>
<li><a href="https://blog.csdn.net/shulianghan/article/details/106958491">【Android 内存优化】使用 Memory Analyzer ( MAT ) 工具</a></li>
<li><a href="https://androidperformance.com/2015/04/11/AndroidMemory-Usage-Of-MAT/">Android 内存优化(1) - MAT 使用入门</a></li>
</ul>


<h3>leakcanary</h3>

<p>除了能监控以外，它还能分析具体的内存泄露，并给出trace，所以当发现问题后，具体定位问题的时候，也可以使用此工具，还是相当强大的。</p>

<p>它的使用相当简单，直接把它加入到dependencies，然后构建 就好了。</p>

<p>至于它的分析结果也是相当直观的，会以Notification的方式通知你，点开后有一个页面展示出引用关系链，然后判断是否是泄露，即可。</p>

<p>详细可以参阅它的<a href="https://square.github.io/leakcanary/getting_started/">官方文档</a>就可以了。</p>

<h2>如何优化内存</h2>

<p>内存优化，一大半在于测试，监控和调试分析，约占70%，这部分是重头，因为只有找到具体的代码位置，才好去修复问题，并且修复后还要验证问题是否真的修复了。不能光在那里看代码，想当然的认为把几个内部类改为static，或者传递引用了ApplicationContext，就能优化了内存。</p>

<p>对于性能优化，当然也包括内存优化，必须用测试手段进行量化，以此来验证是否真有有改善。</p>

<p>本节内容，假设已通过前面提到的测试方法发现了内存问题，并通过调试手段定位到了具体位置。优化的手段也要针对 具体的问题来进行：</p>

<h3>避免内存泄露</h3>

<p>内存优化的大头是要避免泄露，所以重点来谈谈如何避免内存泄露。</p>

<p>前面提到了，内存泄露的根本原因是生命周期混乱，较长生命周期的对象，甚至是超长生命周期的对象，持有了较短生命周期的对象，这一定会导致泄露。所以，要想真的解决内存泄露问题，必须设计好对象的生命周期，这是根本解决之法。</p>

<h4>要尽可能的，缩小对象的生命周期</h4>

<p>对象的生周期不应该超出它本该存在的范围，并且应该尽可能的减少对象的生命周期，这个可能在设计阶段考虑到。但一般较难执行，代码复杂了，很难控得住。</p>

<h4>对于超过Activity生命周期的对象要及时清理</h4>

<p>前面提到过的超长生命周期的东西，如Looper，如Frameworks，如单例，如RxJava的Schedulers，如线程池，这些东西的生命周期远长于Activity，所以，一定要在对应的地方，及时清除对Activity的引用持有。</p>

<p>后面的参考 资料里面也有大量的实用建议可以参考，这里就不重复了。避免内存泄露应该要被总结成为编程规范，然后在团队内部推行，当然也可以设计一些源码静态检测工具，来强制执行。当然，再好的工具和规范也需要人来遵守，任何事情能够在编码阶段防止发生，成本是最小的，收益 是最大的。</p>

<h4>WeakReference和SoftReference不是救命稻草</h4>

<p>千万不要用WeakReference和SoftReference这东西来修复内存泄露问题，它们根本就不是用来修复内存泄露问题的。</p>

<p>再说一遍，内存泄露是由生命周期混乱造成的。</p>

<p>如果强行使用WeakReference来代替原来的强引用，就会造成想使用对象的时候它却被回收了，这时你的正常逻辑就没法走了，而且如何正确的处理这种异常case，也是很难恰当 的处理的。</p>

<p>WeakReference这东西最最合理，最为适合的场景就是缓存里面，也就是说它本身是用于一种可有可无的引用关系，这样一旦被GC了，也不会影响原有逻辑，因为对象本来就可能在，也可能不在缓存里面，使用者必须处理在或者不在两种case。因为缓存的清理可能不够及时（必须由编码人员手动设置条件去清理，比如在退出的时候），当JVM需要GC时，因为都是WeakReference，GC就可以快速的回收对象释放内存。</p>

<h4>不要到处给对象引用置为null</h4>

<p>很多有过C++经验的同学，可能会习惯在对象使用完成后，手动把对象置为null。但其实这是完全没有必要的，只会造成不必要的混乱，JVM会自己去追踪每个对象，它到底还有没有被引用持有着。我们要把精力重点放在对象生命周期的把控上面，简单的置为null，不会缩减对象的生命周期，所以它对解决和防止泄露方面没有任何帮助。</p>

<h3>内存使用优化方式</h3>

<p>除了避免内存泄露，其他一些方式也是有很多技术可以用于优化的。</p>

<h4>减少内存浪费</h4>

<p>内存浪费，就是使用了没必要的内存，虽然可能不会引发问题，但是还是会增加风险，比如同样都是后台进程，你的应用占用内存稍大了一些，被杀的风险就高了一些。</p>

<p>减少内存浪费，核心的方法就是按需申请，特别像图片这种内存占用大户，一定要按需要来加载，何为需要就是目标View的大小，具体可以看官方教程<a href="https://developer.android.com/topic/performance/graphics/load-bitmap">Loading Large Bitmaps Efficiently</a>。以及尽可能的<a href="https://developer.android.com/topic/performance/graphics/manage-memory">要复用bitmap</a>。</p>

<p>再如资源图片，设置合理的分辨率，没有必要啥都上高清，且要为低精度设备提供单独的一套资源。</p>

<p>以及像不是要求那么清晰的场景就用RGB_565，而非RGBA_8888等等，这些都是在编码的时候就可以提高内存使用的方法。</p>

<h4>使用缓存</h4>

<p>缓存是计算机史上最伟大的发明，甚至是人类史上最伟大的发明，它无处不在从硬件到软件都会使用缓存，并且它在各种东西的设计之中都是很重要的一部分。</p>

<p>前面提到的内存抖动问题，就需要用缓存来解决，以避免频繁创建对象。特别是涉及图片的场景，比如流行的图片加载开源库里面都有专门的缓存的机制，有些是二级，有些是三级。当需要设计缓存时，可以重点参考图片加载库中的缓存设计。</p>

<p>另外，SDK中也有标准的缓存组件可以用，<a href="https://developer.android.com/reference/android/util/LruCache">LruCache</a>，这是针对内存层面的缓存，可以看<a href="https://www.jianshu.com/p/e09870b60046">这篇文章</a>来详细了解使用方法。</p>

<h4>合理复用对象</h4>

<p>这里的意思是使用像<a href="https://en.wikipedia.org/wiki/Flyweight_pattern">享元这样的设计模式</a>，来合理的复用对象。</p>

<p>需要注意的是享元(Flyweight Pattern)的适用场景，它适用于创建对象的成本较高，比如创建对象需要的一些资源较昂贵，不同的对象仅是有不同的属性，或者说对象本身在使用的时候的表现是不同的。</p>

<p>一个典型的例子就是绘图的形状，比如一个页面有大量的不同的形状需要绘制，有方的，有圆的，有白色的，有彩色的，有实边的有虚线的。常规的思路是一个基类叫Shape，里面有各种属性，还有一个draw方法，子类可以定义不同的属性，各自实现draw方法。然后根据需求创建一大坨具体的对象，遍历调用draw方法。这是面向对象编程（OOP）中的非常标准的多态（Polymophsim）。事实上，你只需要创建一个对象就够了，它会根据不同的属性画出不同的效果。这就是设计模式中的享元模式，具体可以参考<a href="https://refactoring.guru/design-patterns/flyweight">这篇文章</a>来详细了解。</p>

<h2>认识几种不同的内存类型</h2>

<p>通过各种工具查看的内存时，如通过meminfo以及像Memory profiler，但可以发现有不同种类，需要重点关注以几种：</p>

<h3>Java Heap</h3>

<p>也即通常意义上的heap内存（堆内存），名字可能会是Java，Java Heap，或者Java allocate，但都是一样就是指纯Java代码中通过new创建对象时使用的内存。</p>

<h3>Native Heap</h3>

<p>因为Java是支持JNI与C/C++接通，也即native方法，那么通过native方法创建的对象是计算在Native之中的，它与Java层是分开的，当然通过native方法（malloc或者new）创建的对象，要记得去释放，否则是一定会泄露的。</p>

<p>因为Android的大部分是由C/C++实现的，Java层仅是封装，Frameworks层大部分功能都由JNI转到native层去实现的，因此native这部分的内存也是很多的，并且由于Frameworks本身会大量调用JNI native层，所以即使你的应用程序根本没有用到JNI，但是还是会看到Native内存使用。</p>

<h3>Graphics</h3>

<p>主要是涉及OpenGL ES的相关内存占用，如GL Surfaces，如Texture或者如Framebuffer等，它们所占用的内存。</p>

<p>这里需要特别注意的是，即使你的应用没有用到OpenGL相关的东西，但仍可能会有此部分内存占用，这是由于硬件加速本身也是通过OpenGL ES实现的。</p>

<h3>ion内存</h3>

<p>这个是为了效率，直接从kernel层开出shared buffer，以加速内存使用效率，这个是偏底层的，普通app是用不到的。</p>

<p>可以参考一下这个<a href="https://www.cnblogs.com/willhua/p/10029280.html">The Android ION memory allocator</a>。</p>

<h3>共享内存</h3>

<p>可以理解为Linux中的匿名共享内存，可以用来实现IPC通信，但它并不会被Profiler计算在Java或者Native里面。非死不可出品的Fresco当初牛逼的地方就在于把Bitmap放在匿名共享内存里面，从而不占用应用自己的Heap空间。</p>

<p>可以参考这两个文章：</p>

<ul>
<li><a href="https://juejin.cn/post/6844904053961392141">Ashmem(Android共享内存)使用方法和原理</a></li>
<li><a href="https://developpaper.com/android-shared-memory/">Android shared memory</a></li>
</ul>


<h2>学无止境</h2>

<p>深入学习GC相关知识，如JVM的GC如何演进。</p>

<p>也可以学习一下其他编程语言的GC机制。</p>

<h2>不要过早优化，更不能过度优化</h2>

<p>性能优化这个事情是要在架构设计和产品设计阶段就需要考虑的事情，比如是否要加入缓存。</p>

<p>但如果前期想太多，会造成严重的扭曲，会让你陷入无限的复杂问题里面，难以自拔（本是问题1，但是变成了问题A，问题B，直到问题z，最初的问题1却被忽略了），反倒不是好事情。</p>

<p>最为想理的情况就是小步迭代，先提出能满足需求的最小版本，然后逐步迭代。比如说做一个新的feature的时候，先用最简单的架构和设计来实现，然后考虑补充细节，处理异常case，再考虑可能的扩展，然后考虑性能优化。</p>

<h2>剩下的是态度</h2>

<p>不是说一线开发的态度，而是老板们的态度。</p>

<p>性能问题是直接影响体验，所以只有重视体验的老板才会重视性能问题。而且这也不是研发猿的问题，需要测试，产品都要能重视性能问题，才能最终把性能做好。产品同学不能只顾着提需求，也要平衡性能，并且给研发同学一定的时间去注重性能问题，而测试同学更加重要，需要不断精进你的测试方法，帮助研发同学更好的解决问题，并且要有监控手段，比如说A版本做了性能优化专项，那么为了保留革命果实，需要有一种监控手段，以防性能出现重大回撤。</p>

<p>很多事情不能怪研发，就像有一位技术相当不错的同事说过的话，当时大家聊起性能优化的事情，他说：『道理大家都懂，但当左边是产品经理在那里崔需求，右边是设计师在那说按扭还差几个象素，测试同学在那崔你赶紧发版本啊，我还等着测完回家呢！当你处在这种条件下，谁TMD的还管性能啊，先实现了再说吧，甚至代码格式都懒得改了。』</p>

<p>所以，这是整个工程体系的事情，只有整个研发体系都注重性能，性能才会好，体验才会好，而这就需要一个老板的支持了，否则，性能不可能好，产品汪们只顾着提需求，设计师只顾着画面精美，研发同学光实现需求都做不完，哪有精力去搞性能啊！测试同学也不能只用粗浅的测试方法，只说性能不好，具体哪不好，不应该都让研发自己去调试，去发现问题。另外，也需要做好性能监控机制，以保住革命果实。要不然，A版本辛辛苦苦搞了一轮性能优化，也有大幅改善，然后到了B版本，或者几个月后，再来一轮。</p>

<p>这就是很骨感的现实。所以，在现实生活中只有大厂头部应用 才真的重视性能和体验，并且才能把性能和体验做好。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/topic/performance/memory-overview">Overview of memory management</a></li>
<li><a href="https://developer.android.com/studio/profile">Profile your app performance</a></li>
<li><a href="https://www.jianshu.com/p/258229426da4">Android内存管理机制</a></li>
<li><a href="https://www.jianshu.com/p/51e28a2c609c">最全的Android内存优化技巧</a></li>
<li><a href="https://jsonchao.github.io/2019/08/18/Android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/">Android性能优化之内存优化</a></li>
<li><a href="https://jsonchao.github.io/2019/12/29/%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2Android%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/">深入探索Android内存优化</a></li>
<li><a href="https://juejin.cn/post/6844904096541966350">Android性能优化之内存优化</a></li>
<li><a href="https://juejin.cn/post/6844904099998089230">深入探索 Android 内存优化（炼狱级别-上）</a></li>
<li><a href="https://juejin.cn/post/6872919545728729095">深入探索 Android 内存优化（炼狱级别-下）</a></li>
<li><a href="https://juejin.cn/post/6844904191282905096">内存优化深入版</a></li>
<li><a href="https://pspdfkit.com/blog/2019/android-large-memory-requirements/">Dealing with Large Memory Requirements on Android</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Sync Barrier机制]]></title>
    <link href="http://toughcoder.net/blog/2022/01/07/android-sync-barrier-mechanism/"/>
    <updated>2022-01-07T00:06:33+08:00</updated>
    <id>http://toughcoder.net/blog/2022/01/07/android-sync-barrier-mechanism</id>
    <content type="html"><![CDATA[<h2>诡异的假死问题</h2>

<p>前段时间，项目上遇到了一个假死问题，随机出现，无固定复现规律，大量频繁随机操作后，便会出现假死，整个应用无法操作，不会响应事件，会发生各种奇怪的ANR，且trace不固定。非常之诡异。</p>

<p>经过大量的复现研究和分析， 以及大神的指点后，发现与同步屏障（Sync Barrier）有关系，于是发现有必要研究一下这个东西。</p>

<p><a href=""><img src="http://www.cse.chalmers.se/edu/year/2016/course/course/TDA383_LP1/assets/img/barrier.png" title="auto auto" ></a></p>

<!-- more -->


<h2>什么是Sync Barrier机制</h2>

<p>这是安卓线程消息队列里面的一个新增加的东西，这么说还是太抽象，我们从头说起这件事情：</p>

<h4>安卓的消息队列机制</h4>

<p>消息队列，或者叫做Event Loop，通常在任何一个GUI应用程序里面都会有的，应用大部分时间处于Idle状态，当有事件发生时，比如用户点了一个button，然后开始响应此事件。安卓也是一个GUI应用程序，绝大多数都是带有GUI的应用程序，那么安卓 里面是如何实现这个EventLoop的呢，它是用Looper和MessageQueue，以及Handler，以一种消息队列的方式来实现loop。</p>

<p>有一定经验的同学对这些东西肯定不陌生，因为它们在实际的开发过程中相当常见，比如说对于UI的操作只能放在主线程里面，那么当工作线程想要更新UI时就需要用Handler发一个消息，或者post一个Runnable。或者当你想延后一段时间执行某种操作，就可以用postDelayed。这些都是非常常规的操作了。对于工作线程，如果想启用消息队列，就用Looper#prepare就可以了，当然了，要记得quit。</p>

<p>内部原理上面也不是很复杂，就是Looper会给线程绑定一个消息队列，即是MessageQueue，这是一个无限循环的队列，不断的轮询队列，当有新的消息时就去处理，否则就等待。主线程，安卓框架层在创建应用进程的时候就会给主线程默认创建好MessageQueue，所以就可以向其发消息（sendMessage）或者postDelayed，它们本质上都是一样的，都是向MessageQueue中入队一个消息，稍后它便会得到处理。</p>

<p><img src="https://blog.ycshao.com/2020/08/30/event-loop-and-concurrency/Event%20Loop%20With%20Single%20Worker.png" alt="" /></p>

<h4>同步消息与异步消息</h4>

<p>这个MessageQueue机制，就是队列，也就是说符合队列的特点，先进先出（FIFO，First-In First Out），就是说你先post的消息，肯定是先被处理，后post的后处理，即使有delay时候，也是看谁先到，谁先到谁先被处理。因此，这里面的消息全是同步，也就是说所有消息都是顺序处理，这就是同步消息。</p>

<p>异步消息，也就是说某个消息，想被最高优先级处理，无视发送消息的时机，比如说队列里面有8个消息，如何想让某个消息最先被处理？这时队列就变成了优先队列，有优先级的队列。那么具有高优先级的消息也是异步消息（Asynchronous Message）。即使是最后加入队列的，但因为是异步消息，它会被先处理，并不是FIFO，此可理解 为异步。</p>

<h4>Sync Barrier用以实现优先队列</h4>

<p>说了这么多，Sync Barrier就是安卓 内部用以实现优先级队列的一种方式。</p>

<p>当队列中出现Sync barrier（具体实现上就是Message#target为null）时，就会忽略所有同步消息，寻找异步消息（isAsynchrouns为true）的消息，然后优先处理它。</p>

<p>需要注意的是，把消息标记为异步，以及向消息队列中发送Sync barrier，这些API全部都是hide的，也就是说app中是无法使用的，通过反射也许能调用成功，但风险也较大，后续会被谷歌限制调用。换言之，这东西只能在Frameworks层内部自己使用。</p>

<h2>为什么要有Sync Barrier</h2>

<p>说了这么多，其实本质上，这东西就是一个优先队列，给要处理的消息加一个优先级机制，那这有什么实际用途呢？</p>

<p>消息队列这东西是在安卓一诞生就有了的东西，大部分时候它也没有什么问题。但有一个事情，就是安卓操作系统的UI流畅度远不及水果平台（iOS），原因就是在于水果平台的UI渲染是整个系统中最高优先执行。</p>

<p>有同学会说安卓里面也是这样啊，你想UI都只能在主线程里面操作（因此主线程也叫UI线程）。只能在主线程中操作UI，就能保证UI渲染是最高优先级吗？当然不是了。因为整个应用程序的默认线程就是主线程，换句话说，如果你不明显的去做线程切换，或者启用工作线程，那么所有事情都发生在主线程里面，当然 也包括了UI渲染，因此UI的渲染与你在主线程时面post一个消息的优先级是一样的。</p>

<p>如何让UI渲染在主线程中以最高优先级运行？于是就有了Sync barrier机制，这东西就是为了让消息队列有优先级，并且没有开放给app使用。可以去看一下ViewRootImpl（这货是专门负责ViewTree渲染的，也即可以理解为负责UI渲染的）的几个perform，它都是异步消息，也即会开启Sync barrier，它发送的消息将会是最高优先级的，会被优先处理。</p>

<h2>主要在哪里用Sync barrier</h2>

<p>前面提到了，Sync barrier这玩意儿并不是给app开发同学用的，很多相关的接口并没有开放出来，这是为了提高UI渲染而设计的东西。因此这东西主要是用在了UI渲染过程中。</p>

<p>仔细查看ViewRootImpl的源码可以发现，每次渲染View tree之前都会先给主线程插入一个Sync barrier，以挡住同步消息，以保证渲染被主线程优先执行到。</p>

<pre><code class="java">    @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.R, trackingBug = 170729553)
    void scheduleTraversals() {
        if (!mTraversalScheduled) {
            mTraversalScheduled = true;
            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
            mChoreographer.postCallback(
                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
            notifyRendererOfFramePending();
            pokeDrawLockIfNeeded();
        }
    }

    void unscheduleTraversals() {
        if (mTraversalScheduled) {
            mTraversalScheduled = false;
            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);
            mChoreographer.removeCallbacks(
                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);
        }
    }

    void doTraversal() {
        if (mTraversalScheduled) {
            mTraversalScheduled = false;
            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);

            performTraversals();
       }
    }
</code></pre>

<p>这里的逻辑略复杂一些，View tree本身的处理过程，也即三大步measure, layout和draw，也就是performTraversal本身并没有异步消息，它是在准备渲染的时候放一个sync barrier，而在具体处理每一帧前就移除了sync barrier，这里为何要这样，还没有完全想清楚。通过搜索ViewRootImpl可以发现只有input event，keyevent 以及与用户输入相关的消息被设置为了asynchronous，也就是说用户事件响应被提高了优先级，而view tree的渲染，即UI的每一帧，其实并没有被提升优先级。因为UI刷的每一帧是以固定频率刷新的，Choreographer 从硬件得到vsync脉冲信号，然后回调给ViewRootImpl让其渲染每一帧（也即是performTraversal）。</p>

<h2>Sync Barrier会引发什么问题</h2>

<p>说实话，这套机制，实现的并不怎么优雅，因为，毕竟它并不是在最初的设计之初就考虑到的东西，它的整体运行机制并不完善，非常依赖于调用者的使用，所以它的相关API并未有开放出来。</p>

<p>它有三步，先发一个Sync barrier，然后发送异步消息，然后再移除Sync barrier。</p>

<p>只有UI渲染（ViewTree的相关操作，才需要这样做），大部分其他的消息都是同步的，并不需要这样搞。当有Sync barrier时，消息队列在处理消息的时候会忽略掉所有的同步消息（也即是常规消息），优先处理异步消息，直到Sync barrier移除，也是需要手动移除的。Sync barrier需要手动移除是最坑的。</p>

<p>因此，假如要处理的异步特别多，或者逻辑出错Sync barrier没有被移除，那就悲剧 了，就会导致消息队列中的大量常规消息无法得到处理，队列就会停止工作，应用会出现随机的ANR，以及假死。</p>

<h2>如何调试</h2>

<p>很不幸，Sync barrier导致的问题很难调试，甚至很难被发现，通常都是ANR或者说卡死问题。</p>

<p>那么首先可以按照ANR和卡死的常规分析方式去分析，假如都未发现明显的问题时，比如没有明显的耗时的操作，也没有死锁，也没有被硬件和IO阻塞，也没有进入死循环。</p>

<p>这些常规的分析，都没有发现问题。这时就可以考虑是不是Sync barrier在搞鬼。特别当涉及一些诡异的UI状态时，比如某个View只显示 了一半，比如某一个View没有显示 完全，比如只有背景没有前景，等等，当排除了其他常规问题时，就很可能是Sync barrier有异常导致的。</p>

<p>另外，如果有能力修改Frameworks的话，可以给MessageQueue增加dump信息，把队列中的所有消息都打印出来，以及把Sycn barrier也都打印出来，这样能够比较清楚看到，队列内部的情况，自然也能够发现异常的Sync barrier。</p>

<h2>如何避免Sync Barrier搞鬼</h2>

<p>前面提到过，这套东西都是Frameworks层内部的机制，并没有开放给app使用，而Frameworks内部的逻辑一般来说还是相当健壮的，绝大多数时候并不会出问题。当然了，各个厂商内部搞的各种所谓优化，倒是有可能会引发问题。</p>

<p>在实际开发过程中，引发Sync barrier的最多场景就是自定义View。对于自定义View，是能够在非主线程调用其invalidate的，当有大量的非主线程调用invalidate时，就有可能恰好与主线程的渲染发生交互，具体case非常corner要刚巧非主线程在postInvalide，然后主线程也刚巧在发送异步消息，就可能使得Sync barrier没有被移除，从而导致问题。</p>

<p>这就需要我们在编码阶段做好封装，对于自定义View的刷新触发逻辑做好封装，做一下线程切换，以保证是在主线程里面执行invalidate。因为暴露出去的接口，是没有办法控制的，你没有办法让所有调用者都在主线程里面调用你的接口。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://blog.csdn.net/jdsjlzx/article/details/110563162">Handler sync barrier（同步屏障）</a></li>
<li><a href="https://hningoba.github.io/2019/12/06/Android%20%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9C%E6%9C%BA%E5%88%B6(Sync%20Barrier">Android 同步屏障机制(Sync Barrier)</a>/)</li>
<li><a href="https://xiaozhuanlan.com/topic/0843791256">同步屏障？阻塞唤醒？和我一起重读 Handler 源码</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650839366&amp;idx=2&amp;sn=94536e87f552314acd1e4620109c3c9b&amp;chksm=80b74dd8b7c0c4ce3d4945d690d50feae9b7c2d7009ce113b90cc99712703521c31c75fe2026&amp;mpshare=1&amp;scene=1&amp;srcid=1230rTWKhDHdFQTcru6ohx67&amp;sharer_sharetime=1640838623088&amp;sharer_shareid=80824a30f91a8c144cac1fea148f525a#rd">同步屏障与异步消息，从入门到放弃</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650837028&amp;idx=2&amp;sn=b37f149f3ade5f8cf1bebb49487ed1df&amp;chksm=80b744bab7c0cdaca13a90022b4e8b949c1003a9b606c81ee8ac159377e328b358457d79a3b7&amp;scene=21#wechat_redirect">面试官：如何提高Message的优先级</a></li>
<li><a href="https://juejin.cn/post/6947986170135445535">今日头条 ANR 优化实践系列 - Barrier 导致主线程假死</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Animation Internal Secrets]]></title>
    <link href="http://toughcoder.net/blog/2021/09/14/android-animation-internal-secrets/"/>
    <updated>2021-09-14T21:07:00+08:00</updated>
    <id>http://toughcoder.net/blog/2021/09/14/android-animation-internal-secrets</id>
    <content type="html"><![CDATA[<p>前面的文章重点讲了如何使用安卓平台提供的能力来做好一个动画。为了更深入的理解，需要去了解一下动画框架的内部机理，这样能够帮助我们做出更优雅的动画实现。</p>

<p><a href=""><img src="https://raw.githubusercontent.com/OCNYang/Android-Animation-Set/master/app/src/main/res/drawable/header_bg.jpg?token=AQ83Mm1lTKd-0jwgDJ9K3tNGJbk9OI9iks5axtyQwA%3D%3D" title="auto auto" ></a></p>

<!-- more -->


<h2><a href="https://developer.android.com/guide/topics/graphics/view-animation">View Animation</a>的原理</h2>

<h3>View Animation源码解析</h3>

<p>View animation的代码都是在<a href="https://developer.android.com/reference/android/view/animation/package-summary">android.view.animation</a>包下面。</p>

<p>这里面主要有三个东西，下面来分别仔细说说</p>

<h4><a href=".https://developer.android.com/reference/android/view/animation/Animation">Animation</a></h4>

<p>主要是抽象类<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/animation/Animation.java">Animation</a>以及它的四大子类，也是View animation中的四大变幻对象&ndash;位移变幻<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/animation/TranslateAnimation.java">TranslateAnimation</a>，缩放变幻<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/animation/ScaleAnimation.java">ScaleAnimation</a>，旋转变幻<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/animation/RotateAnimation.java">RotateAnimation</a>和渐变变幻<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/animation/AlphaAnimation.java">AlphaAnimation</a>。</p>

<p>以及一些工具对象，如<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/animation/AnimationSet.java">AnimationSet</a>和<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/animation/AnimationUtils.java">AnimationUtils</a>。</p>

<p>仔细看这些类的源码可以发现，其实它们不复杂，里面也没啥东西，主要是用于各种参数管理，相当于封装出来的工具和原料，具体内部的原理并不在这里。仔细看四大变幻的<a href="https://developer.android.com/reference/android/view/animation/Animation#applyTransformation(float,%20android.view.animation.Transformation)">applyTransformation</a>方法，可以发现这一坨把最接近『原理』的东西都放在了一个叫做Transformation的对象中去了。</p>

<h4><a href="https://developer.android.com/reference/android/view/animation/Transformation">Transformation</a></h4>

<p>直译变幻，但文档中的定义是动画过程中某一时刻应该做的变幻，此为<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/animation/Transformation.java">Transformation</a>。</p>

<p>这货的实现也不复杂，它也就是个中间商，只是一个存储从Animation传过来的参数 的中间变量，它里面有一个Alpha成员参数用以保存当前的渐变参数值，以及一个<a href="https://developer.android.com/reference/android/graphics/Matrix">Matrix</a>，Matrix可以保存当前的位移，旋转和缩放。Matrix应该不算太陌生，处理过<a href="https://developer.android.com/reference/android/graphics/Bitmap">Bitmap</a>变幻的同学，对它应该会有了解，都是通过Matrix来设置参数的。</p>

<h4><a href="https://developer.android.com/reference/android/view/animation/Interpolator">Interpolator</a></h4>

<p>动画是随时间变化的一系列视觉变幻，因人眼视觉残留，连在一起就是动画，跟电影是一个道理。这里就有一个非常关键的参数就是时间。时间对于动画来说体现在两方面一是时长，就是整个动画持续 的时间，另外一个就是变幻变化的速率，也就是说动画播放速度的变化率。其实，这里变化的并不是时间，时间是永恒的以固定速度在流逝，对于动画来说，帧率是固定的，后面会谈到，动画的帧率是由时间驱动器驱动的，它是以固定的时间脉冲来回调渲染动画的每一帧。这里的时间变化其实是做动画的每一帧时用到的参数 的变化，它并不是线性的，假设动画一共有10帧，要把View向右移动100px，默认是线性的，匀速的，也即每一帧都向前移动10px，但如果使用加速插值器，那么可能就是一个变加速运动，第1帧可能在0px，第2帧在5px，第3帧25px，第4帧到36px，以此类推。</p>

<p>时间插值器，就是用来调整播放速度的，用以实现时间变化。</p>

<h3>View Animation的渲染原理</h3>

<p>从前面的讨论来看，动画的渲染跟那几个对象都没有关系，使用View animation的时候，只有两种方法可以让动画生效，一是调用<a href="https://developer.android.com/reference/android/view/View?hl=en#startAnimation(android.view.animation.Animation)">View#startAnimation</a>，另外一个是<a href="https://developer.android.com/reference/android/view/View?hl=en#setAnimation(android.view.animation.Animation)">View#setAnimation</a>，然后再<a href="https://developer.android.com/reference/kotlin/android/view/animation/Animation?hl=en#start()">Animation#start</a>。</p>

<p>假如没有把Animation塞给某一个具体的View对象，光是调用Animation#start，是不会有任何影响和效果的。这说明动画的渲染是在View对象draw时做的，没有与具体View对象建立关联的动画是没有任何效果的。所以动画的渲染主要还要看View本身的逻辑。</p>

<p>可以从View#setAnimation和View#startAnimation入手来看，这两个方法只是把外部传进来的Animation对象保存在了一个叫做mCurrentAnimation成员里面，其他的什么也没做。查询索引，关键的地方有两个，一个是View#applyLegacyAnimation方法，另外一个就是View#draw方法。</p>

<p>先来看View#applyLegacyAnimation方法：</p>

<pre><code class="java">   /**
     * Utility function, called by draw(canvas, parent, drawingTime) to handle the less common
     * case of an active Animation being run on the view.
     */
    private boolean applyLegacyAnimation(ViewGroup parent, long drawingTime,
            Animation a, boolean scalingRequired) {
        Transformation invalidationTransform;
        final int flags = parent.mGroupFlags;
        final boolean initialized = a.isInitialized();
        if (!initialized) {
            a.initialize(mRight - mLeft, mBottom - mTop, parent.getWidth(), parent.getHeight());
            a.initializeInvalidateRegion(0, 0, mRight - mLeft, mBottom - mTop);
            if (mAttachInfo != null) a.setListenerHandler(mAttachInfo.mHandler);
            onAnimationStart();
        }

        final Transformation t = parent.getChildTransformation();
        boolean more = a.getTransformation(drawingTime, t, 1f);
        if (scalingRequired &amp;&amp; mAttachInfo.mApplicationScale != 1f) {
            if (parent.mInvalidationTransformation == null) {
                parent.mInvalidationTransformation = new Transformation();
            }
            invalidationTransform = parent.mInvalidationTransformation;
            a.getTransformation(drawingTime, invalidationTransform, 1f);
        } else {
            invalidationTransform = t;
        }

        if (more) {
            if (!a.willChangeBounds()) {
                if ((flags &amp; (ViewGroup.FLAG_OPTIMIZE_INVALIDATE | ViewGroup.FLAG_ANIMATION_DONE)) ==
                        ViewGroup.FLAG_OPTIMIZE_INVALIDATE) {
                    parent.mGroupFlags |= ViewGroup.FLAG_INVALIDATE_REQUIRED;
                } else if ((flags &amp; ViewGroup.FLAG_INVALIDATE_REQUIRED) == 0) {
                    // The child need to draw an animation, potentially offscreen, so
                    // make sure we do not cancel invalidate requests
                    parent.mPrivateFlags |= PFLAG_DRAW_ANIMATION;
                    parent.invalidate(mLeft, mTop, mRight, mBottom);
                }
            } else {
                if (parent.mInvalidateRegion == null) {
                    parent.mInvalidateRegion = new RectF();
                }
                final RectF region = parent.mInvalidateRegion;
                a.getInvalidateRegion(0, 0, mRight - mLeft, mBottom - mTop, region,
                        invalidationTransform);

                // The child need to draw an animation, potentially offscreen, so
                // make sure we do not cancel invalidate requests
                parent.mPrivateFlags |= PFLAG_DRAW_ANIMATION;

                final int left = mLeft + (int) region.left;
                final int top = mTop + (int) region.top;
                parent.invalidate(left, top, left + (int) (region.width() + .5f),
                        top + (int) (region.height() + .5f));
            }
        }
        return more;
    }
</code></pre>

<p>这个方法看着比较长，但它就做了三件事情：1）初始化动画；2）获取当前时刻的Transformation；3）如果动画还没有完（还有下一帧），那就得调用View的invalidate，得重绘。</p>

<p>再看使用此方法的地方，是在draw，需要注意是带有三个参数的那个draw，在<a href="http://toughcoder.net/blog/2020/07/26/android-view-render-flow/">前面的文章里面</a>介绍过，这个draw方法是由ViewGroup#dispatchDraw中drawChild时调用的：</p>

<pre><code class="java">   /**
     * This method is called by ViewGroup.drawChild() to have each child view draw itself.
     *
     * This is where the View specializes rendering behavior based on layer type,
     * and hardware acceleration.
     */
    boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) {
        final boolean hardwareAcceleratedCanvas = canvas.isHardwareAccelerated();
        /* If an attached view draws to a HW canvas, it may use its RenderNode + DisplayList.
         *
         * If a view is dettached, its DisplayList shouldn't exist. If the canvas isn't
         * HW accelerated, it can't handle drawing RenderNodes.
         */
        boolean drawingWithRenderNode = mAttachInfo != null
                &amp;&amp; mAttachInfo.mHardwareAccelerated
                &amp;&amp; hardwareAcceleratedCanvas;

        boolean more = false;
        final boolean childHasIdentityMatrix = hasIdentityMatrix();
        final int parentFlags = parent.mGroupFlags;

        if ((parentFlags &amp; ViewGroup.FLAG_CLEAR_TRANSFORMATION) != 0) {
            parent.getChildTransformation().clear();
            parent.mGroupFlags &amp;= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION;
        }

        Transformation transformToApply = null;
        boolean concatMatrix = false;
        final boolean scalingRequired = mAttachInfo != null &amp;&amp; mAttachInfo.mScalingRequired;
        final Animation a = getAnimation();
        if (a != null) {
            more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired);
            concatMatrix = a.willChangeTransformationMatrix();
            if (concatMatrix) {
                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
            }
            transformToApply = parent.getChildTransformation();
        } else {
            if ((mPrivateFlags3 &amp; PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) != 0) {
                // No longer animating: clear out old animation matrix
                mRenderNode.setAnimationMatrix(null);
                mPrivateFlags3 &amp;= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
            }
            if (!drawingWithRenderNode
                    &amp;&amp; (parentFlags &amp; ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
                final Transformation t = parent.getChildTransformation();
                final boolean hasTransform = parent.getChildStaticTransformation(this, t);
                if (hasTransform) {
                    final int transformType = t.getTransformationType();
                    transformToApply = transformType != Transformation.TYPE_IDENTITY ? t : null;
                    concatMatrix = (transformType &amp; Transformation.TYPE_MATRIX) != 0;
                }
            }
        }

        concatMatrix |= !childHasIdentityMatrix;

        // Sets the flag as early as possible to allow draw() implementations
        // to call invalidate() successfully when doing animations
        mPrivateFlags |= PFLAG_DRAWN;

        if (!concatMatrix &amp;&amp;
                (parentFlags &amp; (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS |
                        ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN &amp;&amp;
                canvas.quickReject(mLeft, mTop, mRight, mBottom) &amp;&amp;
                (mPrivateFlags &amp; PFLAG_DRAW_ANIMATION) == 0) {
            mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED;
            return more;
        }
        mPrivateFlags2 &amp;= ~PFLAG2_VIEW_QUICK_REJECTED;

        if (hardwareAcceleratedCanvas) {
            // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
            // retain the flag's value temporarily in the mRecreateDisplayList flag
            mRecreateDisplayList = (mPrivateFlags &amp; PFLAG_INVALIDATED) != 0;
            mPrivateFlags &amp;= ~PFLAG_INVALIDATED;
        }

        RenderNode renderNode = null;
        Bitmap cache = null;
        int layerType = getLayerType(); // TODO: signify cache state with just 'cache' local
        if (layerType == LAYER_TYPE_SOFTWARE || !drawingWithRenderNode) {
             if (layerType != LAYER_TYPE_NONE) {
                 // If not drawing with RenderNode, treat HW layers as SW
                 layerType = LAYER_TYPE_SOFTWARE;
                 buildDrawingCache(true);
            }
            cache = getDrawingCache(true);
        }

        if (drawingWithRenderNode) {
            // Delay getting the display list until animation-driven alpha values are
            // set up and possibly passed on to the view
            renderNode = updateDisplayListIfDirty();
            if (!renderNode.hasDisplayList()) {
                // Uncommon, but possible. If a view is removed from the hierarchy during the call
                // to getDisplayList(), the display list will be marked invalid and we should not
                // try to use it again.
                renderNode = null;
                drawingWithRenderNode = false;
            }
        }

        int sx = 0;
        int sy = 0;
        if (!drawingWithRenderNode) {
            computeScroll();
            sx = mScrollX;
            sy = mScrollY;
        }

        final boolean drawingWithDrawingCache = cache != null &amp;&amp; !drawingWithRenderNode;
        final boolean offsetForScroll = cache == null &amp;&amp; !drawingWithRenderNode;

        int restoreTo = -1;
        if (!drawingWithRenderNode || transformToApply != null) {
            restoreTo = canvas.save();
        }
        if (offsetForScroll) {
            canvas.translate(mLeft - sx, mTop - sy);
        } else {
            if (!drawingWithRenderNode) {
                canvas.translate(mLeft, mTop);
            }
            if (scalingRequired) {
                if (drawingWithRenderNode) {
                    // TODO: Might not need this if we put everything inside the DL
                    restoreTo = canvas.save();
                }
                // mAttachInfo cannot be null, otherwise scalingRequired == false
                final float scale = 1.0f / mAttachInfo.mApplicationScale;
                canvas.scale(scale, scale);
            }
        }

        float alpha = drawingWithRenderNode ? 1 : (getAlpha() * getTransitionAlpha());
        if (transformToApply != null
                || alpha &lt; 1
                || !hasIdentityMatrix()
                || (mPrivateFlags3 &amp; PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) {
            if (transformToApply != null || !childHasIdentityMatrix) {
                int transX = 0;
                int transY = 0;

                if (offsetForScroll) {
                    transX = -sx;
                    transY = -sy;
                }

                if (transformToApply != null) {
                    if (concatMatrix) {
                        if (drawingWithRenderNode) {
                            renderNode.setAnimationMatrix(transformToApply.getMatrix());
                        } else {
                            // Undo the scroll translation, apply the transformation matrix,
                            // then redo the scroll translate to get the correct result.
                            canvas.translate(-transX, -transY);
                            canvas.concat(transformToApply.getMatrix());
                            canvas.translate(transX, transY);
                        }
                        parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                    }

                    float transformAlpha = transformToApply.getAlpha();
                    if (transformAlpha &lt; 1) {
                        alpha *= transformAlpha;
                        parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                    }
                }

                if (!childHasIdentityMatrix &amp;&amp; !drawingWithRenderNode) {
                    canvas.translate(-transX, -transY);
                    canvas.concat(getMatrix());
                    canvas.translate(transX, transY);
                }
            }

            // Deal with alpha if it is or used to be &lt;1
            if (alpha &lt; 1 || (mPrivateFlags3 &amp; PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) {
                if (alpha &lt; 1) {
                    mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA;
                } else {
                    mPrivateFlags3 &amp;= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA;
                }
                parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                if (!drawingWithDrawingCache) {
                    final int multipliedAlpha = (int) (255 * alpha);
                    if (!onSetAlpha(multipliedAlpha)) {
                        if (drawingWithRenderNode) {
                            renderNode.setAlpha(alpha * getAlpha() * getTransitionAlpha());
                        } else if (layerType == LAYER_TYPE_NONE) {
                            canvas.saveLayerAlpha(sx, sy, sx + getWidth(), sy + getHeight(),
                                    multipliedAlpha);
                        }
                    } else {
                        // Alpha is handled by the child directly, clobber the layer's alpha
                        mPrivateFlags |= PFLAG_ALPHA_SET;
                    }
                }
            }
        } else if ((mPrivateFlags &amp; PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
            onSetAlpha(255);
            mPrivateFlags &amp;= ~PFLAG_ALPHA_SET;
        }

        if (!drawingWithRenderNode) {
            // apply clips directly, since RenderNode won't do it for this draw
            if ((parentFlags &amp; ViewGroup.FLAG_CLIP_CHILDREN) != 0 &amp;&amp; cache == null) {
                if (offsetForScroll) {
                    canvas.clipRect(sx, sy, sx + getWidth(), sy + getHeight());
                } else {
                    if (!scalingRequired || cache == null) {
                        canvas.clipRect(0, 0, getWidth(), getHeight());
                    } else {
                        canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
                    }
                }
            }

            if (mClipBounds != null) {
                // clip bounds ignore scroll
                canvas.clipRect(mClipBounds);
            }
        }

        if (!drawingWithDrawingCache) {
            if (drawingWithRenderNode) {
                mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;
                ((RecordingCanvas) canvas).drawRenderNode(renderNode);
            } else {
                // Fast path for layouts with no backgrounds
                if ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
                    mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;
                    dispatchDraw(canvas);
                } else {
                    draw(canvas);
                }
            }
        } else if (cache != null) {
            mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;
            if (layerType == LAYER_TYPE_NONE || mLayerPaint == null) {
                // no layer paint, use temporary paint to draw bitmap
                Paint cachePaint = parent.mCachePaint;
                if (cachePaint == null) {
                    cachePaint = new Paint();
                    cachePaint.setDither(false);
                    parent.mCachePaint = cachePaint;
                }
                cachePaint.setAlpha((int) (alpha * 255));
                canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
            } else {
                // use layer paint to draw the bitmap, merging the two alphas, but also restore
                int layerPaintAlpha = mLayerPaint.getAlpha();
                if (alpha &lt; 1) {
                    mLayerPaint.setAlpha((int) (alpha * layerPaintAlpha));
                }
                canvas.drawBitmap(cache, 0.0f, 0.0f, mLayerPaint);
                if (alpha &lt; 1) {
                    mLayerPaint.setAlpha(layerPaintAlpha);
                }
            }
        }

        if (restoreTo &gt;= 0) {
            canvas.restoreToCount(restoreTo);
        }

        if (a != null &amp;&amp; !more) {
            if (!hardwareAcceleratedCanvas &amp;&amp; !a.getFillAfter()) {
                onSetAlpha(255);
            }
            parent.finishAnimatingView(this, a);
        }

        if (more &amp;&amp; hardwareAcceleratedCanvas) {
            if (a.hasAlpha() &amp;&amp; (mPrivateFlags &amp; PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
                // alpha animations should cause the child to recreate its display list
                invalidate(true);
            }
        }

        mRecreateDisplayList = false;

        return more;
    }
</code></pre>

<p>这个方法更长，主要就看transformToApply这个变量就好了，这个变量是在调用了applyLegacyAnimation后被赋值的。之后，可以看到它其中的Matrix被作用于Canvas，而alpha值被用于setAlpha了。好了，这里就是动画的最核心的逻辑。前面说了Transformation对象就是包了一个Matrix和alpha，然后被用在了这里，Matrix作用于<a href="https://developer.android.com/reference/android/graphics/Canvas">Canvas</a>对象，以产生视觉变幻（位移，缩放和旋转），而渐变则是通过setAlpha实现的。</p>

<p>所以View Animation是View tree每次draw的时候去做的，用当前的Animation对象获取到Transformation，然后把Matrix和alpha应用到draw时的Canvas，这就产生了视觉变幻效果。因此，View animation只是放一遍电影，因为这一过程中变化 的只有Transformation对象，也即只有Matrix和alpha在变化，在View draw的时候应用一下就完了，它并没有对View的真实属性产生影响，仅是对渲染的结果Canvas产生影响。而每次View draw的时候，都是会重新生成一个Canvas对象，并且View的属性本身并没有变，所以新生成的Canvas对象并不会体现之前一次draw（也即上一帧）的变幻结果，它只是继续应用Transformation对象，假如动画结束了就没有了Transformation对象，那就没有Matrix和alpha可作用于Canvas，也就没有了动画效果，一切又恢复到了最初原始的样子。</p>

<h2>Property Animation的原理</h2>

<p>属性动画的实现主要是在<a href="https://developer.android.com/reference/kotlin/android/animation/package-summary?hl=en">android.animation</a>里面，它有独立的一级包名，可以看出它在平台中的位置，是要高于View animation的。</p>

<h3>Animator的源码解析</h3>

<p>先从<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/animation/Animator.java">Animator</a>对象看起，它是一个抽象类，只定义了关于动画的基本接口，如duration/start/end/cancel等，以及设置<a href="https://developer.android.com/reference/android/animation/Animator.AnimatorListener">AnimatorListener</a>以外，再无其他东西。</p>

<p>最为核心的对象是<a href="https://developer.android.com/reference/android/animation/ValueAnimator">ValueAnimator</a>，它是属性动画的核心，它主要有两部分，一是管理各种数值，前面的文章说过属性动画的核心原理就是在一定时间内，用一定速率把某个值变成另外一个值；另外一部分就涉及渲染原理，后面再详细说。</p>

<p>再有就是<a href="https://developer.android.com/reference/android/animation/ObjectAnimator">ObjectAnimator</a>，它是ValueAnimator的子类，连同<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/animation/PropertyValuesHolder.java">PropertyValuesHolder</a>一起，针对某个对象的属性进行管理，主要涉及两方面，一个是属性值的管理，也即把对象的属性名字和其要设置的值都暂存起来，另外一部分就是通过反射来把要修改的值作用于目标对象。</p>

<h3>Animator的时间驱动器</h3>

<p>动画要让数值随时间而变化，当start了以后，最重要的事情 就是以一定的时间速率来刷新数值，也即是用一个时间驱动器来刷新每一帧。前面讨论了View animation，是在View tree渲染时去刷新动画的每一帧。</p>

<p>属性动画的核心在ValueAnimator里面，连同一个<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/animation/AnimationHandler.java">AnimatorHandler</a>对象，一起实现了时间驱动。AnimatorHanndler是属性动画的时间驱动器，它从<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/Choreographer.java;drc=master;l=82">Choreographer</a>中接收脉冲信号，然后再回调给所有的ValueAnimator，令其doAnimationFrame。它是一个单例，也就是说同一个进程里所有的属性动画用的是内一个时间驱动器，同一个AnimatorHandler。</p>

<p><strong>注意</strong>：关于Choreographer的解释可以看<a href="http://toughcoder.net/blog/2020/07/26/android-view-render-flow/">另外的文章</a>。</p>

<p>当调用ValueAnimator#start时便会往<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/animation/AnimationHandler.java">AnimatorHandler</a>对象添加一个回调，用以接收do frame的脉冲事件，然后从时间插值器mInterpolator中获取当前的时间速率，再调用animateValue进行数值的改变，其子类可以override此方法以实现属性的具体变化。这里还有一个变量mSelfPulsing用以控制是否使用AnimatorHandler，默认是true，也就是让ValueAnimator使用AnimatorHandler接收来自Choreographer的脉冲信号做动画。此外，也可以自己实现一个时间驱动器。</p>

<p>由此，便可以让在duration之内，渲染动画的每一帧。</p>

<h3>Animator的渲染原理</h3>

<p><a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/animation/ValueAnimator.java">ValueAnimator</a>仅是让一个数值在一定时间内发生特定的变化，它没有实际的视觉效果。常常使用的是ObjectAnimator，并作用于View的属性以产生视觉效果，如前面文章中的例子。那么这个又是如何实现的呢？</p>

<p><a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/animation/ObjectAnimator.java">ObjectAnimator</a>是可能改变某个对象（内部称之为Target对象）的某个属性值，让其随时间变化，当应用到View对象时，比如translationY属性，ObjectAniamtor所做的也仅仅是让translationY的值随时间变化 而已，仅在animateValue时去调用View#setTranslationY把变化的数值传进去。是View自己在做重绘，View的setTranslationY方法中，有做invalidate以进行重绘。由此，便产生了视觉效果。</p>

<p><a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/ViewPropertyAnimator.java">ViewPropertyAnimator</a>是另一个常用的对象，但发现它并不是Animator的子类，是封装出来的专门针对View对象做属性动画的一个工具类，它本质上与ObjectAnimator一样，只不过做了一些集成与封装，可以同时方便的操作多个属性，另外它会把所有属性的值变更 过后统一调一次invalidate，效率上会略高一筹。ObjectAnimator一次只能操作一个属性，并且每个属性变化 时都会调一次invalidate。</p>

<p>它是把支持的属性都先放进一个map里面暂存起来，当调用startAnimation时，创建一个ValueAnimator，并设置一个AnimatorListener，在onAnimationUpdate时，把前面暂存的属性都设置到mView对象中去，然后调用一次invalidate让mView重绘。这里还需要注意，在设置属性这一块与ObjectAnimator也不一样，前面说了ObjectAniamtor是通过属性的settter来实现的，但View的属性的settter都会触发invalidate。所以，ViewPropertyAnimator为了避免每次设置属性时都触发invalidate，它是直接把属性塞给View的mRenderNode对象，然后在所有变化 的属性都设置完以后，再统一做一次重绘(invalidate)。</p>

<p>另外的区别就是，ViewPropertyAnimator仅支持一些特定的属性，而ObjectAnimator可以支持任意属性（只要有setter/getter，就可以）。</p>

<h2>关于动画的常见问题</h2>

<p>通过上面的论述，就搞清楚了动画原理了，下面来看一些比较有意思的问题。</p>

<h3>动画是在主线程里做的么</h3>

<p>动画主要是通过View对象来呈现视觉效果，View是在主线程中渲染的，所以动画也是在主线程里面完成的。这话呢，只对了一半，或者这么说是不够严谨的。</p>

<p>通过上面的讨论，View animation，都是在主线程中实现的，因为它的时间驱动器是View tree的渲染，也即在draw的时候，去计算当前的Transformation，然后应用到View的Canvas上面。这一切都是在主线程中完成的。</p>

<p>但对于属性动画，就不是这个样子，属性动画分两部分，一部分是让数值随时间变化 ，这个其实可以在任意线程中去做。通过上面的讨论，默认的情况下，确实也是在主线程中做的（从Choreographer得到时间脉冲，这是在主线程里面），但是留 有接口，可以改变的，虽然很少这样做，但确实是可行的，并且数值随时间变化，这个事情也是可以在任意线程中完成的。另外一部分，就是让变化 的数值对目标对象生效，这个要看具体的对象了，如果View，肯定 还是要在主线程里搞。</p>

<h3>动画的帧率（FPS）是多少</h3>

<p>从上面的讨论来看，无论是View animation还是属性动画，时间脉冲都是Choreographer，并且对View来说视觉要生效是通过重绘来做的，所以最高帧率都会是60FPS。</p>

<p>所以，其实动画的帧率是固定的，也就是说其doAnimationFrame是固定频率在回调。</p>

<p>这里要与动画的时间插值器区别开来，动画的真实帧率是固定的，时间插值器的作用是让动画的变化变成非线性的。比如说某个属性x从0变到100，ValueAnimator的doAnimationFrame以及animateValue会是以固定的频率，从Choreographer每隔16ms接收一次脉冲，就会调用一次animateValue，时间插值器的作用，能让x值的变化是非线性的：</p>

<p>时间脉冲：0 1 2 3 4 5 6 7 8 9 10
线性变化：0 10 20 30 40 50 60 70 80 90 100
加速减速：0 13 25 37 57 71 79 85 89 95 100</p>

<p>时间插值器并没有让动画的帧率发生变化 ，而是让动画的结果非线性变化。</p>

<h3>动画过程中如何处理MotionEvent事件</h3>

<p>没有任何影响，view animation是发生在draw的时候，而属性动画是设置属性后再re-draw。从逻辑 上来讲动画与事件不冲突，两者之间没有任何影响。</p>

<p>不过呢，View animation是对Canvas做变幻，View对象仍在原来的位置，原来的状态，所以点击动画过程中的View可能会没有效果，特别是对于有位移的时候。但属性动画就没有问题，View就是真实的在移动。</p>

<p>但对于业务逻辑来说，通常动画都用于某个View的入场和出场，所以入场动画做完之前，以及出场动画开始之后，不响应点击事件要好一些，当然，这个就要靠开发者自己去实现了。</p>

<h3>动画可以取消么</h3>

<p>当然可以，都有cancel接口可以调用，但具体影响不太一样。</p>

<p>对于View animation，<a href="https://developer.android.com/reference/android/view/animation/Animation#cancel()">Animation#cancel</a>是会调用onAnimationEnd的，因为它的回调接口没有专门用于cancel的。</p>

<p>但属性动画的回调接口要丰富一些，它有cancel，所以是会回调onAimationCancel的，但不会回调onAnimationEnd。</p>

<h3>动画需要注意的事项</h3>

<p>一定要实现onAnimationCancel，以及onAnimationEnd，如果有涉及状态变更，或者关联其他动画时。要知道动画除了常规结束还会有被cancel掉的可能。</p>

<p>另外，就是对于属性动画，取消有两种方式，一是直接调用<a href="https://developer.android.com/reference/android/animation/Animator#cancel()">Animator#cancel</a>另外一种是调用<a href="https://developer.android.com/reference/android/animation/Animator#end()">Animator#end</a>，两个方法在处理最后的状态时略有差异。end方法会把属性的最终状态设置给属性，然后回调onAnimationEnd，但cancel就直接终止动画了，属性当前啥状态那就啥状态，然后回调onAnimationCancel。其实，大多数情况下，end更为合理，但end可能会造成视觉上的跳跃，属性的状态会突然变化。</p>

<p>再有就是，如果对于View，有多个属性同时做动画时，用ViewPropertyAnimator更好一些。语法上面也更简洁，性能上也略优一些。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Animation Advanced Tricks]]></title>
    <link href="http://toughcoder.net/blog/2021/09/04/android-animation-advanced-tricks/"/>
    <updated>2021-09-04T11:45:13+08:00</updated>
    <id>http://toughcoder.net/blog/2021/09/04/android-animation-advanced-tricks</id>
    <content type="html"><![CDATA[<p><a href="http://toughcoder.net/blog/2021/08/19/android-animation-made-easy/">前面的文章</a>介绍了动画的基本使用方法，本文来聊一聊涉及到动画的高级技巧，以及一些非常优质的学习资源和动画三方库和框架。</p>

<p><a href=""><img src="https://cdn.wccftech.com/wp-content/uploads/2020/04/Animations.png" title="auto auto" ></a></p>

<!-- more -->


<h2>页面之间的过渡动画</h2>

<p>常规的动画都是针对某一页面上的某个元素做动画，这个相对简单，<a href="http://toughcoder.net/blog/2021/08/19/android-animation-made-easy/">之前的文章</a>讲了很多。但有时候页面与页面之间也是需要过渡动画的，这个可以加强切换的视觉体验，但最好要注意整个应用内的风格统一，不能A到B是一种切换样式，B到C却是另外一种。</p>

<p>主要有两类，一是Activity之间的切换，二是布局之间的切换。</p>

<h3>Activity之间的切换动画</h3>

<p>因为Activity的创建与启动以及它的Window的创建和显示都是由Frameworks来控制的，甚至于Activity里面的布局何时加载也是由系统决定的，所以对于Activity之间的切换严重依赖于Frameworks，而不同版本的安卓，支持的情况还不一样。</p>

<h4>传统的做法</h4>

<p>这个是针对 于所有安卓 版本都可以使用的方法，也是最简单的方式，就是使用<a href="https://developer.android.com/reference/android/app/Activity#overridePendingTransition(int,%20int)">Activity#overridePendingTransition</a>方法。</p>

<p>这个方法并不难，具体如何使用可以参考其文档，以及<a href="https://blog.csdn.net/ccpat/article/details/84883418">这篇文章</a>，讲的都比较清楚。</p>

<h4>使用Transition</h4>

<p>在Android 4.4时，系统中加入了一个叫做Transition的东西，专门用于页面之间的切换的，但也仅是限于同一个窗口（也即同一个Activity内）的ViewGroup。在Android 5.0时又把Activity之间的切换提供了支持，对于5.0以上的版本可以使用这个框架来实现切换，会比传统的做法都要专业一些。</p>

<p>具体可以参看<a href="https://developer.android.com/training/transitions/start-activity">官方教程</a>，以及<a href="https://www.jianshu.com/p/a43daa1e3d6e">这篇教程</a>和<a href="https://guides.codepath.com/android/shared-element-activity-transition">这篇文章</a>，讲解的都相当好。</p>

<h3>布局之间的过渡切换</h3>

<p>这里的布局就是指除Activity以外的，比如从一个ViewGroup切换到另外一个ViewGroup。其实Fragment本质上就是一个ViewGroup，所以也包含在内。</p>

<p>在Android 4.4 (Kikat API 19)，加入了<a href="https://developer.android.com/reference/android/transition/Transition">Transition frameworks</a>，专门用于解决场景切换，主要是通过Scene对象和Transition对象。Transition对象定义具体针对 哪个ViewGroup做什么样的动画，而Scene对象定义了ViewGroup的某一种状态，如渐变进入，那么渐变前是一个Scene，完全可见后又是一个Scene，而渐变的过程则叫Transition。</p>

<p><img src="https://developer.android.com/images/transitions/transitions_diagram.png" alt="" /></p>

<p>可以参看<a href="https://developer.android.com/training/transitions">官方文档</a>，以详细了解如何使用transition。</p>

<h2>复杂动画的实现逻辑</h2>

<p>动画是一个非常复杂且精深的领域，千万不要说做个UI很容易，或者说写个动画很容易，要想做好动画需要很深的功底，不但需要对动画框架有深入的了解，也要对整个视觉GUI有深入的理解，并且需要良好的数学与物理知识。</p>

<p>复杂的动画的复杂度体现在两个方面，一个是整体上看起来复杂，也就是是很多不同的动画的组合；另外一个是具体的某个属性复杂，如复杂的路径，复杂的时间变化或者复杂的形变。分开说。</p>

<h4>看起来复杂的动画</h4>

<p>这一般是涉及众多的动画的组合，整体表现上看起来特别复杂。就比如说电商可能会有一个购物筐，里面往外飞各种商品的动画。对于这种就是要把它拆解，拆解开来后，其实并不复杂。</p>

<p><img src="http://pic.90sjimg.com/design/03/61/36/24/5d71ce10b36d1.png" alt="" /></p>

<ul>
<li>购物车：可以是渐变，不断的从透明变到不透明。或者干脆不做动画</li>
<li>商品：预定义一组商品，每次随机选择一个，再选择随机的位置，然后从底下往上飞（或者从上往下飞），再设置一个随机的速度，也可以加上旋转</li>
</ul>


<p>这样拆解开来就不复杂了。</p>

<h4>复杂的变幻</h4>

<p>这里就要涉及一些数学 和物理知识了，比如用一些特别的曲线，特殊的曲面，特殊的形变等。</p>

<h2>优秀的动画的设计范例</h2>

<p>这里就不得不得提到大名顶顶的<a href="https://dribbble.com/">Dribbble</a>了，这里有相当优秀的设计资源，其中也有很多<a href="https://dribbble.com/shots/popular/animation">动画设计</a>，可以尝试着去实现一下，都很有挑战。</p>

<h2>优秀的动画相关资源</h2>

<p>还有一些资源，特别是开源的库，也非常值得学习和研究和使用。</p>

<h4><a href="https://developer.android.com/reference/androidx/constraintlayout/motion/widget/MotionLayout">MotionLayout</a></h4>

<p>这个并不是三方的，而是官方AndroidX中的，相当的强大，当然使用起来也略复杂。具体使用方法可以参考 <a href="https://developer.android.com/training/constraint-layout/motionlayout">官方教程</a>和<a href="https://www.nomtek.com/blog/motionlayout">这篇文章</a>。</p>

<h4><a href="https://awesomeopensource.com/projects/android-animation">The Top 27 Android Animation Open Source Projects</a></h4>

<p>这里是一个集合，里面列出一些优秀的动画相关的开源库，都相当的棒。</p>

<h4><a href="https://github.com/daimajia/AndroidViewAnimations">Android View Animations</a></h4>

<p>有一些针对View的非常炫酷的特效，如抖动，缩放和旋转等。它是受一个<a href="https://github.com/ArtFeel/AFViewShaker">水果上面的动画库</a>的激发。</p>

<h4><a href="https://github.com/lgvalle/Material-Animations">Material-Animations</a></h4>

<p>主要是介绍如何使用Transition frameworks的。</p>

<h4><a href="https://github.com/airbnb/lottie-android">Lottie</a></h4>

<p>可以把设计软件Adobe After Effects直接转成动画。</p>

<h4>一些插值器</h4>

<p>可看<a href="https://github.com/daimajia/AnimationEasingFunctions">这个</a>和<a href="https://easings.net/">这个</a></p>

<h4><a href="https://github.com/ybq/Android-SpinKit">专门用于加载动画</a></h4>

<p>里面有各种神奇的加载特效，非常棒。是一个<a href="https://github.com/tobiasahlin/SpinKit">前端CSS加载特效</a>的Android上的实现。</p>

<h4><a href="https://github.com/OCNYang/Android-Animation-Set">教程的示例</a></h4>

<p>这是一个教程集锦，里面也包含各种示例，是一个相当不错的学习资源。</p>

<h4><a href="https://github.com/REBOOTERS/AndroidAnimationExercise">另外一个教程和示例</a></h4>

<p>与上面的类似，也是一个集教程与实例在一起的项目。</p>

<h4><a href="https://awesomeopensource.com/project/OCNYang/Android-Animation-Set">Android Animation Detailed Tutorials</a></h4>

<p>一个项目的合集。</p>
]]></content>
  </entry>
  
</feed>
