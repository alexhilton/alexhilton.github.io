<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2021-09-14T22:43:45+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Android Animation Internal Secrets]]></title>
    <link href="http://toughcoder.net/blog/2021/09/14/android-animation-internal-secrets/"/>
    <updated>2021-09-14T21:07:00+08:00</updated>
    <id>http://toughcoder.net/blog/2021/09/14/android-animation-internal-secrets</id>
    <content type="html"><![CDATA[<p>前面的文章重点讲了如何使用安卓平台提供的能力来做好一个动画。为了更深入的理解，需要去了解一下动画框架的内部机理，这样能够帮助我们做出更优雅的动画实现。</p>

<p><a href=""><img src="https://miro.medium.com/max/2732/1*u5Fiyt4kb0RyYF_J-8CmwA.jpeg" title="auto auto" ></a></p>

<!-- more -->


<h2><a href="https://developer.android.com/guide/topics/graphics/view-animation">View Animation</a>的原理</h2>

<h3>View Animation源码解析</h3>

<p>View animation的代码都是在<a href="https://developer.android.com/reference/android/view/animation/package-summary">android.view.animation</a>包下面。</p>

<p>这里面主要有三个东西，下面来分别仔细说说</p>

<h4><a href=".https://developer.android.com/reference/android/view/animation/Animation">Animation</a></h4>

<p>主要是抽象类<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/animation/Animation.java">Animation</a>以及它的四大子类，也是View animation中的四大变幻对象&ndash;位移变幻<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/animation/TranslateAnimation.java">TranslateAnimation</a>，缩放变幻<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/animation/ScaleAnimation.java">ScaleAnimation</a>，旋转变幻<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/animation/RotateAnimation.java">RotateAnimation</a>和渐变变幻<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/animation/AlphaAnimation.java">AlphaAnimation</a>。</p>

<p>以及一些工具对象，如<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/animation/AnimationSet.java">AnimationSet</a>和<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/animation/AnimationUtils.java">AnimationUtils</a>。</p>

<p>仔细看这些类的源码可以发现，其实它们不复杂，里面也没啥东西，主要是用于各种参数管理，相当于封装出来的工具和原料，具体内部的原理并不在这里。仔细看四大变幻的<a href="https://developer.android.com/reference/android/view/animation/Animation#applyTransformation(float,%20android.view.animation.Transformation)">applyTransformation</a>方法，可以发现这一坨把最接近『原理』的东西都放在了一个叫做Transformation的对象中去了。</p>

<h4><a href="https://developer.android.com/reference/android/view/animation/Transformation">Transformation</a></h4>

<p>直译变幻，但文档中的定义是动画过程中某一时刻应该做的变幻，此为<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/animation/Transformation.java">Transformation</a>。</p>

<p>这货的实现也不复杂，它也就是个中间商，只是一个存储从Animation传过来的参数 的中间变量，它里面有一个Alpha成员参数用以保存当前的渐变参数值，以及一个<a href="https://developer.android.com/reference/android/graphics/Matrix">Matrix</a>，Matrix可以保存当前的位移，旋转和缩放。Matrix应该不算太陌生，处理过<a href="https://developer.android.com/reference/android/graphics/Bitmap">Bitmap</a>变幻的同学，对它应该会有了解，都是通过Matrix来设置参数的。</p>

<h4><a href="https://developer.android.com/reference/android/view/animation/Interpolator">Interpolator</a></h4>

<p>动画是随时间变化的一系列视觉变幻，因人眼视觉残留，连在一起就是动画，跟电影是一个道理。这里就有一个非常关键的参数就是时间。时间对于动画来说体现在两方面一是时长，就是整个动画持续 的时间，另外一个就是变幻变化的速率，也就是说动画播放速度的变化率。其实，这里变化的并不是时间，时间是永恒的以固定速度在流逝，对于动画来说，帧率是固定的，后面会谈到，动画的帧率是由时间驱动器驱动的，它是以固定的时间脉冲来回调渲染动画的每一帧。这里的时间变化其实是做动画的每一帧时用到的参数 的变化，它并不是线性的，假设动画一共有10帧，要把View向右移动100px，默认是线性的，匀速的，也即每一帧都向前移动10px，但如果使用加速插值器，那么可能就是一个变加速运动，第1帧可能在0px，第2帧在5px，第3帧25px，第4帧到36px，以此类推。</p>

<p>时间插值器，就是用来调整播放速度的，用以实现时间变化。</p>

<h3>View Animation的渲染原理</h3>

<p>从前面的讨论来看，动画的渲染跟那几个对象都没有关系，使用View animation的时候，只有两种方法可以让动画生效，一是调用<a href="https://developer.android.com/reference/android/view/View?hl=en#startAnimation(android.view.animation.Animation)">View#startAnimation</a>，另外一个是<a href="https://developer.android.com/reference/android/view/View?hl=en#setAnimation(android.view.animation.Animation)">View#setAnimation</a>，然后再<a href="https://developer.android.com/reference/kotlin/android/view/animation/Animation?hl=en#start()">Animation#start</a>。</p>

<p>假如没有把Animation塞给某一个具体的View对象，光是startAnimation，是不会有任何影响和效果的。这说明动画的渲染是在View对象draw时做的，没有与具体View对象建立关联的动画是没有任何效果的。所以动画的渲染主要还要看View本身的逻辑。</p>

<p>可以从View#setAnimation和View#startAnimation入手来看，这两个方法只是把外部传进来的Animation对象保存在了一个叫做mCurrentAnimation成员里面，其他的什么也没做。查询索引，关键的地方有两个，一个是View#applyLegacyAnimation方法，另外一个就是View#draw方法。</p>

<p>先来看View#applyLegacyAnimation方法：</p>

<pre><code class="java">   /**
     * Utility function, called by draw(canvas, parent, drawingTime) to handle the less common
     * case of an active Animation being run on the view.
     */
    private boolean applyLegacyAnimation(ViewGroup parent, long drawingTime,
            Animation a, boolean scalingRequired) {
        Transformation invalidationTransform;
        final int flags = parent.mGroupFlags;
        final boolean initialized = a.isInitialized();
        if (!initialized) {
            a.initialize(mRight - mLeft, mBottom - mTop, parent.getWidth(), parent.getHeight());
            a.initializeInvalidateRegion(0, 0, mRight - mLeft, mBottom - mTop);
            if (mAttachInfo != null) a.setListenerHandler(mAttachInfo.mHandler);
            onAnimationStart();
        }

        final Transformation t = parent.getChildTransformation();
        boolean more = a.getTransformation(drawingTime, t, 1f);
        if (scalingRequired &amp;&amp; mAttachInfo.mApplicationScale != 1f) {
            if (parent.mInvalidationTransformation == null) {
                parent.mInvalidationTransformation = new Transformation();
            }
            invalidationTransform = parent.mInvalidationTransformation;
            a.getTransformation(drawingTime, invalidationTransform, 1f);
        } else {
            invalidationTransform = t;
        }

        if (more) {
            if (!a.willChangeBounds()) {
                if ((flags &amp; (ViewGroup.FLAG_OPTIMIZE_INVALIDATE | ViewGroup.FLAG_ANIMATION_DONE)) ==
                        ViewGroup.FLAG_OPTIMIZE_INVALIDATE) {
                    parent.mGroupFlags |= ViewGroup.FLAG_INVALIDATE_REQUIRED;
                } else if ((flags &amp; ViewGroup.FLAG_INVALIDATE_REQUIRED) == 0) {
                    // The child need to draw an animation, potentially offscreen, so
                    // make sure we do not cancel invalidate requests
                    parent.mPrivateFlags |= PFLAG_DRAW_ANIMATION;
                    parent.invalidate(mLeft, mTop, mRight, mBottom);
                }
            } else {
                if (parent.mInvalidateRegion == null) {
                    parent.mInvalidateRegion = new RectF();
                }
                final RectF region = parent.mInvalidateRegion;
                a.getInvalidateRegion(0, 0, mRight - mLeft, mBottom - mTop, region,
                        invalidationTransform);

                // The child need to draw an animation, potentially offscreen, so
                // make sure we do not cancel invalidate requests
                parent.mPrivateFlags |= PFLAG_DRAW_ANIMATION;

                final int left = mLeft + (int) region.left;
                final int top = mTop + (int) region.top;
                parent.invalidate(left, top, left + (int) (region.width() + .5f),
                        top + (int) (region.height() + .5f));
            }
        }
        return more;
    }
</code></pre>

<p>这个方法看着比较长，但它就做了三件事情：1）初始化动画；2）获取当前时刻的Transformation；3）如果动画还没有完（还有下一帧），那就得调用View的invalidate，得重绘。</p>

<p>再看使用此方法的地方，是在draw，需要注意是带有三个参数的那个draw，在<a href="http://toughcoder.net/blog/2020/07/26/android-view-render-flow/">前面的文章里面</a>介绍过，这个draw方法是由ViewGroup#dispatchDraw中drawChild时调用的：</p>

<pre><code class="java">   /**
     * This method is called by ViewGroup.drawChild() to have each child view draw itself.
     *
     * This is where the View specializes rendering behavior based on layer type,
     * and hardware acceleration.
     */
    boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) {
        final boolean hardwareAcceleratedCanvas = canvas.isHardwareAccelerated();
        /* If an attached view draws to a HW canvas, it may use its RenderNode + DisplayList.
         *
         * If a view is dettached, its DisplayList shouldn't exist. If the canvas isn't
         * HW accelerated, it can't handle drawing RenderNodes.
         */
        boolean drawingWithRenderNode = mAttachInfo != null
                &amp;&amp; mAttachInfo.mHardwareAccelerated
                &amp;&amp; hardwareAcceleratedCanvas;

        boolean more = false;
        final boolean childHasIdentityMatrix = hasIdentityMatrix();
        final int parentFlags = parent.mGroupFlags;

        if ((parentFlags &amp; ViewGroup.FLAG_CLEAR_TRANSFORMATION) != 0) {
            parent.getChildTransformation().clear();
            parent.mGroupFlags &amp;= ~ViewGroup.FLAG_CLEAR_TRANSFORMATION;
        }

        Transformation transformToApply = null;
        boolean concatMatrix = false;
        final boolean scalingRequired = mAttachInfo != null &amp;&amp; mAttachInfo.mScalingRequired;
        final Animation a = getAnimation();
        if (a != null) {
            more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired);
            concatMatrix = a.willChangeTransformationMatrix();
            if (concatMatrix) {
                mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
            }
            transformToApply = parent.getChildTransformation();
        } else {
            if ((mPrivateFlags3 &amp; PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) != 0) {
                // No longer animating: clear out old animation matrix
                mRenderNode.setAnimationMatrix(null);
                mPrivateFlags3 &amp;= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM;
            }
            if (!drawingWithRenderNode
                    &amp;&amp; (parentFlags &amp; ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) {
                final Transformation t = parent.getChildTransformation();
                final boolean hasTransform = parent.getChildStaticTransformation(this, t);
                if (hasTransform) {
                    final int transformType = t.getTransformationType();
                    transformToApply = transformType != Transformation.TYPE_IDENTITY ? t : null;
                    concatMatrix = (transformType &amp; Transformation.TYPE_MATRIX) != 0;
                }
            }
        }

        concatMatrix |= !childHasIdentityMatrix;

        // Sets the flag as early as possible to allow draw() implementations
        // to call invalidate() successfully when doing animations
        mPrivateFlags |= PFLAG_DRAWN;

        if (!concatMatrix &amp;&amp;
                (parentFlags &amp; (ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS |
                        ViewGroup.FLAG_CLIP_CHILDREN)) == ViewGroup.FLAG_CLIP_CHILDREN &amp;&amp;
                canvas.quickReject(mLeft, mTop, mRight, mBottom) &amp;&amp;
                (mPrivateFlags &amp; PFLAG_DRAW_ANIMATION) == 0) {
            mPrivateFlags2 |= PFLAG2_VIEW_QUICK_REJECTED;
            return more;
        }
        mPrivateFlags2 &amp;= ~PFLAG2_VIEW_QUICK_REJECTED;

        if (hardwareAcceleratedCanvas) {
            // Clear INVALIDATED flag to allow invalidation to occur during rendering, but
            // retain the flag's value temporarily in the mRecreateDisplayList flag
            mRecreateDisplayList = (mPrivateFlags &amp; PFLAG_INVALIDATED) != 0;
            mPrivateFlags &amp;= ~PFLAG_INVALIDATED;
        }

        RenderNode renderNode = null;
        Bitmap cache = null;
        int layerType = getLayerType(); // TODO: signify cache state with just 'cache' local
        if (layerType == LAYER_TYPE_SOFTWARE || !drawingWithRenderNode) {
             if (layerType != LAYER_TYPE_NONE) {
                 // If not drawing with RenderNode, treat HW layers as SW
                 layerType = LAYER_TYPE_SOFTWARE;
                 buildDrawingCache(true);
            }
            cache = getDrawingCache(true);
        }

        if (drawingWithRenderNode) {
            // Delay getting the display list until animation-driven alpha values are
            // set up and possibly passed on to the view
            renderNode = updateDisplayListIfDirty();
            if (!renderNode.hasDisplayList()) {
                // Uncommon, but possible. If a view is removed from the hierarchy during the call
                // to getDisplayList(), the display list will be marked invalid and we should not
                // try to use it again.
                renderNode = null;
                drawingWithRenderNode = false;
            }
        }

        int sx = 0;
        int sy = 0;
        if (!drawingWithRenderNode) {
            computeScroll();
            sx = mScrollX;
            sy = mScrollY;
        }

        final boolean drawingWithDrawingCache = cache != null &amp;&amp; !drawingWithRenderNode;
        final boolean offsetForScroll = cache == null &amp;&amp; !drawingWithRenderNode;

        int restoreTo = -1;
        if (!drawingWithRenderNode || transformToApply != null) {
            restoreTo = canvas.save();
        }
        if (offsetForScroll) {
            canvas.translate(mLeft - sx, mTop - sy);
        } else {
            if (!drawingWithRenderNode) {
                canvas.translate(mLeft, mTop);
            }
            if (scalingRequired) {
                if (drawingWithRenderNode) {
                    // TODO: Might not need this if we put everything inside the DL
                    restoreTo = canvas.save();
                }
                // mAttachInfo cannot be null, otherwise scalingRequired == false
                final float scale = 1.0f / mAttachInfo.mApplicationScale;
                canvas.scale(scale, scale);
            }
        }

        float alpha = drawingWithRenderNode ? 1 : (getAlpha() * getTransitionAlpha());
        if (transformToApply != null
                || alpha &lt; 1
                || !hasIdentityMatrix()
                || (mPrivateFlags3 &amp; PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) {
            if (transformToApply != null || !childHasIdentityMatrix) {
                int transX = 0;
                int transY = 0;

                if (offsetForScroll) {
                    transX = -sx;
                    transY = -sy;
                }

                if (transformToApply != null) {
                    if (concatMatrix) {
                        if (drawingWithRenderNode) {
                            renderNode.setAnimationMatrix(transformToApply.getMatrix());
                        } else {
                            // Undo the scroll translation, apply the transformation matrix,
                            // then redo the scroll translate to get the correct result.
                            canvas.translate(-transX, -transY);
                            canvas.concat(transformToApply.getMatrix());
                            canvas.translate(transX, transY);
                        }
                        parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                    }

                    float transformAlpha = transformToApply.getAlpha();
                    if (transformAlpha &lt; 1) {
                        alpha *= transformAlpha;
                        parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                    }
                }

                if (!childHasIdentityMatrix &amp;&amp; !drawingWithRenderNode) {
                    canvas.translate(-transX, -transY);
                    canvas.concat(getMatrix());
                    canvas.translate(transX, transY);
                }
            }

            // Deal with alpha if it is or used to be &lt;1
            if (alpha &lt; 1 || (mPrivateFlags3 &amp; PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) {
                if (alpha &lt; 1) {
                    mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA;
                } else {
                    mPrivateFlags3 &amp;= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA;
                }
                parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION;
                if (!drawingWithDrawingCache) {
                    final int multipliedAlpha = (int) (255 * alpha);
                    if (!onSetAlpha(multipliedAlpha)) {
                        if (drawingWithRenderNode) {
                            renderNode.setAlpha(alpha * getAlpha() * getTransitionAlpha());
                        } else if (layerType == LAYER_TYPE_NONE) {
                            canvas.saveLayerAlpha(sx, sy, sx + getWidth(), sy + getHeight(),
                                    multipliedAlpha);
                        }
                    } else {
                        // Alpha is handled by the child directly, clobber the layer's alpha
                        mPrivateFlags |= PFLAG_ALPHA_SET;
                    }
                }
            }
        } else if ((mPrivateFlags &amp; PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
            onSetAlpha(255);
            mPrivateFlags &amp;= ~PFLAG_ALPHA_SET;
        }

        if (!drawingWithRenderNode) {
            // apply clips directly, since RenderNode won't do it for this draw
            if ((parentFlags &amp; ViewGroup.FLAG_CLIP_CHILDREN) != 0 &amp;&amp; cache == null) {
                if (offsetForScroll) {
                    canvas.clipRect(sx, sy, sx + getWidth(), sy + getHeight());
                } else {
                    if (!scalingRequired || cache == null) {
                        canvas.clipRect(0, 0, getWidth(), getHeight());
                    } else {
                        canvas.clipRect(0, 0, cache.getWidth(), cache.getHeight());
                    }
                }
            }

            if (mClipBounds != null) {
                // clip bounds ignore scroll
                canvas.clipRect(mClipBounds);
            }
        }

        if (!drawingWithDrawingCache) {
            if (drawingWithRenderNode) {
                mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;
                ((RecordingCanvas) canvas).drawRenderNode(renderNode);
            } else {
                // Fast path for layouts with no backgrounds
                if ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) {
                    mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;
                    dispatchDraw(canvas);
                } else {
                    draw(canvas);
                }
            }
        } else if (cache != null) {
            mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;
            if (layerType == LAYER_TYPE_NONE || mLayerPaint == null) {
                // no layer paint, use temporary paint to draw bitmap
                Paint cachePaint = parent.mCachePaint;
                if (cachePaint == null) {
                    cachePaint = new Paint();
                    cachePaint.setDither(false);
                    parent.mCachePaint = cachePaint;
                }
                cachePaint.setAlpha((int) (alpha * 255));
                canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint);
            } else {
                // use layer paint to draw the bitmap, merging the two alphas, but also restore
                int layerPaintAlpha = mLayerPaint.getAlpha();
                if (alpha &lt; 1) {
                    mLayerPaint.setAlpha((int) (alpha * layerPaintAlpha));
                }
                canvas.drawBitmap(cache, 0.0f, 0.0f, mLayerPaint);
                if (alpha &lt; 1) {
                    mLayerPaint.setAlpha(layerPaintAlpha);
                }
            }
        }

        if (restoreTo &gt;= 0) {
            canvas.restoreToCount(restoreTo);
        }

        if (a != null &amp;&amp; !more) {
            if (!hardwareAcceleratedCanvas &amp;&amp; !a.getFillAfter()) {
                onSetAlpha(255);
            }
            parent.finishAnimatingView(this, a);
        }

        if (more &amp;&amp; hardwareAcceleratedCanvas) {
            if (a.hasAlpha() &amp;&amp; (mPrivateFlags &amp; PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) {
                // alpha animations should cause the child to recreate its display list
                invalidate(true);
            }
        }

        mRecreateDisplayList = false;

        return more;
    }
</code></pre>

<p>这个方法更长，主要就看transformToApply这个变量就好了，这个变量是在调用了applyLegacyAnimation后被赋值的。之后，可以看到它其中的Matrix被作用于Canvas，而alpha值被用于setAlpha了。好了，这里就是动画的最核心的逻辑。前面说了Transformation对象就是包了一个Matrix和alpha，然后被用在了这里，Matrix作用于<a href="https://developer.android.com/reference/android/graphics/Canvas">Canvas</a>对象，以产生视觉变幻（位移，缩放和旋转），而渐变则是通过setAlpha实现的。</p>

<p>所以View Animation是View tree每次draw的时候去做的，用当前的Animation对象获取到Transformation，然后把Matrix和alpha应用到draw时的Canvas，这就产生了视觉变幻效果。因此，View animation只是放一遍电影，因为这一过程中变化 的只有Transformation对象，也即只有Matrix和alpha在变化，在View draw的时候应用一下就完了，它并没有对View的真实属性产生影响，仅是对渲染的结果Canvas产生影响。而每次View draw的时候，都是会重新生成一个Canvas对象，并且View的属性本身并没有变，所以新生成的Canvas对象并不会体现之前一次draw（也即上一帧）的变幻结果，它只是继续应用Transformation对象，假如动画结束了就没有了Transformation对象，那就没有Matrix和alpha可作用于Canvas，也就没有了动画效果，一切又恢复到了最初原始的样子。</p>

<h2>Property Animation的原理</h2>

<p>属性动画的实现主要是在<a href="https://developer.android.com/reference/kotlin/android/animation/package-summary?hl=en">android.animation</a>里面，它有独立的一级包名，可以看出它在平台中的位置，是要高于View animation的。</p>

<h3>Animator的源码解析</h3>

<p>先从<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/animation/Animator.java">Animator</a>对象看起，它是一个抽象类，只定义了关于动画的基本接口，如duration/start/end/cancel等，以及设置Listener以外，再无其他东西。</p>

<p>最为核心的对象是ValueAnimator，它是属性动画的核心，它主要有两部分，一是管理各种数值，前面的文章说过属性动画的核心原理就是在一定时间内，用一定速率把某个值变成另外一个值；另外一部分就涉及渲染原理，后面再详细说。</p>

<p>再有就是ObjectAnimator，它是ValueAnimator的子类，连同<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/animation/PropertyValuesHolder.java">PropertyValuesHolder</a>一起，针对某个对象的属性进行管理，主要涉及两方面，一个是属性值的管理，也即把对象的属性名字和其要设置的值都暂存起来，另外一部分就是通过反射来把要修改的值作用于目标对象。</p>

<h3>Animator的时间驱动器</h3>

<p>动画要让数值随时间而变化，当start了以后，最重要的事情 就是以一定的时间速率来刷新数值，也即是用一个时间驱动器来刷新每一帧。前面讨论了View animation，是在View tree渲染时去刷新动画的每一帧。</p>

<p>属性动画的核心在ValueAnimator里面，连同一个AnimatorHandler对象，一起实现了时间驱动。AnimatorHanndler是属性动画的时间驱动器，它从<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/Choreographer.java;drc=master;l=82">Choreographer</a>中接收脉冲信号，然后再回调给所有的ValueAnimator，令其doAnimationFrame。它是一个单例，也就是说同一个进程里所有的属性动画用的是内一个时间驱动器，同一个AnimatorHandler。</p>

<p><strong>注意</strong>：关于Choreographer的解释可以看<a href="http://toughcoder.net/blog/2020/07/26/android-view-render-flow/">另外的文章</a>。</p>

<p>当调用ValueAnimator#start时便会往<a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/animation/AnimationHandler.java">AnimatorHandler</a>对象添加一个回调，用以接收do frame的脉冲事件，然后从时间插值器mInterpolator中获取当前的时间速率，再调用animateValue进行数值的改变，其子类可以override此方法以实现属性的具体变化。这里还有一个变量mSelfPulsing用以控制是否使用AnimatorHandler，默认是true，也就是让ValueAnimator使用AnimatorHandler接收来自Choreographer的脉冲信号做动画。此外，也可以自己实现一个时间驱动器。</p>

<p>由此，便可以让在duration之内，渲染动画的每一帧。</p>

<h3>Animator的渲染原理</h3>

<p><a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/animation/ValueAnimator.java">ValueAnimator</a>仅是让一个数值在一定时间内发生特定的变化，它没有实际的视觉效果。常常使用的是ObjectAnimator，并作用于View的属性以产生视觉效果，如前面文章中的例子。那么这个又是如何实现的呢？</p>

<p><a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/animation/ObjectAnimator.java">ObjectAnimator</a>是可能改变某个对象（内部称之为Target对象）的某个属性值，让其随时间变化，当应用到View对象时，比如translationY属性，ObjectAniamtor所做的也仅仅是让translationY的值随时间变化 而已，仅在animateValue时去调用View#setTranslationY把变化的数值传进去。是View自己在做重绘，View的setTranslationY方法中，有做invalidate以进行重绘。由此，便产生了视觉效果。</p>

<p><a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/base/core/java/android/view/ViewPropertyAnimator.java">ViewPropertyAnimator</a>是另一个常用的对象，但发现它并不是Animator的子类，是封装出来的专门针对View对象做属性动画的一个工具类，它本质上与ObjectAnimator一样，只不过做了一些集成与封装，可以同时方便的操作多个属性，另外它会把所有属性的值变更 过后统一调一次invalidate，效率上会略高一筹。ObjectAnimator一次只能操作一个属性，并且每个属性变化 时都会调一次invalidate。</p>

<p>它是把支持的属性都先放进一个map里面暂存起来，当调用startAnimation时，创建一个ValueAnimator，并设置一个AnimatorListener，在onAnimationUpdate时，把前面暂存的属性都设置到mView对象中去，然后调用一次invalidate让mView重绘。这里还需要注意，在设置属性这一块与ObjectAnimator也不一样，前面说了ObjectAniamtor是通过属性的settter来实现的，但View的属性的settter都会触发invalidate。所以，ViewPropertyAnimator为了避免每次设置属性时都触发invalidate，它是直接把属性塞给View的mRenderNode对象，然后在所有变化 的属性都设置完以后，再统一做一次重绘(invalidate)。</p>

<p>另外的区别就是，ViewPropertyAnimator仅支持一些特定的属性，而ObjectAnimator可以支持任意属性（只要有setter/getter，就可以）。</p>

<h2>关于动画的常见问题</h2>

<p>通过上面的论述，就搞清楚了动画原理了，下面来看一些比较有意思的问题。</p>

<h3>动画是在主线程里做的么</h3>

<p>动画主要是通过View对象来呈现视觉效果，View是在主线程中渲染的，所以动画也是在主线程里面完成的。这话呢，只对了一半，或者这么说是不够严谨的。</p>

<p>通过上面的讨论，View animation，都是在主线程中实现的，因为它的时间驱动器是View tree的渲染，也即在draw的时候，去计算当前的Transformation，然后应用到View的Canvas上面。这一切都是在主线程中完成的。</p>

<p>但对于属性动画，就不是这个样子，属性动画分两部分，一部分是让数值随时间变化 ，这个其实可以在任意线程中去做。通过上面的讨论，默认的情况下，确实也是在主线程中做的（从Choreographer得到时间脉冲，这是在主线程里面），但是留 有接口，可以改变的，虽然很少这样做，但确实是可行的，并且数值随时间变化，这个事情也是可以在任意线程中完成的。另外一部分，就是让变化 的数值对目标对象生效，这个要看具体的对象了，如果View，肯定 还是要在主线程里搞。</p>

<h3>动画的帧率（FPS）是多少</h3>

<p>从上面的讨论来看，无论是View animation还是属性动画，时间脉冲都是Choreographer，并且对View来说视觉要生效是通过重绘来做的，所以最高帧率都会是60FPS。</p>

<p>所以，其实动画的帧率是固定的，也就是说其doAnimationFrame是固定频率在回调。</p>

<p>这里要与动画的时间插值器区别开来，动画的真实帧率是固定的，时间插值器的作用是让动画的变化变成非线性的。比如说某个属性x从0变到100，ValueAnimator的doAnimationFrame以及animateValue会是以固定的频率，从Choreographer每隔16ms接收一次脉冲，就会调用一次animateValue，时间插值器的作用，能让x值的变化是非线性的：</p>

<p>时间脉冲：0 1 2 3 4 5 6 7 8 9 10
线性变化：0 10 20 30 40 50 60 70 80 90 100
加速减速：0 13 25 37 57 71 79 85 89 95 100</p>

<p>时间插值器并没有让动画的帧率发生变化 ，而是让动画的结果非线性变化。</p>

<h3>动画过程中如何处理MotionEvent事件</h3>

<p>没有任何影响，view animation是发生在draw的时候，而属性动画是设置属性后再re-draw。从逻辑 上来讲动画与事件不冲突，两者之间没有任何影响。</p>

<p>不过呢，View animation是对Canvas做变幻，View对象仍在原来的位置，原来的状态，所以点击动画过程中的View可能会没有效果，特别是对于有位移的时候。但属性动画就没有问题，View就是真实的在移动。</p>

<p>但对于业务逻辑来说，通常动画都用于某个View的入场和出场，所以入场动画做完之前，以及出场动画开始之后，不响应点击事件要好一些，当然，这个就要靠开发者自己去实现了。</p>

<h3>动画可以取消么</h3>

<p>当然可以，都有cancel接口可以调用，但具体影响不太一样。</p>

<p>对于View animation，<a href="https://developer.android.com/reference/android/view/animation/Animation#cancel()">Animation#cancel</a>是会调用onAnimationEnd的，因为它的回调接口没有专门用于cancel的。</p>

<p>但属性动画的回调接口要丰富一些，它有cancel，所以是会回调onAimationCancel的，但不会回调onAnimationEnd。</p>

<h3>动画需要注意的事项</h3>

<p>一定要实现onAnimationCancel，以及onAnimationEnd，如果有涉及状态变更，或者关联其他动画时。要知道动画除了常规结束还会有被cancel掉的可能。</p>

<p>另外，就是对于属性动画，取消有两种方式，一是直接调用<a href="https://developer.android.com/reference/android/animation/Animator#cancel()">Animator#cancel</a>另外一种是调用<a href="https://developer.android.com/reference/android/animation/Animator#end()">Animator#end</a>，两个方法在处理最后的状态时略有差异。end方法会把属性的最终状态设置给属性，然后回调onAnimationEnd，但cancel就直接终止动画了，属性当前啥状态那就啥状态，然后回调onAnimationCancel。其实，大多数情况下，end更为合理，但end可能会造成视觉上的跳跃，属性的状态会突然变化。</p>

<p>再有就是，如果对于View，有多个属性同时做动画时，用ViewPropertyAnimator更好一些。语法上面也更简洁，性能上也略优一些。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Animation Advanced Tricks]]></title>
    <link href="http://toughcoder.net/blog/2021/09/04/android-animation-advanced-tricks/"/>
    <updated>2021-09-04T11:45:13+08:00</updated>
    <id>http://toughcoder.net/blog/2021/09/04/android-animation-advanced-tricks</id>
    <content type="html"><![CDATA[<p><a href="http://toughcoder.net/blog/2021/08/19/android-animation-made-easy/">前面的文章</a>介绍了动画的基本使用方法，本文来聊一聊涉及到动画的高级技巧，以及一些非常优质的学习资源和动画三方库和框架。</p>

<p><img src="https://cdn.wccftech.com/wp-content/uploads/2020/04/Animations.png" alt="" /></p>

<!-- more -->


<h2>页面之间的过渡动画</h2>

<p>常规的动画都是针对某一页面上的某个元素做动画，这个相对简单，<a href="http://toughcoder.net/blog/2021/08/19/android-animation-made-easy/">之前的文章</a>讲了很多。但有时候页面与页面之间也是需要过渡动画的，这个可以加强切换的视觉体验，但最好要注意整个应用内的风格统一，不能A到B是一种切换样式，B到C却是另外一种。</p>

<p>主要有两类，一是Activity之间的切换，二是布局之间的切换。</p>

<h3>Activity之间的切换动画</h3>

<p>因为Activity的创建与启动以及它的Window的创建和显示都是由Frameworks来控制的，甚至于Activity里面的布局何时加载也是由系统决定的，所以对于Activity之间的切换严重依赖于Frameworks，而不同版本的安卓，支持的情况还不一样。</p>

<h4>传统的做法</h4>

<p>这个是针对 于所有安卓 版本都可以使用的方法，也是最简单的方式，就是使用<a href="https://developer.android.com/reference/android/app/Activity#overridePendingTransition(int,%20int)">Activity#overridePendingTransition</a>方法。</p>

<p>这个方法并不难，具体如何使用可以参考其文档，以及<a href="https://blog.csdn.net/ccpat/article/details/84883418">这篇文章</a>，讲的都比较清楚。</p>

<h4>使用Transition</h4>

<p>在Android 4.4时，系统中加入了一个叫做Transition的东西，专门用于页面之间的切换的，但也仅是限于同一个窗口（也即同一个Activity内）的ViewGroup。在Android 5.0时又把Activity之间的切换提供了支持，对于5.0以上的版本可以使用这个框架来实现切换，会比传统的做法都要专业一些。</p>

<p>具体可以参看<a href="https://developer.android.com/training/transitions/start-activity">官方教程</a>，以及<a href="https://www.jianshu.com/p/a43daa1e3d6e">这篇教程</a>和<a href="https://guides.codepath.com/android/shared-element-activity-transition">这篇文章</a>，讲解的都相当好。</p>

<h3>布局之间的过渡切换</h3>

<p>这里的布局就是指除Activity以外的，比如从一个ViewGroup切换到另外一个ViewGroup。其实Fragment本质上就是一个ViewGroup，所以也包含在内。</p>

<p>在Android 4.4 (Kikat API 19)，加入了<a href="https://developer.android.com/reference/android/transition/Transition">Transition frameworks</a>，专门用于解决场景切换，主要是通过Scene对象和Transition对象。Transition对象定义具体针对 哪个ViewGroup做什么样的动画，而Scene对象定义了ViewGroup的某一种状态，如渐变进入，那么渐变前是一个Scene，完全可见后又是一个Scene，而渐变的过程则叫Transition。</p>

<p><img src="https://developer.android.com/images/transitions/transitions_diagram.png" alt="" /></p>

<p>可以参看<a href="https://developer.android.com/training/transitions">官方文档</a>，以详细了解如何使用transition。</p>

<h2>复杂动画的实现逻辑</h2>

<p>动画是一个非常复杂且精深的领域，千万不要说做个UI很容易，或者说写个动画很容易，要想做好动画需要很深的功底，不但需要对动画框架有深入的了解，也要对整个视觉GUI有深入的理解，并且需要良好的数学与物理知识。</p>

<p>复杂的动画的复杂度体现在两个方面，一个是整体上看起来复杂，也就是是很多不同的动画的组合；另外一个是具体的某个属性复杂，如复杂的路径，复杂的时间变化或者复杂的形变。分开说。</p>

<h4>看起来复杂的动画</h4>

<p>这一般是涉及众多的动画的组合，整体表现上看起来特别复杂。就比如说电商可能会有一个购物筐，里面往外飞各种商品的动画。对于这种就是要把它拆解，拆解开来后，其实并不复杂。</p>

<p><img src="http://pic.90sjimg.com/design/03/61/36/24/5d71ce10b36d1.png" alt="" /></p>

<ul>
<li>购物车：可以是渐变，不断的从透明变到不透明。或者干脆不做动画</li>
<li>商品：预定义一组商品，每次随机选择一个，再选择随机的位置，然后从底下往上飞（或者从上往下飞），再设置一个随机的速度，也可以加上旋转</li>
</ul>


<p>这样拆解开来就不复杂了。</p>

<h4>复杂的变幻</h4>

<p>这里就要涉及一些数学 和物理知识了，比如用一些特别的曲线，特殊的曲面，特殊的形变等。</p>

<h2>优秀的动画的设计范例</h2>

<p>这里就不得不得提到大名顶顶的<a href="https://dribbble.com/">Dribbble</a>了，这里有相当优秀的设计资源，其中也有很多<a href="https://dribbble.com/shots/popular/animation">动画设计</a>，可以尝试着去实现一下，都很有挑战。</p>

<h2>优秀的动画相关资源</h2>

<p>还有一些资源，特别是开源的库，也非常值得学习和研究和使用。</p>

<h4><a href="https://developer.android.com/reference/androidx/constraintlayout/motion/widget/MotionLayout">MotionLayout</a></h4>

<p>这个并不是三方的，而是官方AndroidX中的，相当的强大，当然使用起来也略复杂。具体使用方法可以参考 <a href="https://developer.android.com/training/constraint-layout/motionlayout">官方教程</a>和<a href="https://www.nomtek.com/blog/motionlayout">这篇文章</a>。</p>

<h4><a href="https://awesomeopensource.com/projects/android-animation">The Top 27 Android Animation Open Source Projects</a></h4>

<p>这里是一个集合，里面列出一些优秀的动画相关的开源库，都相当的棒。</p>

<h4><a href="https://github.com/daimajia/AndroidViewAnimations">Android View Animations</a></h4>

<p>有一些针对View的非常炫酷的特效，如抖动，缩放和旋转等。它是受一个<a href="https://github.com/ArtFeel/AFViewShaker">水果上面的动画库</a>的激发。</p>

<h4><a href="https://github.com/lgvalle/Material-Animations">Material-Animations</a></h4>

<p>主要是介绍如何使用Transition frameworks的。</p>

<h4><a href="https://github.com/airbnb/lottie-android">Lottie</a></h4>

<p>可以把设计软件Adobe After Effects直接转成动画。</p>

<h4>一些插值器</h4>

<p>可看<a href="https://github.com/daimajia/AnimationEasingFunctions">这个</a>和<a href="https://easings.net/">这个</a></p>

<h4><a href="https://github.com/ybq/Android-SpinKit">专门用于加载动画</a></h4>

<p>里面有各种神奇的加载特效，非常棒。是一个<a href="https://github.com/tobiasahlin/SpinKit">前端CSS加载特效</a>的Android上的实现。</p>

<h4><a href="https://github.com/OCNYang/Android-Animation-Set">教程的示例</a></h4>

<p>这是一个教程集锦，里面也包含各种示例，是一个相当不错的学习资源。</p>

<h4><a href="https://github.com/REBOOTERS/AndroidAnimationExercise">另外一个教程和示例</a></h4>

<p>与上面的类似，也是一个集教程与实例在一起的项目。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Animation Made Easy]]></title>
    <link href="http://toughcoder.net/blog/2021/08/19/android-animation-made-easy/"/>
    <updated>2021-08-19T22:37:34+08:00</updated>
    <id>http://toughcoder.net/blog/2021/08/19/android-animation-made-easy</id>
    <content type="html"><![CDATA[<p>动画在任何一个GUI系统中都是一个非常重要的设计元素，它可以让交互变得优雅，让界面变得炫酷，让操作变得更加的舒畅，让状态过渡变得更加的顺滑，对视觉效果有极大的提升，时而提升用户体验，特别是对于移动应用来说，更是如此。就好比水果平台，最为吸引人的地方就在于其炫酷流畅的动画效果。早期的Android，在动画这一块确实差，不过，近些年，随着谷歌不断的加大力度在提升，现在来说安卓在动画这一块已经跟水果差不多了。今天就来聊一聊关于动画的话题。</p>

<p><a href=""><img src="https://files.betamax.raywenderlich.com/attachments/collections/291/dae8aa75-8ccb-4b2f-a98d-3d2230b63ed9.png"></a></p>

<!-- more -->


<h2>动画的种类</h2>

<p>一般来说动画分为二个种类：</p>

<h3>逐帧动画(Frame Animation)也叫做<a href="http://developer.android.com/intl/zh-cn/guide/topics/graphics/drawable-animation.html">Drawable Animation</a></h3>

<p>也就是电影胶片式的，一张张不同的画连在一起播放，比较简单，只需要准备足够帧数（数量）的图片，就可以了。缺点也比较明显，需要比较多的资源（图片，存储空间，内存空间以及CPU资源）。并且灵活性非常的差，不能让普通的一段文字或者一个按扭进行动画。
针对某些特别简单的动画可以用此方式来实现，比如像简单的进度条，或者滑动引导提示等，具体的方式就是：</p>

<pre><code>&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android"
    android:oneshot="true"&gt;    
    &lt;item android:drawable="@drawable/rocket_thrust1" android:duration="200" /&gt;
    &lt;item android:drawable="@drawable/rocket_thrust2" android:duration="200" /&gt;
    &lt;item android:drawable="@drawable/rocket_thrust3" android:duration="200" /&gt;
&lt;/animation-list&gt;
</code></pre>

<h3>补间动画（Tween Animation）</h3>

<p>补间动画比帧动画就要高级一些，因为充分利用了计算机的特性，只需要告诉起始状态和结束状态，然后让计算机去计算中间的状态，再不用把每一帧都告诉计算机了。在安卓中就是<a href="http://developer.android.com/intl/zh-cn/guide/topics/graphics/view-animation.html">View Animation</a>，以及后来的强大的<a href="http://developer.android.com/intl/zh-cn/guide/topics/graphics/prop-animation.html">Property Animation</a>。</p>

<h2>动画的基本原理</h2>

<p>动画，其实就是一组快速播放的幻灯片，每一张（每一帧）的状态略有不同，快速连起来播放，由于人的眼睛有视觉残留效应，这就形成了动画。对于计算机程序来说，一般的动画就是给定对象的初始和终末状态，在一定时间内，不断的计算中间过程，并以视觉的方式展示出来，这就是动画。</p>

<p><img src="https://developer.android.com/images/animation/animation-linear.png" alt="" /></p>

<h2>动画的关键要素</h2>

<p>一个动画必须要有以下关键的要素：</p>

<ul>
<li>时长(Duration)，也就 说播放动画的总时长，系统默认是300ms</li>
<li>时间插值器(Interpolation)，就是动画的关键参数随时间要如何变化</li>
<li>重播(Repeat)，包括重播的次数以及方式，次数好理解，方式的意思是，可以顺序的一遍一遍的播，也是可以反着播</li>
<li>延迟(Delay)，动画启动的延时，通常用在动画组合里面。</li>
</ul>


<h2>View Animation</h2>

<p>这是从安卓一开始就支持的动画方式，仅能对View对象生效，使用起来也比较方便和简单，通过组合和自定义插值器，足以实现常用的视觉变幻（如渐变，旋转，缩放和位移）。</p>

<p>主要有四种<a href="http://developer.android.com/intl/zh-cn/reference/android/view/animation/TranslateAnimation.html">位移(translation)</a>，<a href="http://developer.android.com/intl/zh-cn/reference/android/view/animation/AlphaAnimation.html">透明度(alpha)</a>，<a href="http://developer.android.com/intl/zh-cn/reference/android/view/animation/RotateAnimation.html">旋转(rotation)</a>和<a href="http://developer.android.com/intl/zh-cn/reference/android/view/animation/ScaleAnimation.html">缩放(scaling)</a>。还可以以<a href="http://developer.android.com/intl/zh-cn/reference/android/view/animation/AnimationSet.html">集合</a>的方式来把几个动画合在一起播放。可以设置动画的时长(duration)，<a href="http://developer.android.com/intl/zh-cn/reference/android/view/animation/Interpolator.html">速率(interpolator)</a>，重复和事件的<a href="http://developer.android.com/intl/zh-cn/reference/android/view/animation/Animation.AnimationListener.html">监听</a>。
一些使用建议：</p>

<ul>
<li>所有这些东西都是放在<a href="http://developer.android.com/intl/zh-cn/reference/android/view/animation/package-summary.html">android.view.animation</a>包下面的，所以这些东西只能用于View对象。其实绝大多数时候，这也不是问题，除了View，还有啥要做动画呢。</li>
<li><a href="http://developer.android.com/intl/zh-cn/reference/android/view/animation/TranslateAnimation.html">TranslateAnimation</a>只能是直线运动，如果要曲线，就得自定义，可以参考<a href="http://guoh.org/lifelog/2012/04/android-customized-curved-path-animation/">这个</a>。</li>
<li>scale可以实现水平或者垂直翻转。</li>
<li><p>动画的触发是当View需要<a href="http://developer.android.com/intl/zh-cn/reference/android/view/View.html#invalidate(">invalidate</a>)的时候就会触发<a href="http://developer.android.com/intl/zh-cn/reference/android/view/View.html#setAnimation(android.view.animation.Animation">setAnimation</a>)指定的动画。所以，如下代码会正常触发:</p>

<pre><code class="`"> TextView title; // 原来是GONE的
 title.setVisibility(View.VISIBLE);
 title.setAnimation(new AlphaAnimation(0.3f, 1f);
</code></pre>

<p> 不一定非要<a href="http://developer.android.com/intl/zh-cn/reference/android/view/View.html#startAnimation(android.view.animation.Animation">startAnimation</a>)</p></li>
<li>要注意动画前后View的状态。这个比较难受。因为动画过程仅是放一遍电影（动画过程中仅是在View的绘制的时候对Canvas做变幻），对View本身并没有影响，通常的做法是给View Animation加上Listener，在onAnimationEnd的时候去设置目标状态。</li>
</ul>


<p>总的来说，View animation简单易用，大部分场景是可以满足需求的，早期版本确实有一些缺陷，内部状态在动画过程中会有问题，但是最近新的Android版本上面，已没有大问题，所以当能满足需求时，使用也没有问题。</p>

<h2><a href="http://developer.android.com/intl/zh-cn/guide/topics/graphics/prop-animation.html">属性动画（Property Animation)</a></h2>

<p>就像名字暗示那样，从3.0开始一套新的动画API出现了，可以描述为在一段时间内以一定的方式来改变某一个属性，是这样的方式来做动画。所以，它也可以做动画以外的事情。这套API的核心思想是在一段时间内，让某些属性随着时间改变（有点像中学的物理题）。</p>

<p>属性动画就是根据时间来改变某一对象（不一定非要是View）的某一个属性，至于某一时刻属性变化的值所产生的后果，由使用者自定义，因此你可以把它应用于任何对象。</p>

<p>它也与View一样，可以组合，可以设置事件监听。</p>

<p>与View动画最大的区别在于，View动画仅是按要求放一遍电影，不会对View的实际属性产生影响，因此，动画过程中以及完成后View仍是在原来的位置，属性也不会变化。而属性动画则不是，它会直接改变View的属性，所以有些时候这个优势会很方便，比如实现收起与展开的动画时Property动画会明显的优势：</p>

<p>比如，对于一个可以收起和弹出的动画，就可以这样来实现：</p>

<p>收起动画：</p>

<pre><code class="java">private void animateCollapse() {
        AnimatorSet set = new AnimatorSet();
        ObjectAnimator translate = ObjectAnimator.ofFloat(mStatusPanel, "translationY", 0f, mTranslationY);
        ObjectAnimator alpha = ObjectAnimator.ofFloat(mStatusPanel, "alpha", 1f, 0.75f);
        set.setDuration(250);
        set.setInterpolator(new AccelerateDecelerateInterpolator());
        set.playTogether(translate, alpha);
        set.start();
    }
</code></pre>

<p>弹出动画:</p>

<pre><code class="java">private void animateExpansion() {
        AnimatorSet set = new AnimatorSet();
        ObjectAnimator translate = ObjectAnimator.ofFloat(mStatusPanel, "translationY", mTranslationY, 0);
        ObjectAnimator alpha = ObjectAnimator.ofFloat(mStatusPanel, "alpha", 0.75f, 1f);
        set.setDuration(250);
        set.setInterpolator(new AccelerateDecelerateInterpolator());
        set.playTogether(translate, alpha);
        set.start();
    }
</code></pre>

<p>如果要使用View animation，也许也可以实现同样的效果，但估计会很难，因为要注意设置View的属性。比如说收起时并不是全hide，而是半折叠状态，就需要在AnimationListener#onAnimationEnd时去设置特殊的位置状态.</p>

<p>使用时候的建议：</p>

<ul>
<li>属性动画是post layout的，所以所有属性的初始状态就是你在布局中指定的值，动画是以此为基础开始的。</li>
<li><p>比较难使用的是translationX和translationY属性，它们的定义是相对于left和top的值。或者理解为相对于layout之后的在父布局中的位置的左边和右边。比如：</p>

<pre><code>ObjectAnimator.ofFloat(mBar, "translationY", 0, height);
</code></pre>

<p>这个就是进入的动画，一个View从其上头滑入。反过来:</p>

<pre><code>ObjectAnimator.ofFloat(mBar, "translationY", height, 0);
</code></pre>

<p>就是滑出。</p></li>
</ul>


<h3><a href="https://developer.android.com/reference/android/animation/ValueAnimator">ValueAnimator</a></h3>

<p>这是属性动画的核心类，其实它很好的诠释了什么是动画，它就是把某个值在duration内，按照插值器指定的方式从一个值变化到另一个值。看到这个类，就可以感知到动画跟View其实一点关系都没有，动画就是一个随时间变化 的数值而已。</p>

<pre><code class="java">ValueAnimator animation = ValueAnimator.ofFloat(0f, 100f);
animation.setDuration(1000);
animation.start();
</code></pre>

<p>这意思就是让一个浮点数变量，在1秒内，从0，变化 到100。至于这个有什么具体的效果，要看你如何应用这个随时间变化 的浮点数变量，比如用于控制进度，一般情况下都会将变化的数值用于改变View的视觉变幻形态，但并不局限于此，这里只是为了说明这个动画数值可以用于任何地方：</p>

<pre><code class="java">        animation.addUpdateListener(anim -&gt; {
            float t = (float) anim.getAnimatedValue();
            mStatusPanel.setText(String.format("Temperature: %04.1f", t));
        });
</code></pre>

<h3><a href="https://developer.android.com/reference/android/animation/ObjectAnimator">ObjectAnimator</a></h3>

<p>它是ValueAnimator的一个子类，增强了点功能，它的作用是针对 给定的对象，对其指定的某个属性做动画插值，动画计算与前面提到的ValueAnimator是一样的，只不过说它可以对某个对象的指定的属性做计算，并改变这个属性：</p>

<pre><code class="java">ObjectAnimator animation = ObjectAnimator.ofFloat(textView, "translationX", 100f);
animation.setDuration(1000);
animation.start();
</code></pre>

<p>这意思就是说，把动画计算出来的数值应用于一个textView的translationX属性上面。它与下面的代码，用ValueAnimator来实现，是完全等效的：</p>

<pre><code class="java">ValueAnimator animation = ValueAnimator.ofFloat(0f, 100f);
animation.setDuration(1000);
animation.start();

animation.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator updatedAnimation) {
        float animatedValue = (float)updatedAnimation.getAnimatedValue();
        textView.setTranslationX(animatedValue);
    }
});
</code></pre>

<p>由此可见ObjectAnimator就是多做了一层封装，方便来操作而已。需要注意的是，对象的属性必须要有setter和getter，因为这里会用传进来的属性名字用反射去调用，所以必须要有属性对应的settter和getter方法。</p>

<h3><a href="https://developer.android.com/reference/android/view/ViewPropertyAnimator">ViewPropertyAnimator</a></h3>

<p>因为大多数情况下是对View做动画，所以又封装出了一个专门用于View的属性动画工具，也即ViewPropertyAnimator，可以非常方便进行属性动画。用一个实例就会相当明了。</p>

<p>比如说想对某个View进行位置，用ObjectAnimator，就需要这么写：</p>

<pre><code class="java">ObjectAnimator animX = ObjectAnimator.ofFloat(myView, "x", 50f);
ObjectAnimator animY = ObjectAnimator.ofFloat(myView, "y", 100f);
AnimatorSet animSetXY = new AnimatorSet();
animSetXY.playTogether(animX, animY);
animSetXY.start();
</code></pre>

<p>但如果用ViewPropertyAnimator就会非常简洁：</p>

<pre><code class="java">myView.animate().x(50f).y(100f);
</code></pre>

<h3><a href="https://developer.android.com/reference/android/animation/AnimatorSet">AnimatorSet</a></h3>

<p>用于创建组合，前面的例子已经可以看出来它怎么使用的了。当需要同时实现多个变幻时，就可以把多个Animator用AnimatorSet来组合起来。这个类非常的灵活，可以设置不同的时长，延迟和重复。</p>

<h3><a href="https://developer.android.com/reference/android/view/animation/Interpolator">插值器</a></h3>

<p>插值器（Interpolators）用以调节数值与时间变化 的关系，因为动画是有时长的，是在duration内，从某个数值变化 到另一数值，而具体随时间怎么变，则由插值器决定。默认是线性的，比如250ms，0f到100，那么就是匀速运动。也可以加速的，减速的，先加速后减速，先减速后加速。</p>

<p><a href="https://developer.android.com/reference/android/view/animation/package-summary">android.view.animation</a>内定义了大量的插值器可供使用。</p>

<h3>在XML中来声明动画</h3>

<p>与布局类似，动画也是支持在XML中来声明的，这样可以减少代码量，加强复用。方式与方法与写代码差不多，只不过是放在了XML里面，如：</p>

<pre><code class="xml">&lt;set android:ordering="sequentially"&gt;
    &lt;set&gt;
        &lt;objectAnimator
            android:propertyName="x"
            android:duration="500"
            android:valueTo="400"
            android:valueType="intType"/&gt;
        &lt;objectAnimator
            android:propertyName="y"
            android:duration="500"
            android:valueTo="300"
            android:valueType="intType"/&gt;
    &lt;/set&gt;
    &lt;objectAnimator
        android:propertyName="alpha"
        android:duration="500"
        android:valueTo="1f"/&gt;
&lt;/set&gt;
</code></pre>

<p>这就声明了一个AnimatorSet，是一个位移和渐变动画，使用时用<a href="https://developer.android.com/reference/android/animation/AnimatorInflater">AnimatorInflater</a> 来加载<a href="https://developer.android.com/reference/android/animation/AnimatorInflater#loadAnimator(android.content.Context,%20int">load</a>)一下就可以了：</p>

<pre><code class="java">AnimatorSet set = (AnimatorSet) AnimatorInflater.loadAnimator(myContext,
    R.animator.property_animator);
set.setTarget(myObject);
set.start();
</code></pre>

<p>支持的根节点有三个，AnimatorSet，ObjectAnimator和ValueAnimator：</p>

<ul>
<li>ValueAnimator - &lt;animator></li>
<li>ObjectAnimator - &lt;objectAnimator></li>
<li>AnimatorSet - &lt;set></li>
</ul>


<p>对于XML中使用ValueAnimator也是一样的，定义好，然后加载出来就可以用了，其实跟前面用代码写是一样的：</p>

<pre><code class="xml">&lt;animator xmlns:android="http://schemas.android.com/apk/res/android"
    android:duration="1000"
    android:valueType="floatType"
    android:valueFrom="0f"
    android:valueTo="-100f" /&gt;
</code></pre>

<pre><code class="java">ValueAnimator xmlAnimator = (ValueAnimator) AnimatorInflater.loadAnimator(this,
        R.animator.animator);
xmlAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator updatedAnimation) {
        float animatedValue = (float)updatedAnimation.getAnimatedValue();
        textView.setTranslationX(animatedValue);
    }
});

xmlAnimator.start();
</code></pre>

<p><strong>注意</strong>：有一点需要注意的是，因为View Animation也是支持用XML方式来定义的，且是放在了res/anim下面。所以如果使用Property Animation 时要放在res/animator下面，这个一定要注意。</p>

<h3>View状态变化动画</h3>

<p>从安卓一开始，对于一些View的状态变化就可以设置不同的Drawable，以给用户视觉上的交互 反馈，最常见的比如按扭，常规状态，Focused状态和按压状态，以及Disabled的状态（不可点击）可以设置不同的Drawable（如icon或者颜色等）以告诉用户。这个是叫做<a href="https://developer.android.com/guide/topics/resources/drawable-resource#StateList">StateListDrawable</a>。</p>

<p>现如今，也可以针对 View的不同状态设置不同的动画了，通过<a href="https://developer.android.com/reference/android/animation/StateListAnimator">StateListAnimator</a>来实现，它的语法与前面提到的StateListDrawable类似，亦是通过一个selector，只不过其中的每个item都是animator，而非drawable，比如：</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt;
    &lt;!-- the pressed state; increase x and y size to 150% --&gt;
    &lt;item android:state_pressed="true"&gt;
        &lt;set&gt;
            &lt;objectAnimator android:propertyName="scaleX"
                android:duration="@android:integer/config_shortAnimTime"
                android:valueTo="1.5"
                android:valueType="floatType"/&gt;
            &lt;objectAnimator android:propertyName="scaleY"
                android:duration="@android:integer/config_shortAnimTime"
                android:valueTo="1.5"
                android:valueType="floatType"/&gt;
        &lt;/set&gt;
    &lt;/item&gt;
    &lt;!-- the default, non-pressed state; set x and y size to 100% --&gt;
    &lt;item android:state_pressed="false"&gt;
        &lt;set&gt;
            &lt;objectAnimator android:propertyName="scaleX"
                android:duration="@android:integer/config_shortAnimTime"
                android:valueTo="1"
                android:valueType="floatType"/&gt;
            &lt;objectAnimator android:propertyName="scaleY"
                android:duration="@android:integer/config_shortAnimTime"
                android:valueTo="1"
                android:valueType="floatType"/&gt;
        &lt;/set&gt;
    &lt;/item&gt;
&lt;/selector&gt;
</code></pre>

<p>这意思就是当点击的时候进行缩放动画，把其保存在res/xml/animate_scale.xml，这里需要注意，StateListDrawable是可以直接保存在res/drawable/下面的，但动画毕竟不是drawable，是不可以放在res/drawable下面。</p>

<p>通过android:stateListAnimator添加给指定的View，如：</p>

<pre><code class="xml">&lt;Button android:stateListAnimator="@xml/animate_scale"
        ... /&gt;
</code></pre>

<p>如果不在XML中设置，用代码也可以，先用<a href="https://developer.android.com/reference/android/animation/AnimatorInflater">AnimatorInflater</a>，把它<a href="https://developer.android.com/reference/android/animation/AnimatorInflater#loadStateListAnimator(android.content.Context,%20int">加载出来</a>)，然后调用<a href="https://developer.android.com/reference/android/view/View#setStateListAnimator(android.animation.StateListAnimator">View#setStateListAnimator</a>)即可。</p>

<h2>设计与实现要符合标准</h2>

<p>一个不争的事实是，在安卓的早期版本的时候对动画支持并不友好，因此当时很多GUI的设计都是采用水果平台的规范，导致大量的头部app，GUI交互，特别是动画这一块都是尽可能 的去模仿水果平台。</p>

<p>但时代不一样了，现在在谷歌加大了对安桌的支持力度后，特别是当<a href="https://www.google.com/design/spec/material-design/introduction.html">Material Design</a>出来了以后，从Android 5.0 Lollipop开始，伟大的Google就发布了专门针对UED的设计语言<a href="http://developer.android.com/intl/zh-cn/design/material/index.html">Material Design</a>它不再单单是设计规范了，而是一个非常详细的设计语言，具体到Icon怎么画，动画怎么做。那么，安桌的GUI交互设计与实现，就要符合Material Design的规范了，这样不但体验更符合安桌的风格，实现起来也更加的顺手，因为大量的标准库，AndroidX的库和风格主题动画等等都是以Material Design为标准的，开发人猿在实现的时候有更多的资源可以复用，不用再重复的去造轮子。</p>

<p>Anyway，官方的东西我们还是要学习的并尽可能的遵守的，特别是关于Material Design和Animation。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/training/animation">Animations and Transitions</a></li>
<li><a href="https://github.com/lgvalle/Material-Animations">https://github.com/lgvalle/Material-Animations</a></li>
<li><a href="http://android-developers.blogspot.com/2014/10/implementing-material-design-in-your.html">Implementing Material Design in Your Android app</a></li>
<li><a href="http://www.androidchina.net/4385.html">如何学习 Android Animation</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Layout大点兵]]></title>
    <link href="http://toughcoder.net/blog/2021/08/16/android-layout-general-guides/"/>
    <updated>2021-08-16T22:55:56+08:00</updated>
    <id>http://toughcoder.net/blog/2021/08/16/android-layout-general-guides</id>
    <content type="html"><![CDATA[<p>智能手机催生了移动互联时代，现如今移动应用越来越成为最为核心的终端。而GUI页面是移动互联终端的标配，做好一个GUI页面，是非常重要的，能极大的提升用户体验和用户满意度。安桌生态，自古以来（没那么久，自安桌流行以来）在GUI方面就逊于水果生态，GUI页面的美观程度，操作流畅度以及动效的优美程度，水果生态是远好于安卓生态的。好消息是近几年的版本谷歌在这些方面做了大量努力，几乎追平与水果平台的差距。特别是在support libraries（现在是叫AndroidX）里面加入一些在各方面都远好于标准API中的UI组件，现在只要稍加努力就可以做出与水果一样，甚至更炫酷的GUI页面。</p>

<p><a href=""><img src="https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2020/05/types-of-android-Layouts.jpg"></a></p>

<!-- more -->


<p>现在，对于安卓开发人猿来说，做GUI页面时选择很多，比如实现一个简单页面，可以用FrameLayout，也可以用LinearLayout，实现列表时可以用ListView，也可以用RecyclerView，面对纷繁复杂的需求以及众多的选择，到底该如何做选择，就成一个令人头痛的事情，今天就对Android布局进行一次大点兵，聊聊这些布局到底该如何使用。</p>

<p><strong>注意</strong>：这里面提到 的布局的意思是承担主页面的ViewGroup，比如页面的根布局。而不是指一些具体的内容渲染View（如TextView之于Text，ImageView之于Image）。</p>

<h2>简单和够用</h2>

<p>同样一个页面，实现的方式可以千奇百怪，就好比经典的“Hello，world”，就可以有很多种实现方法。文字肯定是用TextView，那么根布局用什么呢？可以用FrameLayout，可以用RelativeLayout，可以用LinearLayout，当然也可以用ListView，甚至是RecyclerView。对于产品同学来说，需求都可以实现了。但是可以并意味着就应该。</p>

<p>从工程和研发的角度来讲，实现方式要以够用和简单为首要原则，功能实现了仅仅是第一步，后续的维护成本是极其高昂的。代码首要是写给人看的，简单或者说优雅的实现方式，才能方便其他人理解，才可以降低维护成本。除此之外，代码也是写给CPU的，执行的性能和效率也是要考虑的因素，重型武器虽然也能杀死一只蚂蚁，但它耗费的资源相较于一根树枝来说，就大太多了。</p>

<p>过早优化是万恶之源，同理过于复杂的实现方案也是灾难之源。开发人猿要把简单和够用作为首要的原则。针对页面布局更是如此，能用普通的就用普通的，能用简单的就用简单的，功能实现了就可以，但是要尽可能以简单和便于理解作为标准。</p>

<h2>布局大点兵</h2>

<p>要想做出合适的选择，首先就需要对常用的布局进入了解，知道每种布局的优势和缺点，不同布局之间的区别，这样才能做出最佳的选择。</p>

<p>对于安卓的布局，可以分为三类，一是结构性布局，二是集合性布局，区别就在于数据是否是一个无限集合。比如像ListView它就是一个集合性布局，因为它可以显示无限个数据，只要往adapter里塞数据，列表就可以展示；而像LinearLayout就是一个结构性布局，虽然理论上它也可以塞无限个子view，但只能手动的塞，且性能会极其的差，毕竟它设计出来的目的，是沿一个方向排列一定数量的子View。</p>

<p>需要注意，不能简单的以可否滑动来作为布局的区分分类，因为结构性的布局，假如子View较多的话，外面包一层ScrollView也是可以滑动的；而集合性布局，假如数据 少于一屏的话，也是不可以滑动的。重点还是在于数据量。</p>

<h3>结构性布局</h3>

<h4><a href="https://developer.android.com/reference/android/widget/FrameLayout">FrameLayout</a></h4>

<p>简单易用，重点应用场景是层叠，在水平和竖直方向都没有约束，因此它最适合用于页面的根布局，比如手机窗口的根节点，Activity的根节点，Dialog的根节点等等，都是FrameLayout。</p>

<p>因为FrameLayout重点在于层叠，所以有时候可以做一些Canvas级别的裁切，比如实现圆角，这时也可以用FrameLayout，对FrameLayout的draw时去做裁切，然后整体效果就是做出了圆角，这对于一些不方便做圆的View有帮助，比如像SurfaceView，本身不方便做圆角，因此可以面其上面包一层FrameLayout，就可以实现圆角。</p>

<h4><a href="https://developer.android.com/reference/android/widget/LinearLayout">LinearLayout</a></h4>

<p>某一个方向的简单堆叠。最为方便的便是按比例排列，不过性能有影响。居中和对齐不如RelativeLayout方便。</p>

<h4><a href="https://developer.android.com/reference/android/widget/RelativeLayout">RelativeLayout</a></h4>

<p>特点就是每个子View必须指定相对于其他View的条件参数，以实现布局。强大且复杂，可以完全实现FrameLayout和LinearLayout。</p>

<p>特点是对于居中和对齐的支持很好，缺点就是性能差。且容易牵一发动全身。</p>

<h4><a href="https://developer.android.com/reference/android/widget/GridLayout">GridLayout</a></h4>

<p>非常适合表格形的页面，就好比计算器之类的，具体使用方法可以<a href="http://toughcoder.net/blog/2015/11/25/android-tricks-introduct-to-gridlayout/">参考之前的文章</a>。要点就在于子View呈表格形排列，且大部分的子View的尺寸是一致的，这时就可以考虑使用GridLayout。</p>

<h4><a href="https://developer.android.com/reference/androidx/constraintlayout/widget/ConstraintLayout">ConstraintLayout</a></h4>

<p>这个是AndroidX中增加的大杀器，使用方法可以<a href="http://toughcoder.net/blog/2021/08/10/android-constraintlayout-made-easy/">参考这篇文章</a>，可以胜任意的非集合性布局场景，可以完全替代前面提到的几种布局。</p>

<p>但为了避免滥用重武器，建议用ConstraintLayout替代LinearLayout和RelativeLayout就好。</p>

<h3>集合性布局</h3>

<h4><a href="https://developer.android.com/reference/android/widget/ListView">ListView</a></h4>

<p>集合性布局的典型代码，非常适合列表性数据。特点是简单易用。缺点是只能垂直方向滑动，每个条目元素的布局不宜复杂，并且对动画的支持不那么友好。当每个元素条目的布局非常简单时（如 就是简单的icon+文字）并且没有眼花聊乱的动画时，那么用这个也足够了。</p>

<h4><a href="https://developer.android.com/reference/android/widget/GridView">GridView</a></h4>

<p>与ListView类似，只不过是以表格形态来展示，简单易用，当每个无素条目较简单时，用这个比较合适，同样只支持垂直方向滑动。</p>

<h4><a href="https://developer.android.com/jetpack/androidx/releases/recyclerview">RecyclerView</a></h4>

<p>AndroidX中的集合性布局的大杀器，它重点在于Recycler，在渲染层面做了较多的优化，且布局方式跟ViewGroup本身没关系，有各种布局管理器来实现不同样式的布局，并且对动画的支持，也就是说每个元素条目的进入退出的动画的支持非常友好。</p>

<p>缺点就是使用起来较麻烦，目前已经变成了集合性布局的标准实现，但其实有被滥用的嫌疑，很多对于元素条目非常简单的场景没必要用它的。</p>

<h4><a href="https://developer.android.com/reference/androidx/viewpager/widget/ViewPager">ViewPager</a></h4>

<p>水平方向多页布局的标准组件。其实把它称作集合性布局，略迁强，因为很多时候它的数据量并不像前面那几位那样多。需要注意它的适用场景是有很多页需要横向滑动展示时，这里页的意思是，每一屏只展示一个元素条目。</p>

<h2>如何选择一个合适的布局</h2>

<p>首先，要对数据量做区分，看是选择结构性布局还是集合性布局，然后再依据页面的复杂程度来做具体的选择。</p>

<p>其次，核心的原则是够用和简单，不能为了用而用，简单的实现功能能节省大量的维护成本。</p>

<p>具体的指导原则是：</p>

<ol>
<li>应用的根布局或者页面的根布局建议用FrameLayout</li>
<li>稍复杂的LinearLayout和RelativeLayout一定要用ConstraintLayout来做</li>
<li>如有可能，可以多多用ConstraintLayout</li>
<li>对于集合性布局，如果元素条目简单，且无动画要求，那就用ListView或者GridView吧</li>
<li>如有可能，可以多多用RecyclerView</li>
<li>水平方向多页展示，没得说就用ViewPager</li>
</ol>


<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/guide/topics/ui/declaring-layout">Layouts</a></li>
<li><a href="https://developer.android.com/guide/topics/ui/layout/linear">Linear Layout</a></li>
<li><a href="https://developer.android.com/guide/topics/ui/layout/relative">Relative Layout</a></li>
<li><a href="https://developer.android.com/training/constraint-layout">Build a Responsive UI with ConstraintLayout</a></li>
<li><a href="https://developer.android.com/guide/topics/ui/layout/recyclerview">Create dynamic lists with RecyclerView</a></li>
<li><a href="https://developer.android.com/guide/topics/ui/binding">AdapterView</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android ConstraintLayout使用攻略]]></title>
    <link href="http://toughcoder.net/blog/2021/08/10/android-constraintlayout-made-easy/"/>
    <updated>2021-08-10T22:49:20+08:00</updated>
    <id>http://toughcoder.net/blog/2021/08/10/android-constraintlayout-made-easy</id>
    <content type="html"><![CDATA[<p>ConstraintLayout是新一代的布局，它汲取了众家之长，把布局的概念进行了大统一，灵活且强大，基本上可以干掉以前所有的常用布局（LinearLayout, RelativeLayout和FrameLayout）。自从Android Studio 2.3（大约在2017年）后，它就变成了Android Studio的默认模板的布局控件，可以看出谷歌对它的钟爱程度。今天就来学习一下如何使用这个新布局神器。</p>

<p><a href=""><img src="https://abhiandroid.com/ui/wp-content/uploads/2018/07/Constraint-Layout-Example-In-Android-Studio-1.png"></a></p>

<!-- more -->


<h2>简述</h2>

<p><a href="(https://developer.android.com/reference/androidx/constraintlayout/widget/ConstraintLayout">ConstraintLayout</a>)与RelativeLayout有些类似，是一个布局管理器（ViewGroup），但要强大许多，它可以以各种方式排列子View，以及按比例伸缩。最重要的改变就是它对于『Drag and drop』拖拽式制作GUI页面支持的相当的好。当然了这个取决于个人喜好，很多人仍然喜欢用写代码的方式直接去写xml文件，包括我在内。拖拽式虽然直观，但是不方便精准控制，对于一般性的布局来说尚可，但稍复杂了后，以及有了一些可滑动的view时，就不是那么的方便了。对于喜欢拖拽的同学可以查看<a href="https://developer.android.google.cn/training/constraint-layout">官方的一个教程</a>，以及<a href="https://blog.csdn.net/guolin_blog/article/details/53122387">郭大婶的一篇文章</a>，这两篇专注于拖拽式，且讲的都比较详细。</p>

<h3>添加依赖</h3>

<p>因为ConstraintLayout并不是在标准的SDK中，而是被放在了support SDK中，现在统一叫androidx了，所以要单独添加依赖：</p>

<pre><code class="groovy">     dependencies {
          implementation 'com.android.support.constraint:constraint-layout:2.1.0'
     }
</code></pre>

<h3>概念与术语</h3>

<p>ContraintLayout中把一切有关布局的参数都称之为Constraint（约束），长和宽，对齐，居中，margin和padding都是constraint。布局中的属性均以&#8221;layout_constraint&#8221;为前缀。
约束（Constrain）的意思是指用另外一个View（包括父布局即ContraintLayout）对当前View的某一布局参数施加影响。具体的影响叫做Constraint，另外一个View称作约束对象（Constraining Object)，当前View称作被约束对象（Constrainted Object）。</p>

<p><img src="https://developer.android.com/reference/androidx/constraintlayout/widget/resources/images/relative-positioning.png" alt="" /></p>

<pre><code class="xml">         &lt;Button android:id="@+id/buttonA" ... /&gt;         &lt;Button android:id="@+id/buttonB" ...                 app:layout_constraintLeft_toRightOf="@id/buttonA" /&gt;
</code></pre>

<h3>排列方式</h3>

<p>对子View的排列方式是一个ViewGroup的最基础的功能，它也体现了不同的布局管理器的作用，如线性布局（LinearLayout）是以水平或者垂直方向平铺方式来排列子View的。ConstraintLayout是以类似RelativeLayout的方式，需要针对每个子View指定如何排列。</p>

<p><img src="https://developer.android.com/reference/androidx/constraintlayout/widget/resources/images/relative-positioning-constraints.png" alt="" /></p>

<h4>基础排列方式</h4>

<p>最为基础的排列方式就是针对每个子View，指定它相对于另外一个View或者父布局（也就是ConstraintLayout本身）的相对位置，从而确定该View的具体方位。具体就是[left, top, right, bottom]四个关键的排列元素相对于另外一个View或者父布局的位置关系。</p>

<p>如，layout_constraintLeft_toLeftOf=&ldquo;parent&#8221;，这就是左边与父布局左边对齐；layout_constraintTop_toBottomOf=&#8221;id/header&#8221;，这是把这个View放在id为header的下面。以此类推，因为与RelativeLayout的布局参数比较类似，就不细说了，详情可参阅文档。</p>

<p>还有一个非常实用的Constraint叫做baseline，它是专门针对TextView的，baseline也即文本的基线，可以简单理解为文字的底部，当有两个TextiView不一样大，文字大小也不一样时，却需要对齐文本，这个属于就相当的有用。</p>

<p><img src="https://upload-images.jianshu.io/upload_images/2787721-aebcad66710f4d48.png?imageMogr2/auto-orient/strip|imageView2/2/w/213/format/webp" alt="" /></p>

<pre><code class="xml">    &lt;TextView android:id="@+id/TextView1"/&gt;

    &lt;TextView
        android:id="@+id/TextView2"
        app:layout_constraintLeft_toRightOf="@+id/TextView1"
        app:layout_constraintBaseline_toBaselineOf="@+id/TextView1"/&gt;
</code></pre>

<h3>margin</h3>

<p>常规使用与其他布局是一样的，通过layout_margin[Start,End,Left,Right,Bottom,Top]来指定与约束对象之间的margin，这个不细说了。</p>

<p>需要说一下，ConstraintLayout有一个goneMargin，可以用于当一个约束对象的Visibility被设置为GONE时，使用。用layout_goneMargin[Start,End,Left,Top,Right,Bottom]来设置。</p>

<p>比如A约束B，B在A的右边，它俩挨着，但如果A的Visibility设置为GONE时，正常情况下B就会挨到原来A的左边了，跑到了左边界上，这时可能就会变得比较丑了，如果使用margin，比如在A和B中间加一个margin，可以解决问题，但是也会影响当A可见的时候。而用goneMargin就可以完美的解决此种场景。layout_goneMarginStart=&ldquo;10dip&#8221;，那么这个margin只有当约束对象A的Visibility被置为GONE时，才会生效，这时B虽然跑到了左边界上，但是还有margin，就不会那么丑了。（其实goneMargin应用的场景也比较有限，前面说的case，也可以用A和B的父布局的leftPadding来解决）</p>

<p><img src="https://developer.android.com/reference/androidx/constraintlayout/widget/resources/images/visibility-behavior.png" alt="" /></p>

<h4>相当骚气的环状排列方式</h4>

<p>除了常规的行列式排列以外，这货还非常骚气的可以环状排列，以约束对象为圆心，通过角度和半径来约束位置：</p>

<ul>
<li>layout_constraintCircle 用以指定作为圆心的约束对象（其他view的id）</li>
<li>layout_constraintCircleRadius 被约束对象与圆心的距离</li>
<li>layout_constraintCircleAngle 被约束对象与横轴的角度（0~360度之间）</li>
</ul>


<p><img src="https://developer.android.com/reference/androidx/constraintlayout/widget/resources/images/circle1.png" alt="" />
<img src="https://developer.android.com/reference/androidx/constraintlayout/widget/resources/images/circle2.png" alt="" /></p>

<pre><code class="xml">  &lt;Button android:id="@+id/buttonA" ... /&gt;  &lt;Button android:id="@+id/buttonB" ...      app:layout_constraintCircle="@+id/buttonA"      app:layout_constraintCircleRadius="100dp"      app:layout_constraintCircleAngle="45" /&gt;
</code></pre>

<h4>环状排列实例</h4>

<p>环状排列虽然骚气，但是现实中似乎应用场景不多。</p>

<h3>居中与对齐</h3>

<p>对齐不是大问题，前面讲的如何排列其实就是对齐，选定一个约束对象后，其他对象都受其约束，就自然对齐了。</p>

<p>比较常见的问题，以及大部分时候比较麻烦的是居中，平衡与中庸中符合绝大多数审美的，因此布局时，绝大多数情况下都是需要居中的。居中的实现的方式就是两边都约束于父布局（也即ConstraintLayout），如：</p>

<p><img src="https://developer.android.com/reference/androidx/constraintlayout/widget/resources/images/centering-positioning.png" alt="" /></p>

<pre><code class="xml">         &lt;androidx.constraintlayout.widget.ConstraintLayout ...&gt;
             &lt;Button android:id="@+id/button" ...
                 app:layout_constraintLeft_toLeftOf="parent"
                 app:layout_constraintRight_toRightOf="parent"/&gt;
         &lt;/&gt;
</code></pre>

<p>居中，其实就是两边的约束边距各占空余空间的50%，扩展开来，想要实现不完全居中，两边边距呈一定比例关系，也是可以办到的。比如说黄金比例0.618就比居中好看，这也好办：
<img src="https://developer.android.com/reference/androidx/constraintlayout/widget/resources/images/centering-positioning-bias.png" alt="" /></p>

<pre><code class="xml">       &lt;androidx.constraintlayout.widget.ConstraintLayout ...&gt;
             &lt;Button android:id="@+id/button" ...
                 app:layout_constraintHorizontal_bias="0.382"
                 app:layout_constraintLeft_toLeftOf="parent"
                 app:layout_constraintRight_toRightOf="parent"/&gt;
      &lt;/&gt;
</code></pre>

<p>这个比例控制叫bias，可以有Horizontal和Vertical两个方向。</p>

<h3>尺寸</h3>

<p>尺寸也就是针对子View的宽与高的约束，其实大部分时候一些具体的子View的宽与高要么指定大小，要么是WRAP_CONTENT的，但有些时候可能就是需要更加的灵活一些，这时就可以考虑用ConstraintLayout里面的一些特性。宽与高设置为固定大小或者WRAP_CONTENT时与其他ViewGroup是一样的，不用多说，要想特别一点的就是设置为『0dip』或者MATCH_CONSTRAINT时，就会用其他约束来决定该View的宽或者高。后面重点讨论有约束的情况。</p>

<h4>默认行为</h4>

<p>如果子View的宽或者高设置为了MATCH_CONSTRAINT（或者『0dip』）时，默认的行为是它会占满剩余的可用空间。</p>

<h4>Max与Min</h4>

<p>还可以加上最大最小的限制：</p>

<ul>
<li>layout_constraintWidth_min and layout_constraintHeight_min : will set the minimum size for this dimension</li>
<li>layout_constraintWidth_max and layout_constraintHeight_max : will set the maximum size for this dimension</li>
<li>layout_constraintWidth_percent and layout_constraintHeight_percent : will set the size of this dimension as a percentage of the parent</li>
</ul>


<h4>按约束对象的比例来设置（Percent）</h4>

<p>前面的默认行为或者最大最小还算不上啥，其他ViewGroup也有类似参数。最为变态与强大的是可以按约束对象的比例来作为此View的宽或者高：</p>

<ul>
<li>The dimension should be set to MATCH_CONSTRAINT (0dp)</li>
<li>The default should be set to percent app:layout_constraintWidth_default=&ldquo;percent&rdquo; or app:layout_constraintHeight_default=&ldquo;percent&rdquo;</li>
<li>Then set the layout_constraintWidth_percent or layout_constraintHeight_percent attributes to a value between 0 and 1</li>
</ul>


<h4>自身宽高比（Ratio）</h4>

<p>这个是最变态的约束方式，可以设置一个自身的宽高比，以确定子View的尺寸，当然了具体的宽或者高还要以其他约束方式确定具体尺寸，然后再按照设置的宽高比对另外一个进行约束。比如，实现一个方形的按扭，宽是其自身要求的宽度值（WRAP_CONTENT），设置的宽高比是1：1，所以高度也会跟宽度一样，就是一个方形的按扭了：</p>

<pre><code class="xml">        &lt;Button android:layout_width="wrap_content"
                   android:layout_height="0dp"
                   app:layout_constraintDimensionRatio="1:1" /&gt;
</code></pre>

<h2>高级特性</h2>

<p>前面讲的是一些基础使用方式，但是这货远不止这些，还有一些非常强大的功能，下面简单介绍两个。</p>

<h3>链（Chains）</h3>

<p>在某一个方向上（横着或者竖着）有着相互约束的一组子View，会被视为一个链，第一个称作头部（Head），可以应用一些样式以对整个链内的子View都产生影响。
<img src="https://developer.android.com/reference/androidx/constraintlayout/widget/resources/images/chains.png" alt="" />
<img src="https://developer.android.com/reference/androidx/constraintlayout/widget/resources/images/chains-head.png" alt="" /></p>

<p>这里的相互约束的意思是，比如有上面A，B，C三个子View，那么它们要相互约束，也即：</p>

<pre><code class="xml">  &lt;ConstraintLayout&gt;
      &lt;A layout_constraintLeft_toLeftOf="parent"
           layout_constraintRight_toRightOf="B" /&gt;
      &lt;B layout_constraintLeft_toLeftOf="A"
           layout_constraintRight_toRightOf="C" /&gt;
      &lt;C layout_constraintLeft_toLeftOf="B"
           layout_constraintRight_toRightOf="parent" /&gt;
  &lt;/ConstraintLayout&gt;
</code></pre>

<p>就可以，对头部子View  A进行样式（Chain style），通过layout_constraintHorizontal_chainStyle来设置：</p>

<ul>
<li>CHAIN_SPREAD &ndash; the elements will be spread out (default style)<em> Weighted chain &ndash; in CHAIN_SPREAD mode, if some widgets are set to MATCH_CONSTRAINT, they will split the available space</em> CHAIN_SPREAD_INSIDE &ndash; similar, but the endpoints of the chain will not be spread out* CHAIN_PACKED &ndash; the elements of the chain will be packed together. The horizontal or vertical bias attribute of the child will then affect the positioning of the packed elements</li>
</ul>


<p><img src="https://developer.android.com/reference/androidx/constraintlayout/widget/resources/images/chains-styles.png" alt="" /></p>

<p>链中的权重（Weighted chains）</p>

<p>默认情况下，子View会均分并占满可用的空间。可以用权重来按比例分配，给子View加上layout_constraintHorizontal_weight后，就会按比例分配，这个与LinearLayout的layoutWeight用法是一样的。</p>

<h3>组（Groups）</h3>

<p>为了View的渲染性能，各路大神告诉我们要尽可能的让布局扁平化，但是，如果太扁平了，全都放在一个ViewGroup下面，就会混乱，特别是像RelativeLayout和ConstraintLayout，子View的排列方式会产生相互依赖，会有牵一发动全身的情况出现。为了避免这种情况，就需要对子View进行分组，对页面进行区域划分，把紧密相关的视为一个组。以往，会用一个子ViewGroup把一个组包起来，虽然会加深View的层次，但这样能避免牵一发动全身。</p>

<p>而对于ConstraintLayout来说，有更先进的方式了，它有一个类叫Group，就是专门用来干这件事儿的，但Group对象并不是一个真的子View，这里的意思是它并不会在View tree中进行渲染，它是专门用于管理属于它的子View的，比如方便对整个组进行Visibility的设置。</p>

<h2>神器要如何使用</h2>

<p>前面的介绍就差不多了，ConstraintLayout还是相当的强大的，如有可能还是尽可能的多用它吧。它的实现上面确实挺复杂的，毕竟功能比较强大，但它的效率并不差。对于常用的几大布局都可以直接用它来替代。</p>

<h3>当线性布局使用（as LinearLayout）</h3>

<p>线性布局最大的优势就在于可以用weight的方式来按比例排放，而这个用前面提到的Chain就可以完美的解决。所以，LinearLayout可以完全放弃。</p>

<h3>当层叠布局使用（as FrameLayout）</h3>

<p>FrameLayout的全用场景一般是作为整个应用的根布局，特别是HomeActivity+Fragment这种架构。从纯的功能角度来讲，ConstraintLayout可以完全实现FrameLayout的所有功能，所以，FrameLayout也可以放弃。</p>

<p>但从简单方便角度来讲，假如是HomeActivity的根布局，子View都是MATCH_PARENT的Fragement的话，也没有必要换成ConstraintLayout，这种场景FrameLayout完全够用，而且非常适合它。换成ConstraintLayout反倒有些浪费，有些杀鸡用牛刀。</p>

<h3>当相对布局使用（as RelativeLayout）</h3>

<p>从前面的讲述可以看出，ConstraintLayout几乎就是RelativeLayout的加强版。所以，凡是用到RelativeLayout的地方都<strong>应该换成ConstaintLayout</strong>。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.google.cn/training/constraint-layout">Build a Responsive UI with ConstraintLayout</a></li>
<li><a href="https://developer.android.com/reference/androidx/constraintlayout/widget/ConstraintLayout">ConstraintLayout</a></li>
<li><a href="https://www.jianshu.com/p/17ec9bd6ca8a">约束布局ConstraintLayout看这一篇就够了</a></li>
<li><a href="https://developer.android.com/codelabs/constraint-layout#0">Use ConstraintLayout to design your Android views</a></li>
<li><a href="https://www.raywenderlich.com/9475-constraintlayout-tutorial-for-android-complex-layouts">ConstraintLayout Tutorial for Android: Complex Layouts</a></li>
<li><a href="https://abhiandroid.com/ui/constraintlayout">Constraint Layout Tutorial With Example In Android Studio</a></li>
<li><a href="https://blog.csdn.net/guolin_blog/article/details/53122387">Android新特性介绍，ConstraintLayout完全解析</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
