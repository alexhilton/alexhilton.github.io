<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2024-08-12T22:46:13+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『密云不雨』| Navigation]]></title>
    <link href="http://toughcoder.net/blog/2024/08/12/navigation-with-compose/"/>
    <updated>2024-08-12T07:46:31+08:00</updated>
    <id>http://toughcoder.net/blog/2024/08/12/navigation-with-compose</id>
    <content type="html"><![CDATA[<p>除了一些玩具性的Demo以外，相信任何一个应用程序不可能只有一个页面，最为极简的应用也至少会有两个页面，一个主页和一个设置页。对于传统的View系统来说对于导航这块没有专门的API，一般都是自己写逻辑跳Activity，或者跳到Fragment，然后再反向的Back，所以有了很多三方的各种Router类库（如大阿里的ARouter，货拉拉的TheRouter）。其实谷歌已经提供了解决方案，在Jetpack中提供了<a href="https://developer.android.com/guide/navigation">Navigation组件</a>，专门用于解决应用内部各种页面之间跳转的问题。</p>

<p><a href=""><img src="https://blog.mindorks.com/images/banner-jetpack-compose-navigation-657edc7b323cafdf.png" title="auto auto" ></a></p>

<!-- more -->


<p>对于Jetpack Compose来说，因为是全新的框架，在设计之初就考虑到了导航的问题，但也不是重新开发了一套新库，而是把Jetpack中的组件Navigation深度的结合了进来。换句话说，在Jetpack Compose中可以直接使用Navigation组件来进行页面之间的跳转，并且有非常符合Compose的粘合API，使用起来非常的丝滑顺手。</p>

<h2>基本概念</h2>

<p>在深入之前有必要先澄清Navigation中的一些概念，了解了一些基本的概念和术语之后，会有助于理解组件的设计理念，也会更容易上手使用。</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 术语 </th>
<th style="text-align:left;"> 用途 </th>
<th style="text-align:left;"> 具体的Composable </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> Host </td>
<td style="text-align:left;"> 包含了当前导航页面的容器。应该把它理解成为导航的容器，包含着当前的页面， 以及一个NavController。 </td>
<td style="text-align:left;"> <a href="https://developer.android.com/reference/kotlin/androidx/navigation/compose/package-summary#NavHost(androidx.navigation.NavHostController,androidx.navigation.NavGraph,androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1">NavHost</a>) </td>
</tr>
<tr>
<td style="text-align:center;"> Graph </td>
<td style="text-align:left;"> 静态的数组结构，定义着一个应用中的所有页面，以及它们之间应该如何跳转。 </td>
<td style="text-align:left;"> <a href="https://developer.android.com/reference/androidx/navigation/NavGraph">NavGraph</a> </td>
</tr>
<tr>
<td style="text-align:center;"> Controller </td>
<td style="text-align:left;"> 页面之间导航的核心管理者。它封装着如何在页面之间跳转的方法，处理链接的方法，以及返回堆栈的方法。 </td>
<td style="text-align:left;"> <a href="https://developer.android.com/reference/androidx/navigation/NavController">NavController</a> </td>
</tr>
<tr>
<td style="text-align:center;"> Destination </td>
<td style="text-align:left;"> 在Graph中的一个节点。当跳转到这个节点时，Host中就包含并展示它的页面。在实际项目中，往往是一个Fragment或者一个Composable，也就是一个页面。 </td>
<td style="text-align:left;"> <a href="https://developer.android.com/reference/androidx/navigation/NavDestination">NavDestination</a> </td>
</tr>
<tr>
<td style="text-align:center;"> Route </td>
<td style="text-align:left;"> Destination的全局唯一标识，包括其所需要的参数。大部分时候，特别是在Compose中，这就是一坨类似于Uri一样的String </td>
<td style="text-align:left;"> </td>
</tr>
</tbody>
</table>


<p>还需要说明一下的就是导航的基本的操作对象是一个页面，一个页面可以理解为一个全屏的，逻辑上内聚，内容上互相关联，自成一家的一个UI页面，比如说一个应用的主页是一个页面，文章列表是一个页面，文章详情是一个页面，设置是一个页面，用户页又是一个页面。当然，这里全屏并不是直观的全屏，意思是说（特别是对于Compose）一个页面的大小是受系统控制的，并不能像普通的Composable那样随意设置大小，对于手机就是全屏的，对于平板可能会一个占据三分之一（列表页），一个占据三分之二（详情页）。</p>

<h2>使用Navigation</h2>

<p>Jetpack Compose是声明式UI，是函数式编程，每一个Composable都是一个函数，所以在Compose中使用Navigation略微的有点不一样。核心原理和核心的规则肯定与Navigation是一样一样的，只是使用上的API略不一样，其实是更简单更方便了（这是声明式UI带来的收益）。</p>

<h3>添加依赖</h3>

<p>在使用之前先要添加Navigation库作为项目的依赖：</p>

<pre><code class="Kotlin">dependencies {
    val navVersion = "2.7.7"
    implementation("androidx.navigation:navigation-runtime-ktx:$navVersion")
    implementation("androidx.navigation:navigation-compose:$navVersion")
}
</code></pre>

<h3>使用Navigation的方法</h3>

<p>可以通过以下步骤来使用Navigation：</p>

<ul>
<li>创建NavHost，并设置为应用的入口，通过Composable函数<a href="https://developer.android.com/reference/kotlin/androidx/navigation/compose/package-summary#NavHost(androidx.navigation.NavHostController,androidx.navigation.NavGraph,androidx.compose.ui.Modifier,androidx.compose.ui.Alignment,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1">NavHost</a>)。</li>
<li>创建NavController，可以直接创建，但推荐的方式是使用Compose提供的状态构造函数<a href="https://developer.android.com/reference/kotlin/androidx/navigation/compose/package-summary#rememberNavController(kotlin.Array">rememberNavController</a>)，它的好处在于当前导航会提升为一个状态。</li>
<li>定义Destination和Route，其实对于Compose来说都是用类似于Uri的String来作为Destination，每一个Destition唯一对应着一个页面。</li>
<li>添加页面，通过函数NavHost的尾部lambda，它实际上是一个<a href="https://developer.android.com/reference/kotlin/androidx/navigation/NavGraphBuilder">NavGraphBuilder</a>的扩展函数，这里调用函数<a href="https://developer.android.com/reference/kotlin/androidx/navigation/compose/package-summary#(androidx.navigation.NavGraphBuilder">composable</a>.composable(kotlin.collections.Map,kotlin.collections.List,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function1,kotlin.Function2))来添加页面。</li>
<li>配置跳转，通过前面创建的navController来实现跳转，用<a href="https://developer.android.com/reference/kotlin/androidx/navigation/NavController#navigate(android.net.Uri">navController.navigate</a>)来跳转到指定的Destination，用<a href="https://developer.android.com/reference/androidx/navigation/NavController#popBackStack(">navController.popBackStack</a>)来返回到前一个页面。而触发的入口肯定是在具体的页面之中，所以页面要把其跳转函数作为参数，在NavGraphBuilder时，再用NavController去实现，这样所有的跳转逻辑就都在NavGraph中，便于管理。</li>
</ul>


<h3>具体实例</h3>

<p>说了那么多貌似挺烦杂的，让我们看一个实例就会瞬间明白。</p>

<p>一个简单的应用有4个页面，先定义Destinations：</p>

<pre><code class="Kotlin">object Destinations {
    const val APP_URI = "http://toughcoder.net/chronos"
    const val HOME_ROUTE = "home" // 主页
    const val HISTORY_ROUTE = "history" // 历史记录页面
    const val SETTINGS = "settings" // 设置页
    const val ARTICLES = "articles" // 文章页
}
</code></pre>

<p>那么就可以如此配置Navigation：</p>

<pre><code class="Kotlin">@Composable
fun ChronosNavGraph(
    modifier: Modifier = Modifier,
    navController: NavHostController = rememberNavController(),
    start: String = Destinations.HOME_ROUTE // 默认的初始页面为主页
) {
    NavHost(
        modifier = modifier,
        navController = navController,
        startDestination = start
    ) {
        composable(
            route = Destinations.HOME_ROUTE,
            deepLinks = listOf(
                navDeepLink { uriPattern = "${Destinations.APP_URI}/${Destinations.HOME_ROUTE}" }
            )
        ) {
            ChronosScreen(
                gotoSettings = { navController.navigate(Destinations.SETTINGS) },
                gotoHistory = { navController.navigate(Destinations.HISTORY_ROUTE) },
                gotoArticles = { navController.navigate(Destinations.ARTICLES) }
            )
        }

        composable(
            route = Destinations.HISTORY_ROUTE,
            deepLinks = listOf(
                navDeepLink { uriPattern = "${Destinations.APP_URI}/${Destinations.HISTORY_ROUTE}" }
            )
        ) {
            HistoryScreen(
                viewModel = viewModel()
            ) {
                navController.popBackStack()
            }
        }

        composable(
            route = Destinations.SETTINGS,
            deepLinks = listOf(
                navDeepLink { uriPattern = "${Destinations.APP_URI}/${Destinations.SETTINGS}" }
            )
        ) {
            SettingsScreen(
                viewModel = viewModel()
            ) {
                navController.popBackStack()
            }
        }

        composable(
            route = Destinations.ARTICLES,
            deepLinks = listOf(
                navDeepLink { uriPattern = "${Destinations.APP_URI}/${Destinations.ARTICLES}" }
            )
        ) {
            ArticlesScreen(
                viewModel = viewModel()
            ) {
                navController.popBackStack()
            }
        }
    }
}
</code></pre>

<p>可以看到每一个composable函数用以创建一个导航页面，里面有其Route，具体的页面，以及跳转的入口函数。deepLinks是每个页面的Uri式的链接，后面会详细的讲解。</p>

<p>最后就是把这个NavGraph作为应用的入口页面：</p>

<pre><code class="Kotlin">override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            ChronosTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    ChronosNavGraph()
                }
            }
        }
    }
</code></pre>

<h2>在页面之间传递参数</h2>

<p>页面跳转还必然会涉及参数的传递，比如具有递进关系的两个页面，核心参数肯定要由前一个页传递过去，最为典型的场景就是列表类页面到详情页面的跳转，比如文章列表要把文章的Id传给详情页，这样详情页才知道去展示哪个文章，用户列表要把用户Id传给详情页，详情页才知道展示哪个用户。</p>

<p>Navigation提供了传递参数的方法，在创建导航页面时传入的Route可以加入占位符形参，然后在跳转navController.navigate时可以传入实参，只不过参数的类型有限制，只能是基础数据类型如字串或者数字。目标页面使用时通过backStackEntry.arguments来获得参数。来具体看一下，比如说传递用户Id的场景：</p>

<pre><code class="Kotlin">NavHost() {
    composable(
          "profile/{userId}",
          arguments = listOf(navArgument("userId") { type = NavType.StringType } // 这句可以省略，因为默认类型都当成是字符串
    ) { backStackEntry -&gt;
          Profile(navController, backStackEntry.arguments?.getString("userId"))
    }
}
</code></pre>

<p>上面参数类型的声明，其实可以省略，因为默认的类型都当成String来解析和处理，如果是其他类型则需要显式地声明。这样目标页面的参数就声明好了，我们在跳转的时候传入实参就可以了：</p>

<pre><code class="Kotlin">navController.navigate("profile/user1234")
</code></pre>

<p>大部分时候参数都是<strong>必填参数</strong>，像上面这样写userId是必填的参数。但有些时候一些非核心的参数，可能不是每次跳转都会传，这就需要页面把参数声明为<strong>可选参数</strong>。可选参数在声明的时候Uri中必须使用查询式语句，如（&#8221;?argName={argName}&ldquo;），另外必须 设置默认值，或者类型是nullable的。这也意味着我们不能省略导航页面构建composable函数中的arguments参数：</p>

<pre><code class="Kotlin">composable(
    "profile?userId={userId}",
    arguments = listOf(navArgument("userId") { defaultValue = "user1234" }) // 注意这里的默认值，当调用navigate时如果不传userId就用这个默认值
) { backStackEntry -&gt;
    Profile(navController, backStackEntry.arguments?.getString("userId"))
}
</code></pre>

<p><strong>注意：</strong> 要尽可能的使用基本的数据类型，如String，Int或者Long，而不传递复杂的数据。复杂的数据通常都是业务逻辑数据，而业务逻辑数据应该使用基本的参数，再从数据源处（通常是通过ViewModel从Repo处）去主动获取，这样才能保证数据的真实有效。这是设计原则中的『单一数据源原则Single Source of Truth』。复杂数据从Repo处获取后，可能会变得过时或者失真，而且在页面之间传递会有拷贝，效率也不高，因此要避免在页面之间传递复杂数据。</p>

<h2>处理DeepLinks</h2>

<p>DeepLinks是Uri式的链接跳转范式，能够以字符串形式的Uri精准的定位到某个应用的具体某个页面，就犹如互联网中的Uri一样。它的好处在于形成了一个统一的标准，形式简单方便，一个字符串就能定位到一个页面。</p>

<p>使用导航页面构建函数composable在构建页面的时候可以传入<a href="https://developer.android.com/reference/androidx/navigation/NavDeepLink">NavDeepLink</a>对象，更为方便的是使用其构建函数<a href="https://developer.android.com/reference/kotlin/androidx/navigation/package-summary#navDeepLink(kotlin.Function1">navDeepLink</a>)：</p>

<pre><code class="Kotlin">val uri = "https://www.example.com"

composable(
    "profile?id={id}",
    deepLinks = listOf(navDeepLink { uriPattern = "$uri/{id}" })
) { backStackEntry -&gt;
    Profile(navController, backStackEntry.arguments?.getString("id"))
}
</code></pre>

<p>从示例中可以看出Uri中还可以带有参数，形参的声明，以及参数的获取与前面提到的页面参数是一样一样的，如果实际传过来的Uri是&#8221;<a href="https://www.example.com/user123">https://www.example.com/user123</a>&#8220;，到此页面后，就能解析出参数id为user123。</p>

<p>正常情况下这些DeepLinks只能在应用内部使用，如果要对应用外开放，则需要在应用的AndroidManifest文件中进行声明，声明为intent filter：</p>

<pre><code class="xml">&lt;activity …&gt;
  &lt;intent-filter&gt;
    ...
    &lt;data android:scheme="https" android:host="www.example.com" /&gt;
  &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>

<h2>页面跳转过渡动画</h2>

<p>页面跳转可以指定具体的过渡动画，具体的可以参考<a href="https://juejin.cn/post/7385758285960609831#heading-10">前面专门讲动画的那篇文章</a>，这里就不再重复了。</p>

<h2>Route的类型安全</h2>

<p>通常情况下Route都是使用Uri式的String，但这明显不够安全，因为调用navController#navigate的时候，可能会传一个不认识的页面Route，或者参数传错了（比如数字参数传了String），等等。轻则跳转失败，因为找不到Destination页面，重则会Crash。要想类型安全，就不能使用String式的Uri，需要把Ruote定义为类型（也即class），但要使用注解&#64;Serializeable标记一下：</p>

<pre><code class="Kotlin">// 主页面，不带任何参数
@Serializable
object Home

// 用户页面，参数是用户Id，其类型是一个String
@Serializable
data class Profile(val id: String)
</code></pre>

<p>然后在构建导航页面的时候，函数composable其实是一个泛型函数，它可以指定Route的参数类型：</p>

<pre><code class="Kotlin">NavHost(navController, startDestination = Home) {
     composable&lt;Home&gt; { // 泛型函数，可以指定参数类型
         HomeScreen(onNavigateToProfile = { id -&gt;
             navController.navigate(Profile(id)) // 跳转的时候传入的实参是一个对象，类型就是上面定义的Route
         })
     }
     composable&lt;Profile&gt; { backStackEntry -&gt;
         val profile: Profile = backStackEntry.toRoute()  // 获取参数的时候，用toRoute来获得Route对象，类型就是我们定义的那个
         ProfileScreen(profile.id)
     }
}
</code></pre>

<p>然后在跳转的时候就可以把Route对象作为实参传进去：</p>

<pre><code class="Kotlin">navController.navigate(Profile(id = 123))
</code></pre>

<p>这样因为都是定义的类型，所以编译器会做编译时检查，虚拟机也会做运行时的类型检查，保证类型安全。</p>

<p><strong>注意：</strong> 不要混淆，这里Route虽然是自定义类型，但并不算是在页面之间传递复杂的业务数据，因为具体的参数仍是诸如String和Int之类的基础数值。把Route定义为类型（class），而不是直接使用String，是为了让编译器帮忙我们保证类型安全，减少出错。</p>

<h2>总结</h2>

<p>使用Navigation可以非常轻松的把应用的各个页面组织连接起来，形成一个完整的交互闭环。谷歌也提供了相应的<a href="https://developer.android.com/codelabs/jetpack-compose-navigation#0">CodeLab</a>可以学习一下。此外，谷歌的一些Sample app，像<a href="https://github.com/android/sunflower/tree/main">Sunflower</a>和<a href="https://github.com/android/compose-samples/tree/main/JetNews">JetNews</a>也是使用Navigation来实现导航的，是非常好的学习案例。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/navigation">Navigation with Compose</a></li>
<li><a href="https://developer.android.com/guide/navigation">Navigation</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『时乘六龙』| Advanced Gestures]]></title>
    <link href="http://toughcoder.net/blog/2024/08/02/advanced-gesture-in-compose/"/>
    <updated>2024-08-02T07:46:30+08:00</updated>
    <id>http://toughcoder.net/blog/2024/08/02/advanced-gesture-in-compose</id>
    <content type="html"><![CDATA[<p>通过<a href="https://juejin.cn/post/7395020728623480841">前面的一篇文章</a>我们学会了如何用各种高级别抽象的扩展函数来进行手势处理。像clickable，draggable，scrollable和anchoredDraggable都是类似于View系统中的各种回调（如onClick或者onScroll）是高级别的抽象，这里我们只能处理手势，大部分情况下这也够用了。</p>

<p><a href=""><img src="file:///Users/alexhilton/Downloads/compose_libs/gesture/advanced_gesture.jpeg" title="auto auto" ></a></p>

<!-- more -->


<p>但是，对于一些复杂的交互 场景需要我们先识别手势，然后再处理手势，这时就不能再用封装好的扩展函数了，而必须要用到像View系统中的onTouchEvent那样的低级别的回调，直接拿到触点事件，然后再识别手势，最后再处理手势。这篇文章就学习一下如何使用Jetpack Compose中的低级别函数来识别和处理手势。</p>

<h2>处理原始触点事件</h2>

<p>除了使用一些封装好了的扩展函数来直接处理某个手势以外，还可以直接接收原始的事件输入。</p>

<p>Jetpack Compose在Modifier中提供了扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/package-summary#(androidx.compose.ui.Modifier">pointerInput</a>.pointerInput(kotlin.Any,kotlin.Any,kotlin.coroutines.SuspendFunction1))来接收原始的触点事件，与View系统中的<a href="https://developer.android.com/reference/android/view/View.OnTouchListener">onTouch</a>是类似的，这是触点事件的低级别的API。通过此API能获得触点事件，之后可以进行手势识别和手势处理，因为拿到的是原始的触点事件，所以很多逻辑要自己写，有些麻烦，但因为完全可控，所以可以实现一些更为复杂的手势识别和手势处理，比如任意方向的拖拽和滑动，长按后的拖拽，多点触控等等。</p>

<h3>接收触点事件</h3>

<p>扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/package-summary#(androidx.compose.ui.Modifier">pointerInput</a>.pointerInput(kotlin.Any,kotlin.Any,kotlin.coroutines.SuspendFunction1))接收三个参数，前两个都是作为<strong>事件处理回调的标识（keys）</strong>，第三个参数是<strong>事件处理回调</strong>，是一个尾部lambda，当某个key发生变化，这个lambda会重新执行，否则即使发生重组（Recomposition），这个lambda也会不会重新执行。</p>

<pre><code class="Kotlin">fun Modifier.pointerInput(key1: Any?, key2: Any?, block: suspend PointerInputScope.() -&gt; Unit): Modifier
</code></pre>

<p>第三参数就是我们要提供的事件处理回调，它是运行在<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/PointerInputScope">PointerInputScope</a>上下文中的lambda，这个上下文作用域里面有很多扩展函数可以直接使用。仔细看这个lambda是suspend的，这是因为输入事件可能不是即时的，可能会有等待的情况，也就是说lambda是在有事件的时候才会执行。PointerInputScope中的函数也都定义为suspend的，这些函数在lambda中可以直接调用，所以lambda本身也必须 是suspend的。</p>

<p>比如说想要打印触点事件，就可以这样写：</p>

<pre><code class="Kotlin">@Composable
private fun LogPointerEvents(filter: PointerEventType? = null) {
    var log by remember { mutableStateOf("") }
    Column {
        Text(log)
        Box(
            Modifier
                .size(100.dp)
                .background(Color.Red)
                .pointerInput(filter) {
                    awaitPointerEventScope {
                        while (true) {
                            val event = awaitPointerEvent()
                            // handle pointer event
                            if (filter == null || event.type == filter) {
                                log = "${event.type}, ${event.changes.first().position}"
                            }
                        }
                    }
                }
        )
    }
}
</code></pre>

<p>filter是一个事件的类型参数当作key，也当作过滤条件。在事件处理回调lambda中，用<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/AwaitPointerEventScope#awaitPointerEvent(androidx.compose.ui.input.pointer.PointerEventPass">awaitPointerEvent</a>)获得每一个触点事件，然后打印出来，<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/AwaitPointerEventScope">awaitPoniterEventScope</a>函数是创建一个协程上下文作用域用以等待事件输入，在其内调用awaitPointerEvent来获得事件。</p>

<h3>识别手势</h3>

<p>虽然pointerInput是一个低级别的接口，但也并不意味着所有的逻辑都必须从头写，在<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/PointerInputScope">PointerInputScope</a>中已经定义了大量的函数可以识别大部分手势：</p>

<ul>
<li>非连续性手势如单击（tap），双击（double tap）和长按（long press）：<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.input.pointer.PointerInputScope">detectTapGestures</a>.detectTapGestures(kotlin.Function1,kotlin.Function1,kotlin.coroutines.SuspendFunction2,kotlin.Function1))</li>
<li>拖拽（drag）：<a href="">detectDragGestures</a>，<a href="">detectDragGesturesAfterLongPress</a>，以及固定方向拖拽<a href="">detectHorizontalDragGestures</a>和<a href="">detectVerticalDragGestures</a></li>
<li>多点触控变幻的手势识别（旋转，平移和缩放）：<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.input.pointer.PointerInputScope">detectTransformGestures</a>.detectTransformGestures(kotlin.Boolean,kotlin.Function4))</li>
</ul>


<p>比如像<a href="https://juejin.cn/post/7395020728623480841">前面文章中</a>提到的拖拽也可以用pointerInput实现：</p>

<pre><code class="Kotlin">@Composable
private fun DraggableTextLowLevel() {
    Box(modifier = Modifier.fillMaxSize()) {
        var offsetX by remember { mutableStateOf(0f) }
        var offsetY by remember { mutableStateOf(0f) }

        Box(
            Modifier
                .offset { IntOffset(offsetX.roundToInt(), offsetY.roundToInt()) }
                .background(Color.Blue)
                .size(50.dp)
                .pointerInput(Unit) {
                    detectDragGestures { change, dragAmount -&gt;
                        change.consume()
                        offsetX += dragAmount.x
                        offsetY += dragAmount.y
                    }
                }
        )
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/gestures-drag.gif" alt="detect_drag_demo" /></p>

<p>前面提到了像detectTapGestures和detectDragGestures都是suspend的函数，所以在一个pointerInter的lambda中只能有一个，比如像下面这样写detectDragGestures不会得到执行：</p>

<pre><code class="Kotlin">var log by remember { mutableStateOf("") }
Column {
    Text(log)
    Box(
        Modifier
            .size(100.dp)
            .background(Color.Red)
            .pointerInput(Unit) {
                detectTapGestures { log = "Tap!" }
                // 不会得到执行，走不到这里，前面一个是suspend的
                detectDragGestures { _, _ -&gt; log = "Dragging" }
            }
    )
}
</code></pre>

<p>一个可行的解决办法就是可以写多个pointerInput，每个ponterInput处理一种手势：</p>

<pre><code class="Kotlin">var log by remember { mutableStateOf("") }
Column {
    Text(log)
    Box(
        Modifier
            .size(100.dp)
            .background(Color.Red)
            .pointerInput(Unit) {
                detectTapGestures { log = "Tap!" }
            }
            .pointerInput(Unit) {
                // These drag events will correctly be triggered
                detectDragGestures { _, _ -&gt; log = "Dragging" }
            }
    )
}
</code></pre>

<h3>直接处理事件</h3>

<p>遇到交互比较复杂的场景，或者当PointerInputScope中提供的识别函数不能解决问题时，或者需要把几种不同的手势组合在一起时，就需要直接处理事件。像View系统中的onTouch一样，我们需要知道不同的事件类型，比如pointer down，pointer move和pointer up等。PointerInputScope中提供了一个函数awaitEachGesture可以取代while (true)来获得每个事件；awaitFirstDown，是手势的开始相当于ACTION&#95;DOWN；waitForUpOrCancellation是事件结束，相当于ACTION&#95;UP和ACTION&#95;CANCEL；drag相当于ACTION&#95;MOVE。我们来看一个例子：</p>

<pre><code class="Kotlin">@Composable
private fun LogPointerEvents() {
    var log by remember { mutableStateOf("") }
    Column(
        modifier = Modifier.fillMaxSize(),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        Text(log)
        Box(
            Modifier
                .size(240.dp)
                .background(Color.DarkGray)
                .pointerInput(Unit) {
                    awaitEachGesture {
                        val down = awaitFirstDown().also {
                            log = "Action Down"
                        }
                        var change = awaitTouchSlopOrCancellation(down.id) { ch, _ -&gt;
                            ch.consume()
                        }
                        while (change != null &amp;&amp; change.pressed) {
                            change = awaitDragOrCancellation(change.id)
                            if (change != null &amp;&amp; change.pressed) {
                                log = "Action Move ${change.type} ${change.position}"
                            }
                        }
                        log = "Action Up"
                    }
                }
        )
    }
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/gesture/event.gif" alt="event_demo" /></p>

<p>需要注意的是这些函数都是suspend的，也就是说当预期的行为发生时才会带着结果返回，比如awaitFirstDown()当有第一个触点事件发生时结束suspend然后返回；awaitTouchSlopOrCancellation当有超过拖拽阈值时结束suspend然后返回；awaitDragOrCancellation当有拖拽发生时结束suspend返回。</p>

<h2>触点事件的派发流程</h2>

<p>为了更好的处理事件，需要了解一下Jetpack Compose的事件派发流程，与View系统是类似的，事件派发的过程也是沿着Composable的树形结构，从父Composable到子Composable，同一层级的顺序则是从上到下，从前到后（Z轴方向），依次做『Hit test』，直到事件被消费，就停止派发。</p>

<p>事件的消费过程则是反过来，子Composable如果未消费就返回给父Composable，前面的Composable未消费，就继续向下传递，直到事件被消费。</p>

<p>如果是自己在pointerInput中直接处理事件，就要特别注意手动的把事件给消费掉，否则可能会继续传递。像awaitPointerEvent，awaitFirstDown，awaitDragOrCancellation等返回的都是<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/PointerInputChange">PointerInputChange</a>对象，调用它的<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/input/pointer/PointerInputChange#consume(">consume()</a>)方法即可把事件消费掉。再比如像上面的例子awaitTouchSlopOrCancellation中，也需要手动的把事件给消费掉，如果把ch.consume()这句删除，就会发现awaitDragOrCancellation不会得到执行，这是因为awaitTouchSlopOrCancellation这个方法还在执行中，调用ch.consume()把事件消费掉，这个函数才会返回。</p>

<p>这也说明了，还是要尽量用系统封装好的手势识别和手势处理函数，不到万不得已不要直接处理原始事件，因为逻辑写起来肯定相当复杂。</p>

<h2>多点触控</h2>

<p>多点触控是超过一个触点同时在屏幕上操作，最为常见的手势就是旋转和缩放，可以使用扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier#(androidx.compose.ui.Modifier">transformable</a>.transformable(androidx.compose.foundation.gestures.TransformableState,kotlin.Boolean,kotlin.Boolean))监听旋转，平移和缩放手势，其中平移单个触点也能触发，缩放和旋转则需要两个触点，当超过3个触点时这个函数不会回调，也即不会触发任何手势：</p>

<pre><code class="Kotlin">@Composable
private fun TransformableSample() {
    // set up all transformation states
    var scale by remember { mutableStateOf(1f) }
    var rotation by remember { mutableStateOf(0f) }
    var offset by remember { mutableStateOf(Offset.Zero) }
    val state = rememberTransformableState { zoomChange, offsetChange, rotationChange -&gt;
        scale *= zoomChange
        rotation += rotationChange
        offset += offsetChange
    }
    Box(
        Modifier
            // 把参数应用到图层去做变幻
            .graphicsLayer(
                scaleX = scale,
                scaleY = scale,
                rotationZ = rotation,
                translationX = offset.x,
                translationY = offset.y
            )
            // 接收变幻手势
            .transformable(state = state)
            .background(Color.Blue)
            .fillMaxSize()
    )
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/gestures-multitouch.gif" alt="multi_touch_demo" /></p>

<p>除了直接使用Modifier.transformable以外，还可以用前面提到过的pointerInput中的<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.input.pointer.PointerInputScope">detectTransformGestures</a>.detectTransformGestures(kotlin.Boolean,kotlin.Function4))这个函数也能得到平移，旋转和缩放的变化数值，把这些数值应用到graphicsLayer去做变幻就可以了，使用detectTransformGestures的另一个好处是可以与其他的手势结合起来。</p>

<h2>总结</h2>

<p>通过本文我们学习如何得到原始的触点事件，以及如何识别手势，相信对触点事件以及手势识别有了更深入的理解，并且借助这些扩展函数就可以写出交互性更好的应用程序界面。即使遇到一些复杂的交互 场景，或者需要组合多种手势时，也都能从容应对。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/understand-gestures">Understand gestures</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/multi-touch">Multitouch: Panning, zooming, rotating</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/user-interactions/handling-interactions">Handling user interactions</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『鱼跃于渊』| Gesture Handling]]></title>
    <link href="http://toughcoder.net/blog/2024/07/29/pointer-event-in-compose/"/>
    <updated>2024-07-29T20:41:20+08:00</updated>
    <id>http://toughcoder.net/blog/2024/07/29/pointer-event-in-compose</id>
    <content type="html"><![CDATA[<p>UI是用户界面，一个最为基础的功能就是与用户进行交互，要具有可交互性。要想有可交互性就需要处理用户输入事件。手势是最为常见的一种用户输入，今天就来专门学习一下如何处理Jetpack Compose中最为常见的手势。</p>

<p><a href=""><img src="https://koenig-media.raywenderlich.com/uploads/2022/10/GesturesInJetpackCompose-twitter.png" title="auto auto" ></a></p>

<!-- more -->


<h2>输入事件与手势概述</h2>

<p>在开始学习之前有必要先澄清一些概念，以免混淆。与View系统不太一样的是，触摸事件在Jetpack Compose中称之为触点事件（Pointer event），对应的主体称之为触点（Pointer），一连串的触点事件就形成了手势（Gesture）。之所以叫触点，是因为并不总是由触摸屏幕触发事件，也可以是手写笔，（外接）鼠标或者（外接）触摸板，这些都是触控类的输入主体，它的最主要的特点是发生在屏幕上的一个坐标点。其具体的类型称之为触点类型（Pointer type）。</p>

<p>事件处理最主要的是也就是要识别各种不同的触点手势，然后做出响应，以让UI具体可交互性。</p>

<h2>点击事件（Tap and Press）</h2>

<p>点击事件是最为常见，也是最为基础的一种手势了，可以简单的看成按下事件（pointer down）和抬起事件（pointer up）组成，但其实也会有移动（pointer move），只不过移动的位移特别小而已，这里我们不过多的纠结。点击事件分为单击，双击和长按，幸运的是在Compose中都有封装好的回调函数可以直接使用，我们一一来看一下。</p>

<h3>单击（Tap/Click）</h3>

<p>单击是最为常见的事件处理了，在之前的教程已经见过了，通过Modifier的扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier">Modifier.clickable</a>.clickable(kotlin.Boolean,kotlin.String,androidx.compose.ui.semantics.Role,kotlin.Function0))就可以为任意一个Composable设置单击事件处理函数。</p>

<h3>双击（Double tap/Double click）和长按（LongPress/Long click）</h3>

<p>对于双击和长按，并不像clickable那样常用，因此需要用到另外一个扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier">Modifier.combinedClickable</a>.combinedClickable(androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.foundation.Indication,kotlin.Boolean,kotlin.String,androidx.compose.ui.semantics.Role,kotlin.String,kotlin.Function0,kotlin.Function0,kotlin.Function0))，这个函数可以设置多个点击事件处理函数，单击双击和长按都可以通过它来设置：</p>

<pre><code class="Kotlin">    Box(
        modifier = Modifier
            .size(100.dp)
            .background(Color.Yellow)
            .combinedClickable(
                onClick = { gotoDetail() },
                onClickLabel = "Go to details",
                onLongClick = { showContextMneu() },
                onLongClickLabel = "Open context menu",
                onDoubleClick = { shareContent() }
            )
    )
</code></pre>

<h2>滚动（Scroll）</h2>

<p>滚动手势是指朝着某一固定的方向慢速的滑动，多用于查看屏幕之外的内容。像集合性布局设计的目的就是为了显示大量的同一类型的数据集合，天生就支持滚动。对于滚动手势需要处理的就是常规布局支持滚动，以及滚动的嵌套。</p>

<h3>非集合性布局支持滚动</h3>

<p>对于常规的非集合性布局（Box，Row和Column）正常情况下是不可滚动的，是没有办法查看超出其尺寸大小范围的内容的。想让这几个布局可滚动也不难，用Modifier的扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier">verticalScroll</a>.verticalScroll(androidx.compose.foundation.ScrollState,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean))和<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier">horizontalScroll</a>.horizontalScroll(androidx.compose.foundation.ScrollState,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean))就可以让不可滚动布局（Box，Row和Column）支持垂直方向滚动和水平方向滚动：</p>

<pre><code class="Kotlin">@Composable
private fun ScrollBoxes() {
    Column(
        modifier = Modifier
            .background(Color.LightGray)
            .size(100.dp)
            .verticalScroll(rememberScrollState())
    ) {
        repeat(10) {
            Text("Item $it", modifier = Modifier.padding(2.dp))
        }
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/gestures-simplescroll.gif" alt="scrollable_box" /></p>

<p>大部分情况下，如果只是想让布局可滚动就不需要处理<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/ScrollState">ScrollState</a>，但如果想要获取滚位置，或者改变滚动位置，比如说页面进入时（Initial composition）自动滚动到某一们位置，可以通过修改<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/ScrollState">SrollState</a>来实现：</p>

<pre><code class="Kotlin">@Composable
private fun ScrollBoxesSmooth() {
    // 进入页面时就自动的平滑的滚动
    val state = rememberScrollState()
    LaunchedEffect(Unit) { state.animateScrollTo(100) }

    Column(
        modifier = Modifier
            .background(Color.LightGray)
            .size(100.dp)
            .padding(horizontal = 8.dp)
            .verticalScroll(state)
    ) {
        // ...
    }
}
</code></pre>

<h3>滚动手势处理</h3>

<p>对于任意的Composable来文章，都可以通过Modifier的扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.Modifier">scrollable</a>.scrollable(androidx.compose.foundation.gestures.ScrollableState,androidx.compose.foundation.gestures.Orientation,kotlin.Boolean,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,androidx.compose.foundation.interaction.MutableInteractionSource))来监听并处理滚动手势。需要注意的是，scrollable仅会告诉你有滚动手势发生和当前的滚动距离，但并不会直接修改布局，需要开发者去使用滑动距离进行布局的修改：</p>

<pre><code class="Kotlin">@Composable
private fun ScrollableSample() {
    // actual composable state
    var offset by remember { mutableStateOf(0f) }
    Box(
        Modifier
            .size(150.dp)
            .scrollable(
                orientation = Orientation.Vertical,
                // Scrollable state: describes how to consume
                // scrolling delta and update offset
                state = rememberScrollableState { delta -&gt;
                    offset += delta
                    delta
                }
            )
            .background(Color.LightGray),
        contentAlignment = Alignment.Center
    ) {
        Text(offset.toString())
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/gestures-numeric-offset.gif" alt="handle_scrollable" /></p>

<p>如果让滚动对布局产生影响，可以用计算得到offset去改变布局的offset属性offset(y = offset.dp)就可以了。</p>

<h3>滚动嵌套</h3>

<p>手势处理最大的一个麻烦就是手势的嵌套，而又以滚动的嵌套最为麻烦，最为典型的就是同一方向的列表中套着列表，开发者必须手动处理滑动冲突。滚动冲突处理的策略并不难，优先由子View消费滚动事件，当子View还可以滚动时，就把事件消费掉；如果子View已到达边界，无法滚动时，视为事件未消费，把事件再传递给父View，由父View消费，这时父View会进行滚动；当然如果滑动事件没有发生在子View上面，那肯定 是父View滚动。</p>

<p>策略虽然简单，但有魔鬼细节，传统的View必须要在onTouch和onInterceptTouch里面写上大坨大坨的逻辑，还要定义很多个全局变量。幸运的是，针对 于同方向的可滚动布局嵌套，Jetpack Compose已经帮我们处理了。对于使用verticalScroll，horizontalScroll，scrollable，集合性布局（LazyRow，LazyColumn和LazyGrid）和TextField实现的同方向滚动嵌套，不用再特殊处理，Compose已经按照前面说的策略处理好了，这就是<strong>自动嵌套滚动机制（Automatic nested scrolling）</strong>。来看一个例子：</p>

<pre><code class="Kotlin">@Composable
private fun AutomaticNestedScroll() {
    val gradient = Brush.verticalGradient(0f to Color.Yellow, 1000f to Color.Red)
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .height(400.dp)
            .background(Color.LightGray)
            .verticalScroll(rememberScrollState())
            .padding(32.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        repeat(6) {
            Box(
                modifier = Modifier
                    .height(128.dp)
                    .verticalScroll(rememberScrollState())
            ) {
                Text(
                    "$it 滑动试试！",
                    modifier = Modifier
                        .align(Alignment.Center)
                        .border(12.dp, Color.DarkGray)
                        .background(brush = gradient)
                        .padding(24.dp)
                        .height(150.dp)
                )
            }
        }
    }
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/gesture/ascroll.gif" alt="nested_scrolling" />
这个例子中外层Column支持垂直滚动，里面的每个Box也支持垂直滚动，当里面的Box自己消费滚动时，外层 是不会动的，而当里面的Box无法滚动时（overscrolled）事件就到了外层的Column，即Column会滚动。</p>

<p><strong>注意：</strong>滚动嵌套并不是一个好的交互设计，尽管有技术手段解决，但用起来仍旧是怪怪的，操作起来也并不方便，误操作的可能性很大。不同方向的滚动嵌套在一起是比较好的方案，比如横向的Tab页代表不同的分类，竖向的内容页是一个分类中的具体内容，内容是竖向的，内容中仍旧可以有一些横向滑动的扩展内容，如图片库，tag标签等。</p>

<h2>拖拽（Drag）</h2>

<p>拖拽是指按住屏幕慢速移动，被点击到的UI元素应该跟随手势移动并停留在触点离开屏幕的地方。通过扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.Modifier">Modifier.draggable</a>.draggable(androidx.compose.foundation.gestures.DraggableState,androidx.compose.foundation.gestures.Orientation,kotlin.Boolean,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Boolean,kotlin.coroutines.SuspendFunction2,kotlin.coroutines.SuspendFunction2,kotlin.Boolean))可以处理单一方向的拖拽手势。在draggable中我们可以用状态记录移动的距离，然后把距离应用到Composable的offset以生成拖拽后的效果：</p>

<pre><code class="Kotlin">@Composable
private fun DraggableText() {
    var offsetX by remember { mutableStateOf(0f) }
    Text(
        modifier = Modifier
            .offset { IntOffset(offsetX.roundToInt(), 0) }
            .background(Color.LightGray)
            .padding(8.dp)
            .draggable(
                orientation = Orientation.Horizontal,
                state = rememberDraggableState { delta -&gt;
                    offsetX += delta
                }
            ),
        text = "降Compose十八掌！",
        style = MaterialTheme.typography.headlineLarge,
        color = MaterialTheme.colorScheme.primary
    )
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/gesture/drag.gif" alt="drag_demo" /></p>

<h2>滑动（Swipe/Fling）</h2>

<p>滑动与拖拽的区别在于滑动是有速度的，滑动手势在触点离开屏幕后并不会立即停止，而且是会继续朝原方向减速直到速度变为0才停，最为常见的交互方式就是滑动删除（swipe-to-dismiss），以及像列表的Fling手势。</p>

<p>使用Modifier的扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.Modifier">anchoredDraggable</a>.anchoredDraggable(androidx.compose.foundation.gestures.AnchoredDraggableState,androidx.compose.foundation.gestures.Orientation,kotlin.Boolean,kotlin.Boolean,androidx.compose.foundation.interaction.MutableInteractionSource))来处理滑动事件，定义一些<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/DraggableAnchors">锚点（DraggableAnchors）</a>，视为一个手势操作中的不同状态，比如像滑动开关，就是开和关，像滑动删除就是正常和已删除，再用一个<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/AnchoredDraggableState">AnchoredDraggableState</a>来追踪滑动的状态，这里面可以定义初始锚点，锚点值，和终止状态的阈值（positionalThreshold超过一定位置就认为到达终点锚点，velocityThreshold速度小于这个时就认为到达终点锚点），以及手势过程中的动画（animationSpec）。然后，再把AnchoredDraggableState中的滑动距离offset设置到Composable中即可。</p>

<p>说的挺复杂，其实很直观，看一个例子就明了：</p>

<pre><code class="Kotlin">enum class SwipeableSwitchState {
    SWITCH_ON, SWITCH_OFF
}

@OptIn(ExperimentalFoundationApi::class)
@Composable
private fun SwipeableSample() {
    val width = 128.dp
    val squareSize = 64.dp

    val density = LocalDensity.current
    val sizePx = with(density) { squareSize.toPx() }
    val anchors = DraggableAnchors {
        SwipeableSwitchState.SWITCH_ON at sizePx
        SwipeableSwitchState.SWITCH_OFF at 0f
    }
    val swipeableState = remember {
        AnchoredDraggableState(
            initialValue = SwipeableSwitchState.SWITCH_OFF,
            anchors = anchors,
            positionalThreshold = { d: Float -&gt; d * 0.4f },
            velocityThreshold = { with(density) { 100.dp.toPx() } },
            animationSpec = tween()
        )
    }
    Box(
        modifier = Modifier
            .width(width)
            .anchoredDraggable(
                state = swipeableState,
                orientation = Orientation.Horizontal,
                startDragImmediately = false
            )
            .background(Color.LightGray)
    ) {
        Box(
            Modifier
                .offset {
                    IntOffset(
                        if (swipeableState.offset.isNaN()) 0 else swipeableState.offset.roundToInt(),
                        0
                    )
                }
                .size(squareSize)
                .background(Color.DarkGray)
        )
    }
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/gesture/swipe.gif" alt="swipe_demo" />
这个例子展示了一个滑动开关的手势处理，滑动距离超过整体长度0.4时，或者速度小于100时就认为到达另一锚点状态。可以明显的看出与拖拽的区别，滑动后手可以离开，但手势仍在继续直到达到终点锚点。</p>

<p><strong>注意：</strong>在Compose 1.6版本以前有另外一个扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#(androidx.compose.ui.Modifier">swipeable</a>.swipeable(androidx.compose.material.SwipeableState,kotlin.collections.Map,androidx.compose.foundation.gestures.Orientation,kotlin.Boolean,kotlin.Boolean,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Function2,androidx.compose.material.ResistanceConfig,androidx.compose.ui.unit.Dp))来处理滑动手势，但在1.6版本时已废弃，被anchoredDraggable取代，并且有一个<a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/migrate-swipeable">替换的教程</a>。</p>

<h2>未完待续</h2>

<p>事件处理对于UI来说是极其重要的，本篇重点讲述了Jetpack Compose中的最为基础和最为常见的事件处理方式，足以满足绝大多数应用场景。事件处理也是极其复杂的，对于交互极其复杂的页面来说，还需要进一步的了解更为底层的事件处理方法，以达到复杂交互的目的，将在后面的文章中继续深入探讨事件处理。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/tap-and-press">Tap and press</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/drag-swipe-fling">Drag, swipe, and fling</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/scroll">Scroll</a></li>
<li><a href="https://canopas.com/how-to-implement-swipe-to-action-using-anchoreddraggable-in-jetpack-compose-cccb22e44dff">How to Implement Swipe-to-Action using AnchoredDraggable in Jetpack Compose</a></li>
<li><a href="https://fvilarino.medium.com/exploring-jetpack-compose-anchored-draggable-modifier-5fdb21a0c64c">Exploring Jetpack Compose Anchored Draggable Modifier</a></li>
<li><a href="https://medium.com/@AungThiha3/jetpack-compose-anchored-draggable-item-in-motionlayout-part-1-8d5a1cde880f">Jetpack Compose: Anchored Draggable Item in MotionLayout Part 1</a></li>
<li><a href="https://medium.com/@AungThiha3/jetpack-compose-anchored-draggable-item-in-motionlayout-part-2-c1fd94188e56">Jetpack Compose: Anchored Draggable Item in MotionLayout Part 2</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『双龙取水』| Text Edit]]></title>
    <link href="http://toughcoder.net/blog/2024/07/24/text-edit-in-compose/"/>
    <updated>2024-07-24T08:28:55+08:00</updated>
    <id>http://toughcoder.net/blog/2024/07/24/text-edit-in-compose</id>
    <content type="html"><![CDATA[<p>文本是所有UI系统中非常重要的一个种元素，文本的输入在UI框架中的重要性也特别的高，因为这是最重要的一种用户输入。今天专注于文本的输入处理，包括文本输入框，以及文本的选择和富式点击处理。</p>

<p><a href=""><img src="https://static.wixstatic.com/media/0d004d_ea93b43aabf348cb8f96c0dc94f85365~mv2.jpg/v1/fit/w_1000%2Ch_600%2Cal_c%2Cq_80/file.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>文本输入</h2>

<p>Compose提供了符合<a href="https://material.io/components/text-fields">Material Design</a>的文本输入<a href="https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#TextField(androidx.compose.ui.text.input.TextFieldValue,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Boolean,androidx.compose.ui.text.TextStyle,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Boolean,androidx.compose.ui.text.input.VisualTransformation,androidx.compose.foundation.text.KeyboardOptions,androidx.compose.foundation.text.KeyboardActions,kotlin.Boolean,kotlin.Int,kotlin.Int,androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.ui.graphics.Shape,androidx.compose.material.TextFieldColors">TextField</a>)，默认的实现是全填充的：</p>

<pre><code class="Kotlin">@Composable
fun SimpleFilledTextFieldSample() {
    var text by remember { mutableStateOf("Hello") }

    TextField(
        value = text,
        onValueChange = { text = it },
        label = { Text("Label") }
    )
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-textfield-hello.png" alt="textfield" />
还有一个边框式的<a href="https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#OutlinedTextField(kotlin.String,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Boolean,androidx.compose.ui.text.TextStyle,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Boolean,androidx.compose.ui.text.input.VisualTransformation,androidx.compose.foundation.text.KeyboardOptions,androidx.compose.foundation.text.KeyboardActions,kotlin.Boolean,kotlin.Int,kotlin.Int,androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.ui.graphics.Shape,androidx.compose.material.TextFieldColors">OutlinedTextField</a>)：</p>

<pre><code class="Kotlin">@Composable
fun SimpleOutlinedTextFieldSample() {
    var text by remember { mutableStateOf("") }

    OutlinedTextField(
        value = text,
        onValueChange = { text = it },
        label = { Text("Label") }
    )
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-outlinedtextfield.png" alt="outlined_textfield" />
可以看到TextField函数最关键的有三个参数：文本框中的显示的文本text，文本变化回调onValueChange，提示标签label。需要注意传给text的变量要是状态（State），这样才会触发重组，否则TextField显示的文本不会发生变化。</p>

<h3>定制TextField</h3>

<p>可以通过其他的参数来控制输入框的行为，最为常用的就是行数限制singleLine和maxLines， 以及文本的样式控制textStyle，它可以控制文本颜色和字体：</p>

<pre><code class="Kotlin">@Composable
fun StyledTextField() {
    var value by remember { mutableStateOf("Hello\nWorld\nInvisible") }

    TextField(
        value = value,
        onValueChange = { value = it },
        label = { Text("Enter text") },
        maxLines = 2,
        textStyle = TextStyle(color = Color.Blue, fontWeight = FontWeight.Bold),
        modifier = Modifier.padding(20.dp)
    )
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-textfield-multiline.png" alt="textfield_customize" />
textStyle比较丰富，除了直接指定颜色以外，还可以用<a href="https://developer.android.com/develop/ui/compose/text/style-text#brush">Brush API</a>，以实现一些颜色渐变，渐变效果是针对整个输入框的，换言之不同的行效果是一样的：</p>

<pre><code class="Kotlin">var text by remember { mutableStateOf("") }
val brush = remember {
    Brush.linearGradient(
        colors = listOf(Color.RED, Color.YELLOW, Color.GREEN, Color.BLUE)
    )
}
TextField(
    value = text, onValueChange = { text = it }, textStyle = TextStyle(brush = brush)
)
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-textfieldgradient.gif" alt="brush_textstyle" /></p>

<h3>与键盘联动</h3>

<p>TextField能够配置软件盘以实现特定输入样式，比如只输入数字，只有英文字符等等，通过TextField的keyboardOptions参数，传入一个<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/KeyboardOptions#KeyboardOptions(androidx.compose.ui.text.input.KeyboardCapitalization,kotlin.Boolean,androidx.compose.ui.text.input.KeyboardType,androidx.compose.ui.text.input.ImeAction">KeyboardOptions</a>)对象。常用的配置项有：</p>

<ul>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/KeyboardCapitalization">capitalization</a> 对于有大小写的语言来说，输入时词首自动大写</li>
<li>autoCorrect 自动更正</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/KeyboardType">keyboardType</a> 键盘类型，如纯字符，纯数字，E-mail地址，网址等等</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/ImeAction">imeAction</a> 让键盘的显示输入完成后的行为相关的按扭，比如<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/ImeAction#Search(">『搜索（Search）』</a>)，<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/ImeAction#Send(">『发送（Send）』</a>)等</li>
</ul>


<p>当输入完成后，用户点了imeAction指定的按扭后，可以指定回调函数以执行相关的操作，通过keyboardActions参数指定一个<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/KeyboardActions">KeyboardActions</a>对象，里面可以指定对应于imeAction中的各种回调，如onSearch会在imeAction指定为Search时，用户点击后触发；onSend会在imeAction是Send时，用户点击触发，等等。</p>

<h3>特殊形式的输入</h3>

<p>有些特殊的场景是不能够直接把用户的输入文本直接的展现在框里，比如输入密码时，再比如像输入电话号码时，可能会自动在3个数字后面加上短横线。这时就需要用到<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/VisualTransformation">VisualTransformation</a>来对文本进行转换处理：</p>

<pre><code class="Kotlin">@Composable
fun PasswordTextField() {
    var password by rememberSaveable { mutableStateOf("") }

    TextField(
        value = password,
        onValueChange = { password = it },
        label = { Text("Enter password") },
        visualTransformation = PasswordVisualTransformation(),
        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password)
    )
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-textfield-password.png" alt="password_textfield" /></p>

<h3>文本状态管理</h3>

<p>TextField的文本（text参数）是需要转换成状态的，这样才能更好的触发重组。基础的通用的TextField使用方式是，把文本转成状态，塞给TextField，然后在其onValueChange中再更新此状态：</p>

<pre><code class="Kotlin">    // ...
    var text by remember { mutableStateOf("") }

    TextField(
        value = text,
        onValueChange = { text = it },
    )
    // ...
</code></pre>

<p>但现实的代码不可能这么简单，用户的输入必然会有业务逻辑去处理，所以onValueChange肯定会调用ViewModel去处理用户输入。那么自然也要从ViewModel处获得。但由于TextField的特殊性，仍然要把使用MutableState来定义状态，而不能用响应式的Reactive stream或者StateFlow：</p>

<pre><code class="Kotlin">class SignUpViewModel(private val userRepository: UserRepository) : ViewModel() {

    var username by mutableStateOf("")
        private set

    fun updateUsername(input: String) {
        username = input
    }
}

// SignUpScreen.kt

@Composable
fun SignUpScreen(/*...*/) {

    OutlinedTextField(
        value = viewModel.username,
        onValueChange = { username -&gt; viewModel.updateUsername(username) }
        /*...*/
    )
}
</code></pre>

<h2>文本的选择</h2>

<p>除了文本输入以外，文本显示的选择也视为文字编辑的一种方式，因为选择之后就可以执行复制或者搜索等全局操作。Compose提供了细粒度的可交互式文本显示控制。Text本身是不支持选择的（Not Selectable），自然也就无法复制。可以使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/selection/package-summary#SelectionContainer(androidx.compose.ui.Modifier,kotlin.Function0">SelectableContainer</a>)来包裹Text以实现可选择（Selectable）：</p>

<pre><code class="Kotlin">@Composable
fun SelectableText() {
    SelectionContainer {
        Text("This text is selectable")
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-selected.png" alt="selectable_text" />
并且，可选择区域可以跨多个Text。与之相对的，还有不可选择函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/selection/package-summary#DisableSelection(kotlin.Function0">DisableSelection</a>)，比如一大片可选择文本中，想让某一小块文本不能被选择，这时DisableSelection就派上用场了：</p>

<pre><code class="Kotlin">@Composable
fun PartiallySelectableText() {
    SelectionContainer {
        Column {
            Text("This text is selectable")
            Text("This one too")
            Text("This one as well")
            DisableSelection {
                Text("But not this one")
                Text("Neither this one")
            }
            Text("But again, you can select this one")
            Text("And this one too")
        }
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-partially-selected.png" alt="disable_selection" /></p>

<p>可以看出对于文本的选择控制还是相当的灵活的（flexible）。</p>

<h2>富式文本点击</h2>

<p>对于针对 整个文本的点击事件可以用Modifier中的<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier">clickable</a>.clickable(kotlin.Boolean,kotlin.String,androidx.compose.ui.semantics.Role,kotlin.Function0))函数来处理，这跟常规的Composable没区别都一样的。但对于文本来说有更为细腻的点击事件处理，包括获取具体点击的光标位置，以及富式文本点击，也即针对 文本中不同部分的响应。</p>

<h3>获取点击的光标位置</h3>

<p>想要获取到文本中点击的光标位置，其实也就是点击的是第几个字符，可以用<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/package-summary#ClickableText(androidx.compose.ui.text.AnnotatedString,androidx.compose.ui.Modifier,androidx.compose.ui.text.TextStyle,kotlin.Boolean,androidx.compose.ui.text.style.TextOverflow,kotlin.Int,kotlin.Function1,kotlin.Function1">ClickableText</a>)，它有一个自己的onClick回调函数，里面的参数是一个offset表示被点击字符的索引：</p>

<pre><code class="Kotlin">@Composable
fun SimpleClickableText() {
    ClickableText(text = AnnotatedString("Click Me"), onClick = { offset -&gt;
        Log.d("ClickableText", "$offset -th character is clicked.")
    })
}
</code></pre>

<p>注意onClick的参数是文本字符串的索引，从0开始。这个索引一般用来确定点击的富文本中的某一个标记（Annotation）。</p>

<h3>富文本的点击处理</h3>

<p>Text是支持富文本的（基于<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/AnnotatedString">AnnotatedString</a>）。通过ClickableText中onClick的索引参数，就能知道点击的具体是哪个Annotation。比如一个超链接标记，具体的URL对用户是不可见的，作为额外的Tag信息在Annotation中，通过索引判断当点击到了超链接上面时，可以跳转到此URL：</p>

<pre><code class="Kotlin">@Composable
fun AnnotatedClickableText() {
    val annotatedText = buildAnnotatedString {
        append("Click ")

        // We attach this *URL* annotation to the following content
        // until `pop()` is called
        pushStringAnnotation(
            tag = "URL", annotation = "https://developer.android.com"
        )
        withStyle(
            style = SpanStyle(
                color = Color.Blue, fontWeight = FontWeight.Bold
            )
        ) {
            append("here")
        }

        pop()
    }

    ClickableText(text = annotatedText, onClick = { offset -&gt;
        // We check if there is an *URL* annotation attached to the text
        // at the clicked position
        annotatedText.getStringAnnotations(
            tag = "URL", start = offset, end = offset
        ).firstOrNull()?.let { annotation -&gt;
            // If yes, we log its value
            Log.d("Clicked URL", annotation.item)
        }
    })
}
</code></pre>

<h2>总结</h2>

<p>本文介绍了两种最常规的文本编辑，一是文本输入，一个是文本的选择和点击，这些都是日常项目开发中的非常常见的需求。Jetpack Compose对文本的操作提供了非常友好的支持，能够应付绝大部分的需求场景。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/text/user-input">Handle user input</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/text/user-interactions">Enable user interactions</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『或跃在渊』| Advanced Animations]]></title>
    <link href="http://toughcoder.net/blog/2024/07/24/advanced-animations-in-compose/"/>
    <updated>2024-07-24T08:26:32+08:00</updated>
    <id>http://toughcoder.net/blog/2024/07/24/advanced-animations-in-compose</id>
    <content type="html"><![CDATA[<p>对于Jetpack Compose来说动画是一个很大的话题，对应的API也比较繁杂，我们在<a href="https://juejin.cn/post/7385758285960609831">前面一篇文章</a>中介绍了最为常用的创建动画的方式，在此基础之上来学习一些更为复杂的动画玩法。</p>

<p><a href=""><img src="https://static.wixstatic.com/media/0d004d_3306bc9db6214c459f675f2a417cc718~mv2.jpeg/v1/fit/w_1000%2Ch_600%2Cal_c%2Cq_80/file.jpeg" title="auto auto" ></a></p>

<!-- more -->


<h2>动画的本质：参数随时间变化</h2>

<p>前面的文章提到过属性驱动动画，比如<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/package-summary#animateFloatAsState(kotlin.Float,androidx.compose.animation.core.AnimationSpec,kotlin.Float,kotlin.String,kotlin.Function1">animateFloatAsState</a>)，本质上就是让数值随时间变化，数值再作为Composable的属性去驱动变幻，进而产生动画效果。那一坨animate&#42;AsState都是通过一个animateValueAsState函数来实现的，这个函数是一个泛型，它可以把任意的数据类型转成随时间变化的动画状态。所以当遇到自定义的数据类型时，就可以使用animateValueAsState来驱动动画。这些属性动画函数animate&#42;AsState是基于更底层的<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Animatable">Animatable</a>实现的。</p>

<h2>使用Transition来组合属性动画</h2>

<p>当动画比较复杂时，比如涉及多个属性的变化时，如果仍然使用animate&#42;AsState那一坨，虽然也是可以行的，但会让代码和逻辑都混乱不堪，特别是如果要协调多个属性动画时就更为困难。这样实现还有一个更大的问题，那就是无法复用，理论上来说动画与UI应该解耦，即使没有动效UI也是可用的，动效也应该可以应用于不同的UI。</p>

<p>这时就可以使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Transition">Transition</a>来管理和组合多个属性动画。但是Transition并不是像<a href="https://developer.android.com/reference/android/animation/AnimatorSet">AnimatorSet</a>那样的单纯的管理器，它其实是另一种概念的抽象，意为过渡，从一种状态过渡到另一种状态，状态变化的细节就是各种属性的变化。Transition支持泛型，也就是状态完全自定义，Transition定义了很多变更数值的方法如animateFloat，animateColor，animateDp等等可以用于更新不同的属性数值。前一篇文章中提到的所见即所得的动画函数（AnimatedVisibility，Crossfade和AnimatedContent）都是基于Transition来实现的。而Transition与属性动画函数animate&#42;AsState并不一样，是基于更底层的<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Animation">Animation</a>实现的。</p>

<h3>Transition创建动画的具体步骤</h3>

<p>Transition是对两个不同的状态之间过渡的封装，因此先要定义状态，基于动效的目标和特点定义状态即可，一般用枚举类型就行了，因为状态仅用于代表过渡中的一个时间点，并没有具体的意义。接下来，使用remember函数转成为Compose的State，以便能触发Recomposition，然后调用函数updateTransition来得到当前时刻的过渡状态：</p>

<pre><code class="Kotlin">enum class BoxState {
    Collapsed,
    Expanded
}
var currentState by remember { mutableStateOf(BoxState.Collapsed) }
val transition = updateTransition(currentState, label = "box state")
</code></pre>

<p>这三步是通用的，使用Transition时都一样。然后就是对于当前时刻过渡状态的去定义具体的属性数值，这步也是自定义的，看要实现的动效而定，可以使用扩展函数animate&#42;来得到的具体的数值：</p>

<pre><code class="Kotlin">val rect by transition.animateRect(label = "rectangle") { state -&gt;
    when (state) {
        BoxState.Collapsed -&gt; Rect(0f, 0f, 100f, 100f)
        BoxState.Expanded -&gt; Rect(100f, 100f, 300f, 300f)
    }
}
val borderWidth by transition.animateDp(label = "border width") { state -&gt;
    when (state) {
        BoxState.Collapsed -&gt; 1.dp
        BoxState.Expanded -&gt; 0.dp
    }
}
</code></pre>

<p>最后，把得到的属性数值rect和borderWidth应用到Composable上即可。</p>

<h3>Transition是支持创建子Transition</h3>

<p>对于Composable结构复杂的情况时，还可以使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Transition#(androidx.compose.animation.core.Transition">createChildTransition</a>.createChildTransition(kotlin.String,kotlin.Function1))来为子布局创建Transition。这样就能够把Transition也按树形关系组织起来，以能让动效更加的协调。</p>

<h3>使用Transition来封装动画</h3>

<p>使用Transition最大的好处在于能够把动效封装起来以能复用：</p>

<pre><code class="Kotlin">enum class BoxState { Collapsed, Expanded }

// Holds the animation values.
private class TransitionData(
    color: State&lt;Color&gt;,
    size: State&lt;Dp&gt;
) {
    val color by color
    val size by size
}

// Create a Transition and return its animation values.
@Composable
private fun updateTransitionData(boxState: BoxState): TransitionData {
    val transition = updateTransition(boxState, label = "box state")
    val color = transition.animateColor(label = "color") { state -&gt;
        when (state) {
            BoxState.Collapsed -&gt; Color.Gray
            BoxState.Expanded -&gt; Color.Red
        }
    }
    val size = transition.animateDp(label = "size") { state -&gt;
        when (state) {
            BoxState.Collapsed -&gt; 64.dp
            BoxState.Expanded -&gt; 128.dp
        }
    }
    return remember(transition) { TransitionData(color, size) }
}
</code></pre>

<p>创建好的Transition可以用于任意的Composable：</p>

<pre><code class="Kotlin">@Composable
fun AnimatingBox(
    modifier: Modifier = Modifier.fillMaxSize()
) {
    var boxState by remember { mutableStateOf(BoxState.Expanded) }
    val transitionData = updateTransitionData(boxState)
    // UI tree
    Box(
        modifier = Modifier
            .background(transitionData.color)
            .size(transitionData.size)
            .clickable {
                boxState =
                    if (boxState == BoxState.Expanded) BoxState.Collapsed else BoxState.Expanded
            }
    )
}

@Composable
fun AnimatingColumn(
    modifier: Modifier = Modifier.fillMaxSize()
) {
    var boxState by remember { mutableStateOf(BoxState.Collapsed) }

    LaunchedEffect(Unit) {
        boxState = BoxState.Expanded
    }

    val transitionData = updateTransitionData(boxState)
    Column(
        modifier = Modifier
            .background(transitionData.color)
            .size(transitionData.size)
    ) {
        Text("Apply to a column")
    }
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/animation/anim_transition.gif" alt="transition_demo" /></p>

<p>可以看一看<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#AnimatedVisibility(kotlin.Boolean,androidx.compose.ui.Modifier,androidx.compose.animation.EnterTransition,androidx.compose.animation.ExitTransition,kotlin.Function1">AnimatedVisibility</a>)以及<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#Crossfade(kotlin.Any,androidx.compose.ui.Modifier,androidx.compose.animation.core.FiniteAnimationSpec,kotlin.String,kotlin.Function1">Crossfade</a>)和<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#AnimatedContent(kotlin.Any,androidx.compose.ui.Modifier,kotlin.Function1,androidx.compose.ui.Alignment,kotlin.Function2">AnimatedContent</a>)的实现，它们都是基于Transition实现的。</p>

<h2>动画的底层API</h2>

<p>到现在我们已经学习了很多创建动画的方式，从封装的层次来说，最上层是所见即所得动画函数如AnimatedVisibility，Crossfade和AnimatedContent，它们是基于<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Transition">Transition</a>实现的；属性动画函数animate&#42;AsState是基于Animatable实现的。这些函数都是Composables，也就是必须在Composition环境中才能使用。而Animatable和Transition都是基于最底层的Animation实现的，Animatable和Animation类似于View系统中的<a href="https://developer.android.com/reference/android/animation/Animator">Animator</a>，管理着某种值随时间在两个状态之间变化。它们两个只与值和时间有关，与Composition无关，因此可以在任意上下文中使用。可以用官方提供的一张图，来搞清楚API之间的关系：</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/animation-low-level.svg" alt="anim_api_level" /></p>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Animation">Animation</a>是最为底层的API，它只管理着值随时间的变化，其余的事情像动画是否已开始，是否已结束都需要调用者自己管理。它使用起来相当的麻烦，除非有必要否则一般不建议直接使用这个对象，本文也不再讨论它。</p>

<p>可以重点研究一下<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Animatable">Animatable</a>，它是基于Animation的，但是封装的较为完整。它是基于协程的单个数值变化动画，它能保证数值的变化是连续的，不过它的主要方法如<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Animatable#animateTo(kotlin.Any,androidx.compose.animation.core.AnimationSpec,kotlin.Any,kotlin.Function1">animateTo</a>)都是suspend的，意味着要在协程上下文中调用，比如启动动画就要用Animatable：</p>

<pre><code class="Kotlin">val color = remember { Animatable(Color.Gray) }
LaunchedEffect(ok) {
    color.animateTo(if (ok) Color.Green else Color.Red)
}
Box(Modifier.fillMaxSize().background(color.value))
</code></pre>

<p>使用Animatable可以创建出很多富有创意的复杂动画，比如说多米诺式的顺次动画，以及并发动画。</p>

<h3>多个部件顺次动画</h3>

<p>多个部件的顺次动画也就是依次发生的动画，比如A，B，和C三个动画作用于不同的UI部件，A先启动，结束后B接着启动，结束后C再启动。比较常规的方式是使用动画回调，在前一个的结束回调中启动下一个，或者使用延时启动，B的启动延时设置为A的动画时长。</p>

<p>借助于Animatable，可以有更为优雅的方案，在同一个协程中依次调用不同的Animatable的animateTo函数就可以，让几个不同的Animatable依次启动了：</p>

<pre><code class="Kotlin">val alphaAnimation = remember { Animatable(0f) }
val yAnimation = remember { Animatable(0f) }

LaunchedEffect("animationKey") {
    alphaAnimation.animateTo(1f)
    yAnimation.animateTo(100f)
    yAnimation.animateTo(500f, animationSpec = tween(100))
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/animations/multiple_properties_sequential.gif" alt="anim_sequential_flow" />
注意，这个动图展示的是顺次动画的流程图，而非一个案例的效果。</p>

<h3>多个部件并发动画</h3>

<p>类似的还有并发动画，就是作用于多个不同的部件的动画同时启动，这个其实相较于顺次动画要容易一些，因为我们用Transition组合多个属性动画实际上就是并发动画。</p>

<p>除了Transition以外，用多个Animatable也可以，我们只需要启动多个协程去执行animateTo即可：</p>

<pre><code class="Kotlin">val alphaAnimation = remember { Animatable(0f) }
val yAnimation = remember { Animatable(0f) }

LaunchedEffect("animationKey") {
    launch {
        alphaAnimation.animateTo(1f)
    }
    launch {
        yAnimation.animateTo(100f)
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/animations/multiple_properties.gif" alt="anim_concurrent_flow" />
注意，这个是并发动画的流程图，而非动画效果。</p>

<h2>集合性布局中的元素项动画</h2>

<p>对于集合性布局来说，当其元素项发生变化时，会触发相应的动画效果，这就是<a href="https://developer.android.com/develop/ui/compose/lists#item-animations">item animations</a>。我们只需要1）为每个子元素项定义一个集合中唯一标识的key；2）然后再调用扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/lazy/LazyItemScope#(androidx.compose.ui.Modifier">Modifier.aniamteItem</a>.animateItem(androidx.compose.animation.core.FiniteAnimationSpec,androidx.compose.animation.core.FiniteAnimationSpec,androidx.compose.animation.core.FiniteAnimationSpec))；即可以在元素项变化时触发动画，它会子元素项出现，消失和发生替换时触发动画效果。</p>

<h2>动画最佳实践</h2>

<p>我们学习了这么多创建动画的方式，在实际项目中要遵守几个原则：1）尽可能优先使用Compose封装好的动画函数，不要重复造轮子；2）第二个就是要为每个动画设置一个label，所有的动画API都会有一个label参数，要尽可能为每个动画设置一个唯一的label，这个是用于Android Studio调试动画时的唯一标识。</p>

<p>再有就是动画会触发Recomposition，re-layout和re-draw，为了尽可能的避免减少re-layout和re-draw，要尽可能的使用已封装好的函数来修改属性，比如使用Modifier的扩展函数（如<a href="https://developer.android.com/develop/ui/compose/graphics/draw/modifiers">Modifier.graphicsLayer {}</a>），而不是直接去改size或者padding。</p>

<h2>References</h2>

<ul>
<li><a href="https://proandroiddev.com/animating-inside-and-outside-the-box-with-jetpack-compose-a56eba1b6af6">Animating Inside and Outside the Box with Jetpack Compose</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/value-based">Value-based animations</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/vectors">Animated vector images in Compose</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/advanced">Advanced animation example: Gestures</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
