<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2025-03-28T22:14:32+08:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[实战：在Compose中优雅地实现提示]]></title>
    <link href="https://alexhilton.github.io/blog/2025/03/28/hints-in-compose/"/>
    <updated>2025-03-28T22:05:00+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/03/28/hints-in-compose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自<a href="https://proandroiddev.com/hints-in-compose-10b6470acc58">Hints in Compose</a>，原文由<a href="https://medium.com/@vitoksmile">Viktor Mykhailiv</a>发布于2025年2月13日，文章内容巨详细，TL;DR;。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0jBirMqQV-aXKXw5gekEkQ.jpeg" title="auto auto" ></a></p>

<!-- more -->


<p>有时我们的应用需要突出显示某些 UI 组件，例如在首次登录（首次使用）时，或者当我们添加新内容（“新功能”）时。</p>

<p>在本文中，我将指导如何构建自定义解决方案来显示提示/工具提示，指向 Compose（Compose Multiplatform 和 Jetpack Compose）中的特定 UI 元素。</p>

<h2>布局层次</h2>

<p>要突出显示 UI 元素，首先我们应该了解“提示”(Hints)的主要概念。
假设我们有一个带有 TopBar、BottomNavigation 和主要操作按钮的应用程序。我们想要突出显示 TopBar 的操作、主要按钮和 BottomNavigation 中的一个项目。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7K0zoXqZM0ajYYZARn6I5w.png" alt="Layout hierarchy" /></p>

<p>对于我们的“提示”，我们需要绘制一个暗淡的背景（也是为了拦截触摸事件），计算突出显示的 UI 元素的位置，剪掉（屏蔽）我们的元素形状以免变暗，最后绘制一个提示（例如带有背景的文本）。</p>

<h2>1. 暗淡的背景</h2>

<p>要在所有内容之上绘制一个暗淡的背景作为覆盖或弹出窗口，我们可以：</p>

<h3>a. 使用自定义可组合项包装我们应用（根组件）的所有内容（例如带有 Modifier.background 的 Box）</h3>

<pre><code class="Kotlin">@Composable
fun AppContent() {
   HintOverlay {
      MaterialTheme {
         Scaffold {
            // 我的应用内容
         }
      }
   }
}
</code></pre>

<h3>b. 使用对话框</h3>

<p>通过使用对话框，我们可以在所有内容之上显示一个覆盖层（例如，在 Android 上，对话框显示在自己的窗口中）。
使用对话框时，Compose Multiplatform 中的 scrimColor 会出现问题。我们无法从 Compose 通用目标配置 scrimColor ，但每个目标（Android 除外）都为 scrimColor 提供了一个实际值。作为一种可能的解决方案，我们可以创建一个例外类来提供对话框属性并为每个目标提供实际实现。</p>

<h3>c. 使用 Popup</h3>

<p>Popup 在这里看起来更好，因为它默认不绘制 scrimColor，并且覆盖层显示在所有内容之上。</p>

<p>我会采用第三种方法，不强制手动使用 HintOverlay。</p>

<p>我还想为覆盖层背景添加 Brush 支持，而不仅仅是 Color 。</p>

<pre><code class="Kotlin">val LocalHintOverlayColor = staticCompositionLocalOf&lt;Color&gt; { Color(0x44000000) }

val LocalHintOverlayBrush = staticCompositionLocalOf&lt;Brush?&gt; { null }

@Composable
fun HintOverlay() {
    Popup {
        Box(
            modifier = Modifier
                .fillMaxSize()
                .overlayBackground()
        ) {
            Text(
                modifier = Modifier.align(Alignment.Center),
                text = "Draw hints here",
                color = Color.White,
            )
        }
    }
}

/**
 * 从 [LocalHintOverlayBrush] 或 [LocalHintOverlayColor] 设置 `background`。
 */
private fun Modifier.overlayBackground(): Modifier = composed {
    LocalHintOverlayBrush.current?.let { background(it) }
        ?: background(LocalHintOverlayColor.current)
}
</code></pre>

<p>我可以使用CompositionLocalProvider 设置 Brush 来覆盖覆盖的背景。</p>

<pre><code class="Kotlin">CompositionLocalProvider(
    LocalHintOverlayBrush provides Brush.linearGradient(
        listOf(
            Color.Red.copy(alpha = 0.5f),
            Color.Blue.copy(alpha = 0.5f),
        )
    ),
) {
    HintOverlay()
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KrHuSNZT0zE-Eddz1GBA2A.png" alt="Dimmed background" /></p>

<h2>2. 计算锚点坐标</h2>

<p>要获取 Compose 中 UI 元素的坐标，我们可以使用OnGloballyPositionedModifier ，当内容的全局位置可能发生变化时，会使用布局的最终​​ LayoutCoordinates 调用该方法。</p>

<p>使用示例：</p>

<pre><code class="Kotlin">Column(
    Modifier.onGloballyPositioned { coordinates -&gt;
        // 这将是Column的大小。
        coordinates.size
        // Column相对于应用程序窗口的位置。
        coordinates.positionInWindow()
        // Column相对于 Compose 根的位置。
        coordinates.positionInRoot()
        // 这些将是提供给布局的对齐线（此处的Column为空）。
        coordinates.providedAlignmentLines
        // 这将是与 Column 的父级相对应的 LayoutCoordinates 实例。
        coordinates.parentLayoutCoordinates
    }
) {
    Box(Modifier.size(20.dp).background(Color.Green))
    Box(Modifier.size(20.dp).background(Color.Blue))
}
</code></pre>

<p>对于我们的提示，我们需要创建一个状态来保存锚点的坐标和大小，并引入一个修改器来更新状态：</p>

<pre><code class="Kotlin">@Stable
class HintAnchorState internal constructor() {

    internal var size: IntSize by mutableStateOf(IntSize.Zero)

    internal var offset: Offset by mutableStateOf(Offset.Zero)
}

@Composable
fun rememberHintAnchorState(): HintAnchorState {
    return remember { HintAnchorState() }
}

fun Modifier.hintAnchor(state: HintAnchorState): Modifier {
    return onGloballyPositioned {
        state.size = it.size
        state.offset = it.positionInWindow()
    }
}
</code></pre>

<p>因此，我们只需订阅所需 UI 元素的大小和坐标变化即可更新锚点的状态。
现在我们需要将此 hintAnchor 修饰符应用于我们的内容：</p>

<pre><code class="Kotlin">val topAppBarActionHintAnchor = rememberHintAnchorState()
val actionHintAnchor = rememberHintAnchorState()
val bottomNavigationHintAnchor = rememberHintAnchorState()

IconButton(
    modifier = Modifier
        .hintAnchor(topAppBarActionHintAnchor),
    onClick = {},
)

Button(
    modifier = Modifier
        .hintAnchor(actionHintAnchor)
        .padding(4.dp),
    onClick = {},
) {
    Text("Action")
}

BottomNavigationItem(
    modifier = Modifier
        .hintAnchor(topAppBarActionHintAnchor),
    //... 传入其他需要的参数
)
</code></pre>

<blockquote><p><strong>注意：</strong> 修饰符顺序在 Compose 中始终很重要，我们在 hintAnchor 后设置 4.dp，以便在此按钮周围留出额外空间（锚点的尺寸将比实际按钮的尺寸大 4.dp）。</p></blockquote>

<p>HintOverlay 可组合项需要进行一些更改才能使用 HintAnchorState为此锚点绘制提示。</p>

<pre><code class="Kotlin">@Composable
fun HintOverlay(
    anchors: () -&gt; List&lt;HintAnchorState&gt;,
) {
    Box(
        modifier = Modifier
            .fillMaxSize()
            .overlayBackground(anchors)
    )
}

/**
 * 从 [LocalHintOverlayBrush] 或 [LocalHintOverlayColor] 设置“background”。
 */
private fun Modifier.overlayBackground(
    anchors: () -&gt; List&lt;HintAnchorState&gt;,
): Modifier = composed {
    val backgroundBrush = LocalHintOverlayBrush.current
    val backgroundColor = LocalHintOverlayColor.current

    drawWithCache {
        onDrawWithContent {
            if (backgroundBrush != null) {
                drawRect(backgroundBrush)
            } else {
                drawRect(backgroundColor)
            }

            anchors().forEach { anchor -&gt;
                drawRect(
                    color = Color.Red,
                    topLeft = anchor.offset,
                    size = anchor.size.toSize(),
                    style = Stroke(width = 5f),
                )
            }

            drawContent()
        }
    }
}
</code></pre>

<p>现在我们只需在锚点周围画一个红色矩形：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EqvV4AHsimwvwZxajIgtXg.png" alt="Anchors" /></p>

<p>但如果我们在移动设备上运行，我们会在 Android 上得到错误的数字：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2wennrPOIcKArOK4MuayAQ.png" alt="With Window Insets" /></p>

<p>该问题与 WindowInsets 有关。让我们减去这些 insets 来修复它：</p>

<pre><code class="Kotlin">fun Modifier.hintAnchor(state: HintAnchorState): Modifier = composed {
    val statusBarInsets = WindowInsets.statusBars.getTop(LocalDensity.current).toFloat()

    onGloballyPositioned {
        state.size = it.size
        state.offset = it.positionInWindow()
            // 修复 Android 上的 WindowInsets
            .minus(Offset(x = 0f, y = statusBarInsets))
    }
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LlrCLPAEgpk7q--X7i3UsA.png" alt="Fixed window insets" /></p>

<h2>3. 剪辑出锚点的形状</h2>

<p>要剪辑形状，我们将使用 Path 和 PathOperation 。修改 hintAnchor Modifier 以接受 Shape ，它将用于在锚点周围设置所需的形状。</p>

<pre><code class="Kotlin">fun Modifier.hintAnchor(
    state: HintAnchorState,
    shape: Shape = RectangleShape,
): Modifier {
    state.shape = shape
    //..onGloballyPositioned
}

@Stable
class HintAnchorState internal constructor() {

    //...其他的状态放这里

    internal var shape: Shape by mutableStateOf(RectangleShape)
}
</code></pre>

<p>根据提供的形状，我们可以创建一个轮廓，用于将锚点的形状从背景中剪掉：</p>

<pre><code class="Kotlin">internal fun Modifier.overlayBackground(
    anchors: () -&gt; List&lt;HintAnchorState&gt;,
): Modifier = composed {
    val backgroundBrush = LocalHintOverlayBrush.current
    val backgroundColor = LocalHintOverlayColor.current
    val layoutDirection = LocalLayoutDirection.current
    val density = LocalDensity.current

    drawWithCache {
        // 准备背景路径
        val path = Path().apply {
            lineTo(size.width, 0f)
            lineTo(size.width, size.height)
            lineTo(0f, size.height)
            lineTo(0f, 0f)
            close()
        }

        anchors().forEach { anchor -&gt;
            // 为锚点准备路径
            val anchorPath = Path()
            anchorPath.addOutline(
                anchor.shape.createOutline(
                    size = anchor.size.toSize(),
                    layoutDirection = layoutDirection,
                    density = density,
                )
            )
            anchorPath.translate(anchor.offset)
            anchorPath.close()

            // 裁剪掉锚点
            path.op(path, anchorPath, PathOperation.Xor)
        }

        onDrawWithContent {
            // 我们不仅仅绘制路径，而不是像以前一样绘制矩形
            if (backgroundBrush != null) {
                drawPath(path, backgroundBrush)
            } else {
                drawPath(path, backgroundColor)
            }

            drawContent()
        }
    }
}
</code></pre>

<p>让我们传递 CircleShape 和 RoundedCornerShape 来看看提示现在是什么样子：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*i2dWMv3Wa9at-fzGiKm8KQ.png" alt="Clip" /></p>

<p>此时，我们知道如何绘制背景覆盖层、计算锚点的位置以及如何剪裁背景。</p>

<h2>4. 绘制提示</h2>

<p>在实际绘制之前，我们应该定义提示需要呈现哪些信息。</p>

<p>为了不强制只提供文本，我们采用slot方法。通过定义slot，我们允许使用任何所需的composables。</p>

<p>我将介绍一个新的类 Hint 来保存我们的Composable内容：</p>

<pre><code class="Kotlin">@Stable
class Hint internal constructor() {

    internal var content: @Composable () -&gt; Unit by mutableStateOf({})
}

@Composable
fun rememberHint(content: @Composable () -&gt; Unit): Hint {
    return remember {
        Hint().also { it.content = content }
    }
}
</code></pre>

<p>并将此 Hint 添加为 HintAnchorState 的一部分：</p>

<pre><code class="Kotlin">@Stable
class HintAnchorState internal constructor(
    internal val hint: Hint,
) {
    //...其他的状态放这里
}

@Composable
fun rememberHintAnchorState(hint: Hint): HintAnchorState {
    return remember(hint) {
        HintAnchorState(hint)
    }
}
</code></pre>

<p>在 HintOverlay 内部，我们可以采用最简单的解决方案 — BoxWithConstraints ：</p>

<pre><code class="Kotlin">@Composable
fun HintOverlay(
    anchors: () -&gt; List&lt;HintAnchorState&gt;,
) {
    //...
    BoxWithConstraints(
        modifier = Modifier
            .fillMaxSize()
            .overlayBackground(anchors)
    ) {
        anchors().forEach { anchor -&gt;
            Box(
                modifier = Modifier
                    .graphicsLayer {
                        translationX = anchor.offset.x
                        translationY = anchor.offset.y + anchor.size.height
                    },
            ) {
                anchor.hint.content()
            }
        }
    }
}
</code></pre>

<p>修改应用程序内容：</p>

<pre><code class="Kotlin">val topAppBarHint = rememberHint {
    OutlinedButton(onClick = {}) { Text("Hint for TopAppBar") }
}
val topAppBarActionHintAnchor = rememberHintAnchorState(topAppBarHint)

val actionHint = rememberHint {
    Text("Hint for Action")
}
val actionHintAnchor = rememberHintAnchorState(actionHint)

val bottomNavigationHint = rememberHint {
    Row(
        verticalAlignment = Alignment.CenterVertically,
    ) {
        Spacer(Modifier.size(32.dp).background(Color.Magenta, CircleShape))
        Spacer(Modifier.size(8.dp))
        Text("Hint for BottomNavigation")
    }
}
val bottomNavigationHintAnchor = rememberHintAnchorState(bottomNavigationHint)
</code></pre>

<p>结果如下：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mMenE2fp2jph6YUBlxX4pA.png" alt="Hint for action" /></p>

<p>让我们引入一个应用程序特定的代码来绘制提示背景。</p>

<pre><code class="Kotlin">@Composable
fun rememberHintContainer(content: @Composable () -&gt; Unit): Hint {
    return rememberHint {
        Box(
            modifier = Modifier
                .padding(top = 8.dp)
                .background(Color.Yellow, shape = RoundedCornerShape(16.dp))
                .padding(16.dp),
        ) {
            CompositionLocalProvider(
                LocalTextStyle provides TextStyle(
                    color = Color.Black,
                    fontSize = 12.sp,
                    fontWeight = FontWeight.Light,
                ),
            ) {
                content()
            }
        }
    }
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xn8pxlU_nUQvywbtqVwUtw.png" alt="Hint2" /></p>

<p>我们遇到了 2 个问题：</p>

<ol>
<li>水平对齐，提示应与其锚点居中对齐。</li>
<li>BottomNavigation 的提示超出了屏幕范围。</li>
</ol>


<p>让我们改用自定义布局并修复这些问题。</p>

<p>要测量和布局多个可组合项，请使用 Layout。此composable允许我们手动测量和布局子项。所有更高级别的布局（如 Column 和 Row）都是使用 Layout 实现的。</p>

<pre><code class="Kotlin">@Composable
internal fun HintsContainer(
    modifier: Modifier,
    anchors: () -&gt; List&lt;HintAnchorState&gt;,
) {
    val anchors = anchors()

    Layout(
        modifier = modifier
            .overlayBackground(anchors),
        content = {
            anchors.forEach { it.hint.content() }
        },
    ) { measurables, constraints -&gt;
        // 测量每一个提示
        val placeables = measurables.map { measurable -&gt;
            measurable.measure(
                constraints.copy(minWidth = 0, minHeight = 0)
            )
        }

        // 将布局尺寸设置得尽可能大
        layout(constraints.maxWidth, constraints.maxHeight) {
            // 将每个提示相对于其锚点放置
            placeables.forEachIndexed { index, placeable -&gt;
                val anchor = anchors[index]

                // 将此提示居中对齐
                val x = (anchor.offset.x.toInt() - (placeable.width - anchor.size.width) / 2)
                    // 修复超出屏幕的坐标
                    .coerceAtLeast(0)
                    .coerceAtMost(constraints.maxWidth - placeable.width)

                // 把这个提示放在它的锚点下面
                var y = (anchor.offset.y.toInt() + anchor.size.height)
                    // 如果超出屏幕，则修复 y 坐标
                    .coerceAtMost(constraints.maxHeight - placeable.height)
                if (y &lt; anchor.offset.y + anchor.size.height) {
                    // 提示与锚点重叠，请将此提示放在其锚点上方
                    y = anchor.offset.y.toInt() - placeable.height
                }

                placeable.placeRelative(x = x, y = y)
            }
        }
    }
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*syuJkuAd-_BgiYfFP8bKgQ.png" alt="Hint3" /></p>

<p>因为我们允许传递任何可组合项作为提示，所以调用者可以完全控制提示的外观，例如，我们可以只使用 Text ，或者使用包含许多子项的复杂 Row 。</p>

<h2>5. 如何控制提示？</h2>

<p>我们静态地添加了提示以将其显示在屏幕上。但真正产品应用程序并非如此。让我们引入 HintController 来控制何时显示提示。</p>

<pre><code class="Kotlin">@Stable
class HintController internal constructor() {

    internal var hint by mutableStateOf&lt;HintAnchorState?&gt;(null)

    fun show(hint: HintAnchorState) {
        this.hint = hint
    }
}

@Composable
fun rememberHintController(): HintController {
    val controller = remember { HintController() }

    controller.hint?.let { hint -&gt;
        HintOverlay(anchor = hint)
    }

    return controller
}
</code></pre>

<p>修改应用程序内容，以便在我们点击锚点时显示提示：</p>

<pre><code class="Kotlin">val hintController = rememberHintController()

IconButton(
    modifier = Modifier
        .hintAnchor(topAppBarActionHintAnchor, CircleShape),
    onClick = {
        hintController.show(topAppBarActionHintAnchor)
    },
)

BottomNavigationItem(
    modifier = Modifier
        .hintAnchor(
            bottomNavigationHintAnchor,
            shape = RoundedCornerShape(50f),
        ),
    onClick = {
        hintController.show(bottomNavigationHintAnchor)
    },
)

Button(
    modifier = Modifier
        .hintAnchor(actionHintAnchor, RoundedCornerShape(16.dp))
        .padding(4.dp),
    onClick = {
        hintController.show(actionHintAnchor)
    },
)
</code></pre>

<blockquote><p>注意：我们不再需要显示的 HintOverlay ，它现在变得内置了。</p></blockquote>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jIOTXOSnHVeL_jjyEx1gdg.png" alt="Control" /></p>

<p>现在我们可以逐一显示提示，但还有两个部分缺失：如何关闭提示，以及如何覆盖覆盖颜色。</p>

<p>对提示控制器进行更改以允许传递覆盖颜色：</p>

<pre><code class="Kotlin">@Composable
fun rememberHintController(overlay: Brush): HintController {
    return rememberHintController(overlay = LocalHintOverlayBrush provides overlay)
}

@Composable
fun rememberHintController(overlay: Color = HintOverlayColorDefault): HintController {
    return rememberHintController(overlay = LocalHintOverlayColor provides overlay)
}

@Composable
private fun rememberHintController(overlay: ProvidedValue&lt;*&gt;): HintController {
    val controller = remember { HintController() }

    controller.hint?.let { hint -&gt;
        CompositionLocalProvider(overlay) {
            HintOverlay(anchor = hint)
        }
    }

    return controller
}
</code></pre>

<p>为了消除我们的提示，让我们引入以下变化：</p>

<pre><code class="Kotlin">@Stable
class HintController internal constructor() {

    internal var hint by mutableStateOf&lt;HintAnchorState?&gt;(null)

    fun show(hint: HintAnchorState) {
        this.hint = hint
    }

    fun dismiss() {
        hint = null
    }
}
</code></pre>

<p>我们使用 Popup 作为覆盖层的容器，如果用户点击 Android 上的返回按钮(BACK)，Popup 就会被关闭。</p>

<pre><code class="Kotlin">@Composable
internal fun HintOverlay(
    anchor: HintAnchorState,
    onDismiss: () -&gt; Unit,
) {
    Popup(
        onDismissRequest = onDismiss,
        // 设置可聚焦以处理按压back事件
        properties = remember { PopupProperties(focusable = true) },
    ) {
        //...在这里画出我们的提示
    }
}

@Composable
internal fun HintsContainer(
    modifier: Modifier,
    anchor: HintAnchorState,
    onDismiss: () -&gt; Unit,
) {
    Layout(
        modifier = modifier
            .overlayBackground(anchor)
            .clickable(
                interactionSource = null,
                // 禁用ripple
                indication = null,
                onClick = onDismiss,
            )
    )
}
</code></pre>

<p>结果演示视频 <a href="https://youtu.be/eo49PKlhO5Y">https://youtu.be/eo49PKlhO5Y</a></p>

<p>现在，HintController 允许我们按时间显示一个提示，但如果我们想按顺序显示多个提示，则没有实际的队列。</p>

<p>可以扩展 HintController 并添加暂停修饰符以知道提示的显示时间（例如，在显示提示后立即执行某项操作）。</p>

<pre><code class="Kotlin">@Stable
class HintController internal constructor() {

    private var queue = mutableStateListOf&lt;HintAnchorState&gt;()

    internal val hint: HintAnchorState? get() = queue.firstOrNull()

    private val pendingRequests = mutableMapOf&lt;HintAnchorState, Continuation&lt;Unit&gt;&gt;()

    suspend fun show(hint: HintAnchorState) {
        suspendCoroutine { continuation -&gt;
            pendingRequests[hint] = continuation
            queue.add(hint)
        }
    }

    suspend fun show(vararg hint: HintAnchorState) {
        show(hint.toList())
    }

    suspend fun show(hints: List&lt;HintAnchorState&gt;) {
        suspendCoroutine { continuation -&gt;
            pendingRequests[hints.last()] = continuation
            queue.addAll(hints)
        }
    }

    internal fun onDismissed(hint: HintAnchorState) {
        pendingRequests[hint]?.let { continuation -&gt;
            continuation.resume(Unit)
            pendingRequests.remove(hint)
        }
        queue.remove(hint)
    }

    fun dismiss() {
        pendingRequests.values
            .forEach { continuation -&gt;
                continuation.resumeWithException(CancellationException("Hint was dismissed"))
            }
        pendingRequests.clear()
        queue.clear()
    }
}
</code></pre>

<p>现在为了在应用程序内部显示提示，我们需要一个 CoroutineScope ：</p>

<pre><code class="Kotlin">val coroutineScope = rememberCoroutineScope()
val hintController = rememberHintController()

// 现在我们可以从提示本身中忽略所有待处理的提示
val topAppBarHint = rememberHintContainer {
    OutlinedButton(
        onClick = {
            hintController.dismiss()
        }
    ) { Text("Hint for TopAppBar") }
}

// 显示 1 条提示
BottomNavigationItem(
    onClick = {
        coroutineScope.launch {
            hintController.show(bottomNavigationHintAnchor)
            scaffoldState.snackbarHostState.showSnackbar("One hint was shown")
        }
    },
)

// 连续显示多个提示
Button(
    onClick = {
        coroutineScope.launch {
            hintController.show(
                topAppBarActionHintAnchor,
                actionHintAnchor,
                bottomNavigationHintAnchor,
            )
            scaffoldState.snackbarHostState.showSnackbar("Many hints were shown")
        }
    },
)
</code></pre>

<blockquote><p><strong>注意：</strong> 如果我们通过调用 hintController.dismiss() 来关闭提示，则 hintController.show 之后的代码将不会被调用。</p></blockquote>

<pre><code class="Kotlin">coroutineScope.launch {
    hintController.show(topAppBarActionHintAnchor)
    // 如果通过调用 hintController.dismiss 关闭了之前的提示，则不会显示 Snackbar
    scaffoldState.snackbarHostState.showSnackbar("One hint was shown")
}
</code></pre>

<p>最终结果如这个视频演示 <a href="https://youtu.be/tyZUNJLEVxQ">https://youtu.be/tyZUNJLEVxQ</a>：我们可以显示单个提示，也可以显示提示列表。</p>

<p>由于该项目使用 Compose Multiplatform，我们可以针对不同的目标运行该应用程序：</p>

<ul>
<li>Android结果演示 <a href="https://youtu.be/BVBCipnbIUc">https://youtu.be/BVBCipnbIUc</a></li>
<li>iOS结果演示 <a href="https://youtu.be/Z1uasddgqwo">https://youtu.be/Z1uasddgqwo</a></li>
</ul>


<h2>总结</h2>

<p>Compose 和 Kotlin Multiplatform 是一个强大的组合，它允许我们使用 Kotlin 来实现 UI 和业务逻辑。CMP 库仅与Jetpack Compose Android 项目完全兼容。</p>

<p>可以在 GitHub 上查看我的repo：<a href="https://github.com/vitoksmile/ComposeHints">https://github.com/vitoksmile/ComposeHints</a>。</p>

<p>感谢你的阅读，期待在 GitHub 上获得你的Star :)。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实战：在Compose中绘制睡眠时间线]]></title>
    <link href="https://alexhilton.github.io/blog/2025/03/26/draw-sleep-timeline-graph-in-compose/"/>
    <updated>2025-03-26T21:41:40+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/03/26/draw-sleep-timeline-graph-in-compose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自<a href="https://proandroiddev.com/sleep-timeline-graph-in-compose-15c99f9a4af0">Draw sleep timeline graph in Compose</a>，原文由<a href="https://medium.com/@vitoksmile">Viktor Mykhailiv</a>发布于2025年1月31日。</p></blockquote>

<p><strong>译者按：</strong> 我们在前面的<a href="https://juejin.cn/column/7367555191338467337">降Compose十八掌</a>系列中讲解过在Compose自定义绘制的方法，可以先温习一下<a href="https://juejin.cn/post/7381826917086920742">上一篇文章</a>。这篇文章是提升自定义绘制技巧的一个非常好的实战例子。</p>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OUAsgvNoNx9VpSk9Eyqgzg.jpeg" title="auto auto" ></a></p>

<!-- more -->


<p>当内置组件不能完全满足我们的应用需求时，自定义绘图非常有用。本文提供了创建自定义睡眠时间线图表的指南，类似于你在<a href="https://play.google.com/store/apps/details?id=com.fitbit.FitbitMobile">Fitbit 应用</a>中找到的图表。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cA9uPgAG29Gu2AhajArq9w.jpeg" alt="Screenshots from Fitbit Android app" /></p>

<h2>在 Compose 中如何绘图？</h2>

<p>要开始在 Compose 中绘图，我们可以使用绘图Modifier或 Canvas可组合函数，这为我们提供了 DrawScope — 一种声明式、无状态的API，用于绘制形状和路径，而无需消费者维护底层状态。DrawScope实现还提供了尺寸信息，并且变幻是相对于本地平移完成的。</p>

<blockquote><p><strong>注意：</strong> Jetpack Compose（仅限 Android）和 Compose Multiplatform（桌面、Android、iOS、Web）具有类似的绘图 API。下面的屏幕截图是在桌面（macOS）上制作的，但所有平台上的结果都是相同的（查看最后一张屏幕截图）。</p></blockquote>

<pre><code class="Kotlin">Canvas(modifier = Modifier.fillMaxSize()) {
    rotate(degrees = 45F) {
        drawRect(
            color = Color.Gray,
            topLeft = Offset(x = size.width / 3F, y = size.height / 3F),
            size = size / 3F
        )
    }
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_qkChFEn25kC_cfgiRXgKg.png" alt="Compose中的自定义绘制" /></p>

<h2>啥是睡眠时间表？</h2>

<p>我们可以在 Health Connect 中读取或写入睡眠数据。睡眠数据显示为会话，可分为以下睡眠阶段：</p>

<ul>
<li>清醒：用户在睡眠周期内清醒。</li>
<li>浅睡眠：用户处于浅睡眠周期。</li>
<li>深睡眠：用户处于深睡眠周期。</li>
<li>REM：用户处于 REM 睡眠周期。</li>
</ul>


<p>这些值表示用户在一定时间范围内经历的睡眠类型。SleepSessionRecord 数据类型包含两部分：</p>

<ol>
<li>整个睡眠过程，涵盖整个睡眠时间。</li>
<li>睡眠过程中的各个阶段，例如浅睡眠或深睡眠。</li>
</ol>


<pre><code class="Kotlin">val record = remember {
    SleepSessionRecord(
        startTime = Instant.parse("2025-01-28T21:10:10Z"),
        endTime = Instant.parse("2025-01-29T07:32:13Z"),
        startZoneOffset = UtcOffset(hours = 2),
        endZoneOffset = UtcOffset(hours = 2),
        stages = listOf(
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-28T21:10:10Z"),
                endTime = Instant.parse("2025-01-28T23:15:13Z"),
                type = SleepSessionStageType.Light,
            ),
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-28T23:15:13Z"),
                endTime = Instant.parse("2025-01-29T01:56:32Z"),
                type = SleepSessionStageType.Deep,
            ),
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-29T01:56:13Z"),
                endTime = Instant.parse("2025-01-29T03:16:22Z"),
                type = SleepSessionStageType.Light,
            ),
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-29T03:16:22Z"),
                endTime = Instant.parse("2025-01-29T04:32:13Z"),
                type = SleepSessionStageType.REM,
            ),
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-29T04:32:13Z"),
                endTime = Instant.parse("2025-01-29T05:12:56Z"),
                type = SleepSessionStageType.Deep,
            ),
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-29T05:12:56Z"),
                endTime = Instant.parse("2025-01-29T07:32:13Z"),
                type = SleepSessionStageType.Light,
            ),
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-28T22:11:56Z"),
                endTime = Instant.parse("2025-01-28T22:17:13Z"),
                type = SleepSessionStageType.Awake,
            ),
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-28T22:39:56Z"),
                endTime = Instant.parse("2025-01-28T22:51:13Z"),
                type = SleepSessionStageType.Awake,
            ),
            SleepSessionRecord.Stage(
                startTime = Instant.parse("2025-01-29T04:47:56Z"),
                endTime = Instant.parse("2025-01-29T04:54:13Z"),
                type = SleepSessionStageType.Awake,
            ),
        ),
    )
}
</code></pre>

<h2>需要一点数学计算</h2>

<p>在睡眠期间，我们可以在不同时刻多次处于同一阶段。我们需要计算相对于睡眠的起点和终点。</p>

<p>要在 Compose 中绘制矩形，我们需要 topOffset 和 size。</p>

<p><img src="" alt="Math" /></p>

<pre><code class="Kotlin">private fun calculate(
    canvasSize: Size,
    recordStartTime: Instant,
    recordEndTime: Instant,
    stages: List&lt;SleepSessionRecord.Stage&gt;,
): List&lt;SleepStageDrawPoint&gt; {
    val totalDuration = (recordEndTime - recordStartTime).inWholeSeconds.toFloat()
        .coerceAtLeast(1f)

    return stages.map { stage -&gt;
        val stageOffset =
            (stage.startTime - recordStartTime).inWholeSeconds / totalDuration
        val stageDuration =
            (stage.endTime - stage.startTime).inWholeSeconds.toFloat() / totalDuration

        SleepStageDrawPoint(
            topLeft = Offset(x = canvasSize.width * stageOffset, y = 0f),
            size = canvasSize.copy(width = canvasSize.width * stageDuration),
        )
    }
}
</code></pre>

<h2>绘制</h2>

<p>让我们构建自定义 Canvas 来绘制睡眠过程的一个阶段，例如深度睡眠。</p>

<pre><code class="Kotlin">@Composable
fun SleepSessionCanvas(
    modifier: Modifier,
    record: SleepSessionRecord,
) {
    Spacer(
        modifier = modifier.drawWithCache {
            val points = calculate(
                canvasSize = size,
                recordStartTime = record.startTime,
                recordEndTime = record.endTime,
                stages = record.stages.filter { it.type == SleepSessionStageType.Deep },
            )

            onDrawWithContent {
                // 画背景
                drawRoundRect(
                    color = Color.LightGray,
                    topLeft = Offset(x = 0f, y = size.height / 4f),
                    size = size.copy(height = size.height / 2f),
                    cornerRadius = CornerRadius(size.height / 2f),
                )

                // 绘制阶段点
                points.forEach { point -&gt;
                    drawRect(
                        topLeft = point.topLeft,
                        size = point.size,
                        color = Color(0xFF673AB7),
                    )
                }
            }
        }
    )
}
</code></pre>

<p>如果我们使用之前定义的睡眠会话运行项目，我们将看到 3 个矩形：1 个灰色矩形表示背景，2 个紫色矩形表示深度睡眠阶段。</p>

<pre><code class="Kotlin">SleepSessionCanvas(
    modifier = Modifier
        .fillMaxWidth()
        .height(320.dp)
        .padding(16.dp),
    record = record,
)
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ANITvvaUEuuwwcACzY21qA.png" alt="深度睡眠阶段" /></p>

<p>为了绘制睡眠过程的所有阶段（清醒、快速眼动、浅睡眠和深睡眠），我们需要进行一些调整，将每个阶段类型垂直绘制为列组件，办法是逐行绘制并对下一行应用一些偏移量（offset）。</p>

<pre><code class="Kotlin">@Composable
fun SleepSessionCanvas(
    modifier: Modifier,
    record: SleepSessionRecord,
    stageHeight: Dp = 48.dp,
    stagesSpacing: Dp = 16.dp,
) {
    val colors = remember {
        mapOf(
            SleepSessionStageType.Awake to Color(0xFFFF9800),
            SleepSessionStageType.Light to Color(0xFF2196F3),
            SleepSessionStageType.Deep to Color(0xFF673AB7),
            SleepSessionStageType.REM to Color(0xFF795548),
        )
    }

    val stageHeightPx = with(LocalDensity.current) { stageHeight.toPx() }
    val stagesSpacingPx = with(LocalDensity.current) { stagesSpacing.toPx() }

    Spacer(
        modifier = modifier
            .requiredHeight(stageHeight * colors.size + stagesSpacing * (colors.size - 1))
            .drawWithCache {
                val stages = listOf(
                    SleepSessionStageType.Awake,
                    SleepSessionStageType.REM,
                    SleepSessionStageType.Light,
                    SleepSessionStageType.Deep,
                ).map { type -&gt;
                    type to calculate(
                        canvasSize = size.copy(height = stageHeightPx),
                        recordStartTime = record.startTime,
                        recordEndTime = record.endTime,
                        stages = record.stages.filter { it.type == type },
                    )
                }

                onDrawWithContent {
                    var offset = 0f
                    stages.forEach { (type, points) -&gt;
                        translate(top = offset) {
                            // 画背景
                            drawRoundRect(
                                color = Color.LightGray,
                                topLeft = Offset(x = 0f, y = stageHeightPx / 4),
                                size = size.copy(height = stageHeightPx / 2),
                                cornerRadius = CornerRadius(stageHeightPx / 2),
                            )

                            // 绘制阶段点
                            points.forEach { point -&gt;
                                drawRect(
                                    topLeft = point.topLeft,
                                    size = point.size,
                                    color = colors.getValue(type),
                                )
                            }
                        }
                        offset += stageHeightPx + stagesSpacingPx
                    }
                }
            }
    )
}
</code></pre>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iXIS4tbsvx5AhTtRqlWi7A.png" alt="最终的图形" /></p>

<h3>添加文本</h3>

<p>要在 Compose 中绘制文本，我们通常可以使用 Text 可组合项。但是，在我们的示例中，我们处于 DrawScope 中，我们可以使用 DrawScope.drawText()方法。</p>

<p>绘制文本与其他绘制命令略有不同。通常，我们为绘制命令提供绘制形状/图像的大小（宽度和高度）。对于文本，有几个参数可以控制渲染文本的大小，例如字体大小、字体、连字符和字母间距。我们需要使用 TextMeasurer 来获取文本的测量大小，具体取决于上述因素。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QB1QvINWUWMlpRoPSzrcUQ.png" alt="Desktop效果" /></p>

<p><img src="https://miro.medium.com/v2/resize:fit:2000/format:webp/1*U_LBREiTciw2F3ghYiHqCw.jpeg" alt="Android和iOS效果" /></p>

<p>请到我的Github repo中查找完整示例代码：<a href="https://github.com/vitoksmile/Sleep-timeline-graph">https://github.com/vitoksmile/Sleep-timeline-graph</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[高效地在Jetpack Compose中设计UI组件]]></title>
    <link href="https://alexhilton.github.io/blog/2025/03/16/effective-compose-components/"/>
    <updated>2025-03-16T20:37:18+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/03/16/effective-compose-components</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自<a href="https://proandroiddev.com/designing-effective-ui-components-in-jetpack-compose-cb8d18f7f888">Designing Effective UI Components in Jetpack Compose</a>，原文作者是Jaewoong Eum，原文发布于2025年2月7日。</p></blockquote>

<p><strong>译者按：</strong> 本文适合有一定Jetpack Compose经验的开发者阅读，假定读者熟悉Jetpack Compose的基本使用方法，以及熟悉常见 的Slot设计模式。否则理解上可能会有一些困难。</p>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*PwVzAjyhIPGIgrT0" title="auto auto" ></a></p>

<!-- more -->


<p>自<a href="https://android-developers.googleblog.com/2021/07/jetpack-compose-announcement.html"> Google 宣布 Jetpack Compose 1.0 稳定版</a>以来，许多公司都已采用 Jetpack Compose 来利用其众多优势。随着 Compose 在 Android 生态系统中的广泛采用，库和 SDK 也开始集成对 Compose 的支持。</p>

<p>传统上，在基于 XML 的项目中，UI 组件以自定义视图的形式提供，并通过属性（attributes）提供可自定义的选项。虽然这种方法可以轻松地将组件集成到 XML 布局中，但它带来了一些挑战，例如在多个组件之间应用主题样式时不一致，以及由于底层 View 类公开的方法而导致的 API 滥用。</p>

<p>与传统的自定义视图相比，Jetpack Compose 提供了一种完全不同的组件设计策略。其声明式结构允许更直观、更灵活的 API 设计。这种转变不仅有利于库和 SDK 开发人员，也有利于构建共享 UI 组件的大型团队，使他们能够实施更好的做法、减少误用并增强整体开发人员体验。</p>

<p>在本文中，你将发现在 Jetpack Compose 中设计 UI 组件的有效策略，借鉴<a href="https://getstream.io/video/sdk/android/"> Stream Video SDK </a>的最佳实践。</p>

<h2>Modifier的最佳实践</h2>

<p><a href="https://developer.android.com/develop/ui/compose/modifiers">Modifier </a>是 Jetpack Compose 中一个功能强大的 API，可让你以链式和可组合的方式装饰和增强 UI 元素。但是，应谨慎使用它，因为它的属性可以传播到其他可组合函数，如果管理不当，可能会导致意想不到的效果。</p>

<p>Modifier函数的顺序尤其重要，因为每个函数都会修改前一个函数返回的Modifier或从可组合项外部传递的Modifier。此顺序直接影响最终输出。在本节中，我们将探讨三个关键原则和最佳实践，它们可以指导你在 Jetpack Compose 中设计有效且可预测的 UI 组件 API。</p>

<h3>1. 将Modifier应用到组件最顶层的布局</h3>

<p>Jetpack Compose 中的Modifier会通过布局层次结构向下传递，但理想情况下，它们应仅应用于可组合函数中最顶层的布局节点。在层次结构中的任意级别应用Modifier可能会导致意外行为，并增加用户误用的可能性，从而使组件更难以预测且更难以有效使用。</p>

<p>例如，假设你想要创建一个代表圆形按钮的组件，如下例所示：</p>

<pre><code class="Kotlin">@Composable
fun RoundedButton(
  modifier: Modifier = Modifier,
  onClick: () -&gt; Unit
) {
  Button(
    modifier = modifier.clip(RoundedCornerShape(32.dp)),
    onClick = onClick
  ) {
    Text(
      modifier = Modifier.padding(10.dp),
      text = "Rounded"
    )
  }
}
</code></pre>

<p>但是，你不应将 Modifier 应用于 Text ，而应应用于 Button ，后者是布局层次结构中最顶层的可组合函数，如下所示：</p>

<pre><code class="Kotlin">@Composable
fun RoundedButton(
  modifier: Modifier = Modifier,
  onClick: () -&gt; Unit
) {
  Button(
    modifier = Modifier.clip(RoundedCornerShape(32.dp)),
    onClick = onClick
  ) {
    Text(
      modifier = modifier.padding(10.dp), // 别这么干
      text = "Rounded"
    )
  }
}
</code></pre>

<p>自定义可组合函数 RoundedButton 的主要用途是表示 Button ，而不是 Text 。因此，你应避免转移所创建主要组件的焦点或用途。</p>

<p>此外，如果布局层次结构变得复杂，并且你在可组合函数的中间级别应用Modifier，则用户可能很难预测提供的Modifier参数最终会影响哪个组件。这种不明确性可能会导致混淆和误用。</p>

<p>如果你想让用户灵活地修改按钮的内部内容，你可以使用插槽来实现，如下例所示：</p>

<pre><code class="Kotlin">@Composable
fun RoundedButton(
  modifier: Modifier = Modifier,
  onClick: () -&gt; Unit,
  content: @Composable RowScope.() -&gt; Unit
) {
  Button(
    modifier = modifier.clip(RoundedCornerShape(32.dp)),
    onClick = onClick
  ) {
    content()
  }
}
</code></pre>

<h3>2. 对Modifier使用单个参数</h3>

<p>你可能想知道是否可以接受多个 Modifier 参数以应用于布局层次结构中的特定组件，同时限制组件的结构，如下例所示：</p>

<pre><code class="Kotlin">@Composable
fun RoundedButton(
  modifier: Modifier = Modifier,
  textModifier: Modifier = Modifier,
  onClick: () -&gt; Unit,
) {
  Button(
    modifier = modifier.clip(RoundedCornerShape(32.dp)),
    onClick = onClick
  ) {
    Text(
      modifier = textModifier.padding(10.dp),
      text = "Rounded"
    )
  }
}
</code></pre>

<p>但是，Modifier 本质上被设计为一个单一的、可链接的参数，使用户能够定义 Composable 函数的外部行为和外观。在 Composable 中引入多个 Modifier 参数会增加不必要的复杂性，增加误用的风险，并且偏离了 Jetpack Compose 保持 API 直观和可预测的原则。</p>

<p>最好使用基于插槽的方法，让用户能够灵活地自定义内部内容。例如，你可以定义一个插槽（slot），让用户提供自定义内容，同时仍保留单个Modifier以进行外部自定义，而不是添加多个Modifier参数。</p>

<pre><code class="Kotlin">@Composable
fun RoundedButton(
  modifier: Modifier = Modifier,
  onClick: () -&gt; Unit,
  content: @Composable RowScope.() -&gt; Unit
) {
  Button(
    modifier = modifier.clip(RoundedCornerShape(32.dp)),
    onClick = onClick
  ) {
    content()
  }
}
</code></pre>

<h3>3. 避免跨组件重复使用Modifier</h3>

<p>设计组件时的另一个重要考虑因素是避免重复使用提供的 Modifier 实例。一些开发人员可能会担心为每个组件创建新的 Modifier 实例可能会导致内存使用量增加或对性能产生负面影响，尤其是在具有大量Modifier的复杂布局层次结构中。</p>

<p>然而，由于 Jetpack Compose 中Modifier实现的优化性质，这种担忧通常是没有根据的。Modifier旨在应用于可组合函数中的单个布局节点，以确保行为清晰且可预测。如果在布局层次结构中不同级别的多个可组合项中使用相同的Modifier，则可能导致意外的副作用和不可预测的行为，从而损害组件的一致性和可用性。</p>

<p>例如，考虑这样一种情况，其中相同的 Modifier 参数在整个布局层次结构中重复使用，如下例所示：</p>

<pre><code class="Kotlin">@Composable
fun MyButtons(
  modifier: Modifier = Modifier,
  onClick: () -&gt; Unit,
) {
  Column(modifier = modifier) {
    Button(
      modifier = modifier,
      onClick = onClick
    ) {
      Text(
        modifier = modifier.padding(10.dp),
        text = "Rounded"
      )
    }

    Button(
      modifier = modifier,
      onClick = onClick
    ) {
      Text(
        modifier = modifier.padding(10.dp),
        text = "Not Rounded"
      )
    }
  }
}
</code></pre>

<p>乍一看，代码似乎运行正常。但是，当你在调用点修改Modifier时，你会注意到意外的行为，可能会以意想不到的方式改变整个布局。</p>

<pre><code class="Kotlin">MyButtons(
  modifier = Modifier
    .clip(RoundedCornerShape(32.dp))
    .background(Color.Blue)
) {}
</code></pre>

<p>为了确保行为正确并避免意外问题，你应避免在多个组件中重复使用Modifier。在本节中，你了解了在设计 Compose 组件时管理Modifier的最佳实践。接下来，让我们通过实现主题来深入了解如何提供一致的 UI 样式。</p>

<h2>主题确保 UI 一致性</h2>

<p>现在，假设你需要提供多种 Compose 组件，这些组件应共享一致的样式。如果这些组件是独立提供的，那么维护这些组件之间一致样式的责任就完全落在用户身上。这可能非常具有挑战性，因为每个组件可能会公开不同的 API 来自定义其样式，从而使同步变得繁琐且容易出错。</p>

<p>在这种情况下，你可以从 Compose Material 库提供的<a href="https://developer.android.com/develop/ui/compose/designsystems/material3#material-theming"> MaterialTheme API </a>中汲取灵感。关键在于确保组件样式一致，同时允许用户无缝自定义并在各个组件之间保持一致的样式。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*AyJL0G8NsCGWX9_Q" alt="Theming Consistency" /></p>

<p>Compose 的<a href="https://getstream.io/video/sdk/"> Stream Video SDK </a>通过提供名为<a href="https://getstream.io/video/docs/android/ui-components/video-theme/"> VideoTheme </a>的专用主题 API 展示了最佳实践。此 VideoTheme API 可确保 SDK 提供的所有 Compose 组件的样式一致，包括颜色、尺寸、排版、形状、涟漪效果等。</p>

<pre><code class="Kotlin">setContent {
    VideoTheme(
        colors = StreamColors.defaultColors().copy(appBackground = Color.Black),
        dimens = StreamDimens.defaultDimens().copy(callAvatarSize = 72.dp),
        shapes = StreamShapes.defaultShapes().copy(
            avatar = RoundedCornerShape(8.dp),
            callButton = RoundedCornerShape(16.dp),
            callControls = RectangleShape,
            callControlsButton = RoundedCornerShape(8.dp)
        )
    ) {
        CallContent(
            modifier = Modifier.fillMaxSize(),
            call = call,
            onBackPressed = { finish() },
        )
    }
}
</code></pre>

<p>通过将 Stream SDK 提供的组件与 VideoTheme 包装在一起（如上例所示），自定义样式将自动一致地应用于所有组件。这种方法使用户能够轻松保持其 UI 的一致性，同时调整主题以满足其应用程序的设计要求。</p>

<h3>实现自定义主题</h3>

<p>让我们深入研究如何实现自定义主题。第一步是定义设计规范，这些规范将在你的组件之间共享或为用户提供自定义功能。考虑包括颜色、形状和尺寸等方面，因为这些通常是确保设计系统一致性的最重要因素。</p>

<p>例如，在 Stream SDK 中，组件所需的所有颜色集均在<a href="https://github.com/GetStream/stream-video-android/blob/c12db8cb6367e10682be3ab323d50dfcc59032f3/stream-video-android-ui-compose/src/main/kotlin/io/getstream/video/android/compose/theme/StreamColors.kt#L24"> StreamColors </a>类中预定义，为用户提供了一种无缝的方式来保持其整个 UI 的一致性。以下是 Stream SDK 如何通过结构良好的颜色集确保一致性的示例：</p>

<pre><code class="Kotlin">public data class StreamColors(
    val brandPrimary: Color,
    val brandPrimaryLt: Color,
    val brandPrimaryDk: Color,
    val brandSecondary: Color,
    val brandSecondaryTransparent: Color,
    val brandCyan: Color,
    val brandGreen: Color,
    val brandYellow: Color,
    ..
  )
</code></pre>

<p>接下来，你应该创建一个<a href="https://developer.android.com/develop/ui/compose/compositionlocal"> CompositionLocal </a>来保存设计规范。这将允许你的组件和用户通过使用 StreamTheme.colors 调用在自定义主题的上下文中无缝访问这些规范。</p>

<p><strong>译注：</strong> CompositionLocal是Compose中用于在上下文函数调用中，隐式的传递常量性质参数的方法，可以参考这篇文章<a href="https://juejin.cn/post/7434543407636267071">用Compose中的CompositionLocal来暗渡陈仓</a>，以了解CompositionLocal的详细用法。</p>

<pre><code class="Kotlin">/**
 * Local providers for various properties we connect to our components, for styling.
 */
private val LocalColors = compositionLocalOf&lt;StreamColors&gt; {
    error("No colors provided! Make sure to wrap all usages of Stream components in a VideoTheme.")
}

public interface StreamTheme {
    /**
     * Retrieves the current [StreamColors] at the call site's position in the hierarchy.
     */
    public val colors: StreamColors
        @Composable @ReadOnlyComposable
        get() = LocalColors.current
}
</code></pre>

<p>然后，你需要利用<a href="https://developer.android.com/develop/ui/compose/compositionlocal"> CompositionLocal </a>将这些设计规范封装在自定义主题中。这种方法允许你在整个可组合层次结构中高效地提供和传播你的设计规范。</p>

<pre><code class="Kotlin">public fun VideoTheme(
    isInDarkMode: Boolean = isSystemInDarkTheme(),
    colors: StreamColors = StreamColors.defaultColors(),
    content: @Composable () -&gt; Unit,
) {
    CompositionLocalProvider(
        LocalColors provides colors,
    ) {
        content()
    }
}
</code></pre>

<p>现在，你的所有组件都应假设它们都包含在自定义主题（例如本例中的 VideoTheme）中，并使用提供的设计规范来确保整个组件集的样式一致。这种方法不仅使你的组件 API 能够采用统一的样式，还允许用户利用这些设计规范进行自定义，从而同时提高灵活性和一致性。</p>

<pre><code class="Kotlin">@Composable
fun VideoRendererCallContent(
    call: Call,
    video: ParticipantState.Video,
    onRendered: (View) -&gt; Unit = {},
) {
    VideoRenderer(
        modifier = Modifier
            .fillMaxSize()
            .background(VideoTheme.colors.baseSheetTertiary), // use pre-defined color styles
        call = call,
        video = video,
        onRendered = onRendered,
    )
}

@Composable
fun MyScreen() { 

  VideoRendererCallContent(..)

  // some complicated components
}

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

         setContent {
            VideoTheme {
               MyScreen()
            }
         }
}
</code></pre>

<p>这种方法不仅对于实现 API（库或 SDK）有效，对于构建应用程序也同样有效，因为它能够使用结构良好、预定义的设计规范轻松维护设计一致性。对于实际示例和实际用例，你可以在<a href="https://github.com/GetStream/stream-video-android/blob/c12db8cb6367e10682be3ab323d50dfcc59032f3/stream-video-android-ui-compose/src/main/kotlin/io/getstream/video/android/compose/theme/VideoTheme.kt"> GitHub </a>上探索实际最佳实践。</p>

<h2>可定制性</h2>

<p>在实现 UI 组件时，尤其是对于库或 SDK，为 UI 和 UX 行为提供强大的自定义和灵活性至关重要。这可确保用户可以轻松重复使用组件并根据其特定要求进行调整。你可以采用各种策略在 Jetpack Compose 中有效地实现这种级别的可定制性。</p>

<h3>1. 利用样式类</h3>

<p>如果你希望为特定组件提供更具针对性的定制，请考虑提供专用的样式类。此类可以定义并允许用户轻松修改组件的 UI 和 UX 行为以满足他们的特定需求。</p>

<p>一个很好的例子是 TextStyle ，它是 Compose UI 库提供的默认类：</p>

<pre><code class="Kotlin">@Immutable
class TextStyle internal constructor(
  ..
) {
    constructor(
        color: Color = Color.Unspecified,
        fontSize: TextUnit = TextUnit.Unspecified,
        fontWeight: FontWeight? = null,
        fontStyle: FontStyle? = null,
        fontSynthesis: FontSynthesis? = null,
        fontFamily: FontFamily? = null,
        ..
     )
}
</code></pre>

<p>如上面的代码所示，TextStyle 类封装了 Text 可组合项的所有样式属性。只需将 TextStyle 实例传递给 Text 可组合项，你就可以轻松自定义其设计，如下例所示：</p>

<pre><code class="Kotlin">Text(
    modifier = Modifier
        .fillMaxWidth()
        .padding(top = 16.dp),
    text = "Stats",
    style = TextStyle(
        fontSize = 16.sp,
        lineHeight = 24.sp,
        fontWeight = FontWeight(600),
        color = Color.White,
        textAlign = TextAlign.Center,
    ),
)
</code></pre>

<p>使用样式类的优点是，它们允许组件开发人员将所有设计规范整合到一个集中的类中。这种方法可以防止设计元素分散在多个布局中，从而使代码库更简洁、更易于管理。</p>

<p>对于用户来说，样式类提供了一种直接且直观的修改设计的方法。此外，用户可以在多个布局中重复使用相同的样式实例，从而更方便地在不同布局中应用一致的自定义。</p>

<p>一个潜在的缺点是，由于<a href="https://getstream.io/blog/jetpack-compose-stability/#jetpack-compose-phases">重组机制（Recomposition）</a>，每当输入发生变化时，Compose 运行时都会比较样式类的所有属性，以确定是否需要重组。与直接在可组合函数中定义单个参数相比，这使其成本略高。然而，从 API 设计的角度来看，改进的用户体验和简化的 API 管理通常超过了这一成本，因此在许多情况下，这是一种值得的权衡。</p>

<h3>2. 借助插槽（Slots）的灵活性</h3>

<p>增强自定义灵活性的另一种有效策略是提供接受可组合函数的插槽，让用户根据自己的需求定义特定的实现。通过提供默认实现，你可以确保用户无需付出额外努力即可利用所提供的功能，同时仍然可以根据需要进行自定义。</p>

<p>例如，Stream Video SDK 提供的 CallContent 组件是一个高级 API，它集成了多个子组件，包括顶部应用栏、视频渲染器、布局结构、网格参与者等。虽然 CallContent API 包含默认实现以方便使用，但它还通过允许通过插槽参数进行自定义来确保灵活性，如以下代码所示：</p>

<pre><code class="Kotlin">fun CallContent(
    call: Call,
    modifier: Modifier = Modifier,
    style: VideoRendererStyle = RegularVideoRendererStyle(),
    appBarContent: @Composable (call: Call) -&gt; Unit = {
        CallAppBar(..)
    },
    videoRenderer: @Composable (..) -&gt; Unit = {
        ParticipantVideo(..)
    },
    videoContent: @Composable RowScope.(call: Call) -&gt; Unit = {
        ParticipantsLayout(..)
    },
) {
  ..
}
</code></pre>

<p>这种方法允许用户实现自己的顶部应用栏、视频渲染器、布局结构、网格参与者等自定义版本。此外，另一种有效的策略是将相似类型的组件分组，并通过插槽使它们可自定义，这通常称为复合组件模式。</p>

<p>复合组件模式涉及创建一个父组件来管理子组件集合，通过为每个子组件公开插槽来提供自定义。此模式允许用户替换或自定义单个子组件，同时保持整体结构和功能的一致性。</p>

<p>想象一下视频通话屏幕上的控制面板包含多个操作按钮，如下图所示：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:886/format:webp/0*mNh-EWJlyCobHHed" alt="Control Panel" /></p>

<p>有些用户可能喜欢不同的操作按钮顺序，例如将麦克风按钮放在第一位，而其他用户可能希望根据其特定用例添加、删除或自定义按钮。在这种情况下，复合组件模式被证明在满足这些不同的要求方面非常有效，例如下面的代码：</p>

<pre><code class="Kotlin">@Composable
public fun ControlActions(
    call: Call,
    modifier: Modifier = Modifier,
    actions: List&lt;(@Composable () -&gt; Unit)&gt;
) {
    Box(
        modifier = modifier,
    ) {
        LazyRow(
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(
                VideoTheme.dimens.spacingM,
                Alignment.CenterHorizontally,
            ),
        ) {
            items(actions) { action -&gt;
                action.invoke()
            }
        }
    }
}
</code></pre>

<p>上面的代码演示了一个接受 Composable 函数列表的单个插槽，然后使用 Row 或 LazyRow 进行渲染。这种方法允许你提供高度灵活的组件 API，同时保持对组件布局预期结构的控制。</p>

<p>之后，你还可以提供默认实现，如下所示，以增加便利性。</p>

<pre><code class="Kotlin">@Composable
public fun buildDefaultCallControlActions(
    onCallAction: (CallAction) -&gt; Unit,
): List&lt;@Composable () -&gt; Unit&gt; {

    return listOf(
        {
            ToggleCameraAction(
                onCallAction = onCallAction,
            )
        },
        {
            ToggleMicrophoneAction(
                onCallAction = onCallAction,
            )
        },
        {
            FlipCameraAction(
                onCallAction = onCallAction,
            )
        },
    )
}

@Composable
public fun ControlActions(
    call: Call,
    modifier: Modifier = Modifier,
    onCallAction: (CallAction) -&gt; Unit = { DefaultOnCallActionHandler.onCallAction(call, it) },
    actions: List&lt;(@Composable () -&gt; Unit)&gt; = buildDefaultCallControlActions(onCallAction)
) {
}
</code></pre>

<p>如需了解更多<a href="https://getstream.io/video/docs/android/ui-components/call/call-controls/"> ControlActions </a>的真实示例，你可以探索<a href="https://github.com/GetStream/stream-video-android/blob/c12db8cb6367e10682be3ab323d50dfcc59032f3/stream-video-android-ui-compose/src/main/kotlin/io/getstream/video/android/compose/ui/components/call/controls/ControlActions.kt#L48"> GitHub </a>上的实现。</p>

<h3>3. 使用主题进行定制</h3>

<p>设计 Compose 组件时的另一个常见挑战是，随着组件层次结构的变大，提供清晰、直接的可定制性变得更加困难。例如，假设你想为组件多个部分使用的视频渲染器提供可定制性，但 UI 层次结构嵌套很深且很复杂，如下例所示：</p>

<pre><code class="Kotlin">@Composable
fun CallContent() {
    ParticipantsLayout {
      ParticipantsRegularGrid {
        OrientationVideoRenderer {
          LazyVerticalGrid {
            VideoRenderer() // &lt;-- users want to customize this renderer style
          }
        }
      }

      FloatingVideoRenderer {
        VideoRenderer() // &lt;-- users want to customize this renderer style
      }
    }
}
</code></pre>

<p>在这种情况下，将插槽或样式参数从最顶层的组件一直传递到 VideoRenderer 组件并不理想。随着你在不同组件之间添加更多可定制性，最顶层的组件 (CallContent) 可能会因大量插槽和样式参数而变得过载。这不仅使你的 API 更难维护，而且还增加了用户混淆或误用的可能性，因为不清楚哪个参数用于什么用途。</p>

<p>为了解决这个问题，你可以利用自定义主题和<a href="https://developer.android.com/develop/ui/compose/compositionlocal"> CompositionLocal</a>来实现可定制性，同时保持 API 更清晰、更易于管理，如下例所示：</p>

<pre><code class="Kotlin">@Immutable
public data class VideoRendererStyle(
    val backgroundColor: Color = Color.Black,
    ..
)

private val LocalVideoRendererStyle = compositionLocalOf&lt;VideoRendererStyle&gt; {
    error("No VideoRendererStyle provided! Make sure to wrap all usages of Stream components in a VideoTheme.")
}

@Composable
public fun VideoTheme(
    videoRendererStyle: VideoRendererStyle = VideoRendererStyle(),
    content: @Composable () -&gt; Unit,
) {
    CompositionLocalProvider(
        LocalVideoRendererStyle provides videoRendererStyle,
    ) {
        content()
    }
}
</code></pre>

<p>现在，你可以通过在不同的组件中使用提供的样式来确保组件样式的一致性，而无需将它们作为参数反复传递。此外，用户可以通过创建自己的自定义主题轻松自定义样式，如下例所示：</p>

<pre><code class="Kotlin">setContent {
    VideoTheme(
        videoRendererStyle = VideoRendererStyle(backgroundColor = Color.Blue)
    ) {
      ..
    } 
}
</code></pre>

<p>如果你希望更广泛地应用此策略并高效地管理更多样式，则可以将它们合并为一个类，例如 StreamStyles ，并提供统一的样式类，而不是 CompositionLocal 中的多个单独样式。有些同学可能会担心 CompositionLocal 带来的性能影响，因为它会在值更改时触发布局层次结构的重组，但主题通常不会在应用程序中频繁更新。它们通常是静态的，以确保设计一致性，因此在这种情况下使用 CompositionLocal 是一种合适且有效的选择。</p>

<h2>预览（Preview）的兼容性</h2>

<p>提供预览非常重要，尤其是在构建组件 API 时，因为它们允许开发人员直接在 Android Studio 中可视化和验证他们的 UI 设计。
一些同学依靠<a href="https://developer.android.com/develop/ui/compose/tooling#live-edit-literals"> Live Literals </a>来动态展示预览中的变化，而其他同学则使用屏幕截图测试来确保其组件的视觉一致性。因此，在实现 Compose 组件时，必须确保它们与 Android Studio 中的预览功能完全兼容，如下面的屏幕截图所示：</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*R74xLmTnWswi86ww" alt="Preview" /></p>

<p>有时，你的组件可能会产生副作用，例如在发出网络请求或处理动态状态后渲染图像，这可能会导致预览出现故障。在这种情况下，你可以利用<a href="https://developer.android.com/develop/ui/compose/tooling/previews#localinspectionmode"> LocalInspectionMode</a>。</p>

<p>LocalInspectionMode 允许你确定可组合项是否在预览模式下呈现，从而使你可以呈现专门用于预览目的的专用布局。这种方法可确保预览保持功能，即使你的组件依赖于复杂的逻辑或外部资源。你可以从<a href="https://github.com/skydoves/landscapist"> Landscapist </a>中找到一个用于网络图像加载的 Jetpack Compose 库的真实示例，它演示了处理预览的最佳实践。</p>

<p>下面的可组合函数会检查它是否处于预览模式。如果是，它会渲染静态图像，而不是执行诸如获取网络数据之类的副作用。这种方法允许用户为 GlideImage 可组合函数构建自己的预览，而不会在预览渲染期间遇到运行时错误。</p>

<pre><code class="Kotlin">@Composable
public fun GlideImage(
  imageModel: () -&gt; Any?,
  modifier: Modifier = Modifier,
  previewPlaceholder: Painter? = null,
  ..
) {
  if (LocalInspectionMode.current &amp;&amp; previewPlaceholder != null) {
      Image(
        modifier = modifier,
        painter = previewPlaceholder,
        ..
      )
      return
  }

  // complex logic about requesting network data and render it
  ..
)
</code></pre>

<p>为了增强项目中的整体预览策略，请考虑探索<a href="https://getstream.io/blog/effective-compose-preview/">设计有效的 UI 以增强 Compose 预览</a>。此资源提供了有价值的见解和技术，可有效优化你的 Compose 预览。</p>

<h2>结论</h2>

<p>在本文中，我们探讨了在 Jetpack Compose 中制作有效 UI 组件的策略，重点关注最佳实践，例如高效处理Modifier、确保设计与主题一致、实施可定制性策略以及增强预览兼容性。设计直观且强大的 API 始终是一项挑战，但努力终将获得回报，因为用户体验和开发者满意度显著提升。</p>

<p>如果你对本文有任何疑问或反馈，可以在 Twitter<a href="https://twitter.com/github_skydoves"> @github_skydoves </a>或<a href="https://github.com/skydoves"> GitHub </a>上找到作者。如果你想随时了解 Stream 的最新动态，请在 Twitter 上关注我们<a href="https://twitter.com/getstream_io"> @getstream_io</a>，获取更多精彩的技术内容。</p>

<p>老规矩，祝你编码愉快！ &ndash; <a href="https://github.com/skydoves">Jaewoong</a></p>

<p>最初<a href="https://getstream.io/blog/designing-effective-compose/">发布于 GetStream.io</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[不使用Jetpack Compose的10个理由]]></title>
    <link href="https://alexhilton.github.io/blog/2025/03/06/reasons-not-to-use-jetpack-compose/"/>
    <updated>2025-03-06T22:25:19+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/03/06/reasons-not-to-use-jetpack-compose</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自<a href="https://sonique6784.medium.com/10-reasons-to-not-use-jetpack-compose-719de5d37c9e">10 reasons to NOT use Jetpack Compose</a>，原文发布于2024年9月24日。</p></blockquote>

<p><strong>译者按：</strong> 软件开发行业从不缺少优秀的工具，当然也没有银弹。身为开发者要学会选择合适的工具，避免出现手里拿着锤子，看什么都是钉子。那么就需要搞清楚两个事情，一个是面临的到底是什么样的问题，以及每种工具它的合适场景是什么。没有对与错，只有合适不合适。这篇文章就是帮助大家更清晰地了解到Jetpack Compose适用的场景，帮助Android开发者做出最合适的选择。</p>

<h2>简介</h2>

<p>Jetpack Compose 是一款出色的 UI 工具包，受到 Android 社​​区的热烈欢迎。它提供了一种为你的 Android 应用构建令人愉悦的 UI 的现代方式。</p>

<p><a href=""><img src="https://www.sixt.tech/assets/jetpack-compose/jetpack-compose.png" title="auto auto" ></a></p>

<!-- more -->


<p>我确实喜欢 Jetpack Compose，但与任何技术一样，它也有一些注意事项。在本文中，我们将了解在什么情况下使用 View 系统更为明智以及原因。</p>

<h2>1. 尽可能减少依赖</h2>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BSFMClR4UbDbGhkXdfHhqg.png" alt="Compose Dependencies" /></p>

<p>如果你需要尽可能少的依赖项，这可能是出于兼容性或安全性目的，那么使用 View 系统可能会更好。View 系统不需要额外的导入。它位于 Android 系统内部，与 Jetpack Compose 不同，后者需要大量依赖项，这会增加包占用空间和运行时的内存使用量，并为额外的风险打开大门。</p>

<h2>2. 性能</h2>

<p>View 系统自 Android 的第一个版本以来就一直存在，它非常成熟，15 年来已经进行了大量优化，对于复杂的布局，其性能通常比 Jetpack Compose 更好。Jetpack Compose 在每次迭代中都在改进，有时已经比 View 更好，请关注这个领域，View 可能很快就会失去性能之王的桂冠！</p>

<h2>3. Espresso测试</h2>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xEebB2vruLxuGrxeoePu0g.png" alt="Espresso测试" /></p>

<p>如果你有大量基于 View 的 Espresso 测试，或者想要使用 Android Studio 中的测试记录功能，最好避免使用 Jetpack Compose，或者只考虑将 Jetpack Compose 用于新的页面。无法轻松将于View 的 Espresso 测试迁移到 Compose。此外<a href="https://developer.android.com/studio/test/other-testing-tools/espresso-test-recorder">记录 Espresso 测试功能</a>不适用于 Compose。但是，可以<a href="https://developer.android.com/develop/ui/compose/testing">手动编写 Espresso </a>来测试 Compose。</p>

<h2>4. 稳定性和成熟度</h2>

<p>我们在「性能」部分简要提到了这一点。Jetpack Compose 已有 3 年历史，每次发布都会有所改进，但有时可能会出现错误。此外，许多 Compose 功能仍处于实验阶段，需要注解才能使用。使用实验性功能可能会给你的业务带来潜在的问题。</p>

<pre><code class="Kotlin">// 有些特性，如Modifier，Layout和Material Design是实验性质的，需要显式的用OptInt。
@OptIn(ExperimentalMaterialApi::class)
@OptIn(@ExperimentalFoundationApi::class)
@OptIn(ExperimentalComposeUiApi::class)
@OptIn(ExperimentalLayoutApi::class)
</code></pre>

<p>如果你需要非常高的成熟度和稳定性，你可能希望坚持使用View 系统。</p>

<h2>5. 功能缺失</h2>

<p>View 系统是 Android 历史的一部分。许多 Android 功能首先在 View 上可用，然后移植到 Compose，通常 Compose 可能只提供一个包装器（例如 Google Maps）。因此，你可能希望保留 View 系统，直到这些功能在 Compose 上可用。请注意，你可以使用 AndroidView 访问那些仅限 View 的功能，Compose 最终会实现这一点。</p>

<h2>6. 广泛应用于现有应用中</h2>

<p>在你的职业生涯中，你很可能需要处理 View。许多大公司即使采用了 Jetpack Compose，仍然使用 View。将 View 页面迁移到 Compose 可能会带来高昂的成本，而对最终客户而言，价值相对较低。大多数公司选择逐步采用 Compose，使用 View 系统来维护较旧的 UI。你可能需要 View 技能才能有效地将 View 转换为 Compose。</p>

<h2>7.APK 大小</h2>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*MyanicOBr--xVFZUqSaxEg.png" alt="APK大小" /></p>

<p>如果你担心软件包的大小，你可以重新考虑是否采用 Jetpack Compose。它将使你的软件包大小至少<a href="https://www.reddit.com/r/androiddev/comments/1c5vjhi/i_see_your_enterprisegrade_jetpack_compose_11mb/">增加几MB</a>，虽然你可以启用<a href="https://r8.googlesource.com/r8/+/refs/heads/master/compatibility-faq.md#r8-full-mode"> R8 完整模式</a>以进一步减小大小。但是，View 系统的占用的额外空间几乎为零，因为组件是系统的一部分，不需要额外的库。</p>

<h2>8. 与旧设备的兼容性</h2>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*C-GWYdBlBQfjl4jHLexP7Q.png" alt="老旧设备你" /></p>

<p>Jetpack Compose 最高可兼容 Android API 21（Lollipop🍭 、Android 5.0）。如果你想要针对性地适配以前的 Android 版本，则必须使用 View。</p>

<h2>9. 嵌入和物联网设备</h2>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WMYdpUZ4oDT6Axy2GSp0CQ.png" alt="物联网设备" /></p>

<p>单一用途的设备（自助服务终端、支付终端、自助结账）通常只运行一个应用，并且 CPU 和 RAM 资源有限。对于这些设备来说，Jetpack Compose 可能太重了，可能需要 Android 开发人员使用 View 系统来适应设备规格。这些设备也可能运行比较旧的Android版本，如 4.0 版。</p>

<h2>10. 你不想学习新东西</h2>

<p>也许你已经接近职业生涯的尾声，或者想要转到其他领域，那么在某些情况下，学习 Jetpack Compose 是没有意义的。学习曲线有点陡峭，因为与 View 相比，这是一种非常新的 UI 开发方法。不过，学习它可能很有用，因为其他框架（如 React 和 Flutter）也使用了某些类似的原理。</p>

<h2>结论</h2>

<p>Jetpack Compose 是一款出色的 UI 工具包，无疑是 Android 的未来，但它并不是唯一的 UI 工具包，View 已经证明它工作得很好，虽然有些人认为它是遗留的，但最好选择适合你的需求和限制的框架。
无论你选择哪种框架，玩得开心！Android 开发丰富多样，作为 Android 开发人员，我们的职责就是利用这些优势。</p>

<p>感谢你阅读本文，希望你喜欢并学到一些东西。请帮忙点赞，以表示你的支持！</p>

<p>本文由<a href="http://androiddev.news/"> Android 开发者新闻</a>赞助，在<a href="https://play.google.com/store/apps/details?id=sonique.fr.adn"> Play 商店下载</a>应用程序。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解Android中的内存泄漏以及如何让LeakCanary来帮忙]]></title>
    <link href="https://alexhilton.github.io/blog/2025/03/01/understanding-memory-leaks/"/>
    <updated>2025-03-01T11:05:54+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/03/01/understanding-memory-leaks</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自<a href="https://proandroiddev.com/understanding-memory-leaks-in-android-how-leakcanary-can-help-4768df60f646">Understanding Memory Leaks in Android &amp; How LeakCanary Can Help</a>，原文发布于2024年12月27日。</p></blockquote>

<p><strong>译者注：</strong> 关于内存优化，笔者也曾经写过两篇文章，侧重于内存问题的深入分析，如有兴趣可以作为拓展阅读：<a href="https://juejin.cn/post/7277489569958756364">让你不再惧怕内存优化</a>和<a href="https://juejin.cn/post/7287913786038992915">Android应用性能剖析全攻略</a>。</p>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Sx4veSpq_Z1oYBsP5Q7nwQ.jpeg" title="auto auto" ></a></p>

<!-- more -->


<p>作为 Android 开发者，管理内存是构建高性能应用的一个最关键方面。开发者面临的一个最常见问题是内存泄漏。这些泄漏会对应用的性能和用户体验产生负面影响，导致运行缓慢、崩溃甚至电池耗尽你。但别担心——有一种解决方案可以让发现和修复内存泄漏变得更容易，那就是LeakCanary。</p>

<p>在这篇文章中，我们将首先探讨什么是内存泄漏、为什么会发生内存泄漏，然后介绍 LeakCanary 作为检测和修复 Android 应用程序中这些泄漏的强大工具。</p>

<h2>什么是内存泄漏？</h2>

<p>当你的应用保留不再需要的内存时，就会发生内存泄漏。简单来说，当不再使用的对象没有从内存中正确清除时，就会发生内存泄漏，从而导致你的应用消耗了不必要的内存。随着时间的推移，这可能会导致性能下降，在极端情况下，还会导致应用崩溃。</p>

<h2>内存泄漏为何如此危险？</h2>

<p>内存泄漏乍一看似乎无害，但它可能会给你的 Android 应用带来严重问题：</p>

<ol>
<li><strong>内存使用量增加：</strong> 当内存未释放时，应用会不断消耗更多资源，导致内存消耗过高。</li>
<li><strong>性能下降：</strong> 随着时间的推移，内存中保存的对象越来越多，应用会变得越来越慢，导致延迟和用户体验不佳。</li>
<li><strong>应用崩溃：</strong> 如果内存消耗达到临界水平，你的应用可能会崩溃甚至强制关闭。</li>
<li><strong>电池耗尽：</strong> 内存泄漏可能导致进程在后台运行，从而比预期更快地耗尽设备电池。</li>
</ol>


<h2>Android 中内存泄漏的常见原因</h2>

<ol>
<li><strong>保存对上下文的引用：</strong> 如果你在静态变量或单例中保存对 Activity 或 Context 的引用，它将永远不会被垃圾回收，因为系统仍会考虑正在使用的 Activity 或 Context。</li>
<li><strong>内部类和匿名类：</strong> 它们隐式保存对外部类（通常是 Activity 或 Fragment）的引用，从而防止它们被垃圾回收。</li>
<li><strong>未关闭的资源：</strong> 完成后不关闭 Cursor、Stream 或数据库连接等资源可能会导致内存堆积。</li>
<li><strong>事件侦听器：</strong> 如果你向 UI 元素添加侦听器（例如 OnClickListener），但在不再需要它们后没有将其删除，这些对象可能会泄漏内存。</li>
</ol>


<h2>LeakCanary 如何帮助检测 Android 中的内存泄漏</h2>

<p>现在我们了解了内存泄漏可能导致的问题，让我们来讨论一下可以帮助我们检测内存泄漏的工具：LeakCanary。</p>

<p><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*xas01FOk-1FlwDFe.png" alt="LeakCanary" /></p>

<p>LeakCanary 是一个适用于 Android 的开源内存泄漏检测库。它旨在自动识别开发过程中应用中的内存泄漏，让你在影响用户之前修复它们。</p>

<ul>
<li>当发生内存泄漏时，LeakCanary 会自动触发堆转储，对其进行分析，并向开发人员提供一份报告，指出泄漏发生的位置。这使开发人员能够更轻松地发现和解决内存泄漏，以免导致性能问题。</li>
</ul>


<h3>LeakCanary 如何工作？</h3>

<p>LeakCanary 的工作原理是监控应用的内存并分析堆转储以识别不应该存在的对象。当检测到内存泄漏时，它会生成一份报告，显示泄漏发生的位置，从而帮助你找出根本原因。</p>

<ol>
<li><strong>堆转储：</strong> 当 LeakCanary 检测到潜在泄漏时，它会进行堆转储（应用内存的快照），并将其与垃圾回收后的堆进行比较。如果它发现不应保留的对象，它会将其标记为泄漏。</li>
<li><strong>泄漏的对象：</strong> LeakCanary 会向你显示哪些对象被保存在内存中以及引用链中，帮助你识别导致泄漏的对象以及它仍被保留的原因。</li>
<li><strong>通知：</strong> 每当 LeakCanary 发现内存泄漏时，它都会在应用的调试版本中通知你。你可以快速访问报告并开始解决问题。</li>
</ol>


<p>LeakCanary 自动检测以下对象的泄漏：</p>

<ul>
<li>销毁的 Activity 实例</li>
<li>销毁的 Fragment 实例</li>
<li>销毁的 fragment View 实例</li>
<li>清除的 ViewModel 实例</li>
<li>销毁的 Service 实例</li>
</ul>


<h3>如何将 LeakCanary 集成到 Android 项目中？</h3>

<p>要将 LeakCanary 集成到 Android 项目中，请按照以下步骤操作：</p>

<ul>
<li><strong>添加 LeakCanary 依赖项：</strong> 在 build.gradle 文件（应用程序级别）中，添加以下内容：</li>
</ul>


<pre><code class="Groovy">dependencies {
    debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.9.1'
}
</code></pre>

<ul>
<li><strong>初始化 LeakCanary：</strong> LeakCanary 在调试构建类型中自动初始化。但是，你可以在 Application 类中手动初始化它：</li>
</ul>


<pre><code class="Java">public class MyApplication extends Application {
    @Override
    public void onCreate() {
        super.onCreate();
        if (LeakCanary.isInAnalyzerProcess(this)) {
            return; // LeakCanary is in heap analysis process
        }
        LeakCanary.install(this); // Initialize LeakCanary
    }
}
</code></pre>

<ul>
<li><strong>在调试模式下运行应用程序</strong>，LeakCanary 将在开发阶段检测内存泄漏。</li>
</ul>


<h3>如何在生产版本中使用 LeakCanary？</h3>

<p>虽然 LeakCanary 专为调试和开发而设计，但在生产环境中使用它时应谨慎。它可能会影响应用性能，并可能不必要地暴露与内存相关的数据。但是，如果你出于某种原因需要在生产环境中启用它，则可以有条件地仅在某些构建版本中添加 LeakCanary：</p>

<pre><code class="Groovy">dependencies {
    releaseImplementation 'com.squareup.leakcanary:leakcanary-android-no-op:2.9.1' // No-op for release
    debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.9.1'
}
</code></pre>

<p>这样，LeakCanary 仅在调试版本中处于活动状态，而无操作版本则用于生产。</p>

<h3>你将采取什么步骤来修复 LeakCanary 报告的内存泄漏？</h3>

<p>当 LeakCanary 报告内存泄漏时，请按照以下步骤解决：</p>

<ol>
<li><p><strong>分析泄漏报告：</strong> LeakCanary 提供一份详细的报告，其中包含一个对象引用链，显示泄漏发生的位置。</p></li>
<li><p><strong>识别泄漏对象：</strong> 查找意外保存在内存中的对象（如 Activity、Fragment 或 Context）。</p></li>
<li><p><strong>修复泄漏：</strong></p>

<ul>
<li>避免将 Activity 或 Context 引用存储在静态变量或长寿命对象中。</li>
<li>确保关闭 Cursor、Stream 等资源。</li>
<li>在不再需要时删除侦听器和回调。</li>
</ul>
</li>
<li><strong>测试修复：</strong> 进行更改后，重新运行你的应用以确认内存泄漏已解决。</li>
</ol>


<h3>LeakCanary 有哪些局限性？</h3>

<p>虽然 LeakCanary 是一款出色的工具，但它也有一些局限性：</p>

<ul>
<li><strong>并非所有泄漏都能被检测到：</strong> LeakCanary 专注于 Java 堆内存泄漏，但它可能无法检测本机内存泄漏或低级问题。</li>
<li><strong>对性能的影响：</strong> 由于堆分析过程，在开发过程中运行 LeakCanary 可能会稍微减慢你的应用速度。</li>
<li><strong>不能取代良好的内存管理：</strong> 虽然 LeakCanary 有助于检测泄漏，但开发人员仍应遵循内存管理的最佳实践，以防止泄漏发生。</li>
</ul>


<h2>结论</h2>

<p>内存管理对于确保 Android 应用高效运行至关重要。LeakCanary 是一款功能强大的工具，可帮助你在内存泄漏影响应用性能之前检测并解决内存泄漏问题。通过遵循最佳实践并将 LeakCanary 集成到你的开发过程中，你可以确保你的应用保持优化状态并且不会出现与内存相关的问题。</p>

<p>检查你是否已在 Android 应用程序中完成以下所有操作：</p>

<ol>
<li><a href="https://developers.google.com/maps/documentation/places/android-sdk/memory-best-practices#rel-unused">释放未使用的资源。</a></li>
<li><a href="https://developers.google.com/maps/documentation/places/android-sdk/memory-best-practices#unreg">不再需要时取消注册监听器。</a></li>
<li><a href="https://developers.google.com/maps/documentation/places/android-sdk/memory-best-practices#cancel-tasks">不需要时取消任务。</a></li>
<li><a href="https://developers.google.com/maps/documentation/places/android-sdk/memory-best-practices#fwd-lifecyc">发生命周期方法以释放资源。</a></li>
<li><a href="https://developers.google.com/maps/documentation/places/android-sdk/memory-best-practices#latest-versions">使用最新版本的 SDK。</a></li>
</ol>


<h2>参考</h2>

<ul>
<li><a href="https://developers.google.com/maps/documentation/places/android-sdk/memory-best-practices">https://developers.google.com/maps/documentation/places/android-sdk/memory-best-practices</a></li>
<li><a href="https://square.github.io/leakcanary/">https://square.github.io/leakcanary/</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
