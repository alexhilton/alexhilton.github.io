<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2024-05-30T20:43:25+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『飞龙在天』]]></title>
    <link href="http://toughcoder.net/blog/2024/05/23/compose-layouts-and-widgets/"/>
    <updated>2024-05-23T20:47:29+08:00</updated>
    <id>http://toughcoder.net/blog/2024/05/23/compose-layouts-and-widgets</id>
    <content type="html"><![CDATA[<p>页面布局是GUI应用开发的核心，决定着一个UI具体如何实现。今天将延着路线图来练习『降Compose十八掌』的第二招式，学习一下如何使用Compose中的布局来构建页面。</p>

<p><a href=""><img src="https://pdfhost.io/api/preview/0d8ea218-1cc8-4b68-a63b-30f534689371" title="auto auto" ></a></p>

<!-- more -->


<h2>基础骨架</h2>

<p>基础骨架是一个应用页面的最关键结构，可以视为一种基础结构，有了基础结构以后，再补充其他具体的细节就能拼凑出来整体页面。<a href="https://developer.android.com/develop/ui/compose/components/scaffold">Scaffold</a>就属于这样的一种基础骨架。</p>

<p>Scaffold并不是Compose设计出来的，它是<a href="https://m3.material.io/">Material Design</a>中的一个基础结构，为复杂的用户界面提供了标准化的平台。它可以把诸如标题栏，内容区域，浮动按扭等不同的UI功能部分组合在一起，形成一个整体连惯的页面。Compose是完全符合Material Design的，因此这里的Scaffold是符合Material Design设计标准的一个实现。</p>

<p>Scaffold主要有四个部分：</p>

<ul>
<li>topBar - 在最顶部的标题栏，可以显示标题，导航按扭，以及菜单。对Android熟悉的同学把它当成ActionBar就可以了。</li>
<li>bottomBar - 在最底部的工具栏，一般用来显示页面内部的下一级的Tab导航，或者当成工具栏放一些实用性操作。</li>
<li>floatingActionButton - 在右下角悬浮的操作按扭。因为右下角空间有限，所以一般把当前页面最主要的操作放在这里。比如说对于文档类，创建『+』按扭就可以放在这里。</li>
<li>content - 内容区域，就是用于显示页面主要内容的地方，无具体形式，需要开发者自己提供其他布局作为内容。唯一需要注意的是，内容Composable lambda有一个参数叫做innerPadding，这个参数的作用是Scaffold对其content区域加的padding，纯大多数情况下，是需要使用此参数的。</li>
</ul>


<p>Scaffold并不难，很好用，看一个&#127792;就知道了：</p>

<pre><code class="Kotlin">@OptIn(ExperimentalMaterial3Api::class)
@Preview
@Composable
fun ScaffoldExample() {
    var presses by remember { mutableIntStateOf(0) }

    Scaffold(
        topBar = {
            TopAppBar(
                colors = mediumTopAppBarColors(
                    containerColor = MaterialTheme.colorScheme.primaryContainer,
                    titleContentColor = MaterialTheme.colorScheme.primary,
                ),
                title = {
                    Text("降Compose十八掌")
                }
            )
        },
        bottomBar = {
            BottomAppBar(
                containerColor = MaterialTheme.colorScheme.primaryContainer,
                contentColor = MaterialTheme.colorScheme.primary,
            ) {
                Text(
                    modifier = Modifier.fillMaxWidth(),
                    textAlign = TextAlign.Center,
                    text = "掌式要义",
                )
            }
        },
        floatingActionButton = {
            FloatingActionButton(onClick = { presses++ }) {
                Icon(Icons.Default.Add, contentDescription = "Add")
            }
        }
    ) { innerPadding -&gt;
        Column(
            modifier = Modifier.padding(innerPadding),
            verticalArrangement = Arrangement.spacedBy(16.dp),
        ) {
            Text(
                modifier = Modifier.padding(8.dp),
                text =
                """
                    “降龙十八掌可说是【武学中的巅峰绝诣】，当真是无坚不摧、无固不破。虽招数有限，但每一招均具绝大威力。
                    北宋年间，丐帮帮主萧峰以此邀斗天下英雄，极少有人能挡得他三招两式，气盖当世，群豪束手。
                    当时共有“降龙廿八掌”，后经萧峰及他义弟虚竹子删繁就简，取精用宏，改为降龙十八掌，掌力更厚。
                    这掌法传到洪七公手上，在华山绝顶与王重阳、黄药师等人论剑时施展出来，王重阳等尽皆称道。”
                """.trimIndent(),
            )
        }
    }
}
</code></pre>

<p>是一个非常标准的Material Design页面。</p>

<p><img src="https://pic4.zhimg.com/80/v2-702cd12966ec61fe985a3d0020114567_1440w.webp" alt="Scaffold Demo" /></p>

<p><strong>注意：</strong>如果仔细看Scaffold函数可以发现，前面提到的四大部分，并不是传入数据，而是传入函数。这是声明式代码与传统方式的最大的区别，也是声明式代码的精髓所在，只是声明一个可以用于产生数据的函数作为参数，而非直接把数据当作参数传过去。这样做的好处在于，框架代码可以在真正需要数据的时候通过调用函数来生成数据，避免了数据提前生成。</p>

<p>小结一下，Scaffold是一个非常强大的基础骨架，适用当作页面基础结构来使用，也就是说只能用它来实现一级页面。</p>

<h2>布局管理器</h2>

<p>有了页面的基础骨架后，就可以往里面填内容了，布局器管理器就是用于组织和管理其他布局和基础部件的约束器，方便对页面元素进行归类和整理。包括三个分类，一是基础布局，是最为基础也最为常用的管理器；二是高级布局，用于一些复杂场景的管理器；三是集合性布局，用于显示数据集合。我们分别来学习。</p>

<h3>基础布局</h3>

<p>最为基础的布局管理器就三个：Row（行式，水平方向依次排列）Column（列式，垂直方向依次排列）和Box（层叠式，在屏幕上层叠）。用一张图就明了：</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/layout-column-row-box.svg" alt="Basic layouts" /></p>

<p>如果有Android基础的同学可以进行类比，Row和Column就相当于LinearLayout，而Box相当于FrameLayout。</p>

<h3>高级布局</h3>

<p>一般情况下通过基础布局的组合能够实现绝大部分的UI页面，如果遇到更复杂的声明，那就要用更为强大的工具。</p>

<h4>约束式布局（ConstraintLayout in Compose）</h4>

<p>ConstraintLayout是谷歌推出的一个更为强大的布局，用约束（constraint）统一了概念，可以任意排列子布局。Compose中也是可以<a href="https://developer.android.com/develop/ui/compose/layouts/constraintlayout">使用ConstraintLayout的</a>，并且它可以替代Row，Column和Box。需要注意它并不是Compose的一部分，需要额外添加依赖：</p>

<pre><code class="Groovy">implementation "androidx.constraintlayout:constraintlayout-compose:1.0.1"
</code></pre>

<pre><code class="Kotlin">@Composable
fun ConstraintLayoutContent() {
    ConstraintLayout {
        // Create references for the composables to constrain
        val (button, text) = createRefs()

        Button(
            onClick = { /* Do something */ },
            // Assign reference "button" to the Button composable
            // and constrain it to the top of the ConstraintLayout
            modifier = Modifier.constrainAs(button) {
                top.linkTo(parent.top, margin = 16.dp)
            }
        ) {
            Text("Button")
        }

        // Assign reference "text" to the Text composable
        // and constrain it to the bottom of the Button composable
        Text(
            "Text",
            Modifier.constrainAs(text) {
                top.linkTo(button.bottom, margin = 16.dp)
            }
        )
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/layout-button-text.png" alt="ConstraintLayout demo" /></p>

<p>ConstraintLayout是非常强大的，可以<a href="https://juejin.cn/post/7259659776459620411">参考前面的一篇文章</a>来了解它的使用方法，在Compose中使用与在View和XML中使用是一样的。</p>

<h4>流式布局（Flow layouts）</h4>

<p><a href="https://developer.android.com/develop/ui/compose/layouts/flow">流式布局</a>非常强大，也非常常用，它们能够自动折成多行或者多列。Row和Column只能一行或者一列，超出了父布局的宽度和高度后，就看不见了。但FlowRow和FlowColumn则可以自动折叠，变为多行或者多列。并且是智能折叠，不会让子元素只显示一半。这个有非常实用的场景，像显示一些新闻的标签时，就可以用FlowRow。</p>

<pre><code class="Kotlin">@Composable
private fun FlowRowSimpleUsageExample() {
    FlowRow(modifier = Modifier.padding(8.dp)) {
        ChipItem("Price: High to Low")
        ChipItem("Avg rating: 4+")
        ChipItem("Free breakfast")
        ChipItem("Free cancellation")
        ChipItem("£50 pn")
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/layouts/flow/flow_row_simple.png" alt="FlowRow demo" /></p>

<h3>集合性布局</h3>

<p><a href="https://developer.android.com/develop/ui/compose/lists">集合性布局</a>用于显示数据集合，通常都是数量比较多。因为集合数据比较多，远超一个屏幕所能显示得完，因此集合性布局的优势在于用少量的子布局，以复用的方式来把集合数据展示出来。主要有三类水平方向的<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/lazy/package-summary#LazyRow(androidx.compose.ui.Modifier,androidx.compose.foundation.lazy.LazyListState,androidx.compose.foundation.layout.PaddingValues,kotlin.Boolean,androidx.compose.foundation.layout.Arrangement.Horizontal,androidx.compose.ui.Alignment.Vertical,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean,kotlin.Function1">LazyRow</a>)，垂直方向的<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/lazy/package-summary#LazyColumn(androidx.compose.ui.Modifier,androidx.compose.foundation.lazy.LazyListState,androidx.compose.foundation.layout.PaddingValues,kotlin.Boolean,androidx.compose.foundation.layout.Arrangement.Vertical,androidx.compose.ui.Alignment.Horizontal,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean,kotlin.Function1">LazyColumn</a>)以及格子式的LazyGrid。使用起来也非常的直观，在其<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/lazy/LazyListScope">LazyListScope</a>中为子元素生成布局就可以了：</p>

<pre><code class="Kotlin">LazyColumn {
    items(
        items = messages, // 这是集合
        key = { message -&gt;
            // 指定一个用于唯一标记集合中每个元素的id
            message.id
        }
    ) { message -&gt;
        // 这里生成集合元素对应的布局
        MessageRow(message)
    }
}
</code></pre>

<p>需要注意的地方就是有很多个扩展函数items，每个集合性布局都有一个，在import的时候一定要选择与布局对应的那个。另外就是为了能让Compose区别不同的数据元素，一定要给集合元素指定一个可以在此范围内唯一标记元素的id。要不然在编辑的时候可能会有问题。</p>

<h2>常见基础部件</h2>

<p>最为常用的就是<a href="https://developer.android.com/develop/ui/compose/text">文本（Text）</a>，<a href="https://developer.android.com/develop/ui/compose/graphics/images/loading">图像（Image）</a>和<a href="https://developer.android.com/develop/ui/compose/graphics/images/material">图标（Icon）</a>了，都不复杂，看个例子就能明白怎么使用。需要说明一下的就是Image是用于显示的图片；而Icon是用于显示小的图标，一般都是矢量图标资源。</p>

<pre><code class="Kotlin">@Composable
fun ArtistCard(artist: Artist) {
    Row(
        modifier = Modifier.padding(16.dp),
        verticalAlignment = Alignment.CenterVertically,
        horizontalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        Box {
            Image(painter = painterResource(id = artist.image), contentDescription = "Artist image")
            Icon(
                modifier = Modifier.align(Alignment.BottomEnd),
                imageVector = Icons.Filled.Check, contentDescription = "Check mark",
                tint = MaterialTheme.colorScheme.surfaceTint
            )
        }
        Column {
            Text(
                text = artist.name,
                style = MaterialTheme.typography.titleMedium,
                color = MaterialTheme.colorScheme.primary
            )
            Text(
                text = artist.status,
                style = MaterialTheme.typography.titleSmall,
                color = MaterialTheme.colorScheme.secondary
            )
        }
    }
}
</code></pre>

<p><img src="https://pic1.zhimg.com/80/v2-5cbb58f28d1ef31f076bcbb3c0565ab8_1440w.webp" alt="Widgets" /></p>

<h2>实战练习</h2>

<p>今天学习的内容比较多，Compose的<a href="https://developer.android.com/develop/ui/compose/components">布局非常之多</a>，今天的内容只是深入浅出式的学习了一些基础。另外，强烈建议亲手操练一下，推荐官方出品的实战教程<a href="https://developer.android.com/codelabs/jetpack-compose-basics#0">Jetpack Compose basics</a>和<a href="https://developer.android.com/codelabs/jetpack-compose-layouts#0">Basic layouts in Compose</a>。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/layouts/basics">Compose layout basics</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为安卓猿准备的Google I/O 2024省流版本]]></title>
    <link href="http://toughcoder.net/blog/2024/05/20/google-io-2024-recap/"/>
    <updated>2024-05-20T22:51:35+08:00</updated>
    <id>http://toughcoder.net/blog/2024/05/20/google-io-2024-recap</id>
    <content type="html"><![CDATA[<p>前两天一年一度的谷歌开发者大会Google I/O 2024在大洋彼岸如期举行，在会上谷歌发布了一系列最新的技术。本文将以Android开发为核心来汇总一下大会的内容。</p>

<p><a href=""><img src="https://io.google/2024/app/images/og-image.jpeg" title="auto auto" ></a></p>

<!-- more -->


<h2>Android 15 Beta 2来了</h2>

<p>自从Android站稳了脚跟以后（大概是在Android 4.3之后）基本上就是每年一个大版本的节奏，一般是在春季有预览版本，在秋季正式发布。为了抢在水果的前面，也都会在Google I/O时进行重点的宣传，所以每年的Google I/O一大看点就是新一代的Android。当然了，从去年开始AI变成了焦点，但是回到前几年时Android是绝对的焦点。</p>

<p>今年也不例外，在Google I/O上面也宣传了一下Android 15，并正式发布了第2个Beta版本，从功能和Feature角度来说，这个就非常接近于正式版本了。不过就如我在<a href="https://juejin.cn/post/7359900973991493669">前面一篇文章</a>中提到的那样，Android 15其实没啥亮点，主要集中在安全和隐私方面的加强，其余的改进也都非常的小。</p>

<p>关于Android 15具体的改动，可以看一下<a href="https://juejin.cn/post/7369178977473478693">前排大佬的总结</a>，总结的比较详细，就不重复了。</p>

<p>想体验Android 15 Beta 2的话，如果是谷歌的设备如Pixel系列，应该就有推送了。另外就是现在谷歌都会与厂商联动一起<a href="https://developer.android.com/about/versions/15/devices">发布新版Android的Beta版本</a>，这已经是好几年的传统了。就比如像小米，在15号大半夜（准确地说是16号凌晨）发布了<a href="https://web.vip.miui.com/page/info/mio/mio/detail?postId=44582045&amp;fromPathname=mioHomePage&amp;app_version=dev.240425&amp;ref=share">四款机型的Android 15 Beta OTA包</a>，手头有设备的可以体验一下。</p>

<p><img src="https://cdn.cnbj1.fds.api.mi-img.com/vip/e3f85e4bf27da33a47a6c343532c8f180555ebf855d77401c957163e1b1b2cac?thumb=1&amp;w=5040" alt="" /></p>

<p>再说一下Android 15（targetSdk 35）的适配，如前所述这一版本较上一代没啥变化，如果本身就已经<a href="https://juejin.cn/post/7359900973991493669">适配到了Android 14（targetSdk 34）</a>，就不用再特殊适配了。</p>

<h2>AI霸屏</h2>

<p>从去年开始AI就是巨头们的焦点，今年更是霸屏，整个Keynote全是关于AI的，唯一提到Android的地方，也是说在Android手机上如何使用AI。在大模型这条赛道上Google是追随者，就在Google I/O前两天还被Open AI给抢了热度给恶心了一把，劈柴大叔今年略忧伤，讲Keynote的时候有点无精打彩，完全没了前几年那种激情四射。</p>

<p>今年Google发布了Gemini 1.5 Pro，支持1M的上下文Token，大约可以记得1500份PDF，并且演示了很多大模型的具体应用场景，像搜索，图片处理以及文字和代码生成助手。</p>

<p>当然，Android开发者更应该关注的是在端侧部署的大模型。时至今日，大模型已经进入了平稳提升期，大家都是在做出更强大的模型，比如参数更多，上下文更长等等。但大模型仍有一个短板就是无法在端侧的部署，特别是移动设备，如手机，平板，车机，甚至手表等，因受制于性能。目前来说，端侧使用大模型都还是使用网络API的方式，一方面这会依赖于网络，但更重要的是，这会受制于安全和隐私。端侧大部分的数据，是不能直接，也不太可能全都上传到服务器。因此端则部署大模型还是有价值可挖的，比如说对于设备的运行数据，以及像用户一些不愿分享的数据，就可以直接用端侧的大模型来直接处理。</p>

<p>Google发布了端侧的大模型Gemini Nano，将会集成在Android 15之中，并且它支持多模态，还是值得期待的。不过呢，目前Gemini Nano也没有具体的API，谷歌也只给了一个空头支票，在手机上选择文字，然后端侧大模型就可以求解其中的数学题。说实话，这个举例场景的不够好，写作业的场景，作业题怎么可能出现在手机里，然后还是现成的文字？也说明美帝的学生不够卷，在我朝，早就有了作业帮，猿辅导之类的拍一下题目就能给出详细求解过程。</p>

<p><img src="https://duet-cdn.vox-cdn.com/thumbor/0x0:720x720/1440x1440/filters:focal(360x360:361x361):no_upscale():format(webp)/cdn.vox-cdn.com/uploads/chorus_asset/file/25446163/google_io_cts_720.gif" alt="" /></p>

<p>不过Android生态一向受制于厂商，谷歌能做的事情并不多，估计只在谷歌的官方设备（Pixel）中可以用，其他的还是要靠厂商。这点就比不上水果，相信在6月份，水果应该会拿出更为接地气（有实际场景应用和开放API）的端侧大模型集成方案。</p>

<h2>Android开发工具</h2>

<p>这次谷歌把其大模型Gemini应用到了很多具体的场景中，Android开发官方IDE Android Studio新版本<a href="https://developer.android.com/studio/preview">Koala</a>中就深度绑定了Gemini，可以用来生成代码，分析代码和帮助解决其他编程问题。</p>

<p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjijLoXfb-dz3Mur_G_lCCPvgbTr-b_Fvc6sigTPPlRJbA_0IhNepgqPW9a4UACplpEHc2llUMxOeEFBjxHOINVoHYBMWRJ3FA9B1L4MlEv0lxEg5YFuzv0pvuY47b0466pQeDgwtiPZSiivgr9iZ9GVWL0xxj5pzLysnq6ShNi7hn0LorpNBVa4enXsq4/s1600/code_transforms.gif" alt="" /></p>

<p>除了代码，此外Gemini还能帮忙分析错误报告，以及生成集成有Gemini API代码的项目，可见Gemini已经深度融合进了Android Studio之中。详细的可以<a href="https://android-developers.googleblog.com/2024/05/google-io-2024-whats-new-in-android-development-tools.html">看一看官文档</a>。看着都挺美好 的，但其实最想知道的问题是，是否会对我们东方大国开放使用？</p>

<p>其他的都是一些常规的小的提升，如可穿待设备的不同模式下的预览，Compose的实时编辑以及Compose Glance（桌面小部件）预览， 以及Android Studio Profiler的改进等等。</p>

<h2>Android开发套件</h2>

<p>对于Android相关的开发套件，唯一提到的都是与<a href="https://juejin.cn/post/7367390293812035610">Jetpack Compose</a>相关的，可见谷歌对它的重视。新东西也都中规中矩，主要是在动画上面，如分享页过渡，可复用列表（Lazy list）元素的动画；文本控件支持HTML了；一个新的布局ContextualFlowRow，用以实现复杂的可复用流式布局，这个还是挺有用的；以及性能提升。详细内容可以<a href="https://android-developers.googleblog.com/2024/05/whats-new-in-jetpack-compose-at-io-24.html">看官方博客</a>。</p>

<p><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjbUo5RnrBoOsutrYVGiLIWZ16yIsll5cxnaSo9Gm4mXwl29MA_fVpwM0wH_RhRrehS9kJRnRISkEVW3yoTkhyT0GUEWg8kGCByRD2Gf0FOIJj9dyLD6NJYtOt4l-Vd_FEkJVj4DRNeu_G5fzwU34Dhq_Gv3dKozTq3iAcOrcHvS4o2WDHGDchZC-zhZL8/s600/image7.gif" alt="" /></p>

<p>Jetpack Compose对于常规的UI来说已经没有问题，但是对于一些专业领域的UI还是无法胜任，比如像相机，视频和图像的预览和渲染还是无法在Compose中使用。好消息是，现在Google已经着手处理了，这次就基于<a href="https://developer.android.com/jetpack/androidx/releases/camera">CameraX</a>搞了一个<a href="https://developer.android.com/jetpack/androidx/releases/camera#camera_viewfinder_compose_version_10_2">camera-viewfinder-compose</a>，能够在Compose中显示相机预览。</p>

<p>再有就是<a href="https://www.jetbrains.com/kotlin-multiplatform/">Kotlin Multiplatform</a>，这个是Jetbrains在主要搞的东西，谷歌也加大了配合力度（First class support），比如已经把一些Jetpack中的库添加了对KMM的支持。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://juejin.cn/post/73687573358034289020">2024 Google I/O Android 相关内容汇总</a></li>
<li><a href="https://9to5google.com/2024/05/14/google-io-2024-developer-recap/">What’s new for developers at Google I/O 2024</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『亢龙有悔』]]></title>
    <link href="http://toughcoder.net/blog/2024/05/15/compose-made-easy/"/>
    <updated>2024-05-15T20:26:06+08:00</updated>
    <id>http://toughcoder.net/blog/2024/05/15/compose-made-easy</id>
    <content type="html"><![CDATA[<p><a href="https://developer.android.com/develop/ui/compose">Jetpack Compose</a>是新一代的声明式的UI开发框架，由Google在2019年推出，最初是作为Android的新式UI开发框架，但它本质是一个声明式UI开发框架，并不受制于底层的平台，现在的Compose已有跨平台开发能力，但Android上的UI开发仍是最主要的使用领域，深受Android开发者喜爱。计划将用一系列文章，并开辟专栏来学习Compose，此为开篇。</p>

<p><a href=""><img src="https://alexzh.com/content/images/2021/02/logo-1.65-1980-compressed-4.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>注意：最初是叫做Jetpack Compose，作为Jetpack套件中的一个，后来与Jetpack独立开来了，现在Compose发展成为一个独立的声明式的UI开发框架，与Jetpack中其他组件并不是同一个概念，也并不在Jetpack套件里面。所以现在更多的称为Compose，为了方便后续统一称为Compose。</p>

<h2>Hello, Compose!</h2>

<p>老规矩，先来个简单的『Hello, world!』，以快速上手体验：</p>

<p>首先，用Android Studio创建一个新的项目，选择『Phone and Tablet』，选择『Empty Activity』，然后Next。</p>

<p><img src="https://pic2.zhimg.com/80/v2-f1df667c79bf94aa44fe00bccdfbbb65_1440w.webp" alt="create project" /></p>

<p>在项目配置页面填入项目名字和包名等信息，其余的用默认就好。</p>

<p><img src="https://pic3.zhimg.com/80/v2-b76564a9cd826d2dfcc949105eb4bb5a_1440w.webp" alt="config project" /></p>

<p>等一会儿后，项目就创建好了，与常规的Android项目一样的，也有AndroidManifest，是项目运行时的主要配置，以及一个系统组件MainActivity作为入口。打开MainActivity.kt，可以发现里面已经默认用了Compose，并且有东西，我们稍改一下，改成下面的样子：</p>

<pre><code class="Kotlin">class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            HelloComposeTheme {
                // A surface container using the 'background' color from the theme
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    Greeting("Android with Compose!")
                }
            }
        }
    }
}

@Composable
fun Greeting(name: String, modifier: Modifier = Modifier) {
    Text(
        text = "Hello, $name",
        modifier = modifier
    )
}

@Preview(showBackground = true)
@Composable
fun GreetingPreview() {
    HelloComposeTheme {
        Greeting("Android")
    }
}
</code></pre>

<p>然后构建并运行项目，就能得到一个『Hello, Android with Compose!』：</p>

<p><img src="https://pic1.zhimg.com/80/v2-4325b9d9a0a3f1ebb8380dcdc7fe2bec_1440w.webp" height="480" width="320" alt="HelloCompose" /></p>

<p>样子略丑，我们来优化一下，修改Greeting函数：</p>

<pre><code class="Kotlin">@Composable
fun Greeting(name: String, modifier: Modifier = Modifier) {
    Box(modifier = Modifier.fillMaxSize()) {
        Text(
            text = "Hello, $name",
            modifier = modifier
                .padding(16.dp)
                .align(Alignment.Center),
            style = MaterialTheme.typography.headlineLarge,
            color = MaterialTheme.colorScheme.inverseSurface
        )
    }
}
</code></pre>

<p>这下好了一丢丢！</p>

<p><img src="https://pic4.zhimg.com/80/v2-efc8c9e62e38c02e6f18665d71862c97_1440w.webp" height="480" width="320" alt="HelloCompose v2" /></p>

<p>除了在手机或者模拟器运行应用以外，还可以直接用Android Studio进行预览（用&#64;Preview标记的函数才会被预览），不过这不算新功能，因为很久以前打开一个XML文件（如布局），也可以直接在AS里预览的：</p>

<p><img src="https://pic1.zhimg.com/80/v2-aa68d4eb84bf1bd130ca896c05371990_1440w.webp" alt="preview" /></p>

<p>好了，现在我们已经成功学会用Compose来撸安卓UI了。如果有时间还可以试试<a href="https://developer.android.com/develop/ui/compose/tutorial">官方的入门Demo</a>。</p>

<p>注意：不同版本的Android Studio可能会略不一样。详见下节『开发环境配置』。</p>

<h2>配置开发环境</h2>

<p>新一点的Android Studio如Giraffe，如果是新建的项目，默认就是用Compose了，不用再怎么搞（如果是上古时代的AS估计还是View的，建议直接升级AS吧都4202年了）。</p>

<p>如果是现有的项目，想要添加Compose支持，可以这样做，先给android的buildFeatures中添加compose为true，并指定kotlin compiler extension的版本，注意这个并不是kotlin的版本，跟它没关系：</p>

<pre><code class="Kotlin">android {
    buildFeatures {
        compose = true
    }

    composeOptions {
        kotlinCompilerExtensionVersion = "1.5.13"
    }
}
</code></pre>

<p>然后再配置一坨依赖：</p>

<pre><code class="Kotlin">dependencies {
    val composeBom = platform("androidx.compose:compose-bom:2024.05.00")
    implementation(composeBom)

    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.ui:ui-graphics")

    // Material Design 3
    implementation("androidx.compose.material3:material3")

    // Android Studio Preview support
    implementation("androidx.compose.ui:ui-tooling-preview")
    debugImplementation("androidx.compose.ui:ui-tooling")
}
</code></pre>

<p>为了方便管理Compose依赖的版本，谷歌搞了一个叫做『物料清单』（Bill of Materials BOM），简单来说就是把Compose所有library的版本放到一个叫做BOM的library中，我们只需要指定一个BOM，这样，就能指定一坨Compose libraries的版本。详细的内容以及困难解决可以<a href="https://developer.android.com/develop/ui/compose/setup#kotlin">参考官方文档</a>。</p>

<h2>理解Compose的基本原理</h2>

<p>从我们的『HelloCompose』中可以看出Compose的特点，它是纯代码，Compose就是一个坨函数声明，不用再撸XML了；它是声明式的，也就是说你只是告诉框架需要什么，期望的样子是什么；它是响应式的，也就是说拿到最新的数据和状态，然后用相应的UI元素进行展示。这与以往用XML写UI是完全不同的，用XML是命令式的，你要拿到View，设置具体的细节。</p>

<p>用Compose撸UI主要分为两部分，一是元素，如布局和具体的渲染元素如文字图片；另一个则是样式控制，所有元素都能接受一个Modifier对象来控制元素的样式，如大小，位置，偏移，对齐等等。会在后面的文章中对这些概念进行详细的讨论。</p>

<p>另外需要注意，Compose就是一坨函数，上面例子中看到的『setContent』，『HelloComposeTheme』，『Suface』，『 Greeting』，『GreetingPreview』，『Box』，『Text』都是函数，虽然它们不符合Kotlin的函数命令规范。这里面套娃式的结构如：</p>

<pre><code class="Kotlin">    setContent {
        HelloComposeTheme {
            // A surface container using the 'background' color from the theme
            Surface(
                modifier = Modifier.fillMaxSize(),
                color = MaterialTheme.colorScheme.background
            ) {
                 Greeting("Android with Compose!")
            }
       }
    }
</code></pre>

<p>是借助于尾部lambda实现的内部DSL，本质上也都是函数调用，视为函数调用就好了。感觉不熟悉的同学可以看看<a href="https://juejin.cn/post/7321550265610108979">前面的文章</a>以加深理解。</p>

<h2>为啥要使用Compose</h2>

<p>就Android开发来说明明已经有比较完善的View和XML来撸UI，为啥还要搞一个Compose呢？</p>

<p>首先，声明式编程范式是最新式的UI构建方式，较原始方式（View和XML）它更加接近于人的思维。开发者只需要告诉架构『我要什么』以及『该如何响应』就可以了，其他事情都交给框架。像Flutter， React， SwiftUI等都是声明式的。一旦我们熟悉了以后，就会发现声明式UI可以极大的提高开发效率，最重要的是它能提高可扩展性（Scalability）。</p>

<p>再有，Compose与各种最新的libraries粘合的特别好，像<a href="https://developer.android.com/jetpack">Jetpack</a>，<a href="https://m3.material.io/">MaterialDesign</a>等等，都可以直接在Compose中使用，非常的方便。</p>

<p>最后，最重要的原因是Google在大力的布道Compose，已经把Compose设置为默认的UI开发方式，作为<a href="https://developer.android.com/modern-android-development">MAD（Modern Android Development）</a>的一块拼盘，新推出的有关于UI的文章都是基于Compose的。并且Google还在不断大力开发Compose，推出新功能以及提升渲染性能。从前面的例子也可以看出，现在默认新建一个项目就是用的Compose，相反，如果想要弄一个只用View的项目，还比较麻烦，要去除一系列配置参数。</p>

<p>作为开发者，肯定要顺应潮流，迎头敢上（对的，是敢而不是赶）。</p>

<h2>迁移建议</h2>

<p>Compose虽然新式且好用，但我们在做迁移的时候要谨慎。对于新的技术（无论是新的编程语言，新的框架，还是新的编程范式）切忌不要一刀切或者搞大跃进。对于，纯新的功能，或者说纯新的项目，当然可以直接就用Compose来开发；但是对于现有的功能，暂时不要去动它，万不可上来就想着用Compose重写一遍。等到对Compose比较熟悉了，人力较富余时，以及现在功能仍会有新的较大的改动时才考虑去重写。对于比较成熟且稳定的功能，建议就不要去折腾它了，因为不会带来价值和收益。</p>

<p><a href="https://developer.android.com/develop/ui/compose/migrate">官方也有迁移建议</a>，可以看一看。</p>

<h2>优质教程与实例</h2>

<p>Google对Compose还是很上心的，写了<a href="https://developer.android.com/develop/ui/compose/documentation">大量的文档</a>，此外还有<a href="https://developer.android.com/courses/jetpack-compose/course">很多教程（CodeLabs）</a>，以及<a href="https://developer.android.com/samples">很多Demo app</a>。并且Compose作为MAD的一块拼盘，也融合进了MAD里面，特别是<a href="https://developer.android.com/develop/ui/compose/architecture">架构层面</a>的文章中用的都是Compose。</p>

<h2>未完，待续</h2>

<p>本文从快速上手的Demo开始，解释一些核心概念，并给出一些有用的资源链接。相信通过此文，能对Compose有一个很好的了解。后续会继续深入探讨各个话题，以练成降Compose十八掌！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实战技巧：Android 14适配从挂号到出院]]></title>
    <link href="http://toughcoder.net/blog/2024/04/23/upgrade-to-targetsdk-34/"/>
    <updated>2024-04-23T21:30:23+08:00</updated>
    <id>http://toughcoder.net/blog/2024/04/23/upgrade-to-targetsdk-34</id>
    <content type="html"><![CDATA[<p>啥？这都4202年了，你的应用还没有升级到targetSDK 34？莫慌，本文就带着你全面的了解升级targetSDK 34的方法以及避坑指南。</p>

<p><a href=""><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/25/1c33d2fabbc44e53b64b6dbbc84fd0ae.png" title="auto auto" ></a></p>

<!-- more -->


<p>注意，<a href="https://apilevels.com/">Android版本与其API level或者targetSDK是一一对应的</a>，只不过一个是外在的说法，一个是具体要做的事情，对于开发者来说适配Android 14，就等同于升级targetSDK到34，这个34称作API level。本文会混着用，但说的都是同一个意思。</p>

<p>等下，有同学举手了，这<a href="https://developer.android.com/about/versions/15">眼看着Android 15（API 35）都</a>要出来，您才教我们升级到targetSDK 34？您 是不是写错了，还是在这里浪费时间呢？</p>

<p>这位同学你先坐下，没写错今天要讲的就是适配Android 14的。至于Android 15还处于预览（Preview）状态呢，它要至少等到10月份左右才会正式发布，属于下半年的KPI了。不过如果 我们把targetSDK 34搞定了，那么年底升级targetSDK 35就会非常的顺畅。</p>

<h2>为啥要升级targetSDK</h2>

<p>在折腾之前要先要搞明白为啥要折腾升级SDK，因为毕竟配置开发环境是软件开发中的排名第二的麻烦事儿（排名第一的是折腾操作系统）项目跑的好好的，何必自找麻烦？</p>

<p>省流点的说，就是你<strong>不得不升级</strong>。众所周知，Android生态最麻烦的事情就是碎片化，也就是用户手机的版本远远小于最新的版本，而且主流的版本升级较慢，通常会比最新的慢3个版本以上，对面的水果则能保持在2个版本以内。这对应用开发生态来说是十分不友好的，因为开发者不愿意升级到最新的SDK，使用平台的最新特性，核心原因在于升级了也没用，因为用户手上的版本仍是3代开外的。</p>

<ul>
<li><a href="https://www.composables.com/tools/distribution-chart">Android Distribution Chart</a></li>
<li><a href="https://developer.android.com/about/dashboards">Distribution dashboard</a></li>
<li><a href="https://gs.statcounter.com/android-version-market-share/mobile/worldwide/">Mobile Android Version Market Share Worldwide</a></li>
</ul>


<p>最心急的当然是谷歌，辛苦花大价钱开发的最新特性竟然没人用，这能忍？于是谷歌对<a href="https://developer.android.com/google/play/requirements/target-sdk">升级targetSDK要求</a>越来越严，对于<strong>谷歌能管得到的地方</strong>，如<a href="https://developer.android.com/distribute/console">Google Play Store</a>和厂商的<a href="https://source.android.com/docs/security/safety-center/test-requirements">GTS测试</a>，都要求至少升级targetSDK到前一代的版本，比如2023年发布了Android 14，那就必须到targetSDK 33（Android 13）；今年将发布Android 15（API 35）那到快要发布时约在2024年秋，应用必须升级到targetSDK 34。</p>

<p>如果不是强制要求升级targetSDK，比如我既不上线到Play Store也不用过GTS，那确实也没必要折腾。因为最近几年Android的新特性其实也都挺鸡肋的，犯不着折腾。</p>

<h2>Android 14的新特性与变化</h2>

<p>具体折腾前还是要先了解一下平台的变化，以评估影响，省流点说，Android 14有以下变化：</p>

<ul>
<li><a href="https://developer.android.com/develop/background-work/services/foreground-services">FOREGROUND&#95;SERVICE</a>必须要指定一个<a href="https://developer.android.com/about/versions/14/changes/fgs-types-required">类型</a>。</li>
<li>调用<a href="https://developer.android.com/reference/android/bluetooth/BluetoothAdapter#getProfileConnectionState(int">BluetoothAdapter#getProfileConnectionState</a>)时必須在Manifest中声明<a href="https://developer.android.com/reference/android/Manifest.permission#BLUETOOTH_CONNECT">BLUETOOTH&#95;CONNECT</a>权限。</li>
<li>支持JDK17，可以使用Java 17了。</li>
<li>动态广播接收器必须指明<a href="https://developer.android.com/reference/androidx/core/content/ContextCompat#RECEIVER_NOT_EXPORTED(">export flag</a>)，这个其实targetSDK 33时就有了。</li>
<li>动态加载的代码（Jar 或者Dex）文件必须标记为只读。这个对插件化和Hotfix等影响较大。</li>
<li>Zip文件处理时，如果有路径越界（如&#8221;..&ldquo;或者以&rdquo;/&ldquo;开头的绝对路径）<a href="https://developer.android.com/reference/java/util/zip/ZipException">会抛异常</a>。</li>
</ul>


<p>总的来说变化不大，主要还是<strong>权限收紧和安全加强</strong>。可以查看<a href="https://developer.android.com/about/versions/14/behavior-changes-14">官方文档</a>来看具体的。不喜欢看原文的同学，还有<a href="https://developer.android.com/about/versions/14/behavior-changes-14?hl=zh-cn">翻译的版本</a>。啥？官方无法访问，莫慌还有<a href="https://developer.android.google.cn/about/versions/14/behavior-changes-14">官方的镜像</a>。</p>

<h2>如何升级</h2>

<h3>做好准备</h3>

<p>折腾开发环境是比较烦的，所以最好找一个相对轻松的时间（比如产品汪休假时），以及心情还不错时。另外一定要把手头的事情做好备份并切到新的分支，以防不测。这真不是把33改到34就能完事儿的，会有各种意想不到的事情。</p>

<h3>修改build.gradle文件</h3>

<p>升级targetSDK的第一步是修改应用的build.gradle文件。找到defaultConfig部分，将targetSdkVersion的值修改为34。例如：</p>

<pre><code class="Groovy">android {
    compileSdkVersion 34
    defaultConfig {
        targetSdkVersion 34
        // 其他配置...
    }
    // 其他构建配置...
}
</code></pre>

<p>同时，确保compileSdkVersion也设置为34，以确保使用最新的编译工具。</p>

<p>注意，建议手动改配置，而不要用所谓的<a href="https://developer.android.com/build/sdk-upgrade-assistant">SDK Upgrade Assistant</a>，因为你不晓得它都会干啥，有可能把项目的配置改的面目全非。</p>

<h3>适配SDK的变化</h3>

<p>就是针对平台的新变化做对应的修改。如何修改？其实<a href="https://developer.android.com/about/versions/14/behavior-changes-14">官方文档</a>里面都有具体的指导，或者<a href="https://blog.csdn.net/lbs458499563/article/details/132928217">这篇文章讲的</a>也非常详细，这里就不重复了。</p>

<h2>避坑指南</h2>

<p>Android 14的变化并不大，没有Android 13带来的变化多，这几年最大的影响是Android 11到Android 13，主要体现在<strong>存储读写</strong>的变化上面，可以看<a href="http://toughcoder.net/blog/2023/05/03/android-scope-storage-puzzles/">之前的一篇文章</a>。</p>

<p><img src="https://s3.eu-west-2.amazonaws.com/uploads.3alampro.com/2021/September/GUKIJS1LwonmLnjJY0Wq5lkZTv78fAukV2SbTSui.jpeg" alt="" /></p>

<p>所以升级到targetSDK 34的难度有多大，有啥坑？这要取决于升级前的基础是什么。如果之前已经升级到了targetSDK 33，那么不会有坑，前面那几点稍弄下，就没有问题了。但如果还在API 30或者31，那麻烦会比较多，因为要先过targetSDK 33这一关，它的坑是最多的，可以<a href="https://juejin.cn/post/7260913522962956347">参考这篇文章</a>。</p>

<h2>做好对平台的封装与隔离</h2>

<p>最近几年Android版本的最大变化就是存储权限的收紧，以前可以直接用File到处读写，现在只有极少数文件夹可读可写，且像媒体文件要用<a href="https://developer.android.com/training/data-storage/shared/media">MediaStore API</a>。如果你的项目代码中到处都是File，甚至在JNI的so中也到处都是绝对路径，那么升级targetSDK会相当痛苦。</p>

<p>这就要求我们在开发过程中多留一个心眼儿。一个伟大的计算机科学家说过「计算机科学中的任何问题都能通过增加一个层来解决」。解决这种平台的硬性依赖的最好方法就是多加一层封装以进行隔离：</p>

<ul>
<li>用一个模块来封装所有的涉及存储的I/O操作，这样即使遇到平台的重大变化，也<strong>只需要改这一个模块，风险大大减小</strong>。</li>
<li>对于JNI，要尽可能的传递数据，而非直接让其操作文件。如果确实要操作文件，那么也要<strong>把根文件夹从Java层传入，不能让so使用绝对路径</strong>。</li>
</ul>


<p>对平台做好<strong>封装和隔离</strong>，会大大加强项目的兼容性，在升级平台SDK时起码能做到<strong>风险可控</strong>。</p>

<h2>未来Android的发展趋势</h2>

<p>Android（其实智能手机操作系统也一样）诞生于21世纪的第一个10年，在第二个10年达到了顶峰，移动互联网让科技巨头吃尽了红利，巨头们的市值更是超过了全球GDP总值。但回首最近两年的Google I/O和水果的WWDC，可以发现，Android和水果越来越像，也在相互抄袭，已经很久没有见到让人感到惊艳的东西了（乔帮主在天上估计都要看不下去了）。</p>

<p>对于Android来说，<strong>系统安全（包括权限收紧和数据安全）</strong>和<strong>隐私保护</strong>（安全和隐私曾经是Android的弱项，现在已追上来了），以及<strong>互联互通</strong>这三个方面还有点新东西，其他的已经没有什么变化了。智能手机已经到了比较明显的瓶颈期，巨头的注意力已经全都转移到了AI上面了。可以看一看<a href="https://developer.android.com/about/versions/15/behavior-changes-15">Android 15的变化</a>，基本上没啥变化，以后的升级会越来越简单了，可能下次只是把34改成35就完事儿了。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/about/versions/14/behavior-changes-14">Behavior changes: Apps targeting Android 14 or higher </a></li>
<li><a href="https://developer.android.com/build/sdk-upgrade-assistant">Use the Android SDK Upgrade Assistant</a></li>
<li><a href="https://developer.android.com/about/versions/14/setup-sdk">Set up the Android 14 SDK</a></li>
<li><a href="https://swiftspeed.app/sdk-target-android-api-level/">How To Update Your App SDK To Target Android API Level 34</a></li>
<li><a href="https://blog.csdn.net/lbs458499563/article/details/132928217">Android14 适配之——targetSdkVersion 升级到 34 需要注意些什么？</a></li>
<li><a href="https://juejin.cn/post/7260913522962956347">升级targetSDK为33后的十来个坑 (工具篇)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/628752923">Android 14 快速适配要点</a></li>
<li><a href="https://juejin.cn/post/7302348032544866316">Android 14 正式版适配笔记（二）— 针对Android14或更高版本应用的变更</a></li>
<li><a href="https://juejin.cn/post/7299834584375869474">Android 14 正式版适配笔记（一）— 针对所有应用的变更</a></li>
<li><a href="https://www.cnblogs.com/joy99/p/17809113.html">记一个 Android 14 适配引发的Android 存储权限问题</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让你从此不再惧怕ANR]]></title>
    <link href="http://toughcoder.net/blog/2023/12/08/android-anr-made-easy/"/>
    <updated>2023-12-08T22:12:55+08:00</updated>
    <id>http://toughcoder.net/blog/2023/12/08/android-anr-made-easy</id>
    <content type="html"><![CDATA[<blockquote><p>这篇文章是基于官方的<a href="https://developer.android.com/topic/performance/anrs/diagnose-and-fix-anrs">Diagnose and fix ANRs</a>翻译而来，但也不是严格的翻译，原文的内容都在，又加上了自己的理解以及自己的经验，以译注的形式对原文的作一些补充。</p></blockquote>

<hr />


<p>当一个Android应用的UI线程被阻塞时间过长，系统就会发出一个臭名昭著的“应用程序未响应”(ANR, Application Not Responding&#8221;)错误。本文将讲述不同类型的ANR，如何分析以及如何解决。文中列出的所有的超时时间范围都是基于<a href="https://source.android.com/">AOSP</a>和Pixel设备；这些时间范围可能会依OEM厂商而不同。</p>

<p><a href=""><img src="https://ts1.cn.mm.bing.net/th/id/R-C.b5cd953e9f33003456314ae6608fcecc?rik=pPBn5R3rPZ83ew&amp;riu=http%3a%2f%2fiotts.com.cn%2fblog%2fimages%2fAndroid_a.jpg&amp;ehk=qj91EEfUUgZ32njo8AfBJIdOoPJYInW%2b7chI6g6Jxqs%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" title="auto auto" ></a></p>

<!-- more -->


<p>需要注意的是，当分析ANR的根因时，区分<strong>系统原因</strong>和<strong>应用本身的原因</strong>是很有帮助的。
当整个系统处于一个糟糕状态时，下面这些问题可能会引发ANR：</p>

<ul>
<li>系统服务内部的一些瞬时问题(Transient issues)就会导致通常很快的binder call变得非常慢。</li>
<li>系统服务的问题以及较高的系统负载会导致应用程序的线程无法被正常的调度。</li>
</ul>


<blockquote><p><strong>译注：</strong><a href="https://learn.microsoft.com/en-us/azure/architecture/best-practices/transient-faults">瞬时问题Transient issue</a>是指一些服务运行时出现了一些瞬时的小错误比如服务器的网络抽风(闪断又闪连)，或者一个系统服务的I/O错误，但可能会导致客户无法正常的获得响应。这里要这样来理解，服务(servers)一般都是长时间运行的，它是有可能会发生一些小错误的，瞬时的很快就恢复了，但如果客户恰好在此时来请求就不会得到响应。尽管这对于服务来说是一个可以忽略的小错误，毕竟它是长时间运行的，几秒钟的小错误不影响它本身的运行，但对客户侧的影响却是较大，对客户侧来说就是请求得不到响应。</p></blockquote>

<p>如果可以的话，区分系统问题还是应用问题的好方法就是使用<a href="https://perfetto.dev/docs/">Perfetto traces</a>:</p>

<ul>
<li>通过查看在Perfetto跟踪的是运行中还是未运行的线程的状态来判断应用的主线程有没有被正常的调度。</li>
<li>查看系统进程system_server的线程，看有没有锁竞争之类的问题。</li>
<li>对于耗时的(跨进程调用)binder calls，查看一下是否存在应答进程，以及为何它会耗时。</li>
</ul>


<blockquote><p><strong>译注：</strong>很多重要的系统服务都在system_server进程里面，如负责创建调度所有组件的<a href="https://android.googlesource.com/platform/frameworks/base/+/4f868ed/services/core/java/com/android/server/am/ActivityManagerService.java">AMS(Activity Manager Service)</a>，包管理<a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/services/core/java/com/android/server/pm/PackageManagerService.java">PMS(Package Manager Service)</a>，窗口管理<a href="https://android.googlesource.com/platform/frameworks/base/+/android-4.3_r2.1/services/java/com/android/server/wm/WindowManagerService.java">WMS(Window Manager Service)</a>等等，system_server进程本来的load其实不轻。再加上很多OEM定制化的功能也必须要在AMS处做事情（如hook或者拦截），导致system_server并不比应用程序少引发问题，而一旦system_server有耗时操作或者在等待锁，会导致整个系统处于极度卡顿状态，这时事件的派发，组件的创建，生命周期的调度，以及WMS的焦点处理等等正常的逻辑都不可能得到及时的流转和响应。这种时候任何一个应用都可能随时发生ANR，但应用本身却都是idle状态，问题是在system_server这一侧。</p>

<p><a href="https://developer.android.com/reference/android/os/Binder">Binder</a>是安卓系统的核心基础通信机制，组件件间的通信，Intent，ContentResolver，应用与AMS，PMS和WMS等等之间的交互都是通过binder call来进行的，常规情况下大部分时候binder call都没有问题会很快问题，但如果binder另一头的某个服务发生了问题，即使是瞬时问题，也会导致binder call被阻塞或者变慢，这时就可能引发应用侧的ANR。</p>

<p>需要厘清概念，系统服务(services)与进程并不是同一回事，也不是一一对应的关系。系统服务是安卓系统架构上的模块，都分布于框架层，支撑着系统的运转。而进程则是CPU（准确的说是操作系统内核）运行和调度的基本单元（进程则再细分为线程）。一个系统服务可能独立占用一个进程，比如像<a href="https://cs.android.com/android/platform/superproject/+/master:packages/providers/MediaProvider/src/com/android/providers/media/MediaService.java">Media Service(mediaserver)</a>，<a href="https://source.android.com/docs/core/camera">CameraService(cameraserver)</a>，也可能会生成几个进程；当然 也有可能几个服务都在同一个进程里面，比如前面提到的与应用程序最为密切相关的三大服务AMS, WMS和PMS。当一个服务必须要有独立进程的时候，就会为它创建独立的进程，比如像CameraService，在Android O以前是没有独立进程的，它活在mediaserver里，后来才有独立的进程cameraserver。</p>

<p>服务是架构上的逻辑概念，而进程和线程是从硬件（CPU）角度看到的代码的执行。ANR是由于进程（准确的说是线程，进程由至少一个线程组成）卡顿或者被阻塞导致的。调试的手段也都是从代码执行的角度，把线程的栈帧转储出来(stack trace dump)，以查看是被哪 个函数阻塞了。</p></blockquote>

<h2>输入派发超时(Input dispatch timeout)</h2>

<p>输入派发无响应发生在应用的主线程无法及时地响应一个输入事件，如滑动手势或者物理按键。因为当输入派发超时发生时应用是在前台的，所以这类超时总是对用户可见的，所以想办法规避是很重要的。</p>

<p><strong>默认超时时间：5秒</strong></p>

<p>输入派发超时无响应通常是由于主线程的问题引起的。如果主线程因为等待获取某个锁而阻塞，锁的持有线程也包含在内。遵循以下最佳实践以防止输入派发未响应：</p>

<ul>
<li>主线程不要进行可能会阻塞或者耗时的操作。可以考虑使用<a href="https://developer.android.com/reference/android/os/StrictMode">严格模式StrictMode</a>来捕捉主线程的一些异常的行为。</li>
<li>尽可能的减少主线程和其他线程之间的锁竞争。</li>
<li>在主线程尽可能减少非UI相关的操作，比如当处理广播(Broadcasts)时或者处理服务时(Services)。</li>
</ul>


<h3>常见的根因</h3>

<p>这里列出一些输入派发无响应常见的根因以及修复建议。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 根因 </th>
<th style="text-align:left;"> 表象 </th>
<th style="text-align:left;"> 修复建议 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 耗时跨进程调用slow binder call </td>
<td style="text-align:left;"> 主线程执行了一个耗时同步binder call </td>
<td style="text-align:left;"> 把这个调用放到非主线程，或者优化一下这个调用，如果你负责这个API的话 </td>
</tr>
<tr>
<td style="text-align:left;"> 很多连续的binder calls </td>
<td style="text-align:left;"> 主线程执行了很多连续的跨进程调用 </td>
<td style="text-align:left;"> 不要在一个密集的循环中执行binder call </td>
</tr>
<tr>
<td style="text-align:left;"> 阻塞式的I/O </td>
<td style="text-align:left;"> 主线程执行了阻塞式的I/O，如数据库操作或者网络请求 </td>
<td style="text-align:left;"> 把所有阻塞式I/O调用放到非主线程里 </td>
</tr>
<tr>
<td style="text-align:left;"> 锁竞争 </td>
<td style="text-align:left;"> 主线程因为等待获取某个锁而阻塞 </td>
<td style="text-align:left;"> 减少主线程与其他线程之间的锁竞争，优化其他线程中的耗时代码 </td>
</tr>
<tr>
<td style="text-align:left;"> 耗时的帧 </td>
<td style="text-align:left;"> 在一帧里面做太多的渲染，导致严重的丢帧 </td>
<td style="text-align:left;"> 减少帧渲染的工作。不要用超过O(n<sup>2</sup>)的算法。用一些高效的组件来进行滑动和分页，比如<a href="https://developer.android.com/jetpack">Jetpack</a>中的<a href="https://developer.android.com/topic/libraries/architecture/paging/v3-overview">Paging library</a> </td>
</tr>
<tr>
<td style="text-align:left;"> 被其他组件阻塞 </td>
<td style="text-align:left;"> 其他的组件比如广播接收器(BroadcastReceiver)正在运行并阻塞着主线程 </td>
<td style="text-align:left;"> 主线程尽量不要做非UI操作，另起一个线程运行broadcast receivers </td>
</tr>
<tr>
<td style="text-align:left;"> GPU挂起 </td>
<td style="text-align:left;"> GPU挂起是一个系统问题或者硬件问题，会导致渲染被阻塞，因此也会引发输入派发ANR </td>
<td style="text-align:left;"> 很不幸的是在应用程序侧是无法搞定这个问题的。唯一的可能就是联系对应厂商。</td>
</tr>
</tbody>
</table>


<p><br /></p>

<h3>如何调试</h3>

<p>通过查看在Google Play Console和Firebase Crashlytics中的ANR簇标来开始调试。簇集会包含疑似引发ANR的最多的栈帧。</p>

<p><strong>注意：</strong>忽略簇集是&#8221;navivePollOnce&#8221;和&#8221;main thread idle&#8221;的输入派发ANR。这类标志通常是关联着栈帧转储太晚的ANRs，没有可操作的提示所以要忽略掉。一般来说，真正的ANR会在其他簇集里，所以问题并不会被掩盖。详细信息可参见<strong>nativePollOnce部分</strong>。</p>

<blockquote><p><strong>译注：</strong>这篇文档是谷歌官方的，所以它自然会使用谷歌官方的应用后台(Google Play Console)和统计分析(Firebase Crashlytics)工具，对于大部分国内的开发者来说这两个东西可能比较陌生。但没关系，原理是相通的，国内也有很多应用异常统计工具和后台，或者一些本地工具抓取的日志，形式是不限的，只要能收集到类似的栈帧(stack traces)就可以用于分析调试ANR。栈帧(stack frame或者stack trace)就是线程里面的函数调用栈，比如a()->b()->c()->d()这样的函数调用，所有的异常统计工具或者日志工具都能抓取出来某一时刻每个线程的栈帧，这也称之为栈帧转储(stack frame dump)。</p></blockquote>

<p>下面的流程图展示如何确定一个输入派发超时ANR的根因：</p>

<p><img src="https://developer.android.com/static/topic/performance/images/debug-input-dispatch-anr.png" alt="" />
图1. 如何调试一个输入派发无响应ANR</p>

<p>Play vitals能够探测并帮助调试这些常见ANRs原因中的一部分。比如说，如果vitals探测到一个ANR是因为锁竞争，它会总结这些问题并在ANR Insights部分给出建议的修复方法。</p>

<p><img src="https://developer.android.com/static/topic/performance/images/play-vitals-anr-detection.png" alt="" />
图2. Google Play vitals ANR探测</p>

<blockquote><p><strong>译注：</strong>输入派发超时ANR发生的时候应用一定是在前台的，并且用户正在交互。因此重点要看主线程里面的可能的耗时操作，对于系统侧的问题以及关键的生命周期方法则一般不太相干，因为这时生命周期一般都走完了，处理常规的交互阶段。</p></blockquote>

<h2>找不到有焦点的窗口(No focused window)</h2>

<p>像触摸等的事件通过命中测试后会直接发送到相关窗口，而像硬件按键事件则需要一个目标（窗口）。这个目标就是指有焦点的窗口。每一个显示器每一时刻只有一个有焦点的窗口，并且常常就是用户当前正在使用的那个。如果找不到有焦点的窗口，输入服务会触发一个&#8221;No focused window ANR&#8221;。找不到焦点窗口ANR是输入派发无响应中的一种。</p>

<p><strong>默认超时时间：5秒。</strong></p>

<h3>常见的原因</h3>

<p>无焦点窗口ANRs通常由以下原因导致：</p>

<ul>
<li>应用启动做了太多耗时操作，还没有渲染出来第一帧。</li>
<li>应用的主窗口无法获取焦点。如果一个窗口被使用了标志位<a href="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams#FLAG_NOT_FOCUSABLE">FLAG_NOT_FOCUSABLE</a>，那么用户 就无法发送按键事件或者触摸事件到这个窗口上面。</li>
</ul>


<pre><code class="Kotlin">override fun onCreate(savedInstanceState: Bundle) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)
    window.addFlags(WindowManager.LayoutParams.FLAG_FLAG_NOT_FOCUSABLE)
}
</code></pre>

<blockquote><p><strong>译注：</strong>No focused window说明应用应在前台而未在前台，或者不应该在前台而在前台，这类ANR最容易发生在生命周期方法执行太慢导致input与window焦点状态不同步导致的。所以重点要看应用的关键生命周期回调方法是否有耗时操作，比如onCreate()/onDestroy()，onStart()/onStop()，以及特别的onResume()/onPause()。可以与上面的输入派发超时进行对比，可以发现这两类ANR分析的侧重点并不一样。</p></blockquote>

<h2>广播接收器超时(Broadcast receiver timeout)</h2>

<p>广播接收器ANR发生在当一个广播接收器无法及时的响应一个广播。对于一个同步的接收器，或者没有调用<a href="https://developer.android.com/reference/android/content/BroadcastReceiver#goAsync(">goAsync</a>)的receivers，超时的意思是<a href="https://developer.android.com/reference/android/content/BroadcastReceiver#onReceive(android.content.Context,%20android.content.Intent">onReceive()</a>)方法未能及时的执行完。对于异步接收器，或者调用了goAsync的receivers，超时的意思是<a href="https://developer.android.com/reference/kotlin/android/content/BroadcastReceiver.PendingResult#finish">PendingResult.finish</a>未能及时的被调用。</p>

<p>广播接收器ANRs经常发生在这些线程中：</p>

<ul>
<li>主线程，问题会是应用启动太慢</li>
<li>运行broadcast receiver的线程，问题会是onReceive执行太慢</li>
<li>广播的后台线程，问题会是执行goAsync的代码太耗时了</li>
</ul>


<p>遵循这些最佳实践来避免广播接收器ANRs：</p>

<ul>
<li>保证快速应用启动，因为应用启动时间也会被计算在ANR的超时时间里，如果应用是被唤醒来处理广播。</li>
<li>如果使用了goAsync，要确保PengingResult.finish早点被调用。这跟同步receivers一样都受超时时间影响。</li>
<li>如果使用了goAsync，要确保工作线程没有开启耗时操作或者阻塞性的操作。</li>
<li>考虑在非主线程里面调用<a href="https://developer.android.google.cn/reference/android/content/Context#registerReceiver(android.content.BroadcastReceiver,%20android.content.IntentFilter">registerReceiver</a>)以免阻塞主线程中的代码执行。（这里的意思是要为广播提供一个非主线程的Handler，这是广播处理回调onReceiver运行的线程。如不提供Handler将会在主线程中运行 &mdash;译注）</li>
</ul>


<blockquote><p><strong>译注：</strong>广播接收器是一个独立的组件，用于任何时候接收广播事件并进行处理，包括应用还未运行时。因此，如果应用还未有运行，那么要响应广播，必须先把应用唤起(创建进程，并创建Application实例)，然后才能创建receiver实例来处理广播。所以应用冷启动时间是会被计算在超时时限内的，从而慢的冷启动肯定会影响广播处理。通常开发者都会只关注应用启动后的情况，比如渲染性能或者用户体验，会忽略其他组件如BroadcastReceiver，Service以及ContentProvider是与Activity一样的平台级别的组件，它们都能单独的运行，但它们毕竟都是在同一个应用里面，要运行在同一进程和同一个Application实例下面，所以在运行这些组件前AMS是需要先唤起应用，应用的启动会影响着所有的四大组件。另外要注意，尽管可以用&#8221;android:process&#8221;给组件(通常是给Service和ContentProvider)指定单独的进程，但冷启动的影响也是存在的，同样需要创建进程和Application实例，并且其实主进程也是被会唤起的。</p></blockquote>

<h3>超时时限(Broadcast receiver timeout)</h3>

<p>广播接收超时时限取决于前台Intent标志是否启用以及系统平台的版本：</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> Intent类型 </th>
<th style="text-align:left;"> Android 13以及更低版本 </th>
<th style="text-align:left;"> Android 14及更高的版本 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 优先级是前台的Intent(启用了FLAG_RECEIVER_FOREGROUND) </td>
<td style="text-align:left;"> 10秒 </td>
<td style="text-align:left;"> 10~20秒，取决于进程是否是CPU挨饿 </td>
</tr>
<tr>
<td style="text-align:left;"> 优先级是后台Intent(未启用FLAG_RECEIVER_FOREGROUND) </td>
<td style="text-align:left;"> 60秒 </td>
<td style="text-align:left;"> 60~120秒，取决于进程是否是CPU挨饿 </td>
</tr>
</tbody>
</table>


<p>想要知道是否启用了FLAG_RECEIVER_FOREGROUND，可以通过在ANR标题中寻找&#8221;flg=&ldquo;然后查看是否存在<strong>0x10000000</strong>。如果这他二进制位是1就说明前台标志被启用了。</p>

<p>受制于短时广播超时时间(10~20秒)的标题例子：</p>

<pre><code class="bash">Broadcast of Intent { act=android.inent.action.SCREEN_ON flg=0x50200010 }
</code></pre>

<p>受制于长广播超时(60~120秒)的标题例子:</p>

<pre><code class="bash">Broadcast of Intent { act=android.intent.action.TIME_SET flg=0x25200010 }
</code></pre>

<h3>广播的超时时间是如何计算的</h3>

<p>广播耗时时长测量从system_server把广播派发给应用时开始，到当应用完成广播的处理时结束。如果应用程序的进程没在运行，还需要把应用冷启动时间计算在ANR的超时时间里面。因此，缓慢的应用启动也可能会导致广播接收超时ANR。</p>

<p>下面这张图展示了广播接收器的时间线与应用进程的对齐关系：</p>

<p><img src="https://developer.android.com/static/topic/performance/images/broadcast-receiver-anr-timeline.png" alt="" />
图3. 广播接收器时间线</p>

<p>ANR超时时间测量当接收器处理完广播时就结束，具体这个什么时候算结束取决于是同步接收器还是异步接收器：</p>

<ul>
<li>对于同步接收器，当onReceive方法返回时测量就结束了。</li>
<li>对于异步接收器，当PendingResult.finish被调用时就结束。</li>
</ul>


<p><img src="https://developer.android.com/static/topic/performance/images/sync-async-measurement-end.png" alt="" />
图4. 同步接收器和异步接收器的ANR超时测量结束时间点</p>

<h3>常见的根因</h3>

<p>这里列出广播接收超时ANR的一些常见根因以及修复建议。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 根因 </th>
<th style="text-align:left;"> 适用于 </th>
<th style="text-align:left;"> 表象 </th>
<th style="text-align:left;"> 建议的修复方式 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 缓慢的应用启动 </td>
<td style="text-align:left;"> 所有接收器 </td>
<td style="text-align:left;"> 应用在冷启动耗时太多 </td>
<td style="text-align:left;"> 优化应用的冷启动 </td>
</tr>
<tr>
<td style="text-align:left;"> onReceive未被调度 </td>
<td style="text-align:left;"> 所有接收器 </td>
<td style="text-align:left;"> 广播接收器线程正忙于其他操作无法执行onReceive </td>
<td style="text-align:left;"> 不要在接收器的线程里面做长时间的耗时操作(放到其他工作线程里去) </td>
</tr>
<tr>
<td style="text-align:left;"> 缓慢的onReceive </td>
<td style="text-align:left;"> 所有的接收器，主要是同步接收器 </td>
<td style="text-align:left;"> 开始执行onReceive了，但因为被阻塞了或者执行的太慢，无法及时的完成并返回 </td>
<td style="text-align:left;"> 优化缓慢的onReceive代码 </td>
</tr>
<tr>
<td style="text-align:left;"> 异步接收器未被调度 </td>
<td style="text-align:left;"> goAsync()接收器 </td>
<td style="text-align:left;"> onReceive要在一个被阻塞的工作线程池中执行，所以始终得不到执行 </td>
<td style="text-align:left;"> 优化阻塞的代码或者binder call，或者用不同的线程来当作广播的工作线程 </td>
</tr>
<tr>
<td style="text-align:left;"> 工作线程太慢或者被阻塞 </td>
<td style="text-align:left;"> goAsync()接收器 </td>
<td style="text-align:left;"> 当处理广播时，在工作线程池中有耗时操作或者阻塞代码。因此，PendingResult.finish()无法及时被调用 </td>
<td style="text-align:left;"> 优化缓慢的异步接收器代码 </td>
</tr>
<tr>
<td style="text-align:left;"> 忘记调用PendingResult.finish() </td>
<td style="text-align:left;"> goAsync()接收器 </td>
<td style="text-align:left;"> 代码的逻辑中没有调用finish() </td>
<td style="text-align:left;"> 保证finish()被调用到 </td>
</tr>
</tbody>
</table>


<p><br /></p>

<h3>如何调试</h3>

<p>基于簇集标签(cluster signature)和ANR报告，可以定位到广播接收器运行的线程，然后再定位到未执行的代码或者运行缓慢的代码。</p>

<blockquote><p><strong>注意：</strong>不要忽略&#8221;nativePollOnce&#8221;或者&#8221;main thread idle&#8221;的簇集标签。Google Play Console和Firebase Crashlytics的ANR标签里面的栈帧通常都是从主线程中获取生成的。但是，广播接收器可能运行在非主线程或者调用了goAsync()（也即转成了异步接收器&mdash;译注）。因此，这些簇集标签仍然有实际价值，可以查看一下栈帧里面的相关线程。</p></blockquote>

<p>下面的流程图展示了如何确定一个广播接收超时ANR的根因：</p>

<p><img src="https://developer.android.com/static/topic/performance/images/debug-broadcast-receiver-timeout-anr.png" alt="" />
图5. 如何调试一个广播超时ANR</p>

<h3>找到接收器的代码</h3>

<p>Google Play Console会在ANR簇集标签里面显示接收器的类名和广播Intent。寻找以下信息：</p>

<ul>
<li>cmp=&lt;receiver class&gt;</li>
<li>act=&lt;broadcast_intent&gt;</li>
</ul>


<p>这里是一个广播超时ANR标签的例子：</p>

<pre><code class="bash">com.example.app.MyClass.myMethod
Broadcast of Intent { act=android.accounts.LOGIN_ACCOUNTS_CHANGED
cmp=com.example.app/com.example.app.MyAccountReceiver }
</code></pre>

<h3>寻找运行onReceive方法的线程</h3>

<p>如果使用Context.registerReceiver()时指定了自定义的handler，那就会运行在此handler所依附的线程里。此外，就是在主线程里。</p>

<h3>实例：异步接收器未被调度</h3>

<p>这部分将逐步的演示如何调试一个广播接收超时ANR。</p>

<p>比如说ANR标签是像酱紫的：</p>

<pre><code class="bash">com.example.app.MyClass.myMethod
Broadcast of Intent {
act=android.accounts.LOG_ACCOUNTS_CHANGED cmp=com.example.app/com.example.app.MyReceiver }
</code></pre>

<p>从标签中可以看出，广播intent是android.accounts.LOG_ACCOUNTS_CHANGED，接收器类型是com.example.app.MyReceiver。</p>

<p>从接收器的代码，可以发现线程池&#8221;BG Thread [0,1,2,3]&ldquo;在主要负责处理这个广播。查看栈帧，可以发现所有四个后台线程(background threads)的模式是一样的：它们都执行了一个阻塞式的调用getDataSync。因为所有的后台线程都被占用着，这个广播无法被及时处理，最后发生了ANR。</p>

<pre><code class="bash">BG Thread #0 (tid=26) Waiting

at jdk.internal.misc.Unsafe.park(Native method:0)
at java.util.concurrent.locks.LockSupport.park(LockSupport.java:211)
at com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture:563)
at com.google.common.util.concurrent.ForwardingFuture.get(ForwardingFuture:68)
at com.example.app.getDataSync(&lt;MyClass&gt;:152)

...

at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:644)
at com.google.android.libraries.concurrent.AndroidExecutorsModule.lambda$withStrictMode$5(AndroidExecutorsModule:451)
at com.google.android.libraries.concurrent.AndroidExecutorsModule$$ExternalSyntheticLambda8.run(AndroidExecutorsModule:1)
at java.lang.Thread.run(Thread.java:1012)
at com.google.android.libraries.concurrent.ManagedPriorityThread.run(ManagedPriorityThread:34)
</code></pre>

<p>有几种方法可以修复这个问题：</p>

<ul>
<li>查出为何getDataSync会如此之慢，然后优化</li>
<li>不要在四后台线程中都执行getDataSync</li>
<li>更为通用的做法是，保证后台线程池中不要执行长时间的耗时操作</li>
<li>为goAsync任务设计一个专用线程池</li>
<li>使用一个无数量限制的线程池，而不是限量为4的后台线程池</li>
</ul>


<h3>实例：应用启动缓慢</h3>

<p>应用启动缓慢可能会导致几个不同类型的ANR，以广播接收超时ANR和执行服务超时ANR最为显著。如果你在主线程的帧中看到了ActivityThread.handleBindApplication，那么这个ANR的根因很有可能就是启动慢造成的。</p>

<blockquote><p><strong>译注：</strong>四大组件(Activity, Service, BroadcastReceiver和ContentProvidier)都是平台能直接识别的组件，均可由AMS直接启动运行，但它们都是应用的一部分，如果应用尚未运行，那么AMS必须先要创建进程，并创建Application实例，这都需要花费时间，会耗费更久，甚至引发ANR，如果冷启动过程中有耗时操作。所以优化应用启动是性能优化的基石。</p></blockquote>

<h2>执行服务超时(Exceute service timeout)</h2>

<p>当应用程序的主线程无法及时的启动一个Service时就会发生执行服务超时ANR。具体来说，就是一个服务无法在一定时限范围内完成onCreate()或者onStartCommand()或者onBind()的执行。</p>

<p><strong>默认超时时间：</strong>前台服务(Foreground Service)是20秒; 后台服务(Background Service)是200秒。ANR超时时间包括应用冷启动，以及onCreate()，onBind()和onStartCommand的调用。</p>

<p>遵循如下最佳实战来规避执行服务ANR：</p>

<ul>
<li>确保应用启动很快，因为如果一个应用被唤起来运行服务组件，启动时间也会被计算在超时时间内。</li>
<li>确保服务的onCreate()，onBind()和onStartCommand()执行的都很快。</li>
<li>不要在主线程里执行来自其他组件的耗时操作或者阻塞式操作，这些操作会阻碍服务的快速启动。</li>
</ul>


<h3>常见的根因</h3>

<p>下表列出执行服务超时ANR的常见根因和修复建议：。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 根因 </th>
<th style="text-align:left;"> 表象 </th>
<th style="text-align:left;"> 建议的修复 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 缓慢的应用启动 </td>
<td style="text-align:left;"> 应用冷启动时间过长 </td>
<td style="text-align:left;"> 优化应用启动速度 </td>
</tr>
<tr>
<td style="text-align:left;"> 缓慢的onCreate()，onStartCommand和onBind </td>
<td style="text-align:left;"> 服务组件的onCreate()，onStartCommand()和onBind()在主线程执行了耗时操作 </td>
<td style="text-align:left;"> 优化代码，或者把耗时操作从这些关键的方法中移出去 </td>
</tr>
<tr>
<td style="text-align:left;"> 未被调度(在执行onStart()之前主线程就被阻塞了) </td>
<td style="text-align:left;"> 在服务启动之前，主线程就被其他组件级阻塞了 </td>
<td style="text-align:left;"> 把其他组件的工作移出主线程。优化其他组件的阻塞代码 </td>
</tr>
</tbody>
</table>


<p><br /></p>

<h3>如何调试</h3>

<p>从Google Play Console和Firebase Crashlytics中的簇集标签和ANR报告，基于主线程当时的运行状态，通常就能确定ANR的根因。</p>

<p><strong>注意：</strong>忽略标签是&#8221;nativePollOnce&#8221;和&#8221;main thread idle&#8221;的执行服务ANR簇集。这些簇集通常是栈帧捕获的太晚，无实际参考意义。真实的ANR栈帧可能会在其他的簇集里，所以问题并不会被掩藏。详细参见nativePollOnce部分。</p>

<p>下面的流程图描述了如何调试一个执行服务超时ANR。</p>

<p><img src="https://developer.android.com/static/topic/performance/images/debug-execute-service-anr.png" alt="" />
图6. 如何调试一个执行服务ANR</p>

<p>如果发现某个执行报务ANR是有实际操作意义的，遵循以下步骤来解决问题：</p>

<ol>
<li>找到ANR簇集标签中的服务组件。在Google Play Console里，服务组件类型会显示在ANR标签里。在后面的这个例子里，类型就是com.example.app/MyService。</li>
</ol>


<pre><code class="bash">com.google.common.util.concurrent.Uninterruptibles.awaitUninterruptibly
Executing service com.example.app/com.example.app.MyService
</code></pre>

<ol>
<li>确定应用启动过程中，服务组件或者其他地方是否有耗时或者阻塞操作，通过检查主线程中的下面这些重要的方法调用</li>
</ol>


<table>
<thead>
<tr>
<th style="text-align:left;"> 主线程栈帧中的方法调用 </th>
<th style="text-align:left;"> 背后的含义 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> android.app.ActivityThread.handleBindApplication </td>
<td style="text-align:left;"> 应用正在启动，ANR由启动太慢引起 </td>
</tr>
<tr>
<td style="text-align:left;"> <ServiceClass>.onCreate()<br/>[&hellip;.]<br/>android.app.ActivityThread.handleCreateService </td>
<td style="text-align:left;"> 服务正在被创建中，所以ANR是由缓慢的onCreate()引起的 </td>
</tr>
<tr>
<td style="text-align:left;"> <ServiceClass>.onBind()<br/>[&hellip;.]<br/>android.app.ActivityThread.handleBindService </td>
<td style="text-align:left;"> 服务正在被绑定中，所以ANR是由缓慢的onBind()引起的 </td>
</tr>
<tr>
<td style="text-align:left;"> <ServiceClass>.onStartCommand()<br/>[&hellip;.]<br/>android.app.ActivityThread.handleServiceArgs </td>
<td style="text-align:left;"> 服务正在被启动中，所以ANR是由缓慢的onStartCommand()引起的 </td>
</tr>
</tbody>
</table>


<p><br />
举个粟子，如果在类MyService里的onStartCommand执行缓慢，主线程栈帧会像酱婶儿的：</p>

<pre><code class="bash">at com.example.app.MyService.onStartCommand(FooService.java:25)
at android.app.ActivityThread.handleServiceArgs(ActivityThread.java:4820)
at android.app.ActivityThread.-$$Nest$mhandleServiceArgs(unavailable:0)
at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2289)
at android.os.Handler.dispatchMessage(Handler.java:106)
at android.os.Looper.loopOnce(Looper.java:205)
at android.os.Looper.loop(Looper.java:294)
at android.app.ActivityThread.main(ActivityThread.java:8176)
at java.lang.reflect.Method.invoke(Native method:0)
</code></pre>

<p>如果没有发现重要的方法调用，还有其他一些可能：</p>

<ul>
<li> 服务正在运行或者在关闭中，意思是说栈帧捕获的太晚了，可以忽略此类ANR或者视为假阳性。</li>
<li><p> 另外一个组件正在运行，比如广播接收器。这种情况下主线程可能被这个组件阻塞着，导致服务无法启动。</p></li>
<li><p>如果能看到关键的方法 调用并确定ANR发生的地点，检查主线程的栈帧以找到缓慢的操作并把它们从关键的方法中移出去。</p></li>
</ul>


<p>关于服务的更多信息，可以看下面这些链接：</p>

<ul>
<li><a href="https://developer.android.com/guide/components/services">服务概览</a></li>
<li><a href="https://developer.android.com/guide/components/foreground-services">前台服务</a></li>
<li><a href="https://developer.android.com/reference/android/app/Service">服务</a></li>
</ul>


<h2>内容提供程序无响应(Content Provider not responding)</h2>

<p>当一个远端内内容提供程序响应查询(query)时花费超过时限，内容提供程序ANR就会发生，且会被杀掉。</p>

<p><strong>默认超时时间：</strong>内容提供程序通过ContentProviderClient.setDetectNotResponding指定的。ANR超时时限包括远端内容提供程序执行查询的时间，以及如果远端应用还未启还包括它的冷启动时间，加在一起的总时间。</p>

<p>遵循下面这些最佳实践来规避内容提供程序ANR：</p>

<ul>
<li>确保应用启动很快，因为如果应用未运行时会被唤起，冷启动时间也会被计算在超时时间内。</li>
<li>确保内容提供程序的查询能很快执行完。</li>
<li>不要执行大量的并发阻塞式的binder call，因为这会阻塞应用的所有的binder线程。</li>
</ul>


<blockquote><p><strong>译注：</strong><a href="https://developer.android.com/reference/android/content/ContentProvider">内容提供程序Content provider</a>都是要经过跨进程调用(binder call)，尽管可能并没有真正的在另外一个进程里。因为我们使用<a href="https://developer.android.com/guide/topics/providers/content-provider-basics">ContentProvider</a>的时候都是通过另一个API ContentResolver来完成，而ContentResolver是通过binder call来与ContentProvider通信的，无论是否真的跨进程。所以，ContentProvider就像一个服务器一样是远端的一侧提供内容，而应用程序(使用者)是客户端一侧需要内容。内容提供程序可能同时服务着不同的客户请求，比如像系统通用的内容提供程序ContactsProvider或者MediaProvider可能同时会有大量的应用请求查询，每一个请求都需要执行binder call，因此内容提供程序可能会同时执行着大量的binder call(它需要查询结果，并把结果以binder call的形式返回给请求方)。所以对于内容提供程序来说，查看binder call的运行状态对于解决ANR问题以及排查性能问题都是非常有帮助的。</p></blockquote>

<h3>常见根因</h3>

<p>下表列出了内容提供程序ANR的常见根因和修复建议。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 根因 </th>
<th style="text-align:left;"> 表象 </th>
<th style="text-align:left;"> 信号 </th>
<th style="text-align:left;"> 建议的修复方式 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 缓慢的查询 </td>
<td style="text-align:left;"> 内容提供程序执行耗时太长或者被阻塞 </td>
<td style="text-align:left;"> binder线程里有android.content.ContentProvider\$Transport.query栈帧 </td>
<td style="text-align:left;"> 优化查询或者查出什么东西在阻塞着binder线程 </td>
</tr>
<tr>
<td style="text-align:left;"> 应用启动太慢 </td>
<td style="text-align:left;"> 内容提供程序启动耗时太久 </td>
<td style="text-align:left;"> 主线程里有ActivityThread.handleBindApplication栈帧 </td>
<td style="text-align:left;"> 优化应用启动 </td>
</tr>
<tr>
<td style="text-align:left;"> Binder线程耗尽了，所有的binder线程都被占用着 </td>
<td style="text-align:left;"> 所有的binder线程都被占用着服务着其他的同步请求，因此内容提供程序binder调用无法执行 </td>
<td style="text-align:left;"> 应用未启动起来，所有的binder线程都被占用，内容提供程序也未能启动起来 </td>
<td style="text-align:left;"> 减小binder线程的负载。也就是说执行更少一些的外发同步binder调用或者在处理到来的调用时少做一些操作。</td>
</tr>
</tbody>
</table>


<p><br /></p>

<h3>如何调试</h3>

<p>要想调试一个内容提供程序ANR，使用Google Play Console或者Firebase Crashlytics中的簇集标签和ANR报告，并用来查看主线程以及binder线程都在做什么。</p>

<p>下面的流程图描述如何调试一个内容提供程序ANR：</p>

<p><img src="https://developer.android.com/static/topic/performance/images/debug-content-provider-anr.png" alt="" />
图7.如何调试一个内容提供程序ANR</p>

<p>下面的代码块展示了当被一个缓慢的内容提供程序查询阻塞时，binder线程的状态。在这个例子里，内容提供程序的查询正在等待一个打开数据库的锁。</p>

<pre><code class="bash">binder:11300_2 (tid=13) Blocked

Waiting for osm (0x01ab5df9) held by at com.google.common.base.Suppliers$NonSerializableMemoizingSupplier.get(Suppliers:182)
at com.example.app.MyClass.blockingGetOpenDatabase(FooClass:171)
[...]
at com.example.app.MyContentProvider.query(MyContentProvider.java:915)
at android.content.ContentProvider$Transport.query(ContentProvider.java:292)
at android.content.ContentProviderNative.onTransact(ContentProviderNative.java:107)
at android.os.Binder.execTransactInternal(Binder.java:1339)
at android.os.Binder.execTransact(Binder.java:1275)
</code></pre>

<p>下面的代码块展示了当被缓慢的应用启动阻塞时，binder线程的状态。在这个例子里，应用启动因为dagger初始化时的锁竞争而变得很慢。</p>

<pre><code class="bash">main (tid=1) Blocked

[...]
at dagger.internal.DoubleCheck.get(DoubleCheck:51)
- locked 0x0e33cd2c (a qsn)at dagger.internal.SetFactory.get(SetFactory:126)
at com.myapp.Bar_Factory.get(Bar_Factory:38)
[...]
at com.example.app.MyApplication.onCreate(DocsApplication:203)
at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1316)
at android.app.ActivityThread.handleBindApplication(ActivityThread.java:6991)
at android.app.ActivityThread.-$$Nest$mhandleBindApplication(unavailable:0)
at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2235)
at android.os.Handler.dispatchMessage(Handler.java:106)
at android.os.Looper.loopOnce(Looper.java:205)
at android.os.Looper.loop(Looper.java:294)
at android.app.ActivityThread.main(ActivityThread.java:8170)
at java.lang.reflect.Method.invoke(Native method:0)
at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:552)
at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:971)
</code></pre>

<h2>缓慢的作业响应(Slow job response)</h2>

<p>当应用响应JobService.onStartJob()或者JobService.onStopJob耗时太久，或者用JobService.setNotification()提供通知时耗时太久，都会引发缓慢的作业响应ANR发生。这说明应用的主线程因为其他操作而被阻塞了。</p>

<p>如果问题是与JobService.onStartJob()或者JobService.onStopJob()有关系，就要检查下主线程的情况。如果问题与JobService.setNotification()有关系，要保证它尽可能的快速的被调用到。在提供通知之前 不要做很多其他事情。</p>

<blockquote><p><strong>译注：</strong><a href="https://developer.android.com/reference/android/app/job/JobService">JobService</a>是Android 5.0 API 21时增加的一个专门用于后台作业的一个Service的子类。上面提到的是都是它的一些回调，与一些其他的回调类似，这些回调必须快速执行完毕，因为<a href="https://developer.android.com/reference/android/app/job/JobScheduler">JobSchedule</a>内部需要做一些资源回收之类的工作，所以这些回调不允许被阻塞。</p></blockquote>

<h2>隐秘的ANRs</h2>

<p>有时候搞不清楚为啥ANR会发生，或者在簇集标签和ANR报告中找不到足够的信息去调试。遇到这些情况，还是可以采取一些步骤以确定这些ANR是否是值得处理的。</p>

<h3>消息队列是空闲(Message queue idle)的或者正处理轮询中(nativePollOnce)</h3>

<p>如果你在栈帧信息中发现android.os.MessageQueue.nativePollOnce，这通常说明疑似无响应的线程实际上是空闲的或者在等待队列中的消息。在Google Play Console里面，ANR的细节是酱紫的：</p>

<pre><code class="bash">Native method - android.os.MessageQueue.nativePollOnce
Executing service com.example.app/com.example.app.MyService
</code></pre>

<p>举个粟子，如果主线程是空闲的，栈帧是酱紫的：</p>

<pre><code class="bash">"main" tid=1 NativeMain threadIdle

#00  pc 0x00000000000d8b38  /apex/com.android.runtime/lib64/bionic/libc.so (__epoll_pwait+8)
#01  pc 0x0000000000019d88  /system/lib64/libutils.so (android::Looper::pollInner(int)+184)
#02  pc 0x0000000000019c68  /system/lib64/libutils.so (android::Looper::pollOnce(int, int*, int*, void**)+112)
#03  pc 0x000000000011409c  /system/lib64/libandroid_runtime.so (android::android_os_MessageQueue_nativePollOnce(_JNIEnv*, _jobject*, long, int)+44)
at android.os.MessageQueue.nativePollOnce (Native method)
at android.os.MessageQueue.next (MessageQueue.java:339)  at android.os.Looper.loop (Looper.java:208)
at android.app.ActivityThread.main (ActivityThread.java:8192)
at java.lang.reflect.Method.invoke (Native method)
at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run (RuntimeInit.java:626)
at com.android.internal.os.ZygoteInit.main (ZygoteInit.java:1015)
</code></pre>

<p>疑似无响应线程可能是空闲的会有几个原因：</p>

<ul>
<li>延迟的栈转储：在ANR被 触发和栈帧转储之间的短时间内，线程状态恢复了。在Android 13版本的Pixels设备上这个延迟大约在100ms，但也可能超过1秒。Android 14版本的Pixels设备上这个延迟小于10ms。</li>
<li>线程归因错误：用于构建ANR标签的线程并不是实际上触发ANR的无响应线程。这种情况下，尝试确定一下这个ANR是否是如下的类型：

<ul>
<li>广播接收超时</li>
<li>内容提供程序无响应</li>
<li>找不到带焦点的窗口</li>
<li>系统侧问题：由于系统负载太重或者系统服务有问题而导致应用进程无法被调度。</li>
</ul>
</li>
</ul>


<h3>没有栈帧(No stack frames)</h3>

<p>有一些ANR报告里面没有包含与ANR相关的栈帧，这说明在生成ANR报告时栈帧转储失败了。有很多可能的原因会导致栈帧丢失：</p>

<ul>
<li>转储栈帧太耗时了，所以超时了</li>
<li>在栈帧转储完成之前进程就挂了或者被杀掉了</li>
</ul>


<pre><code class="bash">[...]

--- CriticalEventLog ---
capacity: 20
timestamp_ms: 1666030897753
window_ms: 300000

libdebuggerd_client: failed to read status response from tombstoned: timeout reached?

----- Waiting Channels: pid 7068 at 2022-10-18 02:21:37.&lt;US_SOCIAL_SECURITY_NUMBER&gt;+0800 -----

[...]
</code></pre>

<p>簇集标签或者ANR报告里面没有栈帧的ANR是没有实际分析意义的。如果要调试，可以去看其他的簇集信息，因为如果一个问题足够明显的话，那么它通常会有它自己的簇集标签存在。其他的可行方案就是查看<a href="https://perfetto.dev/docs/">Perfetto traces</a>.</p>

<h2>已知问题(Known issues)</h2>

<p>在应用的进程里用计时器来测量广播的处理时间或者ANR的触发是行不通的，因为系统是以异步的方式在监控着ANR。</p>

<blockquote><p><strong>译注：</strong>这里的意思是不要想着取巧，应用开发者的重点应该放在你的业务逻辑和性能优化上面，借助平台提供的工具和方法来优化应用的代码逻辑。而像尝试在应用侧自己统计超时这种事情是行不通的，因为系统以比较复杂的异步的方式在统计着超时，应用侧不可能做到与系统侧一样的测量方法，所以自己的统计就变得毫无意义（要么不可行，要么不准确）。还是老老实实的优化好自己的代码吧。</p></blockquote>

<h2>更多的官方资料</h2>

<ul>
<li><a href="https://developer.android.com/topic/performance/anrs/find-unresponsive-thread">Find the unresponsive thread</a></li>
<li><a href="https://developer.android.com/topic/performance/anrs/keep-your-app-responsive">Keep your app responsive</a></li>
<li><a href="https://developer.android.com/guide/topics/resources/layout-resource">Layout resource</a></li>
<li><a href="https://developer.android.com/topic/performance/vitals/anr">ANRs</a></li>
</ul>


<h2>其他优质博文</h2>

<ul>
<li><a href="https://juejin.cn/post/7181731795439157306">钉钉 ANR 治理最佳实践 | 定位 ANR 不再雾里看花</a></li>
<li><a href="https://juejin.cn/post/6940061649348853796">今日头条 ANR 优化实践系列 - 设计原理及影响因素</a></li>
<li><a href="https://juejin.cn/post/7053819042268151838">Android ANR全解析&amp;华为AGC性能管理解决ANR案例集</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
