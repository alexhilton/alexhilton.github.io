<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2024-05-15T20:37:15+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『亢龙有悔』]]></title>
    <link href="http://toughcoder.net/blog/2024/05/15/compose-made-easy/"/>
    <updated>2024-05-15T20:26:06+08:00</updated>
    <id>http://toughcoder.net/blog/2024/05/15/compose-made-easy</id>
    <content type="html"><![CDATA[<p><a href="https://developer.android.com/develop/ui/compose">Jetpack Compose</a>是新一代的声明式的UI开发框架，由Google在2019年推出，最初是作为Android的新式UI开发框架，但它本质是一个声明式UI开发框架，并不受制于底层的平台，现在的Compose已有跨平台开发能力，但Android上的UI开发仍是最主要的使用领域，深受Android开发者喜爱。计划将用一系列文章，并开辟专栏来学习Compose，此为开篇。</p>

<p><a href=""><img src="https://alexzh.com/content/images/2021/02/logo-1.65-1980-compressed-4.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>注意：最初是叫做Jetpack Compose，作为Jetpack套件中的一个，后来与Jetpack独立开来了，现在Compose发展成为一个独立的声明式的UI开发框架，与Jetpack中其他组件并不是同一个概念，也并不在Jetpack套件里面。所以现在更多的称为Compose，为了方便后续统一称为Compose。</p>

<h2>Hello, Compose!</h2>

<p>老规矩，先来个简单的『Hello, world!』，以快速上手体验：</p>

<p>首先，用Android Studio创建一个新的项目，选择『Phone and Tablet』，选择『Empty Activity』，然后Next。</p>

<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2dff3493d9284e2095db9f71ba0242aa~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp" alt="create project" /></p>

<p>在项目配置页面填入项目名字和包名等信息，其余的用默认就好。</p>

<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/397cf1dff8714d8bb6c917fda5db3e3b~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2258&amp;h=1678&amp;s=261564&amp;e=png&amp;b=3d4042" alt="config project" /></p>

<p>等一会儿后，项目就创建好了，与常规的Android项目一样的，也有AndroidManifest，是项目运行时的主要配置，以及一个系统组件MainActivity作为入口。打开MainActivity.kt，可以发现里面已经默认用了Compose，并且有东西，我们稍改一下，改成下面的样子：</p>

<pre><code class="Kotlin">class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            HelloComposeTheme {
                // A surface container using the 'background' color from the theme
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    Greeting("Android with Compose!")
                }
            }
        }
    }
}

@Composable
fun Greeting(name: String, modifier: Modifier = Modifier) {
    Text(
        text = "Hello, $name",
        modifier = modifier
    )
}

@Preview(showBackground = true)
@Composable
fun GreetingPreview() {
    HelloComposeTheme {
        Greeting("Android")
    }
}
</code></pre>

<p>然后构建并运行项目，就能得到一个『Hello, Android with Compose!』：</p>

<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aaade0cd297e42a6a3e1ea80cd877a5c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1220&amp;h=2712&amp;s=41531&amp;e=png&amp;b=fefbff" alt="HelloCompose" /></p>

<p>样子略丑，我们来优化一下，修改Greeting函数：</p>

<pre><code class="Kotlin">@Composable
fun Greeting(name: String, modifier: Modifier = Modifier) {
    Box(modifier = Modifier.fillMaxSize()) {
        Text(
            text = "Hello, $name",
            modifier = modifier
                .padding(16.dp)
                .align(Alignment.Center),
            style = MaterialTheme.typography.headlineLarge,
            color = MaterialTheme.colorScheme.inverseSurface
        )
    }
}
</code></pre>

<p>这下好了一丢丢！</p>

<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/527d3628ab754a588a37f3bd1affcd7c~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1220&amp;h=2712&amp;s=54613&amp;e=png&amp;b=fefbff" alt="HelloCompose v2" />)</p>

<p>除了在手机或者模拟器运行应用以外，还可以直接用Android Studio进行预览（用&#64;Preview标记的函数才会被预览），不过这不算新功能，因为很久以前打开一个XML文件（如布局），也可以直接在AS里预览的：</p>

<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df948a02f2fe4711a1888525c94ca8d6~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=2660&amp;h=1700&amp;s=430528&amp;e=png&amp;b=2c2c2c" alt="preview" /></p>

<p>好了，现在我们已经成功学会用Compose来撸安卓UI了。如果有时间还可以试试<a href="https://developer.android.com/develop/ui/compose/tutorial">官方的入门Demo</a>。</p>

<p>注意：不同版本的Android Studio可能会略不一样。详见下节『开发环境配置』。</p>

<h2>配置开发环境</h2>

<p>新一点的Android Studio如Giraffe，如果是新建的项目，默认就是用Compose了，不用再怎么搞（如果是上古时代的AS估计还是View的，建议直接升级AS吧都4202年了）。</p>

<p>如果是现有的项目，想要添加Compose支持，可以这样做，先给android的buildFeatures中添加compose为true，并指定kotlin compiler extension的版本，注意这个并不是kotlin的版本，跟它没关系：</p>

<pre><code class="Kotlin">android {
    buildFeatures {
        compose = true
    }

    composeOptions {
        kotlinCompilerExtensionVersion = "1.5.13"
    }
}
</code></pre>

<p>然后再配置一坨依赖：</p>

<pre><code class="Kotlin">dependencies {
    val composeBom = platform("androidx.compose:compose-bom:2024.05.00")
    implementation(composeBom)

    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.ui:ui-graphics")

    // Material Design 3
    implementation("androidx.compose.material3:material3")

    // Android Studio Preview support
    implementation("androidx.compose.ui:ui-tooling-preview")
    debugImplementation("androidx.compose.ui:ui-tooling")
}
</code></pre>

<p>为了方便管理Compose依赖的版本，谷歌搞了一个叫做『物料清单』（Bill of Materials BOM），简单来说就是把Compose所有library的版本放到一个叫做BOM的library中，我们只需要指定一个BOM，这样，就能指定一坨Compose libraries的版本。详细的内容以及困难解决可以<a href="https://developer.android.com/develop/ui/compose/setup#kotlin">参考官方文档</a>。</p>

<h2>理解Compose的基本原理</h2>

<p>从我们的『HelloCompose』中可以看出Compose的特点，它是纯代码，Compose就是一个坨函数声明，不用再撸XML了；它是声明式的，也就是说你只是告诉框架需要什么，期望的样子是什么；它是响应式的，也就是说拿到最新的数据和状态，然后用相应的UI元素进行展示。这与以往用XML写UI是完全不同的，用XML是命令式的，你要拿到View，设置具体的细节。</p>

<p>用Compose撸UI主要分为两部分，一是元素，如布局和具体的渲染元素如文字图片；另一个则是样式控制，所有元素都能接受一个Modifier对象来控制元素的样式，如大小，位置，偏移，对齐等等。会在后面的文章中对这些概念进行详细的讨论。</p>

<p>另外需要注意，Compose就是一坨函数，上面例子中看到的『setContent』，『HelloComposeTheme』，『Suface』，『 Greeting』，『GreetingPreview』，『Box』，『Text』都是函数，虽然它们不符合Kotlin的函数命令规范。这里面套娃式的结构如：</p>

<pre><code class="Kotlin">    setContent {
        HelloComposeTheme {
            // A surface container using the 'background' color from the theme
            Surface(
                modifier = Modifier.fillMaxSize(),
                color = MaterialTheme.colorScheme.background
            ) {
                 Greeting("Android with Compose!")
            }
       }
    }
</code></pre>

<p>是借助于尾部lambda实现的内部DSL，本质上也都是函数调用，视为函数调用就好了。感觉不熟悉的同学可以看看<a href="https://juejin.cn/post/7321550265610108979">前面的文章</a>以加深理解。</p>

<h2>为啥要使用Compose</h2>

<p>就Android开发来说明明已经有比较完善的View和XML来撸UI，为啥还要搞一个Compose呢？</p>

<p>首先，声明式编程范式是最新式的UI构建方式，较原始方式（View和XML）它更加接近于人的思维。开发者只需要告诉架构『我要什么』以及『该如何响应』就可以了，其他事情都交给框架。像Flutter， React， SwiftUI等都是声明式的。一旦我们熟悉了以后，就会发现声明式UI可以极大的提高开发效率，最重要的是它能提高可扩展性（Scalability）。</p>

<p>再有，Compose与各种最新的libraries粘合的特别好，像<a href="https://developer.android.com/jetpack">Jetpack</a>，<a href="https://m3.material.io/">MaterialDesign</a>等等，都可以直接在Compose中使用，非常的方便。</p>

<p>最后，最重要的原因是Google在大力的布道Compose，已经把Compose设置为默认的UI开发方式，作为<a href="https://developer.android.com/modern-android-development">MAD（Modern Android Development）</a>的一块拼盘，新推出的有关于UI的文章都是基于Compose的。并且Google还在不断大力开发Compose，推出新功能以及提升渲染性能。从前面的例子也可以看出，现在默认新建一个项目就是用的Compose，相反，如果想要弄一个只用View的项目，还比较麻烦，要去除一系列配置参数。</p>

<p>作为开发者，肯定要顺应潮流，迎头敢上（对的，是敢而不是赶）。</p>

<h2>迁移建议</h2>

<p>Compose虽然新式且好用，但我们在做迁移的时候要谨慎。对于新的技术（无论是新的编程语言，新的框架，还是新的编程范式）切忌不要一刀切或者搞大跃进。对于，纯新的功能，或者说纯新的项目，当然可以直接就用Compose来开发；但是对于现有的功能，暂时不要去动它，万不可上来就想着用Compose重写一遍。等到对Compose比较熟悉了，人力较富余时，以及现在功能仍会有新的较大的改动时才考虑去重写。对于比较成熟且稳定的功能，建议就不要去折腾它了，因为不会带来价值和收益。</p>

<p><a href="https://developer.android.com/develop/ui/compose/migrate">官方也有迁移建议</a>，可以看一看。</p>

<h2>优质教程与实例</h2>

<p>Google对Compose还是很上心的，写了<a href="https://developer.android.com/develop/ui/compose/documentation">大量的文档</a>，此外还有<a href="https://developer.android.com/courses/jetpack-compose/course">很多教程（CodeLabs）</a>，以及<a href="https://developer.android.com/samples">很多Demo app</a>。并且Compose作为MAD的一块拼盘，也融合进了MAD里面，特别是<a href="https://developer.android.com/develop/ui/compose/architecture">架构层面</a>的文章中用的都是Compose。</p>

<h2>未完，待续</h2>

<p>本文从快速上手的Demo开始，解释一些核心概念，并给出一些有用的资源链接。相信通过此文，能对Compose有一个很好的了解。后续会继续深入探讨各个话题，以练成降Compose十八掌！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实战技巧：Android 14适配从挂号到出院]]></title>
    <link href="http://toughcoder.net/blog/2024/04/23/upgrade-to-targetsdk-34/"/>
    <updated>2024-04-23T21:30:23+08:00</updated>
    <id>http://toughcoder.net/blog/2024/04/23/upgrade-to-targetsdk-34</id>
    <content type="html"><![CDATA[<p>啥？这都4202年了，你的应用还没有升级到targetSDK 34？莫慌，本文就带着你全面的了解升级targetSDK 34的方法以及避坑指南。</p>

<p><a href=""><img src="https://cdn.jsdelivr.net/gh/b0xt/sobyte-images/2022/04/25/1c33d2fabbc44e53b64b6dbbc84fd0ae.png" title="auto auto" ></a></p>

<!-- more -->


<p>注意，<a href="https://apilevels.com/">Android版本与其API level或者targetSDK是一一对应的</a>，只不过一个是外在的说法，一个是具体要做的事情，对于开发者来说适配Android 14，就等同于升级targetSDK到34，这个34称作API level。本文会混着用，但说的都是同一个意思。</p>

<p>等下，有同学举手了，这<a href="https://developer.android.com/about/versions/15">眼看着Android 15（API 35）都</a>要出来，您才教我们升级到targetSDK 34？您 是不是写错了，还是在这里浪费时间呢？</p>

<p>这位同学你先坐下，没写错今天要讲的就是适配Android 14的。至于Android 15还处于预览（Preview）状态呢，它要至少等到10月份左右才会正式发布，属于下半年的KPI了。不过如果 我们把targetSDK 34搞定了，那么年底升级targetSDK 35就会非常的顺畅。</p>

<h2>为啥要升级targetSDK</h2>

<p>在折腾之前要先要搞明白为啥要折腾升级SDK，因为毕竟配置开发环境是软件开发中的排名第二的麻烦事儿（排名第一的是折腾操作系统）项目跑的好好的，何必自找麻烦？</p>

<p>省流点的说，就是你<strong>不得不升级</strong>。众所周知，Android生态最麻烦的事情就是碎片化，也就是用户手机的版本远远小于最新的版本，而且主流的版本升级较慢，通常会比最新的慢3个版本以上，对面的水果则能保持在2个版本以内。这对应用开发生态来说是十分不友好的，因为开发者不愿意升级到最新的SDK，使用平台的最新特性，核心原因在于升级了也没用，因为用户手上的版本仍是3代开外的。</p>

<ul>
<li><a href="https://www.composables.com/tools/distribution-chart">Android Distribution Chart</a></li>
<li><a href="https://developer.android.com/about/dashboards">Distribution dashboard</a></li>
<li><a href="https://gs.statcounter.com/android-version-market-share/mobile/worldwide/">Mobile Android Version Market Share Worldwide</a></li>
</ul>


<p>最心急的当然是谷歌，辛苦花大价钱开发的最新特性竟然没人用，这能忍？于是谷歌对<a href="https://developer.android.com/google/play/requirements/target-sdk">升级targetSDK要求</a>越来越严，对于<strong>谷歌能管得到的地方</strong>，如<a href="https://developer.android.com/distribute/console">Google Play Store</a>和厂商的<a href="https://source.android.com/docs/security/safety-center/test-requirements">GTS测试</a>，都要求至少升级targetSDK到前一代的版本，比如2023年发布了Android 14，那就必须到targetSDK 33（Android 13）；今年将发布Android 15（API 35）那到快要发布时约在2024年秋，应用必须升级到targetSDK 34。</p>

<p>如果不是强制要求升级targetSDK，比如我既不上线到Play Store也不用过GTS，那确实也没必要折腾。因为最近几年Android的新特性其实也都挺鸡肋的，犯不着折腾。</p>

<h2>Android 14的新特性与变化</h2>

<p>具体折腾前还是要先了解一下平台的变化，以评估影响，省流点说，Android 14有以下变化：</p>

<ul>
<li><a href="https://developer.android.com/develop/background-work/services/foreground-services">FOREGROUND&#95;SERVICE</a>必须要指定一个<a href="https://developer.android.com/about/versions/14/changes/fgs-types-required">类型</a>。</li>
<li>调用<a href="https://developer.android.com/reference/android/bluetooth/BluetoothAdapter#getProfileConnectionState(int">BluetoothAdapter#getProfileConnectionState</a>)时必須在Manifest中声明<a href="https://developer.android.com/reference/android/Manifest.permission#BLUETOOTH_CONNECT">BLUETOOTH&#95;CONNECT</a>权限。</li>
<li>支持JDK17，可以使用Java 17了。</li>
<li>动态广播接收器必须指明<a href="https://developer.android.com/reference/androidx/core/content/ContextCompat#RECEIVER_NOT_EXPORTED(">export flag</a>)，这个其实targetSDK 33时就有了。</li>
<li>动态加载的代码（Jar 或者Dex）文件必须标记为只读。这个对插件化和Hotfix等影响较大。</li>
<li>Zip文件处理时，如果有路径越界（如&#8221;..&ldquo;或者以&rdquo;/&ldquo;开头的绝对路径）<a href="https://developer.android.com/reference/java/util/zip/ZipException">会抛异常</a>。</li>
</ul>


<p>总的来说变化不大，主要还是<strong>权限收紧和安全加强</strong>。可以查看<a href="https://developer.android.com/about/versions/14/behavior-changes-14">官方文档</a>来看具体的。不喜欢看原文的同学，还有<a href="https://developer.android.com/about/versions/14/behavior-changes-14?hl=zh-cn">翻译的版本</a>。啥？官方无法访问，莫慌还有<a href="https://developer.android.google.cn/about/versions/14/behavior-changes-14">官方的镜像</a>。</p>

<h2>如何升级</h2>

<h3>做好准备</h3>

<p>折腾开发环境是比较烦的，所以最好找一个相对轻松的时间（比如产品汪休假时），以及心情还不错时。另外一定要把手头的事情做好备份并切到新的分支，以防不测。这真不是把33改到34就能完事儿的，会有各种意想不到的事情。</p>

<h3>修改build.gradle文件</h3>

<p>升级targetSDK的第一步是修改应用的build.gradle文件。找到defaultConfig部分，将targetSdkVersion的值修改为34。例如：</p>

<pre><code class="Groovy">android {
    compileSdkVersion 34
    defaultConfig {
        targetSdkVersion 34
        // 其他配置...
    }
    // 其他构建配置...
}
</code></pre>

<p>同时，确保compileSdkVersion也设置为34，以确保使用最新的编译工具。</p>

<p>注意，建议手动改配置，而不要用所谓的<a href="https://developer.android.com/build/sdk-upgrade-assistant">SDK Upgrade Assistant</a>，因为你不晓得它都会干啥，有可能把项目的配置改的面目全非。</p>

<h3>适配SDK的变化</h3>

<p>就是针对平台的新变化做对应的修改。如何修改？其实<a href="https://developer.android.com/about/versions/14/behavior-changes-14">官方文档</a>里面都有具体的指导，或者<a href="https://blog.csdn.net/lbs458499563/article/details/132928217">这篇文章讲的</a>也非常详细，这里就不重复了。</p>

<h2>避坑指南</h2>

<p>Android 14的变化并不大，没有Android 13带来的变化多，这几年最大的影响是Android 11到Android 13，主要体现在<strong>存储读写</strong>的变化上面，可以看<a href="http://toughcoder.net/blog/2023/05/03/android-scope-storage-puzzles/">之前的一篇文章</a>。</p>

<p><img src="https://s3.eu-west-2.amazonaws.com/uploads.3alampro.com/2021/September/GUKIJS1LwonmLnjJY0Wq5lkZTv78fAukV2SbTSui.jpeg" alt="" /></p>

<p>所以升级到targetSDK 34的难度有多大，有啥坑？这要取决于升级前的基础是什么。如果之前已经升级到了targetSDK 33，那么不会有坑，前面那几点稍弄下，就没有问题了。但如果还在API 30或者31，那麻烦会比较多，因为要先过targetSDK 33这一关，它的坑是最多的，可以<a href="https://juejin.cn/post/7260913522962956347">参考这篇文章</a>。</p>

<h2>做好对平台的封装与隔离</h2>

<p>最近几年Android版本的最大变化就是存储权限的收紧，以前可以直接用File到处读写，现在只有极少数文件夹可读可写，且像媒体文件要用<a href="https://developer.android.com/training/data-storage/shared/media">MediaStore API</a>。如果你的项目代码中到处都是File，甚至在JNI的so中也到处都是绝对路径，那么升级targetSDK会相当痛苦。</p>

<p>这就要求我们在开发过程中多留一个心眼儿。一个伟大的计算机科学家说过「计算机科学中的任何问题都能通过增加一个层来解决」。解决这种平台的硬性依赖的最好方法就是多加一层封装以进行隔离：</p>

<ul>
<li>用一个模块来封装所有的涉及存储的I/O操作，这样即使遇到平台的重大变化，也<strong>只需要改这一个模块，风险大大减小</strong>。</li>
<li>对于JNI，要尽可能的传递数据，而非直接让其操作文件。如果确实要操作文件，那么也要<strong>把根文件夹从Java层传入，不能让so使用绝对路径</strong>。</li>
</ul>


<p>对平台做好<strong>封装和隔离</strong>，会大大加强项目的兼容性，在升级平台SDK时起码能做到<strong>风险可控</strong>。</p>

<h2>未来Android的发展趋势</h2>

<p>Android（其实智能手机操作系统也一样）诞生于21世纪的第一个10年，在第二个10年达到了顶峰，移动互联网让科技巨头吃尽了红利，巨头们的市值更是超过了全球GDP总值。但回首最近两年的Google I/O和水果的WWDC，可以发现，Android和水果越来越像，也在相互抄袭，已经很久没有见到让人感到惊艳的东西了（乔帮主在天上估计都要看不下去了）。</p>

<p>对于Android来说，<strong>系统安全（包括权限收紧和数据安全）</strong>和<strong>隐私保护</strong>（安全和隐私曾经是Android的弱项，现在已追上来了），以及<strong>互联互通</strong>这三个方面还有点新东西，其他的已经没有什么变化了。智能手机已经到了比较明显的瓶颈期，巨头的注意力已经全都转移到了AI上面了。可以看一看<a href="https://developer.android.com/about/versions/15/behavior-changes-15">Android 15的变化</a>，基本上没啥变化，以后的升级会越来越简单了，可能下次只是把34改成35就完事儿了。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/about/versions/14/behavior-changes-14">Behavior changes: Apps targeting Android 14 or higher </a></li>
<li><a href="https://developer.android.com/build/sdk-upgrade-assistant">Use the Android SDK Upgrade Assistant</a></li>
<li><a href="https://developer.android.com/about/versions/14/setup-sdk">Set up the Android 14 SDK</a></li>
<li><a href="https://swiftspeed.app/sdk-target-android-api-level/">How To Update Your App SDK To Target Android API Level 34</a></li>
<li><a href="https://blog.csdn.net/lbs458499563/article/details/132928217">Android14 适配之——targetSdkVersion 升级到 34 需要注意些什么？</a></li>
<li><a href="https://juejin.cn/post/7260913522962956347">升级targetSDK为33后的十来个坑 (工具篇)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/628752923">Android 14 快速适配要点</a></li>
<li><a href="https://juejin.cn/post/7302348032544866316">Android 14 正式版适配笔记（二）— 针对Android14或更高版本应用的变更</a></li>
<li><a href="https://juejin.cn/post/7299834584375869474">Android 14 正式版适配笔记（一）— 针对所有应用的变更</a></li>
<li><a href="https://www.cnblogs.com/joy99/p/17809113.html">记一个 Android 14 适配引发的Android 存储权限问题</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让你从此不再惧怕ANR]]></title>
    <link href="http://toughcoder.net/blog/2023/12/08/android-anr-made-easy/"/>
    <updated>2023-12-08T22:12:55+08:00</updated>
    <id>http://toughcoder.net/blog/2023/12/08/android-anr-made-easy</id>
    <content type="html"><![CDATA[<blockquote><p>这篇文章是基于官方的<a href="https://developer.android.com/topic/performance/anrs/diagnose-and-fix-anrs">Diagnose and fix ANRs</a>翻译而来，但也不是严格的翻译，原文的内容都在，又加上了自己的理解以及自己的经验，以译注的形式对原文的作一些补充。</p></blockquote>

<hr />


<p>当一个Android应用的UI线程被阻塞时间过长，系统就会发出一个臭名昭著的“应用程序未响应”(ANR, Application Not Responding&#8221;)错误。本文将讲述不同类型的ANR，如何分析以及如何解决。文中列出的所有的超时时间范围都是基于<a href="https://source.android.com/">AOSP</a>和Pixel设备；这些时间范围可能会依OEM厂商而不同。</p>

<p><a href=""><img src="https://ts1.cn.mm.bing.net/th/id/R-C.b5cd953e9f33003456314ae6608fcecc?rik=pPBn5R3rPZ83ew&amp;riu=http%3a%2f%2fiotts.com.cn%2fblog%2fimages%2fAndroid_a.jpg&amp;ehk=qj91EEfUUgZ32njo8AfBJIdOoPJYInW%2b7chI6g6Jxqs%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" title="auto auto" ></a></p>

<!-- more -->


<p>需要注意的是，当分析ANR的根因时，区分<strong>系统原因</strong>和<strong>应用本身的原因</strong>是很有帮助的。
当整个系统处于一个糟糕状态时，下面这些问题可能会引发ANR：</p>

<ul>
<li>系统服务内部的一些瞬时问题(Transient issues)就会导致通常很快的binder call变得非常慢。</li>
<li>系统服务的问题以及较高的系统负载会导致应用程序的线程无法被正常的调度。</li>
</ul>


<blockquote><p><strong>译注：</strong><a href="https://learn.microsoft.com/en-us/azure/architecture/best-practices/transient-faults">瞬时问题Transient issue</a>是指一些服务运行时出现了一些瞬时的小错误比如服务器的网络抽风(闪断又闪连)，或者一个系统服务的I/O错误，但可能会导致客户无法正常的获得响应。这里要这样来理解，服务(servers)一般都是长时间运行的，它是有可能会发生一些小错误的，瞬时的很快就恢复了，但如果客户恰好在此时来请求就不会得到响应。尽管这对于服务来说是一个可以忽略的小错误，毕竟它是长时间运行的，几秒钟的小错误不影响它本身的运行，但对客户侧的影响却是较大，对客户侧来说就是请求得不到响应。</p></blockquote>

<p>如果可以的话，区分系统问题还是应用问题的好方法就是使用<a href="https://perfetto.dev/docs/">Perfetto traces</a>:</p>

<ul>
<li>通过查看在Perfetto跟踪的是运行中还是未运行的线程的状态来判断应用的主线程有没有被正常的调度。</li>
<li>查看系统进程system_server的线程，看有没有锁竞争之类的问题。</li>
<li>对于耗时的(跨进程调用)binder calls，查看一下是否存在应答进程，以及为何它会耗时。</li>
</ul>


<blockquote><p><strong>译注：</strong>很多重要的系统服务都在system_server进程里面，如负责创建调度所有组件的<a href="https://android.googlesource.com/platform/frameworks/base/+/4f868ed/services/core/java/com/android/server/am/ActivityManagerService.java">AMS(Activity Manager Service)</a>，包管理<a href="https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/services/core/java/com/android/server/pm/PackageManagerService.java">PMS(Package Manager Service)</a>，窗口管理<a href="https://android.googlesource.com/platform/frameworks/base/+/android-4.3_r2.1/services/java/com/android/server/wm/WindowManagerService.java">WMS(Window Manager Service)</a>等等，system_server进程本来的load其实不轻。再加上很多OEM定制化的功能也必须要在AMS处做事情（如hook或者拦截），导致system_server并不比应用程序少引发问题，而一旦system_server有耗时操作或者在等待锁，会导致整个系统处于极度卡顿状态，这时事件的派发，组件的创建，生命周期的调度，以及WMS的焦点处理等等正常的逻辑都不可能得到及时的流转和响应。这种时候任何一个应用都可能随时发生ANR，但应用本身却都是idle状态，问题是在system_server这一侧。</p>

<p><a href="https://developer.android.com/reference/android/os/Binder">Binder</a>是安卓系统的核心基础通信机制，组件件间的通信，Intent，ContentResolver，应用与AMS，PMS和WMS等等之间的交互都是通过binder call来进行的，常规情况下大部分时候binder call都没有问题会很快问题，但如果binder另一头的某个服务发生了问题，即使是瞬时问题，也会导致binder call被阻塞或者变慢，这时就可能引发应用侧的ANR。</p>

<p>需要厘清概念，系统服务(services)与进程并不是同一回事，也不是一一对应的关系。系统服务是安卓系统架构上的模块，都分布于框架层，支撑着系统的运转。而进程则是CPU（准确的说是操作系统内核）运行和调度的基本单元（进程则再细分为线程）。一个系统服务可能独立占用一个进程，比如像<a href="https://cs.android.com/android/platform/superproject/+/master:packages/providers/MediaProvider/src/com/android/providers/media/MediaService.java">Media Service(mediaserver)</a>，<a href="https://source.android.com/docs/core/camera">CameraService(cameraserver)</a>，也可能会生成几个进程；当然 也有可能几个服务都在同一个进程里面，比如前面提到的与应用程序最为密切相关的三大服务AMS, WMS和PMS。当一个服务必须要有独立进程的时候，就会为它创建独立的进程，比如像CameraService，在Android O以前是没有独立进程的，它活在mediaserver里，后来才有独立的进程cameraserver。</p>

<p>服务是架构上的逻辑概念，而进程和线程是从硬件（CPU）角度看到的代码的执行。ANR是由于进程（准确的说是线程，进程由至少一个线程组成）卡顿或者被阻塞导致的。调试的手段也都是从代码执行的角度，把线程的栈帧转储出来(stack trace dump)，以查看是被哪 个函数阻塞了。</p></blockquote>

<h2>输入派发超时(Input dispatch timeout)</h2>

<p>输入派发无响应发生在应用的主线程无法及时地响应一个输入事件，如滑动手势或者物理按键。因为当输入派发超时发生时应用是在前台的，所以这类超时总是对用户可见的，所以想办法规避是很重要的。</p>

<p><strong>默认超时时间：5秒</strong></p>

<p>输入派发超时无响应通常是由于主线程的问题引起的。如果主线程因为等待获取某个锁而阻塞，锁的持有线程也包含在内。遵循以下最佳实践以防止输入派发未响应：</p>

<ul>
<li>主线程不要进行可能会阻塞或者耗时的操作。可以考虑使用<a href="https://developer.android.com/reference/android/os/StrictMode">严格模式StrictMode</a>来捕捉主线程的一些异常的行为。</li>
<li>尽可能的减少主线程和其他线程之间的锁竞争。</li>
<li>在主线程尽可能减少非UI相关的操作，比如当处理广播(Broadcasts)时或者处理服务时(Services)。</li>
</ul>


<h3>常见的根因</h3>

<p>这里列出一些输入派发无响应常见的根因以及修复建议。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 根因 </th>
<th style="text-align:left;"> 表象 </th>
<th style="text-align:left;"> 修复建议 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 耗时跨进程调用slow binder call </td>
<td style="text-align:left;"> 主线程执行了一个耗时同步binder call </td>
<td style="text-align:left;"> 把这个调用放到非主线程，或者优化一下这个调用，如果你负责这个API的话 </td>
</tr>
<tr>
<td style="text-align:left;"> 很多连续的binder calls </td>
<td style="text-align:left;"> 主线程执行了很多连续的跨进程调用 </td>
<td style="text-align:left;"> 不要在一个密集的循环中执行binder call </td>
</tr>
<tr>
<td style="text-align:left;"> 阻塞式的I/O </td>
<td style="text-align:left;"> 主线程执行了阻塞式的I/O，如数据库操作或者网络请求 </td>
<td style="text-align:left;"> 把所有阻塞式I/O调用放到非主线程里 </td>
</tr>
<tr>
<td style="text-align:left;"> 锁竞争 </td>
<td style="text-align:left;"> 主线程因为等待获取某个锁而阻塞 </td>
<td style="text-align:left;"> 减少主线程与其他线程之间的锁竞争，优化其他线程中的耗时代码 </td>
</tr>
<tr>
<td style="text-align:left;"> 耗时的帧 </td>
<td style="text-align:left;"> 在一帧里面做太多的渲染，导致严重的丢帧 </td>
<td style="text-align:left;"> 减少帧渲染的工作。不要用超过O(n<sup>2</sup>)的算法。用一些高效的组件来进行滑动和分页，比如<a href="https://developer.android.com/jetpack">Jetpack</a>中的<a href="https://developer.android.com/topic/libraries/architecture/paging/v3-overview">Paging library</a> </td>
</tr>
<tr>
<td style="text-align:left;"> 被其他组件阻塞 </td>
<td style="text-align:left;"> 其他的组件比如广播接收器(BroadcastReceiver)正在运行并阻塞着主线程 </td>
<td style="text-align:left;"> 主线程尽量不要做非UI操作，另起一个线程运行broadcast receivers </td>
</tr>
<tr>
<td style="text-align:left;"> GPU挂起 </td>
<td style="text-align:left;"> GPU挂起是一个系统问题或者硬件问题，会导致渲染被阻塞，因此也会引发输入派发ANR </td>
<td style="text-align:left;"> 很不幸的是在应用程序侧是无法搞定这个问题的。唯一的可能就是联系对应厂商。</td>
</tr>
</tbody>
</table>


<p><br /></p>

<h3>如何调试</h3>

<p>通过查看在Google Play Console和Firebase Crashlytics中的ANR簇标来开始调试。簇集会包含疑似引发ANR的最多的栈帧。</p>

<p><strong>注意：</strong>忽略簇集是&#8221;navivePollOnce&#8221;和&#8221;main thread idle&#8221;的输入派发ANR。这类标志通常是关联着栈帧转储太晚的ANRs，没有可操作的提示所以要忽略掉。一般来说，真正的ANR会在其他簇集里，所以问题并不会被掩盖。详细信息可参见<strong>nativePollOnce部分</strong>。</p>

<blockquote><p><strong>译注：</strong>这篇文档是谷歌官方的，所以它自然会使用谷歌官方的应用后台(Google Play Console)和统计分析(Firebase Crashlytics)工具，对于大部分国内的开发者来说这两个东西可能比较陌生。但没关系，原理是相通的，国内也有很多应用异常统计工具和后台，或者一些本地工具抓取的日志，形式是不限的，只要能收集到类似的栈帧(stack traces)就可以用于分析调试ANR。栈帧(stack frame或者stack trace)就是线程里面的函数调用栈，比如a()->b()->c()->d()这样的函数调用，所有的异常统计工具或者日志工具都能抓取出来某一时刻每个线程的栈帧，这也称之为栈帧转储(stack frame dump)。</p></blockquote>

<p>下面的流程图展示如何确定一个输入派发超时ANR的根因：</p>

<p><img src="https://developer.android.com/static/topic/performance/images/debug-input-dispatch-anr.png" alt="" />
图1. 如何调试一个输入派发无响应ANR</p>

<p>Play vitals能够探测并帮助调试这些常见ANRs原因中的一部分。比如说，如果vitals探测到一个ANR是因为锁竞争，它会总结这些问题并在ANR Insights部分给出建议的修复方法。</p>

<p><img src="https://developer.android.com/static/topic/performance/images/play-vitals-anr-detection.png" alt="" />
图2. Google Play vitals ANR探测</p>

<blockquote><p><strong>译注：</strong>输入派发超时ANR发生的时候应用一定是在前台的，并且用户正在交互。因此重点要看主线程里面的可能的耗时操作，对于系统侧的问题以及关键的生命周期方法则一般不太相干，因为这时生命周期一般都走完了，处理常规的交互阶段。</p></blockquote>

<h2>找不到有焦点的窗口(No focused window)</h2>

<p>像触摸等的事件通过命中测试后会直接发送到相关窗口，而像硬件按键事件则需要一个目标（窗口）。这个目标就是指有焦点的窗口。每一个显示器每一时刻只有一个有焦点的窗口，并且常常就是用户当前正在使用的那个。如果找不到有焦点的窗口，输入服务会触发一个&#8221;No focused window ANR&#8221;。找不到焦点窗口ANR是输入派发无响应中的一种。</p>

<p><strong>默认超时时间：5秒。</strong></p>

<h3>常见的原因</h3>

<p>无焦点窗口ANRs通常由以下原因导致：</p>

<ul>
<li>应用启动做了太多耗时操作，还没有渲染出来第一帧。</li>
<li>应用的主窗口无法获取焦点。如果一个窗口被使用了标志位<a href="https://developer.android.google.cn/reference/android/view/WindowManager.LayoutParams#FLAG_NOT_FOCUSABLE">FLAG_NOT_FOCUSABLE</a>，那么用户 就无法发送按键事件或者触摸事件到这个窗口上面。</li>
</ul>


<pre><code class="Kotlin">override fun onCreate(savedInstanceState: Bundle) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_main)
    window.addFlags(WindowManager.LayoutParams.FLAG_FLAG_NOT_FOCUSABLE)
}
</code></pre>

<blockquote><p><strong>译注：</strong>No focused window说明应用应在前台而未在前台，或者不应该在前台而在前台，这类ANR最容易发生在生命周期方法执行太慢导致input与window焦点状态不同步导致的。所以重点要看应用的关键生命周期回调方法是否有耗时操作，比如onCreate()/onDestroy()，onStart()/onStop()，以及特别的onResume()/onPause()。可以与上面的输入派发超时进行对比，可以发现这两类ANR分析的侧重点并不一样。</p></blockquote>

<h2>广播接收器超时(Broadcast receiver timeout)</h2>

<p>广播接收器ANR发生在当一个广播接收器无法及时的响应一个广播。对于一个同步的接收器，或者没有调用<a href="https://developer.android.com/reference/android/content/BroadcastReceiver#goAsync(">goAsync</a>)的receivers，超时的意思是<a href="https://developer.android.com/reference/android/content/BroadcastReceiver#onReceive(android.content.Context,%20android.content.Intent">onReceive()</a>)方法未能及时的执行完。对于异步接收器，或者调用了goAsync的receivers，超时的意思是<a href="https://developer.android.com/reference/kotlin/android/content/BroadcastReceiver.PendingResult#finish">PendingResult.finish</a>未能及时的被调用。</p>

<p>广播接收器ANRs经常发生在这些线程中：</p>

<ul>
<li>主线程，问题会是应用启动太慢</li>
<li>运行broadcast receiver的线程，问题会是onReceive执行太慢</li>
<li>广播的后台线程，问题会是执行goAsync的代码太耗时了</li>
</ul>


<p>遵循这些最佳实践来避免广播接收器ANRs：</p>

<ul>
<li>保证快速应用启动，因为应用启动时间也会被计算在ANR的超时时间里，如果应用是被唤醒来处理广播。</li>
<li>如果使用了goAsync，要确保PengingResult.finish早点被调用。这跟同步receivers一样都受超时时间影响。</li>
<li>如果使用了goAsync，要确保工作线程没有开启耗时操作或者阻塞性的操作。</li>
<li>考虑在非主线程里面调用<a href="https://developer.android.google.cn/reference/android/content/Context#registerReceiver(android.content.BroadcastReceiver,%20android.content.IntentFilter">registerReceiver</a>)以免阻塞主线程中的代码执行。（这里的意思是要为广播提供一个非主线程的Handler，这是广播处理回调onReceiver运行的线程。如不提供Handler将会在主线程中运行 &mdash;译注）</li>
</ul>


<blockquote><p><strong>译注：</strong>广播接收器是一个独立的组件，用于任何时候接收广播事件并进行处理，包括应用还未运行时。因此，如果应用还未有运行，那么要响应广播，必须先把应用唤起(创建进程，并创建Application实例)，然后才能创建receiver实例来处理广播。所以应用冷启动时间是会被计算在超时时限内的，从而慢的冷启动肯定会影响广播处理。通常开发者都会只关注应用启动后的情况，比如渲染性能或者用户体验，会忽略其他组件如BroadcastReceiver，Service以及ContentProvider是与Activity一样的平台级别的组件，它们都能单独的运行，但它们毕竟都是在同一个应用里面，要运行在同一进程和同一个Application实例下面，所以在运行这些组件前AMS是需要先唤起应用，应用的启动会影响着所有的四大组件。另外要注意，尽管可以用&#8221;android:process&#8221;给组件(通常是给Service和ContentProvider)指定单独的进程，但冷启动的影响也是存在的，同样需要创建进程和Application实例，并且其实主进程也是被会唤起的。</p></blockquote>

<h3>超时时限(Broadcast receiver timeout)</h3>

<p>广播接收超时时限取决于前台Intent标志是否启用以及系统平台的版本：</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> Intent类型 </th>
<th style="text-align:left;"> Android 13以及更低版本 </th>
<th style="text-align:left;"> Android 14及更高的版本 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 优先级是前台的Intent(启用了FLAG_RECEIVER_FOREGROUND) </td>
<td style="text-align:left;"> 10秒 </td>
<td style="text-align:left;"> 10~20秒，取决于进程是否是CPU挨饿 </td>
</tr>
<tr>
<td style="text-align:left;"> 优先级是后台Intent(未启用FLAG_RECEIVER_FOREGROUND) </td>
<td style="text-align:left;"> 60秒 </td>
<td style="text-align:left;"> 60~120秒，取决于进程是否是CPU挨饿 </td>
</tr>
</tbody>
</table>


<p>想要知道是否启用了FLAG_RECEIVER_FOREGROUND，可以通过在ANR标题中寻找&#8221;flg=&ldquo;然后查看是否存在<strong>0x10000000</strong>。如果这他二进制位是1就说明前台标志被启用了。</p>

<p>受制于短时广播超时时间(10~20秒)的标题例子：</p>

<pre><code class="bash">Broadcast of Intent { act=android.inent.action.SCREEN_ON flg=0x50200010 }
</code></pre>

<p>受制于长广播超时(60~120秒)的标题例子:</p>

<pre><code class="bash">Broadcast of Intent { act=android.intent.action.TIME_SET flg=0x25200010 }
</code></pre>

<h3>广播的超时时间是如何计算的</h3>

<p>广播耗时时长测量从system_server把广播派发给应用时开始，到当应用完成广播的处理时结束。如果应用程序的进程没在运行，还需要把应用冷启动时间计算在ANR的超时时间里面。因此，缓慢的应用启动也可能会导致广播接收超时ANR。</p>

<p>下面这张图展示了广播接收器的时间线与应用进程的对齐关系：</p>

<p><img src="https://developer.android.com/static/topic/performance/images/broadcast-receiver-anr-timeline.png" alt="" />
图3. 广播接收器时间线</p>

<p>ANR超时时间测量当接收器处理完广播时就结束，具体这个什么时候算结束取决于是同步接收器还是异步接收器：</p>

<ul>
<li>对于同步接收器，当onReceive方法返回时测量就结束了。</li>
<li>对于异步接收器，当PendingResult.finish被调用时就结束。</li>
</ul>


<p><img src="https://developer.android.com/static/topic/performance/images/sync-async-measurement-end.png" alt="" />
图4. 同步接收器和异步接收器的ANR超时测量结束时间点</p>

<h3>常见的根因</h3>

<p>这里列出广播接收超时ANR的一些常见根因以及修复建议。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 根因 </th>
<th style="text-align:left;"> 适用于 </th>
<th style="text-align:left;"> 表象 </th>
<th style="text-align:left;"> 建议的修复方式 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 缓慢的应用启动 </td>
<td style="text-align:left;"> 所有接收器 </td>
<td style="text-align:left;"> 应用在冷启动耗时太多 </td>
<td style="text-align:left;"> 优化应用的冷启动 </td>
</tr>
<tr>
<td style="text-align:left;"> onReceive未被调度 </td>
<td style="text-align:left;"> 所有接收器 </td>
<td style="text-align:left;"> 广播接收器线程正忙于其他操作无法执行onReceive </td>
<td style="text-align:left;"> 不要在接收器的线程里面做长时间的耗时操作(放到其他工作线程里去) </td>
</tr>
<tr>
<td style="text-align:left;"> 缓慢的onReceive </td>
<td style="text-align:left;"> 所有的接收器，主要是同步接收器 </td>
<td style="text-align:left;"> 开始执行onReceive了，但因为被阻塞了或者执行的太慢，无法及时的完成并返回 </td>
<td style="text-align:left;"> 优化缓慢的onReceive代码 </td>
</tr>
<tr>
<td style="text-align:left;"> 异步接收器未被调度 </td>
<td style="text-align:left;"> goAsync()接收器 </td>
<td style="text-align:left;"> onReceive要在一个被阻塞的工作线程池中执行，所以始终得不到执行 </td>
<td style="text-align:left;"> 优化阻塞的代码或者binder call，或者用不同的线程来当作广播的工作线程 </td>
</tr>
<tr>
<td style="text-align:left;"> 工作线程太慢或者被阻塞 </td>
<td style="text-align:left;"> goAsync()接收器 </td>
<td style="text-align:left;"> 当处理广播时，在工作线程池中有耗时操作或者阻塞代码。因此，PendingResult.finish()无法及时被调用 </td>
<td style="text-align:left;"> 优化缓慢的异步接收器代码 </td>
</tr>
<tr>
<td style="text-align:left;"> 忘记调用PendingResult.finish() </td>
<td style="text-align:left;"> goAsync()接收器 </td>
<td style="text-align:left;"> 代码的逻辑中没有调用finish() </td>
<td style="text-align:left;"> 保证finish()被调用到 </td>
</tr>
</tbody>
</table>


<p><br /></p>

<h3>如何调试</h3>

<p>基于簇集标签(cluster signature)和ANR报告，可以定位到广播接收器运行的线程，然后再定位到未执行的代码或者运行缓慢的代码。</p>

<blockquote><p><strong>注意：</strong>不要忽略&#8221;nativePollOnce&#8221;或者&#8221;main thread idle&#8221;的簇集标签。Google Play Console和Firebase Crashlytics的ANR标签里面的栈帧通常都是从主线程中获取生成的。但是，广播接收器可能运行在非主线程或者调用了goAsync()（也即转成了异步接收器&mdash;译注）。因此，这些簇集标签仍然有实际价值，可以查看一下栈帧里面的相关线程。</p></blockquote>

<p>下面的流程图展示了如何确定一个广播接收超时ANR的根因：</p>

<p><img src="https://developer.android.com/static/topic/performance/images/debug-broadcast-receiver-timeout-anr.png" alt="" />
图5. 如何调试一个广播超时ANR</p>

<h3>找到接收器的代码</h3>

<p>Google Play Console会在ANR簇集标签里面显示接收器的类名和广播Intent。寻找以下信息：</p>

<ul>
<li>cmp=&lt;receiver class&gt;</li>
<li>act=&lt;broadcast_intent&gt;</li>
</ul>


<p>这里是一个广播超时ANR标签的例子：</p>

<pre><code class="bash">com.example.app.MyClass.myMethod
Broadcast of Intent { act=android.accounts.LOGIN_ACCOUNTS_CHANGED
cmp=com.example.app/com.example.app.MyAccountReceiver }
</code></pre>

<h3>寻找运行onReceive方法的线程</h3>

<p>如果使用Context.registerReceiver()时指定了自定义的handler，那就会运行在此handler所依附的线程里。此外，就是在主线程里。</p>

<h3>实例：异步接收器未被调度</h3>

<p>这部分将逐步的演示如何调试一个广播接收超时ANR。</p>

<p>比如说ANR标签是像酱紫的：</p>

<pre><code class="bash">com.example.app.MyClass.myMethod
Broadcast of Intent {
act=android.accounts.LOG_ACCOUNTS_CHANGED cmp=com.example.app/com.example.app.MyReceiver }
</code></pre>

<p>从标签中可以看出，广播intent是android.accounts.LOG_ACCOUNTS_CHANGED，接收器类型是com.example.app.MyReceiver。</p>

<p>从接收器的代码，可以发现线程池&#8221;BG Thread [0,1,2,3]&ldquo;在主要负责处理这个广播。查看栈帧，可以发现所有四个后台线程(background threads)的模式是一样的：它们都执行了一个阻塞式的调用getDataSync。因为所有的后台线程都被占用着，这个广播无法被及时处理，最后发生了ANR。</p>

<pre><code class="bash">BG Thread #0 (tid=26) Waiting

at jdk.internal.misc.Unsafe.park(Native method:0)
at java.util.concurrent.locks.LockSupport.park(LockSupport.java:211)
at com.google.common.util.concurrent.AbstractFuture.get(AbstractFuture:563)
at com.google.common.util.concurrent.ForwardingFuture.get(ForwardingFuture:68)
at com.example.app.getDataSync(&lt;MyClass&gt;:152)

...

at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1145)at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:644)
at com.google.android.libraries.concurrent.AndroidExecutorsModule.lambda$withStrictMode$5(AndroidExecutorsModule:451)
at com.google.android.libraries.concurrent.AndroidExecutorsModule$$ExternalSyntheticLambda8.run(AndroidExecutorsModule:1)
at java.lang.Thread.run(Thread.java:1012)
at com.google.android.libraries.concurrent.ManagedPriorityThread.run(ManagedPriorityThread:34)
</code></pre>

<p>有几种方法可以修复这个问题：</p>

<ul>
<li>查出为何getDataSync会如此之慢，然后优化</li>
<li>不要在四后台线程中都执行getDataSync</li>
<li>更为通用的做法是，保证后台线程池中不要执行长时间的耗时操作</li>
<li>为goAsync任务设计一个专用线程池</li>
<li>使用一个无数量限制的线程池，而不是限量为4的后台线程池</li>
</ul>


<h3>实例：应用启动缓慢</h3>

<p>应用启动缓慢可能会导致几个不同类型的ANR，以广播接收超时ANR和执行服务超时ANR最为显著。如果你在主线程的帧中看到了ActivityThread.handleBindApplication，那么这个ANR的根因很有可能就是启动慢造成的。</p>

<blockquote><p><strong>译注：</strong>四大组件(Activity, Service, BroadcastReceiver和ContentProvidier)都是平台能直接识别的组件，均可由AMS直接启动运行，但它们都是应用的一部分，如果应用尚未运行，那么AMS必须先要创建进程，并创建Application实例，这都需要花费时间，会耗费更久，甚至引发ANR，如果冷启动过程中有耗时操作。所以优化应用启动是性能优化的基石。</p></blockquote>

<h2>执行服务超时(Exceute service timeout)</h2>

<p>当应用程序的主线程无法及时的启动一个Service时就会发生执行服务超时ANR。具体来说，就是一个服务无法在一定时限范围内完成onCreate()或者onStartCommand()或者onBind()的执行。</p>

<p><strong>默认超时时间：</strong>前台服务(Foreground Service)是20秒; 后台服务(Background Service)是200秒。ANR超时时间包括应用冷启动，以及onCreate()，onBind()和onStartCommand的调用。</p>

<p>遵循如下最佳实战来规避执行服务ANR：</p>

<ul>
<li>确保应用启动很快，因为如果一个应用被唤起来运行服务组件，启动时间也会被计算在超时时间内。</li>
<li>确保服务的onCreate()，onBind()和onStartCommand()执行的都很快。</li>
<li>不要在主线程里执行来自其他组件的耗时操作或者阻塞式操作，这些操作会阻碍服务的快速启动。</li>
</ul>


<h3>常见的根因</h3>

<p>下表列出执行服务超时ANR的常见根因和修复建议：。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 根因 </th>
<th style="text-align:left;"> 表象 </th>
<th style="text-align:left;"> 建议的修复 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 缓慢的应用启动 </td>
<td style="text-align:left;"> 应用冷启动时间过长 </td>
<td style="text-align:left;"> 优化应用启动速度 </td>
</tr>
<tr>
<td style="text-align:left;"> 缓慢的onCreate()，onStartCommand和onBind </td>
<td style="text-align:left;"> 服务组件的onCreate()，onStartCommand()和onBind()在主线程执行了耗时操作 </td>
<td style="text-align:left;"> 优化代码，或者把耗时操作从这些关键的方法中移出去 </td>
</tr>
<tr>
<td style="text-align:left;"> 未被调度(在执行onStart()之前主线程就被阻塞了) </td>
<td style="text-align:left;"> 在服务启动之前，主线程就被其他组件级阻塞了 </td>
<td style="text-align:left;"> 把其他组件的工作移出主线程。优化其他组件的阻塞代码 </td>
</tr>
</tbody>
</table>


<p><br /></p>

<h3>如何调试</h3>

<p>从Google Play Console和Firebase Crashlytics中的簇集标签和ANR报告，基于主线程当时的运行状态，通常就能确定ANR的根因。</p>

<p><strong>注意：</strong>忽略标签是&#8221;nativePollOnce&#8221;和&#8221;main thread idle&#8221;的执行服务ANR簇集。这些簇集通常是栈帧捕获的太晚，无实际参考意义。真实的ANR栈帧可能会在其他的簇集里，所以问题并不会被掩藏。详细参见nativePollOnce部分。</p>

<p>下面的流程图描述了如何调试一个执行服务超时ANR。</p>

<p><img src="https://developer.android.com/static/topic/performance/images/debug-execute-service-anr.png" alt="" />
图6. 如何调试一个执行服务ANR</p>

<p>如果发现某个执行报务ANR是有实际操作意义的，遵循以下步骤来解决问题：</p>

<ol>
<li>找到ANR簇集标签中的服务组件。在Google Play Console里，服务组件类型会显示在ANR标签里。在后面的这个例子里，类型就是com.example.app/MyService。</li>
</ol>


<pre><code class="bash">com.google.common.util.concurrent.Uninterruptibles.awaitUninterruptibly
Executing service com.example.app/com.example.app.MyService
</code></pre>

<ol>
<li>确定应用启动过程中，服务组件或者其他地方是否有耗时或者阻塞操作，通过检查主线程中的下面这些重要的方法调用</li>
</ol>


<table>
<thead>
<tr>
<th style="text-align:left;"> 主线程栈帧中的方法调用 </th>
<th style="text-align:left;"> 背后的含义 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> android.app.ActivityThread.handleBindApplication </td>
<td style="text-align:left;"> 应用正在启动，ANR由启动太慢引起 </td>
</tr>
<tr>
<td style="text-align:left;"> <ServiceClass>.onCreate()<br/>[&hellip;.]<br/>android.app.ActivityThread.handleCreateService </td>
<td style="text-align:left;"> 服务正在被创建中，所以ANR是由缓慢的onCreate()引起的 </td>
</tr>
<tr>
<td style="text-align:left;"> <ServiceClass>.onBind()<br/>[&hellip;.]<br/>android.app.ActivityThread.handleBindService </td>
<td style="text-align:left;"> 服务正在被绑定中，所以ANR是由缓慢的onBind()引起的 </td>
</tr>
<tr>
<td style="text-align:left;"> <ServiceClass>.onStartCommand()<br/>[&hellip;.]<br/>android.app.ActivityThread.handleServiceArgs </td>
<td style="text-align:left;"> 服务正在被启动中，所以ANR是由缓慢的onStartCommand()引起的 </td>
</tr>
</tbody>
</table>


<p><br />
举个粟子，如果在类MyService里的onStartCommand执行缓慢，主线程栈帧会像酱婶儿的：</p>

<pre><code class="bash">at com.example.app.MyService.onStartCommand(FooService.java:25)
at android.app.ActivityThread.handleServiceArgs(ActivityThread.java:4820)
at android.app.ActivityThread.-$$Nest$mhandleServiceArgs(unavailable:0)
at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2289)
at android.os.Handler.dispatchMessage(Handler.java:106)
at android.os.Looper.loopOnce(Looper.java:205)
at android.os.Looper.loop(Looper.java:294)
at android.app.ActivityThread.main(ActivityThread.java:8176)
at java.lang.reflect.Method.invoke(Native method:0)
</code></pre>

<p>如果没有发现重要的方法调用，还有其他一些可能：</p>

<ul>
<li> 服务正在运行或者在关闭中，意思是说栈帧捕获的太晚了，可以忽略此类ANR或者视为假阳性。</li>
<li><p> 另外一个组件正在运行，比如广播接收器。这种情况下主线程可能被这个组件阻塞着，导致服务无法启动。</p></li>
<li><p>如果能看到关键的方法 调用并确定ANR发生的地点，检查主线程的栈帧以找到缓慢的操作并把它们从关键的方法中移出去。</p></li>
</ul>


<p>关于服务的更多信息，可以看下面这些链接：</p>

<ul>
<li><a href="https://developer.android.com/guide/components/services">服务概览</a></li>
<li><a href="https://developer.android.com/guide/components/foreground-services">前台服务</a></li>
<li><a href="https://developer.android.com/reference/android/app/Service">服务</a></li>
</ul>


<h2>内容提供程序无响应(Content Provider not responding)</h2>

<p>当一个远端内内容提供程序响应查询(query)时花费超过时限，内容提供程序ANR就会发生，且会被杀掉。</p>

<p><strong>默认超时时间：</strong>内容提供程序通过ContentProviderClient.setDetectNotResponding指定的。ANR超时时限包括远端内容提供程序执行查询的时间，以及如果远端应用还未启还包括它的冷启动时间，加在一起的总时间。</p>

<p>遵循下面这些最佳实践来规避内容提供程序ANR：</p>

<ul>
<li>确保应用启动很快，因为如果应用未运行时会被唤起，冷启动时间也会被计算在超时时间内。</li>
<li>确保内容提供程序的查询能很快执行完。</li>
<li>不要执行大量的并发阻塞式的binder call，因为这会阻塞应用的所有的binder线程。</li>
</ul>


<blockquote><p><strong>译注：</strong><a href="https://developer.android.com/reference/android/content/ContentProvider">内容提供程序Content provider</a>都是要经过跨进程调用(binder call)，尽管可能并没有真正的在另外一个进程里。因为我们使用<a href="https://developer.android.com/guide/topics/providers/content-provider-basics">ContentProvider</a>的时候都是通过另一个API ContentResolver来完成，而ContentResolver是通过binder call来与ContentProvider通信的，无论是否真的跨进程。所以，ContentProvider就像一个服务器一样是远端的一侧提供内容，而应用程序(使用者)是客户端一侧需要内容。内容提供程序可能同时服务着不同的客户请求，比如像系统通用的内容提供程序ContactsProvider或者MediaProvider可能同时会有大量的应用请求查询，每一个请求都需要执行binder call，因此内容提供程序可能会同时执行着大量的binder call(它需要查询结果，并把结果以binder call的形式返回给请求方)。所以对于内容提供程序来说，查看binder call的运行状态对于解决ANR问题以及排查性能问题都是非常有帮助的。</p></blockquote>

<h3>常见根因</h3>

<p>下表列出了内容提供程序ANR的常见根因和修复建议。</p>

<table>
<thead>
<tr>
<th style="text-align:left;"> 根因 </th>
<th style="text-align:left;"> 表象 </th>
<th style="text-align:left;"> 信号 </th>
<th style="text-align:left;"> 建议的修复方式 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;"> 缓慢的查询 </td>
<td style="text-align:left;"> 内容提供程序执行耗时太长或者被阻塞 </td>
<td style="text-align:left;"> binder线程里有android.content.ContentProvider\$Transport.query栈帧 </td>
<td style="text-align:left;"> 优化查询或者查出什么东西在阻塞着binder线程 </td>
</tr>
<tr>
<td style="text-align:left;"> 应用启动太慢 </td>
<td style="text-align:left;"> 内容提供程序启动耗时太久 </td>
<td style="text-align:left;"> 主线程里有ActivityThread.handleBindApplication栈帧 </td>
<td style="text-align:left;"> 优化应用启动 </td>
</tr>
<tr>
<td style="text-align:left;"> Binder线程耗尽了，所有的binder线程都被占用着 </td>
<td style="text-align:left;"> 所有的binder线程都被占用着服务着其他的同步请求，因此内容提供程序binder调用无法执行 </td>
<td style="text-align:left;"> 应用未启动起来，所有的binder线程都被占用，内容提供程序也未能启动起来 </td>
<td style="text-align:left;"> 减小binder线程的负载。也就是说执行更少一些的外发同步binder调用或者在处理到来的调用时少做一些操作。</td>
</tr>
</tbody>
</table>


<p><br /></p>

<h3>如何调试</h3>

<p>要想调试一个内容提供程序ANR，使用Google Play Console或者Firebase Crashlytics中的簇集标签和ANR报告，并用来查看主线程以及binder线程都在做什么。</p>

<p>下面的流程图描述如何调试一个内容提供程序ANR：</p>

<p><img src="https://developer.android.com/static/topic/performance/images/debug-content-provider-anr.png" alt="" />
图7.如何调试一个内容提供程序ANR</p>

<p>下面的代码块展示了当被一个缓慢的内容提供程序查询阻塞时，binder线程的状态。在这个例子里，内容提供程序的查询正在等待一个打开数据库的锁。</p>

<pre><code class="bash">binder:11300_2 (tid=13) Blocked

Waiting for osm (0x01ab5df9) held by at com.google.common.base.Suppliers$NonSerializableMemoizingSupplier.get(Suppliers:182)
at com.example.app.MyClass.blockingGetOpenDatabase(FooClass:171)
[...]
at com.example.app.MyContentProvider.query(MyContentProvider.java:915)
at android.content.ContentProvider$Transport.query(ContentProvider.java:292)
at android.content.ContentProviderNative.onTransact(ContentProviderNative.java:107)
at android.os.Binder.execTransactInternal(Binder.java:1339)
at android.os.Binder.execTransact(Binder.java:1275)
</code></pre>

<p>下面的代码块展示了当被缓慢的应用启动阻塞时，binder线程的状态。在这个例子里，应用启动因为dagger初始化时的锁竞争而变得很慢。</p>

<pre><code class="bash">main (tid=1) Blocked

[...]
at dagger.internal.DoubleCheck.get(DoubleCheck:51)
- locked 0x0e33cd2c (a qsn)at dagger.internal.SetFactory.get(SetFactory:126)
at com.myapp.Bar_Factory.get(Bar_Factory:38)
[...]
at com.example.app.MyApplication.onCreate(DocsApplication:203)
at android.app.Instrumentation.callApplicationOnCreate(Instrumentation.java:1316)
at android.app.ActivityThread.handleBindApplication(ActivityThread.java:6991)
at android.app.ActivityThread.-$$Nest$mhandleBindApplication(unavailable:0)
at android.app.ActivityThread$H.handleMessage(ActivityThread.java:2235)
at android.os.Handler.dispatchMessage(Handler.java:106)
at android.os.Looper.loopOnce(Looper.java:205)
at android.os.Looper.loop(Looper.java:294)
at android.app.ActivityThread.main(ActivityThread.java:8170)
at java.lang.reflect.Method.invoke(Native method:0)
at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run(RuntimeInit.java:552)
at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:971)
</code></pre>

<h2>缓慢的作业响应(Slow job response)</h2>

<p>当应用响应JobService.onStartJob()或者JobService.onStopJob耗时太久，或者用JobService.setNotification()提供通知时耗时太久，都会引发缓慢的作业响应ANR发生。这说明应用的主线程因为其他操作而被阻塞了。</p>

<p>如果问题是与JobService.onStartJob()或者JobService.onStopJob()有关系，就要检查下主线程的情况。如果问题与JobService.setNotification()有关系，要保证它尽可能的快速的被调用到。在提供通知之前 不要做很多其他事情。</p>

<blockquote><p><strong>译注：</strong><a href="https://developer.android.com/reference/android/app/job/JobService">JobService</a>是Android 5.0 API 21时增加的一个专门用于后台作业的一个Service的子类。上面提到的是都是它的一些回调，与一些其他的回调类似，这些回调必须快速执行完毕，因为<a href="https://developer.android.com/reference/android/app/job/JobScheduler">JobSchedule</a>内部需要做一些资源回收之类的工作，所以这些回调不允许被阻塞。</p></blockquote>

<h2>隐秘的ANRs</h2>

<p>有时候搞不清楚为啥ANR会发生，或者在簇集标签和ANR报告中找不到足够的信息去调试。遇到这些情况，还是可以采取一些步骤以确定这些ANR是否是值得处理的。</p>

<h3>消息队列是空闲(Message queue idle)的或者正处理轮询中(nativePollOnce)</h3>

<p>如果你在栈帧信息中发现android.os.MessageQueue.nativePollOnce，这通常说明疑似无响应的线程实际上是空闲的或者在等待队列中的消息。在Google Play Console里面，ANR的细节是酱紫的：</p>

<pre><code class="bash">Native method - android.os.MessageQueue.nativePollOnce
Executing service com.example.app/com.example.app.MyService
</code></pre>

<p>举个粟子，如果主线程是空闲的，栈帧是酱紫的：</p>

<pre><code class="bash">"main" tid=1 NativeMain threadIdle

#00  pc 0x00000000000d8b38  /apex/com.android.runtime/lib64/bionic/libc.so (__epoll_pwait+8)
#01  pc 0x0000000000019d88  /system/lib64/libutils.so (android::Looper::pollInner(int)+184)
#02  pc 0x0000000000019c68  /system/lib64/libutils.so (android::Looper::pollOnce(int, int*, int*, void**)+112)
#03  pc 0x000000000011409c  /system/lib64/libandroid_runtime.so (android::android_os_MessageQueue_nativePollOnce(_JNIEnv*, _jobject*, long, int)+44)
at android.os.MessageQueue.nativePollOnce (Native method)
at android.os.MessageQueue.next (MessageQueue.java:339)  at android.os.Looper.loop (Looper.java:208)
at android.app.ActivityThread.main (ActivityThread.java:8192)
at java.lang.reflect.Method.invoke (Native method)
at com.android.internal.os.RuntimeInit$MethodAndArgsCaller.run (RuntimeInit.java:626)
at com.android.internal.os.ZygoteInit.main (ZygoteInit.java:1015)
</code></pre>

<p>疑似无响应线程可能是空闲的会有几个原因：</p>

<ul>
<li>延迟的栈转储：在ANR被 触发和栈帧转储之间的短时间内，线程状态恢复了。在Android 13版本的Pixels设备上这个延迟大约在100ms，但也可能超过1秒。Android 14版本的Pixels设备上这个延迟小于10ms。</li>
<li>线程归因错误：用于构建ANR标签的线程并不是实际上触发ANR的无响应线程。这种情况下，尝试确定一下这个ANR是否是如下的类型：

<ul>
<li>广播接收超时</li>
<li>内容提供程序无响应</li>
<li>找不到带焦点的窗口</li>
<li>系统侧问题：由于系统负载太重或者系统服务有问题而导致应用进程无法被调度。</li>
</ul>
</li>
</ul>


<h3>没有栈帧(No stack frames)</h3>

<p>有一些ANR报告里面没有包含与ANR相关的栈帧，这说明在生成ANR报告时栈帧转储失败了。有很多可能的原因会导致栈帧丢失：</p>

<ul>
<li>转储栈帧太耗时了，所以超时了</li>
<li>在栈帧转储完成之前进程就挂了或者被杀掉了</li>
</ul>


<pre><code class="bash">[...]

--- CriticalEventLog ---
capacity: 20
timestamp_ms: 1666030897753
window_ms: 300000

libdebuggerd_client: failed to read status response from tombstoned: timeout reached?

----- Waiting Channels: pid 7068 at 2022-10-18 02:21:37.&lt;US_SOCIAL_SECURITY_NUMBER&gt;+0800 -----

[...]
</code></pre>

<p>簇集标签或者ANR报告里面没有栈帧的ANR是没有实际分析意义的。如果要调试，可以去看其他的簇集信息，因为如果一个问题足够明显的话，那么它通常会有它自己的簇集标签存在。其他的可行方案就是查看<a href="https://perfetto.dev/docs/">Perfetto traces</a>.</p>

<h2>已知问题(Known issues)</h2>

<p>在应用的进程里用计时器来测量广播的处理时间或者ANR的触发是行不通的，因为系统是以异步的方式在监控着ANR。</p>

<blockquote><p><strong>译注：</strong>这里的意思是不要想着取巧，应用开发者的重点应该放在你的业务逻辑和性能优化上面，借助平台提供的工具和方法来优化应用的代码逻辑。而像尝试在应用侧自己统计超时这种事情是行不通的，因为系统以比较复杂的异步的方式在统计着超时，应用侧不可能做到与系统侧一样的测量方法，所以自己的统计就变得毫无意义（要么不可行，要么不准确）。还是老老实实的优化好自己的代码吧。</p></blockquote>

<h2>更多的官方资料</h2>

<ul>
<li><a href="https://developer.android.com/topic/performance/anrs/find-unresponsive-thread">Find the unresponsive thread</a></li>
<li><a href="https://developer.android.com/topic/performance/anrs/keep-your-app-responsive">Keep your app responsive</a></li>
<li><a href="https://developer.android.com/guide/topics/resources/layout-resource">Layout resource</a></li>
<li><a href="https://developer.android.com/topic/performance/vitals/anr">ANRs</a></li>
</ul>


<h2>其他优质博文</h2>

<ul>
<li><a href="https://juejin.cn/post/7181731795439157306">钉钉 ANR 治理最佳实践 | 定位 ANR 不再雾里看花</a></li>
<li><a href="https://juejin.cn/post/6940061649348853796">今日头条 ANR 优化实践系列 - 设计原理及影响因素</a></li>
<li><a href="https://juejin.cn/post/7053819042268151838">Android ANR全解析&amp;华为AGC性能管理解决ANR案例集</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[实战技巧：为Android应用设置独立的多语言]]></title>
    <link href="http://toughcoder.net/blog/2023/11/27/android-set-per-app-langauges/"/>
    <updated>2023-11-27T22:40:38+08:00</updated>
    <id>http://toughcoder.net/blog/2023/11/27/android-set-per-app-langauges</id>
    <content type="html"><![CDATA[<p>通常情况下多语言的设置都在系统设置中，应用需要做的就是提供本应用所使用的字串的多语言翻译，使用时使用R.string.app_name类似的引用，然后系统会根据用户在系统设置中的选项来选择合适的具体的语言。并且这是一个<strong>全局选项</strong>，也就是说选择一个多语言后整个手机都变了。但有些时候，应用想要自己能够设置一个独自的多语言，也就是说想要给自己的应用设置一个不同于全局的多语言。今天就来研究一下这个话题。</p>

<p><a href=""><img src="https://i2.wp.com/techvidvan.com/tutorials/wp-content/uploads/sites/2/2021/08/Android-Localization-1.jpg?fit=1200%2C628&amp;ssl=1"></a></p>

<!--  more -->


<p>这样做的目的是为了提供更好的用户体验，因为一些仅支持某些特定语言的应用，可能会与系统全局选项冲突，或者只在某些固定地区发行的应用，单独的个性化的局部设置会更好一些。这个谷歌已经通过<a href="https://developer.android.com/jetpack">Jetpack</a>中的<a href="https://developer.android.com/jetpack/androidx/releases/appcompat">appcomat</a>库给与了比较好的支持，详细的可以<a href="https://developer.android.com/guide/topics/resources/app-languages">参考这个文档</a>，以及<a href="https://github.com/android/user-interface-samples/tree/main/PerAppLanguages">官方的Sample</a>。我们在官方文档基础之上再叠加试验和理解，做进一步的总结。</p>

<p>主要分为两种方法，一是系统支持单独给应用设置多语言；二是应用中独自设置，这个也是更为通用的解法。</p>

<p><strong>注意</strong>：这里的方法都是让某一个应用内部使用的多语言改变为相应的设置（一般情况下是与系统全局设置不一样的），但是需要注意仅仅局限于应用启动后的应用内部界面使用的语言。对于像桌面上应用的入口仍是系统全局设置为准，因为这个入口并不属于应用自己管辖范围内的。</p>

<h2>系统设置中支持为应用设置单独多语言</h2>

<p>谷歌官方的表述是从Android 13（Android T, SDK 33)开始，就支持了在系统中有一个入口，可以为每个应用单独设置多语言选项。这一部分里面描述的方法也都是支持这个系统入口的情况才能生效的。需要注意，虽然谷歌官方说从Android 13开始就支持了，但这个也要取决 于厂商的定制，目前看大部分国内厂商会把这个功能和入口给屏蔽掉，那么这里后面描述的方法也就都不会生效了。</p>

<h3>入口在哪里</h3>

<p>需要通过系统设置来进行，有两个入口：</p>

<p><img src="https://developer.android.com/static/images/about/versions/13/app-languages.png" height="480" width="320" alt="" /></p>

<ul>
<li>Settings（设置）> Additional Settings (更多设置) > Languages &amp; Input (语言和输入) > (App Languages) 应用语言 > select an app（选择一个应用）</li>
<li>Settings（设置）> Apps (应用)> select an app（选择一个应用） > Language（语言）</li>
</ul>


<p>具体的方法，又分为两种，一是自动式的，二是手动式的。</p>

<h3>自动添加</h3>

<p>说是自动，其实也是利用IDE（即Android Studio）和编译打包时自动根据res下面的多语言生成一份配置而已。在build.gradle或者build.gradle.kts中的android下面添加generateLocaleConfig = true：</p>

<pre><code class="kotlin">    android {
        androidResources {
            generateLocaleConfig = true
        }
    }
</code></pre>

<p>然后在resl中增加一个名为resources.properties的文件，加入默认值配置：</p>

<pre><code>unqualifiedResLocale=en-US
</code></pre>

<h3>手动添加</h3>

<p>在res/xml中增加文件locales_config.xml，加入需要支持的多语言选项，如：</p>

<pre><code class="xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;locale-config xmlns:android="http://schemas.android.com/apk/res/android"&gt;   &lt;locale android:name="en-US"/&gt;   &lt;locale android:name="en-GB"/&gt;   &lt;locale android:name="fr"/&gt;   &lt;locale android:name="ja"/&gt;   &lt;locale android:name="zh-Hans-MO"/&gt;   &lt;locale android:name="zh-Hant-MO"/&gt;&lt;/locale-config&gt;
</code></pre>

<p>然后在AndroidManifest.xml中的appllication加上这一个属性：</p>

<pre><code class="xml">&lt;manifest&gt;
    ...
    &lt;application
        ...
        android:localeConfig="@xml/locales_config"&gt;
    &lt;/application&gt;
&lt;/manifest&gt;
</code></pre>

<p>因为还没有找到支持如此设置的手机，所以上述方法未经验证。</p>

<h2>在应用内部设置多语言</h2>

<p>这个是更为通用的做法，具体的UI就是可以随便弄了，弄个List或者DrowDownMenu都可以。重点是让设置生效的时候需要用到一个API，叫做<a href="https://developer.android.com/reference/androidx/appcompat/app/AppCompatDelegate#setApplicationLocales(androidx.core.os.LocaleListCompat">setApplicationLocales()</a>)和<a href="https://developer.android.com/reference/androidx/appcompat/app/AppCompatDelegate#getApplicationLocales(">getApplicationLocales()</a>)。并且在appcompat 1.6.0以后的版本，有比较方便的API可以直接使用。</p>

<pre><code class="Kotlin">val appLocale: LocaleListCompat = LocaleListCompat.forLanguageTags("xx-YY")// Call this on the main thread as it may require Activity.restart()AppCompatDelegate.setApplicationLocales(appLocale)
</code></pre>

<p>如果要还原使用系统设置中的全局多语言配置，可以用LocaleListCompat.getEmptyLocaleList()当作参数。</p>

<p><strong>特别注意</strong>：此方法要想生效，宿主Activity必须是继承自appcompat中的AppCompatActivity，而不是其他 。</p>

<p>为了兼容以前的版本（Android 12，API level 32以前），还需要在AndroidManifest中添加一个额外的Service：</p>

<pre><code class="xml">&lt;application  ...  &lt;service    android:name="androidx.appcompat.app.AppLocalesMetadataHolderService"    android:enabled="false"    android:exported="false"&gt;    &lt;meta-data      android:name="autoStoreLocales"      android:value="true" /&gt;  &lt;/service&gt;  ...&lt;/application&gt;
</code></pre>

<p>需要注意，这个Service在appcomat库中已经定义好了，只需要在manfiest里添加一下就可以了。</p>

<p>另外需要注意的是，一般情况下，应用自己肯定 会保存一下当前用户所选择的语言。但如果系统也支持应用语言选择入口的话，那么通过系统入口也是可能会修改应用的多语文选项的，这时，就需要把系统的选项与应用内部的选项进行同步。可以通过<a href="https://developer.android.com/reference/androidx/appcompat/app/AppCompatDelegate#getApplicationLocales(">AppCompatDelegate.getApplicationLocales</a>)来获取当前生效的语言选项，它是由appcompat库来维护的，肯定是最新的，所以应用自己保存的选项如果与这个API的结果不一致，就要重置为这个API的结果。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://developer.android.com/guide/topics/resources/app-languages">Per-app language preferences</a></li>
<li><a href="https://github.com/android/user-interface-samples/tree/main/PerAppLanguages">user-interface-samples/PerAppLanguages</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Weather App With Jetpack Compose]]></title>
    <link href="http://toughcoder.net/blog/2023/09/19/weather-app-with-jetpack-compose/"/>
    <updated>2023-09-19T21:10:56+08:00</updated>
    <id>http://toughcoder.net/blog/2023/09/19/weather-app-with-jetpack-compose</id>
    <content type="html"><![CDATA[<p>现在满屏的Compose，近期也看了一些教程，似懂非懂，总感觉还缺点什么，于是有必要使用这些新技术来构造一个真实的Android App，以加深理解。第一个实例就是想做一个天气查询和展示的应用，使用<a href="https://developer.android.com/jetpack/compose">Jetpack Compose</a>以及Google推荐的<a href="https://developer.android.com/modern-android-development">MAD（Modern Android Development）</a>。</p>

<p><a href=""><img src="http://images.shejidaren.com/wp-content/uploads/2013/09/weather-app.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>核心目的</h2>

<p>学习使用Jetpack Compose构建UI，和学习新的架构方式（MVVM）。其实我们不是只读式的学习，更重要的是要在一个真实的项目中去实践这些知识。</p>

<p>Follow官方的教程和建议，先由最简单的版本，一步步的使用这些轮子打造我们的天气应用。</p>

<p><strong>特别注意</strong>：此行不是为了做一个天气App，而是以MAD的方式来构建App，每一步都要<a href="https://m3.material.io/">符合设计规范</a>和<a href="https://developer.android.com/topic/architecture">架构原则</a>，不留破窗。</p>

<h2>技术栈</h2>

<p><img src="https://innovationm.co/wp-content/uploads/2021/05/Jetpack-compose.png" alt="" /></p>

<p>使用MAD，Jpetpack和Compose，以及<a href="https://developer.android.com/jetpack/androidx/releases/compose-material3">Material Design</a>。</p>

<h2>Weather API</h2>

<p>使用 <a href="https://dev.qweather.com/docs/start/">和风API</a>。</p>

<h2>第一个版本</h2>

<p>本着<a href="http://toughcoder.net/blog/2023/08/08/understanding-minimum-viable-product/">MVP的原则</a>，第一个版本尽量简单，实现核心需求即可，第一个版本的目标：查询预定列表中的城市天气，并展示其详细天气信息。</p>

<p>流程图：</p>

<script type="module">
  import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs';
  mermaid.initialize({ startOnLoad: true });
</script>




<div class="mermaid">
flowchart TD
    A([Start]) &#45;&#45;> C{Has preferred city?}
    C &#45;&#45;> |No| E([Show City list])
    E &#45;&#45;> F([Pick a city])
    F &#45;&#45;> J([Save as prefered])
    J &#45;&#45;> D
    C &#45;&#45;> |Yes| D([Show detail page])
    D &#45;&#45;> G{data need refresh?}
    G &#45;&#45;> |Yes| H([Get weather data])
    H &#45;&#45;> D
    G &#45;&#45;> |No| I([End])
</div>


<h3>第一步：构建UI</h3>

<p>第一版本中的第一步，不用网络，全用fake data，把需要的两个页面构建出来，目的在于搭建基础设施，并把流程跑通。</p>

<h3>第二步：接入Weather API</h3>

<p>获取真实的天气数据，并完善天气详情页面。</p>

<h2>Reference</h2>

<ul>
<li><a href="https://juejin.cn/post/7176875120839884860">从 0 到 1 搞一个 Compose Desktop 版本的天气应用（附源码）</a></li>
<li><a href="https://juejin.cn/column/7127467629022806030">天气App系列文章</a></li>
<li><a href="https://github.com/harsh2907/JetWeather">A weather app built on MVVM architecture with jetpack compose and other jetpack libraries</a></li>
<li><a href="https://github.com/Felix-Kariuki/JetWeather">A weather app built using Jetpack compose</a></li>
<li><a href="https://github.com/Mercandj/android-dev-challenge-compose-4">Weather app done in Jetpack Compose for the #AndroidDevChallenge 2021 🌦 ☀️. Neumorphism UI.</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
