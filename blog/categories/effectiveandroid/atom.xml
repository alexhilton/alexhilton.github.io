<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2024-07-29T20:42:40+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『鱼跃于渊』| Gesture Handling]]></title>
    <link href="http://toughcoder.net/blog/2024/07/29/pointer-event-in-compose/"/>
    <updated>2024-07-29T20:41:20+08:00</updated>
    <id>http://toughcoder.net/blog/2024/07/29/pointer-event-in-compose</id>
    <content type="html"><![CDATA[<p>UI是用户界面，一个最为基础的功能就是与用户进行交互，要具有可交互性。要想有可交互性就需要处理用户输入事件。手势是最为常见的一种用户输入，今天就来专门学习一下如何处理Jetpack Compose中最为常见的手势。</p>

<p><a href=""><img src="https://koenig-media.raywenderlich.com/uploads/2022/10/GesturesInJetpackCompose-twitter.png" title="auto auto" ></a></p>

<!-- more -->


<h2>输入事件与手势概述</h2>

<p>在开始学习之前有必要先澄清一些概念，以免混淆。与View系统不太一样的是，触摸事件在Jetpack Compose中称之为触点事件（Pointer event），对应的主体称之为触点（Pointer），一连串的触点事件就形成了手势（Gesture）。之所以叫触点，是因为并不总是由触摸屏幕触发事件，也可以是手写笔，（外接）鼠标或者（外接）触摸板，这些都是触控类的输入主体，它的最主要的特点是发生在屏幕上的一个坐标点。其具体的类型称之为触点类型（Pointer type）。</p>

<p>事件处理最主要的是也就是要识别各种不同的触点手势，然后做出响应，以让UI具体可交互性。</p>

<h2>点击事件（Tap and Press）</h2>

<p>点击事件是最为常见，也是最为基础的一种手势了，可以简单的看成按下事件（pointer down）和抬起事件（pointer up）组成，但其实也会有移动（pointer move），只不过移动的位移特别小而已，这里我们不过多的纠结。点击事件分为单击，双击和长按，幸运的是在Compose中都有封装好的回调函数可以直接使用，我们一一来看一下。</p>

<h3>单击（Tap/Click）</h3>

<p>单击是最为常见的事件处理了，在之前的教程已经见过了，通过Modifier的扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier">Modifier.clickable</a>.clickable(kotlin.Boolean,kotlin.String,androidx.compose.ui.semantics.Role,kotlin.Function0))就可以为任意一个Composable设置单击事件处理函数。</p>

<h3>双击（Double tap/Double click）和长按（LongPress/Long click）</h3>

<p>对于双击和长按，并不像clickable那样常用，因此需要用到另外一个扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier">Modifier.combinedClickable</a>.combinedClickable(androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.foundation.Indication,kotlin.Boolean,kotlin.String,androidx.compose.ui.semantics.Role,kotlin.String,kotlin.Function0,kotlin.Function0,kotlin.Function0))，这个函数可以设置多个点击事件处理函数，单击双击和长按都可以通过它来设置：</p>

<pre><code class="Kotlin">    Box(
        modifier = Modifier
            .size(100.dp)
            .background(Color.Yellow)
            .combinedClickable(
                onClick = { gotoDetail() },
                onClickLabel = "Go to details",
                onLongClick = { showContextMneu() },
                onLongClickLabel = "Open context menu",
                onDoubleClick = { shareContent() }
            )
    )
</code></pre>

<h2>滚动（Scroll）</h2>

<p>滚动手势是指朝着某一固定的方向慢速的滑动，多用于查看屏幕之外的内容。像集合性布局设计的目的就是为了显示大量的同一类型的数据集合，天生就支持滚动。对于滚动手势需要处理的就是常规布局支持滚动，以及滚动的嵌套。</p>

<h3>非集合性布局支持滚动</h3>

<p>对于常规的非集合性布局（Box，Row和Column）正常情况下是不可滚动的，是没有办法查看超出其尺寸大小范围的内容的。想让这几个布局可滚动也不难，用Modifier的扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier">verticalScroll</a>.verticalScroll(androidx.compose.foundation.ScrollState,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean))和<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier">horizontalScroll</a>.horizontalScroll(androidx.compose.foundation.ScrollState,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,kotlin.Boolean))就可以让不可滚动布局（Box，Row和Column）支持垂直方向滚动和水平方向滚动：</p>

<pre><code class="Kotlin">@Composable
private fun ScrollBoxes() {
    Column(
        modifier = Modifier
            .background(Color.LightGray)
            .size(100.dp)
            .verticalScroll(rememberScrollState())
    ) {
        repeat(10) {
            Text("Item $it", modifier = Modifier.padding(2.dp))
        }
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/gestures-simplescroll.gif" alt="scrollable_box" /></p>

<p>大部分情况下，如果只是想让布局可滚动就不需要处理<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/ScrollState">ScrollState</a>，但如果想要获取滚位置，或者改变滚动位置，比如说页面进入时（Initial composition）自动滚动到某一们位置，可以通过修改<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/ScrollState">SrollState</a>来实现：</p>

<pre><code class="Kotlin">@Composable
private fun ScrollBoxesSmooth() {
    // 进入页面时就自动的平滑的滚动
    val state = rememberScrollState()
    LaunchedEffect(Unit) { state.animateScrollTo(100) }

    Column(
        modifier = Modifier
            .background(Color.LightGray)
            .size(100.dp)
            .padding(horizontal = 8.dp)
            .verticalScroll(state)
    ) {
        // ...
    }
}
</code></pre>

<h3>滚动手势处理</h3>

<p>对于任意的Composable来文章，都可以通过Modifier的扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.Modifier">scrollable</a>.scrollable(androidx.compose.foundation.gestures.ScrollableState,androidx.compose.foundation.gestures.Orientation,kotlin.Boolean,kotlin.Boolean,androidx.compose.foundation.gestures.FlingBehavior,androidx.compose.foundation.interaction.MutableInteractionSource))来监听并处理滚动手势。需要注意的是，scrollable仅会告诉你有滚动手势发生和当前的滚动距离，但并不会直接修改布局，需要开发者去使用滑动距离进行布局的修改：</p>

<pre><code class="Kotlin">@Composable
private fun ScrollableSample() {
    // actual composable state
    var offset by remember { mutableStateOf(0f) }
    Box(
        Modifier
            .size(150.dp)
            .scrollable(
                orientation = Orientation.Vertical,
                // Scrollable state: describes how to consume
                // scrolling delta and update offset
                state = rememberScrollableState { delta -&gt;
                    offset += delta
                    delta
                }
            )
            .background(Color.LightGray),
        contentAlignment = Alignment.Center
    ) {
        Text(offset.toString())
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/gestures-numeric-offset.gif" alt="handle_scrollable" /></p>

<p>如果让滚动对布局产生影响，可以用计算得到offset去改变布局的offset属性offset(y = offset.dp)就可以了。</p>

<h3>滚动嵌套</h3>

<p>手势处理最大的一个麻烦就是手势的嵌套，而又以滚动的嵌套最为麻烦，最为典型的就是同一方向的列表中套着列表，开发者必须手动处理滑动冲突。滚动冲突处理的策略并不难，优先由子View消费滚动事件，当子View还可以滚动时，就把事件消费掉；如果子View已到达边界，无法滚动时，视为事件未消费，把事件再传递给父View，由父View消费，这时父View会进行滚动；当然如果滑动事件没有发生在子View上面，那肯定 是父View滚动。</p>

<p>策略虽然简单，但有魔鬼细节，传统的View必须要在onTouch和onInterceptTouch里面写上大坨大坨的逻辑，还要定义很多个全局变量。幸运的是，针对 于同方向的可滚动布局嵌套，Jetpack Compose已经帮我们处理了。对于使用verticalScroll，horizontalScroll，scrollable，集合性布局（LazyRow，LazyColumn和LazyGrid）和TextField实现的同方向滚动嵌套，不用再特殊处理，Compose已经按照前面说的策略处理好了，这就是<strong>自动嵌套滚动机制（Automatic nested scrolling）</strong>。来看一个例子：</p>

<pre><code class="Kotlin">@Composable
private fun AutomaticNestedScroll() {
    val gradient = Brush.verticalGradient(0f to Color.Yellow, 1000f to Color.Red)
    Column(
        modifier = Modifier
            .fillMaxWidth()
            .height(400.dp)
            .background(Color.LightGray)
            .verticalScroll(rememberScrollState())
            .padding(32.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        repeat(6) {
            Box(
                modifier = Modifier
                    .height(128.dp)
                    .verticalScroll(rememberScrollState())
            ) {
                Text(
                    "$it 滑动试试！",
                    modifier = Modifier
                        .align(Alignment.Center)
                        .border(12.dp, Color.DarkGray)
                        .background(brush = gradient)
                        .padding(24.dp)
                        .height(150.dp)
                )
            }
        }
    }
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/gesture/ascroll.gif" alt="nested_scrolling" />
这个例子中外层Column支持垂直滚动，里面的每个Box也支持垂直滚动，当里面的Box自己消费滚动时，外层 是不会动的，而当里面的Box无法滚动时（overscrolled）事件就到了外层的Column，即Column会滚动。</p>

<p><strong>注意：</strong>滚动嵌套并不是一个好的交互设计，尽管有技术手段解决，但用起来仍旧是怪怪的，操作起来也并不方便，误操作的可能性很大。不同方向的滚动嵌套在一起是比较好的方案，比如横向的Tab页代表不同的分类，竖向的内容页是一个分类中的具体内容，内容是竖向的，内容中仍旧可以有一些横向滑动的扩展内容，如图片库，tag标签等。</p>

<h2>拖拽（Drag）</h2>

<p>拖拽是指按住屏幕慢速移动，被点击到的UI元素应该跟随手势移动并停留在触点离开屏幕的地方。通过扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.Modifier">Modifier.draggable</a>.draggable(androidx.compose.foundation.gestures.DraggableState,androidx.compose.foundation.gestures.Orientation,kotlin.Boolean,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Boolean,kotlin.coroutines.SuspendFunction2,kotlin.coroutines.SuspendFunction2,kotlin.Boolean))可以处理单一方向的拖拽手势。在draggable中我们可以用状态记录移动的距离，然后把距离应用到Composable的offset以生成拖拽后的效果：</p>

<pre><code class="Kotlin">@Composable
private fun DraggableText() {
    var offsetX by remember { mutableStateOf(0f) }
    Text(
        modifier = Modifier
            .offset { IntOffset(offsetX.roundToInt(), 0) }
            .background(Color.LightGray)
            .padding(8.dp)
            .draggable(
                orientation = Orientation.Horizontal,
                state = rememberDraggableState { delta -&gt;
                    offsetX += delta
                }
            ),
        text = "降Compose十八掌！",
        style = MaterialTheme.typography.headlineLarge,
        color = MaterialTheme.colorScheme.primary
    )
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/gesture/drag.gif" alt="drag_demo" /></p>

<h2>滑动（Swipe/Fling）</h2>

<p>滑动与拖拽的区别在于滑动是有速度的，滑动手势在触点离开屏幕后并不会立即停止，而且是会继续朝原方向减速直到速度变为0才停，最为常见的交互方式就是滑动删除（swipe-to-dismiss），以及像列表的Fling手势。</p>

<p>使用Modifier的扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/package-summary#(androidx.compose.ui.Modifier">anchoredDraggable</a>.anchoredDraggable(androidx.compose.foundation.gestures.AnchoredDraggableState,androidx.compose.foundation.gestures.Orientation,kotlin.Boolean,kotlin.Boolean,androidx.compose.foundation.interaction.MutableInteractionSource))来处理滑动事件，定义一些<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/DraggableAnchors">锚点（DraggableAnchors）</a>，视为一个手势操作中的不同状态，比如像滑动开关，就是开和关，像滑动删除就是正常和已删除，再用一个<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/gestures/AnchoredDraggableState">AnchoredDraggableState</a>来追踪滑动的状态，这里面可以定义初始锚点，锚点值，和终止状态的阈值（positionalThreshold超过一定位置就认为到达终点锚点，velocityThreshold速度小于这个时就认为到达终点锚点），以及手势过程中的动画（animationSpec）。然后，再把AnchoredDraggableState中的滑动距离offset设置到Composable中即可。</p>

<p>说的挺复杂，其实很直观，看一个例子就明了：</p>

<pre><code class="Kotlin">enum class SwipeableSwitchState {
    SWITCH_ON, SWITCH_OFF
}

@OptIn(ExperimentalFoundationApi::class)
@Composable
private fun SwipeableSample() {
    val width = 128.dp
    val squareSize = 64.dp

    val density = LocalDensity.current
    val sizePx = with(density) { squareSize.toPx() }
    val anchors = DraggableAnchors {
        SwipeableSwitchState.SWITCH_ON at sizePx
        SwipeableSwitchState.SWITCH_OFF at 0f
    }
    val swipeableState = remember {
        AnchoredDraggableState(
            initialValue = SwipeableSwitchState.SWITCH_OFF,
            anchors = anchors,
            positionalThreshold = { d: Float -&gt; d * 0.4f },
            velocityThreshold = { with(density) { 100.dp.toPx() } },
            animationSpec = tween()
        )
    }
    Box(
        modifier = Modifier
            .width(width)
            .anchoredDraggable(
                state = swipeableState,
                orientation = Orientation.Horizontal,
                startDragImmediately = false
            )
            .background(Color.LightGray)
    ) {
        Box(
            Modifier
                .offset {
                    IntOffset(
                        if (swipeableState.offset.isNaN()) 0 else swipeableState.offset.roundToInt(),
                        0
                    )
                }
                .size(squareSize)
                .background(Color.DarkGray)
        )
    }
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/gesture/swipe.gif" alt="swipe_demo" />
这个例子展示了一个滑动开关的手势处理，滑动距离超过整体长度0.4时，或者速度小于100时就认为到达另一锚点状态。可以明显的看出与拖拽的区别，滑动后手可以离开，但手势仍在继续直到达到终点锚点。</p>

<p><strong>注意：</strong>在Compose 1.6版本以前有另外一个扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#(androidx.compose.ui.Modifier">swipeable</a>.swipeable(androidx.compose.material.SwipeableState,kotlin.collections.Map,androidx.compose.foundation.gestures.Orientation,kotlin.Boolean,kotlin.Boolean,androidx.compose.foundation.interaction.MutableInteractionSource,kotlin.Function2,androidx.compose.material.ResistanceConfig,androidx.compose.ui.unit.Dp))来处理滑动手势，但在1.6版本时已废弃，被anchoredDraggable取代，并且有一个<a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/migrate-swipeable">替换的教程</a>。</p>

<h2>未完待续</h2>

<p>事件处理对于UI来说是极其重要的，本篇重点讲述了Jetpack Compose中的最为基础和最为常见的事件处理方式，足以满足绝大多数应用场景。事件处理也是极其复杂的，对于交互极其复杂的页面来说，还需要进一步的了解更为底层的事件处理方法，以达到复杂交互的目的，将在后面的文章中继续深入探讨事件处理。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/tap-and-press">Tap and press</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/drag-swipe-fling">Drag, swipe, and fling</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/touch-input/pointer-input/scroll">Scroll</a></li>
<li><a href="https://canopas.com/how-to-implement-swipe-to-action-using-anchoreddraggable-in-jetpack-compose-cccb22e44dff">How to Implement Swipe-to-Action using AnchoredDraggable in Jetpack Compose</a></li>
<li><a href="https://fvilarino.medium.com/exploring-jetpack-compose-anchored-draggable-modifier-5fdb21a0c64c">Exploring Jetpack Compose Anchored Draggable Modifier</a></li>
<li><a href="https://medium.com/@AungThiha3/jetpack-compose-anchored-draggable-item-in-motionlayout-part-1-8d5a1cde880f">Jetpack Compose: Anchored Draggable Item in MotionLayout Part 1</a></li>
<li><a href="https://medium.com/@AungThiha3/jetpack-compose-anchored-draggable-item-in-motionlayout-part-2-c1fd94188e56">Jetpack Compose: Anchored Draggable Item in MotionLayout Part 2</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『双龙取水』| Text Edit]]></title>
    <link href="http://toughcoder.net/blog/2024/07/24/text-edit-in-compose/"/>
    <updated>2024-07-24T08:28:55+08:00</updated>
    <id>http://toughcoder.net/blog/2024/07/24/text-edit-in-compose</id>
    <content type="html"><![CDATA[<p>文本是所有UI系统中非常重要的一个种元素，文本的输入在UI框架中的重要性也特别的高，因为这是最重要的一种用户输入。今天专注于文本的输入处理，包括文本输入框，以及文本的选择和富式点击处理。</p>

<p><a href=""><img src="https://static.wixstatic.com/media/0d004d_ea93b43aabf348cb8f96c0dc94f85365~mv2.jpg/v1/fit/w_1000%2Ch_600%2Cal_c%2Cq_80/file.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>文本输入</h2>

<p>Compose提供了符合<a href="https://material.io/components/text-fields">Material Design</a>的文本输入<a href="https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#TextField(androidx.compose.ui.text.input.TextFieldValue,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Boolean,androidx.compose.ui.text.TextStyle,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Boolean,androidx.compose.ui.text.input.VisualTransformation,androidx.compose.foundation.text.KeyboardOptions,androidx.compose.foundation.text.KeyboardActions,kotlin.Boolean,kotlin.Int,kotlin.Int,androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.ui.graphics.Shape,androidx.compose.material.TextFieldColors">TextField</a>)，默认的实现是全填充的：</p>

<pre><code class="Kotlin">@Composable
fun SimpleFilledTextFieldSample() {
    var text by remember { mutableStateOf("Hello") }

    TextField(
        value = text,
        onValueChange = { text = it },
        label = { Text("Label") }
    )
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-textfield-hello.png" alt="textfield" />
还有一个边框式的<a href="https://developer.android.com/reference/kotlin/androidx/compose/material/package-summary#OutlinedTextField(kotlin.String,kotlin.Function1,androidx.compose.ui.Modifier,kotlin.Boolean,kotlin.Boolean,androidx.compose.ui.text.TextStyle,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Function0,kotlin.Boolean,androidx.compose.ui.text.input.VisualTransformation,androidx.compose.foundation.text.KeyboardOptions,androidx.compose.foundation.text.KeyboardActions,kotlin.Boolean,kotlin.Int,kotlin.Int,androidx.compose.foundation.interaction.MutableInteractionSource,androidx.compose.ui.graphics.Shape,androidx.compose.material.TextFieldColors">OutlinedTextField</a>)：</p>

<pre><code class="Kotlin">@Composable
fun SimpleOutlinedTextFieldSample() {
    var text by remember { mutableStateOf("") }

    OutlinedTextField(
        value = text,
        onValueChange = { text = it },
        label = { Text("Label") }
    )
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-outlinedtextfield.png" alt="outlined_textfield" />
可以看到TextField函数最关键的有三个参数：文本框中的显示的文本text，文本变化回调onValueChange，提示标签label。需要注意传给text的变量要是状态（State），这样才会触发重组，否则TextField显示的文本不会发生变化。</p>

<h3>定制TextField</h3>

<p>可以通过其他的参数来控制输入框的行为，最为常用的就是行数限制singleLine和maxLines， 以及文本的样式控制textStyle，它可以控制文本颜色和字体：</p>

<pre><code class="Kotlin">@Composable
fun StyledTextField() {
    var value by remember { mutableStateOf("Hello\nWorld\nInvisible") }

    TextField(
        value = value,
        onValueChange = { value = it },
        label = { Text("Enter text") },
        maxLines = 2,
        textStyle = TextStyle(color = Color.Blue, fontWeight = FontWeight.Bold),
        modifier = Modifier.padding(20.dp)
    )
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-textfield-multiline.png" alt="textfield_customize" />
textStyle比较丰富，除了直接指定颜色以外，还可以用<a href="https://developer.android.com/develop/ui/compose/text/style-text#brush">Brush API</a>，以实现一些颜色渐变，渐变效果是针对整个输入框的，换言之不同的行效果是一样的：</p>

<pre><code class="Kotlin">var text by remember { mutableStateOf("") }
val brush = remember {
    Brush.linearGradient(
        colors = listOf(Color.RED, Color.YELLOW, Color.GREEN, Color.BLUE)
    )
}
TextField(
    value = text, onValueChange = { text = it }, textStyle = TextStyle(brush = brush)
)
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-textfieldgradient.gif" alt="brush_textstyle" /></p>

<h3>与键盘联动</h3>

<p>TextField能够配置软件盘以实现特定输入样式，比如只输入数字，只有英文字符等等，通过TextField的keyboardOptions参数，传入一个<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/KeyboardOptions#KeyboardOptions(androidx.compose.ui.text.input.KeyboardCapitalization,kotlin.Boolean,androidx.compose.ui.text.input.KeyboardType,androidx.compose.ui.text.input.ImeAction">KeyboardOptions</a>)对象。常用的配置项有：</p>

<ul>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/KeyboardCapitalization">capitalization</a> 对于有大小写的语言来说，输入时词首自动大写</li>
<li>autoCorrect 自动更正</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/KeyboardType">keyboardType</a> 键盘类型，如纯字符，纯数字，E-mail地址，网址等等</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/ImeAction">imeAction</a> 让键盘的显示输入完成后的行为相关的按扭，比如<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/ImeAction#Search(">『搜索（Search）』</a>)，<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/ImeAction#Send(">『发送（Send）』</a>)等</li>
</ul>


<p>当输入完成后，用户点了imeAction指定的按扭后，可以指定回调函数以执行相关的操作，通过keyboardActions参数指定一个<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/KeyboardActions">KeyboardActions</a>对象，里面可以指定对应于imeAction中的各种回调，如onSearch会在imeAction指定为Search时，用户点击后触发；onSend会在imeAction是Send时，用户点击触发，等等。</p>

<h3>特殊形式的输入</h3>

<p>有些特殊的场景是不能够直接把用户的输入文本直接的展现在框里，比如输入密码时，再比如像输入电话号码时，可能会自动在3个数字后面加上短横线。这时就需要用到<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/input/VisualTransformation">VisualTransformation</a>来对文本进行转换处理：</p>

<pre><code class="Kotlin">@Composable
fun PasswordTextField() {
    var password by rememberSaveable { mutableStateOf("") }

    TextField(
        value = password,
        onValueChange = { password = it },
        label = { Text("Enter password") },
        visualTransformation = PasswordVisualTransformation(),
        keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Password)
    )
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-textfield-password.png" alt="password_textfield" /></p>

<h3>文本状态管理</h3>

<p>TextField的文本（text参数）是需要转换成状态的，这样才能更好的触发重组。基础的通用的TextField使用方式是，把文本转成状态，塞给TextField，然后在其onValueChange中再更新此状态：</p>

<pre><code class="Kotlin">    // ...
    var text by remember { mutableStateOf("") }

    TextField(
        value = text,
        onValueChange = { text = it },
    )
    // ...
</code></pre>

<p>但现实的代码不可能这么简单，用户的输入必然会有业务逻辑去处理，所以onValueChange肯定会调用ViewModel去处理用户输入。那么自然也要从ViewModel处获得。但由于TextField的特殊性，仍然要把使用MutableState来定义状态，而不能用响应式的Reactive stream或者StateFlow：</p>

<pre><code class="Kotlin">class SignUpViewModel(private val userRepository: UserRepository) : ViewModel() {

    var username by mutableStateOf("")
        private set

    fun updateUsername(input: String) {
        username = input
    }
}

// SignUpScreen.kt

@Composable
fun SignUpScreen(/*...*/) {

    OutlinedTextField(
        value = viewModel.username,
        onValueChange = { username -&gt; viewModel.updateUsername(username) }
        /*...*/
    )
}
</code></pre>

<h2>文本的选择</h2>

<p>除了文本输入以外，文本显示的选择也视为文字编辑的一种方式，因为选择之后就可以执行复制或者搜索等全局操作。Compose提供了细粒度的可交互式文本显示控制。Text本身是不支持选择的（Not Selectable），自然也就无法复制。可以使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/selection/package-summary#SelectionContainer(androidx.compose.ui.Modifier,kotlin.Function0">SelectableContainer</a>)来包裹Text以实现可选择（Selectable）：</p>

<pre><code class="Kotlin">@Composable
fun SelectableText() {
    SelectionContainer {
        Text("This text is selectable")
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-selected.png" alt="selectable_text" />
并且，可选择区域可以跨多个Text。与之相对的，还有不可选择函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/selection/package-summary#DisableSelection(kotlin.Function0">DisableSelection</a>)，比如一大片可选择文本中，想让某一小块文本不能被选择，这时DisableSelection就派上用场了：</p>

<pre><code class="Kotlin">@Composable
fun PartiallySelectableText() {
    SelectionContainer {
        Column {
            Text("This text is selectable")
            Text("This one too")
            Text("This one as well")
            DisableSelection {
                Text("But not this one")
                Text("Neither this one")
            }
            Text("But again, you can select this one")
            Text("And this one too")
        }
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/text-partially-selected.png" alt="disable_selection" /></p>

<p>可以看出对于文本的选择控制还是相当的灵活的（flexible）。</p>

<h2>富式文本点击</h2>

<p>对于针对 整个文本的点击事件可以用Modifier中的<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/package-summary#(androidx.compose.ui.Modifier">clickable</a>.clickable(kotlin.Boolean,kotlin.String,androidx.compose.ui.semantics.Role,kotlin.Function0))函数来处理，这跟常规的Composable没区别都一样的。但对于文本来说有更为细腻的点击事件处理，包括获取具体点击的光标位置，以及富式文本点击，也即针对 文本中不同部分的响应。</p>

<h3>获取点击的光标位置</h3>

<p>想要获取到文本中点击的光标位置，其实也就是点击的是第几个字符，可以用<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/package-summary#ClickableText(androidx.compose.ui.text.AnnotatedString,androidx.compose.ui.Modifier,androidx.compose.ui.text.TextStyle,kotlin.Boolean,androidx.compose.ui.text.style.TextOverflow,kotlin.Int,kotlin.Function1,kotlin.Function1">ClickableText</a>)，它有一个自己的onClick回调函数，里面的参数是一个offset表示被点击字符的索引：</p>

<pre><code class="Kotlin">@Composable
fun SimpleClickableText() {
    ClickableText(text = AnnotatedString("Click Me"), onClick = { offset -&gt;
        Log.d("ClickableText", "$offset -th character is clicked.")
    })
}
</code></pre>

<p>注意onClick的参数是文本字符串的索引，从0开始。这个索引一般用来确定点击的富文本中的某一个标记（Annotation）。</p>

<h3>富文本的点击处理</h3>

<p>Text是支持富文本的（基于<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/text/AnnotatedString">AnnotatedString</a>）。通过ClickableText中onClick的索引参数，就能知道点击的具体是哪个Annotation。比如一个超链接标记，具体的URL对用户是不可见的，作为额外的Tag信息在Annotation中，通过索引判断当点击到了超链接上面时，可以跳转到此URL：</p>

<pre><code class="Kotlin">@Composable
fun AnnotatedClickableText() {
    val annotatedText = buildAnnotatedString {
        append("Click ")

        // We attach this *URL* annotation to the following content
        // until `pop()` is called
        pushStringAnnotation(
            tag = "URL", annotation = "https://developer.android.com"
        )
        withStyle(
            style = SpanStyle(
                color = Color.Blue, fontWeight = FontWeight.Bold
            )
        ) {
            append("here")
        }

        pop()
    }

    ClickableText(text = annotatedText, onClick = { offset -&gt;
        // We check if there is an *URL* annotation attached to the text
        // at the clicked position
        annotatedText.getStringAnnotations(
            tag = "URL", start = offset, end = offset
        ).firstOrNull()?.let { annotation -&gt;
            // If yes, we log its value
            Log.d("Clicked URL", annotation.item)
        }
    })
}
</code></pre>

<h2>总结</h2>

<p>本文介绍了两种最常规的文本编辑，一是文本输入，一个是文本的选择和点击，这些都是日常项目开发中的非常常见的需求。Jetpack Compose对文本的操作提供了非常友好的支持，能够应付绝大部分的需求场景。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/text/user-input">Handle user input</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/text/user-interactions">Enable user interactions</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『或跃在渊』| Advanced Animations]]></title>
    <link href="http://toughcoder.net/blog/2024/07/24/advanced-animations-in-compose/"/>
    <updated>2024-07-24T08:26:32+08:00</updated>
    <id>http://toughcoder.net/blog/2024/07/24/advanced-animations-in-compose</id>
    <content type="html"><![CDATA[<p>对于Jetpack Compose来说动画是一个很大的话题，对应的API也比较繁杂，我们在<a href="https://juejin.cn/post/7385758285960609831">前面一篇文章</a>中介绍了最为常用的创建动画的方式，在此基础之上来学习一些更为复杂的动画玩法。</p>

<p><a href=""><img src="https://static.wixstatic.com/media/0d004d_3306bc9db6214c459f675f2a417cc718~mv2.jpeg/v1/fit/w_1000%2Ch_600%2Cal_c%2Cq_80/file.jpeg" title="auto auto" ></a></p>

<!-- more -->


<h2>动画的本质：参数随时间变化</h2>

<p>前面的文章提到过属性驱动动画，比如<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/package-summary#animateFloatAsState(kotlin.Float,androidx.compose.animation.core.AnimationSpec,kotlin.Float,kotlin.String,kotlin.Function1">animateFloatAsState</a>)，本质上就是让数值随时间变化，数值再作为Composable的属性去驱动变幻，进而产生动画效果。那一坨animate&#42;AsState都是通过一个animateValueAsState函数来实现的，这个函数是一个泛型，它可以把任意的数据类型转成随时间变化的动画状态。所以当遇到自定义的数据类型时，就可以使用animateValueAsState来驱动动画。这些属性动画函数animate&#42;AsState是基于更底层的<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Animatable">Animatable</a>实现的。</p>

<h2>使用Transition来组合属性动画</h2>

<p>当动画比较复杂时，比如涉及多个属性的变化时，如果仍然使用animate&#42;AsState那一坨，虽然也是可以行的，但会让代码和逻辑都混乱不堪，特别是如果要协调多个属性动画时就更为困难。这样实现还有一个更大的问题，那就是无法复用，理论上来说动画与UI应该解耦，即使没有动效UI也是可用的，动效也应该可以应用于不同的UI。</p>

<p>这时就可以使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Transition">Transition</a>来管理和组合多个属性动画。但是Transition并不是像<a href="https://developer.android.com/reference/android/animation/AnimatorSet">AnimatorSet</a>那样的单纯的管理器，它其实是另一种概念的抽象，意为过渡，从一种状态过渡到另一种状态，状态变化的细节就是各种属性的变化。Transition支持泛型，也就是状态完全自定义，Transition定义了很多变更数值的方法如animateFloat，animateColor，animateDp等等可以用于更新不同的属性数值。前一篇文章中提到的所见即所得的动画函数（AnimatedVisibility，Crossfade和AnimatedContent）都是基于Transition来实现的。而Transition与属性动画函数animate&#42;AsState并不一样，是基于更底层的<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Animation">Animation</a>实现的。</p>

<h3>Transition创建动画的具体步骤</h3>

<p>Transition是对两个不同的状态之间过渡的封装，因此先要定义状态，基于动效的目标和特点定义状态即可，一般用枚举类型就行了，因为状态仅用于代表过渡中的一个时间点，并没有具体的意义。接下来，使用remember函数转成为Compose的State，以便能触发Recomposition，然后调用函数updateTransition来得到当前时刻的过渡状态：</p>

<pre><code class="Kotlin">enum class BoxState {
    Collapsed,
    Expanded
}
var currentState by remember { mutableStateOf(BoxState.Collapsed) }
val transition = updateTransition(currentState, label = "box state")
</code></pre>

<p>这三步是通用的，使用Transition时都一样。然后就是对于当前时刻过渡状态的去定义具体的属性数值，这步也是自定义的，看要实现的动效而定，可以使用扩展函数animate&#42;来得到的具体的数值：</p>

<pre><code class="Kotlin">val rect by transition.animateRect(label = "rectangle") { state -&gt;
    when (state) {
        BoxState.Collapsed -&gt; Rect(0f, 0f, 100f, 100f)
        BoxState.Expanded -&gt; Rect(100f, 100f, 300f, 300f)
    }
}
val borderWidth by transition.animateDp(label = "border width") { state -&gt;
    when (state) {
        BoxState.Collapsed -&gt; 1.dp
        BoxState.Expanded -&gt; 0.dp
    }
}
</code></pre>

<p>最后，把得到的属性数值rect和borderWidth应用到Composable上即可。</p>

<h3>Transition是支持创建子Transition</h3>

<p>对于Composable结构复杂的情况时，还可以使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Transition#(androidx.compose.animation.core.Transition">createChildTransition</a>.createChildTransition(kotlin.String,kotlin.Function1))来为子布局创建Transition。这样就能够把Transition也按树形关系组织起来，以能让动效更加的协调。</p>

<h3>使用Transition来封装动画</h3>

<p>使用Transition最大的好处在于能够把动效封装起来以能复用：</p>

<pre><code class="Kotlin">enum class BoxState { Collapsed, Expanded }

// Holds the animation values.
private class TransitionData(
    color: State&lt;Color&gt;,
    size: State&lt;Dp&gt;
) {
    val color by color
    val size by size
}

// Create a Transition and return its animation values.
@Composable
private fun updateTransitionData(boxState: BoxState): TransitionData {
    val transition = updateTransition(boxState, label = "box state")
    val color = transition.animateColor(label = "color") { state -&gt;
        when (state) {
            BoxState.Collapsed -&gt; Color.Gray
            BoxState.Expanded -&gt; Color.Red
        }
    }
    val size = transition.animateDp(label = "size") { state -&gt;
        when (state) {
            BoxState.Collapsed -&gt; 64.dp
            BoxState.Expanded -&gt; 128.dp
        }
    }
    return remember(transition) { TransitionData(color, size) }
}
</code></pre>

<p>创建好的Transition可以用于任意的Composable：</p>

<pre><code class="Kotlin">@Composable
fun AnimatingBox(
    modifier: Modifier = Modifier.fillMaxSize()
) {
    var boxState by remember { mutableStateOf(BoxState.Expanded) }
    val transitionData = updateTransitionData(boxState)
    // UI tree
    Box(
        modifier = Modifier
            .background(transitionData.color)
            .size(transitionData.size)
            .clickable {
                boxState =
                    if (boxState == BoxState.Expanded) BoxState.Collapsed else BoxState.Expanded
            }
    )
}

@Composable
fun AnimatingColumn(
    modifier: Modifier = Modifier.fillMaxSize()
) {
    var boxState by remember { mutableStateOf(BoxState.Collapsed) }

    LaunchedEffect(Unit) {
        boxState = BoxState.Expanded
    }

    val transitionData = updateTransitionData(boxState)
    Column(
        modifier = Modifier
            .background(transitionData.color)
            .size(transitionData.size)
    ) {
        Text("Apply to a column")
    }
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/animation/anim_transition.gif" alt="transition_demo" /></p>

<p>可以看一看<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#AnimatedVisibility(kotlin.Boolean,androidx.compose.ui.Modifier,androidx.compose.animation.EnterTransition,androidx.compose.animation.ExitTransition,kotlin.Function1">AnimatedVisibility</a>)以及<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#Crossfade(kotlin.Any,androidx.compose.ui.Modifier,androidx.compose.animation.core.FiniteAnimationSpec,kotlin.String,kotlin.Function1">Crossfade</a>)和<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#AnimatedContent(kotlin.Any,androidx.compose.ui.Modifier,kotlin.Function1,androidx.compose.ui.Alignment,kotlin.Function2">AnimatedContent</a>)的实现，它们都是基于Transition实现的。</p>

<h2>动画的底层API</h2>

<p>到现在我们已经学习了很多创建动画的方式，从封装的层次来说，最上层是所见即所得动画函数如AnimatedVisibility，Crossfade和AnimatedContent，它们是基于<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Transition">Transition</a>实现的；属性动画函数animate&#42;AsState是基于Animatable实现的。这些函数都是Composables，也就是必须在Composition环境中才能使用。而Animatable和Transition都是基于最底层的Animation实现的，Animatable和Animation类似于View系统中的<a href="https://developer.android.com/reference/android/animation/Animator">Animator</a>，管理着某种值随时间在两个状态之间变化。它们两个只与值和时间有关，与Composition无关，因此可以在任意上下文中使用。可以用官方提供的一张图，来搞清楚API之间的关系：</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/animation-low-level.svg" alt="anim_api_level" /></p>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Animation">Animation</a>是最为底层的API，它只管理着值随时间的变化，其余的事情像动画是否已开始，是否已结束都需要调用者自己管理。它使用起来相当的麻烦，除非有必要否则一般不建议直接使用这个对象，本文也不再讨论它。</p>

<p>可以重点研究一下<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Animatable">Animatable</a>，它是基于Animation的，但是封装的较为完整。它是基于协程的单个数值变化动画，它能保证数值的变化是连续的，不过它的主要方法如<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Animatable#animateTo(kotlin.Any,androidx.compose.animation.core.AnimationSpec,kotlin.Any,kotlin.Function1">animateTo</a>)都是suspend的，意味着要在协程上下文中调用，比如启动动画就要用Animatable：</p>

<pre><code class="Kotlin">val color = remember { Animatable(Color.Gray) }
LaunchedEffect(ok) {
    color.animateTo(if (ok) Color.Green else Color.Red)
}
Box(Modifier.fillMaxSize().background(color.value))
</code></pre>

<p>使用Animatable可以创建出很多富有创意的复杂动画，比如说多米诺式的顺次动画，以及并发动画。</p>

<h3>多个部件顺次动画</h3>

<p>多个部件的顺次动画也就是依次发生的动画，比如A，B，和C三个动画作用于不同的UI部件，A先启动，结束后B接着启动，结束后C再启动。比较常规的方式是使用动画回调，在前一个的结束回调中启动下一个，或者使用延时启动，B的启动延时设置为A的动画时长。</p>

<p>借助于Animatable，可以有更为优雅的方案，在同一个协程中依次调用不同的Animatable的animateTo函数就可以，让几个不同的Animatable依次启动了：</p>

<pre><code class="Kotlin">val alphaAnimation = remember { Animatable(0f) }
val yAnimation = remember { Animatable(0f) }

LaunchedEffect("animationKey") {
    alphaAnimation.animateTo(1f)
    yAnimation.animateTo(100f)
    yAnimation.animateTo(500f, animationSpec = tween(100))
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/animations/multiple_properties_sequential.gif" alt="anim_sequential_flow" />
注意，这个动图展示的是顺次动画的流程图，而非一个案例的效果。</p>

<h3>多个部件并发动画</h3>

<p>类似的还有并发动画，就是作用于多个不同的部件的动画同时启动，这个其实相较于顺次动画要容易一些，因为我们用Transition组合多个属性动画实际上就是并发动画。</p>

<p>除了Transition以外，用多个Animatable也可以，我们只需要启动多个协程去执行animateTo即可：</p>

<pre><code class="Kotlin">val alphaAnimation = remember { Animatable(0f) }
val yAnimation = remember { Animatable(0f) }

LaunchedEffect("animationKey") {
    launch {
        alphaAnimation.animateTo(1f)
    }
    launch {
        yAnimation.animateTo(100f)
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/animations/multiple_properties.gif" alt="anim_concurrent_flow" />
注意，这个是并发动画的流程图，而非动画效果。</p>

<h2>集合性布局中的元素项动画</h2>

<p>对于集合性布局来说，当其元素项发生变化时，会触发相应的动画效果，这就是<a href="https://developer.android.com/develop/ui/compose/lists#item-animations">item animations</a>。我们只需要1）为每个子元素项定义一个集合中唯一标识的key；2）然后再调用扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/lazy/LazyItemScope#(androidx.compose.ui.Modifier">Modifier.aniamteItem</a>.animateItem(androidx.compose.animation.core.FiniteAnimationSpec,androidx.compose.animation.core.FiniteAnimationSpec,androidx.compose.animation.core.FiniteAnimationSpec))；即可以在元素项变化时触发动画，它会子元素项出现，消失和发生替换时触发动画效果。</p>

<h2>动画最佳实践</h2>

<p>我们学习了这么多创建动画的方式，在实际项目中要遵守几个原则：1）尽可能优先使用Compose封装好的动画函数，不要重复造轮子；2）第二个就是要为每个动画设置一个label，所有的动画API都会有一个label参数，要尽可能为每个动画设置一个唯一的label，这个是用于Android Studio调试动画时的唯一标识。</p>

<p>再有就是动画会触发Recomposition，re-layout和re-draw，为了尽可能的避免减少re-layout和re-draw，要尽可能的使用已封装好的函数来修改属性，比如使用Modifier的扩展函数（如<a href="https://developer.android.com/develop/ui/compose/graphics/draw/modifiers">Modifier.graphicsLayer {}</a>），而不是直接去改size或者padding。</p>

<h2>References</h2>

<ul>
<li><a href="https://proandroiddev.com/animating-inside-and-outside-the-box-with-jetpack-compose-a56eba1b6af6">Animating Inside and Outside the Box with Jetpack Compose</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/value-based">Value-based animations</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/vectors">Animated vector images in Compose</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/advanced">Advanced animation example: Gestures</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『震惊百里』| Animations]]></title>
    <link href="http://toughcoder.net/blog/2024/07/24/compose-animation-basics/"/>
    <updated>2024-07-24T07:59:35+08:00</updated>
    <id>http://toughcoder.net/blog/2024/07/24/compose-animation-basics</id>
    <content type="html"><![CDATA[<p>动画对于UI来说无疑是最重要的核心功能，它能够让UI变得生动有吸引力。适当的使用动画可以提升UI的流畅性，让UI体验更为顺滑。在Jetpack Compose中有丰富的函数可以用来实现动画，今天就从一些最为常用的学起，闲话就说这么多，赶紧开工。</p>

<p><a href=""><img src="https://koenig-media.raywenderlich.com/uploads/2020/09/JetpackComposeAnimations-twitter.png" title="auto auto" ></a></p>

<!-- more -->


<h2>所见即所得的动画函数</h2>

<p>最为方便和快速上手的就是使用封装的最好的动画函数（Animation Composables）。</p>

<h3>给Composable出现和隐藏加上动画</h3>

<p>UI元素的出现和隐藏是动画最为常用的场景，让视觉体验平滑过度，不那么的突兀。使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#AnimatedVisibility(androidx.compose.animation.core.MutableTransitionState,androidx.compose.ui.Modifier,androidx.compose.animation.EnterTransition,androidx.compose.animation.ExitTransition,kotlin.String,kotlin.Function1">函数AnimatedVisibility</a>)就可以方便的给单个部件的出现和隐藏加上动画：</p>

<pre><code class="Kotlin">        var visible by remember {
            mutableStateOf(true)
        }

        AnimatedVisibility(visible) {
            Box(
                modifier = Modifier
                    .size(200.dp)
                    .clip(RoundedCornerShape(8.dp))
                    .background(colorGreen)
            )        
        }

        Button(modifier = Modifier.align(Alignment.BottomCenter), onClick = {
            visible = !visible
        }) {
            Text("Toggle Show/Hide")
        }
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/animations/animated_visibility_column.gif" alt="anim_visibility" /></p>

<p><strong>注意：</strong>AnimatedVisibility做完淡出动画时，会把其子布局从渲染树中移除。</p>

<p>AnimatedVisibility默认会使用淡入（fadeIn）/淡出（fadeOut）+缩放（shrinking）作为内容的出现/隐藏动画，如果要指定不同的动画，可以通过参数enter和参数exit来指定。<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/EnterTransition">EnterTransition</a>和<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/ExitTransition">ExitTransition</a>有很多<a href="https://developer.android.com/develop/ui/compose/animation/composables-modifiers#enter-exit-transition">预定义的动画</a>可以使用，并且可以通过+进行组合：</p>

<pre><code class="Kotlin">var visible by remember { mutableStateOf(true) }
val density = LocalDensity.current
AnimatedVisibility(
    visible = visible,
    enter = slideInVertically {
        // Slide in from 40 dp from the top.
        with(density) { -40.dp.roundToPx() }
    } + expandVertically(
        // Expand from the top.
        expandFrom = Alignment.Top
    ) + fadeIn(
        // Fade in with the initial alpha of 0.3f.
        initialAlpha = 0.3f
    ),
    exit = slideOutVertically() + shrinkVertically() + fadeOut()
) {
    Text("降Compose十八掌", Modifier.fillMaxWidth().height(200.dp))
}
</code></pre>

<p>仔细看AnimatedVisibility的实现，不难发现，它其实相当于是一个Column，可以当成一个Column来使用，动画是加在此布局上面的。它还支持对其子布局设置单独的动画。可以使用这个扩展函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/AnimatedVisibilityScope#(androidx.compose.ui.Modifier">animateEnterExit</a>.animateEnterExit(androidx.compose.animation.EnterTransition,androidx.compose.animation.ExitTransition,kotlin.String))来对子布局的出现/隐藏加上特定的动画：</p>

<pre><code class="Kotlin">@Composable
fun CustomForChildren(modifier: Modifier = Modifier.fillMaxSize()) {
    Column(
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        var visible by remember { mutableStateOf(true) }

        AnimatedVisibility(
            visible = visible,
            enter = fadeIn(),
            exit = fadeOut()
        ) {
            // Fade in/out the background and the foreground.
            Box(
                Modifier
                    .fillMaxWidth()
                    .height(200.dp)
                    .background(Color.LightGray)) {
                Box(
                    Modifier
                        .align(Alignment.Center)
                        .animateEnterExit(
                            // Slide in/out the inner box.
                            enter = slideInHorizontally(),
                            exit = slideOutHorizontally()
                        )
                        .sizeIn(minWidth = 256.dp, minHeight = 64.dp)
                        .background(Color.Magenta)
                ) {
                    Text(
                        text = "你会看到不同的风景！",
                        style = MaterialTheme.typography.headlineLarge,
                        modifier = Modifier
                            .padding(16.dp)
                            .align(Alignment.Center)
                    )
                }
            }
        }

        Button(
            onClick = { visible = !visible },
            modifier = Modifier.padding(16.dp)
        ) {
            Text("点击有惊喜！！！")
        }
    }
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/animation/custom_for_children.gif" alt="children_enter_exit" /></p>

<h3>两个布局之间淡入淡出</h3>

<p>AnimatedVisibility只能用于单个部件或者单个布局的出现隐藏。但有时会涉及两个部件之间的切换，虽然也是一个出现，前一个隐藏，但它们是有联动的，这时就需要使用专门的切换动画函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#(androidx.compose.animation.core.Transition">Crossfade</a>.Crossfade(androidx.compose.ui.Modifier,androidx.compose.animation.core.FiniteAnimationSpec,kotlin.Function1,kotlin.Function1))，最为典型的场景就是加载内容，先是显示加载进度，有数据可显示时就把进度隐藏，让内容显示：</p>

<pre><code class="Kotlin">@Composable
fun CrossfadeDemo(modifier: Modifier = Modifier.fillMaxSize()) {
    var done by remember { mutableStateOf(false) }

    LaunchedEffect(Unit) {
        delay(5000)
        done = true
    }

    Crossfade(
        modifier = modifier,
        targetState = !done,
        label = "crossfade"
    ) { loading -&gt;
        Box(
            modifier = Modifier.fillMaxSize(),
            contentAlignment = if (loading) Alignment.Center else Alignment.TopStart
        ) {
            if (loading) {
                Column(horizontalAlignment = Alignment.CenterHorizontally) {
                    CircularProgressIndicator(Modifier.size(66.dp))
                    Text(
                        text = "玩命加载中...",
                        modifier = Modifier.padding(16.dp),
                        style = MaterialTheme.typography.headlineMedium
                    )
                }
            } else {
                Text(
                    text =
                    """
                       “降龙十八掌可说是【武学中的巅峰绝诣】，当真是无坚不摧、无固不破。虽招数有限，但每一招均具绝大威力。
                        北宋年间，丐帮帮主萧峰以此邀斗天下英雄，极少有人能挡得他三招两式，气盖当世，群豪束手。
                        当时共有“降龙廿八掌”，后经萧峰及他义弟虚竹子删繁就简，取精用宏，改为降龙十八掌，掌力更厚。
                        这掌法传到洪七公手上，在华山绝顶与王重阳、黄药师等人论剑时施展出来，王重阳等尽皆称道。”
                    """.trimIndent(),
                    modifier = Modifier.padding(16.dp),
                    style = MaterialTheme.typography.headlineMedium
                )
            }
        }
    }
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/animation/crossfade.gif" alt="crossfade" /></p>

<h3>通用的布局切换动画</h3>

<p>如果变幻不止有淡入淡出，或者说布局不只有两个，这时就要用更为通用也更为强大的切换动画函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#AnimatedContent(kotlin.Any,androidx.compose.ui.Modifier,kotlin.Function1,androidx.compose.ui.Alignment,kotlin.Function2">AnimatedContent</a>)，它可以用来定制多个布局之间两两切换的动画：</p>

<pre><code class="Kotlin">var state by remember {
    mutableStateOf(UiState.Loading)
}
AnimatedContent(
    state,
    transitionSpec = {
        fadeIn(
            animationSpec = tween(3000)
        ) togetherWith fadeOut(animationSpec = tween(3000))
    },
    modifier = Modifier.clickable(
        interactionSource = remember { MutableInteractionSource() },
        indication = null
    ) {
        state = when (state) {
            UiState.Loading -&gt; UiState.Loaded
            UiState.Loaded -&gt; UiState.Error
            UiState.Error -&gt; UiState.Loading
        }
    },
    label = "Animated Content"
) { targetState -&gt;
    when (targetState) {
        UiState.Loading -&gt; {
            LoadingScreen()
        }
        UiState.Loaded -&gt; {
            LoadedScreen()
        }
        UiState.Error -&gt; {
            ErrorScreen()
        }
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/animations/animated_content_slower.gif" alt="animated_content" /></p>

<h2>尺寸改变动画</h2>

<p>UI元素的尺寸变化也是非常常用的一类动画，通常作为出场和入场比较合适。对于尺寸的改变可以通过<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/package-summary#(androidx.compose.ui.Modifier">Modifier.animateContentSize</a>.animateContentSize(androidx.compose.animation.core.FiniteAnimationSpec,kotlin.Function2))来实现。它会自己感知尺寸的变化，然后触发动画。可以设置一个参数finishedListener以接收动画做完了的通知。需要特别注意的是，<strong>调用的顺序很重要，animateContentSize必须在任何的尺寸设置之前</strong>，还要注意的是尺寸必须根据不同的条件有所变化，要不然动画没机会展示：</p>

<pre><code class="Kotlin">var expanded by remember { mutableStateOf(false) }
Box(
    modifier = Modifier
        .background(colorBlue)
        .animateContentSize()
        .height(if (expanded) 400.dp else 200.dp)
        .fillMaxWidth()
        .clickable(
            interactionSource = remember { MutableInteractionSource() },
            indication = null
        ) {
            expanded = !expanded
        }

)
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/animations/animated_content_size.gif" alt="" /></p>

<h2>属性状态驱动动画</h2>

<p>一般来说，动画的本质是让参数随时间变化，然后再让UI元素响应这些参数的变化，通过重新渲染，或者做渲染图层的变幻。在Compose中参数变化想影响部件的渲染，就必须把其封装成状态（State），这样参数变化就能被Compose感知到并做Recomposition。然后我们把状态的变化再通过属性设置给Composables，让其做渲染或者变幻，就形成了动画效果。这就是属性动画。</p>

<p>Compose定义了很多方法可以把参数转变成为状态，不同的参数可以通过不同的函数作用于不同的属性：</p>

<h3><a href="https://developer.android.com/develop/ui/compose/animation/value-based#animate-as-state">animateFloatAsState</a></h3>

<p>可以把值的类型为浮点数的属性变为状态驱动动画，比如透明度（alpha），尺寸（size），间隔（padding/offset），字体大小（textSize）以及像旋转/缩放/位移等等。只要是浮点类型就可以用这个来转成状态，然后再通过相应的属性设置给Composable即可。</p>

<p>最为常用的就是结合graphicsLayer图层做变幻：</p>

<pre><code class="Kotlin">@Composable
fun PropertyAnimation(modifier: Modifier = Modifier.fillMaxSize()) {
    var showing by remember { mutableStateOf(false) }

    val scale by animateFloatAsState(
        targetValue = if (showing) 0f else 1f,
        label = "property"
    )
    val alpha by animateFloatAsState(
        targetValue = if (showing) 0f else 1f,
        label = "property"
    )
    Column(
        modifier = Modifier.padding(20.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
    ) {
        Text(
            text = "降Compose十八掌",
            modifier = Modifier
                .padding(20.dp)
                .graphicsLayer {
                    this.alpha = alpha
                    scaleX = scale
                    scaleY = scale
                },
            style = MaterialTheme.typography.headlineLarge
        )
        Spacer(Modifier.height(50.dp))
        Button(onClick = { showing = !showing}) {
            Text("再点一下试试！（试试就试试！）")
        }
    }
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/animation/property.gif" alt="property_state" /></p>

<p>至于其他的像尺寸和间隔，虽然也可以，但因为像padding和offset会直接用dp或者Offset作为值，有更为舒适的API可以直接用（尽管浮点值也可以转换成为dp或者Offset）。</p>

<h3>animateColorAsState</h3>

<p>专门用于颜色值变化，指定两个值后，会在它们中间进行的插值作为动画的帧，能让颜色变化更为平滑和细腻。</p>

<h3>animateIntOffsetAsState</h3>

<p>用于把值Offset的变化变成动画，适合于使用Offset的地方，如Modifier.offset，Modifier.layout等。</p>

<h3>animateDpAsState</h3>

<p>把类型为Dp的值变为动画，适合所有能使用Dp作为参数值的地方，如padding，shadowElavation等。</p>

<p>小结：可以发现由属性状态驱动的动画使用起来比较麻烦，先是要把参数转化为状态，要管理好不同状态下参数的值，还要使用正确的函数把状态作用于Composable的属性。复杂的同时意味着强大，它能实现一些更为复杂的动画。推荐优先使用动画函数，如果无法满足再考虑用属性状态动画。</p>

<h2>页面切换转场动画</h2>

<p>页面是应用中较为完整的一屏UI，比如说新闻应用，列表页是一个页面，点开进入单篇新闻又是一个页面，用户中心是一个页面，设置又是一个页面。不同的页面之间的跳转称之为导航，用的是Jetpack中的库navigation，在Compose中通过navigation-compose做了桥接，所以在Compose中可以直接使用navigation，可以通过创建NavHost时通过参数enterTransition和exitTransition来为页面设置转场动画。可以为每个页面设置单独的转场，也可以设置一个统一的默认的转场动画：</p>

<pre><code class="Kotlin">val navController = rememberNavController()
NavHost(
    navController = navController, startDestination = "landing",
    enterTransition = { EnterTransition.None },
    exitTransition = { ExitTransition.None }
) {
    composable("landing") {
        ScreenLanding(
            // ...
        )
    }
    composable(
        "detail/{photoUrl}",
        arguments = listOf(navArgument("photoUrl") { type = NavType.StringType }),
        enterTransition = {
            fadeIn(
                animationSpec = tween(
                    300, easing = LinearEasing
                )
            ) + slideIntoContainer(
                animationSpec = tween(300, easing = EaseIn),
                towards = AnimatedContentTransitionScope.SlideDirection.Start
            )
        },
        exitTransition = {
            fadeOut(
                animationSpec = tween(
                    300, easing = LinearEasing
                )
            ) + slideOutOfContainer(
                animationSpec = tween(300, easing = EaseOut),
                towards = AnimatedContentTransitionScope.SlideDirection.End
            )
        }
    ) { backStackEntry -&gt;
        ScreenDetails(
            // ...
        )
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/animations/navigation_compose_animation.gif" alt="navigation_transition" /></p>

<h2>组合首次运行时动画</h2>

<p>对于像AnimatedVisibility以及使用animate&42;AsState属性状态动画来说，可以发现它们都是在组合发生之后才能生效，这是因为状态是为了重组而设置的，状态只会在组合之后部件渲染完了，响应事件由事件触发状态变化。组合首次运行的时候，状态仅是初始值，但不会变化，也就不会触发动画。</p>

<p>所以需要一个能在首次组合时就能运行的事件来触发动画依赖的状态，<a href="https://developer.android.com/develop/ui/compose/side-effects#launchedeffect">LaunchedEffect</a>正合适。LaunchedEffect会在首次组合时运行，可以在里面执行一些「副作用」也就是Compose组合之外的行为。可以在这里触发动画的状态，就能够让动画在首次组合时生效了。这一般用作部件的出场动画：</p>

<pre><code class="Kotlin">@Composable
fun LaunchAnimation(modifier: Modifier = Modifier.fillMaxSize()) {
    val alphaAnimation = remember {
        Animatable(0f)
    }
    LaunchedEffect(Unit) {
        alphaAnimation.animateTo(
            targetValue = 1f,
            animationSpec = tween(durationMillis = 30000)
        )
    }
    Box(
        modifier = Modifier
            .offset(16.dp, 16.dp)
            .size(200.dp)
            .graphicsLayer {
                alpha = alphaAnimation.value
            }
            .background(Color.Magenta)
    )
}
</code></pre>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/animation/launch_anim.gif" alt="launch_anim" />
<strong>需要注意</strong>，LaunchedEffect的参数用作标识，参数有变化时，会再次运行，因此对于出场动画，LaunchedEffect的参数要设置为不可变的常量，如Unit。还需要注意的是，LaunchedEffect会在首次组合时运行，对于像集合性布局，会重复的使用子布局来展示元素项，所以每次元素项进入屏幕可视范围时，LaunchedEffect都会运行，动画都会触发，这并不是想要的结果，因为我们只想列表首次加载时触发动画。一个解决办法就是把状态和LaunchedEffect提高到列表的上一级Composable中。</p>

<h2>调整动画参数进行定制</h2>

<p>动画除了具体的形式以外，还有一些共性的参数可以设置，像时长，速度和是否重复，有过View动画经验的同学对此一定不会陌生。可以通过<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/AnimationSpec">AnimationSpec</a>对象来对动画参数进行定制，所有的动画API都能接受一个animationSpec参数。Compose提供了很多AnimationSpec的构造函数可以直接使用：</p>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/animation/customize#spring">spring</a> 刚性动画（或者叫做弹性动画）是模拟物理中刚性物体运动和碰撞的动画，与生活中的体验类似，所以这是默认的动画参数。可以通过调整硬度（stiffness）和阻尼系数（dampingRatio）来改变动画效果。</li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/customize#tween">tween</a> 补间动画，有一定时长，在两个值之间通过Easing函数插值形成的动画。</li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/customize#keyframes">keyframes</a> 关键帧动画，指定一定的关键节点作为动画中的帧。</li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/customize#repeatable">repeatable</a> 可重复一定次数的动画，通过RepeatMode指定重复方式（简单重复，或者反向播放）。</li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/customize#infiniterepeatable">infiniteRepeatable</a> 无限重复动画，通过RepeatMode指定重复方式。</li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/customize#snap">snap</a> 猛跳到目标值，无动画。</li>
</ul>


<p>根据不同的动画参数，可以进一步的做更细致的参数调整，比如像时长和速度。</p>

<h3>修改动画的时长和延时</h3>

<p>动画肯定都有时长，即使无限重复的动画，其每一次也是有时长的。大部分AnimationSpec函数都能接受一个durationMillis参数来调整动画的时长。</p>

<p>动画被触发后，也不一定立马播放，参数本身有一个延时可以控制，大部分都能接受一个delayMilis参数来控制播放的延时。</p>

<p>注意，刚性动画（spring）比较特殊，它不能直接控制时长和延时，刚性动画是通过硬度和阻尼来调整，时长是根据它们计算出来的，而物理世界的刚硬碰撞哪有延时？</p>

<h3>修改动画的播放速度</h3>

<p>对于补间动画和关键帧动画，还可以通过Easing函数来改变动画的播放速度，比如匀速，先快后慢，先慢后快，匀速等等。Easing函数与View动画中的<a href="https://developer.android.com/reference/android/graphics/Interpolator">Interpolator</a>是同样的东西。它是一个简单的数学函数，一个浮点数输入代表当前的时间点，一个浮点数输出代表动画应该到达的位置，取值都是0到1之间。可以理解为物理题，输入参数是时间t，输出则是位移s。</p>

<p>有很多定义好的<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/package-summary#Ease(">Easing函数</a>)可以使用，当然也可以自定义：</p>

<pre><code class="Kotlin">val CustomEasing = Easing { fraction -&gt; fraction * fraction }

@Composable
fun EasingUsage() {
    val value by animateFloatAsState(
        targetValue = 1f,
        animationSpec = tween(
            durationMillis = 300,
            easing = CustomEasing
        )
    )
    // ……
}
</code></pre>

<h2>未完待续</h2>

<p>动画是UI中比较复杂的话题，在Compose中更是如此，动画的本质是把参数转成状态随时间变化，状态再去驱动部件做渲染或者做变幻。本文总结了最常用的和封装层次较为高级的创建动画的方法，足以应付较为常见的动画需求场景。但涉及动画的内容还有很多，比如像与手势交互相关的动画，多个不同的部件联动的动画，以及像动画的性能调优等一些较复杂的话题，将在后续的文章中讲解。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/animation/quick-guide">Quick guide to Animations in Compose</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/composables-modifiers">Animation modifiers and composables</a></li>
<li><a href="https://medium.com/@silaelijah/animations-in-jetpack-compose-60d90a322ca3">Animations In Jetpack Compose</a></li>
<li><a href="https://medium.com/@android-world/jetpack-compose-animation-for-beginners-a-step-by-step-guide-58f1215b7c2c">Jetpack Compose Animation for Beginners: A Step-by-Step Guide</a></li>
<li><a href="https://www.jetpackcompose.net/jetpack-compose-animations">Jetpack Compose Animations</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/animation/customize">Customize animations</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『突如其来』| Graphics Modifiers]]></title>
    <link href="http://toughcoder.net/blog/2024/06/26/graphics-with-modifiers/"/>
    <updated>2024-06-26T22:14:14+08:00</updated>
    <id>http://toughcoder.net/blog/2024/06/26/graphics-with-modifiers</id>
    <content type="html"><![CDATA[<p>在Jetpack Compose中创建自定义绘制内容的方式不止一种，除了前面提到的<a href="https://juejin.cn/post/7381826917086920742">通过Canvas函数的方式</a>以外，还可以通过Modifier的几个扩展函数更为灵活实现一些的自定义内容。今天就来学习一下如何使用Modifier的扩展函数来绘制自定义内容。</p>

<p><a href=""><img src="https://files.koenig.kodeco.com/uploads/2023/11/GraphicsJetpackCompose-twitter.png" title="auto auto" ></a></p>

<!-- more -->


<h2>使用Modifier来叠加自定义内容</h2>

<p>先用一个简单的实例来看一下，如何用Modifier来实现一个自定义内容：</p>

<pre><code class="Kotlin">    val textMeasurer = rememberTextMeasurer()

    Box(
        modifier = Modifier.fillMaxSize()
            .padding(16.dp)
            .drawWithContent {
                drawRect(Color.LightGray)

                drawText(
                    textMeasurer = textMeasurer,
                    text = "降Compose十八掌",
                    topLeft = Offset(size.width / 4f, size.height / 2.2f)
                )

                drawCircle(
                    color = Color.Magenta,
                    radius = size.width / 10f,
                    center = Offset(size.width / 1.8f, size.height / 3f)
                )
                drawCircle(
                    color = Color.Yellow,
                    radius = size.width / 12f,
                    center = Offset(size.width / 1.6f, size.height / 4.5f)
                )
                drawCircle(
                    color = Color.Green,
                    radius = size.width / 14f,
                    center = Offset(size.width / 1.46f, size.height / 7f)
                )
            }
    )
</code></pre>

<p><img src="file:///Users/alexhilton/Desktop/hello_graphics_modifer.png" alt="hello_graphics_modifier" /></p>

<p>可以看到使用Modifier方式与Canvas略不一样，它要应用到其他的Composable上面，所以Modifier方式主要用于<strong>修改或者增强</strong>现有的Composable以达到想要的效果。仍是提供了一个带有<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/drawscope/DrawScope">DrawScope</a>指针的lambda，在这里写绘制指令。</p>

<p>Modifier提供的自定义绘制方式有四种：drawWithContent，drawBehind，drawWithCache和graphicsLayer。前面三种是是针对绘制的扩展，也就是影响绘制的内容；最后一个是图形的扩展，也就是主要用于已经绘制好了的内容的变幻。</p>

<h2>覆写式绘制</h2>

<p>最核心的扩展函数就是<a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/draw/package-summary#(androidx.compose.ui.Modifier">Modifier.drawWithContent</a>.drawWithContent(kotlin.Function1))，它可以让你在目标Composable的内容绘制前或者绘制后，执行一些DrawScope的绘制命令来进行自定义的绘制。也就是说，这个扩展函数可以你让自由的决定在目标Composable绘制之前前或者绘制之后，执行自己想要的绘制命令，以实现一些额外的自定义效果。不过，要记得调用drawContent函数，这个函数是目标Composable的内容绘制函数，当然也可以不调用，那样就变成纯的自定义Composable了。</p>

<p>来看一个猫眼效果：</p>

<pre><code class="Kotlin">@Composable
fun DrawContentDemo(modifier: Modifier = Modifier.fillMaxSize()) {
    var pointerOffset by remember {
        mutableStateOf(Offset(0f, 0f))
    }
    Column(
        modifier = Modifier
            .fillMaxSize()
            .pointerInput("dragging") {
                detectDragGestures { change, dragAmount -&gt;
                    pointerOffset += dragAmount
                }
            }
            .onSizeChanged {
                pointerOffset = Offset(it.width / 2f, it.height / 2f)
            }
            .drawWithContent {
                drawContent()
                // draws a fully black area with a small keyhole at pointerOffset that’ll show part of the UI.
                drawRect(
                    Brush.radialGradient(
                        listOf(Color.Transparent, Color.Black),
                        center = pointerOffset,
                        radius = 100.dp.toPx(),
                    )
                )
            }
    ) {
        Text(
            text =
            """
                “降龙十八掌可说是【武学中的巅峰绝诣】，当真是无坚不摧、无固不破。虽招数有限，但每一招均具绝大威力。
                北宋年间，丐帮帮主萧峰以此邀斗天下英雄，极少有人能挡得他三招两式，气盖当世，群豪束手。
                当时共有“降龙廿八掌”，后经萧峰及他义弟虚竹子删繁就简，取精用宏，改为降龙十八掌，掌力更厚。
                这掌法传到洪七公手上，在华山绝顶与王重阳、黄药师等人论剑时施展出来，王重阳等尽皆称道。”
            """.trimIndent(),
            modifier = Modifier
                .padding(16.dp)
                .drawWithCache {
                    val brush = Brush.linearGradient(
                        listOf(
                            Color(0xFF9E8240),
                            Color(0xFF42A565),
                            Color(0xFFE2E575)
                        )
                    )
                    onDrawBehind {
                        drawRoundRect(
                            brush,
                            cornerRadius = CornerRadius(10.dp.toPx())
                        )
                    }
                }
                .padding(16.dp),
            style = MaterialTheme.typography.headlineMedium
        )
    }
}
</code></pre>

<p><img src="file:///Users/alexhilton/Desktop/draw_content.gif" alt="cat_eye" /></p>

<h2>背景式绘制</h2>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/draw/package-summary#(androidx.compose.ui.Modifier">Modifier.drawBehind</a>.drawBehind(kotlin.Function1))是在目标Composable内容的下面一层（更远离用户的方向）执行绘制命令，所以方便添加一些背景：</p>

<pre><code class="Kotlin">Box {
        Text(
            "降Compose十八掌!",
            modifier = Modifier
                .padding(16.dp)
                .drawBehind {
                    drawRoundRect(
                        Color(0xFFBBAAEE),
                        cornerRadius = CornerRadius(10.dp.toPx())
                    )
                }
                .padding(8.dp),
            style = MaterialTheme.typography.headlineLarge
        )
    }
</code></pre>

<p><img src="file:///Users/alexhilton/Desktop/draw_behind.png" alt="" /></p>

<h2>缓存式绘制</h2>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/draw/package-summary#(androidx.compose.ui.Modifier">Modifier.drawWithCache</a>.drawWithCache(kotlin.Function1))能够缓存在lambda内部创建的一些对象，这主要是为了提升性能的。有过View经验的同学一定知道在自定义View的时候不能在onDraw里面创建对象，因为这会影响性能。这个函数的用途也在于此，把一些对象缓存起来，避免多次创建，以提升渲染性能。</p>

<p>需要注意的是，这些缓存对象的生命周期是画面尺寸未改变，以及创建对象依赖的状态没有变化，也就是说一旦画面有改变，或者依赖的状态有变化，那么缓存失效，对象要被重新创建。</p>

<p>注意，这个函数主要用于与绘制命令强相关的，或者说仅在绘制命令范围内使用的对象，如颜色啊，画刷（Brush），着色器（Shader）啊，路径（Path）啊之类的。</p>

<pre><code class="Kotlin">Box {
        Text(
            "降Compose十八掌!",
            modifier = Modifier
                .padding(16.dp)
                .drawWithCache {
                    val brush = Brush.linearGradient(
                        listOf(
                            Color(0xFF9E82F0),
                            Color(0xFF42A5F5),
                            Color(0xFFE2E575)
                        )
                    )
                    onDrawBehind {
                        drawRoundRect(
                            brush,
                            cornerRadius = CornerRadius(10.dp.toPx())
                        )
                    }
                }
                .padding(16.dp),
            style = MaterialTheme.typography.headlineLarge
        )
    }
</code></pre>

<p><img src="file:///Users/alexhilton/Desktop/drawcache_demo.png" alt="caceh_demo" /></p>

<p>还要注意与状态（State）的区别，使用remember函数可以创建状态，这些状态的生命周期也是能跨越函数的，这也相当于是缓存。但状态的目的是让Compose感知数据变化，进面进行重组（ReComposition）。把与绘制强相关的对象放在状态里面（即用remember转成状态）并不合适。因为与绘制强相关的对象如Brush，Color和Shader等，它并不是自变量，而是因变量，这些对象依赖其底层的数据变化而需要重新创建。所以，最恰当的方式是，是把自变量如底层的颜色数值，或者图片放到状态里面，而Brush和Shader放在drawWithCache里面。</p>

<h2>图形变幻</h2>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/graphics/package-summary#(androidx.compose.ui.Modifier.graphicsLayer(kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,kotlin.Float,androidx.compose.ui.graphics.TransformOrigin,androidx.compose.ui.graphics.Shape,kotlin.Boolean,androidx.compose.ui.graphics.RenderEffect,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.Color,androidx.compose.ui.graphics.CompositingStrategy">Modifier.graphicsLayer</a>))是一个图形的扩展函数，它能够把目标Composable的内容绘制到一个图层（layer）上面，然后提供了一些针对图层进行操作的函数，进而能实现一些变幻。这相当于是把绘制指令做了隔离，先把绘制结果放到一个图层上面，除了变幻，图层还能做很多事情：</p>

<ul>
<li>做类似于<a href="https://developer.android.com/reference/android/graphics/RenderNode">RenderNode</a>那样的渲染管线化（render pipeline），把图层用作管理线中的一个节点，而不用每次都重新绘制。</li>
<li>光栅化（Rasterization），图层可以光栅化，甚至离屏渲染（offscreen drawing），这可以优化动画的帧率和流畅度。</li>
</ul>


<p>不过，最主要的仍是做变幻，进而实现动画（Animation）。但要注意，图形变幻，仅是针对绘制过程做的变幻，并不影响Composable的真实的属性。</p>

<p>graphicsLayer也是一个扩展函数，它的lambda参数是GraphicsLayerScope的一个扩展函数，所以lambda中有指向GraphicsLayerScope的隐式指针。变幻，只需要指定一些参数的值即可，通过一些例子，一看就能懂。</p>

<h3>缩放/位移/旋转/透明度</h3>

<p>通过在graphicsLayer的lambda中指定相应的参数即可以实现这些变幻。对于旋转和缩放，还可以指定中心点（Origin），特别注意旋转，它是三维的有x，y，z三个参数，通过一个例子来感受这些变幻效果：</p>

<pre><code class="Kotlin">    Box(
        modifier = Modifier
            .graphicsLayer {
                scaleX = 1.1f
                scaleY = 1.6f
                translationX = 30.dp.toPx()
                translationY = 50.dp.toPx()
                alpha = 0.7f
                rotationX = 10f
                rotationY = 5f
            }
    ) {
        Text(
            "降Compose十八掌!",
            modifier = Modifier
                .padding(16.dp)
                .drawWithCache {
                    val brush = Brush.linearGradient(
                        listOf(
                            Color(0xFF9E82F0),
                            Color(0xFF42A5F5),
                            Color(0xFFE2E575)
                        )
                    )
                    onDrawBehind {
                        drawRoundRect(
                            brush,
                            cornerRadius = CornerRadius(10.dp.toPx())
                        )
                    }
                }
                .padding(16.dp),
            style = MaterialTheme.typography.headlineLarge
        )
    }
</code></pre>

<p><img src="file:///Users/alexhilton/Desktop/graphics_layer_transform.png" alt="transformation" /></p>

<h3>剪辑与形状</h3>

<p>剪辑（clip）是把绘制好的图层进行裁剪，裁剪的效果由形状（shape）来指定。这里可以尽情的发挥想像力，做出非常炫酷的视觉效果。</p>

<pre><code class="Kotlin">       Box(
            modifier = Modifier
                .size(200.dp)
                .graphicsLayer {
                    clip = true
                    shape = CircleShape
                }
                .background(Color(0xFFF06292))
        ) {
            Text(
                "降Compose十八掌",
                style = TextStyle(color = Color.Black, fontSize = 36.sp),
                modifier = Modifier.align(Alignment.Center)
            )
        }
</code></pre>

<p><img src="file:///Users/alexhilton/Desktop/clip_shape.png" alt="clip_shape" /></p>

<h3>图层的变幻仅对绘制生效</h3>

<p>需要注意的是，对图层做的变幻仅是对渲染结果生效，它并不影响Composable本身的属性（如大小和位置）。比如说，通过剪辑和位移，图层可能会超出Composable本身的区域，也就是说在View树中，这个元素的位置和大小还是原来的样子。</p>

<p>通过Modifier中其他的函数能对Composable本身进行剪辑这才会真正影响它自身的大小，超出边界的内容会被裁剪掉：</p>

<pre><code class="Kotlin">    Column(modifier = Modifier.fillMaxSize().padding(16.dp)) {
        Box(
            modifier = Modifier
                .size(200.dp)
                .clip(RectangleShape)
                .border(2.dp, Color.Black)
                .graphicsLayer {
                    clip = true
                    shape = CircleShape
                    translationX = 50.dp.toPx()
                    translationY = 50.dp.toPx()
                }
                .background(Color(0xFFF06292))
        ) {
            Text(
                "降Compose十八掌",
                style = TextStyle(color = Color.Black, fontSize = 36.sp),
                modifier = Modifier.align(Alignment.Center)
            )
        }

        Box(
            modifier = Modifier
                .size(200.dp)
                .background(Color(0xFF4DB6AC))
        )
    }
</code></pre>

<p><img src="file:///Users/alexhilton/Desktop/clip_modifier.png" alt="clip_modifier" /></p>

<h2>创建Composable的快照</h2>

<p>就像截屏一样，可以给Composable拍照，即把Composable的绘制结果转成一个Bitmap，进而可以保存成图片文件，或者分享到其他应用。主要是通过graphicsLayer的record函数：</p>

<pre><code class="Kotlin">val coroutineScope = rememberCoroutineScope()
val graphicsLayer = rememberGraphicsLayer()
Box(
    modifier = Modifier
        .drawWithContent {
            // 用record函数来录制图层
            graphicsLayer.record {
                // 把内容绘制到图层上面
                this@drawWithContent.drawContent()
            }
            // 把图层再绘制到画布上面，以让内容能正常显示
            drawLayer(graphicsLayer)
        }
        .clickable {
            coroutineScope.launch {
                val bitmap = graphicsLayer.toImageBitmap()
                // 快照Bitmap已准备好了，可以使用此Bitmap了
            }
        }
        .background(Color.White)
) {
    Text("Hello Android", fontSize = 26.sp)
}
</code></pre>

<blockquote><p>注意：函数rememberGraphicsLayer只在compose的1.7.0-alpha07以后的版本才支持，在稳定版本中是不支持的。以BOM方式指定的依赖都是稳定版。可以单独给compose-ui:ui指定版本，如implementation(&ldquo;androidx.compose.ui:ui:1.7.0-beta03&rdquo;)</p></blockquote>

<p><img src="file:///Users/alexhilton/Desktop/graphics_to_bitmap.png" alt="bitmap_share" /></p>

<h2>如何选择恰当的方式</h2>

<p>自定义绘制有两种，一种纯的自已绘制内容，类似于直接继承View，在onDraw中绘制自己想要的效果；另外一种就是基于现有的部件进行改进和增强，类似于子例化TextView或者子例化ImageView，基于原View的内容，再进行变幻，改进或者增强。</p>

<p>视具体的问题而定，如果是第一种，就用Canvas函数，否则的话就用上面讲的Modifier的扩展函数。</p>

<p>其实如果仔细看API的实现，就可以发现Canvas函数其实是Modifier.drawBehind的一层包装：</p>

<pre><code class="Kotlin">@Composable
fun Canvas(modifier: Modifier, onDraw: DrawScope.() -&gt; Unit) =
    Spacer(modifier.drawBehind(onDraw))
</code></pre>

<p>因为Spacer是一个空白的占位符，本身的内容就是空的（只有大小，没有内容），所以整体效果就相当于是一个纯的自定义绘制内容了。</p>

<p>不过本质上都是使用DrawScope对象来进行具体的绘制，上面提到的Modifier的扩展函数也都是对DrawScope的封装。Modifier的强大之处在于它可以应用于所有其他的Composables，可以让开发者非常方便的对现有的Composables进行扩展和增强。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/graphics/draw/modifiers">Graphics modifiers</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
