<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Effectiveandroid | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/effectiveandroid/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2024-09-18T22:38:51+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『神龙摆尾』| Architecture]]></title>
    <link href="http://toughcoder.net/blog/2024/09/12/architecture-in-compose/"/>
    <updated>2024-09-12T22:27:58+08:00</updated>
    <id>http://toughcoder.net/blog/2024/09/12/architecture-in-compose</id>
    <content type="html"><![CDATA[<p>通过前面的<a href="https://juejin.cn/column/7367555191338467337">一系列文章</a>，我们已经掌握了足够的Jetpack Compose的开发基础。为了更好的在实际项目中使用Compose，我们还需要了解一下现代应用开发的架构原则，以及使用Jetpack Compose时如何更好的遵循这些原则。这篇文章将聚焦于架构原则这一话题，进行一些探讨和总结。</p>

<p><a href=""><img src="https://www.sixt.tech/assets/jetpack-compose/jetpack-compose.png" title="auto auto" ></a></p>

<!-- more -->


<h2>现代Android应用开发的架构方式</h2>

<p>Jetpack Compose是一个声明式的UI框架，用它来开发应用程序，因此根本上仍是在做应用程序开发，所以需要遵循现代应用程序的架构原则。</p>

<p>一提到架构自然会想到Bob大叔的<a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">The Clean Architecture</a>，这里面的最主要的核心思想就是分层，把不同的概念按照抽象的层次进行分离，层与层之间有特定的依赖规则，也即只能从控制层往业务逻辑依赖。分层最大的益处就是方便移植和替换，降低维护成本，这也是架构的意义所在。</p>

<p><img src="https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg" alt="图1. The Clean Architecture" /></p>

<p>对于移动应用开发，谷歌也给出比较实用的<a href="https://developer.android.com/topic/architecture#common-principles">现代应用架构原则</a>，其中有四个核心原则：</p>

<ol>
<li>远离系统组件，系统组件（Activity，Service和Fragment等）仅能作为一个入口和必要的依赖对象，以及协调和连接不同的对象。深层次的原因是系统组件实例不可控，系统随时会重新创建实例，所以应该把对系统组件的依赖降到最低；</li>
<li>由数据来驱动UI，且数据最好是不可变的（Immutable data）。这个原则要求把逻辑尽可能的放在数据层而非UI层，UI层就是展示数据层，处理用户事件和UI自己的逻辑，但不应该做的业务逻辑处理。比如说新闻类应用，数据层把一坨列表传过来，UI就展示，如果列表为空，那显示加载错误，用户点击刷新就让数据层刷新数据。但不应该对列表中的数据做更新或者更改，比如说把不同的列表融合为一个，这些都是业务逻辑，应该由数据层来做。这样的好处是能让UI层尽可能的简单，方便移植，方便测试。而且这符合响应式的数据流，可以使用响应式编程范式（MVVM或者MVI）；</li>
<li>单一数据源（Single Source Of Truth），也就是说任何数据都应该只由它的生产者来修改，其他模块只是使用不能修改，因此每一层返回的数据都应该是不可修改类型（Immutable objects）;</li>
<li>单向数据流动（Unidirectional Data Flow），UI层展示数据，获得用户事件，调用业务逻辑层处理事件，业务逻辑层再去数据层请求新的数据，新的数据再来驱动刷新UI，而不可以业务逻辑层修改数据后一边去刷新UI，一边再去让数据层修改数据，这会导致难以调试的bug。</li>
</ol>


<p><img src="https://developer.android.com/static/topic/libraries/architecture/images/mad-arch-overview.png" alt="图2. 现代应用典型架构" /></p>

<p>下面我们围绕Jetpack Compose来深入探讨一下如何把这些架构原则落到实处。</p>

<h2>使用Jetpack Compose落实架构原则</h2>

<p>Jetpack Compose是声明式UI框架，所以它只能出现在UI层，用UI元素展示数据， 以及获取用户事件。其余的部分，如业务逻辑层（ViewModels）和数据层（Models and Data）都与Compose没有关系，也不应该受到Compose的影响。这就是架构分层带来的好处，不同层之间通过约定 的接口进行协作，每一层都可以用不同的技术栈去实现，不会对其他层造成影响。</p>

<p><img src="https://developer.android.com/static/topic/libraries/architecture/images/mad-arch-overview-ui.png" alt="图3. 应用架构中的UI层的角色" /></p>

<h3>典型的项目结构</h3>

<p>按照架构原则，一个典型的项目模块结构应该是酱紫的：</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/project_org.png" alt="图4. 典型项目模块结构" /></p>

<p>Activity（对应着Activity实例）和AndroidApp（对应着Application实例）是应用程序的入口，可能需要在里面做一些必要的初始化工作，比如有些三方的库可能需要在Application#onCreate中去做初始化工作。ui package对应着UI层，负责UI的展示；package model对应着Model层，里面定义着供UI层使用的数据类型，以及获取 这些数据的接口；package data对应着数据层（data layer），实现着model中的接口定义。当然也可以把model与data合并成一个package，不过，单独把数据的定义和数据层的接口拿出来放在一个包里，会更清晰一些，因为UI层只需关心有哪些接口可以获得什么数据，它只需要知道model就够了。</p>

<p>Jetpack Compose的入口应该用一个名字为App的函数，在这里做初始化工作，比如创建数据层的实例，进行弹窗，创建导航等等。此处作为一个桥接，用以把Android的组件与Compose连接起来，创建必要的实例并把各实例协调起来。当然也可以直接把这些事情放入Activity中，但独立出来更方便测试和移植，让系统组件变得更为简单。Activity直接调用App即可：</p>

<pre><code class="Kotlin">class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            AeolusApp(Modifier.fillMaxWidth())
        }
    }
}

@Composable
fun AeolusApp(
    modifier: Modifier = Modifier
) {
    AeolusTheme {
        // A surface container using the 'background' color from the theme
        Surface(
            modifier = modifier,
            color = MaterialTheme.colorScheme.background
        ) {
            CurrentLocationPermission {
                val dataContainer = DataContainerImpl(LocalContext.current)
                AeolusNavGraph(appContainer = dataContainer)
            }
        }
    }
}
</code></pre>

<h3>创建导航</h3>

<p>导航是把所有的UI页面组织在一起形成一个逻辑清晰的交互整体，可以参照之前的文章<a href="https://juejin.cn/post/7398728505872908315">降Compose十八掌之『密云不雨』| Navigation</a>来创建导航。</p>

<p>需要注意的就是页面应该命名为Screen，其ViewModel应该作为参数传递给Screen，Screen和ViewModel的实例创建都在导航中来完成。</p>

<h3>ViewModel应该保持独立</h3>

<p>ViewModel作为UI层与数据层的中间层而存在，目的是让UI层专注于数据展示。为了更好的可移植性，ViewModel不应该有平台相关的依赖，比如<a href="https://juejin.cn/post/7409869765177147430">平台的生命周期</a>或者Context，它只应该依赖model层。并且为了方便依赖注入，应该把Model层的数据接口对象（通常是Repository）作为参数传递给ViewModel：</p>

<pre><code class="Kotlin">class FavoritesViewModel(
    private val locationRepo: LocationRepository,
    private val weatherRepo: WeatherRepository
) : ViewModel() {
}
</code></pre>

<p>具体的Repository对象可以在导航创建ViewModel时创建，或者用依赖注入框架（如Hilt）来注入实例。</p>

<h3>并发原则</h3>

<p>现代的应用肯定都会用并发，无论是协程还是Flow，为了能让并发更加的结构化和可控，应该遵循以下原则：</p>

<ol>
<li>Model层的方法都应该是suspend，对于所有Model层公开出来的方法都应该用suspend来修饰。</li>
<li>Repository（即Data层）的每个方法的实现都要指定明确的Dispatcher，最好接收一个Dispatcher作为构造参数，以方便进行注入或者测试。</li>
<li>ViewModel要把所有对Model的方法调用包裹在协程作用域viewModelScope中。</li>
</ol>


<h3>层与层之间的交互要定义接口</h3>

<p>比如Model层提供给ViewModel的能力要定义为接口，然后在Data层中去实现这些接口。接口的最大好处是方便替换具体的实现，比如换个实现方式时，或者Mock测试时都能很方便的进行替换，甚至还可以使用动态代理在运行时进行替换。</p>

<h3>对外部的依赖要作为构造器参数传入</h3>

<p>作为构造参数传入外部依赖，而不是在内部直接创建，这样做的好处在于方便替换实例，无论是日后更换一种实现实例，还是Mock测试，都可以在不修改类本身的情况下进行实例替换。甚至可以使用依赖注入框架（如Hilt）做到让具体使用的实例可配置化。</p>

<h2>Compose与ViewModel的交互原则</h2>

<p>这部分我们具体谈一谈Compose与ViewModel在交互时的一些原则和建议。ViewModel暴露UiState给Compose展示，Compose则把事件（Event）给ViewModel去处理（可以是MVI式的把事件封装成Intent塞给ViewModel，也可以直接调用ViewModel的接口）。</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/state-unidirectional-flow.png" alt="图5. Compose与ViewModel的UDF" /></p>

<p>比如说一个典型的登录场景，其Composable和ViewModel应该像这样的：</p>

<pre><code class="Kotlin">class MyViewModel : ViewModel() {
    private val _uiState = mutableStateOf&lt;UiState&gt;(UiState())
    val uiState: State&lt;UiState&gt;
        get() = _uiState
    // ...
}

data class UiState(
    loading: Boolean = false,
    signedIn: Boolean = false,
    error: String = ""
)

@Composable
fun MyComposable(viewModel: MyViewModel) {
    val uiState = viewModel.uiState.collectAsStateWithLifecycle()
    if (uiState.loading) {
        // show loading
    } else if (uiState.signedIn) {
        // show signed in status
    } else {
        // show uiState.error
    }
}
</code></pre>

<h3>一定要定义专用的UiState数据对象</h3>

<p>从ViewModel给UI的数据要封装成一个不可变的数据对象（data class）作为UiState，即使其数据与从Model处获得的数据没有变化，也应该定义并做基本转换。</p>

<p>原因就是让UI层和Model不会相互影响，假如直接把Model的数据传给UI，那假如以后Model层的数据有变动，这就会影响到UI。架构分层的目的就是要封装和隔离，每一层都应该定义自己的输出数据类型，把依赖和耦合降到最低。</p>

<h3>当数据特别多时，分成多个UiState对象</h3>

<p>如果页面较复杂，需要的字段特别多，这时应该把页面分成几个区域，同时UiState也应该分成几个不同的对象，而不是大一统的装在一个对象里面。</p>

<p>原因在于Compose会把从ViewModel处获得的UiState装在一个状态里面，从<a href="https://juejin.cn/post/7376094685495001139">前面的文章中</a>我们知道，状态是用于触发重组的，状态发生变化就会触发重组。因为数据多半部分变化的，甚至有些业务逻辑总是某几个字段在变化。因为字段都放在了一个对象中，那么即使只有一个字段变了，对于Compose来说，也是状态变化了，就要进行重组。</p>

<p>把字段按其变化的性质进行拆分，用几个UiState来表示，这样能把变化降到最低，只让真正有变化的UiState触发重组进而刷新UI。</p>

<h3>Compose中要尽可能拆解为无状态函数</h3>

<p>这里的意思是说我们应该把从ViewModel处获得的UiState拆解开来，变成具体的参数用无状态函数去展示，而不应该全都把UiState当成参数传给每一个composables。比如说对于一个新闻页面，对于标题元素就应该只接受两个String作为参数，而不应该把整个NewsUiState作为参数：</p>

<pre><code class="Kotlin">@Composable
fun Header(title: String, subtitle: String) {
    // 只有当title和subtitle发生变化时才会重组
}

@Composable
fun Header(news: NewsUiState) {
    // 只要状态变了就会重组，哪怕有关的title和subtitle没有变化
}
</code></pre>

<p>这样做的目的也是为了尽可能减少重组。</p>

<h3>ViewModel塞给UI的数据要能够直接展示</h3>

<p>UI层负责数据展示，不应该有过多的逻辑，特别是不能有涉及非UI直接相关的逻辑。ViewModel存在的意义就是为了把非UI相关的业务逻辑全从UI中拿走，把UI做的尽可能薄一些，这里薄的意思是逻辑要少。背后的核心原因在于方便测试和移植，众所周知UI是与每个平台强相关的，每个平台的UI构建方式都不一样，并且UI是极难做单元测试的，依赖太多很难Mock。</p>

<p>UI层很薄，仅是数据的展示，逻辑都放在ViewModel中，但ViewModel依赖很少，没有对平台和依赖，它的依赖对象都是可以Mock的，那么ViewModel就很容易做测试，只要测试保证ViewModel没什么问题，那么就基本上可以认为UI也不会有问题，毕竟光做展示一般不会出问题。</p>

<p>这里的最重要的一点就是要保证ViewModel递给UI的数据要是经过逻辑处理后的，可以直接展示的数据。举个粟子，比如说展示时间间隔的字段，类似于『100 ms』，『10 seconds』，『2 mins 10ms』或者『1 hour 10 mins』 这种，那么就不可以直接把一个Int或者Long传给UI，让UI去换算，而是让ViewModel做换算，把结果String传给UI，UI用一个Text直接显示String。这样一来就可测试了，我们Mock几个不同的字段值给ViewModel，再检查它吐出来的UiState中的时长String字段是否符合预期，就能保证这段逻辑没有问题。对于UI可以不用测试了，一个Text显示一个String出错的可能性不大，可以忽略了。</p>

<h2>总结</h2>

<p>架构最难的地方在于它是<strong>形而上学（Metaphysics）</strong>的，不会像算法或者设计模式那样有非常明确的和具体的实施步骤，仅是有一些抽象的指导原则。在实际的项目中就要从实际的业务场景出发，使用可用的技术工具，把指导原则进行落地，要<strong>把『神似』而非『形似』</strong>作为目标。切忌生搬硬套网上一些所谓的应用架构框架，假如真的有通用的架构框架，那谷歌为啥不写在SDK里面？不同的业务，不同的规模，不同的技术栈，不同的版本策略都会影响架构的方式。比如像第一部分提到的四大原则，难道只有用MVVM或者MVI才能做到么？即使用了MVVM，你在ViewModel直接把未处理的数据丢给UI，UI中仍有大量的处理数据的if-else，ViewModel把数据改了后两头更新，这明显不符合架构原则，最后仍是维护一坨巨大的shi山难解的Bug满天飞。所以对于网上的各种架构框架看看就好，一定不能生搬硬套。</p>

<p>可以通过谷歌提供的一些非常好的<a href="https://github.com/android/architecture-samples/tree/main">案例</a>来学习架构，仔细研读这些案例的源码，以深刻理解架构指导原则的内在涵义。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/topic/architecture">Guide to app architecture</a></li>
<li><a href="https://developer.android.com/develop/ui/compose/architecture">Architecting your Compose UI</a></li>
<li><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">The Clean Architecture</a></li>
<li><a href="https://www.geeksforgeeks.org/separation-of-concerns-soc/">Separation of Concerns (SoC)</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『羝羊触蕃』| Handle Platform Lifecycles]]></title>
    <link href="http://toughcoder.net/blog/2024/09/06/compose-interact-with-platforms/"/>
    <updated>2024-09-06T22:21:49+08:00</updated>
    <id>http://toughcoder.net/blog/2024/09/06/compose-interact-with-platforms</id>
    <content type="html"><![CDATA[<p>Jetpack Compose是一个独立的声明式UI框架，它并不受限于任何操作系统平台，从框架定位的角度来讲，它是跨平台的，也应该要跨平台。但是我们的应用程序必然是为某些操作系统平台（后面简称平台Platform）构建的，也就是说要运行在某些平台上面。这就免不了要与平台进行打交道。这篇文章将以Android平台为例，学习在Compose中如何处理平台的生命周期事件。</p>

<p><a href=""><img src="https://www.ericthecoder.com/wp-content/uploads/2020/05/feature.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>感知平台生命周期事件</h2>

<p>对于移动应用程序来说，感知平台的生命周期是非常重要的，比如最为典型的场景，对于一个新闻消息类的应用来说，当首次进入页面的时候肯定 要刷新拉取最新的消息，当用户切换到另外一个应用时，比如接了个电话，或者分享，之后再回到你的应用页面，这时也应该主动刷新消息，而不是要等着用户手动的去点击刷新按扭；再比如说当使用了硬件资源（位置，Camera或者Sensors等）时，更是要当离开应用页面的时候就应该立即释放硬件，以停止对硬件资源的占用。</p>

<p>从前面的文章<a href="https://juejin.cn/post/7401358349877346338">降Compose十八掌之『损则有孚』| Lifecycle</a>中我们了解到Composable本身的生命周期与平台是无关的且非常不一致，光靠Compose自己的节奏是无法感知到在平台生命周期事件的。这就需要我们使用一些桥接工具来感知平台生命周期事件，以能让我们针对感兴趣的事件执行一些操作。</p>

<h3>生命周期事件副作用函数（LifecycleEffects）</h3>

<p>幸运的是Jetpack组件中的lifecycle已经添加了<a href="https://developer.android.com/topic/libraries/architecture/compose">对Compose的支持</a>，定义了一些<a href="https://developer.android.com/reference/kotlin/androidx/lifecycle/compose/package-summary#LifecycleEventEffect(androidx.lifecycle.Lifecycle.Event,androidx.lifecycle.LifecycleOwner,kotlin.Function0">生命周期副作用函数</a>)，在这些副作用函数中可以针对 不同的事件设置代码块，当相应的生命周期发生时就会执行这些代码块：</p>

<pre><code class="Kotlin">LifecycleEventEffect(Lifecycle.Event.ON_START) {
  // onStar时执行一些操作
}
</code></pre>

<p>上面的代码就是指定要在onStart时做一些事情。需要<strong>注意</strong>的是，无法监听onDestroy（即事件Lifecycle.Event.ON_DESTROY），因为Compose的<strong>组合会在onDestroy之前就结束</strong>了。</p>

<p>除了上面的用法之外，还有更为为方便的<a href="https://developer.android.com/reference/kotlin/androidx/lifecycle/compose/package-summary#LifecycleStartEffect(kotlin.Any,androidx.lifecycle.LifecycleOwner,kotlin.Function1">LifecycleStartEffect</a>)和<a href="https://developer.android.com/reference/kotlin/androidx/lifecycle/compose/package-summary#LifecycleResumeEffect(kotlin.Any,androidx.lifecycle.LifecycleOwner,kotlin.Function1">LifecycleResumeEffect</a>)可以直接使用，它们是针对onStart/onStop和onResume/onPause两对事件的，因为生命周期中最为常用的就是这四个事件了：</p>

<pre><code class="Kotlin">LifecycleStartEffect {
  // onStart中需要做的事情

  onStopOrDispose {
    // onStop需要做的事情
  }
}

LifecycleResumeEffect {
  // onResume需要做的事情

  onPauseOrDispose {
    // onPause需要做的事
  }
}
</code></pre>

<p>需要注意，这两个副作用函数是针对事件对的，也就是说必须要带着后面的onStopOrDispose和onPauseOrDispose。如果仅对onStart感兴趣，而无须在onStop中做清理，那么应该直接使用LifecycleEventEffect(Lifecycle.Event.ON_START) {}（对于onResume也是同理）。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://medium.com/@nirazv/managing-lifecycles-events-on-jetpack-compose-bbecf804b43d">Managing Lifecycles Events on Jetpack Compose</a></li>
<li><a href="https://developer.android.com/topic/libraries/architecture/compose">Integrate Lifecycle with Compose</a></li>
</ul>


<h3>监听生命周期事件</h3>

<p>除了直接使用生命周期副作用函数以外，也可以用lifecycle原生的方式，直接向<a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner">LifecycleOwner</a>注册一个<a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleEventObserver">LifecycleEventObserver</a>来监听生命周期。通过Compose提供的LifeCycleOwner.current可以获得当前的LifecycleOwner，然后向其注册一个LifecycleEventObserver，当平台生命周期发生变化时，就会带着事件类型回调给监听者，监听者可以针对感兴趣的事件做操作。还需要注意的是，需要在组合结束（离开）时反注册observer，因此这里要用DisposableEffect。对于副作用函数不熟悉的同学可以去复习一下<a href="https://juejin.cn/post/7405158681078104127">降Compose十八掌之『龙战于野』| Side Effects</a>。</p>

<p>来看个简单的示例：</p>

<pre><code class="Kotlin">val lifecycleOwner = LocalLifecycleOwner.current

    DisposableEffect(lifecycleOwner) {
        val observer = LifecycleEventObserver { _, event -&gt;
            when (event) {
                Lifecycle.Event.ON_CREATE -&gt; { /* onCreate */ }
                Lifecycle.Event.ON_START -&gt; { /* onStart */ }
                Lifecycle.Event.ON_RESUME -&gt; { /* onResume */ }
                Lifecycle.Event.ON_PAUSE -&gt; { /* onPause */ }
                Lifecycle.Event.ON_STOP -&gt; { /* onStop */ }
                Lifecycle.Event.ON_DESTROY -&gt; { /* onDestroy */ }
                Lifecycle.Event.ON_ANY -&gt; { /* Any event */ }
                else -&gt; {}
            }
        }

        lifecycleOwner.lifecycle.addObserver(observer)

        onDispose {
            lifecycleOwner.lifecycle.removeObserver(observer)
        }
    }
</code></pre>

<p>这样就可以监听到生命周期事件，然后针对不同的事件做相应的操作。</p>

<p>当然，如果事件不止做一件事情，或者说对事件的响应不光光是执行一些函数，可能还会有页面的修改，那么这时最好就是把事件保存为一个状态（State），更为方便：</p>

<pre><code class="Kotlin">    val lifecycleOwner = LocalLifecycleOwner.current

    var lifecycleEvent by remember { mutableStateOf(Lifecycle.Event.ON_ANY) }

    DisposableEffect(lifecycleOwner) {
        val observer = LifecycleEventObserver { _, event -&gt;
            lifecycleEvent = event
        }

        lifecycleOwner.lifecycle.addObserver(observer)

        onDispose {
            lifecycleOwner.lifecycle.removeObserver(observer)
        }
    }

    LaunchedEffect(lifecycleEvent) {
        if (lifecycleEvent == Lifecycle.Event.ON_RESUME) {
            viewModel.refresh()
        }
    }

    Column() {
        if (lifecycleEvent == Lifecycle.Event.ON_RESUME) {
            Text("Welcome back")
        }
    }
</code></pre>

<p>扩展阅读：</p>

<ul>
<li><a href="https://stackoverflow.com/questions/74780546/android-handle-lifecycle-event-on-jetpack-compose-screen">Android handle lifecycle event on Jetpack Compose Screen</a></li>
<li><a href="https://proandroiddev.com/jetpack-compose-making-composable-lifecycle-aware-bde67437d2d0">Jetpack Compose — Making Composable lifecycle-aware</a></li>
<li><a href="https://betterprogramming.pub/jetpack-compose-with-lifecycle-aware-composables-7bd5d6793e0">Jetpack Compose with Lifecycle-Aware Composables</a></li>
</ul>


<h3>以数据流的方式来处理生命周期事件</h3>

<p>生命周期是由系统控制，不时发生变化，每次变化会向监听者回调一个事件，如果以一定的时间跨度来看待，这些事件就形成了一个数据流。因此，Lifecycle还提供了一个Flow接口，用以发送Lifecycle事件。可以当作状态（State）来收集此Flow，这样事件的变化就能驱动Compose的重组，进而感知到最新的生命周期事件：</p>

<pre><code class="Kotlin">val lifecycleOwner = LocalLifecycleOwner.current
val stateFlow = lifecycleOwner.lifecycle.currentStateFlow
val currentLifecycleState by stateFlow.collectAsState()

// 或者
val lifecycleOwner = LocalLifecycleOwner.current
val currentLifecycleState = lifecycleOwner.lifecycle.currentStateAsState()
</code></pre>

<p><strong>注意：</strong> 对于Flow不熟悉的同学可以复习一下<a href="https://juejin.cn/post/7336751931375648820">包教包会的Kotlin Flow教程</a>。</p>

<h3>不要在ViewModel中感知生命周期</h3>

<p>根据<a href="https://developer.android.com/topic/architecture">现代安卓开发架构原则</a>，ViewModel应该处理与UI相关的业务逻辑，它应该独立于平台，因此，千万不要在ViewModel去感知生命周期，事实上你也做不到，因为ViewModel是没任何对平台的依赖的，非常独立的一个类型，也即拿不到LifecycleOwner。</p>

<p>当然了，有同学说，我可以从Compose的Composable中把LifecycleOwner当作参数传给ViewModel，但仍然强烈不建议这样做。深层的原因在于，ViewModel是独立于平台的，它有自己的生命周周期，平台的组件（如Activity）是由系统控制的，但ViewModel是由我们自己控制的，它的生命周期要长于平台的组件，也就是说ViewModel的生命周期要长于它持有的LifecycleOwner，故LifecycleOwner可能会变得过时（非当前的Activity了），同时因为被更长生命的ViewModel持有，原LifecycleOwner可能无法被回收而引发内存泄漏。</p>

<p>ViewModel只应该负责业务逻辑相关的事情，在Composable中监听生命周期事件很方便，也很合适，然后调用ViewModel的相应的接口（如refresh()）即可。</p>

<h2>总结</h2>

<p>得益于Jetpack中的Lifecycle组件，在Compose中感知生命周期没有想像中的那样难。在实际项目中，推荐使用更符合Compose的方式，也即生命周期副作用函数以及事件数据流。如果仅是在某些生命周期事件发生时执行一些操作，那就用LifecycleEventEffect函数；如果不止一处需要使用事件，那就用事件数据流。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『履霜冰至』| Phases]]></title>
    <link href="http://toughcoder.net/blog/2024/08/30/jetpack-compose-phases/"/>
    <updated>2024-08-30T08:02:41+08:00</updated>
    <id>http://toughcoder.net/blog/2024/08/30/jetpack-compose-phases</id>
    <content type="html"><![CDATA[<blockquote><p>这篇文章译自<a href="https://developer.android.com/develop/ui/compose/phases">Jetpack Compose phases</a></p></blockquote>

<p>就像大多数其他的UI工具集一样，Compose渲染一帧也要经过几个不同的阶段。就比如说Android view系统，主要有三个阶段：测量（measure），版面编排（layout）和绘制（drawing）。Compose也非常的类似，但有一个特别重要的额外的阶段起始时的组合（composition）阶段。</p>

<p><a href=""><img src="https://pbs.twimg.com/media/F3l9aWwWUAEDYxS.jpg:large" title="auto auto" ></a></p>

<!-- more -->


<p>组合在我们前面的文章中有详细的描述，包括<a href="https://juejin.cn/post/7379437165486112805">降Compose十八掌之『潜龙勿用』| Thinking in Compose</a>和<a href="https://juejin.cn/post/7376094685495001139">降Compose十八掌之『鸿渐于陆』| State</a>。</p>

<h2>每一帧的三个阶段</h2>

<p>Compose有三个主要的阶段：</p>

<ol>
<li>组合（Composition）：要显示什么。Compose运行composable函数并创建UI的一个描述。</li>
<li>版面编排（Layout）：在哪里显示。这个阶段包含两个步骤：测量（measurement）和放置（placement）。给布局树中的每个节点，在二维坐标中，布置元素的测量然后放置它们和它们的子元素。</li>
<li>绘制（Drawing）：如何渲染。把UI元素绘制进一个Canvas，也就是设备的屏幕上。</li>
</ol>


<p><img src="https://developer.android.com/static/develop/ui/compose/images/compose-phases.png" alt="three_phases" /></p>

<blockquote><p>图1. Compose把数据转化为UI的三个阶段</p></blockquote>

<p>这三个阶段的执行顺序是相同的，能够让数据从组合到版面编排再到绘制沿着一个方向流动，以生成一帧（也就是<a href="https://developer.android.com/develop/ui/compose/architecture#udf">「单向数据流」</a>）。需要特别注意的例外是<a href="https://developer.android.com/develop/ui/compose/layouts/basics#constraints">BoxWithConstraints</a>，<a href="https://developer.android.com/develop/ui/compose/lists#lazy">LazyColumn</a>和<a href="https://developer.android.com/develop/ui/compose/lists#lazy">LazyRow</a>，它们子节点的组合依赖于父节点的排版阶段。</p>

<p>可以假定每一帧都会这三个阶段，但是基于性能的考量，在所有的阶段里，Compose会避免相同输入时计算结果相同的重复工作。如果一个composable函数能复用前一次的结果，Compose会跳过它的执行，并且如果没有必要，Compose UI并不会重新排版或者重新绘制整个UI树。Compose仅会做更新UI所必要的最少工作。因为Compose会在不同的阶段追踪状态读取，所以这种优化是可行的。</p>

<h3>理解不同的阶段</h3>

<p>这部分将详细的描述composables的三个渲染阶段是如何进行的。</p>

<h4>组合（Composition）</h4>

<p>在组合阶段，Compose运行时会执行composable函数然后输出一个能代表UI的树形结构。这个树形结构由包含着下一阶段所需要的信息的布局节点组成，如下面这个视频所示：</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/composition-ezgif.gif" alt="" /></p>

<blockquote><p>图2. 在组合阶段创建的代表着你的UI的树形结构。</p></blockquote>

<p>一小段代码和其树形会如下所示：</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/code-subsection.png" alt="ui_tree_vs_code" /></p>

<blockquote><p>图3. UI树的一部分与其对应的代码。</p></blockquote>

<p>在这些例子中，代码中的每个composable函数映射为一UI树中的一个布局节点。在更复杂的例子中，composables可包含逻辑和控制流程，在不同的状态下生成不同的树。</p>

<h4>排版（Layout）</h4>

<p>在排版阶段，Compose使用组合阶段生成的UI树作为输入。布局节点的集合包含了需要确定2D空间下每个节点大小和位置的所有需要的信息。</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/layout-ezgif.gif" alt="" /></p>

<blockquote><p>图4. 在排版阶段UI树中每个布局节点的测量和放置。</p></blockquote>

<p>在排版阶段，树用下面三步算法进行遍历：</p>

<ol>
<li>测量子节点：节点会测量其存在的子节点。</li>
<li>决定自身大小：基于前面的测量，一个节点能决定它自身的大小。</li>
<li>放置子节点：每个子节点以节点为参考进行放置。</li>
</ol>


<p>在这个阶段的最后，每个布局节点都有：</p>

<ul>
<li>一个确定的宽度（width）和高度（height）</li>
<li>一个绘制的位置坐标x，y</li>
</ul>


<p>对于前一部分提到的UI树：</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/code-subsection.png" alt="" /></p>

<p>对于这颗树，算法是这样工作的：</p>

<ol>
<li>Row测量它的子节点：Image和Column。</li>
<li>Image测量过后。因为它没有子节点，所它决定自己的大小并把其大小报告给Row。</li>
<li>接下来测量Column。它先测量它的两个子节点（两个Text函数）。</li>
<li>第一个Text被测量。它没有子节点，所以决定自己大小并告诉给Column

<ol type="a">
<li>第二个Text被测量。它也没有子节点，所以决定自己大小后告诉给Column。</li>
</ol>
</li>
<li>Column使用子节点的测量结果决定自己的大小。它用子节点的最大宽度（作为宽度）和高度之和（作为高度）。</li>
<li>Column相对于自己来放置子节点，把它们垂直地放在下面。</li>
<li>Row使用子节点的测量结果来决定自身大小。它使用子节点的最大高度作为高度，子节点宽度之和作为宽度。然后旋转子节点。</li>
</ol>


<p>注意每个节点仅访问一次。测量和放置所有节点时，Compose运行时仅需要访问一次UI树，这样做能提升性能。当树中的节点数量增加时，遍历所需要的时间仅线性增长。相反，如果每个节点访问多次，遍历时间将呈指数增长。</p>

<h4>绘制（Drawing）</h4>

<p>在绘制阶段，将从上到下的再次遍历树，每个节点依次的在屏幕上绘制其自身。</p>

<p><img src="file:///Users/alexhilton/Downloads/compose_libs/drawing-ezgif.gif" alt="" /></p>

<blockquote><p>图5. 绘制阶段在屏幕上绘制像素点。</p></blockquote>

<p>继续前面的例子，以如下方式绘制出树的内容：</p>

<ol>
<li>Row绘制它有的所有内容，如背景。</li>
<li>Image绘制它自己。</li>
<li>Column绘制它自己。</li>
<li>第一个和第二个Text各自绘制它们自己。</li>
</ol>


<p><img src="file:///Users/alexhilton/Downloads/compose_libs/drawing-ui-tree-ezgif.gif" alt="" /></p>

<blockquote><p>图6. UI树和它的渲染展示。</p></blockquote>

<h2>状态读取</h2>

<p>当你在上面列出的一个阶段中读取状态的值时，Compose会自动追踪值被读取时它在做的事情。这种追踪允许Compose在状态发生变化时重新执行读取者，这是Compose中状态的可观测性的基础。</p>

<p>状态通常都是由mutableStateOf来创建的然后通过两种方式访问：直接读取其属性value或者通过Kotlin的属性委托。可以在文章<a href="https://juejin.cn/post/7376094685495001139">降Compose十八掌之『鸿渐于陆』| State</a>中了解更多的细节。在本文中，「状态读取」通指两种方法中的任意一种。</p>

<pre><code class="Kotlin">// 直接读取状态的value
val paddingState: MutableState&lt;Dp&gt; = remember { mutableStateOf(8.dp) }
Text(
    text = "Hello",
    modifier = Modifier.padding(paddingState.value)
)
</code></pre>

<pre><code class="Kotlin">// 通过属性委托来读取
var padding: Dp by remember { mutableStateOf(8.dp) }
Text(
    text = "Hello",
    modifier = Modifier.padding(padding)
)
</code></pre>

<p>属性委托的背后，「getter」和「setter」函数用来访问和更新状态的value。这些getter和setter函数仅当你把属性当作一个值来引用时才会被调用，而不是委托被创建时，所以这就是上面两种方式是等价的原因。</p>

<p>当一个被读取状态发生变化时都会被重新执行的每一个代码块都是一个重启作用域（restart scope）。在不同的阶段，Compose会追踪状态值的变化然后重启作用域。</p>

<h2>分阶段的状态读取</h2>

<p>如上面所提及，Compose中有三个主要的阶段，在每个阶段中，Compose会追踪哪些状态被读取了。这让Compose能够仅通知针对UI中受影响的元素需要采取措施的特定阶段。</p>

<blockquote><p>注意：状态实例被创建和存储的地方对阶段几乎无影响，只有状态被读取的时间和地点才有重要影响。</p></blockquote>

<p>我们来仔细检查每一个阶段，然后描述一下在其中当状态被读取时所发生的事情。</p>

<h3>阶段一：组合</h3>

<p>在一个&#64;Composable标注的函数里或者lambda代码块里读取状态会影响组合和后续阶段。当状态值发生变化，重组器（recomposer）会安排所有读取状态的composable函数的重新运行。注意如果函数的输入没有变化，运行时可能会跳过一些甚至所有的composable函数。想了解更多可以看文章<a href="https://juejin.cn/post/7401358349877346338">降Compose十八掌之『损则有孚』| Lifecycle</a>。</p>

<p>取决于组合的结果，Compose UI在执行排版和绘制阶段，如果内容始终相同和大小以及布局未发生变化，它也许会跳过这些阶段。</p>

<pre><code class="Kotlin">var padding by remember { mutableStateOf(8.dp) }
Text(
    text = "Hello",
    // 当对象Modifier被构建时，状态`paddin`在组合阶段读取。
    // 状态`padding`的变化会触发重组
    modifier = Modifier.padding(padding)
)
</code></pre>

<h3>阶段二：排版</h3>

<p>排版阶段由两个步骤组成：测量和放置。测量步骤运行传递给composable函数的测量lambda，也即诸如接口LayoutModifier的MeasureScope.measure方法等的代码。放置步骤运行layout函数的放置代码块，也即诸如Modifier.offset {&hellip;}的代码块。</p>

<p>这些步骤中的状态读取影响排版编排和后续的绘制阶段。当状态值发生变化，Compose UI会安排排版阶段。如果大小和位置发生变化，它也会执行绘制阶段。</p>

<p>更准确的说，测量步骤和放置步骤有不同的重启作用域（restart scope），也就是说放置步骤中的状态读取不会重新触发它前面测量步骤。然而，这些步骤经常绞在一起，所以放置步骤中的状态读取可能会影响属于测量步骤中的其他重启作用域。</p>

<pre><code class="Kotlin">var offsetX by remember { mutableStateOf(8.dp) }
Text(
    text = "Hello",
    modifier = Modifier.offset {
        // 当offset被计算时，状态`offsetX`在排版阶段中的放置步骤读取
        // `offsetX`的变化会重启排版
        IntOffset(offsetX.roundToPx(), 0)
    }
)
</code></pre>

<h3>阶段三：绘制</h3>

<p>绘制过程中的状态读取影响绘制阶段。常见的例子包括Canvas()，Modifier.drawBehind和Modifer.drawWithContent函数。当状态值发生变化，Compose UI仅执行绘制阶段。</p>

<pre><code class="Kotlin">var color by remember { mutableStateOf(Color.Red) }
Canvas(modifier = modifier) {
    // 当canvas被渲染时，状态`color`在绘制阶段读取
    // 状态`color`变化重启绘制
    drawRect(color)
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/phases-state-read-draw.svg" alt="phase_state_read_draw" /></p>

<h2>优化状态读取</h2>

<p>因为Compose进行本地化的状态读取追踪，我们可以通过在合适的阶段读取状态以最小化渲染工作量。</p>

<p>我们来看一下下面的例子。这里有一个Image，使用了offset modifier来作为最终布局位置的偏移，实现一个用户滑动时的平行视觉差的效果：</p>

<pre><code class="Kotlin">Box {
    val listState = rememberLazyListState()

    Image(
        // ...
        // 这不是一个最优的实现方式
        Modifier.offset(
            with(LocalDensity.current) {
                // 在组合中读取状态firstVisibleItemScrollOffset
                (listState.firstVisibleItemScrollOffset / 2).toDp()
            }
        )
    )

    LazyColumn(state = listState) {
        // ...
    }
}
</code></pre>

<p>这个代码能行，但性能并不是最优的。上面的代码读取状态firstVisibleItemScrollOffset然后把它传给函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary#(androidx.compose.ui.Modifier">Modifier.offset</a>.offset(androidx.compose.ui.unit.Dp,androidx.compose.ui.unit.Dp))。当用户滑动时firstVisibleItemScrollOffset的值会变化。我们知道，Compose会追踪任何状态读取以便它能重新执行进行读取的代码，也即例子中函数Box中的内容。</p>

<p>这是一个在组合阶段读取状态的例子。这也并不是一无事处，因为这是重组的基础，让数据变化刷新UI。</p>

<p>但这个例子不是最优做法，因为每次滚动都会导致整个composable函数被重新运行，也会重新测量，重新排版，然后最终重新绘制。尽管要显示的内容并没有真正变化，仅是要显示的位置在变化，但我们每个滚动都会触发Compose的所有阶段。我们可以优化状态读取以仅触发排版阶段。</p>

<p>有offset modifier另外一个版本：<a href="https://developer.android.com/reference/kotlin/androidx/compose/foundation/layout/package-summary#(androidx.compose.ui.Modifier">Modifier.offset(offset: Density.()-> IntOffset)</a>.offset(kotlin.Function1))。这个函数接收一个lambda作为参数，lambda代码块的返回结果作为最终的偏移量。我们来改一下前面的例子：</p>

<pre><code class="Kotlin">Box {
    val listState = rememberLazyListState()

    Image(
        // ...
        Modifier.offset {
            // 在排版阶段读取状态firstVisibleItemScrollOffset
            IntOffset(x = 0, y = listState.firstVisibleItemScrollOffset / 2)
        }
    )

    LazyColumn(state = listState) {
        // ...
    }
}
</code></pre>

<p>为何这样就性能更优呢？我们提供给modifier的lambda代码块仅在排版阶段调用（具体来说是在排版阶段中的放置步骤），也就是说在组合阶段状态firstVisibleItemScrollOffset不用再被读取了。因为Compose追踪状态什么时候被读取，这次改动意味着如果状态firstVisibleItemScrollOffset值发生变化，Compose仅会重启排版和绘制阶段。</p>

<blockquote><p><strong>注意：</strong> 你也许很好奇接收一个lambda作为参数与接收一个普通值参数相比是否有额外的开销。确实有。然而，在这个场景中，限制状态读取到排版阶段带来的收益要超过参数的开销。在滑动中firstVisibleItemScrollOffset的值每一帧都会发生变化，把状态读取延迟到排版阶段，能避免很多次重组。</p></blockquote>

<p>虽然这个例子靠有不同的offset modifiers可以用来优化最终代码，但思路是通用的：尽可能把状态读取限制到最少的阶段中，让Compose做最少量的渲染工作。</p>

<p>当然了，在组合阶段也常常绝对有必要读取状态。尽管如此，通过过滤状态变化，还是有可以最小化重组发生的场景。想要了解更多的这方面信息，可以读文章<a href="https://juejin.cn/post/7405158681078104127">降Compose十八掌之『龙战于野』| Side Effects</a>。</p>

<h2>重组循环（循环阶段依赖）</h2>

<p>早些时候我们提到过Compose的阶段总会以相同的顺序被调用，并且在一帧中是没有办法往回走的。然而，不同帧之间组合循环依然会发生。看这个例子：</p>

<pre><code class="Kotlin">Box {
    var imageHeightPx by remember { mutableStateOf(0) }

    Image(
        painter = painterResource(R.drawable.rectangle),
        contentDescription = "I'm above the text",
        modifier = Modifier
            .fillMaxWidth()
            .onSizeChanged { size -&gt;
                // 不要这样做
                imageHeightPx = size.height
            }
    )

    Text(
        text = "I'm below the image",
        modifier = Modifier.padding(
            top = with(LocalDensity.current) { imageHeightPx.toDp() }
        )
    )
}
</code></pre>

<p>这里我们（以不好的方式）实现了一个垂直的列，图片在上面文字在其下面。使用Modifier.onSizeChanged感知图片的实际尺寸，然后通过Modifier.padding作用于文字以让其向下偏移。从Px到Dp的不自然转换已经表明了这段代码有问题。</p>

<p>这个例子的问题在于无法通过一帧就达到最终的排列布局。代码依赖于多帧的绘制，进行了不必要的工作，导致UI会在屏幕上跳跃。</p>

<p>让我们一帧帧的检查来看发生了什么：</p>

<p>在第1帧的组合阶段，imageHeightPx值为0，文字拿到的是Modifier.padding(top = 0)。然后，到了排版阶段，modifier的onSizeChanged回调会被调用。这时imageHeightPx会被更新成为图片的实际高度。Compose为下一帧安排重组。在绘制阶段，文字使用padding 0来渲染，因为这时状态的值还没有被更新。</p>

<p>然后Compose会启动因imageHeightPx的值变化而安排的第2帧渲染。状态是在Box内容代码块中读取，并且是在组合阶段调用的。这回，给到Text的padding是真实的图片的高度。在排版阶段，代码再次修改了imageHeightPx的值，但因为值没有发生变化，所以不会安排重组。</p>

<p>最终，我们得到的text的期望的padding，但是耗费额外的一帧来传递padding值到不同的阶段并不是最优的做法，这会导致带有重叠内容的一帧。</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/phases-recomp-loop.svg" alt="" /></p>

<p>这个例子也许显得有点做作，但要小心这种通用的模式：</p>

<ul>
<li>Modifier.onSizeChanged，onGloballyPositioned，或者一些其他的排版操作</li>
<li>更新一些状态</li>
<li>把状态当作排版modifier（padding(), height()或者类似的）的输入</li>
<li>潜在的重复</li>
</ul>


<p>上面示例的修复办法是使用合适的排版原语。上面例子可以用一个普通的Column()来实现，但你也许会有需要一些定制的更复杂的场景，这些场景可能需要写一些定制化的布局。可以看<a href="https://developer.android.com/develop/ui/compose/layouts/custom">定制布局</a>文档以了解更多。</p>

<p>这里通用的原则是对于需要相互之间测量和旋转的多个UI元素要保持单一数据来源。使用合适的排版原语或者创建一个定制化的布局就意味着最少化的共享父节点可以当作可以协调多个元素之间关联的单一数据源。而引入动态的状态会打破这一原则。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『龙战于野』| Side Effects]]></title>
    <link href="http://toughcoder.net/blog/2024/08/23/jetpack-compose-side-effects/"/>
    <updated>2024-08-23T07:56:53+08:00</updated>
    <id>http://toughcoder.net/blog/2024/08/23/jetpack-compose-side-effects</id>
    <content type="html"><![CDATA[<blockquote><p>主要翻译自官方文档<a href="https://developer.android.com/develop/ui/compose/side-effects">Side-effects in Compose</a>，并不是直译，有些细微调整。</p></blockquote>

<p>一个<strong>副作用</strong>是指发生在composable函数范围之外的应用状态的一个变化。由于composable函数的生命周期和诸如不可预测的重组，以不同的顺序执行composable的重组，或者重组可能会被跳过等性质，理论上composable应该<a href="https://juejin.cn/post/7379437165486112805">要是无副作用</a>的。</p>

<p><a href=""><img src="https://ac.appcircle.io/wp-content/uploads/2022/10/compose-side-effects-state.png" title="auto auto" ></a></p>

<!-- more -->


<p>然而，有些时候副作用是必要的，例如，触发一些诸如显示一个非干扰性提示（snackbar）或者在一定状态条件下跳转到另一个页面，等的一次性的事件时。这些行为应该在一个能够感知composable生命周期的可控的环境中调用。在本文中，你将学习Jetpack Compose提供的几种不同的副作用函数（side effect APIs）。</p>

<h2>副作用的具体使用场景</h2>

<p>如在文章<a href="https://juejin.cn/post/7379437165486112805">降Compose十八掌之『潜龙勿用』| Thinking in Compose</a>中提到的，composables应该尽可能的做到无副作用。当需要对应用状态进行修改时，应该使用副作用API，以便副作用函数以可预测的方式运行。</p>

<blockquote><p><strong>关键点：</strong> 一个作用（effect）是指一个composable函数不会生成UI元素，而是当组合完成时生成副作用。</p></blockquote>

<p>由于Compose中有多种作用，很容易被滥用。要确保在副作用中做的事情是UI相关的并且没有违反『单一数据流原则』。</p>

<blockquote><p><strong>注意：</strong> 一个可响应的UI应该是异步的，Jetpack Compose解决异步的办法是在API级别结合协程而不是使用回调。想要了解更多的协程知识，可以参看<a href="https://juejin.cn/post/7329767824200826918">之前的文章</a>。</p></blockquote>

<h3>LaunchedEffect：在composable的作用域内运行挂起函数</h3>

<p>想要在一个composable的生命周期中执行操作并且需要调用挂起函数，就可以使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#LaunchedEffect(kotlin.Any,kotlin.coroutines.SuspendFunction1">LaunchedEffect</a>)。当LaunchedEffect进入组合时，它会使用作为参数传入的代码块来启动一个协程。如果LaucnhedEffect离开了组合协程会被取消。如果因不同的key LaunchedEffect被重组了（副作用的重启机制会在后面进行讲解），运行中的协程会被取消掉，一个新的协程会被启动以运行新的挂起函数。</p>

<p>例如，一个可调节延迟的脉冲式透明度的动画：</p>

<pre><code class="Kotlin">// 变化的速率可以调节，可以加快动画（减少间隔）
var pulseRateMs by remember { mutableStateOf(3000L) }
val alpha = remember { Animatable(1f) }
LaunchedEffect(pulseRateMs) { // 速度作为key，这样速度变化时，会重启副作用，动画也会重启
    while (isActive) {
        delay(pulseRateMs) // 一定间隔之后显示脉冲动画
        alpha.animateTo(0f)
        alpha.animateTo(1f)
    }
}
</code></pre>

<p>在上面的代码中，动画使用了挂起函数<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html">delay</a>来等待一定的时间。然后，它依次使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/animation/core/Animatable#animateTo(kotlin.Any,androidx.compose.animation.core.AnimationSpec,kotlin.Any,kotlin.Function1">animateTo</a>)展现动画到不可见，再到可见。并在composable的生命周期中不断重复。</p>

<h3>rememberCoroutineScope：获取一个可以在composable之外启动协程的可感知组合的协程作用域</h3>

<p>因为LaunchedEffect是一个composable函数，所以它只能在其他composable函数中调用。如果想要在composable作用域之外启动协程，但又希望限制协程在一定的范围内，以便能在离开组合时协程自动被取消，可以使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#rememberCoroutineScope(kotlin.Function0">rememberCoroutineScope</a>)。在任何需要手动操控一个或者多个协程的生命周期的时候都应该使用rememberCorountineScope，比如说当用户事件发生时需要取消动画。</p>

<p>rememberCoroutineScope是一个composable函数，返回一个协程作用域（CoroutineScope），这个作用域会被绑定到经组合中它被调用的地点。当离开组合时，这个协程作用域会被取消。</p>

<blockquote><p><strong>译注：</strong> 如果对协程作用域不太熟悉的同学，可以参看<a href="https://juejin.cn/post/7324351711660048411">之前的文章</a>。</p></blockquote>

<p>例如，可以用下面的代码，当点击按扭时显示一个Snackbar（译注：非干扰式提示，类似于Toast）：</p>

<pre><code class="Kotlin">@Composable
fun MoviesScreen(snackbarHostState: SnackbarHostState) {

    // 创建一个绑定到MoviesScreen生命周期的协程作用域
    val scope = rememberCoroutineScope()

    Scaffold(
        snackbarHost = {
            SnackbarHost(hostState = snackbarHostState)
        }
    ) { contentPadding -&gt;
        Column(Modifier.padding(contentPadding)) {
            Button(
                onClick = {
                    // 在作用域中创建一个协程来显示提示。
                    scope.launch {
                        snackbarHostState.showSnackbar("Something happened!")
                    }
                }
            ) {
                Text("Press me")
            }
        }
    }
}
</code></pre>

<h3>rememberUpdateState：指向即使值发生变化也不会重启的作用中的一个值</h3>

<p>当参数key中的任何一个发生变化时LaunchedEffect就会重启。然而，在有些情况下我们希望捕获这样作用中的一个值，这个作用不会随着值变化而重启。为了达到这样的效果，需要使用rememberUpdatedState创建一个能被捕获和更新的值的引用。这个方式对于那些含有长时间运行，且重新创建或者重启都非常昂贵之类的操作的副作用是很有用的。</p>

<p>例如，假设你的应用有一个一段时间内消失的加载页面（LandingScreen）。即使这个加载页面被重组了，等待时间副作用和通知已过去了多少时间副作用都不应该被重新启动：</p>

<pre><code class="Kotlin">@Composable
fun LandingScreen(onTimeout: () -&gt; Unit) {

    // 这个状态永远指向LandingScreen重组后最新的onTimeout函数
    val currentOnTimeout by rememberUpdatedState(onTimeout)

    // 创建一个与LandingScreen生命周期一致的副作用。即使LandingScreen被重组了，这里的延迟不应该重新开始.
    LaunchedEffect(true) {
        delay(SplashWaitTimeMillis)
        currentOnTimeout()
    }

    /* 加载页面的内容 */
}
</code></pre>

<p>想要创建一个与调用点生命周期一至的副作用，可以把像Unit或者true等永不会改变的常量当作参数。在上面的例子中，使用了LaunchedEffect(true)。为了保证lambda onTimeout中总是包含LandingScreen被重组后的最新值，onTimeout需要使用rememberUpdatedState来包装。返回值，就是代码中的currentOnTimeout应该在副作用中使用。</p>

<blockquote><p><strong>注意：</strong> LaunchedEffect(true)就像while(true)一样诡异。即使有具体的使用场景，也要三思后行，确保确实需要这样做。</p></blockquote>

<h3>DisposableEffect：需要清理工作的副作用</h3>

<p>对于当离开组合或者key发生变化时需要清朝工作的副作用，使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#DisposableEffect(kotlin.Any,kotlin.Function1">DisposableEffect</a>)。如果DisposableEffect的key发生变化，调用的composable需要进行清理副作用，并且重新调用。</p>

<p>作为一个示例，通过使用<a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleObserver">LifecycleObserver</a>，你也许想要发送基于平台生命周期事件（Lifecycle events）统计事件数据（译注：这里的生命周期是指Android平台组件的生命周期）。想要在Compose中监听这些事件，使用一个DisposableEffect来在需要时注册和反注册观察者：</p>

<pre><code class="Kotlin">@Composable
fun HomeScreen(
    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,
    onStart: () -&gt; Unit, // 发送'started' 事件
    onStop: () -&gt; Unit // 发磅 'stopped' 事件
) {
    // 保证当前的lambda是最新的
    val currentOnStart by rememberUpdatedState(onStart)
    val currentOnStop by rememberUpdatedState(onStop)

    // 如果 `lifecycleOwner` 发生变化，清理并重置副作用函数
    DisposableEffect(lifecycleOwner) {
        // 创建一个观察者以触发我们的事件发送回调lambda
        val observer = LifecycleEventObserver { _, event -&gt;
            if (event == Lifecycle.Event.ON_START) {
                currentOnStart()
            } else if (event == Lifecycle.Event.ON_STOP) {
                currentOnStop()
            }
        }

        // 把观察者添加到生命周期观察者列表里
        lifecycleOwner.lifecycle.addObserver(observer)

        // 当离开组合时，进行清理工作，即把观察者从其列表中移除
        onDispose {
            lifecycleOwner.lifecycle.removeObserver(observer)
        }
    }

    /* Home screen content */
}
</code></pre>

<p>在上面的代码中，副作用会添加一个观察者observer到lifecycleOwner上。如果lifecycleOwner有变动，副作用函数会被清理并且使用新的lifecycleOwner重启。</p>

<p>一个DispoableEffect必须要包含一个onDispose语句作为其代码块的最后一个语句。否则会有编译错误。</p>

<blockquote><p><strong>注意：</strong> 使用一个空的onDispose并不是一个好的做法。要多思考一下是否有更加符合使用场景的副作用函数。</p></blockquote>

<h3>SideEffect：向非Comopse代码发布Compose的状态</h3>

<p>要与非Compose管理的对象共享Compose状态时，使用composable <a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#SideEffect(kotlin.Function0">SideEffect</a>)。使用SideEffect能够保证副作用在每次成功重组后都能得到执行。另一方面，在一个重组保证成功之前执行一个副作用是不正确的，这种场景就会直接在composable中写入副作用。</p>

<p>例如，你的分析库也许允许你通过给后面的统计数据添加自定义的meta data（在此例中是『user properties』）的方式来给用户数据分段。为了建立当前用户的用户类型与统计库之间的联系，可以使用SideEffect来更新此值：</p>

<pre><code class="Kotlin">@Composable
fun rememberFirebaseAnalytics(user: User): FirebaseAnalytics {
    val analytics: FirebaseAnalytics = remember {
        FirebaseAnalytics()
    }

    // 每次成功组合，用当前用户的用户类型来更新 FirebaseAnalytics，保证
    // 后面的统计事件能带上userType
    SideEffect {
        analytics.setUserProperty("userType", user.userType)
    }
    return analytics
}
</code></pre>

<h3>produceState：把非Compose状态转化为Compose状态</h3>

<p><a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#produceState(kotlin.Any,kotlin.coroutines.SuspendFunction1">produceState</a>)启动一个受组合管控的协程作用域，其中可以把值转化为状态。用它可以把非Compose状态转化为Compose状态，例如把外部由订阅驱动 的值如Flow，LiveData或者RxJava转化到组合中。</p>

<p>当produceState进入组合时生产者就会被启动，然后当离开组合时被取消。返回的状态会合并：就是说相同的值不会再次触发重组。</p>

<p>尽管produceState会创建协程，它也能用来监听非挂起数据。想要移除对数据的订阅，使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/ProduceStateScope#awaitDispose(kotlin.Function0">awaitDispose</a>)函数。</p>

<p>下面的例子展示如何使用produceState来从网络加载图片。Composable函数loadNextworkImage返回一个可以用在其他composables中的状态：</p>

<pre><code class="Kotlin">@Composable
fun loadNetworkImage(
    url: String,
    imageRepository: ImageRepository = ImageRepository()
): State&lt;Result&lt;Image&gt;&gt; {

    // 用 Result.Loading 作为初值，创建一个状态 State&lt;T&gt;
    // 如果 「url」或者「imageRepository」任何一个发生变化，运行中的生产者会被取消
    // 使用新的输入被重启。
    return produceState&lt;Result&lt;Image&gt;&gt;(initialValue = Result.Loading, url, imageRepository) {

        // 在协程里，可以调用挂起函数
        val image = imageRepository.load(url)

        // 使用成功或者失败作为结果 来更新状态
        // 这会触发读取此状态的composable的重组
        value = if (image == null) {
            Result.Error
        } else {
            Result.Success(image)
        }
    }
}
</code></pre>

<blockquote><p><strong>注意：</strong> 带有返回值的composable函数应该以常规的Kotlin函数命名规范进行命名，以小写字符开头的驼峰式。</p></blockquote>

<p><br/></p>

<blockquote><p><strong>关键点：</strong> 进一步的了解，produceState使用了其他的副作用函数！它使用remember { mutableStateOf(initialValue) }来持有返回结果，然后在一个LaunchedEffect中触发生产者代码块。每当生产者代码块中更新了value的值，相应的状态也会被更新。
开发者也可以基于现有的API来创造想要的副作用函数</p></blockquote>

<h3>derivedStateOf：把一个或者多个状态对象转化为另一个状态</h3>

<p>在Compose中，每次当被观察的状态对象发生变化或者composable的输入有变化时重组就会发生。状态对象或者输入可能变化次数的超过了UI实际的需要，导致了不必要的重组。</p>

<p>当一个composable的输入变化超过了重组所需要时就应该使用函数<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#derivedStateOf(kotlin.Function0">deriveStateOf</a>)。比较觉的场景是当有些变量频繁的变动，比如滚动位置，但composable仅需要变动超过一定阈值时才需要对其响应。derivedStateOf创建一个新的仅在需要时更新的可观察Compose状态。这样，它就类似于Kotlin Flow中的操作符<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/distinct-until-changed.html">distinctUntilChanged</a>。</p>

<blockquote><p><strong>注意：</strong> derivedStateOf是比较昂贵的（也即性能开销比较大），应该仅用来减少结果未变化时的不必要的重组。</p></blockquote>

<h4>正确的使用</h4>

<p>下面的代码片段展示一个恰当的使用derivedStateOf的场景：</p>

<pre><code class="Kotlin">@Composable
// 当参数 messages 变化时, MessageList会被重组. derivedStateOf不会影响这个重组
fun MessageList(messages: List&lt;Message&gt;) {
    Box {
        val listState = rememberLazyListState()

        LazyColumn(state = listState) {
            // ...
        }

        // 当第一个可见的元素不是第一个元素时显示按扭。用一个被记忆的衍生状态来最小化不必要的重组
        val showButton by remember {
            derivedStateOf {
                listState.firstVisibleItemIndex &gt; 0
            }
        }

        AnimatedVisibility(visible = showButton) {
            ScrollToTopButton()
        }
    }
}
</code></pre>

<p>在这个代码片段中，每次第一个可见的元素变化时firstVisibleItemIndex都会变化。当滚动时，它的值会变成0，1，2，3，4，5等等。然而，仅当值大于0时才需要重组。这个更新频次的不匹配意味着是一个使用derivedStateOf的好的场景。</p>

<h4>错误的使用</h4>

<p>一个常见的错误是想当然的认为当需要合并两个状态时，就需要使用derivedStateOf，因为在创建衍生状态。然而这完全是凭空想像的也不是必须的，如下面代码所展示：</p>

<blockquote><p><strong>注意：</strong> 下面的代码展示derivedStateOf不正确的用例。不要这样使用。</p></blockquote>

<pre><code class="Kotlin">// 不要这样用，不正确的derivedStateOf的用法
var firstName by remember { mutableStateOf("") }
var lastName by remember { mutableStateOf("") }

val fullNameBad by remember { derivedStateOf { "$firstName $lastName" } } // 很糟糕
val fullNameCorrect = "$firstName $lastName" // 不正确
</code></pre>

<p>这段代码中，fullName的更新频次与firstName和lastName是一样的。因此，不会有不必要的重组发生，使用derivedStateOf是多余的。</p>

<h3>snapshotFlow</h3>

<p>使用<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#snapshotFlow(kotlin.Function0">snapshotFlow</a>)能把状态对象（<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/State">State<T></a> objects）转化为一个冷流（cold Flow）。当被订阅（collected）时snapshotFlow会运行代码块在其中发送它读取到的状态对象。当在snapshotFlow代码块中读取的状态对象发生变化时，Flow会发送新的数据给它的订阅者，如果这个新的数据没有被发送过（这个行为与<a href="https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/distinct-until-changed.html">Flow.distinctUntilChanged</a>是类似的）。</p>

<blockquote><p><strong>译注：</strong> 对Flow不熟悉的同学可以参看<a href="https://juejin.cn/post/7336751931375648820">之前的文章</a>。</p></blockquote>

<p>下面的例子展示一个副作用，用以记录当用户滑动超过列表中首个元素时的统计信息：</p>

<pre><code class="Kotlin">val listState = rememberLazyListState()

LazyColumn(state = listState) {
    // ...
}

LaunchedEffect(listState) {
    snapshotFlow { listState.firstVisibleItemIndex }
        .map { index -&gt; index &gt; 0 }
        .distinctUntilChanged()
        .filter { it == true }
        .collect {
            MyAnalyticsService.sendScrolledPastFirstItemEvent()
        }
}
</code></pre>

<p>在上面的代码中，listState.firstVisibleItemIndex会被转化为一个Flow，方便使用Flow操作符带来的便利。</p>

<h2>副作用的重启</h2>

<p>Compose中的一些副作用，像LaunchedEffect，produceState，DispoableEffect，接收不定数量的参数keys，这些参数用于取消正在进行中的副作用和使用新的参数启动新的副作用。</p>

<p>这些API的典型形式是：</p>

<pre><code class="Kotlin">EffectName(restartIfThisKeyChanges, orThisKey, orThisKey, ...) { block }
</code></pre>

<p>由于这个行为的细微性质，如果用于重启副作用的参数并不是正确的参数时，就会产生问题：</p>

<ul>
<li>副作用重启次数少于预期可能会产生bug</li>
<li>重启次数多于预期是冗余的，影响性能</li>
</ul>


<p>首要的原则是，在副作用代码块中使用的可变的和不可变的变量都应该当成composable函数的参数。此外，也可以添加更多的参数以强制重启副作用。如果一个变量的变化不应该导致重启副作用，那这个变量应该用rememberUpdateState包裹起来。如果一个变量因为包裹在remember时没有key而永远不会变化，那么这个变量就应该作为key传给副作用函数。</p>

<blockquote><p><strong>关键点：</strong> 在副作用函数中使用的变量应该添加为函数的参数，或者使用rememberUpdateState包裹起来。</p></blockquote>

<p>在上面展示的DisposbaleEffect代码中，在代码块中使用的变量lifecycleOwner作为副作用函数的一个参数，因为它们的任何变化都会引发重启副作用。</p>

<pre><code class="Kotlin">@Composable
fun HomeScreen(
    lifecycleOwner: LifecycleOwner = LocalLifecycleOwner.current,
    onStart: () -&gt; Unit, // Send the 'started' analytics event
    onStop: () -&gt; Unit // Send the 'stopped' analytics event
) {
    // 这些值在组合中永不会变化，因此用remember包裹起来，以免引发冗余重启
    val currentOnStart by rememberUpdatedState(onStart)
    val currentOnStop by rememberUpdatedState(onStop)

    DisposableEffect(lifecycleOwner) {
        val observer = LifecycleEventObserver { _, event -&gt;
            /* ... */
        }

        lifecycleOwner.lifecycle.addObserver(observer)
        onDispose {
            lifecycleOwner.lifecycle.removeObserver(observer)
        }
    }
}
</code></pre>

<p>currentOnState和currentOnStop不需要作为DisposableEffect的参数key，因为使用了rememberUpdateState它们在组合中始终不会变化。如果不把lifecycleOwner作为参数传递，然后它又发生了变化，HomeScreen会重组，但DisposableEffect不会被清理和重启。这会导致之后使用的都是错误的lifecyleOwner（译注：因为lifecycleOwner可能会发生变化）。</p>

<h3>常量作为key</h3>

<p>可以使用像true这样的常量当作副作用的key，以让它跟它所在的调用点有一样的生命周期。有一些场景适合这样用：比如前面例子中的LaunchedEffect。但是，在这样做之前还是要三思是否真的要这样。</p>

<h2>总结</h2>

<p>函数式编程的理想情况是每个函数都没有副作用，但实际情况副作用却是必须的。通过本文我们学习了如何使用Jetpack Compose提供的副作用函数以解决修改composable范围以外的状态的问题。副作用问题比较难以实现且容易产生难以debug的问题，要仔细分析问题的场景，根据场景选择合适的副作用函数。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[降Compose十八掌之『损则有孚』| Lifecycle]]></title>
    <link href="http://toughcoder.net/blog/2024/08/18/jetpack-compose-lifecycle/"/>
    <updated>2024-08-18T12:14:35+08:00</updated>
    <id>http://toughcoder.net/blog/2024/08/18/jetpack-compose-lifecycle</id>
    <content type="html"><![CDATA[<blockquote><p>这篇文章大部分是<a href="https://developer.android.com/develop/ui/compose/lifecycle">官方文档</a>的翻译，但并不是严格的翻译，同时也加入了笔者自己的理解。</p></blockquote>

<p>通过前面的一系列文章我们已经基本掌握了使用Jetpack Compose来构建UI的方法，在接下来的几篇文章中将重点转移到Compose本身，理解一下Compose是如何把一坨坨的函数（Composables）转化成为目标平台UI的。先从composable的生命周期开始。</p>

<p><a href=""><img src="https://koenig-media.raywenderlich.com/uploads/2022/05/LifecycleOfComposablesInJetpackCompose-twitter.png" title="auto auto" ></a></p>

<!-- more -->


<p><strong>注意：</strong> 这里的生命周期是指Compose中的基本单元composable函数的生命周期，与目标平台（如Android）的生命周期不是一个概念，没有关系。</p>

<h2>概述</h2>

<p>在前面<a href="https://juejin.cn/post/7376094685495001139">讲解状态（State）的文章</a>中提到过，composable函数是Jetpack Compose的基本单元，运行composables就是组合（Composition），组合将会变成应用的UI。</p>

<p>当Jetpack Compose首次运行composables时，也即首次组合（Initial composition），它会追踪在组合中用来描述UI的composables。之后，当有状态变化时，Jetpack Compose会安排重组。重组就是重新执行状态发生变化的composables以作为对状态变化的响应，然后再更新组合体现变更。</p>

<p>组合仅能在首次组合过程中生成然后在重组中更新。修改组合的唯一方式就是通过重组。</p>

<h2>生命周期定义</h2>

<p>一个composable的生命周期可以用三个事件来定义：进入组合，重组，离开组合。</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-composition.png" alt="lifecycle" /></p>

<blockquote><p>图1. 组合中的一个composable的生命周期：进入组合，没有重组或者重组多次，最后离开组合。</p></blockquote>

<p>重组通常都是由状态对象发生变化触发的。Compose会追踪这些状态然后执行在组合中读取这些状态的所有composables，以及被这些composables调用的且无法被跳过的composables。</p>

<p><strong>注意：</strong> Composable的生命周期较View系统和Android平台的Activity以及Fragment要相对简单一些。如果一个composable需要处理外部的资源或者管理更为复杂的生命周期，可以使用副作用（Side Effects）。</p>

<p>如果一个composable被调用了多次，就会有多个实例被放入到组合之中。每一次调用都有独立的属于它自己的生命周期。来看一个例子：</p>

<pre><code class="Kotlin">@Composable
fun MyComposable() {
    Column {
        Text("Hello")
        Text("World")
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-hierarchy.png" alt="composition" /></p>

<blockquote><p>图2. 在组合中MyComposable的可视化表示。如果一个composable被调用了多次，会在组合中生成多个实例。图中不同颜色的元素代表不同的实例。</p></blockquote>

<h2>剖析组合中的composables</h2>

<p>组合中一个composable实例是用其调用点来标识的。Compose编译器认为每个调用点都是不一样的。从多个调用点调用composables会在组合中创建多个实例。</p>

<p><strong>关键术语：</strong> 调用点指的是composable被调用的代码位置。调用点会影响组合，进而影响最终UI。</p>

<p>在重组过程中，如果一个composable调用了与其上一次重组中调用的不同的composables，Compose会标识出哪些composables已调用过，哪些还未被调用过，对于两次组合中都调用了的composables，如果它们的输入没有变化则Compose不会予以执行。</p>

<p>因此，给关联到composable的副作用（各种Side Effects）指定标识就显得龙为重要，这样它们能成功的执行完成，而不是每次重组时都重新启动。</p>

<p>对于下面这个例子：</p>

<pre><code class="Kotlin">@Composable
fun LoginScreen(showError: Boolean) {
    if (showError) {
        LoginError()
    }
    LoginInput() // This call site affects where LoginInput is placed in Composition
}

@Composable
fun LoginInput() { /* ... */ }

@Composable
fun LoginError() { /* ... */ }
</code></pre>

<p>上面的代码中，函数LoginScreen会在一定条件下调用函数LogginError，并且总是会调用函数LoginInput。每个调用都有一个独一无二的调用点和代码位置，编译器正是用这些信息来独一无二的标识每个composable。
<img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-showerror.png" alt="recomposition" /></p>

<blockquote><p>图3. 在组合中，当有状态变化和重组发生时，LoginScreen的可视化展示。相同的颜色元素代表没有被重组。</p></blockquote>

<p>尽管LoginInput从第一个被调用的函数变成了第二个被调用的函数，它的实例在重组中得以留存。并且，因为LoginInput并没有在重组之间发生变化的参数，Compose会跳过对LoginInput的再次调用。</p>

<h2>提供额外的信息以优化重组</h2>

<p>多次调用一个composable会在组合中添加多个实例。当在同一个调用点多次调用同一个composable时，因为Compose没有可用的信息来独一无二的标识每个调用，所以composable的执行顺序被用以区别这些composable实例。有些时候这也够用了，但有些时候这会导致一些非预期的行为。</p>

<pre><code class="Kotlin">@Composable
fun MoviesScreen(movies: List&lt;Movie&gt;) {
    Column {
        for (movie in movies) {
            // MovieOverview composables are placed in Composition given its
            // index position in the for loop
            MovieOverview(movie)
        }
    }
}
</code></pre>

<p>在上面的代码中，Compose会用执行顺序来区别调用的composable实例。如果一个新的数据元素movie被添加到了列表的底部（最后面），Compose可以复用已经在组合中的实例，因为它们的位次没有变化，故而这些composable的输入数据元素movie并不会变化，也就是说因为只在最后添加，先前存在的实例与其数据还是能够对应得上的。</p>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-newelement-bottom.png" alt="no_key" /></p>

<blockquote><p>图4. 当一个新数据元素moviei添加到列表底部后时，组合中MovieScreen的可视化表示。组合中函数MovieOverview的实例会被复用。相同颜色的元素表示未被重组。</p></blockquote>

<p>然而，如果输入列表的变化是在其顶部添加新元素，或者在中间添加新元素，或者有移除，或者变化元素顺序时，就会对列表中位置发生变化的所有MovieOverview进行重组。如果有储如在MovieOverview中获取电影图片的副作用函数的话，这些仅因位置改变而发生的重组就特别重要了。因为重组会影响副作用函数，如果副作用正在进行中，会被取消然后重新启动。</p>

<pre><code class="Kotlin">@Composable
fun MovieOverview(movie: Movie) {
    Column {
        // Side effect explained later in the docs. If MovieOverview
        // recomposes, while fetching the image is in progress,
        // it is cancelled and restarted.
        val image = loadNetworkImage(movie.url)
        MovieHeader(image)

        /* ... */
    }
}
</code></pre>

<p><img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-newelement-top-all-recompose.png" alt="side_effect" /></p>

<blockquote><p>图5. 新元素添加到列表中时组合中MovieScreen的可视化表示。MovieScreen实例无法复用，所有的副作用会重启。不同的颜色代表发生了重组。</p></blockquote>

<p>理想情况下，应该让函数MovieScreen的实例标识与其数据项的标识联系起来。如果列表数据项顺序有变化，最为想理的办法是也把组合树中的对应的函数实例进行次序调整，而不是进行重组（前面说了次序作为函数实例的标识，次序变了，就要使用新位置的数据项调用composable进行重组）。Compose给我们提供了一个方法用以标识组会树中的函数实例：即<a href="https://developer.android.com/reference/kotlin/androidx/compose/runtime/package-summary#key(kotlin.Array,kotlin.Function0">函数key</a>)。</p>

<p>把代码块放入函数key里面，再传给函数key一些数据，这些数据会被组合起来以标识组合中的函数实例。传给函数key的数据不必是全局唯一的，它只需要在key所在的调用点是唯一的就行。比如在前面例子中，每个数据项movie需要有一个唯一的标识，它能在这个列表中唯一标识一部电影就可以了：</p>

<pre><code class="Kotlin">@Composable
fun MoviesScreenWithKey(movies: List&lt;Movie&gt;) {
    Column {
        for (movie in movies) {
            key(movie.id) { // Unique ID for this movie
                MovieOverview(movie)
            }
        }
    }
}
</code></pre>

<p>像上面用了key以后，无论列表怎么变化，Compose都能辩识出具体composable实例，然后加以复用：
<img src="https://developer.android.com/static/develop/ui/compose/images/lifecycle-newelement-top-keys.png" alt="key" /></p>

<blockquote><p>图6. 当新数据元素添加到列表时组合中MovieScreen的可视化展示。因为有了唯一标识，Compose能识别出哪些实例未发生变化，加以复用，它们附带的副作用会继续执行。</p></blockquote>

<p><strong>关键点：</strong> 适度的使用函数key来帮助Compose唯一标识函数实例。特别是针对在同一个调用点大量调用同一个composable时，比如在各种集合性布局中。</p>

<p>有些composable有更为友好的key支持方法。比如像LazyColumn它可以直接在其items DSL中传入一个lambda作为key：</p>

<pre><code class="Kotlin">@Composable
fun MoviesScreenLazy(movies: List&lt;Movie&gt;) {
    LazyColumn {
        items(movies, key = { movie -&gt; movie.id }) { movie -&gt;
            MovieOverview(movie)
        }
    }
}
</code></pre>

<h2>重组时跳过composable的策略</h2>

<p>在重组过程中，一些具备条件的composable函数可以让Compose跳过他们的执行，如果它们的输入参数较前一次组合时没有任何变化。
除了以下情况外，就可以说一个composable函数具备跳过条件：</p>

<ul>
<li>函数有返回值（non-Unit return type）</li>
<li>函数使用了注解&#64;NonRestartableComposable或者&#64;NonSkippableComposable修饰</li>
<li>必需的参数是一个非稳定类型（non-stable type）</li>
</ul>


<p>前两个都好理解，接下来重点看第三个情况。一个类型要想成为稳定的（stable），必须符合以下约定：</p>

<ul>
<li>对于两个相内实例来说，对其们使用equals方法的返回值必须永远相同</li>
<li>如果一个类型的公开属性发生变化，组合会得到通知</li>
<li>所有公开属性类型也必须是稳定的</li>
</ul>


<p>有一些重要的常见类型符合这个约定，Compose编译器会把它们当成稳定的类型，尽管他们并没有使用注解&#64;Stable显式地标注为稳定的：</p>

<ul>
<li>所有的基础数据类型：布尔（Boolean），整数（Int），长整数（Long），浮点（Float），字符（Char）等</li>
<li>字符串（String）</li>
<li>所有的函数类型（lambdas）</li>
</ul>


<p>所有这些类型都能符合稳定约定，因为他们都是不可变类型。因为不可变类型实例不会改变，它们不会通知组合说值有所改变，因此就能符合上述约定。</p>

<p><strong>注意：</strong> 所有的整体不可变类型都可以安全地当成稳定的类型。</p>

<p>一个值得注意的类型是可变状态类型（MutableState），虽然是稳定的但却可变可修改。如果MutableState中持有一个值，这个状态对象被认为是稳定的，因为State属性.value发生的任何变化都会通知给Compose。</p>

<p>当作为传递给一个composable函数参数的所有类型都是稳定的（stable）时，这些参数的值会基于它们在UI树中的函数位置进行等值比较（equality）。从前一次组合起如果值未变化就会跳过其重组。换句话说输入参数的类型是稳定的（stable）是一个大前提，只有稳定的类型比较等值才有意义。</p>

<p><strong>关键点：</strong> 如果一个composable的输入是稳定的且未有变化，Compose就会跳过它的重组。等值比较使用的是方法equals。</p>

<p>仅当Compose能够证明一个类型是稳定的时，才会把一个类型当作稳定的。例如，接口（interface）通常认为是不稳定的，拥有可变公开属性的类型，虽然这些属性的实现可以是不可变的，但这种类型也认为是不稳定的。</p>

<p>如果Compose无法推断出一个类型是不是稳定的，但是想强制它被当作稳定的类型，可以使用注解&#64;Stable来标注。</p>

<pre><code class="Kotlin">// Marking the type as stable to favor skipping and smart recompositions.
@Stable
interface UiState&lt;T : Result&lt;T&gt;&gt; {
    val value: T?
    val exception: Throwable?

    val hasError: Boolean
        get() = exception != null
}
</code></pre>

<p>上面的代码片段中，因为UiState是一个接口，会被当成不稳定的类型。通过添加注解&#64;Stable，告诉Compose它是稳定的，让Compose进行智能重组。这也意味着，当接口类型用于参数类型时，Compose会把接口的所有具体实现当成稳定的类型。</p>

<p><strong>关键点：</strong> 如果Compose无法推断出类型的稳定性，使用注解&#64;Stable来标注以让Compose进行智能重组。</p>

<h2>总结</h2>

<p>Composable函数是Compose的基本单元，通过此文我们理解了一个composable的生命周期，并对Compose的重组机制做了介绍，以及如何更好的让Compose做智能重组。</p>

<h2>References</h2>

<ul>
<li><a href="https://developer.android.com/develop/ui/compose/lifecycle">Lifecycle of composables</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
