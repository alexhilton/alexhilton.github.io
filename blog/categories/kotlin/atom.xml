<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Kotlin | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/kotlin/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2018-05-20T10:39:49+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[学习Kotlin，看这一篇就够了]]></title>
    <link href="http://toughcoder.net/blog/2018/05/17/introduction-to-kotlin-programming-language/"/>
    <updated>2018-05-17T20:51:21+08:00</updated>
    <id>http://toughcoder.net/blog/2018/05/17/introduction-to-kotlin-programming-language</id>
    <content type="html"><![CDATA[<h2>人生苦短，要用Kotlin</h2>

<p>这是一种对程序猿更为友好的语言，可以减少开发者的工作量，原本由开发者干的事情，其实很多都可以由编译器实现了，这是一种更为高级的语言。Java虽然严谨，但却过于繁琐，太啰嗦了，一个小事情却要写大量的代码，而且有些代码又是非常机械式的，在实际编码过程中都是用IDE来自动生成。Java，C，C++，Object C这些都是上世纪的编程语言。</p>

<p><a href=""><img src="https://fossbytes.com/wp-content/uploads/2017/09/Kotlin-programming-language-course.png"></a></p>

<p>现在到了新时代了，编程也发展了很多，像lambda表达式，函数式编程，等等一些新的概念和范式在涌现。所以就有了新时代的编程语言，像水果的Swift，Groovy，Scala，以及Java阵营的Kotlin。Kotlin是新一代的编程语言，与Java完美融合，简洁，方便，可以大大提高程序可读性，特别是对于Android开发者来说。水果推出了Swift以解放水果平台的开发者，而Kotlin就是来解放Android开发者的。</p>

<!-- more -->


<p>虽然说Kotlin可以用在任何可以用Java的地方，但目前主要就是两大领域服务端，以及Android应用开发，特别是有了Google官方的支持，所以Kotlin对于Android开发者的意义更为重大，身为一个Android猿，是一定要学习一下这门现代的编程语言的，因为当你学过了之后 ，你会发现，之前写的代码都是在浪费生命。</p>

<h2>Development environment setup</h2>

<p>有三种方式</p>

<h3>命令行</h3>

<p>其实，这是最好的方式，因为配置起来非常的方便。到<a href="https://kotlinlang.org/docs/tutorials/command-line.html">官网</a>去下载编译器，解压，然后把kotlinc/bin/放到PATH环境变量里面，就可以了。如果要配置Vim，还需要安装一下插件，大神们早就把插件准备好了，只需要<a href="https://github.com/udalov/kotlin-vim">下载</a>，然后按照官方方法安装即可，其实就是把解压后的东西拷贝到相应的目录里面就好了。</p>

<h3>Idea IntellJ</h3>

<p>这个看<a href="https://kotlinlang.org/docs/tutorials/getting-started.html">官方文档</a>就可以了，孤未亲测，如遇困难请自行Google。</p>

<h3>Android Studio</h3>

<p>因为Kotlin官已支持了Android Studio，而Google也支持了，总而言之就是在Android Studio中可以直接使用Kotlin。所以， Android Stuido 3.0以后的版本无需特殊配置，就可以用例Kotlin了。</p>

<p>对于刚开始学习Kotlin而言呢，孤推荐使用命令行的方式，而不要使用Android Studio，特别是直接创建一个基于Kotlin的Android项目，因为此时对语言还不够熟悉，直接上项目，会迷失在项目配置，frameworks以及语言基础之中。刚学习一门语言的时候要先学习基本的语法以及语言本身的特性，这最好先绕开框架和项目，会更容易上手一些。</p>

<h2>Hello world</h2>

<p>这是所有编程语言的入门必学课程，目的是让学习者快速的体验一下一门语言，我们也不用多想，照着一个字母，一个字母的把示例敲进去就好了：</p>

<ol>
<li>选择喜欢的文本编辑器，如Vim hello.kt，Kotlin的文件扩展名是*.kt，我们遵循就好。<br/></li>
<li>一字不差的敲进去:
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">package</span> <span class="nn">hello&lt;/li&gt;</span>
</span><span class='line'><span class="p">&lt;/</span><span class="n">ol</span><span class="p">&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="p">&lt;</span><span class="n">p</span><span class="p">&gt;</span><span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Hello</span><span class="p">,</span> <span class="n">world</span><span class="p">&amp;</span><span class="n">rdquo</span><span class="p">;)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">&lt;</span><span class="n">code</span><span class="p">&gt;</span>
</span><span class='line'><span class="err">然后，保存文件</span><span class="p">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">br</span><span class="p">/&amp;</span><span class="n">gt</span><span class="p">;</span>
</span><span class='line'><span class="m">3.</span> <span class="err">回到命令行，编译源码，如果一切顺利会得到一个叫</span><span class="n">hello</span><span class="p">.</span><span class="n">jar</span><span class="err">的文件，这就是</span><span class="n">kotlin</span><span class="err">的最终输出，也就是它的目标文件</span><span class="p">.</span>
</span><span class='line'><span class="p">&lt;/</span><span class="n">code</span><span class="p">&gt;</span><span class="n">bash</span>
</span><span class='line'><span class="n">kotlinc</span> <span class="n">hello</span><span class="p">.</span><span class="n">kt</span> <span class="p">-</span><span class="n">include</span><span class="p">-</span><span class="n">runtime</span> <span class="p">-</span><span class="n">d</span> <span class="n">hello</span><span class="p">.</span><span class="n">jar</span>
</span><span class='line'><span class="p">&lt;</span><span class="n">code</span><span class="p">&gt;&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">br</span><span class="p">/&amp;</span><span class="n">gt</span><span class="p">;</span>
</span><span class='line'><span class="m">4.</span> <span class="err">运行，这里跟</span><span class="n">Kotlin</span><span class="err">其实已经没啥关系了，因为经过编译得到的是一个标准的</span><span class="n">Jar</span><span class="err">文件，像运行其他</span><span class="n">jar</span><span class="err">一样运行就好了：</span>
</span><span class='line'><span class="p">&lt;/</span><span class="n">code</span><span class="p">&gt;</span><span class="n">bash</span>
</span><span class='line'><span class="n">java</span> <span class="p">-</span><span class="n">jar</span> <span class="n">hello</span><span class="p">.</span><span class="n">jar</span>
</span></code></pre></td></tr></table></div></figure>
就会得到输出Hello, world到此，第一个Kotlin程序已经完成，是不是很酷，已经迫不及待的想深入学习了！往下看吧。</p>

<h2>The basics</h2>

<h3>语句结构</h3>

<p>一行一个语句（先不纠结语句与表达式的区别），不用加分号，不用打分号，光这个就可以节省多少时间呢？是不是感觉人生都浪费在了分号上面。如果想在一行写多个语句，前面的要加上分号。</p>

<p>缩进规则与Java一致，用四个空格，也可以用tab，或者不加缩进，只要没人打你。</p>

<p>语句块需要加上花括号{}。总之，语句结构与Java很类似。</p>

<h3>变量</h3>

<p>用var来声明变量，用val来声明常量，因为Kotlin是静态强类型语言（也就是说每个变量在编译的时候必须知道类型）声明时需要带上类型，方法是在变量名的后面加冒号，空格跟上类型名字，与Pascal差不多。如果声明时直接定义，则可以不用指定类型，编译器会根据定义表达式来推测它的类型。示例：
<code>kotlin
var str: String
val i: Int
var str = "Hello, world"
</code></p>

<h3>语句和表达式</h3>

<p>主要想说一下语句和表达式的区别，简单来说就是表达式是有值的，可以放在变量赋值的右边，而语句是没有值的，不能放在赋值的右边</p>

<h3>基本运算</h3>

<p>不多说了，跟Java一样</p>

<h3>注释</h3>

<p>这个跟Java也一样：
// 单行注释
/<em> </em>/  多行注释
/<em>* </em>/ documentation</p>

<h3>函数</h3>

<p>以fun关键字来定义一个函数格式为：<em>fun 函数名(参数): 返回类型 {函数体}</em>，如:
<code>kotlin
fun foo(name: String): Int {
   return name.length()
}
</code>
命名参数和默认值，调用函数时可以把参数的名字带上，以增加可读性。声明函数时可以用默认值 ，以更好的支持函数的重载。如：
<code>kotlin
fun foo(name: String, number: Int = 42, toUpper: Boolean = false): String {}
</code>
使用时，可以指定参数的名字：
<code>kotlin
foo("a)
foo("b", number = 1)
foo("c", toUpper = true)
foo(name = "d", number = 2, toUpper = false)
</code>
表达式体如果一个函数体内只有一个表达式，且有返回值时，那么，可以直接把返回值放在函数 的后面，如：
<code>kotlin
fun foo(name: String): String = name.toUpperCase()
</code>
甚至还可以把返回类型的声明给省略掉，如：
<code>kotlin
fun foo(name: String) = name.toUpperCase()
</code>
跟Java不一样的是，Kotlin的函数可以声明为toplevel也就是跟class一个级别，也就是说不必非放在类里面，也就是说跟C和C++是类似的。此外，还可以函数赋值给一个变量，这个变量就像其他变量一样。</p>

<h3>类与对象</h3>

<h4>类的声明与对象创建</h4>

<p>用class来声明一个类型，用:来继承父类或者实现接口，不需要使用new来创建对象：
<code>kotlin
class Person {
   var name: String
   var age: Int
}
</code>
假如，一个类，是空的，没有内容，那么花括号{}是可以省略的：
<code>kotlin
class Person
</code>
创建对象：
<code>kotlin
var someone = Person()
</code></p>

<h4>Primary constructor</h4>

<p>构造方法，有所谓的primary constructor，可以直接写在类名的后面：
<code>kotlin
class Person constructor(name: String)
</code>
一般情况下，constructor 可以省略掉：
<code>kotlin
class Person(name: String)
</code>
初始化块因为primary constructor不能包含代码，所以，想要做些初始化工作就可以放在初始化块里面(initializer block)，也可以在定义属性时直接使用：
<code>kotlin
class Person(name: String) {
    var firstName: String = name
    init {
        println("First initializer block that prints ${name}")
    }
}
</code>
一般情况下，如果声明的属性变量在primary constructor中都有赋值（通过initializer block）的话，可以有更简洁的表达方式：
<code>kotlin
class Person(var name: String, var age: Int)
</code>
这相当于：
<code>kotlin
class Person(theName: String, theAge: Int) {
   var name: String = theName   var age: Int = theAge
}
</code>
如果primary construct前面要声明属性，或者有annotation的话，关键字constructor不能省略：
<code>kotlin
class Person public @Inect constructor(var name: String)
</code></p>

<h4>Secondary constructor</h4>

<p>如果primary constructor不能满足需求怎么办呢？还可以声明其他constructor，所谓的secondary constructor:
<code>kotlin
class Person {
   var name: String constructor(name: String）{
       this.name = name
   }
}
</code>
是不是看起来舒服一些，因为跟Java一样了，可以把primary constfuctor和second constructor联合起来一起用：
<code>kotlin
class Person(var name: String) {
    constructor(name: String, parrent: Person) : this(name) {
        parrent.addChild(this)
    }
}
</code>
这里要把secondary construct尽可能delegate到primary constructor，这里的delegate的意思就是primary constructor会在second constructor之前 执行，还有就是initiailzer block都是在primary construct中执行的，这就能保证initiliazer block在second constructor之前执行。即使没有显示的声明primary constructor，编译器还是会生成一个默认的primary constructor以及把secondary constructor默认的delegate到primary constrcutor上面。也就是说，会保证primary constructor以及initializer block执行在second constructor前面：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">class</span> <span class="nc">Constructors</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">init</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">println</span><span class="p">(&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Initializer</span> <span class="n">block</span><span class="p">&amp;</span><span class="n">rdquo</span><span class="p">;)</span>
</span><span class='line'>    <span class="p">}&lt;/</span><span class="n">p</span><span class="p">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="p">&lt;</span><span class="n">pre</span><span class="p">&gt;&lt;</span><span class="n">code</span><span class="p">&gt;</span><span class="n">constructor</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="n">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">println</span><span class="p">(</span><span class="s">&quot;second constructor&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">&lt;/</span><span class="n">code</span><span class="p">&gt;&lt;/</span><span class="n">pre</span><span class="p">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="p">&lt;</span><span class="n">p</span><span class="p">&gt;}&lt;/</span><span class="n">p</span><span class="p">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="p">&lt;</span><span class="n">p</span><span class="p">&gt;</span><span class="k">fun</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">Array</span><span class="p">&lt;</span><span class="n">String</span><span class="p">&gt;)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="py">c</span> <span class="p">=</span> <span class="n">Constructors</span><span class="p">(</span><span class="m">3</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">&lt;</span><span class="n">code</span><span class="p">&gt;</span>
</span><span class='line'><span class="err">输出：</span>
</span><span class='line'><span class="p">&lt;/</span><span class="n">code</span><span class="p">&gt;</span><span class="n">bash</span>
</span><span class='line'><span class="n">Initializer</span> <span class="n">block</span>
</span><span class='line'><span class="n">second</span> <span class="n">constructor</span>
</span></code></pre></td></tr></table></div></figure></p>

<h4>属性和访问方法</h4>

<p>Kotlin会为声明的属性生成默认的setter和getter：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">class</span> <span class="nc">Person</span><span class="p">(</span><span class="k">var</span> <span class="py">name</span><span class="p">:</span> <span class="n">Strring</span><span class="p">,</span> <span class="k">var</span> <span class="py">age</span><span class="p">:</span> <span class="n">Int</span><span class="p">)&lt;/</span><span class="n">p</span><span class="p">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="p">&lt;</span><span class="n">p</span><span class="p">&gt;</span><span class="k">val</span> <span class="py">p</span> <span class="p">=</span> <span class="n">Person</span><span class="p">(&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Kevin</span><span class="p">&amp;</span><span class="n">rdquo</span><span class="p">;,</span> <span class="m">24</span><span class="p">)</span>
</span><span class='line'><span class="n">p</span><span class="p">.</span><span class="n">getName</span><span class="p">()</span> <span class="c1">// 返回&quot;Kevin&quot;</span>
</span><span class='line'><span class="n">p</span><span class="p">.</span><span class="n">setAge</span><span class="p">(</span><span class="m">32</span><span class="p">)</span> <span class="c1">// age变成了32</span>
</span><span class='line'><span class="p">&lt;</span><span class="n">code</span><span class="p">&gt;</span>
</span><span class='line'><span class="err">如果想自定义</span><span class="n">setter</span><span class="err">和</span><span class="n">getter</span><span class="err">，也是可以的：</span>
</span><span class='line'><span class="p">&lt;/</span><span class="n">code</span><span class="p">&gt;</span><span class="n">kotlin</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="py">name</span><span class="p">:</span> <span class="n">String</span>
</span><span class='line'>        <span class="k">set</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="p">==</span> <span class="k">null</span> <span class="p">||</span> <span class="n">n</span> <span class="p">==</span> <span class="p">&amp;</span><span class="n">ldquo</span><span class="p">;&amp;</span><span class="n">rdquo</span><span class="p">;)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">name</span> <span class="p">=</span> <span class="p">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Unkown</span><span class="p">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">name</span> <span class="p">=</span> <span class="n">n</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">get</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="p">==</span> <span class="p">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Unkwon</span><span class="p">&amp;</span><span class="n">rdquo</span><span class="p">;)</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">return</span> <span class="p">&amp;</span><span class="n">ldquo</span><span class="p">;</span><span class="n">Nobody</span><span class="p">&amp;</span><span class="n">rdquo</span><span class="p">;</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">name</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<h4>定义类的方法</h4>

<p>跟声明普通函数一样，只不过是放在了类里面：
<code>kotlin
class Person(val name: String, val age: Int) {
    fun report() = "My name is $name, and I'm $age"
}
</code>
如果，要覆写父类的方法，需要使用在方法声明时加上override关键字。
<code>kotlin
class Doggy(val name: String) : Animal {
    override fun yell() = "Barking from $name"
}
</code></p>

<h4>访问权限</h4>

<p>访问权限也跟Java类似分为public，protected，private以及internal，前三个意义也都一样，只不过默认值不一样，在Java里，如果对成员没有指明，则是package scope，也就是同一个package可以访问，但是Kotlin默认是public的。</p>

<p>internal是module内部可见，有点类似于Java中的package，但是module定义跟package不一样，module是一组编译在一起的Kotlin文件，它跟编译打包有关系，简单的理解它的范围要比package要大。</p>

<p>还有就是类，默认是不可被继承的，相当于final class。如果想要允许继承就要在声明类的时候加上open。</p>

<h3>字串</h3>

<p>概念就不说了，大部分与Java一模一样的，像支持的方法等。唯一需要说的就是字串模板，就是说把其他类型转化为字串时，有较Java更为方便的方式：直接用$来把变量嵌入到字串之中，如：
<code>kotlin
val msg = "Error 1"
val count = 32
print("We got message $msg") //等同于"We got message " + msg
print("Total is $count") // Total is 32
</code></p>

<h3>lambda表达式</h3>

<p>首先要介绍一个概念，高阶函数，其实就是把另外函数当作参数的函数，或者说产生一个函数，也即把函数作为返回值 的函数。前面说过，函数是一级对象，可以像常规变量一样来使用，所以，就能把函数作为参数或者返回值来使用高阶函数。lambda表达式就是为高阶函数更方便使用而生的。</p>

<h4>lambda 表达式</h4>

<p>作为新时代的编程语言，都会支持函数式编程，而lambda表达 式又是函数式编程里面必不可少的一份子。其实啥是lambda表达式呢？说的简单点就是没有名字的函数，非常简短的，通常都是一两句话的没有名字的函数。就是长这个样子{A, B -> C}，这里面A，B是参数，C是表达式，如：
<code>kotlin
val sum = { x: Int, y： Int -&gt; x + y }
</code>
其中，参数的类型是可以省略的，因为编译器能从上下文中推测出来:
max(strings, { a, b -> a.length &lt; b.length }
表达式部分，可以不止一个，最后一个表达式作为返回值。</p>

<p>当把一个lambda表达作为最后一参数，传给某个函数时，可以直接把lambda表达式写在参数的外面，比如：
<code>kotlin
val product = items.fold(1) { acc, e -&gt; acc * e }
</code>
而当lambda是唯一的参数时，也可以把参数的括号省略掉：
<code>kotlin
run { println("Hello, world") }
</code>
还有就是，如果lambda表达中只有一个参数，那么参数也可以省略，直接写表达式:
<code>kotlin
eval{ x * x }
</code></p>

<h4>函数类型</h4>

<p>前面提到了函数是可以像普通变量一样使用的一级类，也就是说它是一个类型。它的具体形式是: (A, B)->C，其中括号内的是参数，C是返回类型，如：
<code>kotlin
val sum: (Int, Int)-&gt;Int = { x, y -&gt; x + y }
val square: (Int)-&gt;Int = { x -&gt; x * x }
</code>
为啥要提一下函数类型呢，因为有时需要声明高阶函数：
<code>kotlin
fun walk(f: (Int)-&gt;Int)
fun run(f: ()-&gt;Unit)
</code>
Unit是一个特殊的返回值，相当于void，意思就是此函数没有返回值。</p>

<h3>集合</h3>

<p>其实大部分跟Java是一样的。只不过有一些函数式的操作，要多注意使用，从而让代码更简洁，如：</p>

<ul>
<li>遍历</li>
<li>过滤</li>
<li>映射</li>
<li>排序</li>
<li>折叠</li>
<li>分组</li>
<li>归类</li>
</ul>


<p>这些操作，对于大家应该都不难理解，就不一一解释了，来断代码就知道了：
<code>kotlin
fun collectionTests() {
    val list = listOf("Apple", "Google", "Microsoft", "Facebook", "Twitter", "Intel", "QualComm", "Tesla")
    // 遍历，以进行某种操作
    list.forEach{ println(it) }
    //按条件进行过滤，返回条件为true的
    val short = list.filter { it.length &lt; 6 }
    println(short) // [Apple, Intel, Tesla]
    // 把列表元素映射成为另外一种元素
    val lenList = list.map{ it.length }
    println("Length of each item $lenList") //Length of each item [5, 6, 9, 8, 7, 5, 8, 5]
    // 按某种条件进行排序
    val ordered = list.sortedBy { it.length }
    println("Sorted by length $ordered") // Sorted by length [Apple, Intel, Tesla, Google, Twitter, Facebook, QualComm, Microsoft]
    // 折叠，用累积的结果继续遍历
    val joint = list.fold("", {partial, item -&gt; if (partial != "")  "$partial, $item" else item })
    println("Joint list with comma $joint") // Joint list with comma Apple, Google, Microsoft, Facebook, Twitter, Intel, QualComm, Tesla
    //分组，用某种条件 把列表分成两组
    val (first, second) = list.partition { it.length &lt; 6 }
    println("Length shorter than 6 $first") // Length shorter than 6 [Apple, Intel, Tesla]
    println("Longer than 6 $second") // Longer than 6 [Google, Microsoft, Facebook, Twitter, QualComm]
    // 归类，按某种方法把元素归类，之后变成了一个Map
    val bucket = list.groupBy { it.length }
    println("$bucket is a map now") //{5=[Apple, Intel, Tesla], 6=[Google], 9=[Microsoft], 8=[Facebook, QualComm], 7=[Twitter]} is a map now
}
</code></p>

<h3>null处理</h3>

<p>为了有效的减少空指针异常，Kotlin加入了Nullable类型，核心的原理是这样的：声明类型的时候要明确的告诉编译器，这个变量是否可能为null，如果可能为null，那么可以赋null给这个变量，并且在使用此变量时必须检查是否为null；假如这个变量不可能为null，那么是不可以赋null给此变量的。也就是说，编译器会帮忙做一些检查，以减少NullPointerException的发生。</p>

<h4>Nullable变量</h4>

<p>默认的变量声明都是不可为null的，如:
<code>kotlin
var safe: String
safe = null // 会有compile error
</code>
要想允许变量为null，要在类型后面加一个问号，以告诉编译器这是一个nullable类型：
<code>kotlin
var danger: String?
danger = null // OKay
</code>
使用时，nullable不能直接使用，必须检查是否为null:
<code>kotlin
safe.length // okay
danger.length // compile error, danger could be null
</code></p>

<h4>检查Nullable的真伪</h4>

<p>可以用传统方式：
<code>kotlin
val len = if (danger != null) danger.length else -1
</code></p>

<h5>Safe call</h5>

<p>既然有Nullable类型，自然就有配套的方式来更方便的使用它：
<code>kotlin
val len = danger?.length
</code>
如果danger是null就返回null，否则返回长度，注意它的返回值是一个Int?（又是一个Nullable类型)。这个还能链起来：
<code>kotlin
bob?.department?.head?.name
</code>
如果任何一环为null，则直接返回null。是不是感觉省了好多if (a == null)判断。</p>

<h5>Elvis operator</h5>

<p>假如不能接受safe call返回的null，咋办呢？想提供默认值的呢？也有方式：
<code>kotlin
val len = danger?.length
println(len ?: -1)
</code>
稍有点绕哈，首先，danger?.length返回一个Int?吧，那么?:的作用就是如果len是null，那么就返回-1,否则返回它的值。</p>

<h5>强制取值符！！</h5>

<p>它的作用是如果Nullable变量为null就抛出NullPointerException，如果正常的话就取其值，返回的类型是一个non-null类型：
<code>kotlin
val len = danger!!.length // get length or NullPointerException
</code>
尽管，编译器可以帮助我们做一些事情，但是现实的项目中的大量的NPE并不是直接来源于，可以方便追踪的赋值为null，而多是发生在多线程环境中，以及非常复杂的逻辑之中，编译器能否追踪到并警示，还有待考察。另外，就是虽有利器，但是要运用恰当，何时用允许null，何时不允许，还是要靠工程师的设计能力，比如尽可能返回空列表，空Map，或者空字串，而不是直接简单的返回null，这就能减少一定的NPE。</p>

<h2>Exercises</h2>

<p>光是看书或者看教程是比较乏味的，学习编程最重要的是要上手去练习，这样能加深印象，更好的理解书中或者教程中所讲的概念和知识点。官方也准备了一个非常好的练习项目叫Kotlin-koans，非常适配初学习者来练手。
下面说一下如何使用这个练习项目：</p>

<ol>
<li>到<a href="https://github.com/Kotlin/kotlin-koans">官网</a>去下载后，解压</li>
<li>用Android Studio打开此项目，一切提示都回答yes</li>
<li>要想运行测试前需要先编译一下项目，否则会提示找不到基础的测试类，找到Gradle窗口，一般在右侧，点开找到kotlin-koans->Tasks->build->build，运行它</li>
<li>现在就可以用先进的TDD方式来学习Kotlin了，在Project视图下面，可以看到kotlin-koans项目，里面有两个，一个是java，一个是tests，这两个目录里面的子目录都是一一对应的，先运行tests下面的，会失败，然后编辑java/下面的对应的代码，直到测试通过。</li>
</ol>


<h2>Essence of Kotlin</h2>

<p>致此，我们可以看出Kotlin这门语言的设计的核心理念：简洁，这是Kotlin的核心理念，所以我们看到，一些机械的，重复的，可以从上下文中推测 出来的都 可以省略，以增加可读性。我们在使用Kotlin的时候要践行此理念，把语言的特性发挥到最大。
当然，简洁，不是牺牲可读性的方式来缩短代码，而是要使用语言中的标准的简洁的表达方式，比如lambda表达式，省略参数等。</p>

<p>要注意参考<a href="http://kotlinlang.org/docs/reference/coding-conventions.html">Kotlin conventions</a>以及<a href="https://android.github.io/kotlin-guides/">Android Kotlin conventions</a>以写出更加简洁和容易理解的代码。</p>

<h2>Android dev setup</h2>

<p>我们来新建一个项目，用纯Kotlin实现一个Hello, world Android应用，来展示一下如何在Android中使用Kotlin:</p>

<p><strong>注意</strong>: 这里使用的是Android Studio 3.1.2版本，默认就支持Kotlin，如果使用小于3.0的版本需要安装Kotlin插件，可自行Google，孤还是建议先升级AS吧。</p>

<ol>
<li>新建一个项目，其实流程跟新建一个普通Android Studio项目是一样一样的，从Android Studio3.0起，新建项目时就会有一个Checkbox，问你要不要添加Kotlin。这里把它选上。
<img src="https://wx2.sinaimg.cn/mw690/870ad0baly1frgfq2b7odj20p40ixwfe.jpg" alt="Step 1" /></li>
<li>就直接下一步就好
<img src="https://wx2.sinaimg.cn/mw690/870ad0bagy1frfm0n9r38j20p40ixq4g.jpg" alt="Step 2" /></li>
<li>Next，创建一个empty activity
<img src="https://wx2.sinaimg.cn/mw690/870ad0baly1frgfqcxzruj20p40ixmy3.jpg" alt="Step 3" /></li>
<li>Finish<br/>
<img src="https://wx3.sinaimg.cn/mw690/870ad0baly1frgfqcz4tpj20p40ixdgr.jpg" alt="Step 4" /></li>
<li>布局跟其他新建的Android项目无差别
<img src="https://wx1.sinaimg.cn/mw690/870ad0baly1frgfqd39n2j20sp0io78b.jpg" alt="Step 5" /></li>
<li>代码已经是Kotlin的了
<img src="https://wx4.sinaimg.cn/mw690/870ad0baly1frgfqczcpmj20nz0cegmo.jpg" alt="Step 6" /></li>
<li><p>直接显示&#8221;Hello, world&#8221;略显无聊，所以加一下点击事件：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='kotlin'><span class='line'><span class="k">class</span> <span class="nc">HelloActivity</span> <span class="p">:</span> <span class="n">AppCompatActivity</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'> <span class="k">override</span> <span class="k">fun</span> <span class="nf">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">:</span> <span class="n">Bundle</span><span class="p">?)</span> <span class="p">{</span>
</span><span class='line'>     <span class="k">super</span><span class="p">.</span><span class="n">onCreate</span><span class="p">(</span><span class="n">savedInstanceState</span><span class="p">)</span>
</span><span class='line'>     <span class="n">setContentView</span><span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">layout</span><span class="p">.</span><span class="n">activity_hello</span><span class="p">)&lt;/</span><span class="n">p</span><span class="p">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="p">&lt;</span><span class="n">pre</span><span class="p">&gt;&lt;</span><span class="n">code</span><span class="p">&gt;</span> <span class="k">val</span> <span class="py">colorTable</span> <span class="p">=</span> <span class="n">listOf</span><span class="p">(</span><span class="s">&quot;#ff0000&quot;</span><span class="p">,</span> <span class="s">&quot;#00ff00&quot;</span><span class="p">,</span> <span class="s">&quot;#0000ff&quot;</span><span class="p">,</span> <span class="s">&quot;#ffff00&quot;</span><span class="p">,</span> <span class="s">&quot;#00ffff&quot;</span><span class="p">,</span> <span class="s">&quot;#ff00ff&quot;</span><span class="p">)</span>
</span><span class='line'> <span class="k">val</span> <span class="py">label</span> <span class="p">=</span> <span class="n">findViewById</span><span class="p">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">TextView</span><span class="p">&amp;</span><span class="n">gt</span><span class="p">;(</span><span class="n">R</span><span class="p">.</span><span class="n">id</span><span class="p">.</span><span class="n">label</span><span class="p">)</span>
</span><span class='line'> <span class="n">label</span><span class="p">.</span><span class="n">setOnClickListener</span> <span class="p">{</span> <span class="n">view</span> <span class="p">-&amp;</span><span class="n">gt</span><span class="p">;</span>
</span><span class='line'>     <span class="k">val</span> <span class="py">randomIndex</span> <span class="p">=</span> <span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="n">random</span><span class="p">()</span> <span class="p">*</span> <span class="n">colorTable</span><span class="p">.</span><span class="n">size</span><span class="p">).</span><span class="n">toInt</span><span class="p">()</span>
</span><span class='line'>     <span class="n">view</span><span class="p">.</span><span class="n">setBackgroundColor</span><span class="p">(</span><span class="n">Color</span><span class="p">.</span><span class="n">parseColor</span><span class="p">(</span><span class="n">colorTable</span><span class="p">[</span><span class="n">randomIndex</span><span class="p">]))</span>
</span><span class='line'> <span class="p">}</span>
</span><span class='line'><span class="p">&lt;/</span><span class="n">code</span><span class="p">&gt;&lt;/</span><span class="n">pre</span><span class="p">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="p">&lt;</span><span class="n">p</span><span class="p">&gt;</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
其实，整体来看，布局和项目的结构还是按照Android的方式来，唯一的不同是代码可以用Kotlin来写了。</p></li>
</ol>


<h2>Good to go</h2>

<p>至此，Kotlin就算入门了，可以使用Kotlin来构建应用程序了，或者在你的项目中应用Kotlin了。</p>

<h2>参考资料和有用的资料分享</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/reference/">官方文档</a></li>
<li><a href="https://www.kotlinresources.com/">Awesome Kotlin Resources</a></li>
<li><a href="https://developer.android.com/kotlin/">Kotlin and Android</a></li>
<li><a href="https://developer.android.com/kotlin/resources">Resources to Learn Kotlin</a></li>
<li><a href="https://learnxinyminutes.com/docs/kotlin/">Learn Kotlin in Y minutes</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
