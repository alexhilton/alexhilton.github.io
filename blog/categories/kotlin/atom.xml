<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Kotlin | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/kotlin/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2023-02-07T20:57:26+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Understanding Coroutines]]></title>
    <link href="http://toughcoder.net/blog/2023/01/27/understanding-coroutines/"/>
    <updated>2023-01-27T10:59:13+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/27/understanding-coroutines</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Coroutine">协程Coroutine</a>是一种轻量级的实现异步的方式，使用上大大简化了以往异步和多线和带来的种种麻烦（如状态同步和锁），今天就来学习一下协程，以及在<a href="https://kotlinlang.org/docs/coroutines-guide.html">Kotlin中协程</a>的使用方式。</p>

<p><a href=""><img src="https://cdn.filestackcontent.com/fShtqYm3Tp2Xl9C36xN8" title="auto auto" ></a></p>

<!-- more -->


<h2>理解异步</h2>

<p>在解释什么是协程之前，得先要理解什么是异步。异步也就是说程序是非阻塞非同步的，并不是按照顺序来执行的。这么说依然很绕，我们来一个简单的例子。比如有这样一个语句：</p>

<pre><code class="kotlin">fun main(args: Array&lt;String&gt;) {
     println("world of Coroutine!") // 1
     print("Hello ...") // 2
}
</code></pre>

<p>这个代码的输出很明显是</p>

<pre><code class="bash">world of Coroutine
Hello ...
</code></pre>

<p>函数的执行是从上到下按我们写的顺序执行的，这就是顺序执行的意思，虽然说编译器会做一些指令重排以期对字节码进行一些优化，但有一个前提就是它不会改变程序的正确性，比如后面语句如果需要前面表达的结果时，一定能保证它们的执行顺序。同步的意思是，执行一个子函数，子函数会占用CPU，直到它运行结束再返回到调用它的函数，继续运行并能把结果带回给调用者，这即是同步的意思。比如这里的println，println没有执行完时，后面的语句是不会执行的。</p>

<p>异步的意思是函数语句的执行并不是按照我们写的顺序来运行的。比如说，前面的函数，如何能输出&#8221;Hello &hellip;world of Coroutine&#8221; ？这就需要让代码实现异步，非顺序的执行。有多种方式，协程就可以实现异步：</p>

<pre><code class="kotlin">fun main() = runBlocking { // this: CoroutineScope
    launch { // launch a new coroutine and continue
        delay(1000L) // non-blocking delay for 1 second (default time unit is ms)
        println("world of Coroutine!") // print after delay
    }
    print("Hello ...") // main coroutine continues while a previous one is delayed
}
// Hello ...world of Coroutine!
</code></pre>

<h2>协程不是线程</h2>

<p>需要特别注意的是协程并不是线程，它并不是实现多线程或者并行的方式，相反，协程是实现异步和并发的方式，它是让多个函数更好的协作以实现异步和并发，<a href="http://c.biancheng.net/view/9486.html">并发与并行的区别可以看这里</a>。</p>

<p><img src="https://ts1.cn.mm.bing.net/th/id/R-C.cd0dda66a295b461b1ec1f269be2314d?rik=4v1wb0LmAIbRew&amp;riu=http%3a%2f%2fsungjk.github.io%2fimages%2f2021%2f08%2f01%2fcoroutine.png&amp;ehk=D9i5q9A3eVYLMoxOPPbCAU0Rxek54FJ%2figmJCJYuY%2fc%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" /></p>

<p>从它的名字可以看出，它是子例程之间的协作，它是函数的执行，可以挂起，可以继续，但它不会产生阻塞。可以理解为它把线程进行了拆解，分为线程环境的具体函数的执行，协程则是函数的执行。</p>

<h2>实战</h2>

<p>这时强烈推荐<a href="https://kotlinlang.org/docs/coroutines-and-channels.html">官方的一个实战性的教程</a>，它是一个有具体应用场景且足够的复杂的小项目，大部分代码已实现了，预留了一些任务来练手，并有教程进行讲解，当然也有参考答案，非常适合学习和参考。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://zhuanlan.zhihu.com/p/25979906">简单解释 Coroutine</a></li>
<li><a href="https://www.baeldung.com/kotlin/threads-coroutines">Threads vs Coroutines in Kotlin</a></li>
<li><a href="https://developer.android.google.cn/kotlin/coroutines">Kotlin coroutines on Android</a></li>
<li><a href="https://amitshekhar.me/blog/kotlin-coroutines">Mastering Kotlin Coroutines</a></li>
<li><a href="https://blog.csdn.net/xinzhilinger/article/details/116240688">Unity 协程(Coroutine)原理与用法详解</a></li>
<li><a href="https://docs.python.org/3/library/asyncio-task.html">Coroutines and Tasks</a></li>
<li><a href="https://www.educba.com/coroutines-vs-threads/">Coroutines vs Threads</a></li>
<li><a href="https://coolshell.cn/articles/10975.html">一个“蝇量级” C 语言协程库</a></li>
<li><a href="https://coolshell.cn/articles/12012.html">STATE THREADS 回调终结者</a></li>
<li><a href="https://en.wikipedia.org/wiki/Asynchronous_I/O">Asynchronous I/O</a></li>
<li><a href="https://realpython.com/async-io-python/">Async IO in Python: A Complete Walkthrough</a></li>
<li><a href="https://www.topcoder.com/thrive/articles/Introduction-to-asyncio-asynchronous-io-in-python">INTRODUCTION TO ASYNCIO (ASYNCHRONOUS IO) IN PYTHON</a></li>
<li><a href="https://andela.com/insights/an-introduction-to-asynchronous-programming-in-python-with-async-io/">An introduction to asynchronous programming in Python with Async IO</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin Collections]]></title>
    <link href="http://toughcoder.net/blog/2023/01/26/kotlin-arrays-and-collections/"/>
    <updated>2023-01-26T16:39:49+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/26/kotlin-arrays-and-collections</id>
    <content type="html"><![CDATA[<p>现代的软件一般比较复杂，程序语言中的基本数据类型往往不能满足需要，除了<a href="http://toughcoder.net/blog/2023/01/19/kotlin-types-and-operators/">基本的数据类型</a>以外，还有对象的容器也非常的重要，比如线性容器（数组，列表和Set）和二维容器（哈希表）等。今天就来学习一下Kotlin中的容器。</p>

<p><a href=""><img src="https://koenig-media.raywenderlich.com/uploads/2019/06/KotlinCollections-twitter.png" title="auto auto" ></a></p>

<!-- more -->


<h2><a href="https://kotlinlang.org/docs/collections-overview.html">Kotlin Collections</a></h2>

<p>集合就是用于处理一组对象的容器，因为用的人较多，所以就成了标准库。常见的集合有三种主要类型，列表类，Set类和Map类。</p>

<h3>线性容器</h3>

<p>这里并不单纯指类List，主要的意思是线性的容器，它的特点是以<strong>相对顺序存储同一类型的对象</strong>，有一个整数索引(index)来表示其相对的位置，查找性能差，其他还好。代表为数组。</p>

<h3><a href="https://kotlinlang.org/docs/arrays.html">数组</a></h3>

<p>最简单也是使用最为广泛的线性容器，不用过多的介绍了，可以参考<a href="http://toughcoder.net/blog/2023/01/19/kotlin-types-and-operators/">之前的文章</a>。</p>

<p>最大的弊端就是长度是固定的，长度在创建数组时就确定了，后面就改不了了。所以，必须在<strong>事先要能够确定数组的长度</strong>。</p>

<h4>创建复杂数组</h4>

<p>比如数组的元素是一个Collection，而非常见的基本数据类型，这时要如何写？</p>

<pre><code class="kotlin">       val carray = arrayOf&lt;MutableList&lt;Int&gt;&gt;(
            mutableListOf(),
            mutableListOf()
        )

        val narray = Array&lt;MutableList&lt;Int&gt;&gt;(10) { mutableListOf() }
</code></pre>

<p>关键就在于要声明元素的类型，其他的与基本数据类型的数组是一样的。另外，如果数组数量比较少，方便直接写，那就用字面构造函数，其实很方便。或者用数组元素的构造方法也可以。</p>

<h4>多维数组</h4>

<p>以最为常见的二维数组来说，要如何创建?</p>

<pre><code class="kotlin">       val smatrix = arrayOf(
            arrayOf(1, 2, 3),
            arrayOf(4, 5, 6),
            arrayOf(7, 8, 9)
        )

        val matrix = Array(5) { IntArray(6) }
</code></pre>

<h3><a href="https://kotlinlang.org/docs/ranges.html">Ranges</a></h3>

<p>用于表示区间的表达式，最为直观理解就是数组的索引，用<strong>操作符..</strong>来表示区间，比如0~9，就是<strong>0..9</strong>，通常用于for-loop中：</p>

<pre><code class="kotlin">if (i in 1..4) { // equivalent of i &gt;= 1 &amp;&amp; i &lt;= 4
    print(i)
}

for (i in 1..4) print(i) // for (int i = 1; i &lt;= 4; i++) print(i)
</code></pre>

<p>还可以指定步长和边界，以及方向：</p>

<pre><code class="kotlin">for (i in 0 until 10) { // for (int i = 0; i &lt; 10; i++)
    print(ln)
}

for (i in 0 until 10 step 2) { // for (int i = 0; i &lt; 10; i += 2)
    print(ln)
}

for (i in 9 downTo 0) { // for (int i = 9; i &gt;= 0; i--)
    print(i)
}
</code></pre>

<p>还可以用于字符，比如：</p>

<pre><code class="kotlin">for (c in 'a'..'z') { // for (char c = 'a'; c &lt;= 'z'; c++)
    print(c)
}
</code></pre>

<p>Range是一个表达式，所以在其之上做其他操作，但需要注意这时<strong>需要加上括号</strong>，比如：</p>

<pre><code class="kotlin">    for (i in (0..9).filter {it % 2 == 0 }) {
        println(i) // only evens
    }
    for (c in ('a'..'z').map { it.toUpperCase() }) {
        println(c) // upper case
    }
</code></pre>

<p><strong>需要注意</strong>，虽然Ranges方便操作数组的索引，但如果想要带着索引遍历数组的话，还是要用专用的遍历方式，而不是用Range，比如：</p>

<pre><code class="kotlin">for ((index, value) in array.withIndex()) {
    println("the element: [$index] = $value")
}
</code></pre>

<h4>注意与repeat的区别</h4>

<p>Ranges是一个数据结构代表着一个区间，这个区间可能是一个整数范围，也可能是一个字符范围，其实也可以是其他自定义数据类型，只要能表达 出区间的概念。只不过整数区间是为常用的一种方式，以及整数区间可以方便当作数组和列表的索引。</p>

<p>但有时如果仅仅想重复一件事情n次，那就没有必要用Ranges，虽然它也可以，这时最为方便的是函数repeat，它与区间的唯一区别是repeat是没有返回值的，它仅是把一件事情重复n次，但没有返回值也就是说没有办法再转化为其他数组或者列表。</p>

<pre><code class="kotlin">repeat(10) { println("repeat # $it") }
//repeat # 0
//repeat # 1
//repeat # 2
//repeat # 3
//repeat # 4
//repeat # 5
//repeat # 6
//repeat # 7
//repeat # 8
//repeat # 9
</code></pre>

<p>而比如Ranges是可以转化为其他数组和列表的：</p>

<pre><code class="kotlin">(0 until 5).map { it * it }.toIntArray()
// [0, 1, 4, 9, 16]
</code></pre>

<h3><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/">列表List</a></h3>

<p>列表可以简单理解为无限长的数组，它最大的特点是<strong>长度不固定，不必事先定好长度，它会随着添加元素而自动增长</strong>。所以，当你事先不知道容器的长度时，就需要用List。它是一个泛型，其余操作与数组一样。</p>

<pre><code class="kotlin">val names = listOf("James", "Donald", "Kevin", "George")
names.map { it.toUpper() }
    .forEach { println(it) }
</code></pre>

<h3><a href="https://kotlinlang.org/docs/sequences.html">序列Sequence</a></h3>

<p>序列与列表比较难区分，直观上它们是一样的。简单来说它并不是容器，它并不持有对象，它生产对象，类似于物理上的信号发射器和<a href="http://toughcoder.net/blog/2023/01/05/introduction-to-rxjava/">RxJava中的Observable</a>，是有时序上的概念的，当你需要时它就生产出来一个元素。</p>

<h3>队列queue</h3>

<p>队列可以用双端队列deque（读作dek），具体实现对象是<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-array-deque/">ArrayDeque&lt;T&gt;</a>。</p>

<p>双端队列是强大的数据结构，即可以用作队列，也可以用作栈。</p>

<h3>Set容器</h3>

<p>Set是一个<strong>不含有重复元素</strong>的容器，特点是<strong>不会保存相对顺序</strong>，可以<strong>快速实现检索</strong>。</p>

<pre><code class="kotlin">    val names = setOf("James", "Harden", "Donald", "Joe")
    for (nm in names) {
        println(nm)
    }
    names.filter { it.length &gt; 4 }
        .forEach { println(it) }
</code></pre>

<h3>Map容器</h3>

<p>由映射键->值对组成的二维容器，键不可重复，值可以重复，不会保存相对顺序，也可以用于快速检索。</p>

<pre><code class="kotlin">    val nameMap = mapOf("James" to 15, "Harden" to 30, "Donald" to 80, "Joe" to 86)
    for (nm in nameMap.keys) {
        println(nm)
    }
    for (age in nameMap.values) {
        println(age)
    }
    for (e in nameMap.entries) {
        println("${e.key} is ${e.value}")
    }
    nameMap.filter { it.key.length &gt; 5 }
        .forEach { println("${it.key} = ${it.value}") }
</code></pre>

<h2>注意Immutability</h2>

<p>有一个地方需要特别注意，那就是容器的<strong>不可变性Immutability</strong>，用常规的方法创建的集合对象是<strong>不可变的Immutable</strong>，就是无法向其中添加元素也无法删除元素。对象的不可变Immutable在函数式编程中是很重要的特性可以有效的减少异步和并发带来的<strong>状态一致性问题</strong>。</p>

<pre><code class="kotlin">val names = listOf("James", "Donald", "Kevin", "George")
names.add("Paul") // compile error, names is immutable
names.map { it.toUpper() }
    .forEach { println(it) }
</code></pre>

<p>这样写会有<strong>编译错误</strong>，因为用listOf创建的列表对象是<strong>不可变的Immutable</strong>。如果想要改变就必须用支持更改的对象，如MutableList, MutableSet和MutableMap，如：</p>

<pre><code class="kotlin">val names = mutableListOf("James", "Donald", "Kevin", "George")
names.add("Paul") // okay
names.map { it.toUpper() }
    .forEach { println(it) }
</code></pre>

<p>如果有可能还是要尽可能的<strong>用不可变对象(Immutable objects)</strong>。</p>

<h2>集合的操作</h2>

<p>集合的操作就是函数式的三板斧过滤filter，转化map和折叠化约fold/reduce，前面讲的所有的容器都是支持的，结合<a href="http://toughcoder.net/blog/2023/01/24/understanding-kotlin-functions/">lambdas</a>可以写出非常规范的函数式代码。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/kotlin-collections/">Kotlin Collections</a></li>
<li><a href="https://blog.csdn.net/u013700502/article/details/123115051">Kotlin常用Collection集合操作整理</a></li>
<li><a href="https://www.baeldung.com/kotlin/kotlin-collection-guide">Kotlin Collections Guide</a></li>
<li><a href="https://www.geeksforgeeks.org/kotlin-ranges/">Kotlin Ranges</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Kotlin Functions]]></title>
    <link href="http://toughcoder.net/blog/2023/01/24/understanding-kotlin-functions/"/>
    <updated>2023-01-24T16:43:37+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/24/understanding-kotlin-functions</id>
    <content type="html"><![CDATA[<p>函数对于编程语言来说是极其重要的一个组成部分，函数可以视为是程序的执行，是真正活的代码，为啥呢？因为运行的时候你必须要执行一个函数，一般从主函数入口，开始一个套一个的函数调用。函数更能体现程序的运行。特别是近些年函数式编程的编程范式开始广泛流行，让函数的地位再次在各种语言中都得到了极大的进升。对于任何一门编程语言，如果没有学好函数，那就相当于没有学，今天就要深入的学习一下Kotlin中的函数。</p>

<p><a href=""><img src="https://cdn.codetober.com/wp-content/uploads/2018/11/02121424/kotlin_functions_title-660x320.png" title="auto auto" ></a></p>

<!-- more -->


<p>首先来区分一下，什么是函数什么是方法，函数是编程语言中的一级对象，地位等同于其他Type，函数可以声明在任何地方：顶层（即在任何类任何方法的外面），类里面，另外函数里面等。一般支持函数式编程语言更喜欢用函数。声明在类里面的函数叫作成员函数，但更准确的说是方法。比如像纯OO的编程语言Java就只会说方法(Method)，而像函数式编程语言(Kotlin/Scala/Groovy)喜欢说函数。</p>

<h2><a href="Functions%EF%BB%BF">函数</a>的基本使用</h2>

<p>函数(Functions)在Kotlin中的一级对象，这就意味着它能像其他类型那样，可以声明变量，可以当作参数传递，可以在函数内部定义，先从基本的使用开始。</p>

<h3>函数的声明与定义</h3>

<p>用<strong>关键字fun</strong>来声明函数，然后是<strong>函数名字，参数列表，返回值</strong>和<strong>函数体</strong>：<em>修饰符</em> fun <em>函数名</em>(<em>参数列表</em>) <em>:返回类型</em> {<em>函数体</em>}</p>

<ul>
<li>修饰符，对于类的成员函数才有，一般是权限open/private</li>
<li>fun，用于声明这是一个函数的关键字</li>
<li>函数名，就像变量名一样，是函数的名字</li>
<li>(参数列表)，要用括号约束起来，就是变量的声明，多个要用逗号分隔</li>
<li>:返回类型，注意冒号，也即是函数返回值的类型，如果很明显类型可以推断出来时，就可以省略</li>
<li>{函数体}，也即函数的真实定义部分，想要执行的一些语句</li>
</ul>


<p>如：</p>

<pre><code class="kotlin">fun double(x: Int): Int {
     return x + x
}
</code></pre>

<p>这就是一个标准的函数。</p>

<h3>函数的使用</h3>

<p>函数的使用有三种，一是调用，另一种是声明变量，再有就是当作参数（这其实是在定义一个变量，然后当作参数）。</p>

<h4>函数的调用</h4>

<p>函数都是表达式，都有返回值，但可以不用管返回值，调用函数的时候用括号来标识，比如前面的函数double，可以这样来调用：</p>

<pre><code class="kotlin">val dx = double(5)
</code></pre>

<p>这是函数最为常用的使用方法，因为程序最终要执行，所以所有的函数最终都是要被调用的。</p>

<h4>声明函数变量</h4>

<p>前面说了，函数是一级类型，它可以像其他类型那样去定义变量，比如前面的double也可以这来写：</p>

<pre><code class="kotlin">    val myDouble = {x: Int -&gt; x + x}
    println(myDouble(6))
</code></pre>

<p>这里的myDouble就是一个函数变量，它的函数类型与前面的double是一样的，它是一个变量，要想执行它的函数体要加括号。</p>

<h4>把函数当作参数</h4>

<p>这里会涉及<a href="https://kotlinlang.org/docs/lambdas.html#higher-order-functions">高阶函数</a>，高阶函数就是涉及函数中的函数，主要体现在函数的参数或者返回值也是一个函数。比如数组和集合的过滤(filter)和遍历(forEach)里面的参数就是一个函数：</p>

<pre><code class="kotlin">    val asc = arrayOf(1, 2, 3, 4, 5)
    asc.filter({(it and 0x01) == 0}).map(myDouble).forEach({ println(it) })
    // output-&gt; 4, 8
</code></pre>

<p>因为把函数当作参数传递时都涉及<a href="https://kotlinlang.org/docs/lambdas.html#function-types">函数的类型定义</a>，而一般情况下用<a href="https://kotlinlang.org/docs/lambdas.html">lambda</a>是最方便的，先有个印象，后面会详细讲解。</p>

<h3>参数</h3>

<p>函数的参数还有两种比较有用的变体，称之为命名参数和默认值，这两个通常会一起使用。</p>

<h4><a href="https://kotlinlang.org/docs/functions.html#named-arguments">命名参数</a></h4>

<p>当一个函数的参数比较多时，那么在调用时想要传递参数就比较蛋疼，特别是还有相同类型的参数的时候，一片混乱，比如：</p>

<pre><code class="kotlin">fun log(tag: String, event: String, source: String, amount: Int, price: Float, persist: Boolean): Unit {
    println("$tag, $event, $amount $price")
    if (persist) {
        // write to file
    }
}

log("func", "Function arguments", "Hard way", 5, 2.3f, false)
</code></pre>

<p>这样调用，参数太多了，并且相同类型的有三个，这三个极容易传错，而且因为类型检查 不会报错，可能会引发极难调试的bug。</p>

<p>这时就可以使用命名参数来缓解了，命名参数，就是在调用函数，传递参数的时候，指定参数的名字，即就是在声明函数时参数的名字，用以指定具体参数，然后这时就可不用管参数的相对顺序了，比如上面的函数也可以这样调用：</p>

<pre><code class="kotlin">   log(event = "Named arguments",
        tag = "func",
        source = "Elegant",
        amount = 5,
        persist = false,
        price = 100f
    )
</code></pre>

<p>不会出错，而且可读性大大加强。但需要注意的是，如果要使用命名参数，就要保持一致性，给所有的参数都要命名。所以，当参数比较多的时候还是比较蛋疼，这时就需要用到参数默认值了。</p>

<h4><a href="https://kotlinlang.org/docs/functions.html#default-arguments">参数默认值</a></h4>

<p>默认值也即是在声明参数的时候指定一个默认值，在调用的时候可以省略这个参数了，比如：</p>

<pre><code class="kotlin">fun foo(x: Int, y: Int = 0): Int {
    return x + y
}

fun afoo(x: Int = 0, y: Int): Int {
    return x - y
}

foo(3)
afoo(y = 5)
</code></pre>

<p>注意，如果默认参数是最后一个参数，那么可以直接省略它，如示例中的foo(3)，但如果默认参数不是最后一个，想省略的话，必须要用命名参数，如afoo(y = 5)。当然了，两个参数都传也可以的：</p>

<pre><code class="kotlin">foo(3, 5)
afoo(3, 5)
</code></pre>

<p>所以要把默认值和命名参数结合起来才能发挥最大的价值：</p>

<pre><code class="kotlin">fun log(tag: String, event: String, source: String = "Elegant", amount: Int = 0, price: Float, persist: Boolean = false): Unit {
    println("$tag, $event, $amount $price")
    if (persist) {
        // write to file
    }
}

    log(event = "Named arguments",
        tag = "func",
        price = 100f
    )
</code></pre>

<p>把握一下<strong>使用原则</strong>：如果参数不多（4个以内），那么就把默认参数往后放，调用的时候也可以不用命名参数，直接省略默认参数就好；如果参数比较多，也要把默认参数往后放，在调用的时候尽可能的使用使用参数。</p>

<h3><a href="https://kotlinlang.org/docs/functions.html#explicit-return-types">返回值</a></h3>

<p>函数的返回值是在参数列表之后，函数体之前用冒号加类型来声明。</p>

<pre><code class="kotlin">fun printHello(name: String?): Unit {
    if (name != null)
        println("Hello $name")
    else
        println("Hi there!")
    // `return Unit` or `return` is optional
}
</code></pre>

<p>如果函数没有返回值就用Unit来声明，相当于Java中的void，但更多的时候是可以省略的：</p>

<pre><code class="kotlin">fun printHello(name: String?) { ... }
</code></pre>

<p>当<a href="https://kotlinlang.org/docs/functions.html#single-expression-functions">函数体只有一个表达式</a>的时候，这个时候可以省略掉函数体，而把表达式直接写在函数声明的后面，用<strong>赋值符=</strong>来连接，如前面的double也可以这样写：</p>

<pre><code class="kotlin">fun double(x: Int): Int = x + x
</code></pre>

<p>这个时候，因为函数体只有一个表达式，所以返回类型很容易推断出来，意味着这时返回类型的声明也可以省略掉：</p>

<pre><code class="kotlin">fun double(x: Int) = x + x
</code></pre>

<p>这会让代码非常的简洁，又不失可读性。</p>

<h3>解构返回</h3>

<p>Kotlin的函数只能有一个返回值，代表某一个类型的一个变量，如果想有多个返回值，就需要用复杂的类型，比如同一类型的多个有规律的变量可能就要用集合，如数组列表等。但如果类型不同，但逻辑上有关系的2个到3个值，如果想要一起返回，就需要用到组合类型如Pair和Triple，Pair可以把两个不同类型的变量组合成一个对象，Triple可以把三个不同类型的变量组合成一个对象，这样就可以在函数中返回了。</p>

<pre><code class="kotlin">fun nameAge() = Pair("Alex", 50)

fun fullName() = Triple("Donald", "Jonh", "Trump")
</code></pre>

<p>对于函数的调用者也很麻烦，要先声明Pair或者Triple对象，然后再拆解，比如这样：</p>

<pre><code class="kotlin">val pna = nameAge()
println("Name ${pna.first}, age ${pna.second}")
</code></pre>

<p>这显然比较笨拙，不够简洁。在Kotlin中有更好的做法，可以在函数调用的时候，对返回值进行拆解，称之为解构，如下写法与上面是一样的：</p>

<pre><code class="kotlin">val (name, age) = nameAge()
println("Name $name, age $age")
</code></pre>

<p>而且，如果只对组合中的某几个感兴趣，可以把不想要的变量用<strong>下划线_</strong>(underscore)来表示，比如说：</p>

<pre><code class="kotlin">val (firstName, _, lastName) = fullName()
println("This is $firstName $lastName")
</code></pre>

<h3>尾部lambda参数传递</h3>

<p>前面说了函数可以作为参数传递给其他函数，但我们在使用的时候，一般会直接把一个lambda传递进去，比如说：</p>

<pre><code class="kotlin">fun execute(a: Int, f: (Int)-&gt;Int): Int {
    if (a &lt; 0) {
        return -1
    }
    return f(a)
}
</code></pre>

<p>调用的时候，可以这样：</p>

<pre><code class="kotlin">execute(3, { it * it })
</code></pre>

<p>但更建议的方式是把lambda放到函数调用之外：</p>

<pre><code class="kotlin">execute(5) { it + it }
</code></pre>

<p>再比如像集合的函数式写法，通常也只传递一个lambda，这时一般都写在函数调用之外，并且当目标函数没有其他参数时也即除了要传入的lambda外无其他参数时，代表函数调用的括号也可以省略：</p>

<pre><code class="kotlin">val nums = arrayOf(1, 2, 3, 4, 5)
nums.filter { it and 0x01 == 0 } // 等同于filter({ it and 0x01 == 0 })
        .map { it * it } // 等同于map({ it * it })
        .forEach { println(it) } // 等同于forEach({ println(it) })
</code></pre>

<p>这样写非常的简洁，但会牺牲一些可读性，因为花样多了，就会比较难识别出来函数的声明与函数的调用，甚至有时候会分不清函数与普通的变量。所以，识别<strong>函数调用</strong>有两种方式，一是看<strong>有没有括号</strong>，另外就看<strong>有没有尾部lambda</strong>。</p>

<h2>匿名函数</h2>

<p>匿名函数就是不指定函数的名字，通常用于把函数当作 参数传递给高阶函数时使用。</p>

<h2>内部函数</h2>

<h2><a href="https://kotlinlang.org/docs/lambdas.html">高阶函数</a></h2>

<p>高阶函数就是函数的函数，也就是说函数的参数或者返回值是一个函数的函数，也即把函数像其他类型那样使用。函数在Kotlin中一级类型(first class type)，因此从语义层面支持了函数式编程范式，当然也就支持了高阶函数以及lambdas。比如像集合的操作filter/map/fold都是高阶函数，因为它们接受一个函数作为参数。</p>

<h3><a href="https://kotlinlang.org/docs/lambdas.html#function-types">函数类型</a></h3>

<p>高级函数是把函数作为参数或者返回值，但显然并不是所有的函数都能当作高阶函数的参数或者返回值，换句话说，函数本身其实也是有类型之别的，两个函数不见得就是一样的。函数是用来针对其参数，然后在函数体内进行一些运算最终返回一个值，所以区分不同的函数最关键的是输入参数和返回值，与其名字其实没有关系，因此输入参数一致，返回值一致就可以视为同一种函数。</p>

<p>函数的类型用<strong>参数和返回值</strong>来表示，如<strong>(A, B) -> R</strong>形式，A和B是参数，R是返回值，需要注意的是括号不能省略，常见的具体形式有：</p>

<ul>
<li>() -> Unit 无参数无返回值</li>
<li>() -> R 无参数有返回值</li>
<li>(A) -> Unit 有一个参数，无返回值</li>
<li>(A) -> R 一个参数，一个返回值</li>
<li>(A, B) -> Unit 两个参数，无返回值</li>
<li>(A, B) -> R 两个参数，一个返回值</li>
</ul>


<p>函数的类型与方法签名类似(method signature)，代表着某一类的函数。在高阶函数的函数参数或者返回函数就需要用函数类型来声明。</p>

<h3><a href="https://kotlinlang.org/docs/lambdas.html#instantiating-a-function-type">实例化一个函数类型</a></h3>

<p>有很多种途径可以实例化一个函数类型，比较常见的有：</p>

<ul>
<li>通过lambda表达式，如{ a, b -> a + b }，这就是一个函数类型(A, B) -> R的实例</li>
<li>匿名函数，如fun(a: Int, b: Int): Int { return if (a > 0 &amp;&amp; b > 0) a + b else -1 }</li>
<li>引用现存的某一个函数，函数签名（参数相同，返回值相同）就视为同一种函数类型，那么已定义好的函数中有能匹配的就可以直接引用过来，<strong>顶级函数和构造函数用::</strong>来引用，<strong>类成员函数用类名::</strong>来引用，如::isOdd, String::toInt, ::Tripple</li>
</ul>


<h2>lambda表达式</h2>

<p>就是匿名隐式函数体，匿名是不用指定函数的名字，连参数的类型和返回值的类型也都省略，有时甚至连参数都可以省略，只有一个函数体，是最为简洁的一种函数定义方式，通常用于传递给高阶函数的参数，lambda力求简洁，所以但凡能推断出来的都可以省略。最简洁的lambda只有函数体，如val asc = IntArray(5) { it * it } // 创建一个长度为5的整数数组并初始化为[0,1,4,9,16]。
<img src="https://oracle-patches.com/images/2021/02/12/Kotlin_Lambda_expressions_large.jpg" alt="" /></p>

<p>lambda的形式是<strong>{ A, B -> expressions }</strong>，外面的花括号不可省略，这是lambda的标识，然后是参数列表，->用于分隔参数和函数体，除了函数体，其余的都可以省略掉，只要能推断出来。</p>

<h3>Trailing lambdas(尾部lambda)</h3>

<p>这个前面讲过了，再复习一下，当一个函数的最后一个参数是一个函数时，就可以在函数的调用外部写lambda，比如：</p>

<pre><code class="kotlin">val product = items.fold(1) { acc, e -&gt; acc * e }

run { println("...") }
</code></pre>

<h3>隐式参数</h3>

<p>如果lambda表达式只有一个参数，那么这个参数也可以省略，只写函数体就可以，并且可以用<strong>隐式参数it</strong>，比如：</p>

<pre><code class="kotlin">ints.filter { it &gt; 0 } // this literal is of type '(it: Int) -&gt; Boolean'

val asc = IntArray(5) { it * it } 
</code></pre>

<h3>lambda的返回值</h3>

<p>lambda力求简洁，所以函数体的最后一个表达式的值即是此lambda的返回值，一般不用显式的return：</p>

<pre><code class="kotlin">ints.filter { it &gt; 0 } // boolean result of 'it &gt; 0' is returned

val asc = IntArray(5) { it * it } // it * it is the return

ints.filter {
    val shouldFilter = it &gt; 0
    shouldFilter
}
</code></pre>

<p>如果要用显式的return语句，要注意scope，在<a href="http://toughcoder.net/blog/2023/01/21/kotlin-controls-and-expressions/">这篇文章有深入讨论</a>，用隐式label来限定scope：</p>

<pre><code class="kotlin">ints.filter {
    val shouldFilter = it &gt; 0
    return@filter shouldFilter
}
</code></pre>

<h3>丢弃参数</h3>

<p>有时候，参数有多个，但可能并不会全都使用，仅使用了其中一个，这时不使用的参数就可以用<strong>下划线_(underscore)</strong>来代替，以表示这个参数不会被使用：</p>

<pre><code class="kotlin">map.forEach { (_, value) -&gt; println("$value!") }
</code></pre>

<p>Kotlin的lambda可以写出非常简洁的函数式链式语句，一气呵成可读性又非常的好，比如：</p>

<pre><code class="kotlin">val headers = fetchHeaders()
headers.filter { it.length == 5 }
    .sortedBy { it }
    .map { it.uppercase() }
    .forEach { println(it) }
</code></pre>

<h2>内联函数</h2>

<h2>操作符重载</h2>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/kotlin-functions/">Kotlin functions</a></li>
<li><a href="https://www.geeksforgeeks.org/kotlin-default-and-named-argument/?ref=lbp">Kotlin | Default and Named argument</a></li>
<li><a href="https://www.cnblogs.com/Jetictors/p/8647888.html">Kotlin——高级篇（一）：Lambda表达式详解</a></li>
<li><a href="https://www.baeldung.com/kotlin/lambda-expressions">Lambda Expressions in Kotlin</a></li>
<li><a href="https://www.yiibai.com/kotlin/lambdas.html">Kotlin lambda表达式</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin Controls and Expressions]]></title>
    <link href="http://toughcoder.net/blog/2023/01/21/kotlin-controls-and-expressions/"/>
    <updated>2023-01-21T17:06:32+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/21/kotlin-controls-and-expressions</id>
    <content type="html"><![CDATA[<p>有结果返回的是表达式，没有返回的称之为语句，语句最大的问题是它没有返回值，那么想要保存结果就必然会产生副作用，比如改变变量。很多时候这是不够方便的，并且在多线程条件下，这甚至是不安全的。Kotlin中，为了加强线程安全性和方便并发和异步，因此绝大多数语句都是表达式。</p>

<p><a href=""><img src="https://www.jrebel.com/sites/default/files/image/2021-01/what%20is%20kotlin%20banner%20image.png" title="auto auto" ></a></p>

<!-- more -->


<h2>分支表达式</h2>

<p>Kotlin中没有三元条件符（a > b ? a : b)，但它的<strong>条件分支都是表达式</strong>，可以直接放在赋值符的右边，或者用在return语句中。</p>

<h3><a href="https://kotlinlang.org/docs/control-flow.html#if-expression">if表达式</a></h3>

<p>它是一个两个分支的表达式，是有返回值的：</p>

<pre><code class="kotlin">val maxV = if (a &gt; b) a else b
</code></pre>

<p>当然了，把它当作常规的语句来使用也是没有问题的：</p>

<pre><code class="kotlin">var max: Int
if (a &gt; b) {
    max = a
} else {
    max = b
}
</code></pre>

<h3><a href="https://kotlinlang.org/docs/control-flow.html#when-expression">when表达式</a></h3>

<p>当超过2个分支时，if就不能用了，这时可以用when表达式，它支持多个分支，类似于其他语言中的switch：</p>

<pre><code class="kotlin">when (x) {
     1 -&gt; println("it is 1")
     2 -&gt; println("it is 2")
     else -&gt; {
          println("it is neight 1 nor 2")
     }
}
</code></pre>

<p>需要注意的是，每一行是一个条件，并不是单单指参数与其相等，比如：</p>

<pre><code class="kotlin">when (x) {
     in 1..5 -&gt; println("Less than 5 bigger than 1")
     x.isEven() -&gt; println("it is even")
     else -&gt; println("It is neither even or less than 5")
}
</code></pre>

<p>当然，最重要的是when是一个表达式，可以<strong>直接用在赋值符的右边，或者当参数传，或者用在return中</strong>：</p>

<pre><code class="kotlin">fun Request.getBody() =
    when (val response = executeRequest()) {
        is Success -&gt; response.body
        is HttpError -&gt; throw HttpException(response.status)
    }
</code></pre>

<p>这里的when就是函数的返回值，可以看到<strong>when是一个表达式，它会返回一个值，这个值直接作为函数的返回值</strong>。</p>

<p>从这几个示例可以看出<strong>when表达式相当强大</strong>比其他语言的switch要强大许多，并且可以直接当作返回值，当需要超过2个条件分支时就可以使用when表达式。</p>

<h2>循环语句</h2>

<p>循环是语句，与其他语言也差不多。</p>

<h3>while loop</h3>

<pre><code class="kotlin">while (x &lt; 10) {
    println(x)
    x++
}
</code></pre>

<h3>屁股向后式do-while loop</h3>

<pre><code class="kotlin">do {
  x = poll()
} while (x &lt; 10)
</code></pre>

<h3><a href="https://kotlinlang.org/docs/control-flow.html#for-loops">强大的for loop</a></h3>

<p>这个是最强大，也是最常用的循环语句遍历数组，集合和固定步长时的首选。</p>

<pre><code class="kotlin">for (item in collection) print(item)
</code></pre>

<p>这里的collection可以是数组和集合（列表和Set）。严格来说只要collection类型实现了iterator()和next()，就可以在for loop中使用。</p>

<p>for加上range，可以非常强大：</p>

<pre><code class="kotlin">for (i in 1..10) // = for (int i = 1; i &lt;= 10; i++)
for (i in 0 until 10) // = for (int i = 0; i &lt; 10; i++)
for (i in 9 downTo 0) // = for (int i = 9; i &gt;= 0; i--)
for (i in 0 until 10 step 2) // = for (int i = 0; i &lt; 10; i += 2)
</code></pre>

<p>如果是数组或者列表，但又必须要用索引，也可以直接来：</p>

<pre><code class="kotlin">for (i in array.indices) {
     println(array[i]) // 'i' is the index
}
</code></pre>

<p>其实有更好的方式：</p>

<pre><code class="kotlin">for ((index, value) in array.withIndex()) {
    println("the element at $index is $value")
}
</code></pre>

<p>其实吧，Kotlin是多范式编程语言，天生支持函数式编程，多数情况下不建议直接上for loop，而是用函数式方式的forEach，数组和集合都支持forEach的：</p>

<pre><code class="kotlin">array.forEach { println(it) }
</code></pre>

<h2><a href="https://kotlinlang.org/docs/returns.html#return-to-labels">终止语句</a></h2>

<p>当想提前退出函数的执行，或者循环时，就需要用到终止语句，有三种<strong>return, break和continue</strong>。</p>

<h3>return终止函数执行</h3>

<p>这个都比较熟悉，常规的用法都是一样的，可以提前退出函数：</p>

<pre><code class="kotlin">fun plot(x: Int) {
     if (x &lt; 1) {
         return -1
     }
     ...
     return y
}
</code></pre>

<p>但当有嵌套的lambda时，如不特别指定，return会退出外层的函数，而不是像想当然的退出lambda，比如：</p>

<pre><code class="kotlin">fun foo() {
    listOf(1, 2, 3, 4, 5).forEach {
        if (it == 3) return // non-local return directly to the caller of foo()
        print(it)
    }
    println("this point is unreachable")
}
</code></pre>

<p>这个不是终止lambda的执行，而是直接退出函数foo的执行。如果想解决呢，即也退出遍历的lambda有三种方案：</p>

<ul>
<li>使用标签</li>
</ul>


<pre><code class="kotlin">fun foo() {
    listOf(1, 2, 3, 4, 5).forEach lit@{
        if (it == 3) return@lit // local return to the caller of the lambda - the forEach loop
        print(it)
    }
    print(" done with explicit label")
}
</code></pre>

<ul>
<li>使用隐式标签，也即遍历的方法当作标签</li>
</ul>


<pre><code class="kotlin">fun foo() {
    listOf(1, 2, 3, 4, 5).forEach {
        if (it == 3) return@forEach // local return to the caller of the lambda - the forEach loop
        print(it)
    }
    print(" done with implicit label")
}
</code></pre>

<ul>
<li>使用匿名函数而不是lambda，匿名函数与常规函数体效力一样，所以return只在函数体内生效
<code>kotlin
fun foo() {
  listOf(1, 2, 3, 4, 5).forEach(fun(value: Int) {
      if (value == 3) return  // local return to the caller of the anonymous function - the forEach loop
      print(value)
  })
  print(" done with anonymous function")
}
</code></li>
</ul>


<p>这三种方式，如果非要使用，建议使用方式二，用自带的隐式label，因为比较方便，可读性也不差。</p>

<p>但，<strong>非常不建议如此使用return语句</strong>，这本是应该避免的问题，lambda多半是用在函数式遍历和处理，在lambda里面提加return本就是非常奇怪的事情。因为如果某些条件不满足，<strong>想不执行此lambda，应该用filter啊</strong>，而不是笨拙的非要在lambda中去终止：</p>

<pre><code class="kotlin">fun foo() {
    listOf(1, 2, 3, 4, 5)
        .filter(i -&gt; i != 3)
        .forEach { println(it) }
    print("You can do whatever you like here.")
}
</code></pre>

<h3>循环的终止</h3>

<p>break终止当前循环，continue则是跳过当前循环的当前步骤，直接跳到下一次迭代。这两个的常规使用与其他语言是一样的。</p>

<p>但对于break，一般来说有一个痛点，就是当有循环嵌套时，break只能终止一层，如果想终止所有循环时，只能再手动的加条件去判断，然后再一层一层的break，比如:</p>

<pre><code class="kotlin">for (i in 0 until 10) {
   var found = false
   for (j in i until 10) {
       if (array[i] + array[j] == target) {
           found = true
           break // only break inner for loop
       }
   }
   if (found) {
       break // this break outer for loop
   }
}
</code></pre>

<p>这多少有点笨拙和丑陋，Kotlin有更优雅的解决方式，就是引入了<strong>标签label</strong>，可以给循环加上标签，在break时可以指定标签，同样是上面的情况，可以这样做：</p>

<pre><code class="kotlin">loop@ for (i in 0 until 10) {
   for (j in i until 10) {
       if (array[i] + array[j] == target) {
          break @loop // break all loops easily
       }
   }
}
</code></pre>

<p>其实吧，这玩意儿跟当年的goto是一样的，虽然可行，但<strong>不建议多使用</strong>，<strong>标签多了以后会让程序的执行更加的混乱</strong>，试想假如在层层循环中break错了某个标签，调试的难度是相当大的。更多的时候需要仔细想想有没有更好的遍历方式，而不是靠标签来救命。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin Types and Operators]]></title>
    <link href="http://toughcoder.net/blog/2023/01/19/kotlin-types-and-operators/"/>
    <updated>2023-01-19T15:16:43+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/19/kotlin-types-and-operators</id>
    <content type="html"><![CDATA[<p><a href="https://kotlinlang.org/">Kotlin</a>是新一代的基于JVM的静态多范式编程语言，功能强大，语法简洁，前面已经做过<a href="https://en.wikipedia.org/wiki/Kotlin_(programming_language)">Kotlin</a>的基本的介绍，今天就来深入的学习一下它的数据类型和运算操作符。</p>

<p><a href=""><img src="https://cdn.educba.com/academy/wp-content/uploads/2019/08/Kotlin-Operators-.2.png" title="auto auto" ></a></p>

<!-- more -->


<h2>数据类型</h2>

<p>与大部分语言不同的是，在Kotlin中一切皆为对象(Everything is an object)，它没有像Java/C++那样，是没有基础数据类型(primitive types)的，都是对象，因此也不会有像Java那样的box和auto box的麻烦。box和autobox对于单独使用基础数据类型时没啥问题，比如一个方法add(Integer)，会进行自动装箱和拆箱。但如果在集合中使用就不一样了，比如array of int与array of Integer是完全不同的数据类型，以及list of int与list of Integer也是完全不同的数据类型，在这些场景里就会相当麻烦，要进行转换，详细可以<a href="http://toughcoder.net/blog/2022/06/14/java-collection-opertions-made-easy/">参考这篇文章</a>。</p>

<h3>变量类型的声明</h3>

<p>类型是放在变量之后，这样可以先强调变量的名字，后关注其类型，如：</p>

<pre><code class="kotlin">var count: Int
var message: String
fun double(x: Int): Int {
      return x + x
}
</code></pre>

<h3>类型推断</h3>

<p>虽然Kotlin是<strong>静态强类型语言</strong>，也就是说在编译的时候，编译器必须知道你的数据是什么类型的，这与Java和C++等是一样的，但并不意味着你必须为每个变量声明它的类型。变量的声明，是告诉编译器有一个什么类型的变量，以及叫什么，就比如在函数中的参数列表，就是变量的声明；而变量的定义，则是在声明的同时，要给变量赋值。</p>

<p>那么，当定义变量的时候，编译器是能够直接推断出来它的类型的，这个时候就可以省去类型的声明，<strong>Kotlin语言力求简洁</strong>，凡是能<strong>推断出变量的类型时都可以省去类型的声明</strong>，如定义变量的时候，如在lambda中，或者在函数的返回值中。</p>

<pre><code class="kotlin">val PI = 3.14 // Double
val PI: Double = 3.14 // 与上面的效果一样
</code></pre>

<h3>数字类型(Numbers)</h3>

<p>数字类型与大部分语言一样，特别的，它与Java语言是一样的，都是有符号的，即数字最高数位代表符号。</p>

<h4>整数</h4>

<p>与Java语言一样，有四大整数具体类型，8位的Byte，16位的Short，32位的Int以及64位的Long。它们的范围如下：</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> Type </th>
<th style="text-align:center;"> Size(bits) </th>
<th style="text-align:left;"> Min value </th>
<th style="text-align:left;"> Max value </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> Byte </td>
<td style="text-align:center;"> 8 </td>
<td style="text-align:left;"> -128 </td>
<td style="text-align:left;"> 127 </td>
</tr>
<tr>
<td style="text-align:center;"> Short </td>
<td style="text-align:center;"> 16 </td>
<td style="text-align:left;"> -32768 (-2<sup>15</sup>) </td>
<td style="text-align:left;"> 32767 (2<sup>15</sup> - 1) </td>
</tr>
<tr>
<td style="text-align:center;"> Int </td>
<td style="text-align:center;"> 32 </td>
<td style="text-align:left;"> -2,147,483,648 (-2<sup>31</sup>) </td>
<td style="text-align:left;"> 2,147,483,647 (2<sup>31</sup> - 1) </td>
</tr>
<tr>
<td style="text-align:center;"> Long </td>
<td style="text-align:center;"> 64 </td>
<td style="text-align:left;"> -9,223,372,036,854,775,808 (-2<sup>63</sup>) </td>
<td style="text-align:left;"> 9,223,372,036,854,775,807 (2<sup>63</sup> - 1) </td>
</tr>
</tbody>
</table>


<p>当然了，每个类型都有其<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/-m-a-x_-v-a-l-u-e.html">最大值</a>和<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/-m-i-n_-v-a-l-u-e.html">最小值</a>的常量可以直接引用，不用自己手动写。另外需要注意的是非10进制的字面常量都是二的补码形式，并不是直观的二进制，详细的可以参考<a href="http://toughcoder.net/blog/2022/03/08/java-integer-basics/">另外一篇文章</a>。</p>

<h4>浮点数</h4>

<p>有Float和Double，它们的定义如下：</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> Type </th>
<th style="text-align:center;"> Size (bits) </th>
<th style="text-align:center;"> Significant bits </th>
<th style="text-align:center;"> Exponent bits </th>
<th style="text-align:center;"> Decimal digits </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> Float </td>
<td style="text-align:center;"> 32 </td>
<td style="text-align:center;"> 24 </td>
<td style="text-align:center;"> 8 </td>
<td style="text-align:center;"> 6-7 </td>
</tr>
<tr>
<td style="text-align:center;"> Double </td>
<td style="text-align:center;"> 64 </td>
<td style="text-align:center;"> 53 </td>
<td style="text-align:center;"> 11 </td>
<td style="text-align:center;"> 15-16 </td>
</tr>
</tbody>
</table>


<p><br/></p>

<h4>字面常量(Literals)</h4>

<p>字面常量是指直接写在代码中的数字，默认的是Int和Double，如果需要指定类型，可以用标记或者给变量指定类型，如：</p>

<pre><code class="kotlin">val one = 1 // Int
val threeBillion = 3000000000 // Long, exceeding Int, so it is Long
val aLong = 1L // mark it as Long
val oneByte: Byte = 1 // Byte
val e = 2.7182818284 // Doubleval eFloat = 2.7182818284f // Float, actual value is 2.7182817
</code></pre>

<p>常见的语法糖：</p>

<ul>
<li>浮点数可以用乘方形式如123.5e10</li>
<li>可以下划线(underscore)来加强可读性，如1_000_000</li>
<li>16进制用0x打头，如0xFF_AB</li>
<li>二进制用0b打头，如0b1101_1111</li>
</ul>


<h3>布尔类型(Booleans)</h3>

<h3>字符类型(Characters)</h3>

<p>用两个单引号来表示，如val ch = &lsquo; &rsquo;</p>

<p>需要注意因为字符是对象，所以不能直接与整数进行比较，需要转化为整数，这点不像Java，在Java中字符是可以直接与整数比较的。</p>

<pre><code class="kotlin">        val map = CharArray(26)
        var index = 0
        for (ch in key) {
            if (!ch.isLetter()) {
                continue
            }
            if (map[ch - 'a'].toInt() == 0) {
                map[ch - 'a'] = 'a' + index
                index++
            }
        }

        return message.map { if (it.isLetter()) map[it - 'a'] else it }
                    .joinToString("")
</code></pre>

<h3>字符串类型(Strings)</h3>

<p>可以视为字符的数组，是一个<strong>不可变对象(immutable object)</strong>，用两个双引号来表示，如</p>

<pre><code class="kotlin">val message = "Hello, world"
</code></pre>

<p>字符串拼接用<strong>加号+</strong>：</p>

<pre><code class="kotlin">val name = "John"
val message = "Hello" + name
</code></pre>

<p>当然了，直接用加号拼接效率不好，一般情况下可以直接用字符串模板更好一些。</p>

<h4>字符串模板</h4>

<p>这是一个强大且方便的内置功能，相当于简化版本的String.format，可以在字符串用<strong>美元符&#36;</strong>来引用一个变量的值，如果是有方法调用或者运算或者成员引用等情况可以加花括号：</p>

<pre><code class="kotlin">val name = "John"
val message = "Hello, $name"
println("Length is ${name.length}")
</code></pre>

<h4>字符遍历</h4>

<p>与Java不同的是，字符串在Kotlin里面更像是字符数组，或者说一个列表，因此可以直接遍历：</p>

<pre><code class="kotlin">val mesage = "The quick fox jumps over the lazy dog"
for (ch in message) {
     println(ch)
}
</code></pre>

<p><strong>in</strong>是一个强大的操作符，可以用于集合的遍历。另外，字符串可以像列表一样进行函数式的操作，如判断是否包含某个字符：</p>

<pre><code class="kotlin">if (message.any {it == ch}) {
   println("$ch is in $message")
}
</code></pre>

<h3><a href="https://kotlinlang.org/docs/arrays.html">数组类型</a>(Arrays)</h3>

<p>数组Array<T>是一个具体类型为T的数组，这是通用的数组，另外还有一种就是基本数组类型数组，我们分别来看一下</p>

<h4>通用对象数组 Array&lt;T&gt;</h4>

<p>这是适用于所有对象的数组，有两种构造方式，一是通过arrayOf()，直接传入数组的具体值，另外就是用构造方法Array(size)</p>

<pre><code class="kotlin">val heights = arrayOf(240, 360, 480, 640)
val classes = arrayOf("John", "Harden", "Kevin", "Stephen")
val guards: Array&lt;String&gt; = Array(5)
guards[0] = "Stephen"
guards[1] = "Kevin"
</code></pre>

<p>还有一种用lambda方式来构造数组，可以非常方便的实现数组的定义：</p>

<pre><code class="kotlin">val asc = Array(5) { i -&gt; (i * i).toString() }
// asc = ["0", "1", "4", "9", "16"]
</code></pre>

<p>需要注意的是这里的类型T都是对象。但其实，对于基础类型的数组，如果都box成为对象效率并不高，虽然Kotlin中并没有真的基础数据类型，但涉及到数组这种批量的数据时，使用基础类型能提升很大的效率，因此还有专门用于基础类型的数组类型。</p>

<h4>基础类型数组 IntArray和FloatArray</h4>

<p>其实有很多，基础的类型都有IntArray, ByteArray, ShortArray, FloatArray, DoubleArray。而且需要注意的是Array&lt;Int&gt;与IntArray是两个数组类型，它们并不一样，这个区别与Java中的Integer[]和int[]是类似的。而且IntArray与Array&lt;T&gt;也没什么关系，也不是什么继承关系。但是它们表现出来的使用方法是一样的。</p>

<pre><code class="kotlin">val heights = intArrayOf(240, 360, 480, 640)
val squares = IntArray(5) { i -&gt; i * i } // [0, 1, 4, 9, 16]
val arr = IntArray(5) { 42 } // [42, 42, 42, 42, 42]
val bundle = arrayOf(intArrayOf(1080, 720), intArrayOf(1920, 1080)) // bundle type is Array&lt;IntArray&gt;
</code></pre>

<h2>运算操作符</h2>

<p>运算操作符与大部分语言是一样的。</p>

<h3>算术运算符</h3>

<p>也即是常规的算术操作符，<strong>+(加) -(减）&#42;(乘) /(除) %(取模)</strong>，这些都是二元操作符，也就是需要两个操作数才能使用。</p>

<p>还有单元操作符，如<strong>自增++自减&ndash;</strong>，当然也分前置和后置，区别与Java/C++中一样。</p>

<p>操作符与<strong>赋值符=</strong>可以配合一起使用，如a += b等同于a = a + b，a /= c等同于 a = a / c</p>

<h3>逻辑运算符</h3>

<p>双元操作符: <strong>&amp;&amp; 逻辑与，|| 逻辑或</strong>，它们的操作数必须 是布尔型，且返回值也是布尔。</p>

<p>与其他语言一样，这两个操作符是short-circiut的或者说是lazy的，也即a &amp;&amp; b，如果a是false，那就不去管b了，因为不影响结果；a || b也一样，如果a是true就不去管b了。</p>

<p>还有单元操作符<strong>! 逻辑非</strong>。一个有意思的地方在于，逻辑非可以与一些操作符合起来使用，而不是直接写在表达式之外，比如，下面两种写法等效：</p>

<pre><code class="kotlin">if (!(a in asc)) {...}
if (a !in asc) {...}
if (b !is Array) {...}
if (!(b is Array)) {...}
</code></pre>

<h3>位运算符</h3>

<p>位运算符比较特殊，与大部分语言不一样。</p>

<h4>移位</h4>

<table>
<thead>
<tr>
<th style="text-align:center;"> 操作符 </th>
<th style="text-align:left;"> 含义 </th>
<th style="text-align:left;"> 示例 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> shr </td>
<td style="text-align:left;"> 向右移位 </td>
<td style="text-align:left;"> a shr 1 </td>
<td style="text-align:left;"> 把a向右移1位 </td>
</tr>
<tr>
<td style="text-align:center;"> shl </td>
<td style="text-align:left;"> 向左移位 </td>
<td style="text-align:left;"> a shl 1 </td>
<td style="text-align:left;"> a向左移1位 </td>
</tr>
<tr>
<td style="text-align:center;"> ushr </td>
<td style="text-align:left;"> 无符号向右移位 </td>
<td style="text-align:left;"> a ushr 1 </td>
<td style="text-align:left;"> （包含符号位）向右移1位 </td>
</tr>
</tbody>
</table>


<h4>按位逻辑运算</h4>

<table>
<thead>
<tr>
<th style="text-align:center;"> 操作符 </th>
<th style="text-align:left;"> 含义 </th>
<th style="text-align:left;"> 示例 </th>
<th style="text-align:left;"> 说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> and </td>
<td style="text-align:left;"> 按位与</td>
<td style="text-align:left;"> a and 1 </td>
<td style="text-align:left;"> a与1按位与 </td>
</tr>
<tr>
<td style="text-align:center;"> or </td>
<td style="text-align:left;"> 按位或 </td>
<td style="text-align:left;"> a or 1 </td>
<td style="text-align:left;"> a与1按位或 </td>
</tr>
<tr>
<td style="text-align:center;"> xor </td>
<td style="text-align:left;"> 按位异或 </td>
<td style="text-align:left;"> a xor 1 </td>
<td style="text-align:left;"> a与1按位异或 </td>
</tr>
<tr>
<td style="text-align:center;"> inv </td>
<td style="text-align:left;"> 按位取反 </td>
<td style="text-align:left;"> inv(a) </td>
<td style="text-align:left;"> 把a按位取反 </td>
</tr>
</tbody>
</table>


<p>这些操作符看起来可能比较怪，然后更怪异的是位运算操作符<strong>不能</strong>与<strong>赋值符=</strong>一起使用，只能这样写：</p>

<pre><code class="kotlin">a = a or b
c = c xor (1 shl 3)
</code></pre>

<p>事实上位运算不是操作符，它们是一种函数，叫做<a href="https://kotlinlang.org/docs/functions.html#infix-notation">infix函数</a>，简写了把括号省略了，看起来就像操作符一样，但它们并不是操作符。</p>

<h3><a href="https://kotlinlang.org/docs/operator-overloading.html">运算符重载</a></h3>

<p>与C++中的运算符重载类似，Kotlin中支持运算符重载，本质上它们都是对象定义的方法，但支持重载为运算符。</p>

<p>比如说加法，a + b，可以写成方法调用的形式a.plus(b)；b or c等同于b.or&copy;，!a等同于a.not()。</p>

<h3>运算符的优先级</h3>

<p>尽管是有默认的优先级的，但<strong>强烈建议使用括号</strong>以减少歧义和增强可读性，更可以避免一些难以察觉的Bug。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/basic-types.html">Basic types﻿</a></li>
<li><a href="https://www.baeldung.com/kotlin/bitwise-operators">Using Bitwise Operators in Kotlin</a></li>
<li><a href="https://www.programiz.com/kotlin-programming/bitwise">Kotlin Bitwise and Bitshift Operations</a></li>
<li><a href="https://www.programiz.com/kotlin-programming/operators">Kotlin Operators</a></li>
<li><a href="https://www.tutorialspoint.com/kotlin/kotlin_operators.htm">Kotlin - Operators</a></li>
<li><a href="https://www.geeksforgeeks.org/kotlin-operators/">Kotlin Operators</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
