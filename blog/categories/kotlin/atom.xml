<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Kotlin | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/kotlin/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2024-03-24T22:57:45+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Deep Dive Into Kotlin Generics Runtime]]></title>
    <link href="http://toughcoder.net/blog/2024/03/16/deep-dive-into-kotlin-generics-runtime/"/>
    <updated>2024-03-16T19:16:00+08:00</updated>
    <id>http://toughcoder.net/blog/2024/03/16/deep-dive-into-kotlin-generics-runtime</id>
    <content type="html"><![CDATA[<p>通过前面的学习，对Kotlin的泛型已经有了比较全面的了解了，泛型的目的是让通用的代码更加的类型安全。现在我们离写出类型安全的泛型代码还差最后一块拼图，那就是泛型的类型擦除，今天就来深入地学习一下运行时的泛型，彻底的弄懂类型擦除的前因后果，并学会如何在运行时做类型检查和类型转换，以期完成拼图掌握泛型，写出类型安全的通用代码。</p>

<p><a href=""><img src="https://global-uploads.webflow.com/618fa90c201104b94458e1fb/61978c1b9e0bf52082dabe92_Kotlin-Generics.png" title="auto auto" ></a></p>

<!-- more -->


<p>关于泛型话题的一系列文章：</p>

<ul>
<li><a href="http://toughcoder.net/blog/2024/03/04/kotlin-generics-made-easy/">这回就好好聊聊Kotlin的泛型</a></li>
<li><a href="http://toughcoder.net/blog/2024/03/10/java-generics-made-easy/">深入浅出Java泛型</a></li>
<li><a href="http://toughcoder.net/blog/2024/03/13/kotlin-generics-revisited/">Kotlin Generics Revisited</a></li>
<li><a href="">Dive deep into Kotlin type erasure</a></li>
</ul>


<h2>泛型类型擦除（Type erasure）</h2>

<p>泛型的类型安全性（包括类型检查type check，和类型转换type casting）都是由编译器在编译时做的，为了保持在JVM上的兼容性，编译器在保障完类型安全性后会对泛型类型进行<a href="https://en.wikipedia.org/wiki/Type_erasure">擦除（Type erasure）</a>。在运行时泛型类型的实例并不包含其类型信息，也就是说它不知道具体的类型参数，比如Foo&lt;Bar&gt;和Foo&lt;Baz?&gt;都被擦除成了Foo&lt;&#42;&gt;，在虚拟机（JVM）来看，它们的类型是一样的。</p>

<p>因为泛型Foo&lt;T&gt;的类型参数T会<strong>被擦除（erased）</strong>，所以与类型参数相关的类型操作（类型检查is T和类型转换as T）都是不允许的。</p>

<h2>可行的类型检查和转换</h2>

<p>虽然类型参数会被擦除，但并不是说对泛型完全不能进行类型操作。</p>

<h3>星号类型操作</h3>

<p>因为所有泛型会被擦除成为星号无界通配Foo&lt;&#42;&gt;，它相当于Foo&lt;Any?&gt;，是所有Foo泛型的基类，类型参数Any?是根基类，所以可以进行类型检查和类型转换：</p>

<pre><code class="Kotlin">if (something is List&lt;*&gt;) {
    something.forEach { println(it) } // 元素被视为Any?类型
}
</code></pre>

<p>针对星号通配做类型操作，类型参数会被视为Any?。但其实这种类型操作没有任何意义，毕竟Any是根基类，任何类当成Any都是没有问题的。</p>

<h3>完全已知具体的类型参数时</h3>

<p>另外一种情况就是，整个方法的上下文中已经完全知道了具体的类型参数时，不涉及泛型类型时，也是可以进行类型操作的，说的比较绕，我们来看一个&#127792;：</p>

<pre><code class="Kotlin">fun handleStrings(list: MutableList&lt;String) {
    if (list is ArrayList) {
        // list is smart-cast to ArrayList&lt;String&gt;
    }
}
</code></pre>

<p>这个方法并不涉及泛型类型，已经知道了具体的类型参数是String，所以类型操作也是可行的，因为编译器知道具体的类型，能对类型进行检查 保证是类型安全的。并且因为具体类型参数String可以推断出来，所以&lt;String&gt;是可以省略的。</p>

<h2>未检查的转换</h2>

<p>当编译器能推断出具体的类型时，进行类型转换就是安全的，这就是被检查的转型（checked cast），如上面的&#127792;。</p>

<p>如果无法推断出类型时，比如涉及泛型类型T时，因为类型会被擦除，编译器不知道具体的类型，这时as T或者as List&lt;T&gt;都是不安全的，编译器会报错，这就是未检查转型（unchecked cast）。</p>

<p>但如果能确信是类型转换是安全的，可以用注解&#64;Suppress(&ldquo;UNCHECKED_CAST&rdquo;)来忽略。</p>

<h2>用关键reified修饰inline泛型函数</h2>

<p><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.Y0Gq_pPe6TUb1g0oEN_51wHaEb?rs=1&amp;pid=ImgDetMain" alt="" /></p>

<p>要想能够对泛型类型参数T做类型操作，只能是在用关键字reified修饰了的inline泛型函数，在这种函数体内可以对泛型类型参数T做类型操作，&#127792;如：</p>

<pre><code class="Kotlin">inline fun &lt;reified A, reified B&gt; Pair&lt;*, *&gt;.asPairOf(): Pair&lt;A, B&gt;? {
    if (first !is A || second !is B) return null
    return first as A to second as B
}

val somePair: Pair&lt;Any?, Any?&gt; = "items" to listOf(1, 2, 3)


val stringToSomething = somePair.asPairOf&lt;String, Any&gt;()
val stringToInt = somePair.asPairOf&lt;String, Int&gt;()
</code></pre>

<p>需要注意的是关键字reified能够让针对类型参数T的操作得到编译器的检查，保证安全，是允许的。但是对于泛型仍是不允许的，&#127792;如：</p>

<pre><code class="Kotlin">inline fun &lt;reified T&gt; List&lt;*&gt;.asListOfType(): List&lt;T&gt;? =
    if (all { it is T })
        @Suppress("UNCHECKED_CAST")
        this as List&lt;T&gt; else
        null
</code></pre>

<p>这个inline泛型函数用关键字reified修饰了，因此针对类型参数T是允许类型检查类型转换，如第2行是允许的。但泛型仍是不合法，如第4行，这时可以用上一小节提到的注解&#64;Suppress(&ldquo;UNCHECKED_CAST&rdquo;)来忽略未检查类型转换。</p>

<h2>inline和reified的原理</h2>

<p>对于一些泛型工厂方法，就非常适合使用inline和reified，以保证转换为类型参数（因为工厂方法最终肯定要as T）是允许的且是安全的：</p>

<pre><code class="Kotlin">inline fun &lt;reified T&gt; logger(): Logger = LoggerFactory.getLogger(T::class.java)

class User {
    private val log = logger&lt;User&gt;()
    // ...
}
</code></pre>

<p>关键字reified其实也没有什么神秘的，因为这是inline函数，这种函数是会把函数体嵌入到任何调用它的地方（call site），而每个调用泛型函数的地方必然会有明确的具体类型参数，那么编译器就知道了具体的类型能保证类型安全（checked cast）。上面的工厂方法在调用时就会大概变成酱紫：</p>

<pre><code class="Kotlin">class User {
    private val log = LoggerFactory.getLogger(User.class.java)
}
</code></pre>

<p>这时其实在函数体内已经知道了具体的类型参数User，编译器能够进行类型检查，所以是安全的。</p>

<h2>总结</h2>

<p>本文深入的讨论一下运行时泛型的一些特性，泛型类型在运行时会被擦除，无法做泛型相关的类型操作，因为编译器无法保证其类型安全。例外就是在用reified修饰的inline函数中可以对类型参数T做类型操作，但泛型类型（带尖括号的&lt;T&gt;）仍是会被擦除，可以用注解&#64;Suppress(&ldquo;UNCHECKED_CAST&rdquo;)来忽略unchecked cast。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/generics.html#type-erasure">Type erasure</a></li>
<li><a href="https://www.baeldung.com/kotlin/generics#generics-at-runtime">6. Generics at Runtime</a></li>
<li><a href="https://www.baeldung.com/kotlin/type-erased-list-array-conversion">How to Convert a Type-Erased List to an Array in Kotlin</a></li>
<li><a href="https://discuss.kotlinlang.org/t/type-erasure/14519">Discussion about Type Erasure</a></li>
<li><a href="https://stackoverflow.com/questions/42916801/how-does-erasure-work-in-kotlin">How does erasure work in Kotlin?</a></li>
<li><a href="https://workingdev.net/2018/09/reified-generics-in-kotlin.html">Reified Generics in Kotlin</a></li>
<li><a href="https://duongnt.com/type-erasure-reified/">Type erasure and reified in Kotlin</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin Generics Revisited]]></title>
    <link href="http://toughcoder.net/blog/2024/03/13/kotlin-generics-revisited/"/>
    <updated>2024-03-13T22:33:20+08:00</updated>
    <id>http://toughcoder.net/blog/2024/03/13/kotlin-generics-revisited</id>
    <content type="html"><![CDATA[<p>在前面的文章中学习Kotlin泛型的基本知识，并且又用了一篇文章来复习了一下Java语言的泛型，有了这些基础我们就可以继续深入的学习Kotlin的泛型了。看它是如何解决Java泛型的遗留问题，再学习一下它的高级特性，最后再总结泛型的最佳实践。</p>

<p><a href=""><img src="https://koenig-media.raywenderlich.com/uploads/2019/09/Generics-feature.png" width="480" height="480"></a></p>

<!-- more -->


<p>本文是作为前面文章的延续和深化，为了更好的阅读效果，建议先回顾一下<a href="http://toughcoder.net/blog/2024/03/10/java-generics-made-easy/">Java泛型基础</a>，和<a href="http://toughcoder.net/blog/2024/03/04/kotlin-generics-made-easy/">Kotlin泛型基础</a>。</p>

<h2>泛型类型参数界限（Upper bounds）</h2>

<p>我们在前面讲解<a href="http://toughcoder.net/blog/2024/03/10/java-generics-made-easy/">Java泛型基础</a>时提到了在声明泛型的时候是可以指定类型参数的界限的，比如用Caculator&lt;T extends Number&gt;可以指定在使用时可以传入的类型参数要是Number或者Number的子类。</p>

<p>在Kotlin中也是可以指定泛型类型参数的界限的，也是用<strong>继承符号:来表示</strong>，&#127792;如：</p>

<pre><code class="Kotlin">class Calculator&lt;T : Number&gt; { ... }
</code></pre>

<p>与Java一样，也可以指定多个界限，要<strong>使用where关键字</strong>：</p>

<pre><code class="Kotlin">class Calculator&lt;T&gt; where T : Number, T : Runnable, T : Closable { ... }

fun &lt;T&gt; copyWhenGreater(list: List&lt;T&gt;, threshold: T): List&lt;String&gt;
    where T : CharSequence,
          T : Comparable&lt;T&gt; {
    return list.filter { it &gt; threshold }.map { it.toString() }
}
</code></pre>

<p>注意：面向对象的继承体系是基类在上面，子类在下面，所以上界的意思是以某个类A为根的继承树，这颗树都可以当成A来使用；下界的意思是从根A到以某个类C为止的一个路径，这个路径上都是C的基类，C都可以当成它们来用。</p>

<p><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/20221025185149/Hierarchical-Inheritance-in-Java.jpg" alt="" /></p>

<h2>更优雅的泛型变化(Variance)</h2>

<p>与Java一样，Kotlin的泛型也是不可变的Invariant，比如虽然String是Any的子类，但List&lt;String&gt;并不是List&lt;Any&gt;的子类。泛型变化Variance的目的就是让两个泛型产生与类型参数协同的变化，比如类型C是类A的子类，那么使用它的泛型&lt;C&gt;也应该是&lt;A&gt;的子类，能使用&lt;A&gt;的方，传入&lt;C&gt;一定要是允许的，并要能够是安全的。</p>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.HRZ3CHxJfgk_hG9T11siDQHaD4?rs=1&amp;pid=ImgDetMain" alt="" /></p>

<h3>使用点变化（Use-site variance）</h3>

<p>基于面向对象的基本特性，只有向上转型(Upcasting)是安全的。具体就分为两种场景，从一个生产者中读取对象时，只要生产者的输出声明的T是基类（T是一个上限），无论生产者输出的是T还是它的子类，对于使用者来说（当T来用）就是安全的。这时生产者的泛型要能够进行协变，在Java中用上界界限通配符&lt;? extends T&gt;来进行协变，具体使用时传入T的子类的泛型也是合法的；同理，向一个消费者中写数据时，消费者声明为T的某个基类（这时T是一个下限），向其传入T，对于使用者来说就是安全的。这时消费者的泛型要能进行逆变，在Java中使用下界界限通配符&lt;? super T&gt;来进行逆变，具体使用时传T的基类的泛型也是合法的。</p>

<p>Kotlin中提供了非常容易理解和使用的<strong>关键字out来进行协变（covariance）和in进行逆变（contravariance）</strong>，可以实现Java中的界限通配符一样的功效。Java界限通配符的规则是<strong>PECS（Producer Extends Consumer Super）</strong>，out正好可以更形象的描述一个生产者，而in可以更形象的描述一个消费者，所以Kotlin的关键字更容易理解和记忆。</p>

<pre><code class="Kotlin">open class Animal
class Dog : Animal()

class MyList&lt;E&gt; {
    fun addAll(from: MyList&lt;out E&gt;) {}
    fun getAll(to: MyList&lt;in E&gt;) {}
}

fun main() {
    val animals = MyList&lt;Animal&gt;()
    val dogs = MyList&lt;Dog&gt;()

    animals.addAll(dogs)
    dogs.getAll(animals)
}
</code></pre>

<p>这种泛型变化是发生在调用者调用时，因此也叫做『使用点变化』(Use-site variance)。在Kotlin中也被称作<strong>类型映射</strong>，因为相当于是用&lt;out T&gt;把T给映射成了一个T的生产者，只能调用其get方法；用&lt;in T&gt;映射成一个T的消费者，只能调用set方法。并且呢，对于同一个函数中既有生产者和消费者时，in和out只写一个就行了，&#127792;如：</p>

<pre><code class="Kotlin">fun copy(from: Array&lt;out Any&gt;, to: Array&lt;Any&gt;) { ... }
</code></pre>

<h3>声明点变化（Declaration-site variance）</h3>

<p>Java界限通配符的一个大问题是只能用于方法的参数但不能是返回值，也就是只能是『Use-site variance』。但in和out没有这个限制，因此它们可以用于返回值。只要给类和接口的泛型声明为out或者in就能让类型参数在其所有的方法产生variance，这就是『declaration-site variance』。</p>

<p>但是要遵守out进行协变，也就是<strong>说out是用于生产者</strong>的，只能作为方法的返回值，或者保证不能set，&#127792;如：</p>

<pre><code class="Kotlin">interface Source&lt;out T&gt; {
    fun nextT(): T
}

fun demo(strs: Source&lt;String&gt;) {
    val objects: Source&lt;Any&gt; = strs // This is OK, since T is an out-parameter
    // ...
}
</code></pre>

<p>同理，<strong>用in进行逆变，只能用于消费者</strong>，只能作为方法的参数，或者保证不get，&#127792;如：</p>

<pre><code>interface Comparable&lt;in T&gt; {
    operator fun compareTo(other: T): Int
}

fun demo(x: Comparable&lt;Number&gt;) {
    x.compareTo(1.0) // 1.0 has type Double, which is a subtype of Number
    // Thus, you can assign x to a variable of type Comparable&lt;Double&gt;
    val y: Comparable&lt;Double&gt; = x // OK!
}
</code></pre>

<p>小结一下，Kotlin使用关键字in和out让泛型的协变和逆变变得容易理解得多了，因为它们能够非常清楚的表达出消费者和生产者，只需要记住一个泛型的生产者要用out来修饰，而一个泛型的消费者要用in来修饰就不会出错，这比Java中的界限通配符简单太多了。</p>

<h2>星号映射(Star projections)</h2>

<p>除了use-site variance是一种类型映射外，还有星号映射。首先来说<strong>星号是无界泛型</strong>，也就是说不指定具体的类型参数，意思是任意类型的泛型，换句话说Foo&lt;&#42;&gt;是任何其他泛型的基类（Foo&lt;String&gt;, Foo&lt;Number&gt;等）。但根据不同的上下文，Foo&lt;&#42;&gt;会映射为不同的具体意义的泛型类型：</p>

<ul>
<li>对于Foo&lt;out T : TUpper&gt;，这里的T是一个受上界TUpper限制的协变类型参数，那么Foo&lt;&#42;&gt;就等同于Foo&lt;out TUpper&gt;。</li>
<li>对于Foo&lt;in T&gt;，这里T是逆变类型参数，Foo&lt;&#42;&gt;等同于Foo&lt;in Nothing&gt;。这意思是无法向Foo&lt;&#42;&gt;中写。</li>
<li>对于Foot&lt;T : TUpper&gt;，这里T是一个被上界TUpper限定的不可变类型参数，那么Foo&lt;&#42;&gt;，在读时（作为生产者）等同于Foo&lt;out TUpper&gt;，在写时（作为消费者）等同于Foo&lt;in Nothing&gt;。</li>
</ul>


<p>如果泛型是多元的，那么每个类型参数可以进行不同的映射。比如说如果一个类型是这样声明的interface Function&lt;in T, out U&gt;，那么会有这样的映射：</p>

<ul>
<li>Function&lt;&#42;, String&gt; 意思是Function&lt;in Nothing, String&gt;</li>
<li>Function&lt;Int, &#42;&gt; 意思是Function&lt;Int, out Any?&gt;</li>
<li>Function&lt;&#42;, &#42;&gt; 意思是Function&lt;in Nothing, out Any?&gt;</li>
</ul>


<p>换句话来理解，就是当不指定具体的类型参数，用星星就代表着不知道具体的类型参数，那么视具体的上下文不同星号会被解释不同的意思。不过这玩意儿可读性较差，除非必不得已，否则还是能不用就用它。</p>

<p>注意：在Kotlin中，<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/">根基类是Any</a>它是所有其他类的基类（the root of Kotlin class hierarchy）。而<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-nothing.html">Nothing</a>是不能有实例的类，可以用它来表示不存在的对象（a value that never exists）。比如说，如果 一个函数返回值类型声明为Nothing，那它就不会返回（always throws an exception），注意是<strong>不会返回（never returns）</strong>，并不是没有返回值，没有返回值要<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/">声明为类型Unit</a>。</p>

<h2>绝不为空类型（Definitely non-null type）</h2>

<p>为了保持对Java的互通性，Kotlin还支持把泛型类型参数声明为『绝不为空类型』definitely non-null type。可以<strong>用&amp; Any来声明</strong>，如&lt;T &amp; Any&gt;来声明T是『绝不为空类型』。</p>

<p>这是为了保持与Java的相互调用，有些Java的类和接口是用<strong>注解&#64;NonNull修饰的</strong>，如：</p>

<pre><code class="Java">public interface Game&lt;T&gt; {
    public T save(T x) {}
    @NotNull
    public T load(@NotNull T x) {}
}
</code></pre>

<p>这时在Kotlin里面就要用到<strong>『绝不为空类型』&amp; Any来声明泛型</strong>：</p>

<pre><code class="Kotlin">interface ArcadeGame&lt;T1&gt; : Game&lt;T1&gt; {
    override fun save(x: T1): T1
    // T1 is definitely non-nullable
    override fun load(x: T1 &amp; Any): T1 &amp; Any
}
</code></pre>

<p>注意，在纯Kotlin代码中是用不到这个特性的。只有当涉及Java的&#64; NonNull时才需要『绝不为空类型』。</p>

<h2>下划线操作符</h2>

<p>当编译器能推断出泛型的类型参数时是可以省略掉类型参数的，比如val names = listOf(&ldquo;James&rdquo;, &ldquo;Kevin&rdquo;)，这里得到的类型是List&lt;String&gt;，但我们并没有显示的指定类型参数，这是因为编译器从listOf的参数中就能推断出类型参数是String，所以listOf的返回就是List&lt;String&gt;。</p>

<p>但有些时候，泛型类型太复杂了，没有办法推断出所有的类型，比如有多元泛型参数时。但根据指定的某一个参数，可以推断出剩余的参数时，这时就没有办法完全省略类型参数，剩余的参数却又可以推断出来，写了又浪费。这时就可以用下划线操作符来代表那些可以推断出来的参数。这里的下划线用法跟在lambda中，用下划线替代不使用的参数是一样的。</p>

<pre><code class="Kotlin">abstract class SomeClass&lt;T&gt; {
    abstract fun execute() : T
}

class SomeImplementation : SomeClass&lt;String&gt;() {
    override fun execute(): String = "Test"
}

class OtherImplementation : SomeClass&lt;Int&gt;() {
    override fun execute(): Int = 42
}

object Runner {
    inline fun &lt;reified S: SomeClass&lt;T&gt;, T&gt; run() : T {
        return S::class.java.getDeclaredConstructor().newInstance().execute()
    }
}

fun main() {
    // T is inferred as String because SomeImplementation derives from SomeClass&lt;String&gt;
    val s = Runner.run&lt;SomeImplementation, _&gt;()
    assert(s == "Test")

    // T is inferred as Int because OtherImplementation derives from SomeClass&lt;Int&gt;
    val n = Runner.run&lt;OtherImplementation, _&gt;()
    assert(n == 42)
}
</code></pre>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/generics.html">Generics: in, out, where</a></li>
<li><a href="https://www.gyata.ai/kotlin/kotlin-generics/">Kotlin Generics</a></li>
<li><a href="https://blog.logrocket.com/understanding-kotlin-generics/">Understanding Kotlin generics</a></li>
<li><a href="https://sebhastian.com/kotlin-generics/#google_vignette">Kotlin generics explained with code examples</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/143380842">深入解析Kotlin 泛型</a></li>
<li><a href="https://juejin.cn/post/6959859571242303495">Kotlin（六）深入理解Kotlin泛型</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[这回就好好聊聊Kotlin的泛型]]></title>
    <link href="http://toughcoder.net/blog/2024/03/04/kotlin-generics-made-easy/"/>
    <updated>2024-03-04T22:51:58+08:00</updated>
    <id>http://toughcoder.net/blog/2024/03/04/kotlin-generics-made-easy</id>
    <content type="html"><![CDATA[<p>泛型(Generics)是静态强类型编程语言中非常强大的特性，可以极大的加强代码的复用，并增强类型安全，减少运行时的类型转换错误。在这篇文章就来详细的学习一下Kotlin中对泛型的支持情况，并学会写出类型安全的可复用代码。</p>

<p><a href=""><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.bl_F0aycuia6QRYMt4AOfQHaFc?rs=1&amp;pid=ImgDetMain" title="auto auto" ></a></p>

<!-- more -->


<h2>泛型基础</h2>

<p>泛型的本质就是能够创建参数化的对象和函数，以实现复用。比如说，我们最熟悉的集合List，它是<strong>与具体类型无关</strong>的数据结构，或者叫做对象容器。列表List的重点在于可扩展长度，但里面具体的对象类型并不是重点，只要是一个对象就可以了。假如没有泛型，可能就要写很多重复的代码，比如字符串列表StringList，数字列表NumberList，等等。用泛型，只<strong>用一个参数化</strong>的List就可以了，用尖括号<strong>&lt;&gt;</strong>来表示参数化。</p>

<pre><code class="Kotlin">val names: List&lt;String&gt; = listOf("James", "Kevin", "Harden")
val rebounds: List&lt;Int&gt; = listOf(2, 14, 7)
</code></pre>

<p>泛型有两种形式，一种是对类进行参数化如List<String>，一种是对函数进行参数化，如max<Int>()。</p>

<h3>参数化的类</h3>

<p>声明方式就是在声明类的时候在类的名字后面用尖括号<strong>&lt;&gt;</strong>来带上一个类型参数，然后在内部就可以当成一个类型来使用：</p>

<pre><code class="Kotlin">class Box&lt;T&gt;(t: T) {
    var value = t
}
</code></pre>

<p>这就创建了一个参数化的容器，它可以持有任何指定类型的对象：</p>

<pre><code class="Kotlin">val box: Box&lt;Int&gt; = Box&lt;Int&gt;(1)
val case: Box&lt;String&gt; = Box&lt;String&gt;("Coat")
</code></pre>

<h3>参数化的函数</h3>

<p>除了参数化的类以外，还可以创建参数化的函数，在函数名字的前面用尖括号<strong>&lt;&gt;</strong>来声明泛型，然后在参数列表以及函数体内就可以当作类型来使用：</p>

<pre><code class="Kotlin">fun &lt;T&gt; singleTonList(item: T): List&lt;T&gt; {
    ...
}
</code></pre>

<p>调用的时候指定一下具体的类型就可以了：</p>

<pre><code class="Kotlin">val l = singletonList&lt;Int&gt;(3)
</code></pre>

<p><strong>注意：</strong>Kotlin语言有强大的类型推断能力，但凡编译器能够推断出类型时，类型的声明都可以省略掉。对于泛型更是如此，比如说，这样写都是合法的：</p>

<pre><code class="Kotlin">val names = listOf("James", "Kevin", "Harden")
val rebounds = listOf(2, 14, 7)
val l = singletonList(3)
</code></pre>

<p>通常情况下，<strong>声明</strong>，<strong>定义</strong>和<strong>赋值</strong>三个地方，只要有一个地方能够让编译器知道具体的类型就够了，其他地方都可以把类型的声明省略掉。</p>

<h2>泛型的本质与优点</h2>

<p>假如不使用泛型，又想写出比较通用的类和函数，唯一可行的方法就是使用通用基类Any当作参数，在Kotlin中Any是所有对象的基类，比如，说想实现一个列表：</p>

<pre><code class="Kotlin">class AnyList {
    fun add(item: Any)
    fun get(idx: Int): Any
}
</code></pre>

<p>这样写可以，但它有很大的问题，就是不能保证类型安全：</p>

<pre><code class="Kotlin">val list = AnyList()
list.add("James")
list.add(13)
val e = (Int) list.get(1)
</code></pre>

<p>一方面我们需要自己进行强行类型转换，但也无法保证你取出来的对象类型与期望的是一致的，更无法保证调用者往里面添加什么对象，因为任何Any的子类都可以让代码通过编译，但在运行时极容易发生类型转换异常ClassCastException。</p>

<p>但用泛型就能很好的解决这个问题，可以得出泛型的优点：</p>

<ol>
<li>不需要做类型转换，编译器会根据指定的具体类型自动做类型转换</li>
<li>类型安全，编译器会帮助做检查，传给泛型的对象必须具有一致的类型，且是指定的类型</li>
<li>保障了运行时的类型安全，因为编译器在编译时做好了检查，所以不会发生运行时的类型错误</li>
</ol>


<p>因此，凡是有需要针对 类型复用的地方，都应该用泛型来实现类型参数化。</p>

<h2>关键字out和关键字in</h2>

<p>大部分情况下，只要给类型和函数加上参数化的类型就够了，但有时候有些复杂情况需要处理。</p>

<h3>协变与逆变</h3>

<p><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98">协变与逆变Covariance and Contravariance</a>是用来描述具有父子继承关系的简单类型，在通过参数化的方法构造出来的更复杂的类型之间是否能保持父子关系的术语。</p>

<p>比如Dog是Animal的子类，根据继承和多态，Dog可以用在任何声明为Animal的语句和表达式中。<strong>变型Variance</strong>指的就是根据已知的父子关系Dog和Animal，如何来确定由它们构成的更复杂类型如List&lt;Dog&gt;和List&lt;Animal&gt;之间的关系？</p>

<p>常规泛型是<strong>不可变的Invariant</strong>，也就是说复杂类型之间的关系与它们具体的参数化类型之间是没有关系的，如List&lt;Dog&gt;并不是List&lt;Animal&gt;，它们之间没有任何关系，不能把List&lt;Dog&gt;当成是List&lt;Animal&gt;，虽然Dog可以被当作Animal。</p>

<p>不可变Invariant有时候会带来不方便，比如说，集合通常都有addAll方法来批量的把对象加入到集合中：</p>

<pre><code class="Kotlin">class List&lt;T&gt; {
    fun addAll(from: List&lt;T&gt;) {
        for (x in from) {
            add(x)
        }
    }
}
val objs: List&lt;Any&gt; = emptyList()
val names: List&lt;String&gt; = listOf("James", "Kevin", "Harden")
objs.addAll(names) // No go, compile error
</code></pre>

<p>这是参数化列表集合，先创建一个具体类型为Any的列表，然后尝试把一个String列表添加到Any列表中，其实这么做是完全安全的，因为String对象是完全可以当作其基类Any来使用的，但泛型的不可变性阻止了我们这么做。</p>

<p>这时就需要<strong>协变</strong>与<strong>逆变</strong>了，也就是通过一定的方法让复杂类型的行为与其参数化类型之间进行协同。</p>

<p><img src="https://phpstan.org/covariance-contravariance.4483af19.png" alt="" /></p>

<h3>关键字out进行协变</h3>

<p>使用out关键能够让泛型进行协变。比如上面例子理想的情况应该是，只要能当作T的类型，都应该能用在addAll中，换句话说把T的子类的列表也应该能够支持，即objs.addAll(names)应该能正常编译并正常运行。使用关键out即可达到这样的效果：</p>

<pre><code class="Kotlin">class List&lt;out T&gt; {
    fun addAll(from: List&lt;T&gt;) {
        for (x in from) {
            add(x)
        }
    }
}
val objs: List&lt;Any&gt; = emptyList()
val names: List&lt;String&gt; = listOf("James", "Kevin", "Harden")
objs.addAll(names) // Okay
</code></pre>

<p>这里的泛型参数from: List<out T>其实是一个生产者，它生产类型为T的对象，所以这里用out来修饰，产出的对象是T或者是T的子类都是会是合法的。或者说当我们想把一个子类的泛型赋给父类的泛型时，就需要对泛型声明为out，以进行协变。</p>

<p><strong>注意：</strong>关键字out与Java泛型中的extend通配符的作用是一样的，指定参数的上限，生产者产生的对象都会向上转型(upcast)为基类，所以需要指定一个上限。</p>

<p>与之相对的，还有in逆变。</p>

<h3>关键字in进行逆变</h3>

<p>有时候情况是相反的，也就是说我们持有的是父类的泛型，但 我们想把它赋给其子类的泛型，这时就可以用in进行逆变。而且必须注意in只能用在消费者中，也就是说是在真实消费对象，为什么呢？其实这里真实发生的是向下转型(downcast)&ndash;把父类的对象赋给子类的引用上面，而向下转型不一定保证是安全的。所以，必须是在真实消费这个对象的地方，只有是期望的真实对象才能被消费。</p>

<pre><code class="Kotlin">class ParameterizedConsumer&lt;in T&gt; {
    fun toString(value: T): String {
        return value.toString()
    }
}

val parameterizedConsumer = ParameterizedConsumer&lt;Number&gt;()

val ref: ParameterizedConsumer&lt;Double&gt; = parameterizedConsumer
</code></pre>

<p><strong>注意：</strong>关键字in与Java泛型中的super是一样的，指定一个下限，因为在消费对象时会转成T，用T来限制成为下限，那么向下转型(downcast)就是安全的。</p>

<h2>任意类型的泛型</h2>

<p>有些比较简单粗暴的场景，就是单纯的想让任意类型的泛型都可以使用，这时关键字out和关键字in可能都不太合适，因为它们只能用于生产者和消费者场景，用以指定类型上限和类型下限。这时可以用<strong>星号&#42;</strong>来当用泛型参数，以表示任意具体类型的泛型都可以使用。</p>

<pre><code class="Kotlin">fun printArray(array: Array&lt;*&gt;) { 
    array.forEach { println(it) }
}

val array = arrayOf(1,2,3) 
printArray(array)
</code></pre>

<h2>关键字reified</h2>

<h3>运行时泛型擦除</h3>

<p>需要注意的是泛型类型在运行时会被擦除(erased)，也就是说在运行时任何对象都是不带有其泛型类型的，具体点的，就是List&lt;String&gt;和List&lt;Int&gt;在运行时，它们的对象实例是一样的，无法知道它们的具体的泛型参数类型。前面讲的各种规则都是发生在编译时间，编译器帮助检查传入的泛型对象是否符合规划，并进行类型转换。到了运行时，泛型类型会被擦除。(为啥会被擦除呢？因为JVM要保持向后兼容，早期的Java没有泛型，只有原始的类型对象(raw type)，所以后来1.5版本后加入的泛型只有擦除掉变成raw type才能保持兼容。)</p>

<h3>关键字reified</h3>

<p>泛型类型擦除会带来一个问题，就是对于泛型类型对象，无法做类型检查(is T)，无法做类型转换(as T)，因为运行时的对象根本不知道它的泛型类型是什么，这会带来极大的不方便，特别是工厂方法就无法使用泛型了，因为无法做类型检查 和转换。</p>

<p>这时inline再加上关键字reified就能完美的解决问题，它们两个配合起来运行时就能保留泛型类型了：</p>

<pre><code class="Kotlin">inline fun &lt;reified T&gt; Iterable&lt;*&gt;.filterIsInstance() = filter { it is T }

&gt;&gt; val set = setOf("1984", 2, 3, "Brave new world", 11)
&gt;&gt; println(set.filterIsInstance&lt;Int&gt;())
[2, 3, 11]
</code></pre>

<p>可以看到类型判断起来作用了。再看一个泛型工厂方法的例子：</p>

<pre><code class="Kotlin">inline fun &lt;reified T&gt; logger(): Logger = LoggerFactory.getLogger(T::class.java)

class User {
    private val log = logger&lt;User&gt;()
    // ...
}
</code></pre>

<h2>练习</h2>

<p>这里强烈推荐谷歌官方给出的关于Kotlin语言中的<a href="https://developer.android.com/codelabs/basic-android-kotlin-compose-generics#0">类型相关的小练习</a>，可以用来巩固加强一下所学的知识。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/generics.html">Generics: in, out, where</a></li>
<li><a href="https://www.geeksforgeeks.org/kotlin-generics/">Kotlin generics</a></li>
<li><a href="https://www.baeldung.com/kotlin/generics">Generics in Kotlin</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32583310">Kotlin 泛型中的 in 和 out</a></li>
<li><a href="https://blog.csdn.net/u011897062/article/details/130832411">Kotlin泛型＜in, out, where＞概念及示例</a></li>
<li><a href="https://rengwuxian.com/kotlin-generics/">Kotlin 的泛型</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一文带你吃透Kotlin类与对象]]></title>
    <link href="http://toughcoder.net/blog/2024/02/26/kotlin-class-made-easy/"/>
    <updated>2024-02-26T21:22:39+08:00</updated>
    <id>http://toughcoder.net/blog/2024/02/26/kotlin-class-made-easy</id>
    <content type="html"><![CDATA[<p>Kotlin是多范式通用编程语言，对面向对象编程(OOP)自然也提供了全方位的支持。通过<a href="http://toughcoder.net/blog/2018/05/17/introduction-to-kotlin-programming-language/">先前一篇文章</a>，学习了使用Kotlin进行基本面向对象编程的方法，本文将在前文基础之上继续深入的学习面向对象编程的高级特性，以能够写出更加符合OO的代码，并能够从容应对一些复杂的OOP场景。</p>

<p><a href=""><img src="https://bigknol.com/wp-content/uploads/2023/07/kotlin_class_objects.png" title="auto auto" ></a></p>

<!-- more -->


<h2>注意构造的顺序</h2>

<p>在构造对象过程中，有三个地方可以对成员进行初始化：1）是在<strong>首构造方法（Primary constructor）</strong>；2）是在声明成员的同时进行初始化，或者是在<strong>初始化代码块(init {&hellip;})</strong>中；3）是在<strong>次要构造方法(Secondary constructor)</strong>中。</p>

<p>要注意它们之间的<strong>区别和执行顺序</strong>，首构造方法是最先执行的，但它不能运行代码，只能进行赋值；成员声明和初始化代码块(init {&hellip;})是首构造方法的一部分，因此要先于次要构造方法。次要构造方法是最后执行，并且次要构造方法一定要委托到首构造方法。成员声明和初始化代码块之间则依赖于书写的顺序，从上到下执行。</p>

<p>虽然编译器有它的规则来保障顺序，但为了可读性和可维护性，我们不应该完全依赖编译器。这里建议的方式是：</p>

<ul>
<li>把类的最核心的成员放在首构造方法，如必须要依赖的参数，公开的成员，类型体系中的核心成员等，这些应该直接放在首构造方法中，并按重要的顺序进行声明，这样也能方便进行依赖注入和测试Mock对象替换。</li>
<li>私有成员应该在类中声明，并且在声明时进行初始化，如果无法初始化就标记为延迟初始(late init)。</li>
<li>初始化代码块，应该做一些复杂的初始化过程，或者成员之间有关联的初始化，或者做一些构造完成之后的操作。比如像在ViewModel中，构造之后，可能执行拉取数据，这就非常适合放在init {&hellip;}之中。</li>
<li>不建议使用次要构造方法，可以用<strong>给首构造方法的参数设置默认值</strong>的方式来进行成员参数上的重载。</li>
<li>初始化代码块要放在所有成员声明之后，以保障执行顺序。</li>
</ul>


<p>扩展阅读<a href="https://kotlinlang.org/docs/classes.html">Classes﻿</a>和<a href="https://kotlinlang.org/docs/properties.html">Properties﻿</a>。</p>

<h2>妙用late init</h2>

<p>通常成员的初始化可以在声明时完成，比如像集合或者一些简单的原始类型对象（Int, Float, String等）。但如果初始化过程比较复杂，或者初始值较难获得，这种情况下，就适合标记为<strong>延迟初始化late init</strong>，然后在合适的时机对成员进行初始化（比如系统框架层的回调中，或者依赖注入等等）。使用一个未初始化的late init成员时会抛出一个叫做<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-uninitialized-property-access-exception/">UninitializedPropertyAccessException</a>的异常，可以在使用成员变量前用<a href="https://kotlinlang.org/docs/reflection.html#property-references">.isInitialized</a>来判断成员变量是否初始化过：</p>

<pre><code class="Kotlin">if (foo::bar.isInitialized) {
    println(foo.bar)
}
</code></pre>

<p>可以发现，对于Android 开发来说<strong>late init</strong>绝对非常有用，因为对于系统组件，我们无法在其构造方法中进行成员初始化，通常都是在第一个回调(如onCreate)中进行初始化，而这些变量全都应该用late init来标记。</p>

<p>另外，需要注意的是，成员是否有被初始化与成员是否是非法值(如null)并不是同一回事，初始化是第一次对成员对象赋值，赋的什么值(正常对象or null)虚拟机并不关心，但只要有过赋值后变量就初始化过了。因此，<strong>用late init可以帮助减少null检查</strong>。</p>

<p>还需要注意的是，延迟初始化late init与属性委托也不是同一回事，late init通常用于内部私有的成员变量，而属性委托通常用于对外开放的公开成员。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/properties.html">Properties</a>。</p>

<h2>函数式接口</h2>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.aCUdGlN1mIUaSZQXKdceSgHaD4?rs=1&amp;pid=ImgDetMain" alt="" /></p>

<p>接口(interfaces)是更高级别的抽象，专注于行为的抽象，用以实现对象间契约式行为交互。这一部分不打算详细讲解interface的使用，而是重点关注函数式接口(function interface)。Kotlin中的接口与Java 8中的接口是一样的，不再全是抽象方法了，可以有默认方法，也就是对接口的方法添加默认的实现，没有默认实现的方法就是抽象方法了（Abstract method）。只有一个抽象方法的接口称之为函数式接口(functional interface)，或者单个抽象方法接口(Single Abstract Method interface)。用fun interface来声明，如：</p>

<pre><code class="Kotlin">fun interface IntPredict {
    fun accept(i: Int): Boolean
}
</code></pre>

<p>函数式接口的最大优势在于，实现接口时可以简化到只用一个lambda，如：</p>

<pre><code class="Kotlin">val isEnv = IntPredict { it % 2 == 0 }
</code></pre>

<p>注意，只有用fun interface声明的含有一个抽象方法的接口才是函数式接口，才能用lambda。对于普通接口，如果它仅含有一个抽象方法，可以转化为函数式接口，比如原接口是酱紫的：</p>

<pre><code class="Kotlin">interface Printer {
    fun print()
}
</code></pre>

<p>那么，可以直接定义一个fun interface Printer就可以了：</p>

<pre><code class="Kotlin">fun interface Printer {
    fun print()
}
</code></pre>

<p>编译器会帮忙做转化。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/fun-interfaces.html">Functional (SAM) interfaces</a>。</p>

<h2>关键字object的妙用</h2>

<p>关键字object用以方便创建匿名对象的场景，如匿名对象，单例以及静态内部类。</p>

<h3>使用匿名对象</h3>

<p>有些时候我们会实现一些接口，或者继承某个基类，但仅是在本地一次性使用(One shot)，这时匿名对象就派上用场了，类似于Java中的匿名内部类。用<strong>object : </strong>后面跟要实现的接口或者要继承的类：</p>

<pre><code class="Kotlin">window.addMouseListener(object : MouseAdapter() {
    override fun mouseClicked(e: MouseEvent) { ... }
    override fun mouseEntered(e: MouseEvent) { ... }
})
</code></pre>

<h3>单例对象</h3>

<p>用object可以非常方便的实现单例模式：</p>

<pre><code class="Kotlin">object DataProviderManager {
    fun registerDataProvider(provider: DataProvider) { ... }
    val allDataProviders: List&lt;DataProvider&gt;
        get() = { ... }
}
</code></pre>

<p>使用时就直接用类名就可以了：DataProviderManager.registerDataProvider(&hellip;)。</p>

<h3>静态成员和方法</h3>

<p><img src="https://ts1.cn.mm.bing.net/th/id/R-C.b4723d86a22037c40298fff12e484b19?rik=tyTmLVbaHs9Mpw&amp;pid=ImgRaw&amp;r=0" alt="" /></p>

<p>在Java中有静态的成员和方法，用以实现一些属于类的成员和方法，在Kotlin中就需要用companion object来实现同样的功能。</p>

<pre><code class="Kotlin">class MyClass {
    companion object Factory {
        fun create(): MyClass = MyClass()
    }
}
</code></pre>

<p>使用时就是用类+方法：MyClass.create()。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/object-declarations.html">Object expressions and declarations</a>。</p>

<h2>纯数据类型</h2>

<p><img src="https://qwebtechnologies.com/blog/wp-content/uploads/2023/03/Kotlin-Data-Class.png" alt="" /></p>

<p>对于函数式编程，通常要写大量的<a href="https://en.wikipedia.org/wiki/Plain_old_Java_object">PoJo</a>用以在函数之间传递数据，这些对象最大的特点就是仅是数据，且不可变(Immutable)，通常的实现方式就是把成员变量全用final修饰（只读read only）。在Kotlin中，可以非常方便的定义这要的类型，即data class。</p>

<pre><code class="Kotlin">data class User(val name: String, val age: Int)
</code></pre>

<p>针对data class，编译器会自动生成equals, hashCode, toString, copy和componentN方法。注意，虽然成员可以标记为var，但不建议这样做，最好还是都标记为只读val，因为data class就是要Immutable。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/data-classes.html">Data classes</a>。</p>

<h2>密封类和接口</h2>

<p>密封类和接口是指用<strong>关键字sealed</strong>修饰的类和接口。它的作用是限制类的层次结构，用sealed修饰的类和接口，它们的所有子类必须在编译的时候就已知，一旦编译完成，不允许再被继承。</p>

<p>密封类型特别适用于库的设计，能够保证库的完整性。通常用于修饰库中的一些关键的有明确类型要求的类型，如<strong>消息类型，错误类型</strong>等等。因为，库会预定义一些消息类型，以及处理消息的接口，假如调用者扩展了某一消息类型，加了很多自定义的东西，这时再用库中的接口来处理的时候，可能会产生未预期的行为，因为库可能不认识这个新的新的消息类型，但因为是子类继承，语法上是合法的。这时密封类型就能派上用场，把消息类型用sealed修饰，就能保证库的完备性，它提供的错误处理接口一定可以正确处理它定义的消息类型。但注意不能滥用，没有必要为库的每一个类和接口都用sealed修饰，其实大部分时候我们是用不到sealed的。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/sealed-classes.html">Sealed classes and interfaces</a>。</p>

<h2>类型别名</h2>

<p>一个非常有意思的特性是类型别名，并不是定义一个新类型，而是取个别名。一般情况下，是为了方便，比如目标类型名字太长时，或者有大量的泛型参数时，就可以为它定义一个别名，图个省流。</p>

<pre><code class="Kotlin">typealias NodeSet = Set&lt;Network.Node&gt;

typealias MyHandler = (Int, String, Any) -&gt; Unit
</code></pre>

<p>扩展阅读<a href="https://kotlinlang.org/docs/type-aliases.html">Type aliases</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[专家之路上的Flow高级秘籍]]></title>
    <link href="http://toughcoder.net/blog/2024/01/27/an-advanced-guide-to-kotlin-flow/"/>
    <updated>2024-01-27T20:59:38+08:00</updated>
    <id>http://toughcoder.net/blog/2024/01/27/an-advanced-guide-to-kotlin-flow</id>
    <content type="html"><![CDATA[<blockquote><p>『君不见，黄河之水天上来，奔流到海不复回。』</p></blockquote>

<p>学习与河流一样，一方面学无止境，又是逆水行舟，不进则退，因为其他人都在卷。<a href="http://toughcoder.net/blog/2024/01/25/kotlin-flow-made-easy/">前文一篇文章</a>讲了Flow的基础，大多数情况下够用了，但是不能停止卷，因为你不卷，就会被别人卷。一旦涉及到复杂的应用场景，就需要用到一些高级的API。今天就来学习一下Flow的高级特性，当遇到问题时也能更从容的应对。</p>

<p><a href=""><img src="https://amitshekhar.me/static/images/blog/flow-api-in-kotlin.png" title="auto auto" ></a></p>

<!-- more -->


<h2>上下文切换</h2>

<p>Flow是基于协程的，是用协程来实现并发，前面也提到过像<a href="">flow {&hellip;}</a>，在上游生产数据，以及中游做变幻时，都是可以直接调用suspend，耗时甚至是阻塞的函数的。而终端操作符如<a href="">collect</a>则是suspend的，调用者（也就是消费者）需要负责确保collect是在协程中调用。我们还知道Flow是是冷流，消费者终端才会触发上游生产者生产，所以对于flow {&hellip;}来说，它的上游和中游运行的上下文来自于终端调用者的上下文，这个叫做『上下文保留』（context preservation），我们可以用一个&#127792; 来验证一下：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    // Should be main by default
    simple().collect { log("Got: $it") }

    // Collect in a specified context
    withContext(Dispatchers.Default) {
        simple().collect { log("Now got: $it") }
    }
}

private fun simple(): Flow&lt;Int&gt; = flow {
    log("Started the simple flow")
    for (i in 1..3) {
        delay(100)
        log("Producing $i")
        emit(i)
    }
}
</code></pre>

<p>输出如下：</p>

<pre><code class="Bash">[main @coroutine#1] Started the simple flow
[main @coroutine#1] Producing 1
[main @coroutine#1] Got: 1
[main @coroutine#1] Producing 2
[main @coroutine#1] Got: 2
[main @coroutine#1] Producing 3
[main @coroutine#1] Got: 3
[DefaultDispatcher-worker-1 @coroutine#1] Started the simple flow
[DefaultDispatcher-worker-1 @coroutine#1] Producing 1
[DefaultDispatcher-worker-1 @coroutine#1] Now got: 1
[DefaultDispatcher-worker-1 @coroutine#1] Producing 2
[DefaultDispatcher-worker-1 @coroutine#1] Now got: 2
[DefaultDispatcher-worker-1 @coroutine#1] Producing 3
[DefaultDispatcher-worker-1 @coroutine#1] Now got: 3
</code></pre>

<p>从这个&#127792; 可以清楚的看到，Flow的context是来自于终端调用者的。</p>

<h3>用flowOn来指定上下文</h3>

<p>有时候使用终端调用者的上下文可能不太方便，因为生产者与消费者的模式其实是解耦的，它们不应该相互受制于对方，对于关键的并发的上下文更是如此。比如说在GUI的应用中，明显应该在工作线程中生产数据，在UI线程中消费数据，从上面的例子来看，由终端调用者来决定上游上下文明显不可取。有同学举手了，欺负我没学过协程是吧？我可以在Flow内部使用withContext来指定上下文啊，我们来试试：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    // Should be main by default
    simple().collect { log("Got: $it") }
}

private fun simple(): Flow&lt;Int&gt; = flow {
    withContext(Dispatchers.Default) {
        log("Started the simple flow")
        for (i in 1..3) {
            delay(100)
            log("Producing $i")
            emit(i)
        }
    }
}
</code></pre>

<p>这位同学可以直接出去了，因为你的代码crash 了：</p>

<pre><code class="Bash">[DefaultDispatcher-worker-1 @coroutine#1] Started the simple flow
[DefaultDispatcher-worker-1 @coroutine#1] Producing 1
Exception in thread "main" java.lang.IllegalStateException: Flow invariant is violated:
        Flow was collected in [CoroutineId(1), "coroutine#1":BlockingCoroutine{Active}@545486c7, BlockingEventLoop@13bfcf14],
        but emission happened in [CoroutineId(1), "coroutine#1":DispatchedCoroutine{Active}@27015c5a, Dispatchers.Default].
        Please refer to 'flow' documentation or use 'flowOn' instead
</code></pre>

<p>意思大概是说Flow内部不让直接用withContext来切上下文，破坏了Flow的不变式，想切上下文要用flowOn。而且仔细看，异常是由emit函数抛出来的。</p>

<p>其实Flow的设计者已经考虑到了这个问题，并且给出了优雅的方式，如果想切换Flow内部（也即上游和中游）的运行上下文，要用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html">flowOn</a>函数：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    // Should be main by default
    simple().collect { log("Got: $it") }
}

private fun simple(): Flow&lt;Int&gt; = flow {
    log("Started the simple flow")
    for (i in 1..3) {
        delay(100)
        log("Producing $i")
        emit(i)
        Thread.sleep(50)
    }
}.flowOn(Dispatchers.Default)
//[DefaultDispatcher-worker-1 @coroutine#2] Started the simple flow
//[DefaultDispatcher-worker-1 @coroutine#2] Producing 1
//[main @coroutine#1] Got: 1
//[DefaultDispatcher-worker-1 @coroutine#2] Producing 2
//[main @coroutine#1] Got: 2
//[DefaultDispatcher-worker-1 @coroutine#2] Producing 3
//[main @coroutine#1] Got: 3
</code></pre>

<p>这回就和谐多了，后台搞生产，UI只展示，完美！还需要特别注意的是<strong>函数flowOn只影响它的上游，不影响它的下游，更不会影响终端</strong>，终端永远都在<strong>其调用者的上下文</strong>中，来看一个&#127792; ：</p>

<pre><code class="Kotlin">withContext(Dispatchers.Main) {    val singleValue = intFlow // will be executed on IO if context wasn't specified before        .map { ... } // Will be executed in IO        .flowOn(Dispatchers.IO)        .filter { ... } // Will be executed in Default        .flowOn(Dispatchers.Default)        .single() // Will be executed in the Main}
</code></pre>

<p>第一个flowOn切到<em>IO</em>，只影响到它前面的创建和map，第二次切换到<em>Default</em>，只影响filter。single是终端，是在<em>Main</em>，因为它的调用者是在<em>Main</em>里面。</p>

<p><strong>注意，注意：</strong> Flow是一个数据流，保持其数据流的特点是相当重要的，无论是正常数据，异常数据，还是出错都是一种数据，应该让其自上而下的流动，在<strong>中游变幻时或者终端时通过操作符来处理</strong>。所以，像硬性的上下文切换，或者异常的try/catch都是不允许的。这就是所谓的流的不变性（Flow invariant）。后面讲异常时还会提到这点。</p>

<h2>任意上下文的Flow builders</h2>

<p>从前面的学习我们知道了，下下文保留的特性，终端会决定上游生产者的上下文，当然也可以通过flowOn来改变上下文。Flow builder其实就是一个生产者，异步的emit数据。但有些时候生产数据时的上下文，也就是调用emit时的上下文，是不确定的。比如说安卓 上面的各种回调（callback）有些是回调在调用者的线程里，有些则不是。<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow.html">flow {&hellip;}</a>中的emit就不能在异步的回调里面调用，这时就要用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/callback-flow.html">callbackFlow {&hellip;}</a>。callbackFlow专门适用于把现有的一些回调转为Flow，最典型的应用就是位置信息：</p>

<pre><code class="Kotlin">fun locationFlow(): Flow&lt;Location&gt; = callbackFlow {
    val listener = object : LocationListener {
        override fun onLocationUpdate(loc: Location) {
            trySend(location)
        }
    }
    locationManager.reqisterLocaitonUpdates(listener)

    awaitClose {
        locationManager.unregisterLocationUpdates(listener)
    }
}
</code></pre>

<p>如果这个Flow，用flow {}去创建会抛异常，因为emit没法在回调中使用。callbackFlow会在回调中发射数据，并在<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/await-close.html">awaitClose</a>代码块中反注册回调以清理资源。awaitClose会在这个流结束时（完成或者被取消）被回调到，以有机会进行资源清理。</p>

<p>其实，无论是flow {}还是callbackFlow {}都是<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/channel-flow.html">channelFlow {}</a>的简单化，channelFlow非常复杂，也超级强大，它可以自带buffer，自带并发，适用于创建一些非常复杂的Flow。在多数时候flow {}和callbackFlow {}就够我们用了。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://stackoverflow.com/questions/61865744/android-kotlin-coroutines-what-is-the-difference-between-flow-callbackflow-ch">Android Kotlin Coroutines: what is the difference between flow, callbackFlow, channelFlow,&hellip; other flow constructors</a></li>
<li><a href="https://www.cnblogs.com/joy99/p/15805962.html">Kotlin 协程四 —— Flow 和 Channel 的应用 </a></li>
<li><a href="https://juejin.cn/post/7220593395420627004">[译]轻松学习Kotlin的Flow、ChannelFlow和CallbackFlow</a></li>
<li><a href="https://juejin.cn/post/7202265125540659259">轻松搞定Kotlin的Flow, ChannelFlow和CallbackFlow - 2</a></li>
</ul>


<h2>副作用函数</h2>

<p>Flow是一个数据流，核心思想是把数据的生产和处理和最终消费分开，上游只负责生产数据，各种操作都应该由中游操作符来做，最终数据由终端消费掉。需要加强数据的封装性，和流的不变性，不破坏管道，用各种转换器来对数据进行操作。那么，对于流何时开始，每个数据何时产生，流什么时候终止，这些事件对于调试来说是很有帮助的。Flow的设计者给出了一系列副作用函数来做之些事情。副作用的意思就是这些函数不会对流本身产生影响。</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-start.html">onStart</a> Flow开始生产之前会调用此函数。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html">onEach</a> 在生产(emit)每个数据之前调用此函数，这个函数最常用被用来打日志，以查看每个产生的数据。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-completion.html">onCompletion</a> 当Flow终止时或者被取消后会调用此函数。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-subscription.html">onSubscritpion</a> 有消费者了时调用此函数（也就是有人collect了此Flow时）。</li>
</ul>


<h2>异常，取消和错误处理</h2>

<p>这一小节重点来看看非正常代码逻辑的处理。先来看看异常处理（Exception handling）。</p>

<h3>用catch函数来处理Flow过程中的异常</h3>

<p>代码随时都可能抛出异常，所以异常处理是一个必须要考虑的事情。当然可以在Flow的各个节点如上游生产，中游变幻和下游终端的代码块里面各种try/catch。一来是不够优雅，再者这会破坏Flow的不变性或者说一致性，它就是管道，数据在里面流动，不应该加以过多的干扰，想要对数据处理应该用操作符。也就是说要让异常（包括其他错误也是如此）对Flow是透明的，意思是说Flow并不关心是否有异常。所以提供了一个<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html">catch函数</a>，它的作用是捕获并处理上游操作中发生的异常：</p>

<pre><code class="Kotlin">simple()    .catch { e -&gt; emit("Caught $e") } // emit on exception    .collect { value -&gt; println(value) }
</code></pre>

<p>需要注意catch与flowOn一样，只影响上游发生的异常，管不了下游：</p>

<pre><code class="Kotlin">flow { emitData() }    .map { computeOne(it) }    .catch { ... } // catches exceptions in emitData and computeOne    .map { computeTwo(it) }    .collect { process(it) } // throws exceptions from process and computeTwo
</code></pre>

<h3>取消Flow</h3>

<p>Flow没有显式的取消函数。Flow是冷流，有消费者时才会去生产数据，消费者停止消费了，Flow自然也就被取消了。终端操作都是suspend的，也就是要在协程中调用，因此<strong>取消终端调用的协程，就会取消Flow。</strong></p>

<h3>错误处理</h3>

<p>其实没有特别的错误处理函数，前面的异常算是一个，如果上游没有抛出异常，就不会有其他错误了，因为错误也是数据的一种类型，并且是由我们自己根据场景来定义的。比如说从网络获取新闻列表，正常时的数据当然是一个个的新闻条目。出错了，比如无网络，或者服务器无响应，这时可能返回一个空的条目，里面有错误的具体信息。但这都是由业务逻辑决定的，是业务逻辑层面的东西。对于Flow而言，都还是有数据的，都是一种数据，具体数据的解读，那是消费者终端的事情，Flow并不关心。</p>

<p>唯一算得上错误处理的函数就是<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-empty.html">onEmpty</a>，它会在Flow是空的时候，也就是不生产任何数据的时候被回调。可以在onEmpty里面生产emit数据，比如产生一个带有错误信息的数据，或者产生一个默认值。因为Flow为空，不产生emit任何数据时，管子是空的数据没有流动，Flow的整个链路，特别是终端collect是不会被执行的，这时可能会有问题，比如UI根本无法做出任何react，除非你设置过了默认UI状态，否则可能会不对。这个时候如果用onEmpty去产生一些默认值或者错误信息的话，就能激活整个Flow，终端能做出预期的响应。</p>

<h3>重试机制</h3>

<p>另一个非常有用的函数就是<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/retry.html">retry</a>，它可以预设一个条件，当条件满足时就会触发重新collect。Flow是冷流，有消费者collect时才会触发生产者emit数据，因此重新collect就能让Flow重新emit数据流。</p>

<h2>背压</h2>

<p>Flow是异步数据流，响应式编程范式，上游生产数据，下游终端消费数据。有时候可能会遇到这样一种情况，就是上游数据生产的速度超过了下游终端的消费速度，这会造成数据流积压在管道中，终端无法及时响应。这种情况称为『背压（Back pressure）』。想像一下一个水管，如果进水速度大于水龙头流出的速度，水就会积压在水管里，如果水管是比较薄弱的（如气球），那么它会膨胀，最后爆掉。</p>

<p>通常情况下，当上游是较为可控的生产者时，不会产生背压，但如果是一些不是开发人员可控的，如硬件（触摸事件，位置信息，传感器，摄像头），其他系统（系统框架的回调，或者服务器的Push）等等，就会产生背压，这时必须进行相应的处理。所有的FRP式异步数据流API都必须处理『背压』，Flow也有相应的API来处理：</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html">buffer</a> 把生产者的emit的数据缓存，然后用Channel以并发的方式流向中游和下游，可以简单理解为并发地调用collect。正常情况下Flow是顺序的（Sequentially），就是数据从上游到中游再到终端，按顺序流动，先生产的数据先流到collect，这就是顺序的数据流sequentially。用上buffer后，就是会是并发的流，先emit的数据不一定先到collect，这就是concurrently。明显，能用buffer的前提是终端处理数据时没有对数据顺序的依赖。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html">conflate</a> 也会像buffer一样启动并发式emit数据，但未能及时被终端消费掉的数据会被丢弃，终端只处理最新数据。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect-latest.html">collectLatest</a> 当有新的数据流出来时，终端只处理最新的数据，此之的终端处理会被取消掉（如果还没有处理完）。</li>
</ul>


<h2>转为热流</h2>

<p>常规的Flow都是冷的(cold flow)，但有时热流(hot flow)也有它的应用场景，Flow API中也有创建热流的方法。
<img src="https://koenig-media.raywenderlich.com/uploads/2021/05/StateFlowAndSharedFlow-twitter.png" alt="" /></p>

<h3>StateFlow</h3>

<p><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/">StateFlow</a>是一个『状态持有』流，它仅包含一个当前元素<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/value.html">value</a>，可以用过<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/update.html">update</a>来更新此状态。它是一个热流，可以有多个终端colloctor，每次更新都会把当前的值emit给所有的终端。</p>

<p>可以用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-state-flow.html">构造方法MutableStateFlow</a>创建一个StateFlow，或者通过函数<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/state-in.html">stateIn</a>来把一个冷流转化为一个StateFlow。</p>

<p>StateFlow是比较常用的，在安卓开发中，几乎所有的ViewModel都会用StateFlow来暂存UI状态数据。</p>

<h3>SharedFlow</h3>

<p>比StateFlow更为通用的便是通用的热流<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-shared-flow/">SharedFlow</a>。可以通过构造方法<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-shared-flow.html">MutableSharedFlow</a>来创建SharedFlow，或者通过函数<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/share-in.html">sharedIn</a>把一个冷流转为SharedFlow。</p>

<p>SharedFlow可以有多个终端collector，所以可以实现一对多的通知，如实现<a href="https://en.wikipedia.org/wiki/Observer_pattern">观察者模式</a>，或者像设置/配置更新，或者广播等等就可以考虑用SharedFlow来实现。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://developer.android.com/kotlin/flow/stateflow-and-sharedflow">StateFlow and SharedFlow</a></li>
<li><a href="https://juejin.cn/post/7314159614065131554">SharedFlow vs StateFlow，一篇看懂选择和使用技巧</a></li>
<li><a href="https://juejin.cn/post/7195569817940164668">Kotlin SharedFlow&amp;StateFlow 热流到底有多热？</a></li>
<li><a href="https://juejin.cn/post/7271832299339169844">ShareFlow与StateFlow实战</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
