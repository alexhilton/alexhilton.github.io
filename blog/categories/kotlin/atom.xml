<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Kotlin | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/kotlin/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2025-11-25T08:34:05+00:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Kotlin互斥锁(Mutex)：协程的线程安全守护神]]></title>
    <link href="https://alexhilton.github.io/blog/2025/10/15/kotlin-mutex/"/>
    <updated>2025-10-15T15:05:51+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/10/15/kotlin-mutex</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Kotlin Mutex: Thread-Safe Concurrency for Coroutines」，原文链接<a href="https://carrion.dev/en/posts/kotlin-mutex-concurrency-guide/">https://carrion.dev/en/posts/kotlin-mutex-concurrency-guide/</a>，由Ignacio Carrión发布于2025年10月3日。</p></blockquote>

<p><a href=""><img src="file:///Users/alexhilton/Downloads/kotlin_mutex.webp" title="auto auto" ></a></p>

<!-- more -->


<p>使用 Kotlin 协程构建并发应用程序时，保护共享的可变状态至关重要。虽然传统的 Java 同步工具（例如 <code>synchronized</code> 块和 <code>ReentrantLock</code>）可以正常工作，但它们会阻塞线程，并且与协程的挂起模型不兼容。因此，引入 <code>Mutex</code>——一个协程友好的同步原语，它提供互斥而不阻塞线程。</p>

<p>本指南探讨了何时使用 Mutex、最佳实践以及它与其他并发控制机制的比较。</p>

<h2>TL;DR：省流版本的建议</h2>

<ul>
<li>当需要保护多个协程访问的共享可变状态时，请使用 <code>Mutex</code>。</li>
<li>在协程代码中，优先使用 <code>Mutex</code> 而不是 <code>synchronized</code>，以避免阻塞线程。</li>
<li>使用 <code>mutex.withLock { }</code> 自动获取和释放锁。</li>
<li>对于更复杂的状态管理场景，请考虑使用 <code>Actor</code> 或 <code>StateFlow</code>。</li>
<li>对于简单的计数器，请改用 <code>AtomicInteger</code> 或 <code>AtomicReference</code>。</li>
<li>如果需要将并发访问限制为多个许可，请使用 <code>Semaphore</code>。</li>
<li>如果不使用 <code>withLock</code>，请始终在 finally 块中释放锁。</li>
</ul>


<h2>什么是互斥锁？</h2>

<p><code>Mutex</code>（互斥）是 <code>kotlinx.coroutines</code> 中的同步原语，用于确保同一时间只有一个协程可以执行临界区。与阻塞线程的传统锁不同，Mutex 会暂停协程，从而使线程可以自由地执行其他工作。</p>

<p>基本结构：</p>

<pre><code class="kotlin">import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock

val mutex = Mutex()

suspend fun protectedOperation() {
    mutex.withLock {
        // Critical section - only one coroutine at a time
        // Modify shared state safely here
    }
}
</code></pre>

<p>关键特性：</p>

<ul>
<li>非阻塞：暂停协程而不是阻塞线程</li>
<li>公平：默认按先进先出顺序授予访问权限</li>
<li>不重入安全：持有锁的协程无法再次获取锁（防止死锁）</li>
<li>轻量级：比线程阻塞锁更高效</li>
</ul>


<h2>互斥锁的核心用例</h2>

<p>最常见的用例——确保对共享变量的安全访问：</p>

<pre><code class="kotlin">class CounterService {
    private var counter = 0
    private val mutex = Mutex()

    suspend fun increment() {
        mutex.withLock {
            counter++
        }
    }

    suspend fun getCount(): Int {
        return mutex.withLock {
            counter
        }
    }
}
</code></pre>

<h3>2. 协调资源访问</h3>

<p>当多个协程需要对某个资源进行独占访问时：</p>

<pre><code class="kotlin">class FileWriter(private val file: File) {
    private val mutex = Mutex()

    suspend fun appendLine(line: String) {
        mutex.withLock {
            file.appendText("$line\n")
        }
    }
}
</code></pre>

<h3>3.确保顺序执行</h3>

<p>即使操作是并发触发的，也必须按顺序执行：</p>

<pre><code class="kotlin">class OrderProcessor {
    private val mutex = Mutex()
    private val orders = mutableListOf&lt;Order&gt;()

    suspend fun processOrder(order: Order) {
        mutex.withLock {
            // Ensure orders are processed sequentially
            orders.add(order)
            validateOrder(order)
            persistOrder(order)
        }
    }
}
</code></pre>

<h3>4. 线程安全的延迟初始化</h3>

<p>在挂起上下文中实现线程安全的延迟初始化：</p>

<pre><code class="kotlin">class DatabaseConnection {
    private var connection: Connection? = null
    private val mutex = Mutex()

    suspend fun getConnection(): Connection {
        if (connection != null) return connection!!

        return mutex.withLock {
            // Double-check inside lock
            connection ?: createConnection().also { connection = it }
        }
    }

    private suspend fun createConnection(): Connection {
        delay(1000) // Simulate connection setup
        return Connection()
    }
}
</code></pre>

<h2>最佳实践</h2>

<h3>1. 始终使用 withLock</h3>

<p>即使发生异常，withLock 也会自动处理锁的获取和释放：</p>

<pre><code class="kotlin">// ✅ Good: Automatic cleanup
mutex.withLock {
    dangerousOperation()
}

// ❌ Bad: Manual management, error-prone
mutex.lock()
try {
    dangerousOperation()
} finally {
    mutex.unlock()
}
</code></pre>

<h3>2. 保持临界区较小</h3>

<p>尽量减少锁的持有时间以减少争用：</p>

<pre><code class="kotlin">// ✅ Good: Lock only for critical section
suspend fun updateUser(userId: String, name: String) {
    val validated = validateName(name) // Outside lock

    mutex.withLock {
        userCache[userId] = validated // Only this needs protection
    }

    notifyObservers(userId) // Outside lock
}

// ❌ Bad: Holding lock during slow operations
suspend fun updateUserSlow(userId: String, name: String) {
    mutex.withLock {
        val validated = validateName(name) // Slow operation inside lock
        userCache[userId] = validated
        notifyObservers(userId) // I/O inside lock
    }
}
</code></pre>

<h3>3. 避免嵌套锁</h3>

<p>互斥锁不可重入。避免两次获取同一个锁：</p>

<pre><code class="kotlin">// ❌ Bad: Deadlock!
suspend fun problematic() {
    mutex.withLock {
        helperFunction() // Tries to acquire mutex again
    }
}

suspend fun helperFunction() {
    mutex.withLock {
        // Will suspend forever
    }
}

// ✅ Good: Restructure to avoid nesting
suspend fun better() {
    mutex.withLock {
        helperFunctionUnsafe() // No lock acquisition
    }
}

fun helperFunctionUnsafe() {
    // Assumes caller holds lock
}
</code></pre>

<h3>4. 优先考虑无锁替代方案</h3>

<p>对于简单操作，原子类型速度更快：</p>

<pre><code class="kotlin">// ✅ Better for simple counters
class AtomicCounter {
    private val counter = AtomicInteger(0)

    fun increment() = counter.incrementAndGet()
    fun get() = counter.get()
}

// ❌ Overkill for a simple counter
class MutexCounter {
    private var counter = 0
    private val mutex = Mutex()

    suspend fun increment() {
        mutex.withLock { counter++ }
    }
}
</code></pre>

<h3>5.文档锁不变量</h3>

<p>明确锁保护的对象：</p>

<pre><code class="kotlin">class UserCache {
    private val mutex = Mutex() // Protects userMap and lastUpdate
    private val userMap = mutableMapOf&lt;String, User&gt;()
    private var lastUpdate = 0L

    suspend fun updateUser(id: String, user: User) {
        mutex.withLock {
            userMap[id] = user
            lastUpdate = System.currentTimeMillis()
        }
    }
}
</code></pre>

<h2>互斥锁 vs. 其他同步方法</h2>

<h3>互斥锁 vs. synchronized</h3>

<pre><code class="kotlin">// Traditional synchronized (blocks thread)
class SynchronizedCounter {
    private var count = 0

    @Synchronized
    fun increment() {
        count++ // Thread blocked while waiting
    }
}

// Mutex (suspends coroutine)
class MutexCounter {
    private var count = 0
    private val mutex = Mutex()

    suspend fun increment() {
        mutex.withLock {
            count++ // Coroutine suspended, thread free
        }
    }
}
</code></pre>

<p><strong>何时该用哪个：</strong></p>

<ul>
<li>对于非暂停代码和旧版 Java 互操作，请使用 <code>synchronized</code></li>
<li>对于暂停函数和基于协程的代码，请使用 <code>Mutex</code></li>
<li>在协程上下文中，<code>Mutex</code> 效率更高，因为线程不会被阻塞</li>
</ul>


<h3>互斥锁 vs. 信号量</h3>

<pre><code class="kotlin">// Mutex: Only one coroutine at a time
val mutex = Mutex()

// Semaphore: N coroutines at a time
val semaphore = Semaphore(permits = 3)

// Example: Rate limiting API calls
class ApiClient {
    private val semaphore = Semaphore(5) // Max 5 concurrent requests

    suspend fun makeRequest(endpoint: String): Response {
        semaphore.withPermit {
            return httpClient.get(endpoint)
        }
    }
}
</code></pre>

<p><strong>何时使用谁：</strong></p>

<ul>
<li>需要独占访问（单次许可）时使用 <code>Mutex</code></li>
<li>需要将并发限制为 N 个操作时使用 <code>Semaphore</code></li>
</ul>


<h3>互斥锁 vs. Actor</h3>

<pre><code class="kotlin">// Mutex: Manual synchronization
class MutexBasedCache {
    private val cache = mutableMapOf&lt;String, Data&gt;()
    private val mutex = Mutex()

    suspend fun get(key: String) = mutex.withLock { cache[key] }
    suspend fun put(key: String, value: Data) = mutex.withLock { cache[key] = value }
}

// Actor: Message-based synchronization
sealed class CacheMessage
data class Get(val key: String, val response: CompletableDeferred&lt;Data?&gt;) : CacheMessage()
data class Put(val key: String, val value: Data) : CacheMessage()

fun CoroutineScope.cacheActor() = actor&lt;CacheMessage&gt; {
    val cache = mutableMapOf&lt;String, Data&gt;()

    for (msg in channel) {
        when (msg) {
            is Get -&gt; msg.response.complete(cache[msg.key])
            is Put -&gt; cache[msg.key] = msg.value
        }
    }
}
</code></pre>

<p><strong>何时使用谁：</strong></p>

<ul>
<li>使用 <code>Mutex</code> 进行直接方法调用的简单同步</li>
<li>对于复杂的状态机或需要消息队列时，使用 <code>Actor</code></li>
<li>Actor 提供更好的封装性，并且可以处理背压</li>
</ul>


<h3>Mutex 与 StateFlow</h3>

<pre><code class="kotlin">// Mutex: Imperative state management
class MutexState {
    private var state = 0
    private val mutex = Mutex()

    suspend fun updateState(transform: (Int) -&gt; Int) {
        mutex.withLock {
            state = transform(state)
        }
    }
}

// StateFlow: Reactive state management
class FlowState {
    private val _state = MutableStateFlow(0)
    val state: StateFlow&lt;Int&gt; = _state.asStateFlow()

    fun updateState(transform: (Int) -&gt; Int) {
        _state.update(transform) // Thread-safe built-in
    }
}
</code></pre>

<p><strong>何时使用哪个：</strong></p>

<ul>
<li>需要自定义同步逻辑时使用 <code>Mutex</code></li>
<li>使用 <code>StateFlow</code> 进行内置线程安全的可观察状态</li>
<li><code>StateFlow</code> 更适合 UI 状态和响应式架构</li>
</ul>


<h3>Mutex 与原子类型</h3>

<pre><code class="kotlin">// AtomicInteger: Lock-free for simple operations
class AtomicCounter {
    private val counter = AtomicInteger(0)

    fun increment() = counter.incrementAndGet()
    fun addAndGet(delta: Int) = counter.addAndGet(delta)
}

// Mutex: For complex operations
class ComplexCounter {
    private var counter = 0
    private var history = mutableListOf&lt;Int&gt;()
    private val mutex = Mutex()

    suspend fun increment() {
        mutex.withLock {
            counter++
            history.add(counter) // Multiple operations
        }
    }
}
</code></pre>

<p><strong>何时使用哪个：</strong></p>

<ul>
<li>使用原子类型进行单变量操作（计数器、标志）</li>
<li>需要协调多个变量时使用 <code>Mutex</code></li>
<li>原子操作速度更快，但受限于特定操作</li>
</ul>


<h2>常见陷阱</h2>

<h3>1. 忘记使用 suspend</h3>

<p>互斥操作需要暂停：</p>

<pre><code class="kotlin">// ❌ Won't compile
fun broken() {
    mutex.withLock { } // Error: suspend function called in non-suspend context
}

// ✅ Correct
suspend fun correct() {
    mutex.withLock { }
}
</code></pre>

<h3>2. 长时间操作期间持有锁</h3>

<pre><code class="kotlin">// ❌ Bad: Holding lock during I/O
suspend fun bad(url: String) {
    mutex.withLock {
        val data = httpClient.get(url) // Network call inside lock
        cache[url] = data
    }
}

// ✅ Good: Fetch outside lock
suspend fun good(url: String) {
    val data = httpClient.get(url)
    mutex.withLock {
        cache[url] = data
    }
}
</code></pre>

<h3>3. 假设可重入</h3>

<pre><code class="kotlin">// ❌ Deadlock: Mutex is not reentrant
suspend fun outer() {
    mutex.withLock {
        inner() // Deadlock!
    }
}

suspend fun inner() {
    mutex.withLock {
        // Never reached
    }
}
</code></pre>

<h3>4. 不处理取消</h3>

<p>持有锁时务必考虑取消：</p>

<pre><code class="kotlin">// ✅ Good: withLock handles cancellation
suspend fun proper() {
    mutex.withLock {
        doWork()
    } // Lock released even on cancellation
}

// ❌ Risky: Manual lock management
suspend fun risky() {
    mutex.lock()
    try {
        doWork() // If cancelled here, lock stays acquired
    } finally {
        mutex.unlock()
    }
}
</code></pre>

<h2>性能考量</h2>

<ul>
<li><strong>互斥 vs. synchronized</strong>：在协程密集型代码中，互斥更高效，因为线程不会被阻塞</li>
<li><strong>争用</strong>：高争用会降低性能；考虑分片（为不同的键设置多个锁）</li>
<li><strong>锁粒度</strong>：更细粒度的锁（更多锁，每个锁保护更少的数据）可减少争用</li>
<li><strong>无锁替代方案</strong>：对于简单操作，原子类型和 <code>StateFlow</code> 速度更快</li>
</ul>


<p>示例：分片以减少争用：</p>

<pre><code class="kotlin">class ShardedCache(private val shardCount: Int = 16) {
    private val mutexes = Array(shardCount) { Mutex() }
    private val caches = Array(shardCount) { mutableMapOf&lt;String, Data&gt;() }

    private fun shardIndex(key: String) = key.hashCode() and (shardCount - 1)

    suspend fun put(key: String, value: Data) {
        val index = shardIndex(key)
        mutexes[index].withLock {
            caches[index][key] = value
        }
    }

    suspend fun get(key: String): Data? {
        val index = shardIndex(key)
        return mutexes[index].withLock {
            caches[index][key]
        }
    }
}
</code></pre>

<h2>真实示例：线程安全的Repository</h2>

<pre><code class="kotlin">class UserRepository(
    private val api: UserApi,
    private val database: UserDatabase
) {
    private val cache = mutableMapOf&lt;String, User&gt;()
    private val mutex = Mutex()

    suspend fun getUser(userId: String): User? {
        // Check cache first (read lock)
        mutex.withLock {
            cache[userId]?.let { return it }
        }

        // Try database (outside lock)
        database.getUser(userId)?.let { user -&gt;
            mutex.withLock {
                cache[userId] = user
            }
            return user
        }

        // Fetch from API (outside lock)
        return try {
            val user = api.fetchUser(userId)
            mutex.withLock {
                cache[userId] = user
                database.insertUser(user)
            }
            user
        } catch (e: Exception) {
            null
        }
    }

    suspend fun updateUser(user: User) {
        mutex.withLock {
            cache[user.id] = user
            database.updateUser(user)
        }
    }

    suspend fun clearCache() {
        mutex.withLock {
            cache.clear()
        }
    }
}
</code></pre>

<h2>测试互斥锁保护的代码</h2>

<pre><code class="kotlin">@Test
fun `concurrent increments should be thread-safe`() = runTest {
    val counter = CounterService()

    // Launch 1000 concurrent increments
    val jobs = List(1000) {
        launch {
            counter.increment()
        }
    }

    jobs.joinAll()

    // Should be exactly 1000
    assertEquals(1000, counter.getCount())
}

@Test
fun `mutex prevents race conditions`() = runTest {
    val cache = mutableMapOf&lt;String, Int&gt;()
    val mutex = Mutex()

    // Simulate race condition
    coroutineScope {
        repeat(100) {
            launch {
                mutex.withLock {
                    val current = cache["key"] ?: 0
                    delay(1) // Simulate work
                    cache["key"] = current + 1
                }
            }
        }
    }

    assertEquals(100, cache["key"])
}
</code></pre>

<h2>总结</h2>

<p><code>Mutex</code> 是一个强大的工具，用于在基于协程的应用程序中保护共享可变状态。它提供线程安全的同步，而不会阻塞线程，使其成为并发协程代码的理想选择。</p>

<p><strong>关键要点</strong>：</p>

<ul>
<li>使用 <code>withLock</code> 进行自动锁管理</li>
<li>保持临界区简洁高效</li>
<li>适当时考虑更简单的替代方案（例如原子操作、StateFlow）</li>
<li>了解何时使用 Mutex 而非其他同步原语</li>
<li>始终妥善处理取消操作</li>
</ul>


<p>记住：最好的同步就是没有同步。尽可能地，设计系统时，通过使用不可变数据结构、消息传递（Actors/Channels）或响应式流（Flow/StateFlow）来完全避免共享可变状态。但是，当你在协程代码中确实需要互斥时，<code>Mutex</code> 是你的最佳选择。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[runBlocking实践：哪里该使用，哪里不该用]]></title>
    <link href="https://alexhilton.github.io/blog/2025/09/23/runblocking-in-practice/"/>
    <updated>2025-09-23T14:34:01+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/09/23/runblocking-in-practice</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「runBlocking in practice: Where it should be used and where not」，原文链接<a href="https://kt.academy/article/run_blocking">https://kt.academy/article/run_blocking</a>，由Marcin Moskała发布于2025年9月1日。</p></blockquote>

<p><a href=""><img src="https://kt.academy/_next/image?url=https%3A%2F%2Fmarcinmoskala.com%2Fkt-academy-articles%2Fpromotion%2Frun_blocking.png&amp;w=3840&amp;q=75" title="auto auto" ></a></p>

<!-- more -->


<p>传统意义上讲，Java 和 Kotlin 项目都基于阻塞调用(blocking)。我所说的阻塞调用是指函数在等待某些操作（例如，等待网络响应）时会阻塞调用者的线程。Kotlin 协程最重要的规则之一是，我们不应该在挂起函数(suspending function)上进行阻塞调用（除非我们使用允许阻塞调用的调度程序，例如 <code>Dispatchers.IO</code>）。</p>

<pre><code class="kotlin">// Incorrect: blocking call in a suspending function
suspend fun getUser(): User {
    val response = api.getUser() // blocking call
    return response.toDomainUser()
}

// Correct: Using withContext(Dispatchers.IO) to make a blocking call in a suspending function
suspend fun getUser(): User = withContext(Dispatchers.IO) {
    val response = api.getUser() // blocking call
    response.toDomainUser()
}
</code></pre>

<p>但是如何反其道而行之呢？如何将挂起调用转换为阻塞调用？为此，我们使用 <code>runBlocking</code>！</p>

<h2><a href="#how-runblocking-works"><code>runBlocking</code> 的工作原理</a></h2>

<p><code>runBlocking</code> 在调用它的线程上启动一个协程，并阻塞该线程直到协程完成。因此，runBlocking 本质上是同步的，因为如果我们多次调用它，第二个调用要等到第一个调用完成后才会启动。作为一个同步协程构建器，<code>runBlocking</code> 返回它启动的协程的结果。</p>

<pre><code class="kotlin">fun main() {
    log("Starting main")
    runBlocking {
        log("Starting first runBlocking")
        delay(1000)
        log("Finishing first runBlocking")
    }
    val result: String = runBlocking {
        log("Starting second runBlocking")
        delay(1000)
        "ABCD"
    }
    log("Second runBlocking finished with result: $result")
}

fun log(message: String) {
    println("[${Thread.currentThread().name}] $message")
}
// [main] Starting main
// [main] Starting first runBlocking
// (1 sec)
// [main] Finishing first runBlocking
// [main] Starting second runBlocking
// (1 sec)
// [main] Second runBlocking finished with result: ABCD
</code></pre>

<p>由于 <code>runBlocking</code> 启动了一个作用域，它会等待其中启动的所有协程完成。这意味着它会等待所有子协程完成。这就是为什么下面的程序要等到所有三个异步协程都完成才会完成。为了展示如何使用 <code>runBlocking</code> 定义结果，我还让这个程序从 <code>main</code> 函数返回 <code>0</code>。</p>

<pre><code class="kotlin">import kotlinx.coroutines.*

fun main(): Int = runBlocking {
    launch { delayAndPrintHello() }
    launch { delayAndPrintHello() }
    launch { delayAndPrintHello() }
    println("Hello")
    0 // result from main
}

suspend fun delayAndPrintHello() {
    delay(1000L)
    println("World!")
}
// Hello
// (1 sec)
// World!
// World!
// World!
</code></pre>

<p><code>runBlocking</code> 的行为可能会让你想起 <code>coroutineScope</code>，这并非巧合，因为它们都启动同步协程，但 <code>runBlocking</code> 是阻塞的，而 <code>coroutineScope</code> 是暂停的。这意味着完全不同的用法，我们只在暂停函数中使用 <code>coroutineScope</code>，而我们永远不应该在暂停函数中使用 <code>runBlocking</code>。这也意味着 <code>coroutineScope</code> 与其调用者建立关系，并且始终处于协程层次结构的中间，而 <code>runBlocking</code> 则启动一个新的协程层次结构。</p>

<h2><a href="#the-practice-of-using-runblocking">使用 <code>runBlocking</code> 的实践</a></h2>

<p>在正确实现的基于协程的项目中，并使用设计良好的协程友好库，我们几乎不需要使用 <code>runBlocking</code>。如果我们在项目中经常使用它，那就被认为是代码异味。然而，在某些情况下，runBlocking 是有用的，甚至是必要的。也有一些情况下，runBlocking 不应该被使用。我们还会讨论那些曾经需要 runBlocking 但现在有了更好的替代方案的情况。现在，让我们来看看。</p>

<h2><a href="#where-to-use-runblocking">在哪里使用 <code>runBlocking</code></a></h2>

<p><code>runBlocking</code> 应该用于需要启动协程并阻塞当前线程直到其完成的情况。这意味着它可以在以下情况下使用：</p>

<ul>
<li>我们需要等待协程的结果。</li>
<li>我们可以阻塞当前线程。</li>
</ul>


<p>一个常见的 Android 示例是在 Retrofit 客户端中设置一个拦截器，将令牌附加到网络调用。获取令牌可能需要发起网络调用，因此我们需要启动一个协程来获取令牌。同时，拦截器需要结果才能继续执行。这个拦截器在 Retrofit 的池中启动，因此可以调用它的调用。这使得它成为使用 <code>runBlocking</code> 的理想场所。</p>

<pre><code class="kotlin">class AddTokenInterceptor: Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val token = runBlocking { getToken() }
        val request = chain.request().newBuilder()
            .addHeader("Authorization", "Bearer $token")
            .build()
        return chain.proceed(request)
    }
}
</code></pre>

<p>在后端系统上，有时我们需要阻塞当前线程以等待协程完成，例如为了让我们的工具正确测量此进程的执行时间，或者当我们需要调用某些阻塞脚本并获取其结果时。</p>

<pre><code class="kotlin">@MeasureExecutionTime
fun runDataMigrationScript() = runBlocking {
    val sourceData = readDataFromSource()
    val transformedData = transformData(sourceData)
    writeDataToTarget(transformedData)
}
</code></pre>

<p>这些情况很少见，大多数后端项目不需要使用 <code>runBlocking</code>。除非它们有一些基于阻塞调用的遗留代码。考虑以下 <code>UserService</code>，它在我们的应用程序中用于管理用户。我们已经将其迁移到暂停调用，但我们仍然有一些基于阻塞调用的遗留控制器和服务。为了避免重写所有这些，我们可以为暂停函数提供阻塞替代方案。这些替代方案可以通过使用 <code>runBlocking</code> 包装暂停函数来实现（你也可以考虑使用一些调度器）。</p>

<pre><code class="kotlin">class UserService(
    private val userRepository: UserRepository,
) {
    suspend fun findUserById(id: String): User = userRepository.findUserById(id)

    // Blocking alternative for legacy parts of our application
    fun findUserByIdBlocking(id: String): User = runBlocking {
        findUserById(id)
    }

    // ...
}
</code></pre>

<p>这可能是 <code>runBlocking</code> 最重要的用途，它充当了从阻塞到暂停的桥梁。一些库为 Java 定义了阻塞替代方案。</p>

<pre><code class="kotlin">suspend fun readDataFromSource(): Data {
    // ...
}

fun readDataFromSourceBlocking(): Data = runBlocking {
    readDataFromSource()
}
</code></pre>

<h2><a href="#where-not-to-use-runblocking">哪些情况下不应使用 <code>runBlocking</code></a></h2>

<p>在某些情况下，不应使用 <code>runBlocking</code>。此外，切勿在挂起函数中直接使用 <code>runBlocking</code>。<code>runBlocking</code> 会阻塞当前线程，因此不应在挂起函数中进行阻塞调用（除非使用允许阻塞调用的调度程序，例如 <code>Dispatchers.IO</code>）。在这种情况下，很可能不需要 <code>runBlocking</code>。</p>

<pre><code class="kotlin">// Incorrect: runBlocking in a suspending function
suspend fun getToken() = runBlocking {
    // ...
}

// runBlocking is most likely not needed
suspend fun getToken() {
    // ...
}
</code></pre>

<p>不应在不需要等待结果的函数中使用 <code>runBlocking</code>。如果你只需要启动协程，通常最好使用 <code>launch</code> 启动异步协程。</p>

<pre><code class="kotlin">// Incorrect: runBlocking used where we do not need to await result
fun startBackgroundProcess() = runBlocking {
    doSomething()
}

// Correct: Using launch to start an asynchronous coroutine
fun startBackgroundProcess() {
    backgroundScope.launch {
        doSomething()
    }
}
</code></pre>

<p>我们还应注意，不要在不应被阻塞的线程上使用 <code>runBlocking</code>。这在 Android 上尤其成问题，因为阻塞主线程会导致应用程序卡死。</p>

<pre><code class="kotlin">// Incorrect: runBlocking on the main thread
fun onClick() = runBlocking {
    userNameView.test = getUserName()
}

// Correct: Using launch to start an asynchronous coroutine
fun onClick() {
    lifecycleScope.launch {
        userNameView.test = getUserName()
    }
}
</code></pre>

<p>在后端，如果我们在 <code>synchronized</code> 块中使用它，可能会出现问题。一个技巧是使用 <code>launch</code> 实现回调函数。但是，通常情况下，最好重新设计代码，使用暂停而不是阻塞调用，并使用协程友好的工具（我们将在<em>同步协程</em>课程中讨论）。</p>

<pre><code class="kotlin">// Possibly incorrect: runBlocking inside synchronized block
synchronized(lock) {
    // ...
    val user = runBlocking { getUser() }
    // ...
}

// One solution: use launch to implement a callback
fun getUser(callback: (User) -&gt; Unit) {
    backgroundScope.launch {
        val user = getUser() // suspending call
        callback(user)
    }
}
synchronized(lock) {
    // ...
    getUser { user -&gt;
        // ...
    }
}
</code></pre>

<h2><a href="#outdated-runblocking-uses">过时的 <code>runBlocking</code> 用法</a></h2>

<p><code>runBlocking</code> 传统上用于包装 <code>main</code> 函数体。它的属性非常适合此目的：它启动一个协程，因此它可以调用挂起函数或启动其他协程，并且它会阻塞线程直到协程完成，因此我们可以确保程序不会在所有这些进程完成之前结束。</p>

<pre><code class="kotlin">fun main(): Unit = runBlocking {
    val user = getUser() // suspending call
    println("User: $user")
}
</code></pre>

<p><code>runBlocking</code> 仍然可以以这种方式使用，但是在大多数现代情况下，我们更喜欢使用 Kotlin 1.3 中引入的挂起 <code>main</code> 函数。此类函数在底层被一个类似于 <code>runBlocking</code> 的阻塞构建器包装。</p>

<pre><code class="kotlin">suspend fun main() {
    val user = getUser() // suspending call
    println("User: $user")
}
</code></pre>

<p>关键区别在于 <code>runBlocking</code> 设置了一个调度器，使其所有子协程在其正在使用的同一线程上运行。挂起 main 函数不会设置调度器，因此其子协程默认在不同的线程上运行。引入此更改是因为 <code>runBlocking</code> 使用的单线程调度器经常导致意外行为。</p>

<pre><code class="kotlin">fun main(): Unit = runBlocking {
    println(Thread.currentThread().name)
    launch {
        println(Thread.currentThread().name)
    }
}
// main
// main
</code></pre>

<pre><code class="kotlin">suspend fun main(): Unit = coroutineScope {
    println(Thread.currentThread().name)
    launch {
        println(Thread.currentThread().name)
    }
}
// main
// DefaultDispatcher-worker-1
</code></pre>

<p><code>runBlocking</code> 的第二个传统用途是在测试中。它被用来包装测试主体，以便我们可以调用挂起函数并在其中启动协程。现在，我们更倾向于使用 <code>kotlinx-coroutines-test</code> 库中的 <code>runTest</code>，它是 <code>runBlocking</code> 的一个更强大、更灵活的替代方案。它允许我们控制时间、生成后台作用域并跟踪子协程上的异常。<code>runTest</code> 将在<em>测试协程</em>课程中讨论。</p>

<pre><code class="kotlin">class UserRepositoryTest {
    val userRepository = InMemoryUserRepository()
    val userService = UserService(userRepository)

    @Test
    fun testGetUser() = runTest { // previously runBlocking
        // given
        userRepository.hasUser(UserEntity("1234", "John Doe"))

        // when
        val user = userService.getUser("1234")

        // then
        assertEquals("John Doe", user.name)
    }
}
</code></pre>

<h2><a href="#%E6%80%BB%E7%BB%93">总结</a></h2>

<ul>
<li><code>runBlocking</code> 是一个阻塞协程构建器，它启动一个协程并阻塞当前线程直到它完成。</li>
<li><code>runBlocking</code> 是从阻塞世界(blocking)到挂起世界(suspending)的桥梁，它用于在需要阻塞当前线程直到协程完成的地方启动协程。</li>
<li>如果你需要在项目中频繁使用 <code>runBlocking</code>，那么它就是一种代码异味。在设计合理的基于协程的项目中，应该尽量少用，或者干脆不用。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[学会说不！让你彻底学会Kotlin Flow的取消机制]]></title>
    <link href="https://alexhilton.github.io/blog/2025/08/08/flow-cancellation/"/>
    <updated>2025-08-08T12:25:21+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/08/08/flow-cancellation</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Cancellable Flows in Kotlin Coroutines: The Complete Guide to Flow Cancellation Techniques」，原文链接<a href="https://proandroiddev.com/cancellable-flows-in-kotlin-coroutines-the-complete-guide-to-flow-cancellation-techniques-8988a85fc158">https://proandroiddev.com/cancellable-flows-in-kotlin-coroutines-the-complete-guide-to-flow-cancellation-techniques-8988a85fc158</a>，由Sahil Thakar发布于2025年7月21日。</p></blockquote>

<p><strong>译者按：</strong> 本文并不是Flow的基础教程，而是专门讲解如何取消flow的，适合对Flow有一定基础的同学。如果对Flow还不够熟悉，可以先行阅读一下之前的文章：</p>

<ul>
<li><a href="https://juejin.cn/post/7336751931375648820">包教包会的Kotlin Flow教程</a></li>
<li><a href="https://juejin.cn/post/7337517508151590947">专家之路上的Flow高级秘籍</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用优雅的姿式应对Kotlin Flow的回压]]></title>
    <link href="https://alexhilton.github.io/blog/2025/07/03/handling-flow-backpress/"/>
    <updated>2025-07-03T14:09:26+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/07/03/handling-flow-backpress</id>
    <content type="html"><![CDATA[<p>本文译自「How to Manage Backpressure in Kotlin Flow: collect • buffer • conflate • collectLatest」，原文链接<a href="https://proandroiddev.com/how-to-manage-backpressure-in-kotlin-flow-collect-buffer-conflate-collectlatest-b8102284d968">https://proandroiddev.com/how-to-manage-backpressure-in-kotlin-flow-collect-buffer-conflate-collectlatest-b8102284d968</a>，由Shbazhenov发布于2025年6月13日。</p>

<p><a href=""><img src="https://blog.mindorks.com/images/kotlin-flow-banner-image.png" title="auto auto" ></a></p>

<!-- more -->


<p>你是否曾遇到过快速数据源发送的数据量超出应用处理能力的情况，导致应用速度变慢甚至崩溃？Kotlin Flow 内置了一些方法，可让你的生产者和消费者保持同步。本文将介绍：</p>

<ol>
<li>回压的含义</li>
<li>Flow 默认的“互相等待”模式如何工作</li>
<li>何时使用 buffer() 添加小型队列</li>
<li>conflate() 如何跳过旧数据项</li>
<li>为什么 collectLatest { } 会停止旧数据处理</li>
<li>如何根据你的情况选择合适的选项</li>
</ol>


<h2>回压的含义</h2>

<p>回压的作用是确保快速的数据发送方不会压垮较慢的接收方。如果没有回压，你可能会在内存中存储过多的数据，或者浪费时间处理过时的信息。</p>

<p>回压可以帮助你：</p>

<ul>
<li>控制内存使用量</li>
<li>避免不必要的工作</li>
<li>使应用性能更可预测</li>
</ul>


<h2>1. 默认“互相等待”模式</h2>

<p>默认情况下，当你执行以下操作时：</p>

<pre><code class="Kotlin">flow {
  repeat(3) {
    emit(it)
    println("Sent $it")
    delay(100)            // 快速的发送者
  }
}
.collect { value -&gt;
  println("Handling $value")
  delay(300)             // 慢速的处理者
}
</code></pre>

<p>发送方 ( emit ) 将暂停，直到处理方 ( collect ) 处理完最后一个值。没有队列，每个值都是一次发送和处理一个。</p>

<h2>2. 使用 buffer() 添加一个小队列</h2>

<p>如果你希望发送方提前一点，请使用：</p>

<pre><code class="Kotlin">flow { … }
  .buffer(capacity = 2)
  .collect { value -&gt;
    // slow work here
  }
</code></pre>

<ul>
<li>现在，发送者最多可以将 2 个项目放入一个小队列中。</li>
<li>一旦队列满了，它就会再次暂停。</li>
</ul>


<p>这给了你一个有限的队列：你仍然可以处理每个项目，但可以平滑速度峰值。</p>

<h2>3. 使用 conflate() 跳过旧项目</h2>

<p>当你只关心最新数据（例如更新进度条）时，你可以这样写：</p>

<pre><code class="Kotlin">flow { … }
  .conflate()
  .collect { value -&gt;
    println("Update to $value")
    delay(300)
  }
</code></pre>

<ul>
<li>如果处理程序繁忙，则仅保留最新未处理的项目。</li>
<li>较旧的项目将被丢弃，因此你无需处理过时的更新。</li>
</ul>


<p>注意：conflate() 不会停止当前工作；它只是在下次读取时跳过旧值。</p>

<h2>4. 使用 collectLatest { } 停止旧工作</h2>

<p>要进一步操作并在新数据进入时取消任何正在进行的工作，请使用：</p>

<pre><code class="Kotlin">flow { … }
  .collectLatest { value -&gt;
    println("Start $value")
    delay(300)    // 可能会被切断
    println("Done $value")
  }
</code></pre>

<ul>
<li>每次发出（emit）新的数据时，处理前一个值的块都会立即被丢弃。</li>
<li>只有当发送方的发送速度持续超出你的处理能力时，你才需要完成最后一个值的工作。</li>
</ul>


<p>这非常适合边输入边搜索的情况，在这种情况下，你希望在用户再次输入时立即丢弃旧请求。</p>

<h2>5. 选择合适的工具</h2>

<h3>普通 collect</h3>

<ul>
<li>功能：发送方和处理方互相等待，一个接一个</li>
<li>何时选择它：你必须按顺序处理每个项目

<h3>.buffer(n)</h3></li>
<li>功能：大小为 n 的小队列；不丢弃任何项目</li>
<li>何时选择它：你需要少量缓冲，但仍要处理所有项目

<h3>.conflate()</h3></li>
<li>功能：如果处理方繁忙，则仅保留最新项目</li>
<li>何时选择它：你需要最新数据，但仍要完成当前工作

<h3>collectLatest { }</h3></li>
<li>功能：新数据到达后立即取消所有正在进行的工作</li>
<li>何时选择它：只考虑最新的结果；立即放下其他一切

<h2>6. 总结</h2></li>
<li>回压机制可防止快速数据流过载慢速处理器。</li>
<li>默认模式没有队列：安全但速度可能较慢。</li>
<li>buffer() 函数添加了一个小队列：更灵活，不会丢包。</li>
<li>conflate() 函数跳过旧值：始终保持最新，但让当前工作完成。</li>
<li>collectLatest { } 函数停止旧工作：仅完成最新项。</li>
</ul>


<p>下次你的 Flow 感觉太快或太慢时，请问自己：</p>

<ol>
<li>我需要处理每个值吗？</li>
<li>小型队列有帮助吗？</li>
<li>只有最新数据才重要吗？</li>
<li>当新数据到达时，我应该取消旧工作吗？</li>
</ol>


<p>选择最合适的简单选项，Kotlin Flow 会处理余下的事情。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一文搞懂Kotlin符号处理接口KSP]]></title>
    <link href="https://alexhilton.github.io/blog/2024/04/16/kotlin-ksp-made-easy/"/>
    <updated>2024-04-16T13:17:43+00:00</updated>
    <id>https://alexhilton.github.io/blog/2024/04/16/kotlin-ksp-made-easy</id>
    <content type="html"><![CDATA[<p>Kotlin符号处理（Kotlin Symbol Processing）即KSP是可以用于开发轻量级编译器插件的一套API。是Kotlin原生的，Kotlin语法友好的编译器插件。使用简单且易于上手，可以实现一些非常强大的编译时代码处理功能，如代码生成和代码检查。今天就来学习一下KSP的基本原理，以及如何使用KSP API。</p>

<p><a href=""><img src="https://androiddeepdive.github.io/Team-Blog/images/cover_ksp.png" title="auto auto" ></a></p>

<!-- more -->


<p><strong>注意</strong>，本文是Kotlin中较为高级的话题，适合有一定的Kotlin基础的同学，否则理解起来可能有难度，可以事先<a href="https://juejin.cn/column/7351592055908892723">阅读前面的文章</a>。</p>

<h2>什么是KSP</h2>

<p>与前文提到的注解处理器kapt类似，KSP也是一种编译时的插件，能够在编译前处理Kotlin语言的符号。KSP API能地道地处理Kotlin的源码，因为它是专门为Kotlin而设计的，能够完全的理解和识别Kotlin的语言符号，以及Kotlin专属的特性：如扩展函数，声明点泛型变化以及本地函数。KSP API基于Kotlin的语法，把Kotlin程序拆解为各种静态的符号，可以处理如类，成员，函数，参数 以及注解等等。但它并不是运行时的（那是反射做的事情），因此像逻辑如循环和条件语句是没有办法进行处理，以及也无法得到表达式的结果。</p>

<p>虽然KSP是编译器插件，但它是运行在最终编译之前，也就是说在编译器编译全部代码之前，事先会运行KSP插件。所以KSP API最适合做的事情是：</p>

<ol>
<li>读取代码和各种资源文件，并进行分析</li>
<li>生成代码</li>
</ol>


<p>接下来看如何具体使用KSP API。</p>

<h2>配置KSP</h2>

<p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcStf17qaB5JSFveiBVlA6ljiI0OgI3kN4hnQkBKtuFnSw&amp;s" alt="" /></p>

<p>KSP是由谷歌开发的一套工具，包括两部分一个是Kotlin plugin，另一个是依赖库。所以需要在项目的根build.gradle里面，先把plugin添加到项目里：</p>

<pre><code class="Groovy">// The root build.gradle of your project
plugins {
    id 'org.jetbrains.kotlin.jvm' version '1.9.23' apply false
    id 'com.google.devtools.ksp' version '1.9.23-1.0.20' apply false
}
</code></pre>

<p>当然，这一步其实并不是必须的，也可以在每个模块中再配置plugin。</p>

<p>接下来，在使用KSP的模块里面添加plugin，添加依赖以及指明KSP processor，这是最为关键的配置：</p>

<pre><code class="Groovy">// module build.gradle
plugins {
    id 'org.jetbrains.kotlin.jvm'
    id 'com.google.devtools.ksp'
}

dependencies {
    implementation project(':kspannotation')
    ksp project(':kspprocessor')
}
</code></pre>

<p>如果项目顶层指定了plugin的版本，那么到了module这里，就不必再指定版本了。另外就是要注意版本的匹配，ksp的版本前半段『1.9.23』指明 的是最低的Kotlin版本要求。最好是让ksp要求的版本与指定的Kotlin版本匹配或者差距较小，否则可能会有问题。dependencies中的ksp指定的是KSP processor，对于有些库可能注解和定义和KSP的processor可能会在同一个包里，那么写一句就够了，如Room的，就一句：ksp &lsquo;androidx.room:room-compiler:2.6.1&#8217;。</p>

<p>如果是自定义的processor，需要为processor单独建一个library module，配置ksp库为依赖即可：</p>

<pre><code class="Groovy">// KSP processor module build.gradle
plugins {
    id 'org.jetbrains.kotlin.jvm'
}

dependencies {
    implementation project(':kspannotation')

    implementation 'com.google.devtools.ksp:symbol-processing-api:1.9.23-1.0.20'
    implementation 'com.squareup:kotlinpoet-ksp:1.16.0'
}
</code></pre>

<p>典型的KSP procesor（包括网上大部分的例子）都是分了三个module，一个是定义注解的module，一个是实现processor的，一个是使用注解和processor的。但这并不是必须的，为了方便，其实把注解的定义和processor放在一个module就可以了。只要把processor与使用它的module分开来了，就可以。</p>

<p><strong>注意：</strong>对于processor module来说它的类型要是library，并且要是Java library或者Kotlin library，因为这是Kotlin语言层面的东西。对于Android同学来说在新建module时一定要选择『Java or Kotlin Library』。</p>

<h2>实现KSP Processor</h2>

<p>配置好了模块后，剩下的就是要实现一个KSP processor了。</p>

<h3>实现Processor</h3>

<p>大部分工作plugin已经做好了，我们需要做的就是实现一些接口。有两个需要实现，一个是<a href="https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/processing/SymbolProcessorProvider.kt">SymbolProcessorProvider</a>，另一个则是<a href="https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/processing/SymbolProcessor.kt">SymbolProcessor</a>。</p>

<p>SymbolProcessorProvider相当于是processor的一个工厂方法，我们实现它的create方法，返回一个SymbolProcessor实例，一个典型的实现：</p>

<pre><code class="Kotlin">class MyProcessorProvider : SymbolProcessorProvider {
    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
        return MyProcessor(environment.codeGenerator)
    }
}
</code></pre>

<p>它就相当于一个工厂方法，把上下文环境传给processor，SymbolProcessor是重点，我们需要实现它的process方法，针对感兴趣的符号进行处理，比如用<a href="https://square.github.io/kotlinpoet/">KotlinPoet</a>生成代码，这里是发挥创造力的地方：</p>

<pre><code class="Kotlin">class MyProcessor(private val generator: CodeGenerator) : SymbolProcessor {
    override fun process(resolver: Resolver): List&lt;KSAnnotated&gt; {
        val annotatedClasses = resolver
            .getSymbolsWithAnnotation(MyAnnotation::class.java.name)
            .filterIsInstance&lt;KSClassDeclaration&gt;()

        for (aclass in annotatedClasses) {
            val packageName = aclass.packageName.asString()
            val className = aclass.simpleName.asString()
            val methods = aclass.getDeclaredFunctions())
            // ...
         }
        return emptyList()
    }
}
</code></pre>

<h3>注册Processor</h3>

<p>实现了process后还需要把process注册一下，否则ksp plugin无法找到这个processor。在processor module与代码同级文件夹下新建文件『resources/META-INF/services/com.google.devtools.ksp.processing.SymbolProcessorProvider』，然后把刚才实现的provider的完整类名，写在文件里，如果是使用IDE一般都会有提示的。</p>

<pre><code class="Kotlin">// myprocessor/src/main/
//    |-- kotlin/net/toughcoder/
//              |-- MyProcessorProvider.kt
//              |-- MyProcessor.kt
//    |-- resources/META-INF/services/
//              |-- com.google.devtools.ksp.processing.SymbolProcessorProvider
// file: resources/META-INF/services/com.google.devtools.ksp.processing.SymbolProcessorProvider
net.toughcoder.MyProcessorProvider
</code></pre>

<h2>为啥要用KSP</h2>

<p>目前来说KSP最主要应用仍然 是注解的处理，以及配合注解进行代码生成。通过前面一篇<a href="https://juejin.cn/post/7355024828262334501">关于注解的文章</a>中我们知道，注解的处理已经有了一个专门的工具了叫做kapt，就目前来说KSP能做的事情kapt也都能做，它们都是用于编译时代码处理以及代码生成，都能处理注解。那么，在已经有了kapt的前提下，为啥还要搞KSP呢？</p>

<p>kapt虽然是Kotlin的注解处理器，但是它保持Java的兼容性，它直接复用了Java的<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/AbstractProcessor.html">AbstractProcessor</a>，要依赖于Java的annotation procssor以及javac，只适用于Kotlin/JVM，其他target用不起来，因此它并不能算是Kotlin原生的工具，对Kotlin的特性支持不友好。再有就是，为了保持与javac的兼容性，它的处理速度很慢，必须先把Kotlin代码转成javac能认识的标准Java代码，这肯定会有不必要的性能开销。基于这些限制，kapt已经停止开发了，处于维护状态了，不会再添加新功能了。<strong>省流点来说，kapt是以Java角度来看待输入代码的（即也要处理的源码），而KSP是以Kotlin角度</strong>。</p>

<p>KSP则是Kotlin原生的，基于Kotlin开发的，且是为了Kotlin开发的，并不受限于javac，因此所有的Kotlin目标平台都能用。并且对Kotlin的特性支持的很友好。它的处理速度也较kapt有提升，因为不必要做编码转换了，省了一道工序。从官方给出的数据看至少能省25%的编译时间。另外，KSP的API使用起来更加的Kotlin友好一些SymbolProcessor传递过来的<a href="https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/processing/Resolver.kt">Resolver</a>有很方便的接口可以取得被标的类，而且符号对象是<a href="https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/symbol/KSClassDeclaration.kt">KSClassDeclaration</a>，它可以方便的取一个Kotlin类的相关的其他符号，如包名，类名，方法等。</p>

<h2>总结</h2>

<p>通过本文我们理解了KSP的概念，并学会了如何在项目中配置KSP， 以及如何实现一个KSP processor。KSP视Kotlin代码为一系列的静态符号，对Kotlin语言特性支持友好，处于活跃的开发状态且被官方大力支持，因此应该尽早转向KSP。并且相信KSP能做的事情会越来越多。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/ksp-overview.html">Kotlin Symbol Processing API</a></li>
<li><a href="https://developer.android.com/build/migrate-to-ksp">Migrate from kapt to KSP</a></li>
<li><a href="https://www.kodeco.com/33148161-write-a-symbol-processor-with-kotlin-symbol-processing">Write a Symbol Processor with Kotlin Symbol Processing</a></li>
<li><a href="https://www.codecentric.de/wissens-hub/blog/kotlin-symbol-processing-introduction">An Introduction to Kotlin Symbol Processing</a></li>
<li><a href="https://kt.academy/article/ak-ksp">Kotlin Symbol Processing</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
