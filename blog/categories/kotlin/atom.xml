<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Kotlin | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/kotlin/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2026-01-12T12:53:23+00:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[深入理解withContext和launch的真正区别]]></title>
    <link href="https://alexhilton.github.io/blog/2025/12/05/real-diff-between-withcontext-and-launch/"/>
    <updated>2025-12-05T00:00:00+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/12/05/real-diff-between-withcontext-and-launch</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「The Real Difference Between withContext(Dispatchers.IO) and launch(Dispatchers.IO)」，原文链接<a href="https://proandroiddev.com/the-real-difference-between-withcontext-dispatchers-io-and-launch-dispatchers-io-b70ec00a33f2">https://proandroiddev.com/the-real-difference-between-withcontext-dispatchers-io-and-launch-dispatchers-io-b70ec00a33f2</a>，由
Anatolii Frolov发布于2025年11月20日。</p></blockquote>

<p><a href=""><img src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nHuLhSAjZIEbeLHiFdMeSA.png" title="auto auto" ></a></p>

<!-- more -->


<p>在使用 Kotlin 协程时，很容易遇到两种看起来几乎相同的模式。它们都使用了 <code>Dispatchers.IO</code>。它们都将工作移出主线程。它们都出现在不同团队编写的仓库、服务层和 ViewModel 代码中。</p>

<p>但相似之处仅限于表面。它们的行为截然不同——这种差异会影响实际 Android 项目中的顺序、正确性，甚至线程安全。当后台操作影响 UI 状态或共享数据时，这一点尤为重要。</p>

<p>这种困惑不难理解。它们的语法几乎相同，并且都在同一个调度器上运行。但一个会暂停直到工作完成，而另一个会启动并行工作并立即返回。这创建了不同的执行路径，很容易被忽略。</p>

<p>本文解释了 <code>withContext(Dispatchers.IO)</code> 和 <code>launch(Dispatchers.IO)</code> 之间的真正区别，通过实际代码展示了它们的行为差异，并重点介绍了这种差异在生产环境 Android 应用中的重要性。</p>

<h2>看似相同的代码行为却截然不同</h2>

<p>以下两段代码看起来几乎一样：</p>

<pre><code class="kotlin">withContext(Dispatchers.IO) {
    // work
}launch(Dispatchers.IO) {
    // work
}
</code></pre>

<p>它们运行在同一个调度器上。它们都将工作转移到后台线程。但它们的行为<strong>并不</strong>相同。</p>

<p>以下是并排运行它们的结果：</p>

<pre><code class="kotlin">fun main() = runBlocking {
    println("Start")

    launch(Dispatchers.IO) {
        delay(100)
        println("Inside launch")
    }

    withContext(Dispatchers.IO) {
        delay(50)
        println("Inside withContext")
    }

    println("End")
}
</code></pre>

<p>输出：</p>

<pre><code class="bash">Start
Inside withContext
End
Inside launch
</code></pre>

<p>这展示了关键区别。</p>

<p><code>withContext</code> 会等待其工作完成才会继续执行。</p>

<p><code>launch</code> 则完全不等待——它并行运行，并在稍后完成。</p>

<h2>为什么会发生这种情况</h2>

<p><code>withContext</code> 是一个挂起函数。这意味着当前协程会在该行暂停，切换到 <code>Dispatchers.IO</code>，执行代码块，然后从中断的地方继续执行。这里的关键词是<strong>等待</strong>。在该行之后的任何代码都会等待代码块执行完毕。</p>

<p><code>launch</code> 会创建一个新的协程并立即返回。当前协程会立即继续执行，而新创建的代码块会独立执行。这是一种“触发并继续”模式。除非你显式地对新创建的协程调用 <code>join()</code>，否则不会有等待。</p>

<p>这不是一个 bug，而是协程构建器的设计决策。</p>

<p><code>withContext</code> 确保单个协程内部的执行顺序。</p>

<p><code>launch</code> 的设计本身就引入了并发性。</p>

<p>这种视觉上的相似性掩盖了行为上的差异。前者保持代码的可预测顺序，而后者引入了并行工作，这些工作可能会根据调度和负载情况随时完成。</p>

<h2>这种差异在实际项目中的重要性</h2>

<p>在许多 Android 场景中，任务完成的确切时间至关重要。哪怕是顺序上的细微差别，都可能导致一些难以察觉的 bug，直到生产环境才会被发现。</p>

<h3>1. 后台任务完成后更新 UI</h3>

<p>在 ViewModel 中：</p>

<pre><code class="kotlin">viewModelScope.launch {
    val user = withContext(Dispatchers.IO) {
        userRepository.loadUser()
    }
    _state.value = user
}
</code></pre>

<p>输出（概念图）：</p>

<pre><code class="bash">User loaded first
UI updated second
</code></pre>

<p>由于 <code>withContext</code> 会等待，因此 UI 只有在加载完成后才会更新。</p>

<p>但如果将其替换为 <code>launch(Dispatchers.IO)</code>：</p>

<pre><code class="kotlin">viewModelScope.launch {
    var result: User? = null

    launch(Dispatchers.IO) {
        result = userRepository.loadUser()
    }

    _state.value = result
}
</code></pre>

<p>输出（概念图）：</p>

<pre><code class="bash">UI updated first
User loaded later
</code></pre>

<p>这里，UI 在后台任务完成之前就更新了。语法上的视觉相似性掩盖了执行顺序的不同。</p>

<h3>2.协调多步骤后台操作</h3>

<p>在自定义仓库代码中，你可能需要操作严格按照顺序执行。例如，先保存数据，然后写入日志：</p>

<pre><code class="kotlin">withContext(Dispatchers.IO) {
    fileWriter.save(data)
}

withContext(Dispatchers.IO) {
    logWriter.write("Saved")
}
</code></pre>

<p><code>suspend</code> 保证了操作顺序。日志写入必须在保存完成后才能进行。</p>

<p>但使用 <code>launch</code> 则：</p>

<pre><code class="kotlin">launch(Dispatchers.IO) { fileWriter.save(data) }
launch(Dispatchers.IO) { logWriter.write("Saved") }
</code></pre>

<p>这两个操作可以以任意顺序执行。在负载较高的情况下，日志写入可能早于保存操作。这听起来似乎无关紧要，但一旦调试或审计变得困难，就会造成问题。</p>

<h3>3. 访问共享状态</h3>

<p>使用 <code>withContext</code> 进行顺序执行在更新共享对象时更安全：</p>

<pre><code class="kotlin">withContext(Dispatchers.IO) {
    cache.update(item)
}
</code></pre>

<p>使用 <code>launch</code>，两个更新操作可以同时运行：</p>

<pre><code class="kotlin">launch(Dispatchers.IO) { cache.update(item1) }
launch(Dispatchers.IO) { cache.update(item2) }
</code></pre>

<p>除非缓存本身是线程安全的，否则并行写入可能会导致竞态条件。</p>

<h2>为什么这种差异容易被忽略</h2>

<p>主要原因是语法。两者都使用相同的括号。两者都显示 <code>Dispatchers.IO</code>。两者都将代码包裹在代码块中。人们的注意力会集中在调度器上，而不是协程构建器上。</p>

<p>另一个原因是许多现代库已经在内部处理线程。Room DAO 方法和 Retrofit 的挂起函数不需要 <code>withContext(Dispatchers.IO)</code>。由于这些库减少了手动切换调度器，开发者看到的协程构建器之间的明显差异较少。</p>

<p>这可能会造成一种错觉，即所有调度器的用法都可以互换，但对于自定义操作来说并非如此。</p>

<h2>与 async/await 的深入比较</h2>

<p>为了进一步突出差异，请比较以下三个示例：</p>

<pre><code class="kotlin">val deferred = async(Dispatchers.IO) {
    loadData()
}val result = deferred.await()
println(result)
</code></pre>

<p>输出（概念图）：</p>

<pre><code class="bash">loadData completes
result printed
</code></pre>

<p><code>async</code> 的行为类似于 <code>launch</code>，但返回 <code>Deferred</code>。</p>

<p><code>await()</code> 会将其转换为顺序行为——就像 <code>withContext</code> 一样。</p>

<p>关键点：<strong>顺序行为仅在显式等待时发生。</strong></p>

<h2>异常处理行为</h2>

<p><code>withContext</code> 直接在调用协程中抛出异常。它们不会被延迟或存储。</p>

<p><code>launch</code> 将异常报告给其父作用域。如果该作用域有 supervisor 或自定义异常处理程序，则效果不同。异常不会立即中断调用者的执行路径。</p>

<p>这意味着：</p>

<pre><code class="kotlin">withContext(Dispatchers.IO) { error("Boom") }
println("Next")
</code></pre>

<p>崩溃会在“Next”执行之前停止协程。</p>

<p>但使用 <code>launch</code>：</p>

<pre><code class="kotlin">launch(Dispatchers.IO) { error("Boom") }
println("Next")
</code></pre>

<p>“Next”仍然会打印。启动的协程会自行崩溃。</p>

<h2>需要记住的内容</h2>

<ul>
<li><p><code>withContext</code> <strong>等待</strong>代码块执行完毕后才会继续执行。</p></li>
<li><p><code>launch</code> 会启动<strong>并行</strong>工作并立即返回。</p></li>
<li><p>当<strong>结果或顺序</strong>至关重要时，请使用 <code>withContext</code>。</p></li>
<li><p>当你需要<strong>并发工作</strong>且无需阻塞调用者时，请使用 <code>launch</code>。</p></li>
<li><p>视觉上的相似性掩盖了行为上的差异——协程构建器定义了语义，而不是调度器。</p></li>
</ul>


<h2>总结</h2>

<p><code>withContext(Dispatchers.IO)</code> 和 <code>launch(Dispatchers.IO)</code> 看起来相似，但行为却不同。前者会暂停并确保顺序执行，而后者会创建并发并立即继续执行。当工作顺序、共享状态、UI 更新或异常处理依赖于工作完成时间时，这种差异至关重要。</p>

<p>理解这种区别可以使协程代码更易于预测，并避免那些只有在实际应用中才会显现的细微错误。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin互斥锁(Mutex)：协程的线程安全守护神]]></title>
    <link href="https://alexhilton.github.io/blog/2025/10/15/kotlin-mutex/"/>
    <updated>2025-10-15T15:05:51+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/10/15/kotlin-mutex</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Kotlin Mutex: Thread-Safe Concurrency for Coroutines」，原文链接<a href="https://carrion.dev/en/posts/kotlin-mutex-concurrency-guide/">https://carrion.dev/en/posts/kotlin-mutex-concurrency-guide/</a>，由Ignacio Carrión发布于2025年10月3日。</p></blockquote>

<p><a href=""><img src="file:///Users/alexhilton/Downloads/kotlin_mutex.webp" title="auto auto" ></a></p>

<!-- more -->


<p>使用 Kotlin 协程构建并发应用程序时，保护共享的可变状态至关重要。虽然传统的 Java 同步工具（例如 <code>synchronized</code> 块和 <code>ReentrantLock</code>）可以正常工作，但它们会阻塞线程，并且与协程的挂起模型不兼容。因此，引入 <code>Mutex</code>——一个协程友好的同步原语，它提供互斥而不阻塞线程。</p>

<p>本指南探讨了何时使用 Mutex、最佳实践以及它与其他并发控制机制的比较。</p>

<h2>TL;DR：省流版本的建议</h2>

<ul>
<li>当需要保护多个协程访问的共享可变状态时，请使用 <code>Mutex</code>。</li>
<li>在协程代码中，优先使用 <code>Mutex</code> 而不是 <code>synchronized</code>，以避免阻塞线程。</li>
<li>使用 <code>mutex.withLock { }</code> 自动获取和释放锁。</li>
<li>对于更复杂的状态管理场景，请考虑使用 <code>Actor</code> 或 <code>StateFlow</code>。</li>
<li>对于简单的计数器，请改用 <code>AtomicInteger</code> 或 <code>AtomicReference</code>。</li>
<li>如果需要将并发访问限制为多个许可，请使用 <code>Semaphore</code>。</li>
<li>如果不使用 <code>withLock</code>，请始终在 finally 块中释放锁。</li>
</ul>


<h2>什么是互斥锁？</h2>

<p><code>Mutex</code>（互斥）是 <code>kotlinx.coroutines</code> 中的同步原语，用于确保同一时间只有一个协程可以执行临界区。与阻塞线程的传统锁不同，Mutex 会暂停协程，从而使线程可以自由地执行其他工作。</p>

<p>基本结构：</p>

<pre><code class="kotlin">import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock

val mutex = Mutex()

suspend fun protectedOperation() {
    mutex.withLock {
        // Critical section - only one coroutine at a time
        // Modify shared state safely here
    }
}
</code></pre>

<p>关键特性：</p>

<ul>
<li>非阻塞：暂停协程而不是阻塞线程</li>
<li>公平：默认按先进先出顺序授予访问权限</li>
<li>不重入安全：持有锁的协程无法再次获取锁（防止死锁）</li>
<li>轻量级：比线程阻塞锁更高效</li>
</ul>


<h2>互斥锁的核心用例</h2>

<p>最常见的用例——确保对共享变量的安全访问：</p>

<pre><code class="kotlin">class CounterService {
    private var counter = 0
    private val mutex = Mutex()

    suspend fun increment() {
        mutex.withLock {
            counter++
        }
    }

    suspend fun getCount(): Int {
        return mutex.withLock {
            counter
        }
    }
}
</code></pre>

<h3>2. 协调资源访问</h3>

<p>当多个协程需要对某个资源进行独占访问时：</p>

<pre><code class="kotlin">class FileWriter(private val file: File) {
    private val mutex = Mutex()

    suspend fun appendLine(line: String) {
        mutex.withLock {
            file.appendText("$line\n")
        }
    }
}
</code></pre>

<h3>3.确保顺序执行</h3>

<p>即使操作是并发触发的，也必须按顺序执行：</p>

<pre><code class="kotlin">class OrderProcessor {
    private val mutex = Mutex()
    private val orders = mutableListOf&lt;Order&gt;()

    suspend fun processOrder(order: Order) {
        mutex.withLock {
            // Ensure orders are processed sequentially
            orders.add(order)
            validateOrder(order)
            persistOrder(order)
        }
    }
}
</code></pre>

<h3>4. 线程安全的延迟初始化</h3>

<p>在挂起上下文中实现线程安全的延迟初始化：</p>

<pre><code class="kotlin">class DatabaseConnection {
    private var connection: Connection? = null
    private val mutex = Mutex()

    suspend fun getConnection(): Connection {
        if (connection != null) return connection!!

        return mutex.withLock {
            // Double-check inside lock
            connection ?: createConnection().also { connection = it }
        }
    }

    private suspend fun createConnection(): Connection {
        delay(1000) // Simulate connection setup
        return Connection()
    }
}
</code></pre>

<h2>最佳实践</h2>

<h3>1. 始终使用 withLock</h3>

<p>即使发生异常，withLock 也会自动处理锁的获取和释放：</p>

<pre><code class="kotlin">// ✅ Good: Automatic cleanup
mutex.withLock {
    dangerousOperation()
}

// ❌ Bad: Manual management, error-prone
mutex.lock()
try {
    dangerousOperation()
} finally {
    mutex.unlock()
}
</code></pre>

<h3>2. 保持临界区较小</h3>

<p>尽量减少锁的持有时间以减少争用：</p>

<pre><code class="kotlin">// ✅ Good: Lock only for critical section
suspend fun updateUser(userId: String, name: String) {
    val validated = validateName(name) // Outside lock

    mutex.withLock {
        userCache[userId] = validated // Only this needs protection
    }

    notifyObservers(userId) // Outside lock
}

// ❌ Bad: Holding lock during slow operations
suspend fun updateUserSlow(userId: String, name: String) {
    mutex.withLock {
        val validated = validateName(name) // Slow operation inside lock
        userCache[userId] = validated
        notifyObservers(userId) // I/O inside lock
    }
}
</code></pre>

<h3>3. 避免嵌套锁</h3>

<p>互斥锁不可重入。避免两次获取同一个锁：</p>

<pre><code class="kotlin">// ❌ Bad: Deadlock!
suspend fun problematic() {
    mutex.withLock {
        helperFunction() // Tries to acquire mutex again
    }
}

suspend fun helperFunction() {
    mutex.withLock {
        // Will suspend forever
    }
}

// ✅ Good: Restructure to avoid nesting
suspend fun better() {
    mutex.withLock {
        helperFunctionUnsafe() // No lock acquisition
    }
}

fun helperFunctionUnsafe() {
    // Assumes caller holds lock
}
</code></pre>

<h3>4. 优先考虑无锁替代方案</h3>

<p>对于简单操作，原子类型速度更快：</p>

<pre><code class="kotlin">// ✅ Better for simple counters
class AtomicCounter {
    private val counter = AtomicInteger(0)

    fun increment() = counter.incrementAndGet()
    fun get() = counter.get()
}

// ❌ Overkill for a simple counter
class MutexCounter {
    private var counter = 0
    private val mutex = Mutex()

    suspend fun increment() {
        mutex.withLock { counter++ }
    }
}
</code></pre>

<h3>5.文档锁不变量</h3>

<p>明确锁保护的对象：</p>

<pre><code class="kotlin">class UserCache {
    private val mutex = Mutex() // Protects userMap and lastUpdate
    private val userMap = mutableMapOf&lt;String, User&gt;()
    private var lastUpdate = 0L

    suspend fun updateUser(id: String, user: User) {
        mutex.withLock {
            userMap[id] = user
            lastUpdate = System.currentTimeMillis()
        }
    }
}
</code></pre>

<h2>互斥锁 vs. 其他同步方法</h2>

<h3>互斥锁 vs. synchronized</h3>

<pre><code class="kotlin">// Traditional synchronized (blocks thread)
class SynchronizedCounter {
    private var count = 0

    @Synchronized
    fun increment() {
        count++ // Thread blocked while waiting
    }
}

// Mutex (suspends coroutine)
class MutexCounter {
    private var count = 0
    private val mutex = Mutex()

    suspend fun increment() {
        mutex.withLock {
            count++ // Coroutine suspended, thread free
        }
    }
}
</code></pre>

<p><strong>何时该用哪个：</strong></p>

<ul>
<li>对于非暂停代码和旧版 Java 互操作，请使用 <code>synchronized</code></li>
<li>对于暂停函数和基于协程的代码，请使用 <code>Mutex</code></li>
<li>在协程上下文中，<code>Mutex</code> 效率更高，因为线程不会被阻塞</li>
</ul>


<h3>互斥锁 vs. 信号量</h3>

<pre><code class="kotlin">// Mutex: Only one coroutine at a time
val mutex = Mutex()

// Semaphore: N coroutines at a time
val semaphore = Semaphore(permits = 3)

// Example: Rate limiting API calls
class ApiClient {
    private val semaphore = Semaphore(5) // Max 5 concurrent requests

    suspend fun makeRequest(endpoint: String): Response {
        semaphore.withPermit {
            return httpClient.get(endpoint)
        }
    }
}
</code></pre>

<p><strong>何时使用谁：</strong></p>

<ul>
<li>需要独占访问（单次许可）时使用 <code>Mutex</code></li>
<li>需要将并发限制为 N 个操作时使用 <code>Semaphore</code></li>
</ul>


<h3>互斥锁 vs. Actor</h3>

<pre><code class="kotlin">// Mutex: Manual synchronization
class MutexBasedCache {
    private val cache = mutableMapOf&lt;String, Data&gt;()
    private val mutex = Mutex()

    suspend fun get(key: String) = mutex.withLock { cache[key] }
    suspend fun put(key: String, value: Data) = mutex.withLock { cache[key] = value }
}

// Actor: Message-based synchronization
sealed class CacheMessage
data class Get(val key: String, val response: CompletableDeferred&lt;Data?&gt;) : CacheMessage()
data class Put(val key: String, val value: Data) : CacheMessage()

fun CoroutineScope.cacheActor() = actor&lt;CacheMessage&gt; {
    val cache = mutableMapOf&lt;String, Data&gt;()

    for (msg in channel) {
        when (msg) {
            is Get -&gt; msg.response.complete(cache[msg.key])
            is Put -&gt; cache[msg.key] = msg.value
        }
    }
}
</code></pre>

<p><strong>何时使用谁：</strong></p>

<ul>
<li>使用 <code>Mutex</code> 进行直接方法调用的简单同步</li>
<li>对于复杂的状态机或需要消息队列时，使用 <code>Actor</code></li>
<li>Actor 提供更好的封装性，并且可以处理背压</li>
</ul>


<h3>Mutex 与 StateFlow</h3>

<pre><code class="kotlin">// Mutex: Imperative state management
class MutexState {
    private var state = 0
    private val mutex = Mutex()

    suspend fun updateState(transform: (Int) -&gt; Int) {
        mutex.withLock {
            state = transform(state)
        }
    }
}

// StateFlow: Reactive state management
class FlowState {
    private val _state = MutableStateFlow(0)
    val state: StateFlow&lt;Int&gt; = _state.asStateFlow()

    fun updateState(transform: (Int) -&gt; Int) {
        _state.update(transform) // Thread-safe built-in
    }
}
</code></pre>

<p><strong>何时使用哪个：</strong></p>

<ul>
<li>需要自定义同步逻辑时使用 <code>Mutex</code></li>
<li>使用 <code>StateFlow</code> 进行内置线程安全的可观察状态</li>
<li><code>StateFlow</code> 更适合 UI 状态和响应式架构</li>
</ul>


<h3>Mutex 与原子类型</h3>

<pre><code class="kotlin">// AtomicInteger: Lock-free for simple operations
class AtomicCounter {
    private val counter = AtomicInteger(0)

    fun increment() = counter.incrementAndGet()
    fun addAndGet(delta: Int) = counter.addAndGet(delta)
}

// Mutex: For complex operations
class ComplexCounter {
    private var counter = 0
    private var history = mutableListOf&lt;Int&gt;()
    private val mutex = Mutex()

    suspend fun increment() {
        mutex.withLock {
            counter++
            history.add(counter) // Multiple operations
        }
    }
}
</code></pre>

<p><strong>何时使用哪个：</strong></p>

<ul>
<li>使用原子类型进行单变量操作（计数器、标志）</li>
<li>需要协调多个变量时使用 <code>Mutex</code></li>
<li>原子操作速度更快，但受限于特定操作</li>
</ul>


<h2>常见陷阱</h2>

<h3>1. 忘记使用 suspend</h3>

<p>互斥操作需要暂停：</p>

<pre><code class="kotlin">// ❌ Won't compile
fun broken() {
    mutex.withLock { } // Error: suspend function called in non-suspend context
}

// ✅ Correct
suspend fun correct() {
    mutex.withLock { }
}
</code></pre>

<h3>2. 长时间操作期间持有锁</h3>

<pre><code class="kotlin">// ❌ Bad: Holding lock during I/O
suspend fun bad(url: String) {
    mutex.withLock {
        val data = httpClient.get(url) // Network call inside lock
        cache[url] = data
    }
}

// ✅ Good: Fetch outside lock
suspend fun good(url: String) {
    val data = httpClient.get(url)
    mutex.withLock {
        cache[url] = data
    }
}
</code></pre>

<h3>3. 假设可重入</h3>

<pre><code class="kotlin">// ❌ Deadlock: Mutex is not reentrant
suspend fun outer() {
    mutex.withLock {
        inner() // Deadlock!
    }
}

suspend fun inner() {
    mutex.withLock {
        // Never reached
    }
}
</code></pre>

<h3>4. 不处理取消</h3>

<p>持有锁时务必考虑取消：</p>

<pre><code class="kotlin">// ✅ Good: withLock handles cancellation
suspend fun proper() {
    mutex.withLock {
        doWork()
    } // Lock released even on cancellation
}

// ❌ Risky: Manual lock management
suspend fun risky() {
    mutex.lock()
    try {
        doWork() // If cancelled here, lock stays acquired
    } finally {
        mutex.unlock()
    }
}
</code></pre>

<h2>性能考量</h2>

<ul>
<li><strong>互斥 vs. synchronized</strong>：在协程密集型代码中，互斥更高效，因为线程不会被阻塞</li>
<li><strong>争用</strong>：高争用会降低性能；考虑分片（为不同的键设置多个锁）</li>
<li><strong>锁粒度</strong>：更细粒度的锁（更多锁，每个锁保护更少的数据）可减少争用</li>
<li><strong>无锁替代方案</strong>：对于简单操作，原子类型和 <code>StateFlow</code> 速度更快</li>
</ul>


<p>示例：分片以减少争用：</p>

<pre><code class="kotlin">class ShardedCache(private val shardCount: Int = 16) {
    private val mutexes = Array(shardCount) { Mutex() }
    private val caches = Array(shardCount) { mutableMapOf&lt;String, Data&gt;() }

    private fun shardIndex(key: String) = key.hashCode() and (shardCount - 1)

    suspend fun put(key: String, value: Data) {
        val index = shardIndex(key)
        mutexes[index].withLock {
            caches[index][key] = value
        }
    }

    suspend fun get(key: String): Data? {
        val index = shardIndex(key)
        return mutexes[index].withLock {
            caches[index][key]
        }
    }
}
</code></pre>

<h2>真实示例：线程安全的Repository</h2>

<pre><code class="kotlin">class UserRepository(
    private val api: UserApi,
    private val database: UserDatabase
) {
    private val cache = mutableMapOf&lt;String, User&gt;()
    private val mutex = Mutex()

    suspend fun getUser(userId: String): User? {
        // Check cache first (read lock)
        mutex.withLock {
            cache[userId]?.let { return it }
        }

        // Try database (outside lock)
        database.getUser(userId)?.let { user -&gt;
            mutex.withLock {
                cache[userId] = user
            }
            return user
        }

        // Fetch from API (outside lock)
        return try {
            val user = api.fetchUser(userId)
            mutex.withLock {
                cache[userId] = user
                database.insertUser(user)
            }
            user
        } catch (e: Exception) {
            null
        }
    }

    suspend fun updateUser(user: User) {
        mutex.withLock {
            cache[user.id] = user
            database.updateUser(user)
        }
    }

    suspend fun clearCache() {
        mutex.withLock {
            cache.clear()
        }
    }
}
</code></pre>

<h2>测试互斥锁保护的代码</h2>

<pre><code class="kotlin">@Test
fun `concurrent increments should be thread-safe`() = runTest {
    val counter = CounterService()

    // Launch 1000 concurrent increments
    val jobs = List(1000) {
        launch {
            counter.increment()
        }
    }

    jobs.joinAll()

    // Should be exactly 1000
    assertEquals(1000, counter.getCount())
}

@Test
fun `mutex prevents race conditions`() = runTest {
    val cache = mutableMapOf&lt;String, Int&gt;()
    val mutex = Mutex()

    // Simulate race condition
    coroutineScope {
        repeat(100) {
            launch {
                mutex.withLock {
                    val current = cache["key"] ?: 0
                    delay(1) // Simulate work
                    cache["key"] = current + 1
                }
            }
        }
    }

    assertEquals(100, cache["key"])
}
</code></pre>

<h2>总结</h2>

<p><code>Mutex</code> 是一个强大的工具，用于在基于协程的应用程序中保护共享可变状态。它提供线程安全的同步，而不会阻塞线程，使其成为并发协程代码的理想选择。</p>

<p><strong>关键要点</strong>：</p>

<ul>
<li>使用 <code>withLock</code> 进行自动锁管理</li>
<li>保持临界区简洁高效</li>
<li>适当时考虑更简单的替代方案（例如原子操作、StateFlow）</li>
<li>了解何时使用 Mutex 而非其他同步原语</li>
<li>始终妥善处理取消操作</li>
</ul>


<p>记住：最好的同步就是没有同步。尽可能地，设计系统时，通过使用不可变数据结构、消息传递（Actors/Channels）或响应式流（Flow/StateFlow）来完全避免共享可变状态。但是，当你在协程代码中确实需要互斥时，<code>Mutex</code> 是你的最佳选择。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[runBlocking实践：哪里该使用，哪里不该用]]></title>
    <link href="https://alexhilton.github.io/blog/2025/09/23/runblocking-in-practice/"/>
    <updated>2025-09-23T14:34:01+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/09/23/runblocking-in-practice</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「runBlocking in practice: Where it should be used and where not」，原文链接<a href="https://kt.academy/article/run_blocking">https://kt.academy/article/run_blocking</a>，由Marcin Moskała发布于2025年9月1日。</p></blockquote>

<p><a href=""><img src="https://kt.academy/_next/image?url=https%3A%2F%2Fmarcinmoskala.com%2Fkt-academy-articles%2Fpromotion%2Frun_blocking.png&amp;w=3840&amp;q=75" title="auto auto" ></a></p>

<!-- more -->


<p>传统意义上讲，Java 和 Kotlin 项目都基于阻塞调用(blocking)。我所说的阻塞调用是指函数在等待某些操作（例如，等待网络响应）时会阻塞调用者的线程。Kotlin 协程最重要的规则之一是，我们不应该在挂起函数(suspending function)上进行阻塞调用（除非我们使用允许阻塞调用的调度程序，例如 <code>Dispatchers.IO</code>）。</p>

<pre><code class="kotlin">// Incorrect: blocking call in a suspending function
suspend fun getUser(): User {
    val response = api.getUser() // blocking call
    return response.toDomainUser()
}

// Correct: Using withContext(Dispatchers.IO) to make a blocking call in a suspending function
suspend fun getUser(): User = withContext(Dispatchers.IO) {
    val response = api.getUser() // blocking call
    response.toDomainUser()
}
</code></pre>

<p>但是如何反其道而行之呢？如何将挂起调用转换为阻塞调用？为此，我们使用 <code>runBlocking</code>！</p>

<h2><a href="#how-runblocking-works"><code>runBlocking</code> 的工作原理</a></h2>

<p><code>runBlocking</code> 在调用它的线程上启动一个协程，并阻塞该线程直到协程完成。因此，runBlocking 本质上是同步的，因为如果我们多次调用它，第二个调用要等到第一个调用完成后才会启动。作为一个同步协程构建器，<code>runBlocking</code> 返回它启动的协程的结果。</p>

<pre><code class="kotlin">fun main() {
    log("Starting main")
    runBlocking {
        log("Starting first runBlocking")
        delay(1000)
        log("Finishing first runBlocking")
    }
    val result: String = runBlocking {
        log("Starting second runBlocking")
        delay(1000)
        "ABCD"
    }
    log("Second runBlocking finished with result: $result")
}

fun log(message: String) {
    println("[${Thread.currentThread().name}] $message")
}
// [main] Starting main
// [main] Starting first runBlocking
// (1 sec)
// [main] Finishing first runBlocking
// [main] Starting second runBlocking
// (1 sec)
// [main] Second runBlocking finished with result: ABCD
</code></pre>

<p>由于 <code>runBlocking</code> 启动了一个作用域，它会等待其中启动的所有协程完成。这意味着它会等待所有子协程完成。这就是为什么下面的程序要等到所有三个异步协程都完成才会完成。为了展示如何使用 <code>runBlocking</code> 定义结果，我还让这个程序从 <code>main</code> 函数返回 <code>0</code>。</p>

<pre><code class="kotlin">import kotlinx.coroutines.*

fun main(): Int = runBlocking {
    launch { delayAndPrintHello() }
    launch { delayAndPrintHello() }
    launch { delayAndPrintHello() }
    println("Hello")
    0 // result from main
}

suspend fun delayAndPrintHello() {
    delay(1000L)
    println("World!")
}
// Hello
// (1 sec)
// World!
// World!
// World!
</code></pre>

<p><code>runBlocking</code> 的行为可能会让你想起 <code>coroutineScope</code>，这并非巧合，因为它们都启动同步协程，但 <code>runBlocking</code> 是阻塞的，而 <code>coroutineScope</code> 是暂停的。这意味着完全不同的用法，我们只在暂停函数中使用 <code>coroutineScope</code>，而我们永远不应该在暂停函数中使用 <code>runBlocking</code>。这也意味着 <code>coroutineScope</code> 与其调用者建立关系，并且始终处于协程层次结构的中间，而 <code>runBlocking</code> 则启动一个新的协程层次结构。</p>

<h2><a href="#the-practice-of-using-runblocking">使用 <code>runBlocking</code> 的实践</a></h2>

<p>在正确实现的基于协程的项目中，并使用设计良好的协程友好库，我们几乎不需要使用 <code>runBlocking</code>。如果我们在项目中经常使用它，那就被认为是代码异味。然而，在某些情况下，runBlocking 是有用的，甚至是必要的。也有一些情况下，runBlocking 不应该被使用。我们还会讨论那些曾经需要 runBlocking 但现在有了更好的替代方案的情况。现在，让我们来看看。</p>

<h2><a href="#where-to-use-runblocking">在哪里使用 <code>runBlocking</code></a></h2>

<p><code>runBlocking</code> 应该用于需要启动协程并阻塞当前线程直到其完成的情况。这意味着它可以在以下情况下使用：</p>

<ul>
<li>我们需要等待协程的结果。</li>
<li>我们可以阻塞当前线程。</li>
</ul>


<p>一个常见的 Android 示例是在 Retrofit 客户端中设置一个拦截器，将令牌附加到网络调用。获取令牌可能需要发起网络调用，因此我们需要启动一个协程来获取令牌。同时，拦截器需要结果才能继续执行。这个拦截器在 Retrofit 的池中启动，因此可以调用它的调用。这使得它成为使用 <code>runBlocking</code> 的理想场所。</p>

<pre><code class="kotlin">class AddTokenInterceptor: Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val token = runBlocking { getToken() }
        val request = chain.request().newBuilder()
            .addHeader("Authorization", "Bearer $token")
            .build()
        return chain.proceed(request)
    }
}
</code></pre>

<p>在后端系统上，有时我们需要阻塞当前线程以等待协程完成，例如为了让我们的工具正确测量此进程的执行时间，或者当我们需要调用某些阻塞脚本并获取其结果时。</p>

<pre><code class="kotlin">@MeasureExecutionTime
fun runDataMigrationScript() = runBlocking {
    val sourceData = readDataFromSource()
    val transformedData = transformData(sourceData)
    writeDataToTarget(transformedData)
}
</code></pre>

<p>这些情况很少见，大多数后端项目不需要使用 <code>runBlocking</code>。除非它们有一些基于阻塞调用的遗留代码。考虑以下 <code>UserService</code>，它在我们的应用程序中用于管理用户。我们已经将其迁移到暂停调用，但我们仍然有一些基于阻塞调用的遗留控制器和服务。为了避免重写所有这些，我们可以为暂停函数提供阻塞替代方案。这些替代方案可以通过使用 <code>runBlocking</code> 包装暂停函数来实现（你也可以考虑使用一些调度器）。</p>

<pre><code class="kotlin">class UserService(
    private val userRepository: UserRepository,
) {
    suspend fun findUserById(id: String): User = userRepository.findUserById(id)

    // Blocking alternative for legacy parts of our application
    fun findUserByIdBlocking(id: String): User = runBlocking {
        findUserById(id)
    }

    // ...
}
</code></pre>

<p>这可能是 <code>runBlocking</code> 最重要的用途，它充当了从阻塞到暂停的桥梁。一些库为 Java 定义了阻塞替代方案。</p>

<pre><code class="kotlin">suspend fun readDataFromSource(): Data {
    // ...
}

fun readDataFromSourceBlocking(): Data = runBlocking {
    readDataFromSource()
}
</code></pre>

<h2><a href="#where-not-to-use-runblocking">哪些情况下不应使用 <code>runBlocking</code></a></h2>

<p>在某些情况下，不应使用 <code>runBlocking</code>。此外，切勿在挂起函数中直接使用 <code>runBlocking</code>。<code>runBlocking</code> 会阻塞当前线程，因此不应在挂起函数中进行阻塞调用（除非使用允许阻塞调用的调度程序，例如 <code>Dispatchers.IO</code>）。在这种情况下，很可能不需要 <code>runBlocking</code>。</p>

<pre><code class="kotlin">// Incorrect: runBlocking in a suspending function
suspend fun getToken() = runBlocking {
    // ...
}

// runBlocking is most likely not needed
suspend fun getToken() {
    // ...
}
</code></pre>

<p>不应在不需要等待结果的函数中使用 <code>runBlocking</code>。如果你只需要启动协程，通常最好使用 <code>launch</code> 启动异步协程。</p>

<pre><code class="kotlin">// Incorrect: runBlocking used where we do not need to await result
fun startBackgroundProcess() = runBlocking {
    doSomething()
}

// Correct: Using launch to start an asynchronous coroutine
fun startBackgroundProcess() {
    backgroundScope.launch {
        doSomething()
    }
}
</code></pre>

<p>我们还应注意，不要在不应被阻塞的线程上使用 <code>runBlocking</code>。这在 Android 上尤其成问题，因为阻塞主线程会导致应用程序卡死。</p>

<pre><code class="kotlin">// Incorrect: runBlocking on the main thread
fun onClick() = runBlocking {
    userNameView.test = getUserName()
}

// Correct: Using launch to start an asynchronous coroutine
fun onClick() {
    lifecycleScope.launch {
        userNameView.test = getUserName()
    }
}
</code></pre>

<p>在后端，如果我们在 <code>synchronized</code> 块中使用它，可能会出现问题。一个技巧是使用 <code>launch</code> 实现回调函数。但是，通常情况下，最好重新设计代码，使用暂停而不是阻塞调用，并使用协程友好的工具（我们将在<em>同步协程</em>课程中讨论）。</p>

<pre><code class="kotlin">// Possibly incorrect: runBlocking inside synchronized block
synchronized(lock) {
    // ...
    val user = runBlocking { getUser() }
    // ...
}

// One solution: use launch to implement a callback
fun getUser(callback: (User) -&gt; Unit) {
    backgroundScope.launch {
        val user = getUser() // suspending call
        callback(user)
    }
}
synchronized(lock) {
    // ...
    getUser { user -&gt;
        // ...
    }
}
</code></pre>

<h2><a href="#outdated-runblocking-uses">过时的 <code>runBlocking</code> 用法</a></h2>

<p><code>runBlocking</code> 传统上用于包装 <code>main</code> 函数体。它的属性非常适合此目的：它启动一个协程，因此它可以调用挂起函数或启动其他协程，并且它会阻塞线程直到协程完成，因此我们可以确保程序不会在所有这些进程完成之前结束。</p>

<pre><code class="kotlin">fun main(): Unit = runBlocking {
    val user = getUser() // suspending call
    println("User: $user")
}
</code></pre>

<p><code>runBlocking</code> 仍然可以以这种方式使用，但是在大多数现代情况下，我们更喜欢使用 Kotlin 1.3 中引入的挂起 <code>main</code> 函数。此类函数在底层被一个类似于 <code>runBlocking</code> 的阻塞构建器包装。</p>

<pre><code class="kotlin">suspend fun main() {
    val user = getUser() // suspending call
    println("User: $user")
}
</code></pre>

<p>关键区别在于 <code>runBlocking</code> 设置了一个调度器，使其所有子协程在其正在使用的同一线程上运行。挂起 main 函数不会设置调度器，因此其子协程默认在不同的线程上运行。引入此更改是因为 <code>runBlocking</code> 使用的单线程调度器经常导致意外行为。</p>

<pre><code class="kotlin">fun main(): Unit = runBlocking {
    println(Thread.currentThread().name)
    launch {
        println(Thread.currentThread().name)
    }
}
// main
// main
</code></pre>

<pre><code class="kotlin">suspend fun main(): Unit = coroutineScope {
    println(Thread.currentThread().name)
    launch {
        println(Thread.currentThread().name)
    }
}
// main
// DefaultDispatcher-worker-1
</code></pre>

<p><code>runBlocking</code> 的第二个传统用途是在测试中。它被用来包装测试主体，以便我们可以调用挂起函数并在其中启动协程。现在，我们更倾向于使用 <code>kotlinx-coroutines-test</code> 库中的 <code>runTest</code>，它是 <code>runBlocking</code> 的一个更强大、更灵活的替代方案。它允许我们控制时间、生成后台作用域并跟踪子协程上的异常。<code>runTest</code> 将在<em>测试协程</em>课程中讨论。</p>

<pre><code class="kotlin">class UserRepositoryTest {
    val userRepository = InMemoryUserRepository()
    val userService = UserService(userRepository)

    @Test
    fun testGetUser() = runTest { // previously runBlocking
        // given
        userRepository.hasUser(UserEntity("1234", "John Doe"))

        // when
        val user = userService.getUser("1234")

        // then
        assertEquals("John Doe", user.name)
    }
}
</code></pre>

<h2><a href="#%E6%80%BB%E7%BB%93">总结</a></h2>

<ul>
<li><code>runBlocking</code> 是一个阻塞协程构建器，它启动一个协程并阻塞当前线程直到它完成。</li>
<li><code>runBlocking</code> 是从阻塞世界(blocking)到挂起世界(suspending)的桥梁，它用于在需要阻塞当前线程直到协程完成的地方启动协程。</li>
<li>如果你需要在项目中频繁使用 <code>runBlocking</code>，那么它就是一种代码异味。在设计合理的基于协程的项目中，应该尽量少用，或者干脆不用。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[学会说不！让你彻底学会Kotlin Flow的取消机制]]></title>
    <link href="https://alexhilton.github.io/blog/2025/08/08/flow-cancellation/"/>
    <updated>2025-08-08T12:25:21+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/08/08/flow-cancellation</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Cancellable Flows in Kotlin Coroutines: The Complete Guide to Flow Cancellation Techniques」，原文链接<a href="https://proandroiddev.com/cancellable-flows-in-kotlin-coroutines-the-complete-guide-to-flow-cancellation-techniques-8988a85fc158">https://proandroiddev.com/cancellable-flows-in-kotlin-coroutines-the-complete-guide-to-flow-cancellation-techniques-8988a85fc158</a>，由Sahil Thakar发布于2025年7月21日。</p></blockquote>

<p><strong>译者按：</strong> 本文并不是Flow的基础教程，而是专门讲解如何取消flow的，适合对Flow有一定基础的同学。如果对Flow还不够熟悉，可以先行阅读一下之前的文章：</p>

<ul>
<li><a href="https://juejin.cn/post/7336751931375648820">包教包会的Kotlin Flow教程</a></li>
<li><a href="https://juejin.cn/post/7337517508151590947">专家之路上的Flow高级秘籍</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用优雅的姿式应对Kotlin Flow的回压]]></title>
    <link href="https://alexhilton.github.io/blog/2025/07/03/handling-flow-backpress/"/>
    <updated>2025-07-03T14:09:26+00:00</updated>
    <id>https://alexhilton.github.io/blog/2025/07/03/handling-flow-backpress</id>
    <content type="html"><![CDATA[<p>本文译自「How to Manage Backpressure in Kotlin Flow: collect • buffer • conflate • collectLatest」，原文链接<a href="https://proandroiddev.com/how-to-manage-backpressure-in-kotlin-flow-collect-buffer-conflate-collectlatest-b8102284d968">https://proandroiddev.com/how-to-manage-backpressure-in-kotlin-flow-collect-buffer-conflate-collectlatest-b8102284d968</a>，由Shbazhenov发布于2025年6月13日。</p>

<p><a href=""><img src="https://blog.mindorks.com/images/kotlin-flow-banner-image.png" title="auto auto" ></a></p>

<!-- more -->


<p>你是否曾遇到过快速数据源发送的数据量超出应用处理能力的情况，导致应用速度变慢甚至崩溃？Kotlin Flow 内置了一些方法，可让你的生产者和消费者保持同步。本文将介绍：</p>

<ol>
<li>回压的含义</li>
<li>Flow 默认的“互相等待”模式如何工作</li>
<li>何时使用 buffer() 添加小型队列</li>
<li>conflate() 如何跳过旧数据项</li>
<li>为什么 collectLatest { } 会停止旧数据处理</li>
<li>如何根据你的情况选择合适的选项</li>
</ol>


<h2>回压的含义</h2>

<p>回压的作用是确保快速的数据发送方不会压垮较慢的接收方。如果没有回压，你可能会在内存中存储过多的数据，或者浪费时间处理过时的信息。</p>

<p>回压可以帮助你：</p>

<ul>
<li>控制内存使用量</li>
<li>避免不必要的工作</li>
<li>使应用性能更可预测</li>
</ul>


<h2>1. 默认“互相等待”模式</h2>

<p>默认情况下，当你执行以下操作时：</p>

<pre><code class="Kotlin">flow {
  repeat(3) {
    emit(it)
    println("Sent $it")
    delay(100)            // 快速的发送者
  }
}
.collect { value -&gt;
  println("Handling $value")
  delay(300)             // 慢速的处理者
}
</code></pre>

<p>发送方 ( emit ) 将暂停，直到处理方 ( collect ) 处理完最后一个值。没有队列，每个值都是一次发送和处理一个。</p>

<h2>2. 使用 buffer() 添加一个小队列</h2>

<p>如果你希望发送方提前一点，请使用：</p>

<pre><code class="Kotlin">flow { … }
  .buffer(capacity = 2)
  .collect { value -&gt;
    // slow work here
  }
</code></pre>

<ul>
<li>现在，发送者最多可以将 2 个项目放入一个小队列中。</li>
<li>一旦队列满了，它就会再次暂停。</li>
</ul>


<p>这给了你一个有限的队列：你仍然可以处理每个项目，但可以平滑速度峰值。</p>

<h2>3. 使用 conflate() 跳过旧项目</h2>

<p>当你只关心最新数据（例如更新进度条）时，你可以这样写：</p>

<pre><code class="Kotlin">flow { … }
  .conflate()
  .collect { value -&gt;
    println("Update to $value")
    delay(300)
  }
</code></pre>

<ul>
<li>如果处理程序繁忙，则仅保留最新未处理的项目。</li>
<li>较旧的项目将被丢弃，因此你无需处理过时的更新。</li>
</ul>


<p>注意：conflate() 不会停止当前工作；它只是在下次读取时跳过旧值。</p>

<h2>4. 使用 collectLatest { } 停止旧工作</h2>

<p>要进一步操作并在新数据进入时取消任何正在进行的工作，请使用：</p>

<pre><code class="Kotlin">flow { … }
  .collectLatest { value -&gt;
    println("Start $value")
    delay(300)    // 可能会被切断
    println("Done $value")
  }
</code></pre>

<ul>
<li>每次发出（emit）新的数据时，处理前一个值的块都会立即被丢弃。</li>
<li>只有当发送方的发送速度持续超出你的处理能力时，你才需要完成最后一个值的工作。</li>
</ul>


<p>这非常适合边输入边搜索的情况，在这种情况下，你希望在用户再次输入时立即丢弃旧请求。</p>

<h2>5. 选择合适的工具</h2>

<h3>普通 collect</h3>

<ul>
<li>功能：发送方和处理方互相等待，一个接一个</li>
<li>何时选择它：你必须按顺序处理每个项目

<h3>.buffer(n)</h3></li>
<li>功能：大小为 n 的小队列；不丢弃任何项目</li>
<li>何时选择它：你需要少量缓冲，但仍要处理所有项目

<h3>.conflate()</h3></li>
<li>功能：如果处理方繁忙，则仅保留最新项目</li>
<li>何时选择它：你需要最新数据，但仍要完成当前工作

<h3>collectLatest { }</h3></li>
<li>功能：新数据到达后立即取消所有正在进行的工作</li>
<li>何时选择它：只考虑最新的结果；立即放下其他一切

<h2>6. 总结</h2></li>
<li>回压机制可防止快速数据流过载慢速处理器。</li>
<li>默认模式没有队列：安全但速度可能较慢。</li>
<li>buffer() 函数添加了一个小队列：更灵活，不会丢包。</li>
<li>conflate() 函数跳过旧值：始终保持最新，但让当前工作完成。</li>
<li>collectLatest { } 函数停止旧工作：仅完成最新项。</li>
</ul>


<p>下次你的 Flow 感觉太快或太慢时，请问自己：</p>

<ol>
<li>我需要处理每个值吗？</li>
<li>小型队列有帮助吗？</li>
<li>只有最新数据才重要吗？</li>
<li>当新数据到达时，我应该取消旧工作吗？</li>
</ol>


<p>选择最合适的简单选项，Kotlin Flow 会处理余下的事情。</p>
]]></content>
  </entry>
  
</feed>
