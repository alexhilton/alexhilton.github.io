<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Kotlin | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/kotlin/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2024-01-25T21:04:58+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Kotlin进阶之协程从上车到起飞]]></title>
    <link href="http://toughcoder.net/blog/2024/01/14/kotlin-coroutines-an-advanced-guide/"/>
    <updated>2024-01-14T21:17:20+08:00</updated>
    <id>http://toughcoder.net/blog/2024/01/14/kotlin-coroutines-an-advanced-guide</id>
    <content type="html"><![CDATA[<p>通过<a href="http://toughcoder.net/blog/2024/01/11/kotlin-coroutine-made-easy/">前面的一篇文章</a>我们理解了协程的基本概念，学会协程的基本使用方法，算是正式入门了，接下来就是要深入的学习技术细节和高级使用方法，以期完全掌握Kotlin协程并能熟练的正确的使用协程，发挥出协程应有的并发编程能力。</p>

<p><a href=""><img src="https://repository-images.githubusercontent.com/61722736/08e87280-62dc-11ea-8fed-a8a4a4ea865d" title="auto auto" ></a></p>

<!-- more -->


<p>本篇为协程三步曲中的第二篇：</p>

<ul>
<li>初级篇：<a href="http://toughcoder.net/blog/2024/01/11/kotlin-coroutine-made-easy/">Kotlin进阶之协程从入门到放弃</a></li>
<li>高级篇：<a href="http://toughcoder.net/blog/2024/01/14/kotlin-coroutines-an-advanced-guide/">Kotlin进阶之协程从上车到起飞</a></li>
<li>终极篇：<a href="http://toughcoder.net/blog/2023/01/27/understanding-coroutines/">Kotlin进阶之协程从专家到出家</a></li>
</ul>


<p>本篇将细致的讨论协程中的一些重要的话题，以期更好的理解协程的原理和正确的使用协程，将从协程运行的上下文开始。</p>

<h2>深究协程上下文</h2>

<p><img src="https://files.betamax.kodeco.com/attachments/videos/3493/c049283d-193b-43b9-b796-0aafe8e9c804.png" alt="" /></p>

<p>创建协程的方法launch/async一共<strong>有3个参数</strong>，除了最后一个是协程的代码块以外，另外两个参数都是用来<strong>控制协程</strong>的，如协程上下文是用以控制协程运行环境的，包括在什么线程中去运行，句柄和树形关系以及何时切换线程，通过传递给launch/async的参数CoroutineContext。以及CoroutineStart就可以控制协程的运行。</p>

<pre><code class="Kotlin">fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -&gt; Unit
): Job

fun &lt;T&gt; CoroutineScope.async(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -&gt; T
): Deferred&lt;T&gt;
</code></pre>

<p>首先我们来看一下协程上下文对象CoroutineContext。</p>

<h3>CoroutineContext</h3>

<p><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/">CoroutineContext</a>是一个集合，具体元素类型是<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/-element/">Element</a>，Element重载了操作符，可以通过<strong>&#43;</strong>来形成集合。CoroutineContext是类似于Map的，每个Element有自己的Key，这是为了保证每个CoroutineContext对象中每个Key只能有一个Element对象。可以把CoroutineContext看成是Map，因此可以使用<strong>[]</strong>来获取Key对应的Element，如取Job，可以用context[Job]，取名字时可以用context[CoroutineName]等。</p>

<p>具体Element有四种：</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/">Job</a>：协程的句柄，或者说唯一标识，用以具体控制每个协程的（cancel和join等），具有树形关系</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/">CoroutineDispatcher</a>：用以指定协程的运行线程</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-name/">CoroutineName</a>：给协程取个名字，方便调试</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/">CoroutineExceptionHandler</a>：指定协程的异常处理器，用以处理未被捕获的异常</li>
</ul>


<p>这里主要介绍一下Job，CoroutineDispatcher和Name，至于ExceptionHandler留到后面讲异常处理时再细讲。</p>

<h4><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/">Job</a></h4>

<p>用launch创建一个协程时也会返回一个Job对象，它就是新创建的协程的句柄，但更好的方式是通过launch的参数，在上下文中指定一个Job对象作为协程的句柄。前面了讲过了，Job用以控制协程的，更为重要的是它能维持树形关系，父协程是可以控制子协程的，像cancel是会传导到所有的子协程的。自己创建Job对象就可以自由指定父协程，而不是默认的从CoroutineScope中继承。</p>

<p>另外，Job也会影响Exception handling，会在后面异常处理部分详细的讲。</p>

<h4><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/">CoroutineDispatcher</a></h4>

<p>这个是在平时用的最多的，因为协程是一种并发编程范式，而要想真并发，必然要涉及线程的切换，不可能指望着主线程把所有的事情都干了，而Dispatcher的作用就是用于主动的指定协程的运行线程。与Java中的Executor，和RxJava中的Schedulers作用是一样的。有一些预定义好的Dispatcher可以用，它们定义在<a href="">Dispatchers</a>里面：</p>

<ul>
<li><a href="">Main</a> 主线程，主函数所在的主线程，以及像UI框架（如Swing和Android）等的UI线程（主线程）</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/">IO</a> 适合I/O密集型的协程，如网络操作（上传/下载），文件读写，数据库读写等等。它背后是线程池，线程的数量是比较多的。因为<strong>I/O虽然耗时，但一般都耗在等待</strong>上面，所以线程的数量可以多一些。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html">Default</a> 适合CPU密集型的协程，比如计算类型的，图形的计算，矩阵计算，多媒体文件的编解码，压缩解压缩，或者算法时间复杂度较高的任务等等。也是线程池，线程的数量一般是CPU的核数。这个线程池的数量很少，因为<strong>这是CPU密集型的任务，需要大量占用着CPU，使CPU一直处于忙碌状态，因此线程数量即使多了，也是没有用处的，因为多创建的线程根本得不到操作系统的调试，没有多余的CPU给线程跑。</strong></li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html">Unconfied</a> 未给协程指定线程，协程会在当前的线程中执行（也就是调用者的线程），直到协程被挂起(suspended)。挂起后再继续(resume)时，由在恢复的线程中继续执行。很混乱吧，是的并发虽然讲究效率，虽然线程/协程啥时候进行，挂起并不能直接完全控制，但是我们仍希望并发要有秩序和确定性。一定要为新创建的协程指定其线程运行环境，因此，<strong>Unconfined不应该被使用</strong>。</li>
</ul>


<p>一般情况下，框架预定义好了的这些dispatcher已经够用了。但如果真的不够用，也可以自定义dispatcher，用扩展函数<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/as-coroutine-dispatcher.html">asCoroutineDispatcher</a>可以非常方便的把Java中的线程池Executors转化为dispatcher：</p>

<pre><code class="Kotlin">val dispatcher = Executors.newSingleThreadExecutor().asCoroutineDispatcher
launch(dispatcher) {
    delay(1000)
    println("Single thread dispatcher")
}
</code></pre>

<h4>CoroutineName</h4>

<p><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-name/">CoroutineName</a>是比较简单的结构，的构造方法可以传一个字符串用以指定协程的名字。协程的名字只有调试的意义，对于代码的运行没有任何影响。比如在调试的时候，或者在性能分析Profiling的时候，可以用名字更加方便的区分不同的协程，进而缩小调试的范围。</p>

<h3>CoroutineStart</h3>

<p><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/">CoroutineStart</a>，是一个枚举类型，用以控制协程的启动方式，具体有四种模式类型：</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-d-e-f-a-u-l-t/">DEFAULT</a> 默认，如果未指定这个参数 时也是默认模式，根据指定的上下文环境，立即调度此协程</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-l-a-z-y/">LAZY</a> 只有当需要此协程时才调度它。比较有意思，具体啥是<strong>需要</strong>呢，也就是当await其结果时，或者需要此协程去<strong>生产事件(produce)</strong>或者<strong>消费事件(consume)</strong>时。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-a-t-o-m-i-c/">ATOMIC</a> 以原子化的方式来调度此协程，也就是以不可取消的方式来调度协程。也就是说在协程代码块执行之前是不可取消的。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-u-n-d-i-s-p-a-t-c-h-e-d/">UNDISPATCHED</a> 在当前的线程环境（也就是调用者的线程）中立即执行协程直到协程的第一个挂起点。挂起之后，继续时则在指定的上下文中的线程运行。</li>
</ul>


<p>一般情况下，我们用默认的就行了。但当熟悉了协程以后，在适当的场景使用不同的启动方式参数可以更大限度的发挥协程的威力。</p>

<p>延展阅读：</p>

<ul>
<li><a href="https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html">Coroutine context and dispatchers</a></li>
<li><a href="https://juejin.cn/post/6926695962354122765">揭秘kotlin协程中的CoroutineContext</a></li>
<li><a href="https://juejin.cn/post/7270899168532152381">深入Kotlin协程系列|图解上下文</a></li>
<li><a href="https://juejin.cn/post/7137927889835524126">协程是怎么切换线程的</a></li>
</ul>


<h2>启动，挂起，让度和延续</h2>

<p>知道了如何创建协程，以及如何通过参数指定它运行的上下文和影响启动的参数后，就需要详细的了解一下协程的几中运行状态，以及什么是挂起，如何让度再到咋回到延续。</p>

<h3>协程的状态</h3>

<p>与Java中的线程类似，协程也是有几种不同的状态的，可以参考下表：</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 协程状态 </th>
<th style="text-align:left;"> 描述 </th>
<th style="text-align:center;"> isActive </th>
<th style="text-align:center;"> isCompleted </th>
<th style="text-align:center;"> isCancelled </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> New </td>
<td style="text-align:left;"> 协程刚被创建，但还未被调度，未运行 </td>
<td style="text-align:center;"> false </td>
<td style="text-align:center;"> false </td>
<td style="text-align:center;"> false </td>
</tr>
<tr>
<td style="text-align:center;"> Active </td>
<td style="text-align:left;"> 已被调度，已运行 </td>
<td style="text-align:center;"> true </td>
<td style="text-align:center;"> false </td>
<td style="text-align:center;"> false </td>
</tr>
<tr>
<td style="text-align:center;"> Completing </td>
<td style="text-align:left;"> 等待子协程结束中 </td>
<td style="text-align:center;"> true </td>
<td style="text-align:center;"> false </td>
<td style="text-align:center;"> false </td>
</tr>
<tr>
<td style="text-align:center;"> Cancelling </td>
<td style="text-align:left;"> cancel子协程中 </td>
<td style="text-align:center;"> false </td>
<td style="text-align:center;"> false </td>
<td style="text-align:center;"> true </td>
</tr>
<tr>
<td style="text-align:center;"> Cancelled </td>
<td style="text-align:left;"> 已被取消，是最终状态 </td>
<td style="text-align:center;"> false </td>
<td style="text-align:center;"> true </td>
<td style="text-align:center;"> true </td>
</tr>
<tr>
<td style="text-align:center;"> Completed </td>
<td style="text-align:left;"> 已结束，是最终状态 </td>
<td style="text-align:center;"> false </td>
<td style="text-align:center;"> true </td>
<td style="text-align:center;"> false </td>
</tr>
</tbody>
</table>


<p>需要注意，这些状态是由<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/">接口Job</a>来定义的，它是一个广义上的异步并发任务，协程是它的一个实现而已，协程返回的也是对象Job，可以通过Job的方法如join，cancel，isActive等方法来控制协程和查询状态。协程的状态转移可以看这张图：</p>

<p><img src="https://assets.alexandria.raywenderlich.com/books/kco/images/7116dd4d1cf7d079a1ece92d888198c4fdcd6cced5bc408119700a236409fdbd/original.png" alt="" /></p>

<h3>协程的挂起，让度和延续</h3>

<p>用suspend修饰的函数必须在协程里调用，因为它们在运行的时候可以让协程挂起，协程遇到<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html">delay</a>或者<a href="">join</a>以及<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/await.html">await/awaitAll</a>时就会被挂起。除此之外，还可以调用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html">yield</a>主动进行挂起，这会释放线程，让其他协程得以运行，这便是<strong>让度</strong>。挂起，是可能导致线程切换的，这取决 于我们如何设置协程的上下文以及start参数。</p>

<p>那么，Kotlin中的协程是如何做到协程延续(resume)时，协程的运行状态和本地变量等是如何得以在线程之间保存和传播的呢？这就涉及到了<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-continuation/">Continuation</a>，在挂起的时候会创建一个Continuation对象，它把恢复协程所需要的数据都会打包起来，延续运行的的时候只需要调用Continuation#resume就可以了。一般情况下，我们不需要了解Conitnuation的创建过程，因为这过于底层了，Kotlin的编译器会帮我们做好一切。</p>

<p><img src="https://doordash.engineering/wp-content/uploads/2021/11/coroutine-11-1-1024x484.jpg" alt="" /></p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://juejin.cn/post/7288606110336401467">一文搞懂 Kotlin Coroutine Job 的工作流程</a></li>
<li><a href="https://juejin.cn/post/7304615395741351988">详解Kotlin协程实现原理</a></li>
<li><a href="https://juejin.cn/post/7312404578958934054">源解 Kotlin 协程</a></li>
</ul>


<h2>无限序列</h2>

<p>在继续深入学习其他话题之前先来看一个实际的妙用协程的例子，使用协程创建异步无限序列。<a href="https://kotlinlang.org/docs/constructing-collections.html">集合(Collections)</a>是对象的容器，用来存储对象实例（objects）的，把对象放入到集合中，也就是说在『放入』的过程中时，元素必须已经创建好了。而<a href="https://kotlinlang.org/docs/sequences.html">序列(Sequences)</a>并不存储对象实例，它按需生成对象，也就是说只有需要某个元素时，序列才会生成它，并且序列可以有无限个元素，它是按需生成元素，如果需要可以有无限发子弹。</p>

<p>序列是按需生成元素，因此它具有延迟化，占用资源少的特点。对于用<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/sequence.html">sequence builder</a>来创建无限序列时，其实就用到了协程，比如说创建一个质数的序列：</p>

<pre><code class="Kotlin">fun primes(start: Int): Sequence&lt;Int&gt; = sequence {
    println("Infinite prime sequence:")
    var n = start
    while (true) {
        if (n &gt; 1 &amp;&amp; (2 until n).none { i -&gt; n % i == 0 }) {
            yield(n)
            println("\tGenerating next prime after $n")
        }
        n++
    }
}

fun main() {
    for (prime in primes(start = 10)) {
        println("Received $prime")
        if (prime &gt; 30) {
            break
        }
    }
}
</code></pre>

<p>这段代码的输出是：</p>

<pre><code class="Bash">Infinite prime sequence:
Received 11
    Generating next prime after 11
Received 13
    Generating next prime after 13
Received 17
    Generating next prime after 17
Received 19
    Generating next prime after 19
Received 23
    Generating next prime after 23
Received 29
    Generating next prime after 29
Received 31
</code></pre>

<p>序列生成器之所以能够一个一个的生成元素，并返回给调用者的原因就是在于<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence-scope/yield.html">yield()</a>函数，它是一个suspend函数，执行后就会挂起，然后调用者的代码得以继续执行。如果没有把sequence生成器挂起的话，它会陷入死循环。我们可以详细的看一眼sequence的签名：</p>

<pre><code class="Kotlin">fun &lt;T&gt; sequence(
    block: suspend SequenceScope&lt;T&gt;.() -&gt; Unit
): Sequence&lt;T&gt;
</code></pre>

<p>可以发现sequence builder的参数是一个运行在SequenceScope中的挂起函数，内部一定是会创建一个协程来运行此代码块。并且，我们在此代码块中一定要让协程挂起，否则可能会陷入死循环。</p>

<p>拓展阅读 <a href="https://kt.academy/article/cc-sequence">Sequence builders in Kotlin Coroutines</a>。</p>

<h2>协程取消</h2>

<p>创建协程能得到协程的句柄即Job对象，可以用来控制协程，最重要的一个操作就是取消协程，通过<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/cancel.html">cancel</a>方法，目的是终止协程的运行。我们先来看一个示例：</p>

<pre><code class="Kotlin">val job = launch {
    repeat(1000) { i -&gt;
        println("job: I'm sleeping $i ...")
        delay(500L)
    }
}
delay(1300L) // delay a bit
println("main: I'm tired of waiting!")
job.cancel() // cancels the job
job.join() // waits for job's completion 
println("main: Now I can quit.")
</code></pre>

<p>输出如下：</p>

<pre><code class="Kotlin">job: I'm sleeping 0 ...
job: I'm sleeping 1 ...
job: I'm sleeping 2 ...
main: I'm tired of waiting!
main: Now I can quit.
</code></pre>

<h3>协程取消的特性</h3>

<p>协程只有<strong>处于挂起状态时才能被取消</strong>，这个可以看上面Job的状态表格。父协程被取消，它同时也会取消所有的子协程，并且父协程只有在所有子协程退出后才会退出，这种树形管理关系是结构化并发的基础。另外就是，为了更好的<strong>实现可取消性</strong>，在协程内部要在关键的地方检查<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/is-active.html">isActive</a>，比如循环时，或者做一些耗时操作时，以及时响应cancel。</p>

<p>为了更全面的响应取消操作，也要捕获<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/">CancellationException</a>，并在finally中清理占用的资源，这是因为对于挂起的库函数，当被cancel时会抛出CancellationException。如果有Java的并发经验的同学可以发现，这跟取消Thread是一样的（即interrupt一个Thread）。</p>

<h3>不可取消协程</h3>

<p>有时候可能希望协程不被取消，也就是不能被取消，因为可能在执行一些关键的初始化工作，不可被打断和取消，这时可以用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-non-cancellable/">withContext(NonCancellable) { &hellip; }</a>来作为协程的上下文环境，这坨代码块就不可被取消了，只有执行完才会返回，任外部如何cancel都没用：</p>

<pre><code class="Kotlin">val job = launch {
    try {
        repeat(1000) { i -&gt;
            println("job: I'm sleeping $i ...")
            delay(500L)
        }
    } finally {
        withContext(NonCancellable) {
            println("job: I'm running finally")
            delay(1000L)
            println("job: And I've just delayed for 1 sec because I'm non-cancellable")
        }
    }
}
delay(1300L) // delay a bit
println("main: I'm tired of waiting!")
job.cancelAndJoin() // cancels the job and waits for its completion
println("main: Now I can quit.")
</code></pre>

<p>这段代码非常有意思，父协程启动了子协程后就取消它，子协程中的try代码块会被取消，repeat不会执行完，但它的finally代码块是不可以取消的，一定要执行完子协程才能返回。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/cancellation-and-timeouts.html">Cancellation and timeouts</a>。</p>

<h2>超时处理</h2>

<p>对于异步和并发编程来说，<strong>超时处理</strong>是非常关键的，虽然异步地或者并发地去执行任务，但对于主线程来说不可能永远等待任务，比如请求网络时，如果在网络库未设置连接超时，那么主线程或者说主协程就有可能面临无限等待。一般的做法是把问题丢给用户，用户受不了了，不想等了，那就返回或者退出，返回或者退出自然会去cancel掉所有的异步任务，无论是协程还是线程。</p>

<p>但是，更为优雅的方式是对于每一个启动的异步任务，都主动的设置一个超时时间，在给定的时间内任务仍未结束，那就取消它，终止它。这样整体的并发会更加的有秩序和可控，当然了，取消随时仍可能发生，超时时间未到时，仍是可以主动取消的。</p>

<p>在Kotlin中，给协程加上超时时限非常的方便，用扩展函数<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html">withTimeout(limit) {&hellip;}</a>就可以非常方便的给代码块加上超时时限，当超时时限达到时，如果协程仍未返回，会终止协程并抛出异常<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html">TimeoutCancellationException</a>。</p>

<pre><code class="Kotlin">withTimeout(1300L) {
    repeat(1000) { i -&gt;
        println("I'm sleeping $i ...")
        delay(500L)
    }
}
//I'm sleeping 0 ...
//I'm sleeping 1 ...
//I'm sleeping 2 ...
//Exception in thread "main" kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1300 ms
</code></pre>

<p>扩展阅读 <a href="https://juejin.cn/post/7250085815431020605">探索 Kotlin 协程 withTimeout 原理</a>。</p>

<h2>异常处理</h2>

<p>程序运行总会遇到异常情况，至少有一半的代码都是在处理各种异常情况。协程就是以异常的方式运行一坨代码块，这些代码块自然也可能会抛出异常，这时要如何处理呢？有同学举手了，好办啊，try-catch不就行了？这位同学先坐下，对于同步的代码是可行的，但对于异步代码并不总是可行。并发编程中的异常处理略微稍复杂一些，我们来详细的看看协程中的异常处理方法。</p>

<h3>协程中异常的传播</h3>

<p>对于同步代码来说，在外面调用层包裹try-catch总是管用的，比如说：</p>

<pre><code class="Kotlin">fun boo() {
    try {
        // do some sync works that may throw exceptions
    } catch (e: Exception) {
        println("Got you, no where to run!!!")
    }
}
</code></pre>

<p>但对于异步代码，这不管用，比如说想在协程外面try-catch异常，是行不通的：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    try {
        val job = launch(Dispatchers.Default + SupervisorJob()) {
            println("Ready to run!")
            delay(400)
            throw Exception("You will never catch me, hahaha!")
        }
        job.join()
    } catch (e: Exception) {
        println("Try to handle everything: ${e.message}")
    }
}
//Ready to run!
//Exception in thread "DefaultDispatcher-worker-1" java.lang.Exception: You will never catch me, hahaha!
</code></pre>

<p>协程中抛出了异常，但外层并没有能catch住，这段代码会crash。我们再看看async的情况：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    try {
        val deferred = async(Dispatchers.Default + SupervisorJob()) {
            println("Ready to run!")
            delay(400)
            throw Exception("You will never catch me, hahaha!")
        }
        deferred.await()
    } catch (e: Exception) {
        println("No where to run: ${e.message}")
    }
}
//Ready to run!
//No where to run: You will never catch me, hahaha!
</code></pre>

<p>这回外层的catch是生效的，能把协程中的异常捕获住！到此，我们可以总结一下协程中的异常的传播：<strong>launch创建的协程异常是不可在外面捕获的，而async则可以</strong>。</p>

<p><strong>注意：</strong>无论是launch还是async，如果父协程不去join或者await等待子协程的话，则是死活都无法捕获到子协程的异常的，因为协程是异步的，launch/async很快就返回了，会立马执行它后面的语句，所以，当协程运行时，外面的代码（即launch/async后面的语句）可能已执行完了，自然是不可能捕获到任何异常的，可以通过把上面两个例子中的join和await去掉，然后运行试试看，都会crash。</p>

<p>那么，要想处理协程中的异常，一是让协程自己去try-catch，另外就是使用CoroutineContext的另一个Element，叫作CoroutineExceptionHandler。</p>

<h3>未捕获异常处理器CoroutineExceptionHandler</h3>

<p>如果协程内部出现了未捕获的异常(uncaught exceptions)时，会先看协程上下文中有没有指定未捕获异常处理器(uncaught exception handler)，如果没有则会按前面说的方式再传播。在指定协程上下文时可以用一个<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/">CoroutineExceptionHandler</a>对象来当作uncaught excpetion handler，以处理未捕获异常：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    val handler = CoroutineExceptionHandler { _, exception -&gt;
        println("Totally under control: ${exception.message}")
    }

    val job1 = launch(Dispatchers.Default + SupervisorJob() + handler) {
        delay(200)
        throw Exception("Exploded!!!")
    }

    val job2 = launch(Dispatchers.Default + SupervisorJob() + handler) {
        delay(800)
        throw Exception("Can I run away???")
    }

    val deferred = async(Dispatchers.Default + SupervisorJob() + handler) {
        delay(400)
        throw Exception("You will never catch me, hahaha!")
    }

    joinAll(job1, job2, deferred)
}
//Totally under control: Exploded!!!
//Totally under control: Can I run away???
</code></pre>

<p>可以发现通过给launch指定CoroutineExceptionHandler可以捕获其uncaught excpetions。但是注意看async创建的协程似乎没效果，这是因为async本来就会把异常传播给其父协程，不会给CoroutineExceptionHandler处理，所以对于async来说指定了handler也是没有效果的，会<strong>被async忽略掉</strong>。</p>

<p>还需要注意的是，只有根协程（root coroutine）的上下文中的CoroutineExceptionHandler是有效的，被用于处理uncaught exceptions。协程是有树形关系的，一个协程出现未捕获异常(uncaught exception)时，它会把它丢给它的父协程处理，一层一层的传播直到根协程（root coroutine），如果根协程的上下文环境中有handler，那就用它来处理，否则就crash。换句话说，只有最外层的协程(root coroutine)设置一个handler给其context就够了，其他的子协程即使设置了handler也是没有用处的。</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    val handler = CoroutineExceptionHandler { _, exception -&gt;
        println("Totally under control: ${exception.message}")
    }

    val job1 = launch(Dispatchers.Default + SupervisorJob() + handler) {
        val subHandler = CoroutineExceptionHandler { _, exp -&gt;
            println("Try to intercept exceptions: ${exp.message}")
        }
        val subJob = launch(Dispatchers.Default + subHandler) {
            val grandJob = launch(Dispatchers.Default + subHandler) {
                throw Exception("Bad thing happened deep down!")
            }
            grandJob.join()
        }
        subJob.join()
    }

    val job2 = launch(Dispatchers.Default + SupervisorJob() + handler) {
        delay(800)
        throw Exception("Can I run away???")
    }

    joinAll(job1, job2)
}
//Totally under control: Bad thing happened deep down!
//Totally under control: Can I run away???
</code></pre>

<p>是的，聪明的你一定发现了，这里的规则其实与Java中的<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler">Thread.UncaughtExceptionHandler</a>)是一样一样的，它也是只需要有一个所以用<strong>static</strong>成员就可以了。</p>

<h3>链式反应</h3>

<p>当协程发生未捕获异常(uncaught exceptions)而被动终止时，它自己肯定是会被终止的，这个异常会沿树形向上传给它的父协程，其父协程也会被终止(cancle)，由于结构化并发，父协程被cancel时，会cancel其所有的子协程。就像<strong>链式反应</strong>一样，在未经特殊处理情况下，一旦<strong>子协程发生异常</strong>，就会导致其所在的<strong>树形结构的所有协程被终止</strong>，可以通过一个示例来验证一下：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    val handler = CoroutineExceptionHandler { _, exception -&gt;
        println("Totally under control: ${exception.message}")
    }

    val root = launch(Dispatchers.Default + SupervisorJob() + handler) {
        val subJob1 = launch {
            val grandJob = launch {
                delay(100)
                throw Exception("Bad thing happened from deep down!")
            }
            grandJob.join()
            println("Sub coroutine #1 completed")
        }

        val subJob2 = launch {
            try {
                delay(60 * 1000)
            } finally {
                println("Sub coroutine #2 cancelled!!")
            }
        }

        val subJob3 = launch {
            try {
                delay(60 * 1000)
            } finally {
                println("Sub coroutine #3 cancelled!!!")
            }
        }

        val subJob4 = launch {
            try {
                delay(60 * 1000)
            } finally {
                println("Sub coroutine #4 cancelled!!!!")
            }
        }

        joinAll(subJob1, subJob2, subJob3, subJob4)
    }

    root.join()
}
//Sub coroutine #2 cancelled!!
//Sub coroutine #4 cancelled!!!!
//Sub coroutine #3 cancelled!!!
//Totally under control: Bad thing happened from deep down!
</code></pre>

<p>其他几个子协程subJob2，subJob3和subJob4都在工作中，但被grandJob的未捕获异常给终止掉了。另外，我们还可以发现这个异常是在根协程(root)里面的Uncaught exception handler中处理了，同时还可以发现，异常处理handler是在所有子协程被终止结束后才得以处理。再来看一个来自官方教程上面的例子：</p>

<pre><code class="Kotlin">val handler = CoroutineExceptionHandler { _, exception -&gt; 
    println("CoroutineExceptionHandler got $exception") 
}
val job = GlobalScope.launch(handler) {
    launch { // the first child
        try {
            delay(Long.MAX_VALUE)
        } finally {
            withContext(NonCancellable) {
                println("Children are cancelled, but exception is not handled until all children terminate")
                delay(100)
                println("The first child finished its non cancellable block")
            }
        }
    }
    launch { // the second child
        delay(10)
        println("Second child throws an exception")
        throw ArithmeticException()
    }
}
job.join()
//Second child throws an exception
//Children are cancelled, but exception is not handled until all children terminate
//The first child finished its non cancellable block
//CoroutineExceptionHandler got java.lang.ArithmeticException
</code></pre>

<p>这个例子非常的有意思，用到了好几个特性，先是第二个子协程发生了未捕获异常(ArithmeticException)，导致其父协程job被取消，但job还有其他子协程，所以还会去cancel仍在运行中的子协程，这个子协程被取消了，它正在delay，这时cancel它会抛CancellationException而终止delay，进入finally，finally中有一个不可以被打断的任务。而只有当所有子协程都终止完成了，job的handler才得以处理这个异常(ArithmeticException)。</p>

<h3>监管责任(Supervision)</h3>

<p>链式反应，异常会在树形关系中传递导致整个树形协程都被终止，这样设计的目的在于结构化并发，它能让整体结构的行为较一致，形成一个整体结构。很多时候这并不是想要的行为，比如说启动四个协程去服务器取四段数据，然后拼成一个整体使用，即使某段异常了，取不到，也没有必须把整体都取消掉。</p>

<p>可以给父协程加上监管责任，这样当其某一个子协程失败了，它会履行监管责任，保障其他子协程仍能运行，可以用一个例子来看一下：</p>

<pre><code class="Kotlin">val supervisor = SupervisorJob()
with(CoroutineScope(coroutineContext + supervisor)) {
    // launch the first child -- its exception is ignored for this example (don't do this in practice!)
    val firstChild = launch(CoroutineExceptionHandler { _, _ -&gt;  }) {
        println("The first child is failing")
        throw AssertionError("The first child is cancelled")
    }
    // launch the second child
    val secondChild = launch {
        firstChild.join()
        // Cancellation of the first child is not propagated to the second child
        println("The first child is cancelled: ${firstChild.isCancelled}, but the second one is still active")
        try {
            delay(Long.MAX_VALUE)
        } finally {
            // But cancellation of the supervisor is propagated
            println("The second child is cancelled because the supervisor was cancelled")
        }
    }
    // wait until the first child fails &amp; completes
    firstChild.join()
    println("Cancelling the supervisor")
    supervisor.cancel()
    secondChild.join()
}
//The first child is failing//The first child is cancelled: true, but the second one is still active//Cancelling the supervisor//The second child is cancelled because the supervisor was cancelled
</code></pre>

<p>有两种方式加上监管责任，一种是在协程上下文时指定一个<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-supervisor-job.html">SupervisorJob</a>对象，比如前面那个例子，可以这样修改：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    val handler = CoroutineExceptionHandler { _, exception -&gt;
        println("Totally under control: ${exception.message}")
    }

    val root = launch(Dispatchers.Default + SupervisorJob() + handler) {
        val subJob1 = launch {
            val grandJob = launch(SupervisorJob()) {
                delay(100)
                throw Exception("Bad thing happened from deep down!")
            }
            grandJob.join()
            println("Sub coroutine #1 completed")
        }

        val subJob2 = launch {
            try {
                delay(10 * 1000)
            } finally {
                println("Sub coroutine #2 cancelled!!")
            }
        }

        val subJob3 = launch {
            try {
                delay(20 * 1000)
            } finally {
                println("Sub coroutine #3 cancelled!!!")
            }
        }

        val subJob4 = launch {
            try {
                delay(30 * 1000)
            } finally {
                println("Sub coroutine #4 cancelled!!!!")
            }
        }

        joinAll(subJob1, subJob2, subJob3, subJob4)
    }

    root.join()
}
//Totally under control: Bad thing happened from deep down!
//Sub coroutine #1 completed
//Sub coroutine #2 cancelled!!
//Sub coroutine #3 cancelled!!!
//Sub coroutine #4 cancelled!!!!
</code></pre>

<p>除了单独的为每个协程上下文指定SupervisorJob以外，还有更为优雅的方式就是在合适的层级使用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html">扩展函数superivorScope</a>来创建一个scope，我们用此方法改造另一 个例子：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    val handler = CoroutineExceptionHandler { _, exception -&gt;
        println("CoroutineExceptionHandler got $exception")
    }
    val job = GlobalScope.launch(handler) {
        supervisorScope {
            launch { // the first child
                try {
                    delay(10 * 1000)
                } finally {
                    withContext(NonCancellable) {
                        println("Children are cancelled, but exception is not handled until all children terminate")
                        delay(100)
                        println("The first child finished its non cancellable block")
                    }
                }
            }
            launch { // the second child
                delay(10)
                println("Second child throws an exception")
                throw ArithmeticException()
            }
        }
    }
    job.join()
}
//Second child throws an exception
//CoroutineExceptionHandler got java.lang.ArithmeticException
//Children are cancelled, but exception is not handled until all children terminate
//The first child finished its non cancellable block
</code></pre>

<h3>取消异常(CancellationException)不是异常</h3>

<p>需要注意取消异常<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/">CancellationException</a>并不是常规的异常，不遵循前面说的规则，它会被忽略掉。这是因为CancellationException只会发生在主动取消协程时<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/cancel.html">Job#cancel</a>，这是自上而下的取消协程，并不需要链式反应和异常处理。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://kotlinlang.org/docs/exception-handling.html">Coroutine exceptions handling</a></li>
<li><a href="https://juejin.cn/post/7270478168758829111">彻底掌握kotlin 协程异常处理</a></li>
<li><a href="https://juejin.cn/post/7249647450515996732">Kotlin篇 > > 协程中的异常及异常处理</a></li>
</ul>


<h2>调试</h2>

<p>调试总是必须且难免的，有时候代码运行与预期不符，但又想不通为啥时就需要进行调试以弄清楚为啥会产生那样的结果。与常规的代码一样，调试有两种方式，一是<strong>通过IDE中的『Debug』功能，step-by-step</strong>的运行代码，修改代码；另一种就是<strong>通过加日志</strong>。</p>

<h3>在IDE中『Debug』</h3>

<p>凡是IDE，或者说敢称自己是IDE的，肯定有调试功能，也就是step-by-step式的单步跟踪功能。对Kotlin比较友好的IDEA和Android Studio自然也不例外。协程也是标准的Kotlin代码，所以也是可以调试的，并且在调试方面其实没有区别。都是先在代码中设置断点，然后使用虫子图标的『Debug』功能就好了。对于IDEA系（包括Android Studio），设置断点就是在代码编辑器行号旁边点一下就可以了：</p>

<p><img src="https://kotlinlang.org/docs/images/coroutine-breakpoint.png" alt="" /></p>

<p>然后点虫子图标进行『Debug』即可：</p>

<p><img src="https://kotlinlang.org/docs/images/flow-debug-project.png" alt="" /></p>

<p>这时代码会运行，然后在预设置的断点处停止，并出现调试窗口，这里面可以单步跟踪，继续执行，或者查看代码的运行状态。对于协程来说，会比较方便的显示每个协程的状态，比如是<em>SUSPENDED</em>还是<em>RUNNING</em>等。</p>

<p><img src="https://kotlinlang.org/docs/images/coroutine-idea-debugging-1.png" alt="" /></p>

<p>注意，对于异步流程和并发流程比较多的代码来说，『Debug』会扰乱原本的时序，因为JVM必须在断点处停下来。因此，『Debug』更适用于比较复杂的大段的同步代码的调试，比如协程内部的某一段逻辑。</p>

<h3>用日志来调试</h3>

<p>另外的方式就是用日志来查看代码的运行状态，其实这跟协程也没啥关系，用日志输出想要输出的信息就可以了。只不过对于协程，我们需要知道协程信息，也就是说要知道每条日志是哪个协程输出的。这就需要一个能够输出当前协程名字的方法，一个办法是在打日志时输出CoroutineName，可以通过context[CoroutineName]；更为方便的方法是直接输出线程名字<strong>Thread.currentThread().name</strong>，然后给JVM加上选项<strong>-Dkotlinx.coroutines.debug</strong>就可以得到协程的详细名字：</p>

<pre><code class="Kotlin">fun log(msg: String) = println("[${Thread.currentThread().name}] $msg")

fun main() = runBlocking {
    val a = async {
        log("I'm computing a piece of the answer")
        6
    }
    val b = async {
        log("I'm computing another piece of the answer")
        7
    }
    log("The answer is ${a.await() * b.await()}")
}
//[main @coroutine#2] I'm computing a piece of the answer
//[main @coroutine#3] I'm computing another piece of the answer
//[main @coroutine#1] The answer is 42
</code></pre>

<p>从日志中可以看每条日志所在的线程名字（即前面的main）和协程名字（即&#64;后面的内容）。注意，一定要给VM加上选项<strong>-Dkotlinx.coroutines.debug</strong>，要不然不会带有协程名字，只有线程名字：</p>

<pre><code class="Bash"># Output without -Dkotlinx.coroutines.debug

[main] I'm computing a piece of the answer
[main] I'm computing another piece of the answer
[main] The answer is 42
</code></pre>

<p>对于Android应用来说，是没有办法<strong>直接给VM加上选项的</strong>，这时可以通过<strong>设置系统属性</strong>，在应用的入口处，比如在<a href="">Application#onCreate</a>或者<a href="">Activity#onCreate</a>时，设置属性即可：</p>

<pre><code class="Kotlin">System.setProperty("kotlinx.coroutines.debug", if (BuildConfig.DEBUG) "on" else "off")
</code></pre>

<p>对于异步流程和并发流程较多的地方，用日志是比较理想的调试手段，因为它<strong>对程序运行的干扰相对较小</strong>。</p>

<p>当然了，并发编程最大的问题就是<strong>比较难调试</strong>，调试必然需要知道程序运行的状态，无论是日志还是单步调试都会对程序的运行造成影响，从而使原本的逻辑发生改变。相信同学们都会遇到类似的情景：加了几句日志，Bug就不复现了。这就好比量子世界里面观察者对量子的影响一样，听起来不可思议，但确实会发生。并发编程需要在编码之前做好功课，用什么样的模型，选什么样的范式，谁是生产者，谁是消费者，用图形画一画，厘清思路，之后再去编码实现。而不是上来就编码，边想边做，发现线程不够用了，就多开一个吧，A数据回来的太快了，消费者还没有准备好，那就先用一个Map存着吧，这样乱撞式的开发，最后可能会实现需求，但出现Bug必然是极难调试的。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html#debugging-coroutines-and-threads">Debugging coroutines and threads﻿</a></li>
<li><a href="https://kotlinlang.org/docs/debug-coroutines-with-idea.html">Debug coroutines using IntelliJ IDEA – tutorial</a></li>
<li><a href="https://juejin.cn/post/6860647298926379021">Kotlin Jetpack 实战 | 08. 协程“不为人知”的调试技巧</a></li>
</ul>


<h2>协程间通信</h2>

<p>大多数时候协程之间是需要通信的，比如说一个协程在从网络拉取数据，另一个协程可能需要显示进度。可以通过一些共享变量来实现，但这会有潜在的问题，因为<strong>协程随时可能会切换线程运行环境</strong>，这时共享变量就会存在线程安全问题。Kotlin则提供了更为优雅的方式，即Channel。</p>

<p><img src="https://kotlinlang.org/docs/images/using-channel-many-coroutines.png" alt="" /></p>

<p><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/">Channel</a>是一个<a href="https://jenkov.com/tutorials/java-concurrency/producer-consumer.html">生产者-消费者模式</a>，它是线程安全的，可以在生产者与消费之间传递数据。它与Java中的<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html">BlockingQueue</a>是类似的，不同之处在于，它是为协程而生的，它的操作只会挂起不会阻塞，但都是线程安全的。生产者通过<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/">send</a>来生产数据，消费者通过<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/">receive</a>来消费数据。生产者和消费者都可以用协程来实现，所以Channel是一个非常优雅的协程通信方式，高效，可靠且线程安全，来看个小示例：</p>

<pre><code class="Kotlin">fun main() = runBlocking&lt;Unit&gt; {
    val channel = Channel&lt;String&gt;()

    launch(Dispatchers.Default) {
        channel.send("A1")
        delay(10)
        channel.send("A2")
        logd("Producer A done")
    }
    launch(Dispatchers.IO) {
        channel.send("B1")
        logd("Producer B done")
    }

    launch {
        repeat(3) {
            val x = channel.receive()
            logd("Got $x")
        }
    }
}

fun logd(message: Any?) {
    println("[${Thread.currentThread().name}] $message")
}
//[main @coroutine#4] Got A1
//[main @coroutine#4] Got B1
//[DefaultDispatcher-worker-1 @coroutine#3] Producer B done
//[DefaultDispatcher-worker-2 @coroutine#2] Producer A done
//[main @coroutine#4] Got A2
</code></pre>

<p>进一步学习：</p>

<ul>
<li><a href="https://kotlinlang.org/docs/coroutines-and-channels.html#channels">Coroutines and Channels﻿</a></li>
<li><a href="https://kotlinlang.org/docs/channels.html">More about channels﻿</a></li>
<li><a href="https://juejin.cn/post/7171272840426029063">Kotlin协程之一文看懂Channel管道</a></li>
<li><a href="https://juejin.cn/post/7272174836335296548">Kotlin协程之Channel的使用与原理</a></li>
<li><a href="https://kt.academy/article/cc-channel">Channel in Kotlin Coroutines</a></li>
</ul>


<h2>在安卓中使用协程</h2>

<p><img src="https://ts1.cn.mm.bing.net/th/id/R-C.bd4dc46a7a5a9909ddeb90af8b5d689c?rik=6LThCIIV%2bEN67w&amp;riu=http%3a%2f%2fwikicodecamp.com%2fwp-content%2fuploads%2f2022%2f07%2fandroid_2_coroutine.jpg&amp;ehk=EORu%2fSzDMOJNZINUWgwnsOQ%2bf%2f53YvmcuiPz9Cj%2b%2bNI%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" /></p>

<p>从2019年开始，安卓开发生态中已经是<a href="https://developer.android.com/kotlin/first">Kotlin first</a>了，Kotlin是推荐的编程语言，因此协程自然也变成了推荐的异步和并发编程方式。想要在Android应用开发中用好协程，除了协程本身的知识以外，还需要注意的就是Android本身的东西。Android本身是有框架和相当多组件的，并不像我们前面写demo那样，都是从主函数main开始。因此，我们需要注意的就是多多使用框架和组件已经为我们定义好的协程工具，比如UI逻辑层的协程都要在viewModelScope中启动；以及要符合一些架构上的原则，比如Repository要有自己的scope和dispatcher。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://developer.android.com/kotlin/coroutines">Kotlin coroutines on Android</a></li>
<li><a href="https://developer.android.com/kotlin/coroutines/coroutines-adv">Improve app performance with Kotlin coroutines</a></li>
<li><a href="https://developer.android.com/kotlin/coroutines/coroutines-best-practices">Best practices for coroutines in Android</a></li>
</ul>


<h2>书籍推荐</h2>

<p>当对Kotlin以及协程有了基本的认识之后，如果想要进阶的学习，就需要读一些专题书籍，这里推荐两本：</p>

<ul>
<li><a href="https://www.packtpub.com/product/learning-concurrency-in-kotlin/9781788627160">《Learn Concurrency in Kotlin》</a> 这本书以并发为主题，只不过是用Kotlin协程的方式来实现并发，所以它的重点在于<strong>并发编程Concurrency</strong>，具体实现方式其实可以多种多样。</li>
<li><a href="https://www.bennyhuo.com/project/kotlin-coroutines.html">《深入理解Kotlin协程》</a> 这本书的优点在于会横向的介绍其他编程语言中的并发范式，从而能够深入的理解协程，对于有一定编程经验的人来说，横向比较的方式是非常有效的。</li>
</ul>


<h2>参考资料</h2>

<ul>
<li><a href="https://amitshekhar.me/blog/kotlin-coroutines">Mastering Kotlin Coroutines</a></li>
<li><a href="https://doordash.engineering/2021/11/09/the-beginners-guide-to-kotlin-coroutine-internals/">The Beginner’s Guide to Kotlin Coroutine Internals</a></li>
<li><a href="https://theboreddev.wpcomstaging.com/understanding-kotlin-coroutines/">Understanding Kotlin Coroutines</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin进阶之协程从入门到放弃]]></title>
    <link href="http://toughcoder.net/blog/2024/01/11/kotlin-coroutine-made-easy/"/>
    <updated>2024-01-11T22:29:39+08:00</updated>
    <id>http://toughcoder.net/blog/2024/01/11/kotlin-coroutine-made-easy</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Coroutine">协程Coroutine</a>是最新式的并发编程范式，它是纯编程语言层面的东西，不受制于操作系统，轻量级，易于控制，结构严谨，不易出错，易于测试，工具和配套设施都比较完备。在新生代编程语言（如Kotlin和Swift）中支持良好，在Kotlin中有着非常友好的支持，并且是写异步和并发程序的推荐方式。为了彻底学会使用协程和理解协程背后的原理，计划用三篇文章专注来学习协程。</p>

<p><a href=""><img src="https://cdn.filestackcontent.com/fShtqYm3Tp2Xl9C36xN8" title="auto auto" ></a></p>

<!-- more -->


<ul>
<li>第一篇：主要介绍协程的基本概念，以及如何使用协程，目标就是讲清基本概念，并快速上手。</li>
<li>第二篇：协程的高级用法，如结构化协程，Scope，Context，Exception handling，在框架中使用（如在Compose和Jetpack中），与Flow一起使用。目标就是进一步发挥协程的威力，写出专业健壮的协程代码 。</li>
<li>第三篇：理解协程的核心原理，以及协程的实现机制，以及在其他编程语言中的支持情况。目标是深刻理解协程的原理的实现机制，做到心中无剑，以及尝试在不支持协程的语言中实现协程</li>
</ul>


<p><strong>注意</strong>：在任何一个编程语言中异步和并发编程总是略微复杂的话题，Kotlin中的协程也不例外，因此需要先有一定的前置知识，也就是说要大概弄懂操作系统中的进程与线程， 以及要有一些Java中的线程和并发编程经验，否则是没有办法很好理解和使用Kotlin协程的。</p>

<h2>Hello, coroutines</h2>

<p>每当学习一门新的技术，最喜欢的方式就是快速的上手，比如先弄个『Hello, world!』之类的，而不是上来就讲什么概念，原理，范式和方法论。编程是门实践性很强的学科，要快速上手快速体验，当有了一定的感觉之后，再去研究它的概念和原理。</p>

<p>我们也要从一个『Hello, coroutines!』开始我们的Kotlin协程之旅。</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    launch {
        delay(1000)
        println(", coroutines!")
    }
    print("Hello")
}
// Hello, coroutines!
</code></pre>

<p>以常规的方式来思考，写在前面的语句会先执行，写在后面的语句会后执行，这就是同步的意思，似乎应该输出：</p>

<pre><code class="Bash">, coroutines!
Hello
</code></pre>

<p>但我们得到了期望的输出『Hello, coroutines!』，这就是协程的作用，它可以实现异步。这里launch是一个函数，后面的lambda是它的参数，它的作用就是启动一个协程来运行传入的代码块。这个代码块很简单，它先delay了1秒，然后再输出语句。因为启动了协程，并且协程里的代码等了1秒再执行余下的语句，因此，主函数中的输出语句先执行了，这样就得到了我们期望的输出顺序。</p>

<h3>配置协程运行环境</h3>

<p><strong>注意，注意</strong>，协程并不是Kotlin标准库的一部分，它属于<a href="https://github.com/Kotlin/kotlinx.coroutines/tree/master">官方扩展库</a>的一部分，有自己单独的版本号，要想使用协程还需要<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects">单独配置依赖</a>。协程模块的名字是kotlinx.coroutines，有自已独立的版本号，需要注意的是，要注意Kotlin版本与协程版本之间的匹配关系，协程库对它所支持的Kotlin有最低版本要求。目前协程库最新版本是1.8.0-RC2，它对应的Kotlin版本是1.9.21。</p>

<p>配置协程库依赖：</p>

<h4>Maven</h4>

<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.jetbrains.kotlinx&lt;/groupId&gt;
    &lt;artifactId&gt;kotlinx-coroutines-core&lt;/artifactId&gt;
    &lt;version&gt;1.8.0-RC2&lt;/version&gt;
&lt;/dependency&gt;

&lt;properties&gt;
    &lt;kotlin.version&gt;1.9.21&lt;/kotlin.version&gt;
&lt;/properties&gt;
</code></pre>

<h4>Gradle</h4>

<pre><code class="Groovy">dependencies {
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.8.0-RC2")
}

plugins {
    // For build.gradle.kts (Kotlin DSL)
    kotlin("jvm") version "1.9.21"

    // For build.gradle (Groovy DSL)
    id "org.jetbrains.kotlin.jvm" version "1.9.21"
}

repositories {
    mavenCentral()
}
</code></pre>

<h4>Android</h4>

<pre><code class="Groovy">implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.8.0-RC2")
</code></pre>

<h2>协程是啥</h2>

<p><img src="https://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/58ee3d6d55fbb2fb3f8cdfbe474a20a44723dcf3.jpg" alt="" /></p>

<p>那么协程是啥呢？协程就是一个子例程，或者说一个函数，与常规的函数其实也没啥区别，只不过它可以异步地执行，可以挂起，当然不同的协程也可以并行的执行（这就是并发了）。协程是没有阻塞的，协程只会挂起，一旦协程挂起，就交出CPU的控制权，就可以去执行其他协程了。协程是一种轻量级的线程，但它并不是线程，跟线程也没有直接关系，当然它跟其他函数一样，也是要运行在某一个线程里面的。</p>

<p>在Kotlin中协程的关键字是suspend，它用以修饰一个函数，suspend函数只能被另一个suspend函数调用，或者运行在一个协程内。另外就是delay函数了，它是将协程挂起一定时间。<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch/async</a>函数则是创建并启动一个协程，await函数是等待一个协程执行结束并返回结果。runBlocking函数则是创建一个可以使用协程的作用域，叫作CoroutineScope，协程只能在协程作用域内启动，作用域的目的就是为了管理在其内启动的协程。不理解或者记不住这些关键字和函数也没有关系，这里只需要先有一个印象就够了。</p>

<h3>动动手，折腾一下</h3>

<p>对于我们的『Hello, coroutines!』程序，可以尝试进行一些修改，比如改一下delay的值，去掉runBlocking，或者去掉launch看看会发生什么！</p>

<h2>创建协程</h2>

<p>在继续之前，我们把之前的代码重构一下，把协程代码块抽象成一个函数：</p>

<pre><code class="Kotlin">fun main() = runBlocking { // this: CoroutineScope
    launch { doWorld() }
    println("Hello")
}
// Hello, coroutines!

// this is your first suspending function
suspend fun doWorld() {
    delay(1000L)
    println(", coroutines!!")
}
</code></pre>

<p>功能没变仍是输出『Hello, coroutines!』只不过代码块变成了一个suspend函数，被suspend修饰的函数只能运行在协程之中，或者被另一个suspend函数调用，当然 最终仍是要运行在某一个协程之中的。</p>

<p>创建协程的函数是launch()和<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async()</a>，它们都是函数，参数都是一个代码块，它们的作用是创建一个协程并让代码块参数运行在此协程内。把上面的launch换成async得到的结果是一模一样的：</p>

<pre><code class="Kotlin">fun main() = runBlocking { // this: CoroutineScope
    async { doWorld() }
    println("Hello")
}
// Hello, coroutines!
</code></pre>

<p>当然了，它们之间肯定是区别的，要不然何必费事弄两个函数呢，我们后面再讲它们的具体区别。</p>

<p>到现在我们知道了如何创建协程了，但如我们手动把<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a>删除掉，就会有编译错误，说launch/async找不到，那是因为这两个函数是扩展函数，它们是CoroutineScope类的扩展函数。前面说了，所有的协程必须运行在一个CoroutineScope内，前面的runBlocking函数的作用就是创建一个CoroutineScope，下面我们重点来看看啥是CoroutineScope。</p>

<h2>协程作用域</h2>

<p><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/">作用域（CoroutineScope）</a>是用于管理协程的，所有的协程必须运行在某个作用域内，这样通过作用域就可以更好的管理协程，比如控制它们的生命周期。这里面的概念就是<a href="https://kotlinlang.org/docs/coroutines-basics.html#structured-concurrency">结构化并发(structured concurrency)</a>，也就是让所有的协程以一种结构化的方式来组织和管理，以让整体的并发更为有秩序和可控。</p>

<p><img src="https://www.ericthecoder.com/wp-content/uploads/2019/09/feature-1.jpg" alt="" /></p>

<p>这与人类社会是类似的，比如军队，要把士兵编为不同的组织结构（如团，旅，师，军，集团军），目的就是增强整体的执行效率，进而增强战斗力，试想一个军队，如果没有组织结构，那就会是一盘散沙，战斗力可想而知。</p>

<h3>如何创建作用域</h3>

<p>有很多<a href="https://kotlinlang.org/docs/coroutines-basics.html#scope-builder">构造器方法</a>可以用于创建作用域，基本上不会直接创建作用域对象。最常见的就是用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a>函数，它的作用是创建一个CoroutineScope，执行里面的协程，并等待所有的协程执行完毕后再退出(返回)，我们可以继续改造我们的例子，自己为我们的协程创建一个作用域：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    doWorld()
}

suspend fun doWorld() = coroutineScope {  // this: CoroutineScope
    launch {
        delay(1000L)
        println(", coroutines!!")
    }
    println("Hello")
}
</code></pre>

<p>还有一些其他的作用域生成方法如runBlocking和<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/">GlobalScope</a>，GlobalScope是一个全局的作用域，也就是Kotlin提供的一个在整个Kotlin中都可以直接使用的协程作用域，显然，我们不应该使用它，因为作用域的目的在于组织和管理协程，如果把所有的协程都放在一个全局作用域下面了，那跟没有使用域也没有啥区别了。就好比一个军队，只有一个将军，下面直辖一万个士兵，这跟没有将军是没有分别的。</p>

<p>至于runBlocking，它是创建一个作用域，执行其里面创建的协程，等待所有协程执行完毕后退出，但它还有一个重要的功能就是，在等待协程执行的过程中它会阻塞线程，以保证调用者的线程一定比协程晚些退出。因此，只应该在一个地方使用runBlocking，那就是在主函数中使用，其他地方都不应该使用它。</p>

<p>虽然说协程必须运行在某一个CoroutineScope中，但是不是说在每个要创建协程的地方都使用coroutineScope创建一个新的作用域呢？这显然是滥用了。作用域的目的在于组织和管理协程，因此作用域应该符合架构设计的原则，比如为一个模块或者同一类功能创建一个作用域，以方便管理其内部分的协程。并且CoroutineScope是树形结构的，也就是说作用域本身也可以管理其他作用域，这才能形成完整的结构，体现结构化并发的思想。</p>

<h3>使用框架中的CoroutineScope</h3>

<p>如前所述作用域更多的要从架构角度来考虑。实际上大多数时候，我们并不需要自己创建作用域，因为框架会为我们准备好。就好比Jetpack中的<a href="https://developer.android.com/topic/libraries/architecture/viewmodel">ViewModel</a>，它的作用是把UI操作的逻辑封装起来，那么ViewModel中的所有协程都应该运行在viewModelScope之中，而这是框架已经为我们创建好了的，它会结合系统组件生命周期来管理协程。</p>

<h2>运行上下文</h2>

<p>协程不是什么神密的东西，也不是什么银弹，它就是一个普通的函数（例程routine），只不过它可以异步执行，也就是说launch了一个协程后，这条语句很快就执行完了，马上去执行launch {&hellip;}下面的语句了，协程代码块的执行是在协程里面，它什么时候返回结果是不知道的。也可以挂起，协程挂起后就释放了运行它的线程，并不会阻塞运行它的线程，那么其他协程就有机会运行。</p>

<p>这就涉及另一个重要的东西，就是协程运行的上下文，或者说协程运行的线程环境。协程它就是一个函数，它当然需要运行在某个线程里面。除非特别指定以切换运行的线程，否则所有的协程是运行在主线程中的。</p>

<p>协程的运行环境由<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/">CoroutineContext</a>来定义，但其实基本上不会直接创建这个对象，都是通过参数或者其他构建函数来指定协程的运行上下文环境。</p>

<h3>创建协程时指定上下文</h3>

<p>创建协程的函数launch和async是有多个参数，一共有三个参数，最后一个当然是代码块，前面两个都是有默认值的参数，因此大部分时候可以省略，它们的完整函数签名是：</p>

<pre><code class="Kotlin">fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -&gt; Unit
): Job

fun &lt;T&gt; CoroutineScope.async(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -&gt; T
): Deferred&lt;T&gt;
</code></pre>

<p>第一个参数便是指定协程运行的上下文。现在可以为我们的协程加上线程环境了：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    doWorld()
}

suspend fun doWorld() = coroutineScope {  // this: CoroutineScope
    launch(Dispatchers.Default) {
        delay(1000L)
        println(", coroutines!!")
    }
    println("Hello")
}
</code></pre>

<h3>使用扩展函数withContext</h3>

<p>另外一种方式就是使用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html">扩展函数withContext</a>，在其参数指定的上下文环境中调用代码块中的协程，等待其执行完，并返回结果。</p>

<pre><code class="Kotlin">suspend fun &lt;T&gt; withContext(context: CoroutineContext, block: suspend CoroutineScope.() -&gt; T): T
</code></pre>

<p>上面的例子也可以这样写：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    doWorld()
}

suspend fun doWorld() = coroutineScope {  // this: CoroutineScope
    launch {
        withContext(Dispatchers.Default) {
            delay(1000L)
            println(", coroutines!!")
        }
    }
    println("Hello")
}
</code></pre>

<p>但这并不是好的用法，withContext应该用在一些suspend方法中，并且这些方法想自己指定执行环境，并且执行环境对调用方是透明的。比如说，一个负责用户操作的UesrRepository，它只向外部暴露一些suspend方法，在这些suspend方法内部通过withContext来指定它自己运行的上下文环境，从而不用管调用者的执行环境，不也需要调用者知道repo的执行环境：</p>

<pre><code class="Kotlin">class UserRepository(
    val dispatcher: Dispatcher = Dispathers.IO
) {
    suspend fun login() {
        withContext(dispatcher) {
            // Do login
        }
    }
}
</code></pre>

<p>让每一个架构层次或者模块自己管理好自己运行的上下文，还有一个好处在于，可以方便的通过<strong>依赖注入</strong>来进行<strong>Mock或者测试</strong>。</p>

<h3>使用框架中的上下文环境</h3>

<p>虽然我们可以指定<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/">协程运行的上下文环境</a>，那是不是意味着要自己创建很多的context呢？非也，非也。框架中也预定义好了<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/">很多context</a>，可以直接拿来用，比如<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html">Dispatchers.Default</a>，这是Kotlin中的默认线程适合做计算密集类任务；<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-i-o.html">Dispatchers.IO</a>，这适合做IO密集的操作，如文件读写，网络等；<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html">Dispatchers.Main</a>，这是Kotlin中的主线程（即main函数运行的线程），UI中的主线程（如Swing和安卓的主线程）；等等，当然了，也可以自己创建一个context。</p>

<p>到这里我们可以发现，现代化的并发框架较以前是是非常的完备，从创建，到管理，再到运行环境都考虑的非常全面。比如<a href="https://github.com/ReactiveX/RxJava">RxJava</a>或者我们现在正在学习的协程，都是如此。在Java中，其实也有类似的东西，其实就是<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html">ExecutorService</a>，它就是异步和并发任务运行的环境。只不过，它的API设计的还是太过原始，你仍然 需要自己去实现一个<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html">Executor</a>，并没有像RxJava中的<a href="https://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/schedulers/Schedulers.html">Schedulers</a>以及Kotlin中的Dispatchers一样，有一些功能明确的预定义的对象可以直接使用。</p>

<h2>并发性</h2>

<p>并发就是代码『同时运行』，当然 有真并发，那就是并行，比如两台电脑同时都在运行不同的或者相同的应用程序，类似于两个人同时都在干活儿，这是并行（真并发）；大多数并发都是假的，只不过操作系统以粒度非常小的时间片在不同的代码间来回切换，让人感觉起来好像所有的代码都在同时运行，但真到了CPU的指令周期里面，其实同一个周期只能执行一个命令。当然了，现代处理器都具有多核心，每个核心可以执行一个指令，因此多核心可以真的同时运行多个线程，也可以实现真并发。</p>

<p>并发的前提是要能异步，也就是像我们的launch {&hellip;}一样，它很快就执行完了，这样后面可以继续执行，因此，协程是可以实现并发的，也就是让多个协程『同时运行』：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    doWorld()
}

// Concurrently executes both sections
suspend fun doWorld() = coroutineScope { // this: CoroutineScope
    launch {
        delay(2000L)
        println(", coroutine #2, comes later!")
    }
    launch {
        delay(1000L)
        println(", coroutine #1, here I am!")
    }
    print("Hello")
}
//Hello, coroutine #2, here I am!
//, coroutine #1, comes later!
</code></pre>

<p>注意，我们这里是假并发，我们没有指定线程，两个协程都是运行在主线程里面的，但它们没有相互影响，更没有阻塞发生，它们确实是『同时运行的』。</p>

<p>当然了，在实际开发过程中呢，肯定还是要指定协程的运行线程，以实现真的并发，原因在于真实的软件代码是比较复杂，主线程，以及每个协程都有大量的代码要执行，都去揩主线程的油，肯定 很快就被榨干了，所以必然要上<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-i-o.html">Dispatchers.IO</a>之类的多线程以实现真正的并发。</p>

<h2>可控制性</h2>

<p>好的并发框架一定是可控的，也就是说对于异步任务来说要能很好的<strong>开启</strong>，<strong>等待</strong>和<strong>终止</strong>。Kotlin中的协程是可以做到这一点的。前面说到launch和async都可以创建一个协程，那它俩到底 啥区别？我们从前面它们的函数签名可以看出它俩的返回值是不一样的，launch返回一个<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/">Job对象</a>，而async返回一个<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/">Deferred对象</a>。</p>

<p>Job对象可以理解为协程的一个句柄，可以用来控制协程，比如终止它（取消它cancel），『同步等待』它执行完（join()）。</p>

<pre><code class="Kotlin">suspend fun doWorld() = coroutineScope {
    val job = launch {
        delay(2000L)
        println(" and coroutine #2")
    }
    launch {
        delay(1000L)
        println("from coroutine #1 !")
    }
    println("Hello")
    job.join()
    println("All jobs done.")
}

fun main() = runBlocking {
    doWorld()
}
</code></pre>

<p>上面的例子输出是符合期望的：</p>

<pre><code class="Bash">Hello
from coroutine #1 !
 and coroutine #2
All jobs done.
</code></pre>

<p>而如果，把 job.join()去掉的话，因为launch {&hellip;}创建的协程是异步执行，很快就返回了，最后的语句println(&ldquo;All jobs done.&rdquo;)会得到执行，因为协程都有delay，所以『All jobs done.』要先于协程中的语句输出：</p>

<pre><code class="Bash">Hello
All jobs done?
from coroutine #1 !
 and coroutine #2
</code></pre>

<p><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.gkI-tiJSxqG7wpydbs9EugHaEK?rs=1&amp;pid=ImgDetMain" alt="" /></p>

<p>而Deferred是Job的一个子类，它特有的功能是取得协程的返回结果，通过其await函数可以『同步的等待』协程结果返回，launch可以通过Job来等待协程执行完成，但是拿不到协程的返回结果，这就是launch与async的最大的区别。</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    val one = async { computeOne() }
    val two = async { computeTwo() }

    println(" Finally we got: ${one.await() + two.await()}")
}

private suspend fun computeOne(): Int {
    return withContext(Dispatchers.IO) {
        print("Coroutine #1: Calculating ...")
        delay(2400)
        val res = 12
        println(", got $res")
        return@withContext res
    }
}

private suspend fun computeTwo(): Int {
    return withContext(Dispatchers.IO) {
        print("Coroutine #2: Calculating ...")
        delay(2200)
        val res = 20
        println(", got $res")
        return@withContext res
    }
}
//Coroutine #1: Calculating ...Coroutine #2: Calculating ..., got 20
//, got 12
// Finally we got: 32
</code></pre>

<p><strong>注意，注意</strong>：前面说Job#join()和Deferred#await()都可以『同步地等待』协程执行完成，但这里的『同步等待』是非阻塞式的，它只是把当前协程挂起，虽然说join和await后面的语句在协程返回前不会得到执行，但这并不是像<a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/sleep.html">join/sleep/wait</a>之于<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html">Thread</a>那种阻塞式的。协程的join和await只是挂起，把运行环境中的线程释放，在此期间其他协程是可以得到CPU资源（即线程）继续运行的。</p>

<h2>总结</h2>

<p>本文主要介绍了Kotlin中的协程基本使用方法：在一个协程作用域中，通过launch/async来创建一个协程，通过context来切换协程的运行上下文（线程环境），并可以通过Job/Deferred对象来控制协程。</p>

<p>到此，我们可以总结出协程的一些特点：</p>

<ul>
<li><strong>轻量级</strong>，它是纯编程语言层面的东西，不涉及操作系统支持的进程和线程的创建，因此它占用的资源非常少，是轻量级的异步和并发利器。</li>
<li><strong>非阻塞式</strong>，协程最重要的特点是非阻塞，它的等待虽然会让其后面的语句延迟执行，但此时运行的线程已被释放，其他协程可以得到运行。</li>
<li><strong>设施完备</strong>，管理协程的作用域，切换运行环境的context，协程的可控，可以非常优雅的实现结构化并发编程，从而减少出错，并且完全可测。</li>
</ul>


<p>其实，可以看出<strong>协程是一种代码执行上的操作框架</strong>，它能让代码挂起，交出真实的CPU控制权（可以想像为一个大的switch语句，在不同的函数之间跳转切换）。进程和线程都是操作系统直接支持的，操作硬件资源的方法，一个运行中的线程必须占有一个CPU核心，线程只能被阻塞，无法挂起，因为操作系统切换线程就意味着让CPU去运行另外一个线程，那么前一个线程就进入了阻塞状态(Blocked)，等操作系统再切换回这个线程时，它才得以继续运行，从阻塞状态转为运行状态。而协程是纯的编程语言层面实现的东西，视线程为透明，一旦挂起，就可以去执行另一坨代码，它全靠程序员自己来控制，协程，即一起协作的子例程，这也是协程，作为新一代并发编程范式最大的优势。</p>

<h2>书籍推荐</h2>

<p>《Kotlin编程实战》是推荐的书籍，这本书比较厚实，把Kotlin的每个特性都论述的十分详细。</p>

<h2>实践</h2>

<p>强烈推荐<a href="https://kotlinlang.org/docs/coroutines-and-channels.html">官方的一个实战教程</a>，非常适合入门，难度也不大，并且有答案，可以一步一步的学会使用协程，并理解它。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/coroutines-guide.html">Coroutines guide</a></li>
<li><a href="https://kotlinlang.org/docs/coroutines-basics.html">Coroutines basics</a></li>
<li><a href="https://kotlinlang.org/docs/coroutines-and-channels.html">Coroutines and channels − tutorial</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Kotlin Delegation]]></title>
    <link href="http://toughcoder.net/blog/2023/09/14/understanding-kotlin-delegation/"/>
    <updated>2023-09-14T22:01:46+08:00</updated>
    <id>http://toughcoder.net/blog/2023/09/14/understanding-kotlin-delegation</id>
    <content type="html"><![CDATA[<p>委托或者说委派，是一种设计机制，实现者并不真正的实现某些方法（行为），而是让另外一个对象来当真正的实现者。委拖与依赖注入和延时加载技术结合在一起会产生非常巨大的威力，让代码不但灵活方便扩展，也非常的优雅，但确实会较难以理解。<a href="https://kotlinlang.org/docs/delegation.html">委托机制(Delegation)</a>在Kotlin中的支持是很友好的，并且非常完善，用关键字by和lazy一起就可以写出非常强大的委拖机制代码。</p>

<p><a href=""><img src="https://hashnode.com/utility/r?url=https:%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1629222884259%2FI3f9YGK1M.png%3Fw%3D1200%26h%3D630%26fit%3Dcrop%26crop%3Dentropy%26auto%3Dcompress%2Cformat%26format%3Dwebp%26fm%3Dpng" title="auto auto" ></a></p>

<!-- more -->


<h2><a href="https://en.wikipedia.org/wiki/Delegation_pattern">Delegation Pattern</a></h2>

<p>要想理解Kotlin中的委托，要先理解一下设计模式中的委托模式。严格来说委拖并不是一种设计模式，因为它并没有固定的范式，在GoF以及很多关于设计模式的书中并没有这一模式，准确的来说它是一种行为的实现方式，并不自己直接实现，而是委派给另外一个对象的方法。委托是一种行为模式，它只注重于行为，一般情况下都是对对象的方法进行委托，或者行为产生的结果也就是一个变量或者对象的域也可以委托，但只能委托给一个函数，这个函数会产生结果，以得到域的值。</p>

<p><img src="https://assets.alexandria.raywenderlich.com/books/des/images/c57492352703ffd13faa67205936b3bcb113947305da80d0be80770d0ceea10e/original.png" alt="" /></p>

<h3>委托与代理的区别</h3>

<p>代理是一种正式的设计模式，它强调的是权限和隔离，client只能访问到proxy，而并不知道realObject。而委托是一种实现机制，不自己实现，委派给其他对象去实现，它更强调的是行为和结果。代理是一种委托机制，但委托并不是代理。</p>

<p><img src="https://i1.wp.com/www.robertlarsononline.com/wp-content/uploads/2017/05/ProxyPatternGeneric.png?resize=700%2C388&amp;ssl=1" alt="" /></p>

<p>在理解了委托的概念后，就可以进一步的来看一下Kotlin中的委托了。</p>

<h2><a href="https://kotlinlang.org/docs/delegation.html">实现委托</a></h2>

<p>就是某一个类的实现，完全委托给另外一个对象，为了保持行为的一致，它们都实现了某一个接口。用关键字by来实现这一委托机制：</p>

<pre><code class="kotlin">interface Base {
    fun print()
}

class BaseImpl(val x: Int) : Base {
    override fun print() { print(x) }
}

class Derived(b: Base) : Base by b

fun main() {
    val b = BaseImpl(10)
    Derived(b).print()
}
</code></pre>

<p>类Drived也实现了接口Base，但它并没有自己去实现方法，而是委派给了它的构造参数b，b也是一个实现了接口的对象。这样Drived的行为就都委托给了对象b。而b则可以是任何一个实现了Base接口的对象，并且是在创建Drived时才指定的。更进一步的，这里可以用工厂方法，因为只要能生成一个实现了Base接口的对象即可，甚至可以用依赖注入来动态生成对委托对象。</p>

<p>这里需要明确一下术语，委托给别人的对象称为受托对象或者受托类，真正的做事情的人称之为委托对象。</p>

<p>Kotlin仅用一个关键字by就可以完成委托，编译器会自动生成受托类的实现，它的每个方法就直接调用委托对象的方法，可以理解 为上面的代码会编译生成这要的字节码：</p>

<pre><code class="java">class Derived extends Base {
    private Base impl;
    override void print() {
         impl.print();
    }
}
</code></pre>

<h2><a href="https://kotlinlang.org/docs/delegated-properties.html">属性委托</a></h2>

<pre><code class="kotlin">class Example {
    var p: String by Delegate()
}
</code></pre>

<p>属性委托是把属性的getter/setter委托给某一个函数，或者某一个对象（这个对象要有setValue/getValue方法，本质上仍是委托给一个函数）。</p>

<h2><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/lazy.html">延时机制(lazy)</a></h2>

<p>延时机制的委托才能产生最大的威力，而在Kotlin中，借助by和lazy就能对对象的属性实现延时委托机制，让只有在必要的时候(即第一次访问这个属性的时候)才生产出属性的真实值。</p>

<pre><code class="kotlin">val lazyValue: String by lazy {
    println("computed!")
    "Hello"
}

fun main() {
    println(lazyValue)
    println(lazyValue)
}
</code></pre>

<p>其实，by lazy可以应用在任何地方，不光是属性，常规的变量也是可以的。另外，需要注意lazy不但是第一次用到此变量时才会此具体计算，而且也只计算一次，后续再访问时，会从cache中读取首次计算后的值：</p>

<pre><code class="kotlin">var foo by lazy {
    if (someCondition) {
         generate()
    } else {
         defaultValue
    }
}
</code></pre>

<p>这个例子，假如第一次访问变量foo时，执行lazy后时someCondition是false就会返回defaultValue，而且后续再访问foo也不会再执行这个尾部lambda了，会直接返回defaultValue，因为它被cache住了。所以一般用lazy都是要针对 只读变量，也即<code>val foo by lazy { ... }</code>，这才是最正统的用法。</p>

<p>需要注意，lazy并不是一个关键字，它是一个函数，它只有一个参数就是一个lambda，所以可以写成尾部lambda的方式。</p>

<h2>常规委托</h2>

<p>使用by关键字就可以实现委托，这除了可以用于类的实现，属性实现以外，其实任何一个变量也可以用by来委托给一个函数。</p>

<pre><code class="kotlin">var expand by remember { mutableStateOf(true) }
</code></pre>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.cnblogs.com/itzhoucong/p/14255117.html">设计模式（二）之委派模式（Delegate Pattern）深入浅出 </a></li>
<li><a href="https://learnku.com/docs/99-software-pattern/delegation-pattern/12018">委托模式 Delegation Pattern</a></li>
<li><a href="https://www.zhihu.com/question/23123039">编程设计模式中委托 和代理模式什么区别？</a></li>
<li><a href="https://stackoverflow.com/questions/38250022/what-does-by-keyword-do-in-kotlin">What does &lsquo;by&rsquo; keyword do in Kotlin?</a></li>
<li><a href="https://blog.csdn.net/wzgiceman/article/details/82689135">Kotlin -by 详解</a></li>
<li><a href="https://juejin.cn/post/7057675598671380493">Kotlin常用的by lazy你真的了解吗</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[More About Kotlin Functions]]></title>
    <link href="http://toughcoder.net/blog/2023/09/13/more-about-kotlin-functions/"/>
    <updated>2023-09-13T20:52:36+08:00</updated>
    <id>http://toughcoder.net/blog/2023/09/13/more-about-kotlin-functions</id>
    <content type="html"><![CDATA[<p>Kotlin中的函数是一级对象，除了常规的函数式编程以外，还支持一些非常灵活的特殊用法，可以大大增强代码的可读性和简洁性，让代码更加的优雅，在业界顶级的库如Compose中有大量的应用，今天就来学习一些，以扫清学习Compose的障碍。</p>

<p><a href=""><img src="https://www.callicoder.com/static/faf261ddf8d3f25d8c48da997d9a2dc1/kotlin-functions.png" title="auto auto" ></a></p>

<!-- more -->


<h2><a href="https://kotlinlang.org/docs/extensions.html">Extension Functions</a></h2>

<p>与传统的编程语言如C/C++，Java或者Python最大的不同就是，Kotlin对于类的扩展提供了相当灵活的方式。像Java和Python除了标准的继承方式以外，就只能用注解和Decorator。但对于Kotlin还可以用<a href="https://kotlinlang.org/docs/extensions.html">Extensions</a>这一方式。无论是注解还是Decorator，它的使用方式还是比较笨拙的，可以明显的看出来是额外定义的函数，与原Class是没啥关系的。</p>

<p><img src="https://thetechstack.net/assets/images/banners/kotlin-extension-function.png" alt="" /></p>

<p>比如说，对于整数来说，我们通常会有求绝对值，通常可以这样写：</p>

<pre><code class="kotlin">fun abs(a: Int) = if (a &lt; 0) -a else a
</code></pre>

<p>然后，这样使用：</p>

<pre><code class="kotlin">val aa = abs(a)
</code></pre>

<p>但在Kotlin中，有更优雅的方式：</p>

<pre><code class="kotlin">fun Int.abs() = if (this &lt; 0) -this else this

println((-4).abs())
println(100.abs())
</code></pre>

<p>这就是Extension functions，这样定义了后，可以像整数类型本身定义的方法那样直接在其对象上面调用。</p>

<h3>如何定义Extension functions</h3>

<p>Extension functions是针对Class的，或者一个Type的，指定目标Class名字，和参数就可以了，在函数的内部this就是调用函数时的对象。
<code>kotlin
fun &lt;ClassName&gt;.&lt;function name&gt;(params...): return type {
    // this is the function's receiver, which is the object when function invoked.
    // function implementation
}
</code>
需要注意，Extension functions必须是针对Class的。</p>

<h3>理解Extension functions</h3>

<p>Extension functions并没什么高深和神秘的东西，它只是相当于一个static函数，接收目标Class的对象而已，比如说：</p>

<pre><code class="kotlin">fun Shape.area(): Int = this.length * this.width

fun area(shape: Shape): Int = shape.length * shape.width
</code></pre>

<p>其实这两个函数是完全一样的，上面的那个Extension function其实就相当于后面的那个常规函数。只不过在函数的调用上面更加的方便，看起来更像是目标Class提供的方法一样，更优雅一些。</p>

<h3>Extension function的作用域</h3>

<p>Extension function并不会真的对目标Class做任何修改，它只是相当于你自己定义的一个函数。所以，它的作用域就是你定义的函数的作用域，如果你是在一个文件中定义的，那么它的作用域就是导入了这个文件的地方；如果是在一个类中的，那作用域就是这个类。</p>

<p>另外的问题就是，假如在多个地方定义了相同的Extension function，会发生什么呢，相同的意思就是目标Class一样，函数名字也一样，所做的事情也一样，仍是把它当成普通函数来理解就行，按照虚拟机懒惰加载的原则，应该是第一个被引用到的Extension function生效。</p>

<h3>参考资料</h3>

<ul>
<li><a href="https://www.baeldung.com/kotlin/extension-methods">Extension Functions in Kotlin</a></li>
<li><a href="https://marketsplash.com/tutorials/kotlin/kotlin-extension-function/">Kotlin Extension Function: How To Implement And Use It</a></li>
<li><a href="https://www.geekailab.com/doc/as/book/docs/Part1/Android%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87Kotlin%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/KotlinExtensions.html">让人爱不释手的Kotlin扩展（Extensions）技术探Extensions秘与应用</a></li>
<li><a href="https://www.jianshu.com/p/314cdb1603fc">Kotlin 扩展函数及原理</a></li>
<li><a href="https://juejin.cn/post/6935027613542907941">Kotlin 编程 #3 扩展函数（终于知道为什么 with 用 this，let 用 it）</a></li>
</ul>


<h2><a href="https://kotlinlang.org/docs/functions.html#infix-notation">Infix Functions</a></h2>

<p>准确的来说是Infix notation，它是一种执行函数的特殊方式，并不是定义了特殊的函数。也就是说某个函数被infix修饰了后，就可以用更为简洁的方式来调用它。常规的函数执行（或者说调用）是用函数名字加上括号，括号里面是参数，比如foo()，bar(&ldquo;here&rdquo;)。而infix方式则可以是 <code>参数1 函数名 参数2</code> 这种方式，也即与常规的函数调用完全不一样。看起来像是语言本身的关键字一样。</p>

<p><img src="https://www.fusebes.com/wp-content/uploads/2021/03/Post-Banners-FuseBase-17-1.png" alt="" /></p>

<p>比如，移位并不是运算符，也不是关键字，而是一个被infix修饰的二元参数函数：</p>

<pre><code class="kotlin">finfix un Int.shr(x: Int): Int {...}

8.shr(2) // 这样正常调用也完全可以，把整数8右移2位
8 shr 2 // 这是infix式的用法，其实是等同于上面的函数调用
</code></pre>

<p>infix必须是Extension function，并且只能有一个参数，算上Extension function的接收对象，其实一共是2个参数。标准库中也定义了大量的infix，如整数位移的shr和shl。以及像一些DSL中的函数，都会定义成infix，以让代码更简洁。</p>

<p>总之，下次再见到 <code>a xyz b</code> 这种写法时，不用害怕，并不是有了新的关键字，这里的xyz是infix notation，把它当成函数调用 <code>xyz(a, b)</code> 就好了。</p>

<h3>参考资料</h3>

<ul>
<li><a href="https://www.programiz.com/kotlin-programming/infix-notation">Kotlin Infix Function Call</a></li>
<li><a href="https://www.baeldung.com/kotlin/infix-functions">Infix Functions in Kotlin</a></li>
</ul>


<h2><a href="https://kotlinlang.org/docs/inline-functions.html">inline Functions</a></h2>

<p><img src="https://cdn.educba.com/academy/wp-content/uploads/2021/04/Kotlin-Inline-Function.jpg" alt="" /></p>

<p>常规的lambda会有closure（捕获上下文中的对象），在编译后会产生很多对象，这会导致一些性能问题，但这是标准的函数式编程。</p>

<p>但某些情况下，我提供的是一个单纯的行为（lambda），比如像Collections的forEach以及filter，传入的lambda也好，或者其他函数也好，这是一个单纯的行为，你在集合中遍历时执行它就好。这种情况好，我们希望高阶函数在其函数体内直接使用传入的函数参数就可以了，不需要进行常规的对象创建（closure对象以及函数接口对象）。就可以使用inline关键字来修饰这人高阶函数。</p>

<h3>参考资料</h3>

<ul>
<li><a href="https://www.baeldung.com/kotlin/inline-functions">Inline Functions in Kotlin</a></li>
<li><a href="https://amitshekhar.me/blog/inline-function-in-kotlin">inline function in Kotlin</a></li>
<li><a href="https://www.geeksforgeeks.org/kotlin-inline-functions/">Kotlin Inline Functions</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Kotlin Scope Functions]]></title>
    <link href="http://toughcoder.net/blog/2023/04/12/understanding-kotlin-scope-functions/"/>
    <updated>2023-04-12T15:06:18+08:00</updated>
    <id>http://toughcoder.net/blog/2023/04/12/understanding-kotlin-scope-functions</id>
    <content type="html"><![CDATA[<p>Kotlin是基于JVM衍生出来的新一代通用编程语言，它的目标是简洁，可读和高效，这里的高效并不是代码的运行效率高，而是说项目的开发效率高。Kotlin有太多的小巧的新特性（在Java眼中就是语法糖），比如在Kotlin中有几个作用和用法都非常接近的函数apply/with/run/let/also，它们的正统名字是<strong>作用域函数</strong>(Scope functions)，今天就来学习一下这些函数的使用方法和具体区别。</p>

<p><a href=""><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.eDXYmyuQp-E1wGqx4WnhIgHaEK?pid=ImgDet&amp;rs=1" title="auto auto" ></a></p>

<!-- more -->


<p>Java是面向对象的王牌语言，它的特点是严谨和教条，Java写出来的代码学过Java的人大多都看得懂，所以规模以上的项目现在基本上都用Java，这对维护是有好处的。但Kotlin不一样，它有非常多的特性，融合了众多编程语言的特点，同样一件事情，可能有无数种写法，虽然号称是用标准Kotlin语言实现的，但是即使学过Kotin的人也看不懂。比如虽然你学会了Function，Object和lambda，以及像inline function和extension，但是如果用apply和with写几段方法，你就看不懂了，这就导致了Kotlin虽然易于上手，但是要想学透和提高曲线 就会陡峭许多。</p>

<p><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.pVewkBVy74Ivnoumj0Gx0wHaF8?pid=ImgDet&amp;rs=1" alt="" /></p>

<h2>到底是个啥</h2>

<p>先来看一下Scope function到底是什么，它们的作用是在一个对象上执行一段代码，我们来看一个简单的例子：有一个类是Person，它有一些属性和方法，我们想对它的一个对象进行操作，通常会这样做：</p>

<pre><code class="kotlin">val alice = Person(name="Alice", age=20,addr="Amsterdam")
println(alice)
alice.moveTo("London")
alice.incrementAge(2)
println("Two years later ${alice.name} is at ${alice.addr}")
</code></pre>

<p>但使用scope function，我们可以这样做：</p>

<pre><code class="kotlin">val alice = Person("Alice", 20, "Amsterdam").apply {
    println(this)
    moveTo("London")
    incrementAge(2)
}
println("Two years later ${alice.name} is at ${alice.addr}")

//Person(name='Alice', age=20, addr='Amsterdam')
//Two years later Alice is at London
</code></pre>

<p>这两段代码的输出是完全一样的，但是第二段明显要简洁很多这就是scope function的作用，仔细看apply后面的lambda块，它是一个scope，犹如在对象的类定义之中，在这个代码块中可以直接引用对象的方法，而不是像常规的那样使用对象的引用。</p>

<p><em>注意</em>：如果不是很尾部lambda的同学可以先行参考<a href="http://toughcoder.net/blog/2023/01/24/understanding-kotlin-functions/">另外一篇文章</a>，以加强理解。</p>

<h2>理解Scope</h2>

<p>作用域也可以理解为一个代码块的上下文，也就是说在一个代码中，可以直接使用的东西，环境变量之于进程，系统框架为应用准备的基础对象，都可以视为一种scope。最为明显的就是类的定义，在类中，我们可以引用this指针来代表当前对象super指针来代表基类，这也是一种scope。lambda捕获的闭包也是一种scope。</p>

<p>Kotlin的scope functions就是把某一个对象当作代码块的scope，代码块中的代码可以方便的使用这个对象。</p>

<h2>Scope funtions的作用</h2>

<p>如同开头讨论的，能用scope function写出来的东西，用常规方式也一样可以做到，那到底图个啥呢？用scope function的方式代码变得更加的简洁和紧凑，我们把针对某一对象的密集操作集中在一起放入一个代码块中，会更加的内聚和紧凑，易于扩展和维护。但也要注意不能滥用，代码块中只应该写与对象相关的操作，与scope对象不相干的事情是绝对不应该放入其中的。</p>

<h2>Scope functions</h2>

<p>主要有6个，它们的应用主体都是一个对象，也就是要在一个对象上面调用这些函数，然后提供一个代码块（lambda）：</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> Scope Function </th>
<th style="text-align:center;"> Object reference </th>
<th style="text-align:center;"> Return value </th>
<th style="text-align:center;"> Description </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> let </td>
<td style="text-align:center;"> it </td>
<td style="text-align:center;"> lambda result </td>
<td style="text-align:center;"> Extension function </td>
</tr>
<tr>
<td style="text-align:center;"> run </td>
<td style="text-align:center;"> this </td>
<td style="text-align:center;"> lambda result </td>
<td style="text-align:center;"> Extension function </td>
</tr>
<tr>
<td style="text-align:center;"> run </td>
<td style="text-align:center;"> _ </td>
<td style="text-align:center;"> lambda result </td>
<td style="text-align:center;"> No object in the scope </td>
</tr>
<tr>
<td style="text-align:center;"> with </td>
<td style="text-align:center;"> this </td>
<td style="text-align:center;"> lambda result </td>
<td style="text-align:center;"> Take the object as an argument </td>
</tr>
<tr>
<td style="text-align:center;"> apply </td>
<td style="text-align:center;"> this </td>
<td style="text-align:center;"> context object </td>
<td style="text-align:center;"> Extension function </td>
</tr>
<tr>
<td style="text-align:center;"> also </td>
<td style="text-align:center;"> it </td>
<td style="text-align:center;"> context object </td>
<td style="text-align:center;"> Extension function </td>
</tr>
</tbody>
</table>


<h2>它们的区别</h2>

<h3>with不是一个extension函数</h3>

<p>其他几个都是extension函数，所以with一定要把scope object作为参数传入。</p>

<h3>scope对象的引用方式</h3>

<p>对于scope function来说scope对象都会作为一个context object，可以在lambda块中使用，有些是作为this指针，有些是作为lambda的默认参数名字也即it指针，但它们都指向context object，本质上是没有区别的只是指针的名字一个是this一个是it。但是，跟类的定义scope是一样的，this指针是可以省略的，但如果it作为参数，则是不能省略的，具体来说，比如说，用apply时，代码块中是this指针，那么可以直接这样写：</p>

<pre><code class="kotlin">val alice = Person("Alice", 20, "Amsterdam").apply {
    println(this)
    moveTo("London")
    incrementAge(2)
}
</code></pre>

<p>当然 你也可以显式的把this写出来，this.moveTo(&ldquo;London&rdquo;)，但这就麻烦多了，何必呢。所以apply最合适的场景是对对象本身的操作，如赋值和修改属性。</p>

<p>但如果是用also，就必须用it了，这个不能省，因为它是对scope对象的引用：
<code>kotlin
alice.also {
    println("Two years later ${it.name} is at ${it.addr}")
}
</code>
所以，also最适合的不是对对象本身的操作，而是一些与对象相关的副作用，如打印日志等。</p>

<h3>返回值不同</h3>

<p>这坨Scope functions是一个函数，它是有返回值的，这个返回是不一样的，apply/also返回的是context object，其他几个则是返回lambda中的返回值也就是lambda的最后一个表达 式或者lambda中显式的return语句。</p>

<p>所以，如果是想继续使用scope object，那么就要用apply/also，如果想得到某个其他值就要用let/run/with，即使说不在乎函数的返回值时，这时也推荐使用also，因为假如后续想继续添加其他操作时，可以直接在后面链接上其他的scope function。其他返回值的let/run/with一般用在一组操作的确定性的终点上面，比如统计均值，那最后的均值计算可以用run，比如文件操作，读写都可以用with。</p>

<h2>如何选择合适的scope函数</h2>

<p>结合它们各自的特点，可以得到如下使用建议：</p>

<h3>如果是更改scope对象本身，用apply()</h3>

<p>比如说要设置某个对象的一坨属性状态，这时就把目标对象作为scope，然后在其上调用apply()，在函数块内把操作都做完：</p>

<pre><code class="Kotlin">val alice = Person("Alice", 20, "Amsterdam").apply {
    println(this)
    moveTo("London")
    incrementAge(2)
}
</code></pre>

<h3>如果是对象弱相关的副作用操作，就用also()</h3>

<p>最为典型的例子就是比如说打印一些日志，这时最好的就是用also。</p>

<h3>判断nullity，不是null时执行一些强相关操作时用let</h3>

<p>基于当前对象，执行一些强相关的操作，这时可以用let，并且可以顺便做nullable检查。</p>

<h3>对象作为一个参数，执行一些转化时用run/with</h3>

<p>把当前对象作为一个参数，或者一个输入，做一些操作，执行一些转化，最终输出为其他对象时，这种时候最好用run/with，比如在不同的架构层级之间转换类型对象时，就可以用run/with。或者在网络返回和本地数据库实体之间转换时，也可以用run/with，区别不大，但用with可读性略强一些，相当于是把对象视为一个上下文，比如：</p>

<pre><code class="Kotlin">val res = nowWeather.getWeather(city)
with (res) {
   WeatherEnity(weather, city)
}
</code></pre>

<p>with函数体内的参数是this，可以直接引用对象的成员，可以使代码非常的简洁，对象成了上下文，又不失可读性。这就让scope函数发挥了最大的价值。</p>

<h2>注意事项</h2>

<p>任何技术和工具要深刻理解它们的应用范围和使用场景以避免滥用，要用到恰到好处才能发挥最大的价值。对于一些非必须的东西，更是如此。</p>

<p>Scope functions是应用于对象上面的，所以前提是当你需要对一个对象进行一些操作时，才可以使用scope functions，具体选择哪一个参考 上面一节的讨论。另外，就是放入代码块中的操作必须全部是scope对象相关的才可以。一个scope function中只能是一组相关的操作，不同组的操作要启用不同的scope functions。比如说网络请求response的处理，可以分为服务器状态码和返回实体的检测，转成具体数据，打印日志这么三个scope functions，而不是全放进一个里面。</p>

<p>总而言之，要视具体的需求和场景，并基于场景选择合适的scope function，切忌过度使用。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/scope-functions.html">Scope functions</a></li>
<li><a href="https://blog.mindorks.com/using-scoped-functions-in-kotlin-let-run-with-also-apply/">Using Scoped Functions in Kotlin - let, run, with, also, apply</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/kotlin-let-run-also-apply-with">Kotlin let, run, also, apply, with</a></li>
<li><a href="https://shusheng007.top/2020/10/02/1-6/">秒懂Kotlin之彻底掌握Scope Functions (apply, also,let,run,with)</a></li>
<li><a href="https://www.jianshu.com/p/5c4a954d2b2c">Kotlin之let,apply,run,with等函数区别</a></li>
<li><a href="https://juejin.cn/post/6868179386344931342">Kotlin学习：run、with、apply、also、let的区别</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
