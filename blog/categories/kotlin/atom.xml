<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Kotlin | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/kotlin/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2025-09-24T22:42:05+08:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[runBlocking实践：哪里该使用，哪里不该用]]></title>
    <link href="https://alexhilton.github.io/blog/2025/09/23/runblocking-in-practice/"/>
    <updated>2025-09-23T22:34:01+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/09/23/runblocking-in-practice</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「runBlocking in practice: Where it should be used and where not」，原文链接<a href="https://kt.academy/article/run_blocking">https://kt.academy/article/run_blocking</a>，由Marcin Moskała发布于2025年9月1日。</p></blockquote>

<p><a href=""><img src="https://kt.academy/_next/image?url=https%3A%2F%2Fmarcinmoskala.com%2Fkt-academy-articles%2Fpromotion%2Frun_blocking.png&amp;w=3840&amp;q=75" title="auto auto" ></a></p>

<!-- more -->


<p>传统意义上讲，Java 和 Kotlin 项目都基于阻塞调用(blocking)。我所说的阻塞调用是指函数在等待某些操作（例如，等待网络响应）时会阻塞调用者的线程。Kotlin 协程最重要的规则之一是，我们不应该在挂起函数(suspending function)上进行阻塞调用（除非我们使用允许阻塞调用的调度程序，例如 <code>Dispatchers.IO</code>）。</p>

<pre><code class="kotlin">// Incorrect: blocking call in a suspending function
suspend fun getUser(): User {
    val response = api.getUser() // blocking call
    return response.toDomainUser()
}

// Correct: Using withContext(Dispatchers.IO) to make a blocking call in a suspending function
suspend fun getUser(): User = withContext(Dispatchers.IO) {
    val response = api.getUser() // blocking call
    response.toDomainUser()
}
</code></pre>

<p>但是如何反其道而行之呢？如何将挂起调用转换为阻塞调用？为此，我们使用 <code>runBlocking</code>！</p>

<h2><a href="#how-runblocking-works"><code>runBlocking</code> 的工作原理</a></h2>

<p><code>runBlocking</code> 在调用它的线程上启动一个协程，并阻塞该线程直到协程完成。因此，runBlocking 本质上是同步的，因为如果我们多次调用它，第二个调用要等到第一个调用完成后才会启动。作为一个同步协程构建器，<code>runBlocking</code> 返回它启动的协程的结果。</p>

<pre><code class="kotlin">fun main() {
    log("Starting main")
    runBlocking {
        log("Starting first runBlocking")
        delay(1000)
        log("Finishing first runBlocking")
    }
    val result: String = runBlocking {
        log("Starting second runBlocking")
        delay(1000)
        "ABCD"
    }
    log("Second runBlocking finished with result: $result")
}

fun log(message: String) {
    println("[${Thread.currentThread().name}] $message")
}
// [main] Starting main
// [main] Starting first runBlocking
// (1 sec)
// [main] Finishing first runBlocking
// [main] Starting second runBlocking
// (1 sec)
// [main] Second runBlocking finished with result: ABCD
</code></pre>

<p>由于 <code>runBlocking</code> 启动了一个作用域，它会等待其中启动的所有协程完成。这意味着它会等待所有子协程完成。这就是为什么下面的程序要等到所有三个异步协程都完成才会完成。为了展示如何使用 <code>runBlocking</code> 定义结果，我还让这个程序从 <code>main</code> 函数返回 <code>0</code>。</p>

<pre><code class="kotlin">import kotlinx.coroutines.*

fun main(): Int = runBlocking {
    launch { delayAndPrintHello() }
    launch { delayAndPrintHello() }
    launch { delayAndPrintHello() }
    println("Hello")
    0 // result from main
}

suspend fun delayAndPrintHello() {
    delay(1000L)
    println("World!")
}
// Hello
// (1 sec)
// World!
// World!
// World!
</code></pre>

<p><code>runBlocking</code> 的行为可能会让你想起 <code>coroutineScope</code>，这并非巧合，因为它们都启动同步协程，但 <code>runBlocking</code> 是阻塞的，而 <code>coroutineScope</code> 是暂停的。这意味着完全不同的用法，我们只在暂停函数中使用 <code>coroutineScope</code>，而我们永远不应该在暂停函数中使用 <code>runBlocking</code>。这也意味着 <code>coroutineScope</code> 与其调用者建立关系，并且始终处于协程层次结构的中间，而 <code>runBlocking</code> 则启动一个新的协程层次结构。</p>

<h2><a href="#the-practice-of-using-runblocking">使用 <code>runBlocking</code> 的实践</a></h2>

<p>在正确实现的基于协程的项目中，并使用设计良好的协程友好库，我们几乎不需要使用 <code>runBlocking</code>。如果我们在项目中经常使用它，那就被认为是代码异味。然而，在某些情况下，runBlocking 是有用的，甚至是必要的。也有一些情况下，runBlocking 不应该被使用。我们还会讨论那些曾经需要 runBlocking 但现在有了更好的替代方案的情况。现在，让我们来看看。</p>

<h2><a href="#where-to-use-runblocking">在哪里使用 <code>runBlocking</code></a></h2>

<p><code>runBlocking</code> 应该用于需要启动协程并阻塞当前线程直到其完成的情况。这意味着它可以在以下情况下使用：</p>

<ul>
<li>我们需要等待协程的结果。</li>
<li>我们可以阻塞当前线程。</li>
</ul>


<p>一个常见的 Android 示例是在 Retrofit 客户端中设置一个拦截器，将令牌附加到网络调用。获取令牌可能需要发起网络调用，因此我们需要启动一个协程来获取令牌。同时，拦截器需要结果才能继续执行。这个拦截器在 Retrofit 的池中启动，因此可以调用它的调用。这使得它成为使用 <code>runBlocking</code> 的理想场所。</p>

<pre><code class="kotlin">class AddTokenInterceptor: Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val token = runBlocking { getToken() }
        val request = chain.request().newBuilder()
            .addHeader("Authorization", "Bearer $token")
            .build()
        return chain.proceed(request)
    }
}
</code></pre>

<p>在后端系统上，有时我们需要阻塞当前线程以等待协程完成，例如为了让我们的工具正确测量此进程的执行时间，或者当我们需要调用某些阻塞脚本并获取其结果时。</p>

<pre><code class="kotlin">@MeasureExecutionTime
fun runDataMigrationScript() = runBlocking {
    val sourceData = readDataFromSource()
    val transformedData = transformData(sourceData)
    writeDataToTarget(transformedData)
}
</code></pre>

<p>这些情况很少见，大多数后端项目不需要使用 <code>runBlocking</code>。除非它们有一些基于阻塞调用的遗留代码。考虑以下 <code>UserService</code>，它在我们的应用程序中用于管理用户。我们已经将其迁移到暂停调用，但我们仍然有一些基于阻塞调用的遗留控制器和服务。为了避免重写所有这些，我们可以为暂停函数提供阻塞替代方案。这些替代方案可以通过使用 <code>runBlocking</code> 包装暂停函数来实现（你也可以考虑使用一些调度器）。</p>

<pre><code class="kotlin">class UserService(
    private val userRepository: UserRepository,
) {
    suspend fun findUserById(id: String): User = userRepository.findUserById(id)

    // Blocking alternative for legacy parts of our application
    fun findUserByIdBlocking(id: String): User = runBlocking {
        findUserById(id)
    }

    // ...
}
</code></pre>

<p>这可能是 <code>runBlocking</code> 最重要的用途，它充当了从阻塞到暂停的桥梁。一些库为 Java 定义了阻塞替代方案。</p>

<pre><code class="kotlin">suspend fun readDataFromSource(): Data {
    // ...
}

fun readDataFromSourceBlocking(): Data = runBlocking {
    readDataFromSource()
}
</code></pre>

<h2><a href="#where-not-to-use-runblocking">哪些情况下不应使用 <code>runBlocking</code></a></h2>

<p>在某些情况下，不应使用 <code>runBlocking</code>。此外，切勿在挂起函数中直接使用 <code>runBlocking</code>。<code>runBlocking</code> 会阻塞当前线程，因此不应在挂起函数中进行阻塞调用（除非使用允许阻塞调用的调度程序，例如 <code>Dispatchers.IO</code>）。在这种情况下，很可能不需要 <code>runBlocking</code>。</p>

<pre><code class="kotlin">// Incorrect: runBlocking in a suspending function
suspend fun getToken() = runBlocking {
    // ...
}

// runBlocking is most likely not needed
suspend fun getToken() {
    // ...
}
</code></pre>

<p>不应在不需要等待结果的函数中使用 <code>runBlocking</code>。如果你只需要启动协程，通常最好使用 <code>launch</code> 启动异步协程。</p>

<pre><code class="kotlin">// Incorrect: runBlocking used where we do not need to await result
fun startBackgroundProcess() = runBlocking {
    doSomething()
}

// Correct: Using launch to start an asynchronous coroutine
fun startBackgroundProcess() {
    backgroundScope.launch {
        doSomething()
    }
}
</code></pre>

<p>我们还应注意，不要在不应被阻塞的线程上使用 <code>runBlocking</code>。这在 Android 上尤其成问题，因为阻塞主线程会导致应用程序卡死。</p>

<pre><code class="kotlin">// Incorrect: runBlocking on the main thread
fun onClick() = runBlocking {
    userNameView.test = getUserName()
}

// Correct: Using launch to start an asynchronous coroutine
fun onClick() {
    lifecycleScope.launch {
        userNameView.test = getUserName()
    }
}
</code></pre>

<p>在后端，如果我们在 <code>synchronized</code> 块中使用它，可能会出现问题。一个技巧是使用 <code>launch</code> 实现回调函数。但是，通常情况下，最好重新设计代码，使用暂停而不是阻塞调用，并使用协程友好的工具（我们将在<em>同步协程</em>课程中讨论）。</p>

<pre><code class="kotlin">// Possibly incorrect: runBlocking inside synchronized block
synchronized(lock) {
    // ...
    val user = runBlocking { getUser() }
    // ...
}

// One solution: use launch to implement a callback
fun getUser(callback: (User) -&gt; Unit) {
    backgroundScope.launch {
        val user = getUser() // suspending call
        callback(user)
    }
}
synchronized(lock) {
    // ...
    getUser { user -&gt;
        // ...
    }
}
</code></pre>

<h2><a href="#outdated-runblocking-uses">过时的 <code>runBlocking</code> 用法</a></h2>

<p><code>runBlocking</code> 传统上用于包装 <code>main</code> 函数体。它的属性非常适合此目的：它启动一个协程，因此它可以调用挂起函数或启动其他协程，并且它会阻塞线程直到协程完成，因此我们可以确保程序不会在所有这些进程完成之前结束。</p>

<pre><code class="kotlin">fun main(): Unit = runBlocking {
    val user = getUser() // suspending call
    println("User: $user")
}
</code></pre>

<p><code>runBlocking</code> 仍然可以以这种方式使用，但是在大多数现代情况下，我们更喜欢使用 Kotlin 1.3 中引入的挂起 <code>main</code> 函数。此类函数在底层被一个类似于 <code>runBlocking</code> 的阻塞构建器包装。</p>

<pre><code class="kotlin">suspend fun main() {
    val user = getUser() // suspending call
    println("User: $user")
}
</code></pre>

<p>关键区别在于 <code>runBlocking</code> 设置了一个调度器，使其所有子协程在其正在使用的同一线程上运行。挂起 main 函数不会设置调度器，因此其子协程默认在不同的线程上运行。引入此更改是因为 <code>runBlocking</code> 使用的单线程调度器经常导致意外行为。</p>

<pre><code class="kotlin">fun main(): Unit = runBlocking {
    println(Thread.currentThread().name)
    launch {
        println(Thread.currentThread().name)
    }
}
// main
// main
</code></pre>

<pre><code class="kotlin">suspend fun main(): Unit = coroutineScope {
    println(Thread.currentThread().name)
    launch {
        println(Thread.currentThread().name)
    }
}
// main
// DefaultDispatcher-worker-1
</code></pre>

<p><code>runBlocking</code> 的第二个传统用途是在测试中。它被用来包装测试主体，以便我们可以调用挂起函数并在其中启动协程。现在，我们更倾向于使用 <code>kotlinx-coroutines-test</code> 库中的 <code>runTest</code>，它是 <code>runBlocking</code> 的一个更强大、更灵活的替代方案。它允许我们控制时间、生成后台作用域并跟踪子协程上的异常。<code>runTest</code> 将在<em>测试协程</em>课程中讨论。</p>

<pre><code class="kotlin">class UserRepositoryTest {
    val userRepository = InMemoryUserRepository()
    val userService = UserService(userRepository)

    @Test
    fun testGetUser() = runTest { // previously runBlocking
        // given
        userRepository.hasUser(UserEntity("1234", "John Doe"))

        // when
        val user = userService.getUser("1234")

        // then
        assertEquals("John Doe", user.name)
    }
}
</code></pre>

<h2><a href="#%E6%80%BB%E7%BB%93">总结</a></h2>

<ul>
<li><code>runBlocking</code> 是一个阻塞协程构建器，它启动一个协程并阻塞当前线程直到它完成。</li>
<li><code>runBlocking</code> 是从阻塞世界(blocking)到挂起世界(suspending)的桥梁，它用于在需要阻塞当前线程直到协程完成的地方启动协程。</li>
<li>如果你需要在项目中频繁使用 <code>runBlocking</code>，那么它就是一种代码异味。在设计合理的基于协程的项目中，应该尽量少用，或者干脆不用。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[学会说不！让你彻底学会Kotlin Flow的取消机制]]></title>
    <link href="https://alexhilton.github.io/blog/2025/08/08/flow-cancellation/"/>
    <updated>2025-08-08T20:25:21+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/08/08/flow-cancellation</id>
    <content type="html"><![CDATA[<blockquote><p>本文译自「Cancellable Flows in Kotlin Coroutines: The Complete Guide to Flow Cancellation Techniques」，原文链接<a href="https://proandroiddev.com/cancellable-flows-in-kotlin-coroutines-the-complete-guide-to-flow-cancellation-techniques-8988a85fc158">https://proandroiddev.com/cancellable-flows-in-kotlin-coroutines-the-complete-guide-to-flow-cancellation-techniques-8988a85fc158</a>，由Sahil Thakar发布于2025年7月21日。</p></blockquote>

<p><strong>译者按：</strong> 本文并不是Flow的基础教程，而是专门讲解如何取消flow的，适合对Flow有一定基础的同学。如果对Flow还不够熟悉，可以先行阅读一下之前的文章：</p>

<ul>
<li><a href="https://juejin.cn/post/7336751931375648820">包教包会的Kotlin Flow教程</a></li>
<li><a href="https://juejin.cn/post/7337517508151590947">专家之路上的Flow高级秘籍</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用优雅的姿式应对Kotlin Flow的回压]]></title>
    <link href="https://alexhilton.github.io/blog/2025/07/03/handling-flow-backpress/"/>
    <updated>2025-07-03T22:09:26+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/07/03/handling-flow-backpress</id>
    <content type="html"><![CDATA[<p>本文译自「How to Manage Backpressure in Kotlin Flow: collect • buffer • conflate • collectLatest」，原文链接<a href="https://proandroiddev.com/how-to-manage-backpressure-in-kotlin-flow-collect-buffer-conflate-collectlatest-b8102284d968">https://proandroiddev.com/how-to-manage-backpressure-in-kotlin-flow-collect-buffer-conflate-collectlatest-b8102284d968</a>，由Shbazhenov发布于2025年6月13日。</p>

<p><a href=""><img src="https://blog.mindorks.com/images/kotlin-flow-banner-image.png" title="auto auto" ></a></p>

<!-- more -->


<p>你是否曾遇到过快速数据源发送的数据量超出应用处理能力的情况，导致应用速度变慢甚至崩溃？Kotlin Flow 内置了一些方法，可让你的生产者和消费者保持同步。本文将介绍：</p>

<ol>
<li>回压的含义</li>
<li>Flow 默认的“互相等待”模式如何工作</li>
<li>何时使用 buffer() 添加小型队列</li>
<li>conflate() 如何跳过旧数据项</li>
<li>为什么 collectLatest { } 会停止旧数据处理</li>
<li>如何根据你的情况选择合适的选项</li>
</ol>


<h2>回压的含义</h2>

<p>回压的作用是确保快速的数据发送方不会压垮较慢的接收方。如果没有回压，你可能会在内存中存储过多的数据，或者浪费时间处理过时的信息。</p>

<p>回压可以帮助你：</p>

<ul>
<li>控制内存使用量</li>
<li>避免不必要的工作</li>
<li>使应用性能更可预测</li>
</ul>


<h2>1. 默认“互相等待”模式</h2>

<p>默认情况下，当你执行以下操作时：</p>

<pre><code class="Kotlin">flow {
  repeat(3) {
    emit(it)
    println("Sent $it")
    delay(100)            // 快速的发送者
  }
}
.collect { value -&gt;
  println("Handling $value")
  delay(300)             // 慢速的处理者
}
</code></pre>

<p>发送方 ( emit ) 将暂停，直到处理方 ( collect ) 处理完最后一个值。没有队列，每个值都是一次发送和处理一个。</p>

<h2>2. 使用 buffer() 添加一个小队列</h2>

<p>如果你希望发送方提前一点，请使用：</p>

<pre><code class="Kotlin">flow { … }
  .buffer(capacity = 2)
  .collect { value -&gt;
    // slow work here
  }
</code></pre>

<ul>
<li>现在，发送者最多可以将 2 个项目放入一个小队列中。</li>
<li>一旦队列满了，它就会再次暂停。</li>
</ul>


<p>这给了你一个有限的队列：你仍然可以处理每个项目，但可以平滑速度峰值。</p>

<h2>3. 使用 conflate() 跳过旧项目</h2>

<p>当你只关心最新数据（例如更新进度条）时，你可以这样写：</p>

<pre><code class="Kotlin">flow { … }
  .conflate()
  .collect { value -&gt;
    println("Update to $value")
    delay(300)
  }
</code></pre>

<ul>
<li>如果处理程序繁忙，则仅保留最新未处理的项目。</li>
<li>较旧的项目将被丢弃，因此你无需处理过时的更新。</li>
</ul>


<p>注意：conflate() 不会停止当前工作；它只是在下次读取时跳过旧值。</p>

<h2>4. 使用 collectLatest { } 停止旧工作</h2>

<p>要进一步操作并在新数据进入时取消任何正在进行的工作，请使用：</p>

<pre><code class="Kotlin">flow { … }
  .collectLatest { value -&gt;
    println("Start $value")
    delay(300)    // 可能会被切断
    println("Done $value")
  }
</code></pre>

<ul>
<li>每次发出（emit）新的数据时，处理前一个值的块都会立即被丢弃。</li>
<li>只有当发送方的发送速度持续超出你的处理能力时，你才需要完成最后一个值的工作。</li>
</ul>


<p>这非常适合边输入边搜索的情况，在这种情况下，你希望在用户再次输入时立即丢弃旧请求。</p>

<h2>5. 选择合适的工具</h2>

<h3>普通 collect</h3>

<ul>
<li>功能：发送方和处理方互相等待，一个接一个</li>
<li>何时选择它：你必须按顺序处理每个项目

<h3>.buffer(n)</h3></li>
<li>功能：大小为 n 的小队列；不丢弃任何项目</li>
<li>何时选择它：你需要少量缓冲，但仍要处理所有项目

<h3>.conflate()</h3></li>
<li>功能：如果处理方繁忙，则仅保留最新项目</li>
<li>何时选择它：你需要最新数据，但仍要完成当前工作

<h3>collectLatest { }</h3></li>
<li>功能：新数据到达后立即取消所有正在进行的工作</li>
<li>何时选择它：只考虑最新的结果；立即放下其他一切

<h2>6. 总结</h2></li>
<li>回压机制可防止快速数据流过载慢速处理器。</li>
<li>默认模式没有队列：安全但速度可能较慢。</li>
<li>buffer() 函数添加了一个小队列：更灵活，不会丢包。</li>
<li>conflate() 函数跳过旧值：始终保持最新，但让当前工作完成。</li>
<li>collectLatest { } 函数停止旧工作：仅完成最新项。</li>
</ul>


<p>下次你的 Flow 感觉太快或太慢时，请问自己：</p>

<ol>
<li>我需要处理每个值吗？</li>
<li>小型队列有帮助吗？</li>
<li>只有最新数据才重要吗？</li>
<li>当新数据到达时，我应该取消旧工作吗？</li>
</ol>


<p>选择最合适的简单选项，Kotlin Flow 会处理余下的事情。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一文搞懂Kotlin符号处理接口KSP]]></title>
    <link href="https://alexhilton.github.io/blog/2024/04/16/kotlin-ksp-made-easy/"/>
    <updated>2024-04-16T21:17:43+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/04/16/kotlin-ksp-made-easy</id>
    <content type="html"><![CDATA[<p>Kotlin符号处理（Kotlin Symbol Processing）即KSP是可以用于开发轻量级编译器插件的一套API。是Kotlin原生的，Kotlin语法友好的编译器插件。使用简单且易于上手，可以实现一些非常强大的编译时代码处理功能，如代码生成和代码检查。今天就来学习一下KSP的基本原理，以及如何使用KSP API。</p>

<p><a href=""><img src="https://androiddeepdive.github.io/Team-Blog/images/cover_ksp.png" title="auto auto" ></a></p>

<!-- more -->


<p><strong>注意</strong>，本文是Kotlin中较为高级的话题，适合有一定的Kotlin基础的同学，否则理解起来可能有难度，可以事先<a href="https://juejin.cn/column/7351592055908892723">阅读前面的文章</a>。</p>

<h2>什么是KSP</h2>

<p>与前文提到的注解处理器kapt类似，KSP也是一种编译时的插件，能够在编译前处理Kotlin语言的符号。KSP API能地道地处理Kotlin的源码，因为它是专门为Kotlin而设计的，能够完全的理解和识别Kotlin的语言符号，以及Kotlin专属的特性：如扩展函数，声明点泛型变化以及本地函数。KSP API基于Kotlin的语法，把Kotlin程序拆解为各种静态的符号，可以处理如类，成员，函数，参数 以及注解等等。但它并不是运行时的（那是反射做的事情），因此像逻辑如循环和条件语句是没有办法进行处理，以及也无法得到表达式的结果。</p>

<p>虽然KSP是编译器插件，但它是运行在最终编译之前，也就是说在编译器编译全部代码之前，事先会运行KSP插件。所以KSP API最适合做的事情是：</p>

<ol>
<li>读取代码和各种资源文件，并进行分析</li>
<li>生成代码</li>
</ol>


<p>接下来看如何具体使用KSP API。</p>

<h2>配置KSP</h2>

<p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcStf17qaB5JSFveiBVlA6ljiI0OgI3kN4hnQkBKtuFnSw&amp;s" alt="" /></p>

<p>KSP是由谷歌开发的一套工具，包括两部分一个是Kotlin plugin，另一个是依赖库。所以需要在项目的根build.gradle里面，先把plugin添加到项目里：</p>

<pre><code class="Groovy">// The root build.gradle of your project
plugins {
    id 'org.jetbrains.kotlin.jvm' version '1.9.23' apply false
    id 'com.google.devtools.ksp' version '1.9.23-1.0.20' apply false
}
</code></pre>

<p>当然，这一步其实并不是必须的，也可以在每个模块中再配置plugin。</p>

<p>接下来，在使用KSP的模块里面添加plugin，添加依赖以及指明KSP processor，这是最为关键的配置：</p>

<pre><code class="Groovy">// module build.gradle
plugins {
    id 'org.jetbrains.kotlin.jvm'
    id 'com.google.devtools.ksp'
}

dependencies {
    implementation project(':kspannotation')
    ksp project(':kspprocessor')
}
</code></pre>

<p>如果项目顶层指定了plugin的版本，那么到了module这里，就不必再指定版本了。另外就是要注意版本的匹配，ksp的版本前半段『1.9.23』指明 的是最低的Kotlin版本要求。最好是让ksp要求的版本与指定的Kotlin版本匹配或者差距较小，否则可能会有问题。dependencies中的ksp指定的是KSP processor，对于有些库可能注解和定义和KSP的processor可能会在同一个包里，那么写一句就够了，如Room的，就一句：ksp &lsquo;androidx.room:room-compiler:2.6.1&#8217;。</p>

<p>如果是自定义的processor，需要为processor单独建一个library module，配置ksp库为依赖即可：</p>

<pre><code class="Groovy">// KSP processor module build.gradle
plugins {
    id 'org.jetbrains.kotlin.jvm'
}

dependencies {
    implementation project(':kspannotation')

    implementation 'com.google.devtools.ksp:symbol-processing-api:1.9.23-1.0.20'
    implementation 'com.squareup:kotlinpoet-ksp:1.16.0'
}
</code></pre>

<p>典型的KSP procesor（包括网上大部分的例子）都是分了三个module，一个是定义注解的module，一个是实现processor的，一个是使用注解和processor的。但这并不是必须的，为了方便，其实把注解的定义和processor放在一个module就可以了。只要把processor与使用它的module分开来了，就可以。</p>

<p><strong>注意：</strong>对于processor module来说它的类型要是library，并且要是Java library或者Kotlin library，因为这是Kotlin语言层面的东西。对于Android同学来说在新建module时一定要选择『Java or Kotlin Library』。</p>

<h2>实现KSP Processor</h2>

<p>配置好了模块后，剩下的就是要实现一个KSP processor了。</p>

<h3>实现Processor</h3>

<p>大部分工作plugin已经做好了，我们需要做的就是实现一些接口。有两个需要实现，一个是<a href="https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/processing/SymbolProcessorProvider.kt">SymbolProcessorProvider</a>，另一个则是<a href="https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/processing/SymbolProcessor.kt">SymbolProcessor</a>。</p>

<p>SymbolProcessorProvider相当于是processor的一个工厂方法，我们实现它的create方法，返回一个SymbolProcessor实例，一个典型的实现：</p>

<pre><code class="Kotlin">class MyProcessorProvider : SymbolProcessorProvider {
    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
        return MyProcessor(environment.codeGenerator)
    }
}
</code></pre>

<p>它就相当于一个工厂方法，把上下文环境传给processor，SymbolProcessor是重点，我们需要实现它的process方法，针对感兴趣的符号进行处理，比如用<a href="https://square.github.io/kotlinpoet/">KotlinPoet</a>生成代码，这里是发挥创造力的地方：</p>

<pre><code class="Kotlin">class MyProcessor(private val generator: CodeGenerator) : SymbolProcessor {
    override fun process(resolver: Resolver): List&lt;KSAnnotated&gt; {
        val annotatedClasses = resolver
            .getSymbolsWithAnnotation(MyAnnotation::class.java.name)
            .filterIsInstance&lt;KSClassDeclaration&gt;()

        for (aclass in annotatedClasses) {
            val packageName = aclass.packageName.asString()
            val className = aclass.simpleName.asString()
            val methods = aclass.getDeclaredFunctions())
            // ...
         }
        return emptyList()
    }
}
</code></pre>

<h3>注册Processor</h3>

<p>实现了process后还需要把process注册一下，否则ksp plugin无法找到这个processor。在processor module与代码同级文件夹下新建文件『resources/META-INF/services/com.google.devtools.ksp.processing.SymbolProcessorProvider』，然后把刚才实现的provider的完整类名，写在文件里，如果是使用IDE一般都会有提示的。</p>

<pre><code class="Kotlin">// myprocessor/src/main/
//    |-- kotlin/net/toughcoder/
//              |-- MyProcessorProvider.kt
//              |-- MyProcessor.kt
//    |-- resources/META-INF/services/
//              |-- com.google.devtools.ksp.processing.SymbolProcessorProvider
// file: resources/META-INF/services/com.google.devtools.ksp.processing.SymbolProcessorProvider
net.toughcoder.MyProcessorProvider
</code></pre>

<h2>为啥要用KSP</h2>

<p>目前来说KSP最主要应用仍然 是注解的处理，以及配合注解进行代码生成。通过前面一篇<a href="https://juejin.cn/post/7355024828262334501">关于注解的文章</a>中我们知道，注解的处理已经有了一个专门的工具了叫做kapt，就目前来说KSP能做的事情kapt也都能做，它们都是用于编译时代码处理以及代码生成，都能处理注解。那么，在已经有了kapt的前提下，为啥还要搞KSP呢？</p>

<p>kapt虽然是Kotlin的注解处理器，但是它保持Java的兼容性，它直接复用了Java的<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/AbstractProcessor.html">AbstractProcessor</a>，要依赖于Java的annotation procssor以及javac，只适用于Kotlin/JVM，其他target用不起来，因此它并不能算是Kotlin原生的工具，对Kotlin的特性支持不友好。再有就是，为了保持与javac的兼容性，它的处理速度很慢，必须先把Kotlin代码转成javac能认识的标准Java代码，这肯定会有不必要的性能开销。基于这些限制，kapt已经停止开发了，处于维护状态了，不会再添加新功能了。<strong>省流点来说，kapt是以Java角度来看待输入代码的（即也要处理的源码），而KSP是以Kotlin角度</strong>。</p>

<p>KSP则是Kotlin原生的，基于Kotlin开发的，且是为了Kotlin开发的，并不受限于javac，因此所有的Kotlin目标平台都能用。并且对Kotlin的特性支持的很友好。它的处理速度也较kapt有提升，因为不必要做编码转换了，省了一道工序。从官方给出的数据看至少能省25%的编译时间。另外，KSP的API使用起来更加的Kotlin友好一些SymbolProcessor传递过来的<a href="https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/processing/Resolver.kt">Resolver</a>有很方便的接口可以取得被标的类，而且符号对象是<a href="https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/symbol/KSClassDeclaration.kt">KSClassDeclaration</a>，它可以方便的取一个Kotlin类的相关的其他符号，如包名，类名，方法等。</p>

<h2>总结</h2>

<p>通过本文我们理解了KSP的概念，并学会了如何在项目中配置KSP， 以及如何实现一个KSP processor。KSP视Kotlin代码为一系列的静态符号，对Kotlin语言特性支持友好，处于活跃的开发状态且被官方大力支持，因此应该尽早转向KSP。并且相信KSP能做的事情会越来越多。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/ksp-overview.html">Kotlin Symbol Processing API</a></li>
<li><a href="https://developer.android.com/build/migrate-to-ksp">Migrate from kapt to KSP</a></li>
<li><a href="https://www.kodeco.com/33148161-write-a-symbol-processor-with-kotlin-symbol-processing">Write a Symbol Processor with Kotlin Symbol Processing</a></li>
<li><a href="https://www.codecentric.de/wissens-hub/blog/kotlin-symbol-processing-introduction">An Introduction to Kotlin Symbol Processing</a></li>
<li><a href="https://kt.academy/article/ak-ksp">Kotlin Symbol Processing</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin Annotation Made Easy]]></title>
    <link href="https://alexhilton.github.io/blog/2024/04/09/kotlin-annotation-made-easy/"/>
    <updated>2024-04-09T22:14:10+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/04/09/kotlin-annotation-made-easy</id>
    <content type="html"><![CDATA[<p>注解（Annotations）允许我们在代码中添加元数据（Meta data），提供代码以外的信息，这些元数据可以在编译时被编译器或其他工具读取和处理。 Kotlin作为一种功能强大且易于使用的多范式通用编程语言，注解（Annotations）是其核心特性之一。在Kotlin中，注解的使用非常广泛，可以用于框架设计、代码生成、测试、依赖注入等多个方面。今天就来学习一下Kotlin中注解的使用方法。</p>

<p><a href=""><img src="https://appmaster.dev/wp-content/uploads/2023/03/Understan-Kotlin-Annotations-1024x536.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>Kotlin是基于JVM的编程语言，并且可以与Java互通使用，因此事先了解一下Java的注解对于学习Kotlin的注解是非常有帮助的。可以阅读一下前面的文章来<a href="https://juejin.cn/post/7353138889458319412">回顾Java语言的注解</a>。</p>

<h2>什么是注解</h2>

<p>注解是元编程的一种实现方式，它并不直接改变代码，而是为代码提供额外的数据。注解不能单独存在，必须与代码中的其他元素一起使用。在Kotlin中，注解要使用符号『@』后面加一个已定义的注解名字，如『@Deprecated』。注解在Kotlin中的使用非常广泛的，相信有过代码经验的同学都至少看过大量的注解。</p>

<h2>注解的使用方法</h2>

<p>注解的使用是非常的直观的，在需要的代码元素（类，变量，属性，函数，参数等等）加上想要使用的注解就可以了：</p>

<pre><code class="Kotlin">@Fancy class Foo {
    @Fancy fun baz(@Fancy foo: Int): Int {
        return (@Fancy 1)
    }
}
</code></pre>

<p>Kotlin的注解也可以用在lambda上面，这实际上相当于应用于lambda函数生成的函数实例的invoke()上面：</p>

<pre><code class="Kotlin">annotation class Suspendable

val f = @Suspendable { Fiber.sleep(10) }
</code></pre>

<h3>注解的使用点目标</h3>

<p>由于Kotlin最终要编译成为字节码，运行在JVM上，所以它必须符合Java的规范。但语法上Kotlin与Java还是不一样的，比如一句Kotlin代码可能会相当于Java的好几句，换句话说一个Kotlin语句中的元素可能会对应着Java中的好几个。这可能会带来问题。</p>

<p>注解并不能单独出现，它必须作用到某一个语法上的元素，因为Kotlin语法元素可能会对应着几个Java语法元素，那么注解可能会被用在多个目标元素上面。为了能精确的指定注解的作用目标，可以使用『使用点目标』（use-site targets）来标记具体的目标元素：</p>

<pre><code class="Kotlin">class Example(@field:Ann val foo,    // annotate Java field
              @get:Ann val bar,      // annotate Java getter
              @param:Ann val quux)   // annotate Java constructor parameter
</code></pre>

<p>这里面『Ann』是一个注解，其前面的『field/get/param』就用以指定具体的注解目标元素。可用的使用点目标有这些：</p>

<ul>
<li>file</li>
<li>property</li>
<li>field</li>
<li>get 属性的getter</li>
<li>set 属性的setter</li>
<li>receiver 扩展函数或者扩展属性的底层对象</li>
<li>param 构造函数的参数</li>
<li>setparam 属性setter的参数</li>
<li>delegate 指存储着受托对象实例的域成员</li>
</ul>


<p>『receiver』指的是扩展函数发生作用的实例，比如说：</p>

<pre><code class="Kotlin">fun @receiver:Fancy String.myExtension() { ... }
</code></pre>

<p>那么，这个注解『Fancy』将作用于具体调用这个扩展方法myExtension的String实例上面。</p>

<p>这些具体的使用点目标可以精确的指定JVM认识的元素上面，可以发现，它们远比定义注解时的<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/">@Target</a>要丰富。如果不指定具体的使用点目标，那么就会按照@Target指定的目标，如果有多个目标，会按如下顺序选择：</p>

<ul>
<li>param</li>
<li>property</li>
<li>field</li>
</ul>


<h3>兼容Java注解</h3>

<p>Kotlin是完全兼容Java注解，也就是说Java中定义的注解，在Kotlin中都可以直接使用。</p>

<pre><code class="Java">// Java
public @interface Ann {
    int intValue();
    String stringValue();
}
</code></pre>

<pre><code class="Kotlin">// Kotlin
@Ann(intValue = 1, stringValue = "abc") class C
</code></pre>

<p>虽然可以直接用，但毕竟Kotlin的语法要丰富得多，所以为了避免歧义，要使用前面介绍的使用点目标来精确指定注解的作用目标。</p>

<h2>自定义注解</h2>

<p>使用关键字『annotation』来声明自定义注解，如：</p>

<pre><code class="Kotlin">annotation class Fancy
</code></pre>

<p>之后就可以使用注解了：</p>

<pre><code class="Kotlin">@Fancy class Foo {
    @Fancy fun baz(@Fancy foo: Int): Int {
        return (@Fancy 1)
    }
}
</code></pre>

<p>光这样声明还不够，还需要定义注解具体的内容，如可修饰的目标和行为特点，这就需要用到元注解（Meta annotations），也即定义注解时所需要的注解。</p>

<h3>元注解（Meta annotations）</h3>

<h4>@MustBeDocumented</h4>

<p>用于指定此注解是公开API的一部分，必须包含在文档中。</p>

<h4>@Repeatable</h4>

<p>允许在同一个地方多次使用注解。</p>

<h4><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-target/">@Target</a></h4>

<p>用于指定此注解可以应用到哪些程序元素上面，如类和接口，函数，属性和表达式。</p>

<ul>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-c-l-a-s-s.html#kotlin.annotation.AnnotationTarget.CLASS">AnnotationTarget.CLASS</a> - 类型，包括类型原型（classes），接口，对象，注解类型</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-p-r-o-p-e-r-t-y.html#kotlin.annotation.AnnotationTarget.PROPERTY">AnnotationTarget.PROPERTY</a> - 属性</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-f-i-e-l-d.html#kotlin.annotation.AnnotationTarget.FIELD">AnnotationTarget.FIELD</a> - 域变量</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-l-o-c-a-l_-v-a-r-i-a-b-l-e.html#kotlin.annotation.AnnotationTarget.LOCAL_VARIABLE">AnnotationTarget.LOCAL_VARIABLE</a> - 局部变量（本地变量）</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-v-a-l-u-e_-p-a-r-a-m-e-t-e-r.html#kotlin.annotation.AnnotationTarget.VALUE_PARAMETER">AnnotationTarget.VALUE_PARAMETER</a> - 参数</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-c-o-n-s-t-r-u-c-t-o-r.html#kotlin.annotation.AnnotationTarget.CONSTRUCTOR">AnnotationTarget.CONSTRUCTOR</a> - 构造函数</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-f-u-n-c-t-i-o-n.html#kotlin.annotation.AnnotationTarget.FUNCTION">AnnotationTarget.FUNCTION</a> - 函数</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-p-r-o-p-e-r-t-y_-g-e-t-t-e-r.html#kotlin.annotation.AnnotationTarget.PROPERTY_GETTER">AnnotationTarget.PROPERTY_GETTER</a> - 属性的getter</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-p-r-o-p-e-r-t-y_-s-e-t-t-e-r.html#kotlin.annotation.AnnotationTarget.PROPERTY_SETTER">AnnotationTarget.PROPERTY_SETTER</a> - 属性的setter</li>
</ul>


<h4>@Retention</h4>

<p>指定注解信息保存到代码生命周期的哪一阶段，编译前，编译时还是运行时。默认值是运行时，也即在运行时注解是可见的。</p>

<ul>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-retention/-s-o-u-r-c-e.html">AnnotationRetention.SOURCE</a> - 只在源码过程中保留，并不会出现在编译后的class中（二进制文件中）。</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-retention/-b-i-n-a-r-y.html">AnnotationRetention.BINARY</a> - 会在class中保留，但对于运行时并不可见，也就是通过反射无法得到注解。</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-retention/-r-u-n-t-i-m-e.html">AnnotationRetention.RUNTIME</a> - 注解会保留到运行时，运行时的操作如反射可以解析注解，这是默认的@Rentention值。</li>
</ul>


<h3>构造方法（Constructors）</h3>

<p>与Java很不同的是Kotlin的注解更加的像常规的类（class），注解也可以有构造函数：</p>

<pre><code class="Kotlin">annotation class Special(val why: String)

@Special("example") class Foo {}
</code></pre>

<p>构造函数可以使用的参数包括：</p>

<ul>
<li>基础数据类型Int，Long，Float和String等</li>
<li>类型原型（即class，如Foo::class）</li>
<li>枚举类型</li>
<li>其他注解类型</li>
<li>由以上类型组成的数组</li>
</ul>


<p>注意不能有可能为空（如String?）的类型，当然也不可以传递null给注解的构造函数。还有，如果用其他注解作为参数时，注解名字前就不用再加『@』了：</p>

<pre><code class="Kotlin">annotation class ReplaceWith(val expression: String)

annotation class Deprecated(
        val message: String,
        val replaceWith: ReplaceWith = ReplaceWith(""))
</code></pre>

<h3>注解的实例化（Instantiation）</h3>

<p>在Kotlin中可以通过调用注解的构造函数来实例化一个注解来使用。而不必非要像Java那样用反射接口去获取。</p>

<pre><code class="Kotlin">annotation class InfoMarker(val info: String)

fun processInfo(marker: InfoMarker): Unit = TODO()

fun main(args: Array&lt;String&gt;) {
    if (args.isNotEmpty())
        processInfo(getAnnotationReflective(args))
    else
        processInfo(InfoMarker("default"))
}
</code></pre>

<h2>注解解析</h2>

<p>Kotlin是基于JVM的编程语言，最终要编译成为字节码运行在JVM上面，所以注解的解析与Java语言注解解析是一样的，可以在运行时用反射API来解析注解。关于Java注解解析可以<a href="/blog/2024/03/24/java-annotations-made-easy/">参考另一篇文章</a>，因为运行时注解解析用处并不大，并且也不复杂，看一个简单&#127792;就可以了：</p>

<pre><code class="Kotlin">class Item(
  @Positive val amount: Float, 
  @AllowedNames(["Alice", "Bob"]) val name: String)

val fields = item::class.java.declaredFields
for (field in fields) {
    for (annotation in field.annotations) {
        if (field.isAnnotationPresent(AllowedNames::class.java)) {
            val allowedNames = field.getAnnotation(AllowedNames::class.java)?.names
         }
    }
}
</code></pre>

<h2>注解处理器</h2>

<p>注解是元编程的一种方式，它最大的威力是在编译前进行代码处理和代码生成。除了注解的定义和使用外，更为关键的注解的处理需要用到注解处理器（Annotation Processor），并且要配合编译器插件<a href="https://kotlinlang.org/docs/kapt.html">kapt</a>和<a href="https://kotlinlang.org/docs/ksp-overview.html">KSP</a>来使用。</p>

<p>需要注意，因为注解是JVM支持的特性，在编译时需要借助javac编译器，所以只有运行目标是JVM时注解才有效。因为Kotlin是支持编译为不同运行目标的，除了JVM外，还有JavaScript和Native。</p>

<h3>实现注解处理器</h3>

<p>与Java的注解处理器类似，在定义好注解后，还需要实现一个注解处理器，以对注解进行处理。一般情况下实现AbstractProcessor就可以了。在其process方法中过滤出来想要处理的注解进行处理，比如使用<a href="https://github.com/square/kotlinpoet">KotlinPoet</a>生成代码。</p>

<p>另外，还要注意，注解处理器必须在一个单独的module中，然后添加为使用此注解module的依赖，这是因为注解的处理是在编译前，所以处理器需要在正式编译前就已经编译好。</p>

<pre><code class="kotlin">package net.toughcoder

import javax.annotation.processing.*
import javax.lang.model.element.*
import javax.tools.Diagnostic

@SupportedAnnotationTypes("com.example.MyAnnotation")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
class MyAnnotationProcessor : AbstractProcessor() {

    override fun process(annotations: MutableSet&lt;out TypeElement&gt;, roundEnv: RoundEnvironment): Boolean {
        for (annotation : annotations) {
            for (element : roundEnv.getElementsAnnotatedWith(annotation)) {
                val myAnnotation = element.getAnnotation(MyAnnotation::class.java)
                val message = "Processing element with annotation MyAnnotation(value = ${myAnnotation.value})"
                processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, message, element)
            }
        }
        return true
    }
}
</code></pre>

<p>从例子中可以看到，其实Kotlin中的注解处理器（Processor）直接就是用的Java的，所以在用的时候最好加上Java语言的版本。</p>

<h3>注册注解处理器</h3>

<p>为能正常使用注解处理器，需要把注解处理器放在一个单独的Module里，并作为其他module的依赖，这样能确保它在编译被依赖项时正常使用，被依赖项也即注解使用的地方。</p>

<p>需要在处理器module中与代码平级的文件夹创建resources文件夹，创建一个子文件夹META-INF，再在META-INF创建一个子文件services，在里面创建一个文件名为『javax.annotation.processing.Processor』，然后把实现的注解处理器的完整类名，写在这个文件的第一行：</p>

<pre><code class="Kotlin">// file: resources/META-INF/services/javax.annotation.processing.Processor
net.toughcoder.MyAnnotationProcessor
</code></pre>

<h3>使用注解处理器</h3>

<p><img src="https://bigknol.com/wp-content/uploads/2023/07/android-ksp-kapt-768x439.png" alt="" /></p>

<p>需要做两个事情，一个是把注解处理器添加为其他项目或者module的依赖。然后再用<a href="https://kotlinlang.org/docs/kapt.html">专门处理注解处理器的编译器插件</a>使用注解处理器。</p>

<pre><code class="Groovy">dependencies {
    implementation(kotlin('stdlib'))
    kapt 'net.toughcoder:my-annotation-processor:1.0.0'
}

kapt {
    useBuildCache = true
    annotationProcessors = ['net.toughcoder:my-annotation-processor:1.0.0']
}
</code></pre>

<h2>总结</h2>

<p>本文介绍了Kotlin中注解的基本语法、使用方法和处理过程。通过自定义注解处理器，我们可以在编译时处理注解并生成相应的代码或执行其他任务。注解是Kotlin编程中的核心特性，它可以帮助我们提高代码的可读性、可维护性和可扩展性。大部分的注解都在编译时，也不会对性能产生影响，所以可以放心大胆的用注解来提升开发效率。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/annotations.html">Annotations</a></li>
<li><a href="https://www.baeldung.com/kotlin/annotations">Kotlin Annotations</a></li>
<li><a href="https://kt.academy/article/ak-annotation-processing">Annotation Processing</a></li>
<li><a href="https://www.kodeco.com/8574679-annotation-processing-supercharge-your-development">Annotation Processing: Supercharge Your Development</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
