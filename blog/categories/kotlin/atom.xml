<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Kotlin | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/kotlin/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2023-09-13T21:05:02+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[More About Kotlin Functions]]></title>
    <link href="http://toughcoder.net/blog/2023/09/13/more-about-kotlin-functions/"/>
    <updated>2023-09-13T20:52:36+08:00</updated>
    <id>http://toughcoder.net/blog/2023/09/13/more-about-kotlin-functions</id>
    <content type="html"><![CDATA[<p>Kotlin中的函数是一级对象，除了常规的函数式编程以外，还支持一些非常灵活的特殊用法，可以大大增强代码的可读性和简洁性，让代码更加的优雅，在业界顶级的库如Compose中有大量的应用，今天就来学习一些，以扫清学习Compose的障碍。</p>

<p><a href=""><img src="https://www.callicoder.com/static/faf261ddf8d3f25d8c48da997d9a2dc1/kotlin-functions.png" title="auto auto" ></a></p>

<!-- more -->


<h2><a href="https://kotlinlang.org/docs/extensions.html">Extension Functions</a></h2>

<p>与传统的编程语言如C/C++，Java或者Python最大的不同就是，Kotlin对于类的扩展提供了相当灵活的方式。像Java和Python除了标准的继承方式以外，就只能用注解和Decorator。但对于Kotlin还可以用<a href="https://kotlinlang.org/docs/extensions.html">Extensions</a>这一方式。无论是注解还是Decorator，它的使用方式还是比较笨拙的，可以明显的看出来是额外定义的函数，与原Class是没啥关系的。</p>

<p><img src="https://thetechstack.net/assets/images/banners/kotlin-extension-function.png" alt="" /></p>

<p>比如说，对于整数来说，我们通常会有求绝对值，通常可以这样写：</p>

<pre><code class="kotlin">fun abs(a: Int) = if (a &lt; 0) -a else a
</code></pre>

<p>然后，这样使用：</p>

<pre><code class="kotlin">val aa = abs(a)
</code></pre>

<p>但在Kotlin中，有更优雅的方式：</p>

<pre><code class="kotlin">fun Int.abs() = if (this &lt; 0) -this else this

println((-4).abs())
println(100.abs())
</code></pre>

<p>这就是Extension functions，这样定义了后，可以像整数类型本身定义的方法那样直接在其对象上面调用。</p>

<h3>如何定义Extension functions</h3>

<p>Extension functions是针对Class的，或者一个Type的，指定目标Class名字，和参数就可以了，在函数的内部this就是调用函数时的对象。
<code>kotlin
fun &lt;ClassName&gt;.&lt;function name&gt;(params...): return type {
    // this is the function's receiver, which is the object when function invoked.
    // function implementation
}
</code>
需要注意，Extension functions必须是针对Class的。</p>

<h3>理解Extension functions</h3>

<p>Extension functions并没什么高深和神秘的东西，它只是相当于一个static函数，接收目标Class的对象而已，比如说：</p>

<pre><code class="kotlin">fun Shape.area(): Int = this.length * this.width

fun area(shape: Shape): Int = shape.length * shape.width
</code></pre>

<p>其实这两个函数是完全一样的，上面的那个Extension function其实就相当于后面的那个常规函数。只不过在函数的调用上面更加的方便，看起来更像是目标Class提供的方法一样，更优雅一些。</p>

<h3>Extension function的作用域</h3>

<p>Extension function并不会真的对目标Class做任何修改，它只是相当于你自己定义的一个函数。所以，它的作用域就是你定义的函数的作用域，如果你是在一个文件中定义的，那么它的作用域就是导入了这个文件的地方；如果是在一个类中的，那作用域就是这个类。</p>

<p>另外的问题就是，假如在多个地方定义了相同的Extension function，会发生什么呢，相同的意思就是目标Class一样，函数名字也一样，所做的事情也一样，仍是把它当成普通函数来理解就行，按照虚拟机懒惰加载的原则，应该是第一个被引用到的Extension function生效。</p>

<h3>参考资料</h3>

<ul>
<li><a href="https://www.baeldung.com/kotlin/extension-methods">Extension Functions in Kotlin</a></li>
<li><a href="https://marketsplash.com/tutorials/kotlin/kotlin-extension-function/">Kotlin Extension Function: How To Implement And Use It</a></li>
<li><a href="https://www.geekailab.com/doc/as/book/docs/Part1/Android%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87Kotlin%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/KotlinExtensions.html">让人爱不释手的Kotlin扩展（Extensions）技术探Extensions秘与应用</a></li>
<li><a href="https://www.jianshu.com/p/314cdb1603fc">Kotlin 扩展函数及原理</a></li>
<li><a href="https://juejin.cn/post/6935027613542907941">Kotlin 编程 #3 扩展函数（终于知道为什么 with 用 this，let 用 it）</a></li>
</ul>


<h2><a href="https://kotlinlang.org/docs/functions.html#infix-notation">Infix Functions</a></h2>

<p>准确的来说是Infix notation，它是一种执行函数的特殊方式，并不是定义了特殊的函数。也就是说某个函数被infix修饰了后，就可以用更为简洁的方式来调用它。常规的函数执行（或者说调用）是用函数名字加上括号，括号里面是参数，比如foo()，bar(&ldquo;here&rdquo;)。而infix方式则可以是 <code>参数1 函数名 参数2</code>这种方式，也即与常规的函数调用完全不一样。看起来像是语言本身的关键字一样。</p>

<p><img src="https://www.fusebes.com/wp-content/uploads/2021/03/Post-Banners-FuseBase-17-1.png" alt="" /></p>

<p>比如，移位并不是运算符，也不是关键字，而是一个被infix修饰的二元参数函数：</p>

<pre><code class="kotlin">finfix un Int.shr(x: Int): Int {...}

8.shr(2) // 这样正常调用也完全可以，把整数8右移2位
8 shr 2 // 这是infix式的用法，其实是等同于上面的函数调用
</code></pre>

<p>infix必须是Extension function，并且只能有一个参数，算上Extension function的接收对象，其实一共是2个参数。标准库中也定义了大量的infix，如委托用的by。以及像一些DSL中的函数，都会定义成infix，以让代码更简洁。</p>

<p>总之，下次再见到a x b这种写法时，不用害怕，并不是有了新的关键字，这里的x是infix，把它当成函数调用x(a, b)就好了。</p>

<h3>参考资料</h3>

<ul>
<li><a href="https://www.programiz.com/kotlin-programming/infix-notation">Kotlin Infix Function Call</a></li>
<li><a href="https://www.baeldung.com/kotlin/infix-functions">Infix Functions in Kotlin</a></li>
</ul>


<h2><a href="https://kotlinlang.org/docs/inline-functions.html">inline Functions</a></h2>

<p><img src="https://cdn.educba.com/academy/wp-content/uploads/2021/04/Kotlin-Inline-Function.jpg" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Kotlin Scope Functions]]></title>
    <link href="http://toughcoder.net/blog/2023/04/12/understanding-kotlin-scope-functions/"/>
    <updated>2023-04-12T15:06:18+08:00</updated>
    <id>http://toughcoder.net/blog/2023/04/12/understanding-kotlin-scope-functions</id>
    <content type="html"><![CDATA[<p>Kotlin是基于JVM衍生出来的新一代通用编程语言，它的目标是简洁，可读和高效，这里的高效并不是代码的运行效率高，而是说项目的开发效率高。Kotlin有太多的小巧的新特性（在Java眼中就是语法糖），比如在Kotlin中有几个作用和用法都非常接近的函数apply/with/run/let/also，它们的正统名字是<strong>作用域函数</strong>(Scope functions)，今天就来学习一下这些函数的使用方法和具体区别。</p>

<p><a href=""><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.eDXYmyuQp-E1wGqx4WnhIgHaEK?pid=ImgDet&amp;rs=1" title="auto auto" ></a></p>

<!-- more -->


<p>Java是面向对象的王牌语言，它的特点是严谨和教条，Java写出来的代码学过Java的人大多都看得懂，所以规模以上的项目现在基本上都用Java，这对维护是有好处的。但Kotlin不一样，它有非常多的特性，融合了众多编程语言的特点，同样一件事情，可能有无数种写法，虽然号称是用标准Kotlin语言实现的，但是即使学过Kotin的人也看不懂。比如虽然你学会了Function，Object和lambda，以及像inline function和extension，但是如果用apply和with写几段方法，你就看不懂了，这就导致了Kotlin虽然易于上手，但是要想学透和提高曲线 就会陡峭许多。</p>

<p><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.pVewkBVy74Ivnoumj0Gx0wHaF8?pid=ImgDet&amp;rs=1" alt="" /></p>

<h2>到底是个啥</h2>

<p>先来看一下Scope function到底是什么，它们的作用是在一个对象上执行一段代码，我们来看一个简单的例子：有一个类是Person，它有一些属性和方法，我们想对它的一个对象进行操作，通常会这样做：</p>

<pre><code class="kotlin">val alice = Person(name="Alice", age=20,addr="Amsterdam")
println(alice)
alice.moveTo("London")
alice.incrementAge(2)
println("Two years later ${alice.name} is at ${alice.addr}")
</code></pre>

<p>但使用scope function，我们可以这样做：</p>

<pre><code class="kotlin">val alice = Person("Alice", 20, "Amsterdam").apply {
    println(this)
    moveTo("London")
    incrementAge(2)
}
println("Two years later ${alice.name} is at ${alice.addr}")

//Person(name='Alice', age=20, addr='Amsterdam')
//Two years later Alice is at London
</code></pre>

<p>这两段代码的输出是完全一样的，但是第二段明显要简洁很多这就是scope function的作用，仔细看apply后面的lambda块，它是一个scope，犹如在对象的类定义之中，在这个代码块中可以直接引用对象的方法，而不是像常规的那样使用对象的引用。</p>

<p><em>注意</em>：如果不是很尾部lambda的同学可以先行参考<a href="http://toughcoder.net/blog/2023/01/24/understanding-kotlin-functions/">另外一篇文章</a>，以加强理解。</p>

<h2>理解Scope</h2>

<p>作用域也可以理解为一个代码块的上下文，也就是说在一个代码中，可以直接使用的东西，环境变量之于进程，系统框架为应用准备的基础对象，都可以视为一种scope。最为明显的就是类的定义，在类中，我们可以引用this指针来代表当前对象super指针来代表基类，这也是一种scope。lambda捕获的闭包也是一种scope。</p>

<p>Kotlin的scope functions就是把某一个对象当作代码块的scope，代码块中的代码可以方便的使用这个对象。</p>

<h2>Scope funtions的作用</h2>

<p>如同开头讨论的，能用scope function写出来的东西，用常规方式也一样可以做到，那到底图个啥呢？用scope function的方式代码变得更加的简洁和紧凑，我们把针对某一对象的密集操作集中在一起放入一个代码块中，会更加的内聚和紧凑，易于扩展和维护。但也要注意不能滥用，代码块中只应该写与对象相关的操作，与scope对象不相干的事情是绝对不应该放入其中的。</p>

<h2>Scope functions</h2>

<p>主要有6个，它们的应用主体都是一个对象，也就是要在一个对象上面调用这些函数，然后提供一个代码块（lambda）：</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> Scope Function </th>
<th style="text-align:center;"> Object reference </th>
<th style="text-align:center;"> Return value </th>
<th style="text-align:center;"> Description </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> let </td>
<td style="text-align:center;"> it </td>
<td style="text-align:center;"> lambda result </td>
<td style="text-align:center;"> Extension function </td>
</tr>
<tr>
<td style="text-align:center;"> run </td>
<td style="text-align:center;"> this </td>
<td style="text-align:center;"> lambda result </td>
<td style="text-align:center;"> Extension function </td>
</tr>
<tr>
<td style="text-align:center;"> run </td>
<td style="text-align:center;"> _ </td>
<td style="text-align:center;"> lambda result </td>
<td style="text-align:center;"> No object in the scope </td>
</tr>
<tr>
<td style="text-align:center;"> with </td>
<td style="text-align:center;"> this </td>
<td style="text-align:center;"> lambda result </td>
<td style="text-align:center;"> Take the object as an argument </td>
</tr>
<tr>
<td style="text-align:center;"> apply </td>
<td style="text-align:center;"> this </td>
<td style="text-align:center;"> context object </td>
<td style="text-align:center;"> Extension function </td>
</tr>
<tr>
<td style="text-align:center;"> also </td>
<td style="text-align:center;"> it </td>
<td style="text-align:center;"> context object </td>
<td style="text-align:center;"> Extension function </td>
</tr>
</tbody>
</table>


<h2>它们的区别和如何选用</h2>

<h3>with不是一个extension函数</h3>

<p>其他几个都是extension函数，所以with一定要把scope object作为参数传入。</p>

<h3>scope对象的引用方式</h3>

<p>对于scope function来说scope对象都会作为一个context object，可以在lambda块中使用，有些是作为this指针，有些是作为lambda的默认参数名字也即it指针，但它们都指向context object，本质上是没有区别的只是指针的名字一个是this一个是it。但是，跟类的定义scope是一样的，this指针是可以省略的，但如果it作为参数，则是不能省略的，具体来说，比如说，用apply时，代码块中是this指针，那么可以直接这样写：</p>

<pre><code class="kotlin">val alice = Person("Alice", 20, "Amsterdam").apply {
    println(this)
    moveTo("London")
    incrementAge(2)
}
</code></pre>

<p>当然 你也可以显式的把this写出来，this.moveTo(&ldquo;London&rdquo;)，但这就麻烦多了，何必呢。所以apply最合适的场景是对对象本身的操作，如赋值和修改属性。</p>

<p>但如果是用also，就必须用it了，这个不能省，因为它是对scope对象的引用：
<code>kotlin
alice.also {
    println("Two years later ${it.name} is at ${it.addr}")
}
</code>
所以，also最适合的不是对对象本身的操作，而是一些与对象相关的副作用，如打印日志等。</p>

<h3>返回值不同</h3>

<p>这坨Scope functions是一个函数，它是有返回值的，这个返回是不一样的，apply/also返回的是context object，其他几个则是返回lambda中的返回值也就是lambda的最后一个表达 式或者lambda中显式的return语句。</p>

<p>所以，如果是想继续使用scope object，那么就要用apply/also，如果想得到某个其他值就要用let/run/with，即使说不在乎函数的返回值时，这时也推荐使用also，因为假如后续想继续添加其他操作时，可以直接在后面链接上其他的scope function。其他返回值的let/run/with一般用在一组操作的确定性的终点上面，比如统计均值，那最后的均值计算可以用run，比如文件操作，读写都可以用with。</p>

<h2>注意事项</h2>

<p>任何技术和工具要深刻理解它们的应用范围和使用场景以避免滥用，要用到恰到好处才能发挥最大的价值。对于一些非必须的东西，更是如此。</p>

<p>Scope functions是应用于对象上面的，所以前提是当你需要对一个对象进行一些操作时，才可以使用scope functions，具体选择哪一个参考 上面一节的讨论。另外，就是放入代码块中的操作必须全部是scope对象相关的才可以。一个scope function中只能是一组相关的操作，不同组的操作要启用不同的scope functions。比如说网络请求response的处理，可以分为服务器状态码和返回实体的检测，转成具体数据，打印日志这么三个scope functions，而不是全放进一个里面。</p>

<p>总而言之，要视具体的需求和场景，并基于场景选择合适的scope function，切忌过度使用。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/scope-functions.html">Scope functions</a></li>
<li><a href="https://blog.mindorks.com/using-scoped-functions-in-kotlin-let-run-with-also-apply/">Using Scoped Functions in Kotlin - let, run, with, also, apply</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/kotlin-let-run-also-apply-with">Kotlin let, run, also, apply, with</a></li>
<li><a href="https://shusheng007.top/2020/10/02/1-6/">秒懂Kotlin之彻底掌握Scope Functions (apply, also,let,run,with)</a></li>
<li><a href="https://www.jianshu.com/p/5c4a954d2b2c">Kotlin之let,apply,run,with等函数区别</a></li>
<li><a href="https://juejin.cn/post/6868179386344931342">Kotlin学习：run、with、apply、also、let的区别</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Kotlin Based DSL]]></title>
    <link href="http://toughcoder.net/blog/2023/02/14/understanding-kotlin-based-dsl/"/>
    <updated>2023-02-14T16:51:58+08:00</updated>
    <id>http://toughcoder.net/blog/2023/02/14/understanding-kotlin-based-dsl</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL Domain Specific Langauge</a>是解决特定领域内问题的编程语言，它的特点通常是简洁，虽不通用，但可读性强，呈描述式和声明式，比较典型的例子就是SQL语句和正则表达式，以及一些文本处理工具如Sed和AWK。与之对应的就是通用编程语言<a href="https://en.wikipedia.org/wiki/General-purpose_language">GPL General Purpose Language</a>，能解决几乎所有的计算机问题，没有为特定领域进行定制，但语句可读性远不及DSL，它们的语句一般都是命令式的，如熟悉的C/C++, Java和Python等。</p>

<p><a href=""><img src="https://cdn.educba.com/academy/wp-content/uploads/2022/07/Kotlin-DSL.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>GPL中的DSL痛点</h2>

<p>DSL的优点是<strong>声明式的，描述式的</strong>，并不在意<strong>具体细节的实现</strong>，比如像SQL语句，我只关心我想要什么，具体如何实现的是底下工具的事情：</p>

<pre><code class="SQL">select (id, name, address)
    where name = "John" and age &lt;= 10
    from classlist
</code></pre>

<p>但，当在GPL，通用编程语言中解决DSL问题时，就会很蛋疼，在任何一个编程语言中实现一个SQL查询 的接口都会相当的笨拙和难用，要么需要创建很多个对象，要么需要传递一大堆令人费解的参数：</p>

<pre><code class="Java">    Cursor cursor = query(uri, projects, where, whereArgs, sortby);
</code></pre>

<p>可读性非常的差，假如能写成DSL那样，可读性会大大的增强。</p>

<h2>DSL式的API</h2>

<p>在Kotlin中，可以写成这样：</p>

<pre><code class="kotlin">query {
    from "classlist"
    where {
        "name" eq "John"
        "age" lessEq 10
    }
}
</code></pre>

<p>可读性大大加强，这样的API使用起来也会如丝般顺滑，因为它符合DSL：描述性的，声明式的，不关心具体实现细节，只关注想要什么。</p>

<h2>背后原理</h2>

<p>Kotlin借助尾部lambda，infix函数，扩展函数。整体来就其实是一个函数调用，因为Kotlin函数最后一个参数如果是lambda时可以写在函数调用之外，所以，一层一层的DSL，其实就是函数调用。</p>

<p>再借助扩展函数和infix函数，可以把另外一些函数调用写成DSL式，比如像二进制按位或运算a or b等同于a.or(b)，这也是一个函数调用，但可读性大大加强。可以像写不作文一样的来写代码。</p>

<p>总之，见到DSL式的语句时不用惊慌，它是合法的Kotlin函数调用，把它理解成为函数调用就可以了。</p>

<h2>合理使用</h2>

<p>虽然DSL式的API能大大提高可读性，像真正的DSL一样去使用，但也要注意合理使用，不能滥用。我们要正向的解决问题，当遇到特定领域的问题时，就可以定义和实现出一套符合DSL的API。也就是说我们要利用Kotin语言提供的能力来实现DSL式的API去解决特定领域的问题。就像Android的布局，就可以定义出一套DSL式的API，这就是当时比较火的<a href="https://github.com/Kotlin/anko">anko</a>(现已废弃了)，以及像涉及HTML，涉及SQL的相关问题时。</p>

<p>但不能反过来，为了写成DSL式，而去把所有的API都搞成那样，比如把一些常规的操作像网络，像文件操作等都搞成那样，那就纯属滥用了。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/type-safe-builders.html#full-definition-of-the-com-example-html-package">Type-safe builders﻿</a></li>
<li><a href="https://www.baeldung.com/kotlin/dsl">Building DSLs in Kotlin</a></li>
<li><a href="https://coolshell.cn/articles/5709.html">API设计：用流畅接口构造内部DSL</a></li>
<li><a href="https://www.jianshu.com/p/f5f0d38e3e44">Kotlin之美——DSL篇</a></li>
<li><a href="https://blog.mindorks.com/mastering-kotlin-dsl-in-android-step-by-step-guide/">Mastering Kotlin DSL In Android - Step By Step Guide</a></li>
<li><a href="https://brunoaybar.com/how-do-kotlin-dsl-libraries-work/">How do Kotlin DSL libraries work?</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Coroutines]]></title>
    <link href="http://toughcoder.net/blog/2023/01/27/understanding-coroutines/"/>
    <updated>2023-01-27T10:59:13+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/27/understanding-coroutines</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Coroutine">协程Coroutine</a>是一种轻量级的实现异步的方式，使用上大大简化了以往异步和多线和带来的种种麻烦（如状态同步和锁），今天就来学习一下协程，以及在<a href="https://kotlinlang.org/docs/coroutines-guide.html">Kotlin中协程</a>的使用方式。</p>

<p><a href=""><img src="https://cdn.filestackcontent.com/fShtqYm3Tp2Xl9C36xN8" title="auto auto" ></a></p>

<!-- more -->


<h2>理解异步</h2>

<p>在解释什么是协程之前，得先要理解什么是异步。异步也就是说程序是非阻塞非同步的，并不是按照顺序来执行的。这么说依然很绕，我们来一个简单的例子。比如有这样一个语句：</p>

<pre><code class="kotlin">fun main(args: Array&lt;String&gt;) {
     println("world of Coroutine!") // 1
     print("Hello ...") // 2
}
</code></pre>

<p>这个代码的输出很明显是</p>

<pre><code class="bash">world of Coroutine
Hello ...
</code></pre>

<p>函数的执行是从上到下按我们写的顺序执行的，这就是顺序执行的意思，虽然说编译器会做一些指令重排以期对字节码进行一些优化，但有一个前提就是它不会改变程序的正确性，比如后面语句如果需要前面表达的结果时，一定能保证它们的执行顺序。同步的意思是，执行一个子函数，子函数会占用CPU，直到它运行结束再返回到调用它的函数，继续运行并能把结果带回给调用者，这即是同步的意思。比如这里的println，println没有执行完时，后面的语句是不会执行的。</p>

<p>异步的意思是函数语句的执行并不是按照我们写的顺序来运行的。比如说，前面的函数，如何能输出&#8221;Hello &hellip;world of Coroutine&#8221; ？这就需要让代码实现异步，非顺序的执行。有多种方式，协程就可以实现异步：</p>

<pre><code class="kotlin">fun main() = runBlocking { // this: CoroutineScope
    launch { // launch a new coroutine and continue
        delay(1000L) // non-blocking delay for 1 second (default time unit is ms)
        println("world of Coroutine!") // print after delay
    }
    print("Hello ...") // main coroutine continues while a previous one is delayed
}
// Hello ...world of Coroutine!
</code></pre>

<h2>协程不是线程</h2>

<p>需要特别注意的是协程并不是线程，它并不是实现多线程或者并行的方式，相反，协程是实现异步和并发的方式，它是让多个函数更好的协作以实现异步和并发，<a href="http://c.biancheng.net/view/9486.html">并发与并行的区别可以看这里</a>。</p>

<p><img src="https://ts1.cn.mm.bing.net/th/id/R-C.cd0dda66a295b461b1ec1f269be2314d?rik=4v1wb0LmAIbRew&amp;riu=http%3a%2f%2fsungjk.github.io%2fimages%2f2021%2f08%2f01%2fcoroutine.png&amp;ehk=D9i5q9A3eVYLMoxOPPbCAU0Rxek54FJ%2figmJCJYuY%2fc%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" /></p>

<p>从它的名字可以看出，它是子例程之间的协作，它是函数的执行，可以挂起，可以继续，但它不会产生阻塞。可以理解为它把线程进行了拆解，分为线程环境的具体函数的执行，协程则是函数的执行。</p>

<p>理解协程的要点是协程只会挂起，不会阻塞，重点转移到了各个函数如何协作，如何设计挂起点。至于并发部分，则交由协程运行的上下文环境(CoroutineContext)来处理。</p>

<h2>实战</h2>

<p>这时强烈推荐<a href="https://kotlinlang.org/docs/coroutines-and-channels.html">官方的一个实战性的教程</a>，它是一个有具体应用场景且足够的复杂的小项目，大部分代码已实现了，预留了一些任务来练手，并有教程进行讲解，当然也有参考答案，非常适合学习和参考。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://zhuanlan.zhihu.com/p/25979906">简单解释 Coroutine</a></li>
<li><a href="https://www.baeldung.com/kotlin/threads-coroutines">Threads vs Coroutines in Kotlin</a></li>
<li><a href="https://developer.android.google.cn/kotlin/coroutines">Kotlin coroutines on Android</a></li>
<li><a href="https://amitshekhar.me/blog/kotlin-coroutines">Mastering Kotlin Coroutines</a></li>
<li><a href="https://blog.csdn.net/xinzhilinger/article/details/116240688">Unity 协程(Coroutine)原理与用法详解</a></li>
<li><a href="https://docs.python.org/3/library/asyncio-task.html">Coroutines and Tasks</a></li>
<li><a href="https://www.educba.com/coroutines-vs-threads/">Coroutines vs Threads</a></li>
<li><a href="https://coolshell.cn/articles/10975.html">一个“蝇量级” C 语言协程库</a></li>
<li><a href="https://coolshell.cn/articles/12012.html">STATE THREADS 回调终结者</a></li>
<li><a href="https://en.wikipedia.org/wiki/Asynchronous_I/O">Asynchronous I/O</a></li>
<li><a href="https://realpython.com/async-io-python/">Async IO in Python: A Complete Walkthrough</a></li>
<li><a href="https://www.topcoder.com/thrive/articles/Introduction-to-asyncio-asynchronous-io-in-python">INTRODUCTION TO ASYNCIO (ASYNCHRONOUS IO) IN PYTHON</a></li>
<li><a href="https://andela.com/insights/an-introduction-to-asynchronous-programming-in-python-with-async-io/">An introduction to asynchronous programming in Python with Async IO</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin Collections]]></title>
    <link href="http://toughcoder.net/blog/2023/01/26/kotlin-arrays-and-collections/"/>
    <updated>2023-01-26T16:39:49+08:00</updated>
    <id>http://toughcoder.net/blog/2023/01/26/kotlin-arrays-and-collections</id>
    <content type="html"><![CDATA[<p>现代的软件一般比较复杂，程序语言中的基本数据类型往往不能满足需要，除了<a href="http://toughcoder.net/blog/2023/01/19/kotlin-types-and-operators/">基本的数据类型</a>以外，还有对象的容器也非常的重要，比如线性容器（数组，列表和Set）和二维容器（哈希表）等。今天就来学习一下Kotlin中的容器。</p>

<p><a href=""><img src="https://koenig-media.raywenderlich.com/uploads/2019/06/KotlinCollections-twitter.png" title="auto auto" ></a></p>

<!-- more -->


<h2><a href="https://kotlinlang.org/docs/collections-overview.html">Kotlin Collections</a></h2>

<p>集合就是用于处理一组对象的容器，因为用的人较多，所以就成了标准库。常见的集合有三种主要类型，列表类，Set类和Map类。</p>

<h3>线性容器</h3>

<p>这里并不单纯指类List，主要的意思是线性的容器，它的特点是以<strong>相对顺序存储同一类型的对象</strong>，有一个整数索引(index)来表示其相对的位置，查找性能差，其他还好。代表为数组。</p>

<h3><a href="https://kotlinlang.org/docs/arrays.html">数组</a></h3>

<p>最简单也是使用最为广泛的线性容器，不用过多的介绍了，可以参考<a href="http://toughcoder.net/blog/2023/01/19/kotlin-types-and-operators/">之前的文章</a>。</p>

<p>最大的弊端就是长度是固定的，长度在创建数组时就确定了，后面就改不了了。所以，必须在<strong>事先要能够确定数组的长度</strong>。</p>

<h4>创建复杂数组</h4>

<p>比如数组的元素是一个Collection，而非常见的基本数据类型，这时要如何写？</p>

<pre><code class="kotlin">       val carray = arrayOf&lt;MutableList&lt;Int&gt;&gt;(
            mutableListOf(),
            mutableListOf()
        )

        val narray = Array&lt;MutableList&lt;Int&gt;&gt;(10) { mutableListOf() }
</code></pre>

<p>关键就在于要声明元素的类型，其他的与基本数据类型的数组是一样的。另外，如果数组数量比较少，方便直接写，那就用字面构造函数，其实很方便。或者用数组元素的构造方法也可以。</p>

<h4>多维数组</h4>

<p>以最为常见的二维数组来说，要如何创建?</p>

<pre><code class="kotlin">       val smatrix = arrayOf(
            arrayOf(1, 2, 3),
            arrayOf(4, 5, 6),
            arrayOf(7, 8, 9)
        )

        val matrix = Array(5) { IntArray(6) }
</code></pre>

<h3><a href="https://kotlinlang.org/docs/ranges.html">Ranges</a></h3>

<p>用于表示区间的表达式，最为直观理解就是数组的索引，用<strong>操作符..</strong>来表示区间，比如0~9，就是<strong>0..9</strong>，通常用于for-loop中：</p>

<pre><code class="kotlin">if (i in 1..4) { // equivalent of i &gt;= 1 &amp;&amp; i &lt;= 4
    print(i)
}

for (i in 1..4) print(i) // for (int i = 1; i &lt;= 4; i++) print(i)
</code></pre>

<p>还可以指定步长和边界，以及方向：</p>

<pre><code class="kotlin">for (i in 0 until 10) { // for (int i = 0; i &lt; 10; i++)
    print(ln)
}

for (i in 0 until 10 step 2) { // for (int i = 0; i &lt; 10; i += 2)
    print(ln)
}

for (i in 9 downTo 0) { // for (int i = 9; i &gt;= 0; i--)
    print(i)
}
</code></pre>

<p>还可以用于字符，比如：</p>

<pre><code class="kotlin">for (c in 'a'..'z') { // for (char c = 'a'; c &lt;= 'z'; c++)
    print(c)
}
</code></pre>

<p>Range是一个表达式，所以在其之上做其他操作，但需要注意这时<strong>需要加上括号</strong>，比如：</p>

<pre><code class="kotlin">    for (i in (0..9).filter {it % 2 == 0 }) {
        println(i) // only evens
    }
    for (c in ('a'..'z').map { it.toUpperCase() }) {
        println(c) // upper case
    }
</code></pre>

<p><strong>需要注意</strong>，虽然Ranges方便操作数组的索引，但如果想要带着索引遍历数组的话，还是要用专用的遍历方式，而不是用Range，比如：</p>

<pre><code class="kotlin">for ((index, value) in array.withIndex()) {
    println("the element: [$index] = $value")
}
</code></pre>

<h4>注意与repeat的区别</h4>

<p>Ranges是一个数据结构代表着一个区间，这个区间可能是一个整数范围，也可能是一个字符范围，其实也可以是其他自定义数据类型，只要能表达 出区间的概念。只不过整数区间是为常用的一种方式，以及整数区间可以方便当作数组和列表的索引。</p>

<p>但有时如果仅仅想重复一件事情n次，那就没有必要用Ranges，虽然它也可以，这时最为方便的是函数repeat，它与区间的唯一区别是repeat是没有返回值的，它仅是把一件事情重复n次，但没有返回值也就是说没有办法再转化为其他数组或者列表。</p>

<pre><code class="kotlin">repeat(10) { println("repeat # $it") }
//repeat # 0
//repeat # 1
//repeat # 2
//repeat # 3
//repeat # 4
//repeat # 5
//repeat # 6
//repeat # 7
//repeat # 8
//repeat # 9
</code></pre>

<p>而比如Ranges是可以转化为其他数组和列表的：</p>

<pre><code class="kotlin">(0 until 5).map { it * it }.toIntArray()
// [0, 1, 4, 9, 16]
</code></pre>

<h3><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/">列表List</a></h3>

<p>列表可以简单理解为无限长的数组，它最大的特点是<strong>长度不固定，不必事先定好长度，它会随着添加元素而自动增长</strong>。所以，当你事先不知道容器的长度时，就需要用List。它是一个泛型，其余操作与数组一样。</p>

<pre><code class="kotlin">val names = listOf("James", "Donald", "Kevin", "George")
names.map { it.toUpper() }
    .forEach { println(it) }
</code></pre>

<h3><a href="https://kotlinlang.org/docs/sequences.html">序列Sequence</a></h3>

<p>序列与列表比较难区分，直观上它们是一样的。简单来说它并不是容器，它并不持有对象，它生产对象，类似于物理上的信号发射器和<a href="http://toughcoder.net/blog/2023/01/05/introduction-to-rxjava/">RxJava中的Observable</a>，是有时序上的概念的，当你需要时它就生产出来一个元素。</p>

<h3>队列queue</h3>

<p>队列可以用双端队列deque（读作dek），具体实现对象是<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-array-deque/">ArrayDeque&lt;T&gt;</a>。</p>

<p>双端队列是强大的数据结构，即可以用作队列，也可以用作栈。</p>

<h3>Set容器</h3>

<p>Set是一个<strong>不含有重复元素</strong>的容器，特点是<strong>不会保存相对顺序</strong>，可以<strong>快速实现检索</strong>。</p>

<pre><code class="kotlin">    val names = setOf("James", "Harden", "Donald", "Joe")
    for (nm in names) {
        println(nm)
    }
    names.filter { it.length &gt; 4 }
        .forEach { println(it) }
</code></pre>

<h3>Map容器</h3>

<p>由映射键->值对组成的二维容器，键不可重复，值可以重复，不会保存相对顺序，也可以用于快速检索。</p>

<pre><code class="kotlin">    val nameMap = mapOf("James" to 15, "Harden" to 30, "Donald" to 80, "Joe" to 86)
    for (nm in nameMap.keys) {
        println(nm)
    }
    for (age in nameMap.values) {
        println(age)
    }
    for (e in nameMap.entries) {
        println("${e.key} is ${e.value}")
    }
    nameMap.filter { it.key.length &gt; 5 }
        .forEach { println("${it.key} = ${it.value}") }
</code></pre>

<h2>注意Immutability</h2>

<p>有一个地方需要特别注意，那就是容器的<strong>不可变性Immutability</strong>，用常规的方法创建的集合对象是<strong>不可变的Immutable</strong>，就是无法向其中添加元素也无法删除元素。对象的不可变Immutable在函数式编程中是很重要的特性可以有效的减少异步和并发带来的<strong>状态一致性问题</strong>。</p>

<pre><code class="kotlin">val names = listOf("James", "Donald", "Kevin", "George")
names.add("Paul") // compile error, names is immutable
names.map { it.toUpper() }
    .forEach { println(it) }
</code></pre>

<p>这样写会有<strong>编译错误</strong>，因为用listOf创建的列表对象是<strong>不可变的Immutable</strong>。如果想要改变就必须用支持更改的对象，如MutableList, MutableSet和MutableMap，如：</p>

<pre><code class="kotlin">val names = mutableListOf("James", "Donald", "Kevin", "George")
names.add("Paul") // okay
names.map { it.toUpper() }
    .forEach { println(it) }
</code></pre>

<p>如果有可能还是要尽可能的<strong>用不可变对象(Immutable objects)</strong>。</p>

<h2>集合的操作</h2>

<p>集合的操作就是函数式的三板斧过滤filter，转化map和折叠化约fold/reduce，前面讲的所有的容器都是支持的，结合<a href="http://toughcoder.net/blog/2023/01/24/understanding-kotlin-functions/">lambdas</a>可以写出非常规范的函数式代码。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/kotlin-collections/">Kotlin Collections</a></li>
<li><a href="https://blog.csdn.net/u013700502/article/details/123115051">Kotlin常用Collection集合操作整理</a></li>
<li><a href="https://www.baeldung.com/kotlin/kotlin-collection-guide">Kotlin Collections Guide</a></li>
<li><a href="https://www.geeksforgeeks.org/kotlin-ranges/">Kotlin Ranges</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
