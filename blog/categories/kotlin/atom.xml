<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Kotlin | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/kotlin/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2025-07-17T23:15:53+08:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[用优雅的姿式应对Kotlin Flow的回压]]></title>
    <link href="https://alexhilton.github.io/blog/2025/07/03/handling-flow-backpress/"/>
    <updated>2025-07-03T22:09:26+08:00</updated>
    <id>https://alexhilton.github.io/blog/2025/07/03/handling-flow-backpress</id>
    <content type="html"><![CDATA[<p>本文译自「How to Manage Backpressure in Kotlin Flow: collect • buffer • conflate • collectLatest」，原文链接<a href="https://proandroiddev.com/how-to-manage-backpressure-in-kotlin-flow-collect-buffer-conflate-collectlatest-b8102284d968">https://proandroiddev.com/how-to-manage-backpressure-in-kotlin-flow-collect-buffer-conflate-collectlatest-b8102284d968</a>，由Shbazhenov发布于2025年6月13日。</p>

<p><a href=""><img src="https://blog.mindorks.com/images/kotlin-flow-banner-image.png" title="auto auto" ></a></p>

<!-- more -->


<p>你是否曾遇到过快速数据源发送的数据量超出应用处理能力的情况，导致应用速度变慢甚至崩溃？Kotlin Flow 内置了一些方法，可让你的生产者和消费者保持同步。本文将介绍：</p>

<ol>
<li>回压的含义</li>
<li>Flow 默认的“互相等待”模式如何工作</li>
<li>何时使用 buffer() 添加小型队列</li>
<li>conflate() 如何跳过旧数据项</li>
<li>为什么 collectLatest { } 会停止旧数据处理</li>
<li>如何根据你的情况选择合适的选项</li>
</ol>


<h2>回压的含义</h2>

<p>回压的作用是确保快速的数据发送方不会压垮较慢的接收方。如果没有回压，你可能会在内存中存储过多的数据，或者浪费时间处理过时的信息。</p>

<p>回压可以帮助你：</p>

<ul>
<li>控制内存使用量</li>
<li>避免不必要的工作</li>
<li>使应用性能更可预测</li>
</ul>


<h2>1. 默认“互相等待”模式</h2>

<p>默认情况下，当你执行以下操作时：</p>

<pre><code class="Kotlin">flow {
  repeat(3) {
    emit(it)
    println("Sent $it")
    delay(100)            // 快速的发送者
  }
}
.collect { value -&gt;
  println("Handling $value")
  delay(300)             // 慢速的处理者
}
</code></pre>

<p>发送方 ( emit ) 将暂停，直到处理方 ( collect ) 处理完最后一个值。没有队列，每个值都是一次发送和处理一个。</p>

<h2>2. 使用 buffer() 添加一个小队列</h2>

<p>如果你希望发送方提前一点，请使用：</p>

<pre><code class="Kotlin">flow { … }
  .buffer(capacity = 2)
  .collect { value -&gt;
    // slow work here
  }
</code></pre>

<ul>
<li>现在，发送者最多可以将 2 个项目放入一个小队列中。</li>
<li>一旦队列满了，它就会再次暂停。</li>
</ul>


<p>这给了你一个有限的队列：你仍然可以处理每个项目，但可以平滑速度峰值。</p>

<h2>3. 使用 conflate() 跳过旧项目</h2>

<p>当你只关心最新数据（例如更新进度条）时，你可以这样写：</p>

<pre><code class="Kotlin">flow { … }
  .conflate()
  .collect { value -&gt;
    println("Update to $value")
    delay(300)
  }
</code></pre>

<ul>
<li>如果处理程序繁忙，则仅保留最新未处理的项目。</li>
<li>较旧的项目将被丢弃，因此你无需处理过时的更新。</li>
</ul>


<p>注意：conflate() 不会停止当前工作；它只是在下次读取时跳过旧值。</p>

<h2>4. 使用 collectLatest { } 停止旧工作</h2>

<p>要进一步操作并在新数据进入时取消任何正在进行的工作，请使用：</p>

<pre><code class="Kotlin">flow { … }
  .collectLatest { value -&gt;
    println("Start $value")
    delay(300)    // 可能会被切断
    println("Done $value")
  }
</code></pre>

<ul>
<li>每次发出（emit）新的数据时，处理前一个值的块都会立即被丢弃。</li>
<li>只有当发送方的发送速度持续超出你的处理能力时，你才需要完成最后一个值的工作。</li>
</ul>


<p>这非常适合边输入边搜索的情况，在这种情况下，你希望在用户再次输入时立即丢弃旧请求。</p>

<h2>5. 选择合适的工具</h2>

<h3>普通 collect</h3>

<ul>
<li>功能：发送方和处理方互相等待，一个接一个</li>
<li>何时选择它：你必须按顺序处理每个项目

<h3>.buffer(n)</h3></li>
<li>功能：大小为 n 的小队列；不丢弃任何项目</li>
<li>何时选择它：你需要少量缓冲，但仍要处理所有项目

<h3>.conflate()</h3></li>
<li>功能：如果处理方繁忙，则仅保留最新项目</li>
<li>何时选择它：你需要最新数据，但仍要完成当前工作

<h3>collectLatest { }</h3></li>
<li>功能：新数据到达后立即取消所有正在进行的工作</li>
<li>何时选择它：只考虑最新的结果；立即放下其他一切

<h2>6. 总结</h2></li>
<li>回压机制可防止快速数据流过载慢速处理器。</li>
<li>默认模式没有队列：安全但速度可能较慢。</li>
<li>buffer() 函数添加了一个小队列：更灵活，不会丢包。</li>
<li>conflate() 函数跳过旧值：始终保持最新，但让当前工作完成。</li>
<li>collectLatest { } 函数停止旧工作：仅完成最新项。</li>
</ul>


<p>下次你的 Flow 感觉太快或太慢时，请问自己：</p>

<ol>
<li>我需要处理每个值吗？</li>
<li>小型队列有帮助吗？</li>
<li>只有最新数据才重要吗？</li>
<li>当新数据到达时，我应该取消旧工作吗？</li>
</ol>


<p>选择最合适的简单选项，Kotlin Flow 会处理余下的事情。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一文搞懂Kotlin符号处理接口KSP]]></title>
    <link href="https://alexhilton.github.io/blog/2024/04/16/kotlin-ksp-made-easy/"/>
    <updated>2024-04-16T21:17:43+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/04/16/kotlin-ksp-made-easy</id>
    <content type="html"><![CDATA[<p>Kotlin符号处理（Kotlin Symbol Processing）即KSP是可以用于开发轻量级编译器插件的一套API。是Kotlin原生的，Kotlin语法友好的编译器插件。使用简单且易于上手，可以实现一些非常强大的编译时代码处理功能，如代码生成和代码检查。今天就来学习一下KSP的基本原理，以及如何使用KSP API。</p>

<p><a href=""><img src="https://androiddeepdive.github.io/Team-Blog/images/cover_ksp.png" title="auto auto" ></a></p>

<!-- more -->


<p><strong>注意</strong>，本文是Kotlin中较为高级的话题，适合有一定的Kotlin基础的同学，否则理解起来可能有难度，可以事先<a href="https://juejin.cn/column/7351592055908892723">阅读前面的文章</a>。</p>

<h2>什么是KSP</h2>

<p>与前文提到的注解处理器kapt类似，KSP也是一种编译时的插件，能够在编译前处理Kotlin语言的符号。KSP API能地道地处理Kotlin的源码，因为它是专门为Kotlin而设计的，能够完全的理解和识别Kotlin的语言符号，以及Kotlin专属的特性：如扩展函数，声明点泛型变化以及本地函数。KSP API基于Kotlin的语法，把Kotlin程序拆解为各种静态的符号，可以处理如类，成员，函数，参数 以及注解等等。但它并不是运行时的（那是反射做的事情），因此像逻辑如循环和条件语句是没有办法进行处理，以及也无法得到表达式的结果。</p>

<p>虽然KSP是编译器插件，但它是运行在最终编译之前，也就是说在编译器编译全部代码之前，事先会运行KSP插件。所以KSP API最适合做的事情是：</p>

<ol>
<li>读取代码和各种资源文件，并进行分析</li>
<li>生成代码</li>
</ol>


<p>接下来看如何具体使用KSP API。</p>

<h2>配置KSP</h2>

<p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcStf17qaB5JSFveiBVlA6ljiI0OgI3kN4hnQkBKtuFnSw&amp;s" alt="" /></p>

<p>KSP是由谷歌开发的一套工具，包括两部分一个是Kotlin plugin，另一个是依赖库。所以需要在项目的根build.gradle里面，先把plugin添加到项目里：</p>

<pre><code class="Groovy">// The root build.gradle of your project
plugins {
    id 'org.jetbrains.kotlin.jvm' version '1.9.23' apply false
    id 'com.google.devtools.ksp' version '1.9.23-1.0.20' apply false
}
</code></pre>

<p>当然，这一步其实并不是必须的，也可以在每个模块中再配置plugin。</p>

<p>接下来，在使用KSP的模块里面添加plugin，添加依赖以及指明KSP processor，这是最为关键的配置：</p>

<pre><code class="Groovy">// module build.gradle
plugins {
    id 'org.jetbrains.kotlin.jvm'
    id 'com.google.devtools.ksp'
}

dependencies {
    implementation project(':kspannotation')
    ksp project(':kspprocessor')
}
</code></pre>

<p>如果项目顶层指定了plugin的版本，那么到了module这里，就不必再指定版本了。另外就是要注意版本的匹配，ksp的版本前半段『1.9.23』指明 的是最低的Kotlin版本要求。最好是让ksp要求的版本与指定的Kotlin版本匹配或者差距较小，否则可能会有问题。dependencies中的ksp指定的是KSP processor，对于有些库可能注解和定义和KSP的processor可能会在同一个包里，那么写一句就够了，如Room的，就一句：ksp &lsquo;androidx.room:room-compiler:2.6.1&#8217;。</p>

<p>如果是自定义的processor，需要为processor单独建一个library module，配置ksp库为依赖即可：</p>

<pre><code class="Groovy">// KSP processor module build.gradle
plugins {
    id 'org.jetbrains.kotlin.jvm'
}

dependencies {
    implementation project(':kspannotation')

    implementation 'com.google.devtools.ksp:symbol-processing-api:1.9.23-1.0.20'
    implementation 'com.squareup:kotlinpoet-ksp:1.16.0'
}
</code></pre>

<p>典型的KSP procesor（包括网上大部分的例子）都是分了三个module，一个是定义注解的module，一个是实现processor的，一个是使用注解和processor的。但这并不是必须的，为了方便，其实把注解的定义和processor放在一个module就可以了。只要把processor与使用它的module分开来了，就可以。</p>

<p><strong>注意：</strong>对于processor module来说它的类型要是library，并且要是Java library或者Kotlin library，因为这是Kotlin语言层面的东西。对于Android同学来说在新建module时一定要选择『Java or Kotlin Library』。</p>

<h2>实现KSP Processor</h2>

<p>配置好了模块后，剩下的就是要实现一个KSP processor了。</p>

<h3>实现Processor</h3>

<p>大部分工作plugin已经做好了，我们需要做的就是实现一些接口。有两个需要实现，一个是<a href="https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/processing/SymbolProcessorProvider.kt">SymbolProcessorProvider</a>，另一个则是<a href="https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/processing/SymbolProcessor.kt">SymbolProcessor</a>。</p>

<p>SymbolProcessorProvider相当于是processor的一个工厂方法，我们实现它的create方法，返回一个SymbolProcessor实例，一个典型的实现：</p>

<pre><code class="Kotlin">class MyProcessorProvider : SymbolProcessorProvider {
    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
        return MyProcessor(environment.codeGenerator)
    }
}
</code></pre>

<p>它就相当于一个工厂方法，把上下文环境传给processor，SymbolProcessor是重点，我们需要实现它的process方法，针对感兴趣的符号进行处理，比如用<a href="https://square.github.io/kotlinpoet/">KotlinPoet</a>生成代码，这里是发挥创造力的地方：</p>

<pre><code class="Kotlin">class MyProcessor(private val generator: CodeGenerator) : SymbolProcessor {
    override fun process(resolver: Resolver): List&lt;KSAnnotated&gt; {
        val annotatedClasses = resolver
            .getSymbolsWithAnnotation(MyAnnotation::class.java.name)
            .filterIsInstance&lt;KSClassDeclaration&gt;()

        for (aclass in annotatedClasses) {
            val packageName = aclass.packageName.asString()
            val className = aclass.simpleName.asString()
            val methods = aclass.getDeclaredFunctions())
            // ...
         }
        return emptyList()
    }
}
</code></pre>

<h3>注册Processor</h3>

<p>实现了process后还需要把process注册一下，否则ksp plugin无法找到这个processor。在processor module与代码同级文件夹下新建文件『resources/META-INF/services/com.google.devtools.ksp.processing.SymbolProcessorProvider』，然后把刚才实现的provider的完整类名，写在文件里，如果是使用IDE一般都会有提示的。</p>

<pre><code class="Kotlin">// myprocessor/src/main/
//    |-- kotlin/net/toughcoder/
//              |-- MyProcessorProvider.kt
//              |-- MyProcessor.kt
//    |-- resources/META-INF/services/
//              |-- com.google.devtools.ksp.processing.SymbolProcessorProvider
// file: resources/META-INF/services/com.google.devtools.ksp.processing.SymbolProcessorProvider
net.toughcoder.MyProcessorProvider
</code></pre>

<h2>为啥要用KSP</h2>

<p>目前来说KSP最主要应用仍然 是注解的处理，以及配合注解进行代码生成。通过前面一篇<a href="https://juejin.cn/post/7355024828262334501">关于注解的文章</a>中我们知道，注解的处理已经有了一个专门的工具了叫做kapt，就目前来说KSP能做的事情kapt也都能做，它们都是用于编译时代码处理以及代码生成，都能处理注解。那么，在已经有了kapt的前提下，为啥还要搞KSP呢？</p>

<p>kapt虽然是Kotlin的注解处理器，但是它保持Java的兼容性，它直接复用了Java的<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/AbstractProcessor.html">AbstractProcessor</a>，要依赖于Java的annotation procssor以及javac，只适用于Kotlin/JVM，其他target用不起来，因此它并不能算是Kotlin原生的工具，对Kotlin的特性支持不友好。再有就是，为了保持与javac的兼容性，它的处理速度很慢，必须先把Kotlin代码转成javac能认识的标准Java代码，这肯定会有不必要的性能开销。基于这些限制，kapt已经停止开发了，处于维护状态了，不会再添加新功能了。<strong>省流点来说，kapt是以Java角度来看待输入代码的（即也要处理的源码），而KSP是以Kotlin角度</strong>。</p>

<p>KSP则是Kotlin原生的，基于Kotlin开发的，且是为了Kotlin开发的，并不受限于javac，因此所有的Kotlin目标平台都能用。并且对Kotlin的特性支持的很友好。它的处理速度也较kapt有提升，因为不必要做编码转换了，省了一道工序。从官方给出的数据看至少能省25%的编译时间。另外，KSP的API使用起来更加的Kotlin友好一些SymbolProcessor传递过来的<a href="https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/processing/Resolver.kt">Resolver</a>有很方便的接口可以取得被标的类，而且符号对象是<a href="https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/symbol/KSClassDeclaration.kt">KSClassDeclaration</a>，它可以方便的取一个Kotlin类的相关的其他符号，如包名，类名，方法等。</p>

<h2>总结</h2>

<p>通过本文我们理解了KSP的概念，并学会了如何在项目中配置KSP， 以及如何实现一个KSP processor。KSP视Kotlin代码为一系列的静态符号，对Kotlin语言特性支持友好，处于活跃的开发状态且被官方大力支持，因此应该尽早转向KSP。并且相信KSP能做的事情会越来越多。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/ksp-overview.html">Kotlin Symbol Processing API</a></li>
<li><a href="https://developer.android.com/build/migrate-to-ksp">Migrate from kapt to KSP</a></li>
<li><a href="https://www.kodeco.com/33148161-write-a-symbol-processor-with-kotlin-symbol-processing">Write a Symbol Processor with Kotlin Symbol Processing</a></li>
<li><a href="https://www.codecentric.de/wissens-hub/blog/kotlin-symbol-processing-introduction">An Introduction to Kotlin Symbol Processing</a></li>
<li><a href="https://kt.academy/article/ak-ksp">Kotlin Symbol Processing</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin Annotation Made Easy]]></title>
    <link href="https://alexhilton.github.io/blog/2024/04/09/kotlin-annotation-made-easy/"/>
    <updated>2024-04-09T22:14:10+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/04/09/kotlin-annotation-made-easy</id>
    <content type="html"><![CDATA[<p>注解（Annotations）允许我们在代码中添加元数据（Meta data），提供代码以外的信息，这些元数据可以在编译时被编译器或其他工具读取和处理。 Kotlin作为一种功能强大且易于使用的多范式通用编程语言，注解（Annotations）是其核心特性之一。在Kotlin中，注解的使用非常广泛，可以用于框架设计、代码生成、测试、依赖注入等多个方面。今天就来学习一下Kotlin中注解的使用方法。</p>

<p><a href=""><img src="https://appmaster.dev/wp-content/uploads/2023/03/Understan-Kotlin-Annotations-1024x536.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>Kotlin是基于JVM的编程语言，并且可以与Java互通使用，因此事先了解一下Java的注解对于学习Kotlin的注解是非常有帮助的。可以阅读一下前面的文章来<a href="https://juejin.cn/post/7353138889458319412">回顾Java语言的注解</a>。</p>

<h2>什么是注解</h2>

<p>注解是元编程的一种实现方式，它并不直接改变代码，而是为代码提供额外的数据。注解不能单独存在，必须与代码中的其他元素一起使用。在Kotlin中，注解要使用符号『@』后面加一个已定义的注解名字，如『@Deprecated』。注解在Kotlin中的使用非常广泛的，相信有过代码经验的同学都至少看过大量的注解。</p>

<h2>注解的使用方法</h2>

<p>注解的使用是非常的直观的，在需要的代码元素（类，变量，属性，函数，参数等等）加上想要使用的注解就可以了：</p>

<pre><code class="Kotlin">@Fancy class Foo {
    @Fancy fun baz(@Fancy foo: Int): Int {
        return (@Fancy 1)
    }
}
</code></pre>

<p>Kotlin的注解也可以用在lambda上面，这实际上相当于应用于lambda函数生成的函数实例的invoke()上面：</p>

<pre><code class="Kotlin">annotation class Suspendable

val f = @Suspendable { Fiber.sleep(10) }
</code></pre>

<h3>注解的使用点目标</h3>

<p>由于Kotlin最终要编译成为字节码，运行在JVM上，所以它必须符合Java的规范。但语法上Kotlin与Java还是不一样的，比如一句Kotlin代码可能会相当于Java的好几句，换句话说一个Kotlin语句中的元素可能会对应着Java中的好几个。这可能会带来问题。</p>

<p>注解并不能单独出现，它必须作用到某一个语法上的元素，因为Kotlin语法元素可能会对应着几个Java语法元素，那么注解可能会被用在多个目标元素上面。为了能精确的指定注解的作用目标，可以使用『使用点目标』（use-site targets）来标记具体的目标元素：</p>

<pre><code class="Kotlin">class Example(@field:Ann val foo,    // annotate Java field
              @get:Ann val bar,      // annotate Java getter
              @param:Ann val quux)   // annotate Java constructor parameter
</code></pre>

<p>这里面『Ann』是一个注解，其前面的『field/get/param』就用以指定具体的注解目标元素。可用的使用点目标有这些：</p>

<ul>
<li>file</li>
<li>property</li>
<li>field</li>
<li>get 属性的getter</li>
<li>set 属性的setter</li>
<li>receiver 扩展函数或者扩展属性的底层对象</li>
<li>param 构造函数的参数</li>
<li>setparam 属性setter的参数</li>
<li>delegate 指存储着受托对象实例的域成员</li>
</ul>


<p>『receiver』指的是扩展函数发生作用的实例，比如说：</p>

<pre><code class="Kotlin">fun @receiver:Fancy String.myExtension() { ... }
</code></pre>

<p>那么，这个注解『Fancy』将作用于具体调用这个扩展方法myExtension的String实例上面。</p>

<p>这些具体的使用点目标可以精确的指定JVM认识的元素上面，可以发现，它们远比定义注解时的<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/">@Target</a>要丰富。如果不指定具体的使用点目标，那么就会按照@Target指定的目标，如果有多个目标，会按如下顺序选择：</p>

<ul>
<li>param</li>
<li>property</li>
<li>field</li>
</ul>


<h3>兼容Java注解</h3>

<p>Kotlin是完全兼容Java注解，也就是说Java中定义的注解，在Kotlin中都可以直接使用。</p>

<pre><code class="Java">// Java
public @interface Ann {
    int intValue();
    String stringValue();
}
</code></pre>

<pre><code class="Kotlin">// Kotlin
@Ann(intValue = 1, stringValue = "abc") class C
</code></pre>

<p>虽然可以直接用，但毕竟Kotlin的语法要丰富得多，所以为了避免歧义，要使用前面介绍的使用点目标来精确指定注解的作用目标。</p>

<h2>自定义注解</h2>

<p>使用关键字『annotation』来声明自定义注解，如：</p>

<pre><code class="Kotlin">annotation class Fancy
</code></pre>

<p>之后就可以使用注解了：</p>

<pre><code class="Kotlin">@Fancy class Foo {
    @Fancy fun baz(@Fancy foo: Int): Int {
        return (@Fancy 1)
    }
}
</code></pre>

<p>光这样声明还不够，还需要定义注解具体的内容，如可修饰的目标和行为特点，这就需要用到元注解（Meta annotations），也即定义注解时所需要的注解。</p>

<h3>元注解（Meta annotations）</h3>

<h4>@MustBeDocumented</h4>

<p>用于指定此注解是公开API的一部分，必须包含在文档中。</p>

<h4>@Repeatable</h4>

<p>允许在同一个地方多次使用注解。</p>

<h4><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-target/">@Target</a></h4>

<p>用于指定此注解可以应用到哪些程序元素上面，如类和接口，函数，属性和表达式。</p>

<ul>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-c-l-a-s-s.html#kotlin.annotation.AnnotationTarget.CLASS">AnnotationTarget.CLASS</a> - 类型，包括类型原型（classes），接口，对象，注解类型</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-p-r-o-p-e-r-t-y.html#kotlin.annotation.AnnotationTarget.PROPERTY">AnnotationTarget.PROPERTY</a> - 属性</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-f-i-e-l-d.html#kotlin.annotation.AnnotationTarget.FIELD">AnnotationTarget.FIELD</a> - 域变量</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-l-o-c-a-l_-v-a-r-i-a-b-l-e.html#kotlin.annotation.AnnotationTarget.LOCAL_VARIABLE">AnnotationTarget.LOCAL_VARIABLE</a> - 局部变量（本地变量）</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-v-a-l-u-e_-p-a-r-a-m-e-t-e-r.html#kotlin.annotation.AnnotationTarget.VALUE_PARAMETER">AnnotationTarget.VALUE_PARAMETER</a> - 参数</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-c-o-n-s-t-r-u-c-t-o-r.html#kotlin.annotation.AnnotationTarget.CONSTRUCTOR">AnnotationTarget.CONSTRUCTOR</a> - 构造函数</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-f-u-n-c-t-i-o-n.html#kotlin.annotation.AnnotationTarget.FUNCTION">AnnotationTarget.FUNCTION</a> - 函数</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-p-r-o-p-e-r-t-y_-g-e-t-t-e-r.html#kotlin.annotation.AnnotationTarget.PROPERTY_GETTER">AnnotationTarget.PROPERTY_GETTER</a> - 属性的getter</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-p-r-o-p-e-r-t-y_-s-e-t-t-e-r.html#kotlin.annotation.AnnotationTarget.PROPERTY_SETTER">AnnotationTarget.PROPERTY_SETTER</a> - 属性的setter</li>
</ul>


<h4>@Retention</h4>

<p>指定注解信息保存到代码生命周期的哪一阶段，编译前，编译时还是运行时。默认值是运行时，也即在运行时注解是可见的。</p>

<ul>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-retention/-s-o-u-r-c-e.html">AnnotationRetention.SOURCE</a> - 只在源码过程中保留，并不会出现在编译后的class中（二进制文件中）。</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-retention/-b-i-n-a-r-y.html">AnnotationRetention.BINARY</a> - 会在class中保留，但对于运行时并不可见，也就是通过反射无法得到注解。</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-retention/-r-u-n-t-i-m-e.html">AnnotationRetention.RUNTIME</a> - 注解会保留到运行时，运行时的操作如反射可以解析注解，这是默认的@Rentention值。</li>
</ul>


<h3>构造方法（Constructors）</h3>

<p>与Java很不同的是Kotlin的注解更加的像常规的类（class），注解也可以有构造函数：</p>

<pre><code class="Kotlin">annotation class Special(val why: String)

@Special("example") class Foo {}
</code></pre>

<p>构造函数可以使用的参数包括：</p>

<ul>
<li>基础数据类型Int，Long，Float和String等</li>
<li>类型原型（即class，如Foo::class）</li>
<li>枚举类型</li>
<li>其他注解类型</li>
<li>由以上类型组成的数组</li>
</ul>


<p>注意不能有可能为空（如String?）的类型，当然也不可以传递null给注解的构造函数。还有，如果用其他注解作为参数时，注解名字前就不用再加『@』了：</p>

<pre><code class="Kotlin">annotation class ReplaceWith(val expression: String)

annotation class Deprecated(
        val message: String,
        val replaceWith: ReplaceWith = ReplaceWith(""))
</code></pre>

<h3>注解的实例化（Instantiation）</h3>

<p>在Kotlin中可以通过调用注解的构造函数来实例化一个注解来使用。而不必非要像Java那样用反射接口去获取。</p>

<pre><code class="Kotlin">annotation class InfoMarker(val info: String)

fun processInfo(marker: InfoMarker): Unit = TODO()

fun main(args: Array&lt;String&gt;) {
    if (args.isNotEmpty())
        processInfo(getAnnotationReflective(args))
    else
        processInfo(InfoMarker("default"))
}
</code></pre>

<h2>注解解析</h2>

<p>Kotlin是基于JVM的编程语言，最终要编译成为字节码运行在JVM上面，所以注解的解析与Java语言注解解析是一样的，可以在运行时用反射API来解析注解。关于Java注解解析可以<a href="/blog/2024/03/24/java-annotations-made-easy/">参考另一篇文章</a>，因为运行时注解解析用处并不大，并且也不复杂，看一个简单&#127792;就可以了：</p>

<pre><code class="Kotlin">class Item(
  @Positive val amount: Float, 
  @AllowedNames(["Alice", "Bob"]) val name: String)

val fields = item::class.java.declaredFields
for (field in fields) {
    for (annotation in field.annotations) {
        if (field.isAnnotationPresent(AllowedNames::class.java)) {
            val allowedNames = field.getAnnotation(AllowedNames::class.java)?.names
         }
    }
}
</code></pre>

<h2>注解处理器</h2>

<p>注解是元编程的一种方式，它最大的威力是在编译前进行代码处理和代码生成。除了注解的定义和使用外，更为关键的注解的处理需要用到注解处理器（Annotation Processor），并且要配合编译器插件<a href="https://kotlinlang.org/docs/kapt.html">kapt</a>和<a href="https://kotlinlang.org/docs/ksp-overview.html">KSP</a>来使用。</p>

<p>需要注意，因为注解是JVM支持的特性，在编译时需要借助javac编译器，所以只有运行目标是JVM时注解才有效。因为Kotlin是支持编译为不同运行目标的，除了JVM外，还有JavaScript和Native。</p>

<h3>实现注解处理器</h3>

<p>与Java的注解处理器类似，在定义好注解后，还需要实现一个注解处理器，以对注解进行处理。一般情况下实现AbstractProcessor就可以了。在其process方法中过滤出来想要处理的注解进行处理，比如使用<a href="https://github.com/square/kotlinpoet">KotlinPoet</a>生成代码。</p>

<p>另外，还要注意，注解处理器必须在一个单独的module中，然后添加为使用此注解module的依赖，这是因为注解的处理是在编译前，所以处理器需要在正式编译前就已经编译好。</p>

<pre><code class="kotlin">package net.toughcoder

import javax.annotation.processing.*
import javax.lang.model.element.*
import javax.tools.Diagnostic

@SupportedAnnotationTypes("com.example.MyAnnotation")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
class MyAnnotationProcessor : AbstractProcessor() {

    override fun process(annotations: MutableSet&lt;out TypeElement&gt;, roundEnv: RoundEnvironment): Boolean {
        for (annotation : annotations) {
            for (element : roundEnv.getElementsAnnotatedWith(annotation)) {
                val myAnnotation = element.getAnnotation(MyAnnotation::class.java)
                val message = "Processing element with annotation MyAnnotation(value = ${myAnnotation.value})"
                processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, message, element)
            }
        }
        return true
    }
}
</code></pre>

<p>从例子中可以看到，其实Kotlin中的注解处理器（Processor）直接就是用的Java的，所以在用的时候最好加上Java语言的版本。</p>

<h3>注册注解处理器</h3>

<p>为能正常使用注解处理器，需要把注解处理器放在一个单独的Module里，并作为其他module的依赖，这样能确保它在编译被依赖项时正常使用，被依赖项也即注解使用的地方。</p>

<p>需要在处理器module中与代码平级的文件夹创建resources文件夹，创建一个子文件夹META-INF，再在META-INF创建一个子文件services，在里面创建一个文件名为『javax.annotation.processing.Processor』，然后把实现的注解处理器的完整类名，写在这个文件的第一行：</p>

<pre><code class="Kotlin">// file: resources/META-INF/services/javax.annotation.processing.Processor
net.toughcoder.MyAnnotationProcessor
</code></pre>

<h3>使用注解处理器</h3>

<p><img src="https://bigknol.com/wp-content/uploads/2023/07/android-ksp-kapt-768x439.png" alt="" /></p>

<p>需要做两个事情，一个是把注解处理器添加为其他项目或者module的依赖。然后再用<a href="https://kotlinlang.org/docs/kapt.html">专门处理注解处理器的编译器插件</a>使用注解处理器。</p>

<pre><code class="Groovy">dependencies {
    implementation(kotlin('stdlib'))
    kapt 'net.toughcoder:my-annotation-processor:1.0.0'
}

kapt {
    useBuildCache = true
    annotationProcessors = ['net.toughcoder:my-annotation-processor:1.0.0']
}
</code></pre>

<h2>总结</h2>

<p>本文介绍了Kotlin中注解的基本语法、使用方法和处理过程。通过自定义注解处理器，我们可以在编译时处理注解并生成相应的代码或执行其他任务。注解是Kotlin编程中的核心特性，它可以帮助我们提高代码的可读性、可维护性和可扩展性。大部分的注解都在编译时，也不会对性能产生影响，所以可以放心大胆的用注解来提升开发效率。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/annotations.html">Annotations</a></li>
<li><a href="https://www.baeldung.com/kotlin/annotations">Kotlin Annotations</a></li>
<li><a href="https://kt.academy/article/ak-annotation-processing">Annotation Processing</a></li>
<li><a href="https://www.kodeco.com/8574679-annotation-processing-supercharge-your-development">Annotation Processing: Supercharge Your Development</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Deep Dive Into Kotlin Generics Runtime]]></title>
    <link href="https://alexhilton.github.io/blog/2024/03/16/deep-dive-into-kotlin-generics-runtime/"/>
    <updated>2024-03-16T19:16:00+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/03/16/deep-dive-into-kotlin-generics-runtime</id>
    <content type="html"><![CDATA[<p>通过前面的学习，对Kotlin的泛型已经有了比较全面的了解了，泛型的目的是让通用的代码更加的类型安全。现在我们离写出类型安全的泛型代码还差最后一块拼图，那就是泛型的类型擦除，今天就来深入地学习一下运行时的泛型，彻底的弄懂类型擦除的前因后果，并学会如何在运行时做类型检查和类型转换，以期完成拼图掌握泛型，写出类型安全的通用代码。</p>

<p><a href=""><img src="https://global-uploads.webflow.com/618fa90c201104b94458e1fb/61978c1b9e0bf52082dabe92_Kotlin-Generics.png" title="auto auto" ></a></p>

<!-- more -->


<p>关于泛型话题的一系列文章：</p>

<ul>
<li><a href="/blog/2024/03/04/kotlin-generics-made-easy/">这回就好好聊聊Kotlin的泛型</a></li>
<li><a href="/blog/2024/03/10/java-generics-made-easy/">深入浅出Java泛型</a></li>
<li><a href="/blog/2024/03/13/kotlin-generics-revisited/">Kotlin Generics Revisited</a></li>
<li><a href="">Dive deep into Kotlin type erasure</a></li>
</ul>


<h2>泛型类型擦除（Type erasure）</h2>

<p>泛型的类型安全性（包括类型检查type check，和类型转换type casting）都是由编译器在编译时做的，为了保持在JVM上的兼容性，编译器在保障完类型安全性后会对泛型类型进行<a href="https://en.wikipedia.org/wiki/Type_erasure">擦除（Type erasure）</a>。在运行时泛型类型的实例并不包含其类型信息，也就是说它不知道具体的类型参数，比如Foo&lt;Bar&gt;和Foo&lt;Baz?&gt;都被擦除成了Foo&lt;&#42;&gt;，在虚拟机（JVM）来看，它们的类型是一样的。</p>

<p>因为泛型Foo&lt;T&gt;的类型参数T会<strong>被擦除（erased）</strong>，所以与类型参数相关的类型操作（类型检查is T和类型转换as T）都是不允许的。</p>

<h2>可行的类型检查和转换</h2>

<p>虽然类型参数会被擦除，但并不是说对泛型完全不能进行类型操作。</p>

<h3>星号类型操作</h3>

<p>因为所有泛型会被擦除成为星号无界通配Foo&lt;&#42;&gt;，它相当于Foo&lt;Any?&gt;，是所有Foo泛型的基类，类型参数Any?是根基类，所以可以进行类型检查和类型转换：</p>

<pre><code class="Kotlin">if (something is List&lt;*&gt;) {
    something.forEach { println(it) } // 元素被视为Any?类型
}
</code></pre>

<p>针对星号通配做类型操作，类型参数会被视为Any?。但其实这种类型操作没有任何意义，毕竟Any是根基类，任何类当成Any都是没有问题的。</p>

<h3>完全已知具体的类型参数时</h3>

<p>另外一种情况就是，整个方法的上下文中已经完全知道了具体的类型参数时，不涉及泛型类型时，也是可以进行类型操作的，说的比较绕，我们来看一个&#127792;：</p>

<pre><code class="Kotlin">fun handleStrings(list: MutableList&lt;String) {
    if (list is ArrayList) {
        // list is smart-cast to ArrayList&lt;String&gt;
    }
}
</code></pre>

<p>这个方法并不涉及泛型类型，已经知道了具体的类型参数是String，所以类型操作也是可行的，因为编译器知道具体的类型，能对类型进行检查 保证是类型安全的。并且因为具体类型参数String可以推断出来，所以&lt;String&gt;是可以省略的。</p>

<h2>未检查的转换</h2>

<p>当编译器能推断出具体的类型时，进行类型转换就是安全的，这就是被检查的转型（checked cast），如上面的&#127792;。</p>

<p>如果无法推断出类型时，比如涉及泛型类型T时，因为类型会被擦除，编译器不知道具体的类型，这时as T或者as List&lt;T&gt;都是不安全的，编译器会报错，这就是未检查转型（unchecked cast）。</p>

<p>但如果能确信是类型转换是安全的，可以用注解&#64;Suppress(&ldquo;UNCHECKED_CAST&rdquo;)来忽略。</p>

<h2>用关键reified修饰inline泛型函数</h2>

<p><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.Y0Gq_pPe6TUb1g0oEN_51wHaEb?rs=1&amp;pid=ImgDetMain" alt="" /></p>

<p>要想能够对泛型类型参数T做类型操作，只能是在用关键字reified修饰了的inline泛型函数，在这种函数体内可以对泛型类型参数T做类型操作，&#127792;如：</p>

<pre><code class="Kotlin">inline fun &lt;reified A, reified B&gt; Pair&lt;*, *&gt;.asPairOf(): Pair&lt;A, B&gt;? {
    if (first !is A || second !is B) return null
    return first as A to second as B
}

val somePair: Pair&lt;Any?, Any?&gt; = "items" to listOf(1, 2, 3)


val stringToSomething = somePair.asPairOf&lt;String, Any&gt;()
val stringToInt = somePair.asPairOf&lt;String, Int&gt;()
</code></pre>

<p>需要注意的是关键字reified能够让针对类型参数T的操作得到编译器的检查，保证安全，是允许的。但是对于泛型仍是不允许的，&#127792;如：</p>

<pre><code class="Kotlin">inline fun &lt;reified T&gt; List&lt;*&gt;.asListOfType(): List&lt;T&gt;? =
    if (all { it is T })
        @Suppress("UNCHECKED_CAST")
        this as List&lt;T&gt; else
        null
</code></pre>

<p>这个inline泛型函数用关键字reified修饰了，因此针对类型参数T是允许类型检查类型转换，如第2行是允许的。但泛型仍是不合法，如第4行，这时可以用上一小节提到的注解&#64;Suppress(&ldquo;UNCHECKED_CAST&rdquo;)来忽略未检查类型转换。</p>

<h2>inline和reified的原理</h2>

<p>对于一些泛型工厂方法，就非常适合使用inline和reified，以保证转换为类型参数（因为工厂方法最终肯定要as T）是允许的且是安全的：</p>

<pre><code class="Kotlin">inline fun &lt;reified T&gt; logger(): Logger = LoggerFactory.getLogger(T::class.java)

class User {
    private val log = logger&lt;User&gt;()
    // ...
}
</code></pre>

<p>关键字reified其实也没有什么神秘的，因为这是inline函数，这种函数是会把函数体嵌入到任何调用它的地方（call site），而每个调用泛型函数的地方必然会有明确的具体类型参数，那么编译器就知道了具体的类型能保证类型安全（checked cast）。上面的工厂方法在调用时就会大概变成酱紫：</p>

<pre><code class="Kotlin">class User {
    private val log = LoggerFactory.getLogger(User.class.java)
}
</code></pre>

<p>这时其实在函数体内已经知道了具体的类型参数User，编译器能够进行类型检查，所以是安全的。</p>

<h2>总结</h2>

<p>本文深入的讨论一下运行时泛型的一些特性，泛型类型在运行时会被擦除，无法做泛型相关的类型操作，因为编译器无法保证其类型安全。例外就是在用reified修饰的inline函数中可以对类型参数T做类型操作，但泛型类型（带尖括号的&lt;T&gt;）仍是会被擦除，可以用注解&#64;Suppress(&ldquo;UNCHECKED_CAST&rdquo;)来忽略unchecked cast。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/generics.html#type-erasure">Type erasure</a></li>
<li><a href="https://www.baeldung.com/kotlin/generics#generics-at-runtime">6. Generics at Runtime</a></li>
<li><a href="https://www.baeldung.com/kotlin/type-erased-list-array-conversion">How to Convert a Type-Erased List to an Array in Kotlin</a></li>
<li><a href="https://discuss.kotlinlang.org/t/type-erasure/14519">Discussion about Type Erasure</a></li>
<li><a href="https://stackoverflow.com/questions/42916801/how-does-erasure-work-in-kotlin">How does erasure work in Kotlin?</a></li>
<li><a href="https://workingdev.net/2018/09/reified-generics-in-kotlin.html">Reified Generics in Kotlin</a></li>
<li><a href="https://duongnt.com/type-erasure-reified/">Type erasure and reified in Kotlin</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin Generics Revisited]]></title>
    <link href="https://alexhilton.github.io/blog/2024/03/13/kotlin-generics-revisited/"/>
    <updated>2024-03-13T22:33:20+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/03/13/kotlin-generics-revisited</id>
    <content type="html"><![CDATA[<p>在前面的文章中学习Kotlin泛型的基本知识，并且又用了一篇文章来复习了一下Java语言的泛型，有了这些基础我们就可以继续深入的学习Kotlin的泛型了。看它是如何解决Java泛型的遗留问题，再学习一下它的高级特性，最后再总结泛型的最佳实践。</p>

<p><a href=""><img src="https://koenig-media.raywenderlich.com/uploads/2019/09/Generics-feature.png" width="480" height="480"></a></p>

<!-- more -->


<p>本文是作为前面文章的延续和深化，为了更好的阅读效果，建议先回顾一下<a href="/blog/2024/03/10/java-generics-made-easy/">Java泛型基础</a>，和<a href="/blog/2024/03/04/kotlin-generics-made-easy/">Kotlin泛型基础</a>。</p>

<h2>泛型类型参数界限（Upper bounds）</h2>

<p>我们在前面讲解<a href="/blog/2024/03/10/java-generics-made-easy/">Java泛型基础</a>时提到了在声明泛型的时候是可以指定类型参数的界限的，比如用Caculator&lt;T extends Number&gt;可以指定在使用时可以传入的类型参数要是Number或者Number的子类。</p>

<p>在Kotlin中也是可以指定泛型类型参数的界限的，也是用<strong>继承符号:来表示</strong>，&#127792;如：</p>

<pre><code class="Kotlin">class Calculator&lt;T : Number&gt; { ... }
</code></pre>

<p>与Java一样，也可以指定多个界限，要<strong>使用where关键字</strong>：</p>

<pre><code class="Kotlin">class Calculator&lt;T&gt; where T : Number, T : Runnable, T : Closable { ... }

fun &lt;T&gt; copyWhenGreater(list: List&lt;T&gt;, threshold: T): List&lt;String&gt;
    where T : CharSequence,
          T : Comparable&lt;T&gt; {
    return list.filter { it &gt; threshold }.map { it.toString() }
}
</code></pre>

<p>注意：面向对象的继承体系是基类在上面，子类在下面，所以上界的意思是以某个类A为根的继承树，这颗树都可以当成A来使用；下界的意思是从根A到以某个类C为止的一个路径，这个路径上都是C的基类，C都可以当成它们来用。</p>

<p><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/20221025185149/Hierarchical-Inheritance-in-Java.jpg" alt="" /></p>

<h2>更优雅的泛型变化(Variance)</h2>

<p>与Java一样，Kotlin的泛型也是不可变的Invariant，比如虽然String是Any的子类，但List&lt;String&gt;并不是List&lt;Any&gt;的子类。泛型变化Variance的目的就是让两个泛型产生与类型参数协同的变化，比如类型C是类A的子类，那么使用它的泛型&lt;C&gt;也应该是&lt;A&gt;的子类，能使用&lt;A&gt;的方，传入&lt;C&gt;一定要是允许的，并要能够是安全的。</p>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.HRZ3CHxJfgk_hG9T11siDQHaD4?rs=1&amp;pid=ImgDetMain" alt="" /></p>

<h3>使用点变化（Use-site variance）</h3>

<p>基于面向对象的基本特性，只有向上转型(Upcasting)是安全的。具体就分为两种场景，从一个生产者中读取对象时，只要生产者的输出声明的T是基类（T是一个上限），无论生产者输出的是T还是它的子类，对于使用者来说（当T来用）就是安全的。这时生产者的泛型要能够进行协变，在Java中用上界界限通配符&lt;? extends T&gt;来进行协变，具体使用时传入T的子类的泛型也是合法的；同理，向一个消费者中写数据时，消费者声明为T的某个基类（这时T是一个下限），向其传入T，对于使用者来说就是安全的。这时消费者的泛型要能进行逆变，在Java中使用下界界限通配符&lt;? super T&gt;来进行逆变，具体使用时传T的基类的泛型也是合法的。</p>

<p>Kotlin中提供了非常容易理解和使用的<strong>关键字out来进行协变（covariance）和in进行逆变（contravariance）</strong>，可以实现Java中的界限通配符一样的功效。Java界限通配符的规则是<strong>PECS（Producer Extends Consumer Super）</strong>，out正好可以更形象的描述一个生产者，而in可以更形象的描述一个消费者，所以Kotlin的关键字更容易理解和记忆。</p>

<pre><code class="Kotlin">open class Animal
class Dog : Animal()

class MyList&lt;E&gt; {
    fun addAll(from: MyList&lt;out E&gt;) {}
    fun getAll(to: MyList&lt;in E&gt;) {}
}

fun main() {
    val animals = MyList&lt;Animal&gt;()
    val dogs = MyList&lt;Dog&gt;()

    animals.addAll(dogs)
    dogs.getAll(animals)
}
</code></pre>

<p>这种泛型变化是发生在调用者调用时，因此也叫做『使用点变化』(Use-site variance)。在Kotlin中也被称作<strong>类型映射</strong>，因为相当于是用&lt;out T&gt;把T给映射成了一个T的生产者，只能调用其get方法；用&lt;in T&gt;映射成一个T的消费者，只能调用set方法。并且呢，对于同一个函数中既有生产者和消费者时，in和out只写一个就行了，&#127792;如：</p>

<pre><code class="Kotlin">fun copy(from: Array&lt;out Any&gt;, to: Array&lt;Any&gt;) { ... }
</code></pre>

<h3>声明点变化（Declaration-site variance）</h3>

<p>Java界限通配符的一个大问题是只能用于方法的参数但不能是返回值，也就是只能是『Use-site variance』。但in和out没有这个限制，因此它们可以用于返回值。只要给类和接口的泛型声明为out或者in就能让类型参数在其所有的方法产生variance，这就是『declaration-site variance』。</p>

<p>但是要遵守out进行协变，也就是<strong>说out是用于生产者</strong>的，只能作为方法的返回值，或者保证不能set，&#127792;如：</p>

<pre><code class="Kotlin">interface Source&lt;out T&gt; {
    fun nextT(): T
}

fun demo(strs: Source&lt;String&gt;) {
    val objects: Source&lt;Any&gt; = strs // This is OK, since T is an out-parameter
    // ...
}
</code></pre>

<p>同理，<strong>用in进行逆变，只能用于消费者</strong>，只能作为方法的参数，或者保证不get，&#127792;如：</p>

<pre><code>interface Comparable&lt;in T&gt; {
    operator fun compareTo(other: T): Int
}

fun demo(x: Comparable&lt;Number&gt;) {
    x.compareTo(1.0) // 1.0 has type Double, which is a subtype of Number
    // Thus, you can assign x to a variable of type Comparable&lt;Double&gt;
    val y: Comparable&lt;Double&gt; = x // OK!
}
</code></pre>

<p>小结一下，Kotlin使用关键字in和out让泛型的协变和逆变变得容易理解得多了，因为它们能够非常清楚的表达出消费者和生产者，只需要记住一个泛型的生产者要用out来修饰，而一个泛型的消费者要用in来修饰就不会出错，这比Java中的界限通配符简单太多了。</p>

<h2>星号映射(Star projections)</h2>

<p>除了use-site variance是一种类型映射外，还有星号映射。首先来说<strong>星号是无界泛型</strong>，也就是说不指定具体的类型参数，意思是任意类型的泛型，换句话说Foo&lt;&#42;&gt;是任何其他泛型的基类（Foo&lt;String&gt;, Foo&lt;Number&gt;等）。但根据不同的上下文，Foo&lt;&#42;&gt;会映射为不同的具体意义的泛型类型：</p>

<ul>
<li>对于Foo&lt;out T : TUpper&gt;，这里的T是一个受上界TUpper限制的协变类型参数，那么Foo&lt;&#42;&gt;就等同于Foo&lt;out TUpper&gt;。</li>
<li>对于Foo&lt;in T&gt;，这里T是逆变类型参数，Foo&lt;&#42;&gt;等同于Foo&lt;in Nothing&gt;。这意思是无法向Foo&lt;&#42;&gt;中写。</li>
<li>对于Foot&lt;T : TUpper&gt;，这里T是一个被上界TUpper限定的不可变类型参数，那么Foo&lt;&#42;&gt;，在读时（作为生产者）等同于Foo&lt;out TUpper&gt;，在写时（作为消费者）等同于Foo&lt;in Nothing&gt;。</li>
</ul>


<p>如果泛型是多元的，那么每个类型参数可以进行不同的映射。比如说如果一个类型是这样声明的interface Function&lt;in T, out U&gt;，那么会有这样的映射：</p>

<ul>
<li>Function&lt;&#42;, String&gt; 意思是Function&lt;in Nothing, String&gt;</li>
<li>Function&lt;Int, &#42;&gt; 意思是Function&lt;Int, out Any?&gt;</li>
<li>Function&lt;&#42;, &#42;&gt; 意思是Function&lt;in Nothing, out Any?&gt;</li>
</ul>


<p>换句话来理解，就是当不指定具体的类型参数，用星星就代表着不知道具体的类型参数，那么视具体的上下文不同星号会被解释不同的意思。不过这玩意儿可读性较差，除非必不得已，否则还是能不用就用它。</p>

<p>注意：在Kotlin中，<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/">根基类是Any</a>它是所有其他类的基类（the root of Kotlin class hierarchy）。而<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-nothing.html">Nothing</a>是不能有实例的类，可以用它来表示不存在的对象（a value that never exists）。比如说，如果 一个函数返回值类型声明为Nothing，那它就不会返回（always throws an exception），注意是<strong>不会返回（never returns）</strong>，并不是没有返回值，没有返回值要<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/">声明为类型Unit</a>。</p>

<h2>绝不为空类型（Definitely non-null type）</h2>

<p>为了保持对Java的互通性，Kotlin还支持把泛型类型参数声明为『绝不为空类型』definitely non-null type。可以<strong>用&amp; Any来声明</strong>，如&lt;T &amp; Any&gt;来声明T是『绝不为空类型』。</p>

<p>这是为了保持与Java的相互调用，有些Java的类和接口是用<strong>注解&#64;NonNull修饰的</strong>，如：</p>

<pre><code class="Java">public interface Game&lt;T&gt; {
    public T save(T x) {}
    @NotNull
    public T load(@NotNull T x) {}
}
</code></pre>

<p>这时在Kotlin里面就要用到<strong>『绝不为空类型』&amp; Any来声明泛型</strong>：</p>

<pre><code class="Kotlin">interface ArcadeGame&lt;T1&gt; : Game&lt;T1&gt; {
    override fun save(x: T1): T1
    // T1 is definitely non-nullable
    override fun load(x: T1 &amp; Any): T1 &amp; Any
}
</code></pre>

<p>注意，在纯Kotlin代码中是用不到这个特性的。只有当涉及Java的&#64; NonNull时才需要『绝不为空类型』。</p>

<h2>下划线操作符</h2>

<p>当编译器能推断出泛型的类型参数时是可以省略掉类型参数的，比如val names = listOf(&ldquo;James&rdquo;, &ldquo;Kevin&rdquo;)，这里得到的类型是List&lt;String&gt;，但我们并没有显示的指定类型参数，这是因为编译器从listOf的参数中就能推断出类型参数是String，所以listOf的返回就是List&lt;String&gt;。</p>

<p>但有些时候，泛型类型太复杂了，没有办法推断出所有的类型，比如有多元泛型参数时。但根据指定的某一个参数，可以推断出剩余的参数时，这时就没有办法完全省略类型参数，剩余的参数却又可以推断出来，写了又浪费。这时就可以用下划线操作符来代表那些可以推断出来的参数。这里的下划线用法跟在lambda中，用下划线替代不使用的参数是一样的。</p>

<pre><code class="Kotlin">abstract class SomeClass&lt;T&gt; {
    abstract fun execute() : T
}

class SomeImplementation : SomeClass&lt;String&gt;() {
    override fun execute(): String = "Test"
}

class OtherImplementation : SomeClass&lt;Int&gt;() {
    override fun execute(): Int = 42
}

object Runner {
    inline fun &lt;reified S: SomeClass&lt;T&gt;, T&gt; run() : T {
        return S::class.java.getDeclaredConstructor().newInstance().execute()
    }
}

fun main() {
    // T is inferred as String because SomeImplementation derives from SomeClass&lt;String&gt;
    val s = Runner.run&lt;SomeImplementation, _&gt;()
    assert(s == "Test")

    // T is inferred as Int because OtherImplementation derives from SomeClass&lt;Int&gt;
    val n = Runner.run&lt;OtherImplementation, _&gt;()
    assert(n == 42)
}
</code></pre>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/generics.html">Generics: in, out, where</a></li>
<li><a href="https://www.gyata.ai/kotlin/kotlin-generics/">Kotlin Generics</a></li>
<li><a href="https://blog.logrocket.com/understanding-kotlin-generics/">Understanding Kotlin generics</a></li>
<li><a href="https://sebhastian.com/kotlin-generics/#google_vignette">Kotlin generics explained with code examples</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/143380842">深入解析Kotlin 泛型</a></li>
<li><a href="https://juejin.cn/post/6959859571242303495">Kotlin（六）深入理解Kotlin泛型</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
