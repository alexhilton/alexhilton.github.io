<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Kotlin | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/kotlin/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2024-03-11T23:53:25+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[这回就好好聊聊Kotlin的泛型]]></title>
    <link href="http://toughcoder.net/blog/2024/03/04/kotlin-generics-made-easy/"/>
    <updated>2024-03-04T22:51:58+08:00</updated>
    <id>http://toughcoder.net/blog/2024/03/04/kotlin-generics-made-easy</id>
    <content type="html"><![CDATA[<p>泛型(Generics)是静态强类型编程语言中非常强大的特性，可以极大的加强代码的复用，并增强类型安全，减少运行时的类型转换错误。在这篇文章就来详细的学习一下Kotlin中对泛型的支持情况，并学会写出类型安全的可复用代码。</p>

<p><a href=""><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.bl_F0aycuia6QRYMt4AOfQHaFc?rs=1&amp;pid=ImgDetMain" title="auto auto" ></a></p>

<!-- more -->


<h2>泛型基础</h2>

<p>泛型的本质就是能够创建参数化的对象和函数，以实现复用。比如说，我们最熟悉的集合List，它是<strong>与具体类型无关</strong>的数据结构，或者叫做对象容器。列表List的重点在于可扩展长度，但里面具体的对象类型并不是重点，只要是一个对象就可以了。假如没有泛型，可能就要写很多重复的代码，比如字符串列表StringList，数字列表NumberList，等等。用泛型，只<strong>用一个参数化</strong>的List就可以了，用尖括号<strong>&lt;&gt;</strong>来表示参数化。</p>

<pre><code class="Kotlin">val names: List&lt;String&gt; = listOf("James", "Kevin", "Harden")
val rebounds: List&lt;Int&gt; = listOf(2, 14, 7)
</code></pre>

<p>泛型有两种形式，一种是对类进行参数化如List<String>，一种是对函数进行参数化，如max<Int>()。</p>

<h3>参数化的类</h3>

<p>声明方式就是在声明类的时候在类的名字后面用尖括号<strong>&lt;&gt;</strong>来带上一个类型参数，然后在内部就可以当成一个类型来使用：</p>

<pre><code class="Kotlin">class Box&lt;T&gt;(t: T) {
    var value = t
}
</code></pre>

<p>这就创建了一个参数化的容器，它可以持有任何指定类型的对象：</p>

<pre><code class="Kotlin">val box: Box&lt;Int&gt; = Box&lt;Int&gt;(1)
val case: Box&lt;String&gt; = Box&lt;String&gt;("Coat")
</code></pre>

<h3>参数化的函数</h3>

<p>除了参数化的类以外，还可以创建参数化的函数，在函数名字的前面用尖括号<strong>&lt;&gt;</strong>来声明泛型，然后在参数列表以及函数体内就可以当作类型来使用：</p>

<pre><code class="Kotlin">fun &lt;T&gt; singleTonList(item: T): List&lt;T&gt; {
    ...
}
</code></pre>

<p>调用的时候指定一下具体的类型就可以了：</p>

<pre><code class="Kotlin">val l = singletonList&lt;Int&gt;(3)
</code></pre>

<p><strong>注意：</strong>Kotlin语言有强大的类型推断能力，但凡编译器能够推断出类型时，类型的声明都可以省略掉。对于泛型更是如此，比如说，这样写都是合法的：</p>

<pre><code class="Kotlin">val names = listOf("James", "Kevin", "Harden")
val rebounds = listOf(2, 14, 7)
val l = singletonList(3)
</code></pre>

<p>通常情况下，<strong>声明</strong>，<strong>定义</strong>和<strong>赋值</strong>三个地方，只要有一个地方能够让编译器知道具体的类型就够了，其他地方都可以把类型的声明省略掉。</p>

<h2>泛型的本质与优点</h2>

<p>假如不使用泛型，又想写出比较通用的类和函数，唯一可行的方法就是使用通用基类Any当作参数，在Kotlin中Any是所有对象的基类，比如，说想实现一个列表：</p>

<pre><code class="Kotlin">class AnyList {
    fun add(item: Any)
    fun get(idx: Int): Any
}
</code></pre>

<p>这样写可以，但它有很大的问题，就是不能保证类型安全：</p>

<pre><code class="Kotlin">val list = AnyList()
list.add("James")
list.add(13)
val e = (Int) list.get(1)
</code></pre>

<p>一方面我们需要自己进行强行类型转换，但也无法保证你取出来的对象类型与期望的是一致的，更无法保证调用者往里面添加什么对象，因为任何Any的子类都可以让代码通过编译，但在运行时极容易发生类型转换异常ClassCastException。</p>

<p>但用泛型就能很好的解决这个问题，可以得出泛型的优点：</p>

<ol>
<li>不需要做类型转换，编译器会根据指定的具体类型自动做类型转换</li>
<li>类型安全，编译器会帮助做检查，传给泛型的对象必须具有一致的类型，且是指定的类型</li>
<li>保障了运行时的类型安全，因为编译器在编译时做好了检查，所以不会发生运行时的类型错误</li>
</ol>


<p>因此，凡是有需要针对 类型复用的地方，都应该用泛型来实现类型参数化。</p>

<h2>关键字out和关键字in</h2>

<p>大部分情况下，只要给类型和函数加上参数化的类型就够了，但有时候有些复杂情况需要处理。</p>

<h3>协变与逆变</h3>

<p><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98">协变与逆变Covariance and Contravariance</a>是用来描述具有父子继承关系的简单类型，在通过参数化的方法构造出来的更复杂的类型之间是否能保持父子关系的术语。</p>

<p>比如Dog是Animal的子类，根据继承和多态，Dog可以用在任何声明为Animal的语句和表达式中。<strong>变型Variance</strong>指的就是根据已知的父子关系Dog和Animal，如何来确定由它们构成的更复杂类型如List&lt;Dog&gt;和List&lt;Animal&gt;之间的关系？</p>

<p>常规泛型是<strong>不可变的Invariant</strong>，也就是说复杂类型之间的关系与它们具体的参数化类型之间是没有关系的，如List&lt;Dog&gt;并不是List&lt;Animal&gt;，它们之间没有任何关系，不能把List&lt;Dog&gt;当成是List&lt;Animal&gt;，虽然Dog可以被当作Animal。</p>

<p>不可变Invariant有时候会带来不方便，比如说，集合通常都有addAll方法来批量的把对象加入到集合中：</p>

<pre><code class="Kotlin">class List&lt;T&gt; {
    fun addAll(from: List&lt;T&gt;) {
        for (x in from) {
            add(x)
        }
    }
}
val objs: List&lt;Any&gt; = emptyList()
val names: List&lt;String&gt; = listOf("James", "Kevin", "Harden")
objs.addAll(names) // No go, compile error
</code></pre>

<p>这是参数化列表集合，先创建一个具体类型为Any的列表，然后尝试把一个String列表添加到Any列表中，其实这么做是完全安全的，因为String对象是完全可以当作其基类Any来使用的，但泛型的不可变性阻止了我们这么做。</p>

<p>这时就需要<strong>协变</strong>与<strong>逆变</strong>了，也就是通过一定的方法让复杂类型的行为与其参数化类型之间进行协同。</p>

<p><img src="https://phpstan.org/covariance-contravariance.4483af19.png" alt="" /></p>

<h3>关键字out进行协变</h3>

<p>使用out关键能够让泛型进行协变。比如上面例子理想的情况应该是，只要能当作T的类型，都应该能用在addAll中，换句话说把T的子类的列表也应该能够支持，即objs.addAll(names)应该能正常编译并正常运行。使用关键out即可达到这样的效果：</p>

<pre><code class="Kotlin">class List&lt;out T&gt; {
    fun addAll(from: List&lt;T&gt;) {
        for (x in from) {
            add(x)
        }
    }
}
val objs: List&lt;Any&gt; = emptyList()
val names: List&lt;String&gt; = listOf("James", "Kevin", "Harden")
objs.addAll(names) // Okay
</code></pre>

<p>这里的泛型参数from: List<out T>其实是一个生产者，它生产类型为T的对象，所以这里用out来修饰，产出的对象是T或者是T的子类都是会是合法的。或者说当我们想把一个子类的泛型赋给父类的泛型时，就需要对泛型声明为out，以进行协变。</p>

<p><strong>注意：</strong>关键字out与Java泛型中的extend通配符的作用是一样的，指定参数的上限，生产者产生的对象都会向上转型(upcast)为基类，所以需要指定一个上限。</p>

<p>与之相对的，还有in逆变。</p>

<h3>关键字in进行逆变</h3>

<p>有时候情况是相反的，也就是说我们持有的是父类的泛型，但 我们想把它赋给其子类的泛型，这时就可以用in进行逆变。而且必须注意in只能用在消费者中，也就是说是在真实消费对象，为什么呢？其实这里真实发生的是向下转型(downcast)&ndash;把父类的对象赋给子类的引用上面，而向下转型不一定保证是安全的。所以，必须是在真实消费这个对象的地方，只有是期望的真实对象才能被消费。</p>

<pre><code class="Kotlin">class ParameterizedConsumer&lt;in T&gt; {
    fun toString(value: T): String {
        return value.toString()
    }
}

val parameterizedConsumer = ParameterizedConsumer&lt;Number&gt;()

val ref: ParameterizedConsumer&lt;Double&gt; = parameterizedConsumer
</code></pre>

<p><strong>注意：</strong>关键字in与Java泛型中的super是一样的，指定一个下限，因为在消费对象时会转成T，用T来限制成为下限，那么向下转型(downcast)就是安全的。</p>

<h2>任意类型的泛型</h2>

<p>有些比较简单粗暴的场景，就是单纯的想让任意类型的泛型都可以使用，这时关键字out和关键字in可能都不太合适，因为它们只能用于生产者和消费者场景，用以指定类型上限和类型下限。这时可以用<strong>星号&#42;</strong>来当用泛型参数，以表示任意具体类型的泛型都可以使用。</p>

<pre><code class="Kotlin">fun printArray(array: Array&lt;*&gt;) { 
    array.forEach { println(it) }
}

val array = arrayOf(1,2,3) 
printArray(array)
</code></pre>

<h2>关键字reified</h2>

<h3>运行时泛型擦除</h3>

<p>需要注意的是泛型类型在运行时会被擦除(erased)，也就是说在运行时任何对象都是不带有其泛型类型的，具体点的，就是List&lt;String&gt;和List&lt;Int&gt;在运行时，它们的对象实例是一样的，无法知道它们的具体的泛型参数类型。前面讲的各种规则都是发生在编译时间，编译器帮助检查传入的泛型对象是否符合规划，并进行类型转换。到了运行时，泛型类型会被擦除。(为啥会被擦除呢？因为JVM要保持向后兼容，早期的Java没有泛型，只有原始的类型对象(raw type)，所以后来1.5版本后加入的泛型只有擦除掉变成raw type才能保持兼容。)</p>

<h3>关键字reified</h3>

<p>泛型类型擦除会带来一个问题，就是对于泛型类型对象，无法做类型检查(is T)，无法做类型转换(as T)，因为运行时的对象根本不知道它的泛型类型是什么，这会带来极大的不方便，特别是工厂方法就无法使用泛型了，因为无法做类型检查 和转换。</p>

<p>这时inline再加上关键字reified就能完美的解决问题，它们两个配合起来运行时就能保留泛型类型了：</p>

<pre><code class="Kotlin">inline fun &lt;reified T&gt; Iterable&lt;*&gt;.filterIsInstance() = filter { it is T }

&gt;&gt; val set = setOf("1984", 2, 3, "Brave new world", 11)
&gt;&gt; println(set.filterIsInstance&lt;Int&gt;())
[2, 3, 11]
</code></pre>

<p>可以看到类型判断起来作用了。再看一个泛型工厂方法的例子：</p>

<pre><code class="Kotlin">inline fun &lt;reified T&gt; logger(): Logger = LoggerFactory.getLogger(T::class.java)

class User {
    private val log = logger&lt;User&gt;()
    // ...
}
</code></pre>

<h2>练习</h2>

<p>这里强烈推荐谷歌官方给出的关于Kotlin语言中的<a href="https://developer.android.com/codelabs/basic-android-kotlin-compose-generics#0">类型相关的小练习</a>，可以用来巩固加强一下所学的知识。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/generics.html">Generics: in, out, where</a></li>
<li><a href="https://www.geeksforgeeks.org/kotlin-generics/">Kotlin generics</a></li>
<li><a href="https://www.baeldung.com/kotlin/generics">Generics in Kotlin</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32583310">Kotlin 泛型中的 in 和 out</a></li>
<li><a href="https://blog.csdn.net/u011897062/article/details/130832411">Kotlin泛型＜in, out, where＞概念及示例</a></li>
<li><a href="https://rengwuxian.com/kotlin-generics/">Kotlin 的泛型</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一文带你吃透Kotlin类与对象]]></title>
    <link href="http://toughcoder.net/blog/2024/02/26/kotlin-class-made-easy/"/>
    <updated>2024-02-26T21:22:39+08:00</updated>
    <id>http://toughcoder.net/blog/2024/02/26/kotlin-class-made-easy</id>
    <content type="html"><![CDATA[<p>Kotlin是多范式通用编程语言，对面向对象编程(OOP)自然也提供了全方位的支持。通过<a href="http://toughcoder.net/blog/2018/05/17/introduction-to-kotlin-programming-language/">先前一篇文章</a>，学习了使用Kotlin进行基本面向对象编程的方法，本文将在前文基础之上继续深入的学习面向对象编程的高级特性，以能够写出更加符合OO的代码，并能够从容应对一些复杂的OOP场景。</p>

<p><a href=""><img src="https://bigknol.com/wp-content/uploads/2023/07/kotlin_class_objects.png" title="auto auto" ></a></p>

<!-- more -->


<h2>注意构造的顺序</h2>

<p>在构造对象过程中，有三个地方可以对成员进行初始化：1）是在<strong>首构造方法（Primary constructor）</strong>；2）是在声明成员的同时进行初始化，或者是在<strong>初始化代码块(init {&hellip;})</strong>中；3）是在<strong>次要构造方法(Secondary constructor)</strong>中。</p>

<p>要注意它们之间的<strong>区别和执行顺序</strong>，首构造方法是最先执行的，但它不能运行代码，只能进行赋值；成员声明和初始化代码块(init {&hellip;})是首构造方法的一部分，因此要先于次要构造方法。次要构造方法是最后执行，并且次要构造方法一定要委托到首构造方法。成员声明和初始化代码块之间则依赖于书写的顺序，从上到下执行。</p>

<p>虽然编译器有它的规则来保障顺序，但为了可读性和可维护性，我们不应该完全依赖编译器。这里建议的方式是：</p>

<ul>
<li>把类的最核心的成员放在首构造方法，如必须要依赖的参数，公开的成员，类型体系中的核心成员等，这些应该直接放在首构造方法中，并按重要的顺序进行声明，这样也能方便进行依赖注入和测试Mock对象替换。</li>
<li>私有成员应该在类中声明，并且在声明时进行初始化，如果无法初始化就标记为延迟初始(late init)。</li>
<li>初始化代码块，应该做一些复杂的初始化过程，或者成员之间有关联的初始化，或者做一些构造完成之后的操作。比如像在ViewModel中，构造之后，可能执行拉取数据，这就非常适合放在init {&hellip;}之中。</li>
<li>不建议使用次要构造方法，可以用<strong>给首构造方法的参数设置默认值</strong>的方式来进行成员参数上的重载。</li>
<li>初始化代码块要放在所有成员声明之后，以保障执行顺序。</li>
</ul>


<p>扩展阅读<a href="https://kotlinlang.org/docs/classes.html">Classes﻿</a>和<a href="https://kotlinlang.org/docs/properties.html">Properties﻿</a>。</p>

<h2>妙用late init</h2>

<p>通常成员的初始化可以在声明时完成，比如像集合或者一些简单的原始类型对象（Int, Float, String等）。但如果初始化过程比较复杂，或者初始值较难获得，这种情况下，就适合标记为<strong>延迟初始化late init</strong>，然后在合适的时机对成员进行初始化（比如系统框架层的回调中，或者依赖注入等等）。使用一个未初始化的late init成员时会抛出一个叫做<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-uninitialized-property-access-exception/">UninitializedPropertyAccessException</a>的异常，可以在使用成员变量前用<a href="https://kotlinlang.org/docs/reflection.html#property-references">.isInitialized</a>来判断成员变量是否初始化过：</p>

<pre><code class="Kotlin">if (foo::bar.isInitialized) {
    println(foo.bar)
}
</code></pre>

<p>可以发现，对于Android 开发来说<strong>late init</strong>绝对非常有用，因为对于系统组件，我们无法在其构造方法中进行成员初始化，通常都是在第一个回调(如onCreate)中进行初始化，而这些变量全都应该用late init来标记。</p>

<p>另外，需要注意的是，成员是否有被初始化与成员是否是非法值(如null)并不是同一回事，初始化是第一次对成员对象赋值，赋的什么值(正常对象or null)虚拟机并不关心，但只要有过赋值后变量就初始化过了。因此，<strong>用late init可以帮助减少null检查</strong>。</p>

<p>还需要注意的是，延迟初始化late init与属性委托也不是同一回事，late init通常用于内部私有的成员变量，而属性委托通常用于对外开放的公开成员。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/properties.html">Properties</a>。</p>

<h2>函数式接口</h2>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.aCUdGlN1mIUaSZQXKdceSgHaD4?rs=1&amp;pid=ImgDetMain" alt="" /></p>

<p>接口(interfaces)是更高级别的抽象，专注于行为的抽象，用以实现对象间契约式行为交互。这一部分不打算详细讲解interface的使用，而是重点关注函数式接口(function interface)。Kotlin中的接口与Java 8中的接口是一样的，不再全是抽象方法了，可以有默认方法，也就是对接口的方法添加默认的实现，没有默认实现的方法就是抽象方法了（Abstract method）。只有一个抽象方法的接口称之为函数式接口(functional interface)，或者单个抽象方法接口(Single Abstract Method interface)。用fun interface来声明，如：</p>

<pre><code class="Kotlin">fun interface IntPredict {
    fun accept(i: Int): Boolean
}
</code></pre>

<p>函数式接口的最大优势在于，实现接口时可以简化到只用一个lambda，如：</p>

<pre><code class="Kotlin">val isEnv = IntPredict { it % 2 == 0 }
</code></pre>

<p>注意，只有用fun interface声明的含有一个抽象方法的接口才是函数式接口，才能用lambda。对于普通接口，如果它仅含有一个抽象方法，可以转化为函数式接口，比如原接口是酱紫的：</p>

<pre><code class="Kotlin">interface Printer {
    fun print()
}
</code></pre>

<p>那么，可以直接定义一个fun interface Printer就可以了：</p>

<pre><code class="Kotlin">fun interface Printer {
    fun print()
}
</code></pre>

<p>编译器会帮忙做转化。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/fun-interfaces.html">Functional (SAM) interfaces</a>。</p>

<h2>关键字object的妙用</h2>

<p>关键字object用以方便创建匿名对象的场景，如匿名对象，单例以及静态内部类。</p>

<h3>使用匿名对象</h3>

<p>有些时候我们会实现一些接口，或者继承某个基类，但仅是在本地一次性使用(One shot)，这时匿名对象就派上用场了，类似于Java中的匿名内部类。用<strong>object : </strong>后面跟要实现的接口或者要继承的类：</p>

<pre><code class="Kotlin">window.addMouseListener(object : MouseAdapter() {
    override fun mouseClicked(e: MouseEvent) { ... }
    override fun mouseEntered(e: MouseEvent) { ... }
})
</code></pre>

<h3>单例对象</h3>

<p>用object可以非常方便的实现单例模式：</p>

<pre><code class="Kotlin">object DataProviderManager {
    fun registerDataProvider(provider: DataProvider) { ... }
    val allDataProviders: List&lt;DataProvider&gt;
        get() = { ... }
}
</code></pre>

<p>使用时就直接用类名就可以了：DataProviderManager.registerDataProvider(&hellip;)。</p>

<h3>静态成员和方法</h3>

<p><img src="https://ts1.cn.mm.bing.net/th/id/R-C.b4723d86a22037c40298fff12e484b19?rik=tyTmLVbaHs9Mpw&amp;pid=ImgRaw&amp;r=0" alt="" /></p>

<p>在Java中有静态的成员和方法，用以实现一些属于类的成员和方法，在Kotlin中就需要用companion object来实现同样的功能。</p>

<pre><code class="Kotlin">class MyClass {
    companion object Factory {
        fun create(): MyClass = MyClass()
    }
}
</code></pre>

<p>使用时就是用类+方法：MyClass.create()。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/object-declarations.html">Object expressions and declarations</a>。</p>

<h2>纯数据类型</h2>

<p><img src="https://qwebtechnologies.com/blog/wp-content/uploads/2023/03/Kotlin-Data-Class.png" alt="" /></p>

<p>对于函数式编程，通常要写大量的<a href="https://en.wikipedia.org/wiki/Plain_old_Java_object">PoJo</a>用以在函数之间传递数据，这些对象最大的特点就是仅是数据，且不可变(Immutable)，通常的实现方式就是把成员变量全用final修饰（只读read only）。在Kotlin中，可以非常方便的定义这要的类型，即data class。</p>

<pre><code class="Kotlin">data class User(val name: String, val age: Int)
</code></pre>

<p>针对data class，编译器会自动生成equals, hashCode, toString, copy和componentN方法。注意，虽然成员可以标记为var，但不建议这样做，最好还是都标记为只读val，因为data class就是要Immutable。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/data-classes.html">Data classes</a>。</p>

<h2>密封类和接口</h2>

<p>密封类和接口是指用<strong>关键字sealed</strong>修饰的类和接口。它的作用是限制类的层次结构，用sealed修饰的类和接口，它们的所有子类必须在编译的时候就已知，一旦编译完成，不允许再被继承。</p>

<p>密封类型特别适用于库的设计，能够保证库的完整性。通常用于修饰库中的一些关键的有明确类型要求的类型，如<strong>消息类型，错误类型</strong>等等。因为，库会预定义一些消息类型，以及处理消息的接口，假如调用者扩展了某一消息类型，加了很多自定义的东西，这时再用库中的接口来处理的时候，可能会产生未预期的行为，因为库可能不认识这个新的新的消息类型，但因为是子类继承，语法上是合法的。这时密封类型就能派上用场，把消息类型用sealed修饰，就能保证库的完备性，它提供的错误处理接口一定可以正确处理它定义的消息类型。但注意不能滥用，没有必要为库的每一个类和接口都用sealed修饰，其实大部分时候我们是用不到sealed的。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/sealed-classes.html">Sealed classes and interfaces</a>。</p>

<h2>类型别名</h2>

<p>一个非常有意思的特性是类型别名，并不是定义一个新类型，而是取个别名。一般情况下，是为了方便，比如目标类型名字太长时，或者有大量的泛型参数时，就可以为它定义一个别名，图个省流。</p>

<pre><code class="Kotlin">typealias NodeSet = Set&lt;Network.Node&gt;

typealias MyHandler = (Int, String, Any) -&gt; Unit
</code></pre>

<p>扩展阅读<a href="https://kotlinlang.org/docs/type-aliases.html">Type aliases</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[专家之路上的Flow高级秘籍]]></title>
    <link href="http://toughcoder.net/blog/2024/01/27/an-advanced-guide-to-kotlin-flow/"/>
    <updated>2024-01-27T20:59:38+08:00</updated>
    <id>http://toughcoder.net/blog/2024/01/27/an-advanced-guide-to-kotlin-flow</id>
    <content type="html"><![CDATA[<blockquote><p>『君不见，黄河之水天上来，奔流到海不复回。』</p></blockquote>

<p>学习与河流一样，一方面学无止境，又是逆水行舟，不进则退，因为其他人都在卷。<a href="http://toughcoder.net/blog/2024/01/25/kotlin-flow-made-easy/">前文一篇文章</a>讲了Flow的基础，大多数情况下够用了，但是不能停止卷，因为你不卷，就会被别人卷。一旦涉及到复杂的应用场景，就需要用到一些高级的API。今天就来学习一下Flow的高级特性，当遇到问题时也能更从容的应对。</p>

<p><a href=""><img src="https://amitshekhar.me/static/images/blog/flow-api-in-kotlin.png" title="auto auto" ></a></p>

<!-- more -->


<h2>上下文切换</h2>

<p>Flow是基于协程的，是用协程来实现并发，前面也提到过像<a href="">flow {&hellip;}</a>，在上游生产数据，以及中游做变幻时，都是可以直接调用suspend，耗时甚至是阻塞的函数的。而终端操作符如<a href="">collect</a>则是suspend的，调用者（也就是消费者）需要负责确保collect是在协程中调用。我们还知道Flow是是冷流，消费者终端才会触发上游生产者生产，所以对于flow {&hellip;}来说，它的上游和中游运行的上下文来自于终端调用者的上下文，这个叫做『上下文保留』（context preservation），我们可以用一个&#127792; 来验证一下：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    // Should be main by default
    simple().collect { log("Got: $it") }

    // Collect in a specified context
    withContext(Dispatchers.Default) {
        simple().collect { log("Now got: $it") }
    }
}

private fun simple(): Flow&lt;Int&gt; = flow {
    log("Started the simple flow")
    for (i in 1..3) {
        delay(100)
        log("Producing $i")
        emit(i)
    }
}
</code></pre>

<p>输出如下：</p>

<pre><code class="Bash">[main @coroutine#1] Started the simple flow
[main @coroutine#1] Producing 1
[main @coroutine#1] Got: 1
[main @coroutine#1] Producing 2
[main @coroutine#1] Got: 2
[main @coroutine#1] Producing 3
[main @coroutine#1] Got: 3
[DefaultDispatcher-worker-1 @coroutine#1] Started the simple flow
[DefaultDispatcher-worker-1 @coroutine#1] Producing 1
[DefaultDispatcher-worker-1 @coroutine#1] Now got: 1
[DefaultDispatcher-worker-1 @coroutine#1] Producing 2
[DefaultDispatcher-worker-1 @coroutine#1] Now got: 2
[DefaultDispatcher-worker-1 @coroutine#1] Producing 3
[DefaultDispatcher-worker-1 @coroutine#1] Now got: 3
</code></pre>

<p>从这个&#127792; 可以清楚的看到，Flow的context是来自于终端调用者的。</p>

<h3>用flowOn来指定上下文</h3>

<p>有时候使用终端调用者的上下文可能不太方便，因为生产者与消费者的模式其实是解耦的，它们不应该相互受制于对方，对于关键的并发的上下文更是如此。比如说在GUI的应用中，明显应该在工作线程中生产数据，在UI线程中消费数据，从上面的例子来看，由终端调用者来决定上游上下文明显不可取。有同学举手了，欺负我没学过协程是吧？我可以在Flow内部使用withContext来指定上下文啊，我们来试试：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    // Should be main by default
    simple().collect { log("Got: $it") }
}

private fun simple(): Flow&lt;Int&gt; = flow {
    withContext(Dispatchers.Default) {
        log("Started the simple flow")
        for (i in 1..3) {
            delay(100)
            log("Producing $i")
            emit(i)
        }
    }
}
</code></pre>

<p>这位同学可以直接出去了，因为你的代码crash 了：</p>

<pre><code class="Bash">[DefaultDispatcher-worker-1 @coroutine#1] Started the simple flow
[DefaultDispatcher-worker-1 @coroutine#1] Producing 1
Exception in thread "main" java.lang.IllegalStateException: Flow invariant is violated:
        Flow was collected in [CoroutineId(1), "coroutine#1":BlockingCoroutine{Active}@545486c7, BlockingEventLoop@13bfcf14],
        but emission happened in [CoroutineId(1), "coroutine#1":DispatchedCoroutine{Active}@27015c5a, Dispatchers.Default].
        Please refer to 'flow' documentation or use 'flowOn' instead
</code></pre>

<p>意思大概是说Flow内部不让直接用withContext来切上下文，破坏了Flow的不变式，想切上下文要用flowOn。而且仔细看，异常是由emit函数抛出来的。</p>

<p>其实Flow的设计者已经考虑到了这个问题，并且给出了优雅的方式，如果想切换Flow内部（也即上游和中游）的运行上下文，要用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html">flowOn</a>函数：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    // Should be main by default
    simple().collect { log("Got: $it") }
}

private fun simple(): Flow&lt;Int&gt; = flow {
    log("Started the simple flow")
    for (i in 1..3) {
        delay(100)
        log("Producing $i")
        emit(i)
        Thread.sleep(50)
    }
}.flowOn(Dispatchers.Default)
//[DefaultDispatcher-worker-1 @coroutine#2] Started the simple flow
//[DefaultDispatcher-worker-1 @coroutine#2] Producing 1
//[main @coroutine#1] Got: 1
//[DefaultDispatcher-worker-1 @coroutine#2] Producing 2
//[main @coroutine#1] Got: 2
//[DefaultDispatcher-worker-1 @coroutine#2] Producing 3
//[main @coroutine#1] Got: 3
</code></pre>

<p>这回就和谐多了，后台搞生产，UI只展示，完美！还需要特别注意的是<strong>函数flowOn只影响它的上游，不影响它的下游，更不会影响终端</strong>，终端永远都在<strong>其调用者的上下文</strong>中，来看一个&#127792; ：</p>

<pre><code class="Kotlin">withContext(Dispatchers.Main) {    val singleValue = intFlow // will be executed on IO if context wasn't specified before        .map { ... } // Will be executed in IO        .flowOn(Dispatchers.IO)        .filter { ... } // Will be executed in Default        .flowOn(Dispatchers.Default)        .single() // Will be executed in the Main}
</code></pre>

<p>第一个flowOn切到<em>IO</em>，只影响到它前面的创建和map，第二次切换到<em>Default</em>，只影响filter。single是终端，是在<em>Main</em>，因为它的调用者是在<em>Main</em>里面。</p>

<p><strong>注意，注意：</strong> Flow是一个数据流，保持其数据流的特点是相当重要的，无论是正常数据，异常数据，还是出错都是一种数据，应该让其自上而下的流动，在<strong>中游变幻时或者终端时通过操作符来处理</strong>。所以，像硬性的上下文切换，或者异常的try/catch都是不允许的。这就是所谓的流的不变性（Flow invariant）。后面讲异常时还会提到这点。</p>

<h2>任意上下文的Flow builders</h2>

<p>从前面的学习我们知道了，下下文保留的特性，终端会决定上游生产者的上下文，当然也可以通过flowOn来改变上下文。Flow builder其实就是一个生产者，异步的emit数据。但有些时候生产数据时的上下文，也就是调用emit时的上下文，是不确定的。比如说安卓 上面的各种回调（callback）有些是回调在调用者的线程里，有些则不是。<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow.html">flow {&hellip;}</a>中的emit就不能在异步的回调里面调用，这时就要用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/callback-flow.html">callbackFlow {&hellip;}</a>。callbackFlow专门适用于把现有的一些回调转为Flow，最典型的应用就是位置信息：</p>

<pre><code class="Kotlin">fun locationFlow(): Flow&lt;Location&gt; = callbackFlow {
    val listener = object : LocationListener {
        override fun onLocationUpdate(loc: Location) {
            trySend(location)
        }
    }
    locationManager.reqisterLocaitonUpdates(listener)

    awaitClose {
        locationManager.unregisterLocationUpdates(listener)
    }
}
</code></pre>

<p>如果这个Flow，用flow {}去创建会抛异常，因为emit没法在回调中使用。callbackFlow会在回调中发射数据，并在<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/await-close.html">awaitClose</a>代码块中反注册回调以清理资源。awaitClose会在这个流结束时（完成或者被取消）被回调到，以有机会进行资源清理。</p>

<p>其实，无论是flow {}还是callbackFlow {}都是<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/channel-flow.html">channelFlow {}</a>的简单化，channelFlow非常复杂，也超级强大，它可以自带buffer，自带并发，适用于创建一些非常复杂的Flow。在多数时候flow {}和callbackFlow {}就够我们用了。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://stackoverflow.com/questions/61865744/android-kotlin-coroutines-what-is-the-difference-between-flow-callbackflow-ch">Android Kotlin Coroutines: what is the difference between flow, callbackFlow, channelFlow,&hellip; other flow constructors</a></li>
<li><a href="https://www.cnblogs.com/joy99/p/15805962.html">Kotlin 协程四 —— Flow 和 Channel 的应用 </a></li>
<li><a href="https://juejin.cn/post/7220593395420627004">[译]轻松学习Kotlin的Flow、ChannelFlow和CallbackFlow</a></li>
<li><a href="https://juejin.cn/post/7202265125540659259">轻松搞定Kotlin的Flow, ChannelFlow和CallbackFlow - 2</a></li>
</ul>


<h2>副作用函数</h2>

<p>Flow是一个数据流，核心思想是把数据的生产和处理和最终消费分开，上游只负责生产数据，各种操作都应该由中游操作符来做，最终数据由终端消费掉。需要加强数据的封装性，和流的不变性，不破坏管道，用各种转换器来对数据进行操作。那么，对于流何时开始，每个数据何时产生，流什么时候终止，这些事件对于调试来说是很有帮助的。Flow的设计者给出了一系列副作用函数来做之些事情。副作用的意思就是这些函数不会对流本身产生影响。</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-start.html">onStart</a> Flow开始生产之前会调用此函数。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html">onEach</a> 在生产(emit)每个数据之前调用此函数，这个函数最常用被用来打日志，以查看每个产生的数据。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-completion.html">onCompletion</a> 当Flow终止时或者被取消后会调用此函数。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-subscription.html">onSubscritpion</a> 有消费者了时调用此函数（也就是有人collect了此Flow时）。</li>
</ul>


<h2>异常，取消和错误处理</h2>

<p>这一小节重点来看看非正常代码逻辑的处理。先来看看异常处理（Exception handling）。</p>

<h3>用catch函数来处理Flow过程中的异常</h3>

<p>代码随时都可能抛出异常，所以异常处理是一个必须要考虑的事情。当然可以在Flow的各个节点如上游生产，中游变幻和下游终端的代码块里面各种try/catch。一来是不够优雅，再者这会破坏Flow的不变性或者说一致性，它就是管道，数据在里面流动，不应该加以过多的干扰，想要对数据处理应该用操作符。也就是说要让异常（包括其他错误也是如此）对Flow是透明的，意思是说Flow并不关心是否有异常。所以提供了一个<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html">catch函数</a>，它的作用是捕获并处理上游操作中发生的异常：</p>

<pre><code class="Kotlin">simple()    .catch { e -&gt; emit("Caught $e") } // emit on exception    .collect { value -&gt; println(value) }
</code></pre>

<p>需要注意catch与flowOn一样，只影响上游发生的异常，管不了下游：</p>

<pre><code class="Kotlin">flow { emitData() }    .map { computeOne(it) }    .catch { ... } // catches exceptions in emitData and computeOne    .map { computeTwo(it) }    .collect { process(it) } // throws exceptions from process and computeTwo
</code></pre>

<h3>取消Flow</h3>

<p>Flow没有显式的取消函数。Flow是冷流，有消费者时才会去生产数据，消费者停止消费了，Flow自然也就被取消了。终端操作都是suspend的，也就是要在协程中调用，因此<strong>取消终端调用的协程，就会取消Flow。</strong></p>

<h3>错误处理</h3>

<p>其实没有特别的错误处理函数，前面的异常算是一个，如果上游没有抛出异常，就不会有其他错误了，因为错误也是数据的一种类型，并且是由我们自己根据场景来定义的。比如说从网络获取新闻列表，正常时的数据当然是一个个的新闻条目。出错了，比如无网络，或者服务器无响应，这时可能返回一个空的条目，里面有错误的具体信息。但这都是由业务逻辑决定的，是业务逻辑层面的东西。对于Flow而言，都还是有数据的，都是一种数据，具体数据的解读，那是消费者终端的事情，Flow并不关心。</p>

<p>唯一算得上错误处理的函数就是<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-empty.html">onEmpty</a>，它会在Flow是空的时候，也就是不生产任何数据的时候被回调。可以在onEmpty里面生产emit数据，比如产生一个带有错误信息的数据，或者产生一个默认值。因为Flow为空，不产生emit任何数据时，管子是空的数据没有流动，Flow的整个链路，特别是终端collect是不会被执行的，这时可能会有问题，比如UI根本无法做出任何react，除非你设置过了默认UI状态，否则可能会不对。这个时候如果用onEmpty去产生一些默认值或者错误信息的话，就能激活整个Flow，终端能做出预期的响应。</p>

<h3>重试机制</h3>

<p>另一个非常有用的函数就是<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/retry.html">retry</a>，它可以预设一个条件，当条件满足时就会触发重新collect。Flow是冷流，有消费者collect时才会触发生产者emit数据，因此重新collect就能让Flow重新emit数据流。</p>

<h2>背压</h2>

<p>Flow是异步数据流，响应式编程范式，上游生产数据，下游终端消费数据。有时候可能会遇到这样一种情况，就是上游数据生产的速度超过了下游终端的消费速度，这会造成数据流积压在管道中，终端无法及时响应。这种情况称为『背压（Back pressure）』。想像一下一个水管，如果进水速度大于水龙头流出的速度，水就会积压在水管里，如果水管是比较薄弱的（如气球），那么它会膨胀，最后爆掉。</p>

<p>通常情况下，当上游是较为可控的生产者时，不会产生背压，但如果是一些不是开发人员可控的，如硬件（触摸事件，位置信息，传感器，摄像头），其他系统（系统框架的回调，或者服务器的Push）等等，就会产生背压，这时必须进行相应的处理。所有的FRP式异步数据流API都必须处理『背压』，Flow也有相应的API来处理：</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html">buffer</a> 把生产者的emit的数据缓存，然后用Channel以并发的方式流向中游和下游，可以简单理解为并发地调用collect。正常情况下Flow是顺序的（Sequentially），就是数据从上游到中游再到终端，按顺序流动，先生产的数据先流到collect，这就是顺序的数据流sequentially。用上buffer后，就是会是并发的流，先emit的数据不一定先到collect，这就是concurrently。明显，能用buffer的前提是终端处理数据时没有对数据顺序的依赖。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html">conflate</a> 也会像buffer一样启动并发式emit数据，但未能及时被终端消费掉的数据会被丢弃，终端只处理最新数据。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect-latest.html">collectLatest</a> 当有新的数据流出来时，终端只处理最新的数据，此之的终端处理会被取消掉（如果还没有处理完）。</li>
</ul>


<h2>转为热流</h2>

<p>常规的Flow都是冷的(cold flow)，但有时热流(hot flow)也有它的应用场景，Flow API中也有创建热流的方法。
<img src="https://koenig-media.raywenderlich.com/uploads/2021/05/StateFlowAndSharedFlow-twitter.png" alt="" /></p>

<h3>StateFlow</h3>

<p><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/">StateFlow</a>是一个『状态持有』流，它仅包含一个当前元素<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/value.html">value</a>，可以用过<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/update.html">update</a>来更新此状态。它是一个热流，可以有多个终端colloctor，每次更新都会把当前的值emit给所有的终端。</p>

<p>可以用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-state-flow.html">构造方法MutableStateFlow</a>创建一个StateFlow，或者通过函数<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/state-in.html">stateIn</a>来把一个冷流转化为一个StateFlow。</p>

<p>StateFlow是比较常用的，在安卓开发中，几乎所有的ViewModel都会用StateFlow来暂存UI状态数据。</p>

<h3>SharedFlow</h3>

<p>比StateFlow更为通用的便是通用的热流<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-shared-flow/">SharedFlow</a>。可以通过构造方法<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-shared-flow.html">MutableSharedFlow</a>来创建SharedFlow，或者通过函数<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/share-in.html">sharedIn</a>把一个冷流转为SharedFlow。</p>

<p>SharedFlow可以有多个终端collector，所以可以实现一对多的通知，如实现<a href="https://en.wikipedia.org/wiki/Observer_pattern">观察者模式</a>，或者像设置/配置更新，或者广播等等就可以考虑用SharedFlow来实现。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://developer.android.com/kotlin/flow/stateflow-and-sharedflow">StateFlow and SharedFlow</a></li>
<li><a href="https://juejin.cn/post/7314159614065131554">SharedFlow vs StateFlow，一篇看懂选择和使用技巧</a></li>
<li><a href="https://juejin.cn/post/7195569817940164668">Kotlin SharedFlow&amp;StateFlow 热流到底有多热？</a></li>
<li><a href="https://juejin.cn/post/7271832299339169844">ShareFlow与StateFlow实战</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[包教包会的Kotlin Flow教程]]></title>
    <link href="http://toughcoder.net/blog/2024/01/25/kotlin-flow-made-easy/"/>
    <updated>2024-01-25T23:17:51+08:00</updated>
    <id>http://toughcoder.net/blog/2024/01/25/kotlin-flow-made-easy</id>
    <content type="html"><![CDATA[<p>Kotlin中的<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/">Flow</a>是专门用于处理异步数据流的API，是<a href="https://en.wikipedia.org/wiki/Functional_reactive_programming">函数响应式编程范式(Functional Reactive Programming FRP)</a>在Kotlin上的一个实现，并且深度融合了Kotlin的协程。是Kotlin中处理异步数据流问题的首先方案。今天就来认识一下Flow并学会如何使用它。</p>

<p><a href=""><img src="https://blog.mindorks.com/images/kotlin-flow-banner-image.png" title="auto auto" ></a></p>

<!-- more -->


<h2>Hello, Flow!</h2>

<p>老规矩，新学习一个新东西的时候，总是要从一个基础的『Hello, world』开始，快速上手体验，有个第一印象。我们就从一个简单的『Hello, Flow!』开始Flow之旅：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    val simple = flow {
        listOf("Hello", "world", "of", "flows!")
            .forEach {
                delay(100)
                emit(it)
            }
    }

    simple.collect {
        println(it)
    }
}
//Hello
//world
//of
//flows!
</code></pre>

<p>这里创建了一个异步产生String的数据流Flow&lt;String&gt;，会不定时的产生一个String，然后收集此数据流产生的数据，把流出的String对象消费掉。</p>

<p>可以看出Flow本质上是一个<strong>生产者消费者模式</strong>，流出的数据是由生产者产生的，且最终被消费者消费掉。可以把Flow想像成为一个<strong>生产线中的传送带</strong>，产品（数据）在上面不停的流动，经过各个站点的加工，最终成型，由消费者消费掉。从这个小例子中可以看出Flow API的三要素：数据流的<strong>上游</strong>是创建Flow（生产者）；<strong>中游</strong>是变幻操作（数据的处理和加工）；<strong>下游</strong>是收集数据（消费者），我们一一的详细来学习。</p>

<h2>创建Flow</h2>

<p>Flow是一个生产者，创建Flow也就是把数据放到传送带上。数据可以是基础数据或者集合，也可以是其他方式生成的数据，如网络或者回调或者硬件。创建Flow的API称作flow builder函数。</p>

<h3>用集合创建Flow</h3>

<p>这是创建Flow的最简单的方式，有两个，一个是<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-of.html">flowOf</a>用于从固定数量的元素创建，多用于示例，实际中基本上用不到：</p>

<pre><code class="Kotlin">val simple = flowOf("Hello", "world", "of", "flows!")
simple.collect { println(it) }
</code></pre>

<p>或者，通过<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/as-flow.html">asFlow</a>把现有的集合转为Flow，这个还是比较实用的：</p>

<pre><code class="Kotlin">listOf("Hello", "world", "of", "flows!").asFlow()
    .collect { println(it) }
(1..5).asFlow().collect { println(it) }
</code></pre>

<h3>通用flow builder</h3>

<p>最为通用的flow builder就是<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow.html">flow {&hellip;}</a>了，这是最为通用，也是最为常用的构造器。在代码块中调用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html">emit</a>就可以了，这个代码块会运行在协程之中，所以在这个代码里可以调用suspend函数：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    val simple = flow {
        for (i in 1..3) {
            delay(100)
            println("Emitting: $i")
            emit(i)
        }
    }
    simple.collect { println(it) }
}
//Emitting: 1
//1
//Emitting: 2
//2
//Emitting: 3
//3
</code></pre>

<p>这是一个代码块，只要调用了emit产生数据即可，又可调用suspend函数，因此非常的实用，比如可以执行网络请求，请求回来后emit等等。</p>

<h2>终端操作符</h2>

<p>数据从生产者流出，直到消费者把数据收集起来进行消费，而只有数据被消费了才有意义。因此，还需要终端操作（Terminal flow operators）。需要注意的是终端操作符是Flow的终点，并不算是Flow传送带内部，因此终端操作都是suspend函数，调用者需要负责创建协程以正常调用这些suspending terminal operators。</p>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.WAtR3lx1-6aO3Cnsl3s3YgHaB7?rs=1&amp;pid=ImgDetMain" alt="" /></p>

<p>常见的终端操作有三个：</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html">collect</a> 最为通用的，可执行一个代码块，参数就是Flow流出的数据</li>
<li>转换为<a href="https://kotlinlang.org/docs/collections-overview.html">集合Collections</a>，如<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/to-list.html">toList</a>和<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/to-set.html">toSet</a>等，可以方便把收集到的数据转换为集合</li>
<li>取特定的值，如<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/first.html">first()</a>只取第一个，<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/last.html">last</a>只取最后一个, <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/single.html">single</a>只要一个数据（无数据和超过一个数据时都会抛异常。</li>
<li>降维（或者叫作聚合accumulate）操作，如折叠<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/fold.html">fold</a>和化约<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/reduce.html">reduce</a>，折叠和化约可以对数据流进行降维，如求和，求积，求最大值最小值等等。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/count.html">count</a> 其实也是降维的一种，返回数据流中的数据个数，它还可以结合过滤以计算某种过滤条件后的数据数量。</li>
</ul>


<pre><code class="Kotlin">fun main() = runBlocking {
    val simple = flow {
        for (i in 1..3) {
            delay(100)
            println("Emitting: $i")
            emit(i)
        }
    }
    simple.collect { println(it) }
    println("toList: ${simple.toList()}")
    println("first: ${simple.first()}")
    println("sum by fold: ${simple.fold(0) { s, a -&gt; s + a }}")
}
</code></pre>

<p>输出：</p>

<pre><code class="Bash">Emitting: 1
1
Emitting: 2
2
Emitting: 3
3
Emitting: 1
Emitting: 2
Emitting: 3
toList: [1, 2, 3]
Emitting: 1
first: 1
Emitting: 1
Emitting: 2
Emitting: 3
sum by fold: 6
</code></pre>

<p>这些终端操作符都简单，比较好理解，看一眼示例就知道怎么用了。需要注意的就是first()和single()，first是只接收数据流中的第一个，而single则要求数据流只能有一个数据（没有或者超过一个都会抛异常）。比较有意思就是last()，数据流是一个流，一个产品传送带，通常情况下都是指无限或者说不确定数据 数量时才叫数据流，那又何来最后一个数据呢？通常情况下last都是无意义的。只有当我们知道流的生产者只生产有限数量数据时，或者采用了一些限制性的变幻操作符时，last才能派上用场。</p>

<p>再有就是注意fold和reduce的区别，这里它们的区别跟集合上的操作是一样的，fold可以提供初始值，流为空时返回初始值；而reduce没初始值，流为空时会抛异常。</p>

<h2>变幻操作符</h2>

<p>数据在流动的过程中可以对数据进行转化操作，从一种数据类型变别另外一种，这就是变幻(Transformation)，这是数据流最为灵活和强大的一个方面。这跟<a href="https://kotlinlang.org/docs/collection-transformations.html">集合的变幻</a>是类似的。</p>

<p><img src="https://cdn-media-1.freecodecamp.org/images/1*ju5YD8bRZhdCGmptRQdmlw.png" alt="" /></p>

<h3>转换</h3>

<p>最常见的变幻就是转换，也就是把从一种数据类型转换为另一种数据类型，用的最多当然是<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html">map</a>，还有更为通用的<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/transform.html">transform</a>。它们都能把数据流中的数据从一种类型转换为另一种类型，比如把Flow<String>转为Flow<Int>。区别在于，map是死板的转换，一个对象进去，另一个对象作为返回值出来；但transform更为灵活，它并不是把新类型作为返回值，它可以像上游生产者那样产生(emit)新数据，甚至可以产生(emit)多个新数据，它是非常强大的，所有其他的变幻操作符，都是基于transform实现的。</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    val simple = flow {
        for (i in 1..3) {
            delay(100)
            println("Emitting: $i")
            emit(i)
        }
    }

    simple.map { " Mapping to ${it * it}" }
        .collect { println(it) }

    simple.transform { req -&gt;
        emit(" Making request $req")
        emit(performRequest(req))
    }.collect {
        println(it)
    }
}

fun performRequest(req: Int) = "Response for $req"
</code></pre>

<p>输出是:</p>

<pre><code class="Bash">Emitting: 1
 Mapping to 1
Emitting: 2
 Mapping to 4
Emitting: 3
 Mapping to 9
Emitting: 1
 Making request 1
Response for 1
Emitting: 2
 Making request 2
Response for 2
Emitting: 3
 Making request 3
Response for 3
</code></pre>

<p>还有一个操作符<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/with-index.html">withIndex</a>它与集合中的<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/map-indexed.html">mapIndexed</a>是类似的，它的作用是把元素变成IndexedValue，这样在后面就可以得到元素和元素的索引 了，在某些场景下还是比较方便的。</p>

<h3>限制</h3>

<p>数据流里面的数据不一定都是需要的，所以通常需要对数据元素进行过滤，这就是限制性操作符，最常见的就是<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/filter.html">filter</a>，这里与集合的限制操作也是类似的：</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/filter.html">filter</a> 把数据转为布尔型，从而对数据流进行过滤。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/distinct-until-changed.html">distinctUntilChanged</a> 过滤数据流中重复的元素。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/drop.html">drop</a> 丢弃前面一定数量的元素。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/take.html">take</a> 只返回流中前面一定数量的元素，当数量达到时流将被取消，注意take与drop是相反的。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/debounce.html">debounce</a> 仅保留流中一定超时间隔内的元素，比如超时时间是1秒，那只返回到达1秒时最新的元素，这个元素前面的将被丢弃。这个在秒杀场景拦截疯狂点击，或者一个服务中拦截疯狂请求时非常有用。只取一定时间间隔内的最新的元素，拦截掉无效数据。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/sample.html">sample</a> 以一定的时间间隔取元素，与debounce差不多，区别在于debounce会返回最后一个元素，而sample不一定，要看间隔最后一个元素能否落在一个时间间隔内。</li>
</ul>


<pre><code class="Kotlin">@OptIn(FlowPreview::class)
fun main() = runBlocking {
    val constraint = flow {
        emit(1)
        delay(90)
        emit(2)
        delay(90)
        emit(3)
        delay(1010)
        emit(4)
        delay(1010)
        emit(5)
    }

    constraint.filter { it % 2 == 0 }
        .collect { println("filter: $it") }
    constraint.drop(3)
        .collect { println("drop(3): $it") }
    constraint.take(3)
        .collect { println("take(3): $it") }

    constraint.debounce(1000)
        .collect { println("debounce(1000): $it") }
    constraint.sample(1000)
        .collect { println("sample(1000): $it") }
}
</code></pre>

<p>仔细看它们的输出，以理解它们的作用：</p>

<pre><code class="Bash">filter: 2
filter: 4
drop(3): 4
drop(3): 5
take(3): 1
take(3): 2
take(3): 3
debounce(1000): 3
debounce(1000): 4
debounce(1000): 5
sample(1000): 3
sample(1000): 4
</code></pre>

<p>需要留意，debounce和sample是Preview的API，需要<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-flow-preview/">加上Preview注解</a>。</p>

<p>中游的变幻操作符仍属于流的一部分，它们都仍运行在Flow的上下文中，因此，这些操作符内，与流的builder一样，都可以直接调用其他的supsend函数，甚至是其他的耗时的，阻塞的函数都可以调用。并不需要特别的为上游和中游创建上下文。</p>

<p>Flow的操作符特别多，我们需要留意区别中游操作符和下游终端。看这些函数的返回类型就可以了，返回类型是具体数据的，一定是下游终端操作符；而对于上游生产者和中游变幻操作符，其返回值一定是一个Flow。</p>

<h2>高级操作符</h2>

<p>前面讲的操作符都是针对 某一个流本身的，但大多数场景一个流明显不够用啊，我们需要操作多个流，这时就需要用到一些高级操作符了。</p>

<h3>合并多路流</h3>

<p>多路流不可能一个一个的处理，合并成为一路流更加的方便，有以下合并方法：</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/merge.html">归并merge</a>把<strong>数据类型相同的多路流归并为一路</strong>，注意一定是数据类型相同的才可以归并，并且归并后的元素顺序是未知的，也即不会保留原各路流的元素顺序。归并流的数量没有限制。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/zip.html">粘合zip</a> 当想要<strong>把两路流的元素对齐后粘合为一个元素</strong>时，就可以使用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/zip.html">zip</a>，当任何一个流结束或者被取消时，zip也就结束了。只能两个两个的粘合。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/combine.html">组合combine</a>把多路流中的每个流的最新元素粘合成新数据，形成一个新的流，其元素是把<strong>每个元素</strong>都用<strong>每路流的最新元素</strong>来转换生成。最少需要2路流，最多支持5路流。</li>
</ul>


<p>用一个&#127792;来感受一下它们的作用：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    val one = flowOf(1, 2, 3)
                .map(Int::toString)
                .onEach { delay(10) }
    val two = flowOf("a", "b", "c", "d")
                .onEach { delay(25) }
    merge(one, two)
        .collect { println("Merge: $it") }
    one.zip(two) { i, s -&gt; "Zip: $i. $s" }
        .collect { println(it) }
    combine(one, two) { i, s -&gt; "Combine $i with $s" }
        .collect { println(it) }
}
</code></pre>

<p>这里是输出：</p>

<pre><code class="Bash">Merge: 1
Merge: 2
Merge: a
Merge: 3
Merge: b
Merge: c
Merge: d
Zip: 1. a
Zip: 2. b
Zip: 3. c
Combine 2 with a
Combine 3 with a
Combine 3 with b
Combine 3 with c
Combine 3 with d
</code></pre>

<p>通过它们的输出可以看到它们的区别：merge就像把两个水管接到一样，简单没有多余加工，适合数据类型一样的流（比如都是水）；zip会对齐两路流，让能对齐的元素两两结合，对不齐时就结束了。</p>

<p>而combine要等到<strong>集齐每路流的最新元素，才能转换成新数据</strong>，two是较one慢的，看到two的元素『a』时，one最新的元素是『2』，之后one的『3』来了，这时two最新的元素还是『a』，之后one停在了『3』，后续two的元素都与『3』组合。有同学可能会有疑问，为啥one的『1』丢弃了，没找到组合呢？因为它来的太早了，one的『1』来了时，two还没有元素，它肯定会等，但当two的第一个元素『a』来了时，这时one的最新元素已是『2』了，one是10发一个元素，two是隔25发一个元素，所以two的第1个元素到了时，one的第2个元素已经来了，它是最新的，所以组合时会用它。combine要集齐每路流的最新元素才能合成。</p>

<p>总结起来就是，<strong>zip会按顺序对齐元素</strong>；而combine要<strong>集齐每路流的最新元素</strong>，先要<strong>集齐</strong>，齐了时还要<strong>取每个流的最新元素</strong>。可以动手运行示例，修改delay的时间，看输出有啥不一样的，以加深理解。</p>

<h3>展平(Flatten)</h3>

<p>一个Flow就是一个异步数据流，它相当于一个传送带或者管道，货物（具体的数据）在其上面或者里面流动。正常情况下Flow内部都是常规数据（对象）在流动，但Flow本身也是一个对象，因此也可以嵌套，把流当成另一个流的数据，比如Flow&lt;Flow&lt;Int&gt;&gt;，这就是Flow of Flows of Int。Flow是数据流，最终消费者需要的是具体的数据，所以对于嵌套的Flow of Flows，通常都需要在传给终端操作符之前进行展平(flatten)，得到一个faltterned Flow（即从Flow&lt;Flow&lt;Int&gt;&gt;转成Flow&lt;Int&gt;），就可以被终端消费了。操作符中以flat开头的函数都是用于展平的，主要是两类，一类是<strong>展平flatten系</strong>，一类是<strong>先变幻再展平flatMap系</strong>。</p>

<h4>直接展平</h4>

<p>最直观的展平莫过于对于已经是嵌套的Flow of Flows做展平处理，以能让终端操作符正常的消费Flow里面的数据，有两个API可以做展平：</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flatten-concat.html">flattenConcat</a> 把嵌套的Flow of Flows展平为一个Flow，内层的每个流都是按顺序拼接在一起的，串行拼接。比如Flow of 4 Flows，内层有四个管道，那就就变成了『内层1』->『内层2』->『内层3』->『内层4』。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flatten-merge.html">flattenMerge</a> 把Flow of Flows展平为一个Flow，内层的所有Flow是以并发的方式将元素混合流入新管道，是并发式混合，相当于四个管道同时往另一个管道倒水，原流中的顺序会错乱掉。</li>
</ul>


<pre><code class="Kotlin">@OptIn(ExperimentalCoroutinesApi::class)
fun main() = runBlocking {
    val flow2D = flowOf("Hello", "world", "of", "flow!")
        .map { it.toCharArray().map { c -&gt; " '$c' " }.asFlow() }
        .flowOn(Dispatchers.Default)

    flow2D.collect { println("Flow object before flatten: $it") } // Data in flow are Flow objects

    println("With flattenConcat:")
    flow2D.flattenConcat()
        .collect { print(it) }

    println("\nWith flattenMerge:")
    flow2D.flattenMerge()
        .collect { print(it) }
}
//Flow object before flatten: kotlinx.coroutines.flow.FlowKt__BuildersKt$asFlow$$inlined$unsafeFlow$3@1b0375b3
//Flow object before flatten: kotlinx.coroutines.flow.FlowKt__BuildersKt$asFlow$$inlined$unsafeFlow$3@e580929
//Flow object before flatten: kotlinx.coroutines.flow.FlowKt__BuildersKt$asFlow$$inlined$unsafeFlow$3@1cd072a9
//Flow object before flatten: kotlinx.coroutines.flow.FlowKt__BuildersKt$asFlow$$inlined$unsafeFlow$3@7c75222b
//With flattenConcat:
 //'H'  'e'  'l'  'l'  'o'  'w'  'o'  'r'  'l'  'd'  'o'  'f'  'f'  'l'  'o'  'w'  '!' 
//With flattenMerge:
// 'H'  'e'  'l'  'l'  'o'  'w'  'o'  'r'  'l'  'd'  'o'  'f'  'f'  'l'  'o'  'w'  '!'
</code></pre>

<p>从输出中可以看出，如果不展平Flow里面是Flow对象，没法用。flattenConcat是把内层的流串行的接在一起。但flattenMerge的输出似乎与文档描述不太一致，并没有并发式的混合。</p>

<h4>先转换再展平</h4>

<p><img src="https://velog.velcdn.com/images/morning-la/post/59271fa7-8768-43f7-bebf-1387e77d8013/image.png" alt="" /></p>

<p>大多数时候并没有现成的嵌套好的Flow of Flows给你展平，更多的时候是我们需要自己把元素转换为一个Flow，先生成Flow of Flows，然后再展平，且有定义好的API可以直接用：</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-concat.html">flatMapConcat</a> 先把Flow中的数据做变幻，这个变幻必须从元素变成另一个Flow，这时就变成了嵌套式的Flow of Flows，然后再串行式展平为一个Flow。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html">flatMapLatest</a> 先把Flow中的最新数据做变幻，这个变幻必须从元素变成另一个Flow，这时会取消掉之前转换生成的内层流，结果虽然也是嵌套，但内层流只有一个，就是原Flow中最新元素转换生成的那个流。然后再展平，这个其实也不需要真展平，因为内层流只有一个，它里面的数据就是最终展平后的数据。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-merge.html">flatMapMerge</a> 与flatMapConcat一样，只不过展平的时候嵌套的内层流是以并发的形式来拼接的。</li>
</ul>


<p>来看个&#127792;就能明白它们的作用了：</p>

<pre><code class="Kotlin">@OptIn(ExperimentalCoroutinesApi::class)
fun main() = runBlocking {
    val source = (1..3).asFlow()
        .onEach { delay(100) }

    println("With flatMapConcat:")
    var start = System.currentTimeMillis()
    source.flatMapConcat(::requestFlow)
        .collect { println("$it at ${System.currentTimeMillis() - start}ms from the start") }

    println("With flatMapMerge:")
    start = System.currentTimeMillis()
    source.flatMapMerge(4, ::requestFlow)
        .collect { println("$it at ${System.currentTimeMillis() - start}ms from the start") }

    println("With flatMapLatest:")
    source.flatMapLatest(::requestFlow)
        .collect { println("$it at ${System.currentTimeMillis() - start}ms from the start") }
}

fun requestFlow(x: Int): Flow&lt;String&gt; = flow {
    emit(" &gt;&gt;[$x]: First: $x")
    delay(150)
    emit(" &gt;&gt;[$x]: Second: ${x * x}")
    delay(200)
    emit(" &gt;&gt;[$x]: Third: ${x * x * x}")
}
</code></pre>

<p>输出比较多：</p>

<pre><code class="Bash">With flatMapConcat:
 &gt;&gt;[1]: First: 1 at 140ms from the start
 &gt;&gt;[1]: Second: 1 at 306ms from the start
 &gt;&gt;[1]: Third: 1 at 508ms from the start
 &gt;&gt;[2]: First: 2 at 613ms from the start
 &gt;&gt;[2]: Second: 4 at 765ms from the start
 &gt;&gt;[2]: Third: 8 at 969ms from the start
 &gt;&gt;[3]: First: 3 at 1074ms from the start
 &gt;&gt;[3]: Second: 9 at 1230ms from the start
 &gt;&gt;[3]: Third: 27 at 1432ms from the start
With flatMapMerge:
 &gt;&gt;[1]: First: 1 at 130ms from the start
 &gt;&gt;[2]: First: 2 at 235ms from the start
 &gt;&gt;[1]: Second: 1 at 284ms from the start
 &gt;&gt;[3]: First: 3 at 341ms from the start
 &gt;&gt;[2]: Second: 4 at 386ms from the start
 &gt;&gt;[1]: Third: 1 at 486ms from the start
 &gt;&gt;[3]: Second: 9 at 492ms from the start
 &gt;&gt;[2]: Third: 8 at 591ms from the start
 &gt;&gt;[3]: Third: 27 at 695ms from the start
With flatMapLatest:
 &gt;&gt;[1]: First: 1 at 807ms from the start
 &gt;&gt;[2]: First: 2 at 915ms from the start
 &gt;&gt;[3]: First: 3 at 1021ms from the start
 &gt;&gt;[3]: Second: 9 at 1173ms from the start
 &gt;&gt;[3]: Third: 27 at 1378ms from the start
</code></pre>

<p><img src="https://velog.velcdn.com/images/morning-la/post/5d218551-4021-4a91-8b85-bf69beb786d6/image.png" alt="" /></p>

<p>这个示例中原始Flow是一个Int值，把它转换成为一个字符串流Flow&lt;String&gt;。从输出中可以看到flatMapConcat确实是串行拼接，并且flatMapMerge是并发式的混合，不保证内部Flow的元素顺序。仔细看flatMapLatest的输出，每当原始Flow中有新的值生成时，之前转换生成的流会被取消，它们并没有运行完（仅第一个元素流出了）。而原始流的最后一个元素『3』则完整的从展平流中流出了。</p>

<p>展平的函数比较多容易学杂，其实有一个非常简单的区分方法：带有<strong>Map字样</strong>的函数就是先把元素<strong>转换成Flow</strong>之后再展平；带有<strong>Concat</strong>就是把嵌套内层流<strong>串行拼接</strong>；而带有<strong>Merge</strong>的则是把内层流<strong>并发式的混合</strong>。使用的时候，如果<strong>想保证顺序就用带有Concat的函数；想要并发性，想高效一些，并且不在乎元素顺序，那就用带有Merge的函数。</strong></p>

<h2>Flow是冷流</h2>

<p>对于数据流来说有<strong>冷热</strong>之分，冷流(Cold stream)是指消费者开始接收数据时，才开始生产数据，换句话说就是生产者消费者整个链路搭建好了后，上游才开始生产数据；热流(Hot stream)，与之相反，不管有没有人在消费，都在生产数据。有一个非常形象的比喻就是，冷流就好比CD，你啥时候都可以听，而且只要你播放就从头开始播放CD上所有的音乐；而热流就好比电台广播，不管你听不听，它总是按它的节奏在广播，今天不听，就错过今天的数据了，今天听跟明天听，听到的内容也是不一样的。</p>

<p>Kotlin的<strong>Flow是冷流</strong>，其实从上面的例子也能看出来，每个例子中都是只创建一个Flow对象，然后有多次collect，但<strong>每次collect都能拿到Flow中完整的数据</strong>，这就是<strong>典型的冷流</strong>。绝大多数场景，我们需要的也都是冷流。</p>

<p>扩展阅读<a href="https://kt.academy/article/cc-hot-cold">Hot and cold data sources</a>。</p>

<h2>与ReactiveX的区别</h2>

<p>Flow是用于处理异步数据流的API，是函数响应式编程范式FRP的一个实现。但它并不是唯一的，更为<a href="https://github.com/ReactiveX/RxJava">流行的RxJava</a>也是符合FRP的异步数据流处理API，它出现的要更早，社区更活跃，资源更丰富，流行程度更高，基本上是每个安卓项目必备的依赖库，同时也是面试必考题。</p>

<p>因为Kotlin是基于JVM的衍生语言，它与Java是互通的，可以混着用。所以RxJava可以直接在Kotlin中使用，无需要任何改动。但毕竟RxJava是原生的Java库，Kotlin中的大量语法糖还是很香的，由此便有了<a href="https://github.com/ReactiveX/RxKotlin">RxKotlin</a>。RxKotlin并不是把<a href="https://reactivex.io/">ReactiveX规范</a>重新实现一遍，它只是一个轻量的粘合库，通过扩展函数和Kotlin的语法糖等，让RxJava更加的Kotlin友好，在Kotlin中使用RxJava时更加的顺滑。但核心仍是RxJava，如并发的实现仍是用线程。</p>

<p>那么Flow相较RxJava有啥区别呢？区别就在于Flow是纯的Kotlin的东西，它们背后的思想是一样的都是异步数据流，都是FRP，但Flow是原生的，它与Kotlin的特性紧密结合，比如它的并发是用协程通信用的是Channel。使用建议就是，如果本身对RxJava很熟悉，且是遗留代码，那就没有必要去再改成Flow；但如果是新开发的纯新功能，并且不与遗留代码交互，也没有与架构冲突，还是建议直接上Flow。</p>

<h2>什么时候用Flow</h2>

<p>每一个工具都有它特定的应用场景，Flow虽好，但不可滥用，要以架构的角度来认清问题的本质，符合才可以用。Flow是用于处理异步数据流的API，是FRP范式下的利器。因此，只当核心业务逻辑是由异步数据流驱动的场景时，用Flow才是合适的。现在绝大多数端（前端，客户端和桌面）GUI应用都是响应式的，用户输入了，或者服务器Push了数据，应用做出响应，所以都是符合FRP范式的。那么重点就在于数据流了，如果数据连串成流，就可以用Flow。比如用户输出，点击事件/文字输入等，这并不只发生一次，所以是数据流（事件流）。核心的业务数据，比如新闻列表，商品列表，文章列表，评论列表等都是流，都可以用Flow。配置，设置和数据库的变化也都是流。</p>

<p>但，一个单篇的文章展示，一个商品展示这就不是流，只有一个文章，即使用流，它也只有一个数据，而且我们知道它只有一个数据。这种情况就没有必要用Flow，直接用一个supsend请求就好了。</p>

<h2>在Android中使用Flow</h2>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2020/05/KotlinFlow-twitter.png" alt="" /></p>

<p>安卓开发的官方语言已经变成了Kotlin了，安卓应用也非常符合FRP范式，那么对于涉及异步数据流的场景自然要使用Flow。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://blog.mindorks.com/what-is-flow-in-kotlin-and-how-to-use-it-in-android-project/">What is Flow in Kotlin and how to use it in Android Project?</a></li>
<li><a href="https://developer.android.com/kotlin/flow">Kotlin flows on Android</a></li>
<li><a href="https://github.com/amitshekhariitbhu/Learn-Kotlin-Flow">Learn Kotlin Flow by real examples for Android</a></li>
</ul>


<h2>书籍推荐</h2>

<p>Flow本身的东西其实并不多，就是三板斧：创建，变幻和终端。但Flow背后的思想是很庞大的，想要用好Flow必须要学会函数响应式编程范式。也就是说只有学会以FRP范式来构建软件时，才能真正用好Flow。</p>

<p><a href="https://www.manning.com/books/functional-reactive-programming">《Functional Reactive Programming》</a></p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/flow.html">Asynchronous Flow</a></li>
<li><a href="https://amitshekhar.me/blog/flow-api-in-kotlin">Mastering Flow API in Kotlin</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin进阶之协程从上车到起飞]]></title>
    <link href="http://toughcoder.net/blog/2024/01/14/kotlin-coroutines-an-advanced-guide/"/>
    <updated>2024-01-14T21:17:20+08:00</updated>
    <id>http://toughcoder.net/blog/2024/01/14/kotlin-coroutines-an-advanced-guide</id>
    <content type="html"><![CDATA[<p>通过<a href="http://toughcoder.net/blog/2024/01/11/kotlin-coroutine-made-easy/">前面的一篇文章</a>我们理解了协程的基本概念，学会协程的基本使用方法，算是正式入门了，接下来就是要深入的学习技术细节和高级使用方法，以期完全掌握Kotlin协程并能熟练的正确的使用协程，发挥出协程应有的并发编程能力。</p>

<p><a href=""><img src="https://repository-images.githubusercontent.com/61722736/08e87280-62dc-11ea-8fed-a8a4a4ea865d" title="auto auto" ></a></p>

<!-- more -->


<p>本篇为协程三步曲中的第二篇：</p>

<ul>
<li>初级篇：<a href="http://toughcoder.net/blog/2024/01/11/kotlin-coroutine-made-easy/">Kotlin进阶之协程从入门到放弃</a></li>
<li>高级篇：<a href="http://toughcoder.net/blog/2024/01/14/kotlin-coroutines-an-advanced-guide/">Kotlin进阶之协程从上车到起飞</a></li>
<li>终极篇：<a href="http://toughcoder.net/blog/2023/01/27/understanding-coroutines/">Kotlin进阶之协程从专家到出家</a></li>
</ul>


<p>本篇将细致的讨论协程中的一些重要的话题，以期更好的理解协程的原理和正确的使用协程，将从协程运行的上下文开始。</p>

<h2>深究协程上下文</h2>

<p><img src="https://files.betamax.kodeco.com/attachments/videos/3493/c049283d-193b-43b9-b796-0aafe8e9c804.png" alt="" /></p>

<p>创建协程的方法launch/async一共<strong>有3个参数</strong>，除了最后一个是协程的代码块以外，另外两个参数都是用来<strong>控制协程</strong>的，如协程上下文是用以控制协程运行环境的，包括在什么线程中去运行，句柄和树形关系以及何时切换线程，通过传递给launch/async的参数CoroutineContext。以及CoroutineStart就可以控制协程的运行。</p>

<pre><code class="Kotlin">fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -&gt; Unit
): Job

fun &lt;T&gt; CoroutineScope.async(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -&gt; T
): Deferred&lt;T&gt;
</code></pre>

<p>首先我们来看一下协程上下文对象CoroutineContext。</p>

<h3>CoroutineContext</h3>

<p><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/">CoroutineContext</a>是一个集合，具体元素类型是<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/-element/">Element</a>，Element重载了操作符，可以通过<strong>&#43;</strong>来形成集合。CoroutineContext是类似于Map的，每个Element有自己的Key，这是为了保证每个CoroutineContext对象中每个Key只能有一个Element对象。可以把CoroutineContext看成是Map，因此可以使用<strong>[]</strong>来获取Key对应的Element，如取Job，可以用context[Job]，取名字时可以用context[CoroutineName]等。</p>

<p>具体Element有四种：</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/">Job</a>：协程的句柄，或者说唯一标识，用以具体控制每个协程的（cancel和join等），具有树形关系</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/">CoroutineDispatcher</a>：用以指定协程的运行线程</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-name/">CoroutineName</a>：给协程取个名字，方便调试</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/">CoroutineExceptionHandler</a>：指定协程的异常处理器，用以处理未被捕获的异常</li>
</ul>


<p>这里主要介绍一下Job，CoroutineDispatcher和Name，至于ExceptionHandler留到后面讲异常处理时再细讲。</p>

<h4><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/">Job</a></h4>

<p>用launch创建一个协程时也会返回一个Job对象，它就是新创建的协程的句柄，但更好的方式是通过launch的参数，在上下文中指定一个Job对象作为协程的句柄。前面了讲过了，Job用以控制协程的，更为重要的是它能维持树形关系，父协程是可以控制子协程的，像cancel是会传导到所有的子协程的。自己创建Job对象就可以自由指定父协程，而不是默认的从CoroutineScope中继承。</p>

<p>另外，Job也会影响Exception handling，会在后面异常处理部分详细的讲。</p>

<h4><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/">CoroutineDispatcher</a></h4>

<p>这个是在平时用的最多的，因为协程是一种并发编程范式，而要想真并发，必然要涉及线程的切换，不可能指望着主线程把所有的事情都干了，而Dispatcher的作用就是用于主动的指定协程的运行线程。与Java中的Executor，和RxJava中的Schedulers作用是一样的。有一些预定义好的Dispatcher可以用，它们定义在<a href="">Dispatchers</a>里面：</p>

<ul>
<li><a href="">Main</a> 主线程，主函数所在的主线程，以及像UI框架（如Swing和Android）等的UI线程（主线程）</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/">IO</a> 适合I/O密集型的协程，如网络操作（上传/下载），文件读写，数据库读写等等。它背后是线程池，线程的数量是比较多的。因为<strong>I/O虽然耗时，但一般都耗在等待</strong>上面，所以线程的数量可以多一些。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html">Default</a> 适合CPU密集型的协程，比如计算类型的，图形的计算，矩阵计算，多媒体文件的编解码，压缩解压缩，或者算法时间复杂度较高的任务等等。也是线程池，线程的数量一般是CPU的核数。这个线程池的数量很少，因为<strong>这是CPU密集型的任务，需要大量占用着CPU，使CPU一直处于忙碌状态，因此线程数量即使多了，也是没有用处的，因为多创建的线程根本得不到操作系统的调试，没有多余的CPU给线程跑。</strong></li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html">Unconfied</a> 未给协程指定线程，协程会在当前的线程中执行（也就是调用者的线程），直到协程被挂起(suspended)。挂起后再继续(resume)时，由在恢复的线程中继续执行。很混乱吧，是的并发虽然讲究效率，虽然线程/协程啥时候进行，挂起并不能直接完全控制，但是我们仍希望并发要有秩序和确定性。一定要为新创建的协程指定其线程运行环境，因此，<strong>Unconfined不应该被使用</strong>。</li>
</ul>


<p>一般情况下，框架预定义好了的这些dispatcher已经够用了。但如果真的不够用，也可以自定义dispatcher，用扩展函数<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/as-coroutine-dispatcher.html">asCoroutineDispatcher</a>可以非常方便的把Java中的线程池Executors转化为dispatcher：</p>

<pre><code class="Kotlin">val dispatcher = Executors.newSingleThreadExecutor().asCoroutineDispatcher
launch(dispatcher) {
    delay(1000)
    println("Single thread dispatcher")
}
</code></pre>

<h4>CoroutineName</h4>

<p><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-name/">CoroutineName</a>是比较简单的结构，的构造方法可以传一个字符串用以指定协程的名字。协程的名字只有调试的意义，对于代码的运行没有任何影响。比如在调试的时候，或者在性能分析Profiling的时候，可以用名字更加方便的区分不同的协程，进而缩小调试的范围。</p>

<h3>CoroutineStart</h3>

<p><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/">CoroutineStart</a>，是一个枚举类型，用以控制协程的启动方式，具体有四种模式类型：</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-d-e-f-a-u-l-t/">DEFAULT</a> 默认，如果未指定这个参数 时也是默认模式，根据指定的上下文环境，立即调度此协程</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-l-a-z-y/">LAZY</a> 只有当需要此协程时才调度它。比较有意思，具体啥是<strong>需要</strong>呢，也就是当await其结果时，或者需要此协程去<strong>生产事件(produce)</strong>或者<strong>消费事件(consume)</strong>时。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-a-t-o-m-i-c/">ATOMIC</a> 以原子化的方式来调度此协程，也就是以不可取消的方式来调度协程。也就是说在协程代码块执行之前是不可取消的。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-start/-u-n-d-i-s-p-a-t-c-h-e-d/">UNDISPATCHED</a> 在当前的线程环境（也就是调用者的线程）中立即执行协程直到协程的第一个挂起点。挂起之后，继续时则在指定的上下文中的线程运行。</li>
</ul>


<p>一般情况下，我们用默认的就行了。但当熟悉了协程以后，在适当的场景使用不同的启动方式参数可以更大限度的发挥协程的威力。</p>

<p>延展阅读：</p>

<ul>
<li><a href="https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html">Coroutine context and dispatchers</a></li>
<li><a href="https://juejin.cn/post/6926695962354122765">揭秘kotlin协程中的CoroutineContext</a></li>
<li><a href="https://juejin.cn/post/7270899168532152381">深入Kotlin协程系列|图解上下文</a></li>
<li><a href="https://juejin.cn/post/7137927889835524126">协程是怎么切换线程的</a></li>
</ul>


<h2>启动，挂起，让度和延续</h2>

<p>知道了如何创建协程，以及如何通过参数指定它运行的上下文和影响启动的参数后，就需要详细的了解一下协程的几中运行状态，以及什么是挂起，如何让度再到咋回到延续。</p>

<h3>协程的状态</h3>

<p>与Java中的线程类似，协程也是有几种不同的状态的，可以参考下表：</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> 协程状态 </th>
<th style="text-align:left;"> 描述 </th>
<th style="text-align:center;"> isActive </th>
<th style="text-align:center;"> isCompleted </th>
<th style="text-align:center;"> isCancelled </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> New </td>
<td style="text-align:left;"> 协程刚被创建，但还未被调度，未运行 </td>
<td style="text-align:center;"> false </td>
<td style="text-align:center;"> false </td>
<td style="text-align:center;"> false </td>
</tr>
<tr>
<td style="text-align:center;"> Active </td>
<td style="text-align:left;"> 已被调度，已运行 </td>
<td style="text-align:center;"> true </td>
<td style="text-align:center;"> false </td>
<td style="text-align:center;"> false </td>
</tr>
<tr>
<td style="text-align:center;"> Completing </td>
<td style="text-align:left;"> 等待子协程结束中 </td>
<td style="text-align:center;"> true </td>
<td style="text-align:center;"> false </td>
<td style="text-align:center;"> false </td>
</tr>
<tr>
<td style="text-align:center;"> Cancelling </td>
<td style="text-align:left;"> cancel子协程中 </td>
<td style="text-align:center;"> false </td>
<td style="text-align:center;"> false </td>
<td style="text-align:center;"> true </td>
</tr>
<tr>
<td style="text-align:center;"> Cancelled </td>
<td style="text-align:left;"> 已被取消，是最终状态 </td>
<td style="text-align:center;"> false </td>
<td style="text-align:center;"> true </td>
<td style="text-align:center;"> true </td>
</tr>
<tr>
<td style="text-align:center;"> Completed </td>
<td style="text-align:left;"> 已结束，是最终状态 </td>
<td style="text-align:center;"> false </td>
<td style="text-align:center;"> true </td>
<td style="text-align:center;"> false </td>
</tr>
</tbody>
</table>


<p>需要注意，这些状态是由<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/">接口Job</a>来定义的，它是一个广义上的异步并发任务，协程是它的一个实现而已，协程返回的也是对象Job，可以通过Job的方法如join，cancel，isActive等方法来控制协程和查询状态。协程的状态转移可以看这张图：</p>

<p><img src="https://assets.alexandria.raywenderlich.com/books/kco/images/7116dd4d1cf7d079a1ece92d888198c4fdcd6cced5bc408119700a236409fdbd/original.png" alt="" /></p>

<h3>协程的挂起，让度和延续</h3>

<p>用suspend修饰的函数必须在协程里调用，因为它们在运行的时候可以让协程挂起，协程遇到<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html">delay</a>或者<a href="">join</a>以及<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/await.html">await/awaitAll</a>时就会被挂起。除此之外，还可以调用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html">yield</a>主动进行挂起，这会释放线程，让其他协程得以运行，这便是<strong>让度</strong>。挂起，是可能导致线程切换的，这取决 于我们如何设置协程的上下文以及start参数。</p>

<p>那么，Kotlin中的协程是如何做到协程延续(resume)时，协程的运行状态和本地变量等是如何得以在线程之间保存和传播的呢？这就涉及到了<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-continuation/">Continuation</a>，在挂起的时候会创建一个Continuation对象，它把恢复协程所需要的数据都会打包起来，延续运行的的时候只需要调用Continuation#resume就可以了。一般情况下，我们不需要了解Conitnuation的创建过程，因为这过于底层了，Kotlin的编译器会帮我们做好一切。</p>

<p><img src="https://doordash.engineering/wp-content/uploads/2021/11/coroutine-11-1-1024x484.jpg" alt="" /></p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://juejin.cn/post/7288606110336401467">一文搞懂 Kotlin Coroutine Job 的工作流程</a></li>
<li><a href="https://juejin.cn/post/7304615395741351988">详解Kotlin协程实现原理</a></li>
<li><a href="https://juejin.cn/post/7312404578958934054">源解 Kotlin 协程</a></li>
</ul>


<h2>无限序列</h2>

<p>在继续深入学习其他话题之前先来看一个实际的妙用协程的例子，使用协程创建异步无限序列。<a href="https://kotlinlang.org/docs/constructing-collections.html">集合(Collections)</a>是对象的容器，用来存储对象实例（objects）的，把对象放入到集合中，也就是说在『放入』的过程中时，元素必须已经创建好了。而<a href="https://kotlinlang.org/docs/sequences.html">序列(Sequences)</a>并不存储对象实例，它按需生成对象，也就是说只有需要某个元素时，序列才会生成它，并且序列可以有无限个元素，它是按需生成元素，如果需要可以有无限发子弹。</p>

<p>序列是按需生成元素，因此它具有延迟化，占用资源少的特点。对于用<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/sequence.html">sequence builder</a>来创建无限序列时，其实就用到了协程，比如说创建一个质数的序列：</p>

<pre><code class="Kotlin">fun primes(start: Int): Sequence&lt;Int&gt; = sequence {
    println("Infinite prime sequence:")
    var n = start
    while (true) {
        if (n &gt; 1 &amp;&amp; (2 until n).none { i -&gt; n % i == 0 }) {
            yield(n)
            println("\tGenerating next prime after $n")
        }
        n++
    }
}

fun main() {
    for (prime in primes(start = 10)) {
        println("Received $prime")
        if (prime &gt; 30) {
            break
        }
    }
}
</code></pre>

<p>这段代码的输出是：</p>

<pre><code class="Bash">Infinite prime sequence:
Received 11
    Generating next prime after 11
Received 13
    Generating next prime after 13
Received 17
    Generating next prime after 17
Received 19
    Generating next prime after 19
Received 23
    Generating next prime after 23
Received 29
    Generating next prime after 29
Received 31
</code></pre>

<p>序列生成器之所以能够一个一个的生成元素，并返回给调用者的原因就是在于<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.sequences/-sequence-scope/yield.html">yield()</a>函数，它是一个suspend函数，执行后就会挂起，然后调用者的代码得以继续执行。如果没有把sequence生成器挂起的话，它会陷入死循环。我们可以详细的看一眼sequence的签名：</p>

<pre><code class="Kotlin">fun &lt;T&gt; sequence(
    block: suspend SequenceScope&lt;T&gt;.() -&gt; Unit
): Sequence&lt;T&gt;
</code></pre>

<p>可以发现sequence builder的参数是一个运行在SequenceScope中的挂起函数，内部一定是会创建一个协程来运行此代码块。并且，我们在此代码块中一定要让协程挂起，否则可能会陷入死循环。</p>

<p>拓展阅读 <a href="https://kt.academy/article/cc-sequence">Sequence builders in Kotlin Coroutines</a>。</p>

<h2>协程取消</h2>

<p>创建协程能得到协程的句柄即Job对象，可以用来控制协程，最重要的一个操作就是取消协程，通过<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/cancel.html">cancel</a>方法，目的是终止协程的运行。我们先来看一个示例：</p>

<pre><code class="Kotlin">val job = launch {
    repeat(1000) { i -&gt;
        println("job: I'm sleeping $i ...")
        delay(500L)
    }
}
delay(1300L) // delay a bit
println("main: I'm tired of waiting!")
job.cancel() // cancels the job
job.join() // waits for job's completion 
println("main: Now I can quit.")
</code></pre>

<p>输出如下：</p>

<pre><code class="Kotlin">job: I'm sleeping 0 ...
job: I'm sleeping 1 ...
job: I'm sleeping 2 ...
main: I'm tired of waiting!
main: Now I can quit.
</code></pre>

<h3>协程取消的特性</h3>

<p>协程只有<strong>处于挂起状态时才能被取消</strong>，这个可以看上面Job的状态表格。父协程被取消，它同时也会取消所有的子协程，并且父协程只有在所有子协程退出后才会退出，这种树形管理关系是结构化并发的基础。另外就是，为了更好的<strong>实现可取消性</strong>，在协程内部要在关键的地方检查<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/is-active.html">isActive</a>，比如循环时，或者做一些耗时操作时，以及时响应cancel。</p>

<p>为了更全面的响应取消操作，也要捕获<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/">CancellationException</a>，并在finally中清理占用的资源，这是因为对于挂起的库函数，当被cancel时会抛出CancellationException。如果有Java的并发经验的同学可以发现，这跟取消Thread是一样的（即interrupt一个Thread）。</p>

<h3>不可取消协程</h3>

<p>有时候可能希望协程不被取消，也就是不能被取消，因为可能在执行一些关键的初始化工作，不可被打断和取消，这时可以用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-non-cancellable/">withContext(NonCancellable) { &hellip; }</a>来作为协程的上下文环境，这坨代码块就不可被取消了，只有执行完才会返回，任外部如何cancel都没用：</p>

<pre><code class="Kotlin">val job = launch {
    try {
        repeat(1000) { i -&gt;
            println("job: I'm sleeping $i ...")
            delay(500L)
        }
    } finally {
        withContext(NonCancellable) {
            println("job: I'm running finally")
            delay(1000L)
            println("job: And I've just delayed for 1 sec because I'm non-cancellable")
        }
    }
}
delay(1300L) // delay a bit
println("main: I'm tired of waiting!")
job.cancelAndJoin() // cancels the job and waits for its completion
println("main: Now I can quit.")
</code></pre>

<p>这段代码非常有意思，父协程启动了子协程后就取消它，子协程中的try代码块会被取消，repeat不会执行完，但它的finally代码块是不可以取消的，一定要执行完子协程才能返回。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/cancellation-and-timeouts.html">Cancellation and timeouts</a>。</p>

<h2>超时处理</h2>

<p>对于异步和并发编程来说，<strong>超时处理</strong>是非常关键的，虽然异步地或者并发地去执行任务，但对于主线程来说不可能永远等待任务，比如请求网络时，如果在网络库未设置连接超时，那么主线程或者说主协程就有可能面临无限等待。一般的做法是把问题丢给用户，用户受不了了，不想等了，那就返回或者退出，返回或者退出自然会去cancel掉所有的异步任务，无论是协程还是线程。</p>

<p>但是，更为优雅的方式是对于每一个启动的异步任务，都主动的设置一个超时时间，在给定的时间内任务仍未结束，那就取消它，终止它。这样整体的并发会更加的有秩序和可控，当然了，取消随时仍可能发生，超时时间未到时，仍是可以主动取消的。</p>

<p>在Kotlin中，给协程加上超时时限非常的方便，用扩展函数<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-timeout.html">withTimeout(limit) {&hellip;}</a>就可以非常方便的给代码块加上超时时限，当超时时限达到时，如果协程仍未返回，会终止协程并抛出异常<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/index.html">TimeoutCancellationException</a>。</p>

<pre><code class="Kotlin">withTimeout(1300L) {
    repeat(1000) { i -&gt;
        println("I'm sleeping $i ...")
        delay(500L)
    }
}
//I'm sleeping 0 ...
//I'm sleeping 1 ...
//I'm sleeping 2 ...
//Exception in thread "main" kotlinx.coroutines.TimeoutCancellationException: Timed out waiting for 1300 ms
</code></pre>

<p>扩展阅读 <a href="https://juejin.cn/post/7250085815431020605">探索 Kotlin 协程 withTimeout 原理</a>。</p>

<h2>异常处理</h2>

<p>程序运行总会遇到异常情况，至少有一半的代码都是在处理各种异常情况。协程就是以异常的方式运行一坨代码块，这些代码块自然也可能会抛出异常，这时要如何处理呢？有同学举手了，好办啊，try-catch不就行了？这位同学先坐下，对于同步的代码是可行的，但对于异步代码并不总是可行。并发编程中的异常处理略微稍复杂一些，我们来详细的看看协程中的异常处理方法。</p>

<h3>协程中异常的传播</h3>

<p>对于同步代码来说，在外面调用层包裹try-catch总是管用的，比如说：</p>

<pre><code class="Kotlin">fun boo() {
    try {
        // do some sync works that may throw exceptions
    } catch (e: Exception) {
        println("Got you, no where to run!!!")
    }
}
</code></pre>

<p>但对于异步代码，这不管用，比如说想在协程外面try-catch异常，是行不通的：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    try {
        val job = launch(Dispatchers.Default + SupervisorJob()) {
            println("Ready to run!")
            delay(400)
            throw Exception("You will never catch me, hahaha!")
        }
        job.join()
    } catch (e: Exception) {
        println("Try to handle everything: ${e.message}")
    }
}
//Ready to run!
//Exception in thread "DefaultDispatcher-worker-1" java.lang.Exception: You will never catch me, hahaha!
</code></pre>

<p>协程中抛出了异常，但外层并没有能catch住，这段代码会crash。我们再看看async的情况：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    try {
        val deferred = async(Dispatchers.Default + SupervisorJob()) {
            println("Ready to run!")
            delay(400)
            throw Exception("You will never catch me, hahaha!")
        }
        deferred.await()
    } catch (e: Exception) {
        println("No where to run: ${e.message}")
    }
}
//Ready to run!
//No where to run: You will never catch me, hahaha!
</code></pre>

<p>这回外层的catch是生效的，能把协程中的异常捕获住！到此，我们可以总结一下协程中的异常的传播：<strong>launch创建的协程异常是不可在外面捕获的，而async则可以</strong>。</p>

<p><strong>注意：</strong>无论是launch还是async，如果父协程不去join或者await等待子协程的话，则是死活都无法捕获到子协程的异常的，因为协程是异步的，launch/async很快就返回了，会立马执行它后面的语句，所以，当协程运行时，外面的代码（即launch/async后面的语句）可能已执行完了，自然是不可能捕获到任何异常的，可以通过把上面两个例子中的join和await去掉，然后运行试试看，都会crash。</p>

<p>那么，要想处理协程中的异常，一是让协程自己去try-catch，另外就是使用CoroutineContext的另一个Element，叫作CoroutineExceptionHandler。</p>

<h3>未捕获异常处理器CoroutineExceptionHandler</h3>

<p>如果协程内部出现了未捕获的异常(uncaught exceptions)时，会先看协程上下文中有没有指定未捕获异常处理器(uncaught exception handler)，如果没有则会按前面说的方式再传播。在指定协程上下文时可以用一个<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/">CoroutineExceptionHandler</a>对象来当作uncaught excpetion handler，以处理未捕获异常：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    val handler = CoroutineExceptionHandler { _, exception -&gt;
        println("Totally under control: ${exception.message}")
    }

    val job1 = launch(Dispatchers.Default + SupervisorJob() + handler) {
        delay(200)
        throw Exception("Exploded!!!")
    }

    val job2 = launch(Dispatchers.Default + SupervisorJob() + handler) {
        delay(800)
        throw Exception("Can I run away???")
    }

    val deferred = async(Dispatchers.Default + SupervisorJob() + handler) {
        delay(400)
        throw Exception("You will never catch me, hahaha!")
    }

    joinAll(job1, job2, deferred)
}
//Totally under control: Exploded!!!
//Totally under control: Can I run away???
</code></pre>

<p>可以发现通过给launch指定CoroutineExceptionHandler可以捕获其uncaught excpetions。但是注意看async创建的协程似乎没效果，这是因为async本来就会把异常传播给其父协程，不会给CoroutineExceptionHandler处理，所以对于async来说指定了handler也是没有效果的，会<strong>被async忽略掉</strong>。</p>

<p>还需要注意的是，只有根协程（root coroutine）的上下文中的CoroutineExceptionHandler是有效的，被用于处理uncaught exceptions。协程是有树形关系的，一个协程出现未捕获异常(uncaught exception)时，它会把它丢给它的父协程处理，一层一层的传播直到根协程（root coroutine），如果根协程的上下文环境中有handler，那就用它来处理，否则就crash。换句话说，只有最外层的协程(root coroutine)设置一个handler给其context就够了，其他的子协程即使设置了handler也是没有用处的。</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    val handler = CoroutineExceptionHandler { _, exception -&gt;
        println("Totally under control: ${exception.message}")
    }

    val job1 = launch(Dispatchers.Default + SupervisorJob() + handler) {
        val subHandler = CoroutineExceptionHandler { _, exp -&gt;
            println("Try to intercept exceptions: ${exp.message}")
        }
        val subJob = launch(Dispatchers.Default + subHandler) {
            val grandJob = launch(Dispatchers.Default + subHandler) {
                throw Exception("Bad thing happened deep down!")
            }
            grandJob.join()
        }
        subJob.join()
    }

    val job2 = launch(Dispatchers.Default + SupervisorJob() + handler) {
        delay(800)
        throw Exception("Can I run away???")
    }

    joinAll(job1, job2)
}
//Totally under control: Bad thing happened deep down!
//Totally under control: Can I run away???
</code></pre>

<p>是的，聪明的你一定发现了，这里的规则其实与Java中的<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#setUncaughtExceptionHandler(java.lang.Thread.UncaughtExceptionHandler">Thread.UncaughtExceptionHandler</a>)是一样一样的，它也是只需要有一个所以用<strong>static</strong>成员就可以了。</p>

<h3>链式反应</h3>

<p>当协程发生未捕获异常(uncaught exceptions)而被动终止时，它自己肯定是会被终止的，这个异常会沿树形向上传给它的父协程，其父协程也会被终止(cancle)，由于结构化并发，父协程被cancel时，会cancel其所有的子协程。就像<strong>链式反应</strong>一样，在未经特殊处理情况下，一旦<strong>子协程发生异常</strong>，就会导致其所在的<strong>树形结构的所有协程被终止</strong>，可以通过一个示例来验证一下：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    val handler = CoroutineExceptionHandler { _, exception -&gt;
        println("Totally under control: ${exception.message}")
    }

    val root = launch(Dispatchers.Default + SupervisorJob() + handler) {
        val subJob1 = launch {
            val grandJob = launch {
                delay(100)
                throw Exception("Bad thing happened from deep down!")
            }
            grandJob.join()
            println("Sub coroutine #1 completed")
        }

        val subJob2 = launch {
            try {
                delay(60 * 1000)
            } finally {
                println("Sub coroutine #2 cancelled!!")
            }
        }

        val subJob3 = launch {
            try {
                delay(60 * 1000)
            } finally {
                println("Sub coroutine #3 cancelled!!!")
            }
        }

        val subJob4 = launch {
            try {
                delay(60 * 1000)
            } finally {
                println("Sub coroutine #4 cancelled!!!!")
            }
        }

        joinAll(subJob1, subJob2, subJob3, subJob4)
    }

    root.join()
}
//Sub coroutine #2 cancelled!!
//Sub coroutine #4 cancelled!!!!
//Sub coroutine #3 cancelled!!!
//Totally under control: Bad thing happened from deep down!
</code></pre>

<p>其他几个子协程subJob2，subJob3和subJob4都在工作中，但被grandJob的未捕获异常给终止掉了。另外，我们还可以发现这个异常是在根协程(root)里面的Uncaught exception handler中处理了，同时还可以发现，异常处理handler是在所有子协程被终止结束后才得以处理。再来看一个来自官方教程上面的例子：</p>

<pre><code class="Kotlin">val handler = CoroutineExceptionHandler { _, exception -&gt; 
    println("CoroutineExceptionHandler got $exception") 
}
val job = GlobalScope.launch(handler) {
    launch { // the first child
        try {
            delay(Long.MAX_VALUE)
        } finally {
            withContext(NonCancellable) {
                println("Children are cancelled, but exception is not handled until all children terminate")
                delay(100)
                println("The first child finished its non cancellable block")
            }
        }
    }
    launch { // the second child
        delay(10)
        println("Second child throws an exception")
        throw ArithmeticException()
    }
}
job.join()
//Second child throws an exception
//Children are cancelled, but exception is not handled until all children terminate
//The first child finished its non cancellable block
//CoroutineExceptionHandler got java.lang.ArithmeticException
</code></pre>

<p>这个例子非常的有意思，用到了好几个特性，先是第二个子协程发生了未捕获异常(ArithmeticException)，导致其父协程job被取消，但job还有其他子协程，所以还会去cancel仍在运行中的子协程，这个子协程被取消了，它正在delay，这时cancel它会抛CancellationException而终止delay，进入finally，finally中有一个不可以被打断的任务。而只有当所有子协程都终止完成了，job的handler才得以处理这个异常(ArithmeticException)。</p>

<h3>监管责任(Supervision)</h3>

<p>链式反应，异常会在树形关系中传递导致整个树形协程都被终止，这样设计的目的在于结构化并发，它能让整体结构的行为较一致，形成一个整体结构。很多时候这并不是想要的行为，比如说启动四个协程去服务器取四段数据，然后拼成一个整体使用，即使某段异常了，取不到，也没有必须把整体都取消掉。</p>

<p>可以给父协程加上监管责任，这样当其某一个子协程失败了，它会履行监管责任，保障其他子协程仍能运行，可以用一个例子来看一下：</p>

<pre><code class="Kotlin">val supervisor = SupervisorJob()
with(CoroutineScope(coroutineContext + supervisor)) {
    // launch the first child -- its exception is ignored for this example (don't do this in practice!)
    val firstChild = launch(CoroutineExceptionHandler { _, _ -&gt;  }) {
        println("The first child is failing")
        throw AssertionError("The first child is cancelled")
    }
    // launch the second child
    val secondChild = launch {
        firstChild.join()
        // Cancellation of the first child is not propagated to the second child
        println("The first child is cancelled: ${firstChild.isCancelled}, but the second one is still active")
        try {
            delay(Long.MAX_VALUE)
        } finally {
            // But cancellation of the supervisor is propagated
            println("The second child is cancelled because the supervisor was cancelled")
        }
    }
    // wait until the first child fails &amp; completes
    firstChild.join()
    println("Cancelling the supervisor")
    supervisor.cancel()
    secondChild.join()
}
//The first child is failing//The first child is cancelled: true, but the second one is still active//Cancelling the supervisor//The second child is cancelled because the supervisor was cancelled
</code></pre>

<p>有两种方式加上监管责任，一种是在协程上下文时指定一个<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-supervisor-job.html">SupervisorJob</a>对象，比如前面那个例子，可以这样修改：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    val handler = CoroutineExceptionHandler { _, exception -&gt;
        println("Totally under control: ${exception.message}")
    }

    val root = launch(Dispatchers.Default + SupervisorJob() + handler) {
        val subJob1 = launch {
            val grandJob = launch(SupervisorJob()) {
                delay(100)
                throw Exception("Bad thing happened from deep down!")
            }
            grandJob.join()
            println("Sub coroutine #1 completed")
        }

        val subJob2 = launch {
            try {
                delay(10 * 1000)
            } finally {
                println("Sub coroutine #2 cancelled!!")
            }
        }

        val subJob3 = launch {
            try {
                delay(20 * 1000)
            } finally {
                println("Sub coroutine #3 cancelled!!!")
            }
        }

        val subJob4 = launch {
            try {
                delay(30 * 1000)
            } finally {
                println("Sub coroutine #4 cancelled!!!!")
            }
        }

        joinAll(subJob1, subJob2, subJob3, subJob4)
    }

    root.join()
}
//Totally under control: Bad thing happened from deep down!
//Sub coroutine #1 completed
//Sub coroutine #2 cancelled!!
//Sub coroutine #3 cancelled!!!
//Sub coroutine #4 cancelled!!!!
</code></pre>

<p>除了单独的为每个协程上下文指定SupervisorJob以外，还有更为优雅的方式就是在合适的层级使用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html">扩展函数superivorScope</a>来创建一个scope，我们用此方法改造另一 个例子：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    val handler = CoroutineExceptionHandler { _, exception -&gt;
        println("CoroutineExceptionHandler got $exception")
    }
    val job = GlobalScope.launch(handler) {
        supervisorScope {
            launch { // the first child
                try {
                    delay(10 * 1000)
                } finally {
                    withContext(NonCancellable) {
                        println("Children are cancelled, but exception is not handled until all children terminate")
                        delay(100)
                        println("The first child finished its non cancellable block")
                    }
                }
            }
            launch { // the second child
                delay(10)
                println("Second child throws an exception")
                throw ArithmeticException()
            }
        }
    }
    job.join()
}
//Second child throws an exception
//CoroutineExceptionHandler got java.lang.ArithmeticException
//Children are cancelled, but exception is not handled until all children terminate
//The first child finished its non cancellable block
</code></pre>

<h3>取消异常(CancellationException)不是异常</h3>

<p>需要注意取消异常<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-cancellation-exception/">CancellationException</a>并不是常规的异常，不遵循前面说的规则，它会被忽略掉。这是因为CancellationException只会发生在主动取消协程时<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/cancel.html">Job#cancel</a>，这是自上而下的取消协程，并不需要链式反应和异常处理。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://kotlinlang.org/docs/exception-handling.html">Coroutine exceptions handling</a></li>
<li><a href="https://juejin.cn/post/7270478168758829111">彻底掌握kotlin 协程异常处理</a></li>
<li><a href="https://juejin.cn/post/7249647450515996732">Kotlin篇 > > 协程中的异常及异常处理</a></li>
</ul>


<h2>调试</h2>

<p>调试总是必须且难免的，有时候代码运行与预期不符，但又想不通为啥时就需要进行调试以弄清楚为啥会产生那样的结果。与常规的代码一样，调试有两种方式，一是<strong>通过IDE中的『Debug』功能，step-by-step</strong>的运行代码，修改代码；另一种就是<strong>通过加日志</strong>。</p>

<h3>在IDE中『Debug』</h3>

<p>凡是IDE，或者说敢称自己是IDE的，肯定有调试功能，也就是step-by-step式的单步跟踪功能。对Kotlin比较友好的IDEA和Android Studio自然也不例外。协程也是标准的Kotlin代码，所以也是可以调试的，并且在调试方面其实没有区别。都是先在代码中设置断点，然后使用虫子图标的『Debug』功能就好了。对于IDEA系（包括Android Studio），设置断点就是在代码编辑器行号旁边点一下就可以了：</p>

<p><img src="https://kotlinlang.org/docs/images/coroutine-breakpoint.png" alt="" /></p>

<p>然后点虫子图标进行『Debug』即可：</p>

<p><img src="https://kotlinlang.org/docs/images/flow-debug-project.png" alt="" /></p>

<p>这时代码会运行，然后在预设置的断点处停止，并出现调试窗口，这里面可以单步跟踪，继续执行，或者查看代码的运行状态。对于协程来说，会比较方便的显示每个协程的状态，比如是<em>SUSPENDED</em>还是<em>RUNNING</em>等。</p>

<p><img src="https://kotlinlang.org/docs/images/coroutine-idea-debugging-1.png" alt="" /></p>

<p>注意，对于异步流程和并发流程比较多的代码来说，『Debug』会扰乱原本的时序，因为JVM必须在断点处停下来。因此，『Debug』更适用于比较复杂的大段的同步代码的调试，比如协程内部的某一段逻辑。</p>

<h3>用日志来调试</h3>

<p>另外的方式就是用日志来查看代码的运行状态，其实这跟协程也没啥关系，用日志输出想要输出的信息就可以了。只不过对于协程，我们需要知道协程信息，也就是说要知道每条日志是哪个协程输出的。这就需要一个能够输出当前协程名字的方法，一个办法是在打日志时输出CoroutineName，可以通过context[CoroutineName]；更为方便的方法是直接输出线程名字<strong>Thread.currentThread().name</strong>，然后给JVM加上选项<strong>-Dkotlinx.coroutines.debug</strong>就可以得到协程的详细名字：</p>

<pre><code class="Kotlin">fun log(msg: String) = println("[${Thread.currentThread().name}] $msg")

fun main() = runBlocking {
    val a = async {
        log("I'm computing a piece of the answer")
        6
    }
    val b = async {
        log("I'm computing another piece of the answer")
        7
    }
    log("The answer is ${a.await() * b.await()}")
}
//[main @coroutine#2] I'm computing a piece of the answer
//[main @coroutine#3] I'm computing another piece of the answer
//[main @coroutine#1] The answer is 42
</code></pre>

<p>从日志中可以看每条日志所在的线程名字（即前面的main）和协程名字（即&#64;后面的内容）。注意，一定要给VM加上选项<strong>-Dkotlinx.coroutines.debug</strong>，要不然不会带有协程名字，只有线程名字：</p>

<pre><code class="Bash"># Output without -Dkotlinx.coroutines.debug

[main] I'm computing a piece of the answer
[main] I'm computing another piece of the answer
[main] The answer is 42
</code></pre>

<p>对于Android应用来说，是没有办法<strong>直接给VM加上选项的</strong>，这时可以通过<strong>设置系统属性</strong>，在应用的入口处，比如在<a href="">Application#onCreate</a>或者<a href="">Activity#onCreate</a>时，设置属性即可：</p>

<pre><code class="Kotlin">System.setProperty("kotlinx.coroutines.debug", if (BuildConfig.DEBUG) "on" else "off")
</code></pre>

<p>对于异步流程和并发流程较多的地方，用日志是比较理想的调试手段，因为它<strong>对程序运行的干扰相对较小</strong>。</p>

<p>当然了，并发编程最大的问题就是<strong>比较难调试</strong>，调试必然需要知道程序运行的状态，无论是日志还是单步调试都会对程序的运行造成影响，从而使原本的逻辑发生改变。相信同学们都会遇到类似的情景：加了几句日志，Bug就不复现了。这就好比量子世界里面观察者对量子的影响一样，听起来不可思议，但确实会发生。并发编程需要在编码之前做好功课，用什么样的模型，选什么样的范式，谁是生产者，谁是消费者，用图形画一画，厘清思路，之后再去编码实现。而不是上来就编码，边想边做，发现线程不够用了，就多开一个吧，A数据回来的太快了，消费者还没有准备好，那就先用一个Map存着吧，这样乱撞式的开发，最后可能会实现需求，但出现Bug必然是极难调试的。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://kotlinlang.org/docs/coroutine-context-and-dispatchers.html#debugging-coroutines-and-threads">Debugging coroutines and threads﻿</a></li>
<li><a href="https://kotlinlang.org/docs/debug-coroutines-with-idea.html">Debug coroutines using IntelliJ IDEA – tutorial</a></li>
<li><a href="https://juejin.cn/post/6860647298926379021">Kotlin Jetpack 实战 | 08. 协程“不为人知”的调试技巧</a></li>
</ul>


<h2>协程间通信</h2>

<p>大多数时候协程之间是需要通信的，比如说一个协程在从网络拉取数据，另一个协程可能需要显示进度。可以通过一些共享变量来实现，但这会有潜在的问题，因为<strong>协程随时可能会切换线程运行环境</strong>，这时共享变量就会存在线程安全问题。Kotlin则提供了更为优雅的方式，即Channel。</p>

<p><img src="https://kotlinlang.org/docs/images/using-channel-many-coroutines.png" alt="" /></p>

<p><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/">Channel</a>是一个<a href="https://jenkov.com/tutorials/java-concurrency/producer-consumer.html">生产者-消费者模式</a>，它是线程安全的，可以在生产者与消费之间传递数据。它与Java中的<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html">BlockingQueue</a>是类似的，不同之处在于，它是为协程而生的，它的操作只会挂起不会阻塞，但都是线程安全的。生产者通过<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/">send</a>来生产数据，消费者通过<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/">receive</a>来消费数据。生产者和消费者都可以用协程来实现，所以Channel是一个非常优雅的协程通信方式，高效，可靠且线程安全，来看个小示例：</p>

<pre><code class="Kotlin">fun main() = runBlocking&lt;Unit&gt; {
    val channel = Channel&lt;String&gt;()

    launch(Dispatchers.Default) {
        channel.send("A1")
        delay(10)
        channel.send("A2")
        logd("Producer A done")
    }
    launch(Dispatchers.IO) {
        channel.send("B1")
        logd("Producer B done")
    }

    launch {
        repeat(3) {
            val x = channel.receive()
            logd("Got $x")
        }
    }
}

fun logd(message: Any?) {
    println("[${Thread.currentThread().name}] $message")
}
//[main @coroutine#4] Got A1
//[main @coroutine#4] Got B1
//[DefaultDispatcher-worker-1 @coroutine#3] Producer B done
//[DefaultDispatcher-worker-2 @coroutine#2] Producer A done
//[main @coroutine#4] Got A2
</code></pre>

<p>进一步学习：</p>

<ul>
<li><a href="https://kotlinlang.org/docs/coroutines-and-channels.html#channels">Coroutines and Channels﻿</a></li>
<li><a href="https://kotlinlang.org/docs/channels.html">More about channels﻿</a></li>
<li><a href="https://juejin.cn/post/7171272840426029063">Kotlin协程之一文看懂Channel管道</a></li>
<li><a href="https://juejin.cn/post/7272174836335296548">Kotlin协程之Channel的使用与原理</a></li>
<li><a href="https://kt.academy/article/cc-channel">Channel in Kotlin Coroutines</a></li>
</ul>


<h2>在安卓中使用协程</h2>

<p><img src="https://ts1.cn.mm.bing.net/th/id/R-C.bd4dc46a7a5a9909ddeb90af8b5d689c?rik=6LThCIIV%2bEN67w&amp;riu=http%3a%2f%2fwikicodecamp.com%2fwp-content%2fuploads%2f2022%2f07%2fandroid_2_coroutine.jpg&amp;ehk=EORu%2fSzDMOJNZINUWgwnsOQ%2bf%2f53YvmcuiPz9Cj%2b%2bNI%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" /></p>

<p>从2019年开始，安卓开发生态中已经是<a href="https://developer.android.com/kotlin/first">Kotlin first</a>了，Kotlin是推荐的编程语言，因此协程自然也变成了推荐的异步和并发编程方式。想要在Android应用开发中用好协程，除了协程本身的知识以外，还需要注意的就是Android本身的东西。Android本身是有框架和相当多组件的，并不像我们前面写demo那样，都是从主函数main开始。因此，我们需要注意的就是多多使用框架和组件已经为我们定义好的协程工具，比如UI逻辑层的协程都要在viewModelScope中启动；以及要符合一些架构上的原则，比如Repository要有自己的scope和dispatcher。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://developer.android.com/kotlin/coroutines">Kotlin coroutines on Android</a></li>
<li><a href="https://developer.android.com/kotlin/coroutines/coroutines-adv">Improve app performance with Kotlin coroutines</a></li>
<li><a href="https://developer.android.com/kotlin/coroutines/coroutines-best-practices">Best practices for coroutines in Android</a></li>
</ul>


<h2>书籍推荐</h2>

<p>当对Kotlin以及协程有了基本的认识之后，如果想要进阶的学习，就需要读一些专题书籍，这里推荐两本：</p>

<ul>
<li><a href="https://www.packtpub.com/product/learning-concurrency-in-kotlin/9781788627160">《Learn Concurrency in Kotlin》</a> 这本书以并发为主题，只不过是用Kotlin协程的方式来实现并发，所以它的重点在于<strong>并发编程Concurrency</strong>，具体实现方式其实可以多种多样。</li>
<li><a href="https://www.bennyhuo.com/project/kotlin-coroutines.html">《深入理解Kotlin协程》</a> 这本书的优点在于会横向的介绍其他编程语言中的并发范式，从而能够深入的理解协程，对于有一定编程经验的人来说，横向比较的方式是非常有效的。</li>
</ul>


<h2>参考资料</h2>

<ul>
<li><a href="https://amitshekhar.me/blog/kotlin-coroutines">Mastering Kotlin Coroutines</a></li>
<li><a href="https://doordash.engineering/2021/11/09/the-beginners-guide-to-kotlin-coroutine-internals/">The Beginner’s Guide to Kotlin Coroutine Internals</a></li>
<li><a href="https://theboreddev.wpcomstaging.com/understanding-kotlin-coroutines/">Understanding Kotlin Coroutines</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
