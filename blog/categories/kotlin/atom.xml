<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Kotlin | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/kotlin/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2024-01-12T22:51:44+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Kotlin进阶之协程从入门到放弃]]></title>
    <link href="http://toughcoder.net/blog/2024/01/11/kotlin-coroutine-made-easy/"/>
    <updated>2024-01-11T22:29:39+08:00</updated>
    <id>http://toughcoder.net/blog/2024/01/11/kotlin-coroutine-made-easy</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Coroutine">协程Coroutine</a>是最新式的并发编程范式，它是纯编程语言层面的东西，不受制于操作系统，轻量级，易于控制，结构严谨，不易出错，易于测试，工具和配套设施都比较完备。在新生代编程语言（如Kotlin和Swift）中支持良好，在Kotlin中有着非常友好的支持，并且是写异步和并发程序的推荐方式。为了彻底学会使用协程和理解协程背后的原理，计划用三篇文章专注来学习协程。</p>

<p><a href=""><img src="https://cdn.filestackcontent.com/fShtqYm3Tp2Xl9C36xN8" title="auto auto" ></a></p>

<!-- more -->


<ul>
<li>第一篇：主要介绍协程的基本概念，以及如何使用协程，目标就是讲清基本概念，并快速上手。</li>
<li>第二篇：协程的高级用法，如结构化协程，Scope，Context，Exception handling，在框架中使用（如在Compose和Jetpack中），与Flow一起使用。目标就是进一步发挥协程的威力，写出专业健壮的协程代码 。</li>
<li>第三篇：理解协程的核心原理，以及协程的实现机制，以及在其他编程语言中的支持情况。目标是深刻理解协程的原理的实现机制，做到心中无剑，以及尝试在不支持协程的语言中实现协程</li>
</ul>


<p><strong>注意</strong>：在任何一个编程语言中异步和并发编程总是略微复杂的话题，Kotlin中的协程也不例外，因此需要先有一定的前置知识，也就是说要大概弄懂操作系统中的进程与线程， 以及要有一些Java中的线程和并发编程经验，否则是没有办法很好理解和使用Kotlin协程的。</p>

<h2>Hello, coroutines</h2>

<p>每当学习一门新的技术，最喜欢的方式就是快速的上手，比如先弄个『Hello, world!』之类的，而不是上来就讲什么概念，原理，范式和方法论。编程是门实践性很强的学科，要快速上手快速体验，当有了一定的感觉之后，再去研究它的概念和原理。</p>

<p>我们也要从一个『Hello, coroutines!』开始我们的Kotlin协程之旅。</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    launch {
        delay(1000)
        println(", coroutines!")
    }
    print("Hello")
}
// Hello, coroutines!
</code></pre>

<p>以常规的方式来思考，写在前面的语句会先执行，写在后面的语句会后执行，这就是同步的意思，似乎应该输出：</p>

<pre><code class="Bash">, coroutines!
Hello
</code></pre>

<p>但我们得到了期望的输出『Hello, coroutines!』，这就是协程的作用，它可以实现异步。这里launch是一个函数，后面的lambda是它的参数，它的作用就是启动一个协程来运行传入的代码块。这个代码块很简单，它先delay了1秒，然后再输出语句。因为启动了协程，并且协程里的代码等了1秒再执行余下的语句，因此，主函数中的输出语句先执行了，这样就得到了我们期望的输出顺序。</p>

<h3>配置协程运行环境</h3>

<p><strong>注意，注意</strong>，协程并不是Kotlin标准库的一部分，它属于<a href="https://github.com/Kotlin/kotlinx.coroutines/tree/master">官方扩展库</a>的一部分，有自己单独的版本号，要想使用协程还需要<a href="https://github.com/Kotlin/kotlinx.coroutines/blob/master/README.md#using-in-your-projects">单独配置依赖</a>。协程模块的名字是kotlinx.coroutines，有自已独立的版本号，需要注意的是，要注意Kotlin版本与协程版本之间的匹配关系，协程库对它所支持的Kotlin有最低版本要求。目前协程库最新版本是1.8.0-RC2，它对应的Kotlin版本是1.9.21。</p>

<p>配置协程库依赖：</p>

<h4>Maven</h4>

<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.jetbrains.kotlinx&lt;/groupId&gt;
    &lt;artifactId&gt;kotlinx-coroutines-core&lt;/artifactId&gt;
    &lt;version&gt;1.8.0-RC2&lt;/version&gt;
&lt;/dependency&gt;

&lt;properties&gt;
    &lt;kotlin.version&gt;1.9.21&lt;/kotlin.version&gt;
&lt;/properties&gt;
</code></pre>

<h4>Gradle</h4>

<pre><code class="Groovy">dependencies {
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.8.0-RC2")
}

plugins {
    // For build.gradle.kts (Kotlin DSL)
    kotlin("jvm") version "1.9.21"

    // For build.gradle (Groovy DSL)
    id "org.jetbrains.kotlin.jvm" version "1.9.21"
}

repositories {
    mavenCentral()
}
</code></pre>

<h4>Android</h4>

<pre><code class="Groovy">implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:1.8.0-RC2")
</code></pre>

<h2>协程是啥</h2>

<p><img src="https://gss0.baidu.com/-4o3dSag_xI4khGko9WTAnF6hhy/zhidao/pic/item/58ee3d6d55fbb2fb3f8cdfbe474a20a44723dcf3.jpg" alt="" /></p>

<p>那么协程是啥呢？协程就是一个子例程，或者说一个函数，与常规的函数其实也没啥区别，只不过它可以异步地执行，可以挂起，当然不同的协程也可以并行的执行（这就是并发了）。协程是没有阻塞的，协程只会挂起，一旦协程挂起，就交出CPU的控制权，就可以去执行其他协程了。协程是一种轻量级的线程，但它并不是线程，跟线程也没有直接关系，当然它跟其他函数一样，也是要运行在某一个线程里面的。</p>

<p>在Kotlin中协程的关键字是suspend，它用以修饰一个函数，suspend函数只能被另一个suspend函数调用，或者运行在一个协程内。另外就是delay函数了，它是将协程挂起一定时间。<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html">launch/async</a>函数则是创建并启动一个协程，await函数是等待一个协程执行结束并返回结果。runBlocking函数则是创建一个可以使用协程的作用域，叫作CoroutineScope，协程只能在协程作用域内启动，作用域的目的就是为了管理在其内启动的协程。不理解或者记不住这些关键字和函数也没有关系，这里只需要先有一个印象就够了。</p>

<h3>动动手，折腾一下</h3>

<p>对于我们的『Hello, coroutines!』程序，可以尝试进行一些修改，比如改一下delay的值，去掉runBlocking，或者去掉launch看看会发生什么！</p>

<h2>创建协程</h2>

<p>在继续之前，我们把之前的代码重构一下，把协程代码块抽象成一个函数：</p>

<pre><code class="Kotlin">fun main() = runBlocking { // this: CoroutineScope
    launch { doWorld() }
    println("Hello")
}
// Hello, coroutines!

// this is your first suspending function
suspend fun doWorld() {
    delay(1000L)
    println(", coroutines!!")
}
</code></pre>

<p>功能没变仍是输出『Hello, coroutines!』只不过代码块变成了一个suspend函数，被suspend修饰的函数只能运行在协程之中，或者被另一个suspend函数调用，当然 最终仍是要运行在某一个协程之中的。</p>

<p>创建协程的函数是launch()和<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html">async()</a>，它们都是函数，参数都是一个代码块，它们的作用是创建一个协程并让代码块参数运行在此协程内。把上面的launch换成async得到的结果是一模一样的：</p>

<pre><code class="Kotlin">fun main() = runBlocking { // this: CoroutineScope
    async { doWorld() }
    println("Hello")
}
// Hello, coroutines!
</code></pre>

<p>当然了，它们之间肯定是区别的，要不然何必费事弄两个函数呢，我们后面再讲它们的具体区别。</p>

<p>到现在我们知道了如何创建协程了，但如我们手动把<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html">runBlocking</a>删除掉，就会有编译错误，说launch/async找不到，那是因为这两个函数是扩展函数，它们是CoroutineScope类的扩展函数。前面说了，所有的协程必须运行在一个CoroutineScope内，前面的runBlocking函数的作用就是创建一个CoroutineScope，下面我们重点来看看啥是CoroutineScope。</p>

<h2>协程作用域</h2>

<p><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/">作用域（CoroutineScope）</a>是用于管理协程的，所有的协程必须运行在某个作用域内，这样通过作用域就可以更好的管理协程，比如控制它们的生命周期。这里面的概念就是<a href="https://kotlinlang.org/docs/coroutines-basics.html#structured-concurrency">结构化并发(structured concurrency)</a>，也就是让所有的协程以一种结构化的方式来组织和管理，以让整体的并发更为有秩序和可控。</p>

<p><img src="https://www.ericthecoder.com/wp-content/uploads/2019/09/feature-1.jpg" alt="" /></p>

<p>这与人类社会是类似的，比如军队，要把士兵编为不同的组织结构（如团，旅，师，军，集团军），目的就是增强整体的执行效率，进而增强战斗力，试想一个军队，如果没有组织结构，那就会是一盘散沙，战斗力可想而知。</p>

<h3>如何创建作用域</h3>

<p>有很多<a href="https://kotlinlang.org/docs/coroutines-basics.html#scope-builder">构造器方法</a>可以用于创建作用域，基本上不会直接创建作用域对象。最常见的就是用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html">coroutineScope</a>函数，它的作用是创建一个CoroutineScope，执行里面的协程，并等待所有的协程执行完毕后再退出(返回)，我们可以继续改造我们的例子，自己为我们的协程创建一个作用域：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    doWorld()
}

suspend fun doWorld() = coroutineScope {  // this: CoroutineScope
    launch {
        delay(1000L)
        println(", coroutines!!")
    }
    println("Hello")
}
</code></pre>

<p>还有一些其他的作用域生成方法如runBlocking和<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-global-scope/">GlobaleScope</a>，GlobleScope是一个全局的作用域，也就是Kotlin提供的一个在整个Kotlin中都可以直接使用的协程作用域，显然，我们不应该使用它，因为作用域的目的在于组织和管理协程，如果把所有的协程都放在一个全局作用域下面了，那跟没有使用域也没有啥区别了。就好比一个军队，只有一个将军，下面直辖一万个士兵，这跟没有将军是没有分别的。</p>

<p>至于runBlocking，它是创建一个作用域，执行其里面创建的协程，等待所有协程执行完毕后退出，但它还有一人上重要的功能就是，在等待协程执行的过程中它会阻塞线程，以保证调用者的线程一定比协程晚些退出。因此，只应该在一个地方使用runBlocking，那就是在主函数中使用，其他地方都不应该使用它。</p>

<p>虽然说协程必须运行在某一个CoroutineScope中，但是不是说在每个要创建协程的地方都使用coroutineScope创建一个新的作用域呢？这显然是滥用了。作用域的目的在于组织和管理协程，因此作用域应该符合架构设计的原则，比如为一个模块或者同一类功能创建一个作用域，以方便管理其内部分的协程。并且CoroutineScope是树形结构的，也就是说作用域本身也可以管理其他作用域，这才能形成完整的结构，体现结构化并发的思想。</p>

<h3>使用框架中的CoroutineScope</h3>

<p>如前所述作用域更多的要从架构角度来考虑。实际上大多数时候，我们并不需要自己创建作用域，因为框架会为我们准备好。就好比Jetpack中的<a href="https://developer.android.com/topic/libraries/architecture/viewmodel">ViewModel</a>，它的作用是把UI操作的逻辑封装起来，那么ViewModel中的所有协程都应该运行在viewModelScope之中，而这是框架已经为我们创建好了的，它会结合系统组件生命周期来管理协程。</p>

<h2>运行上下文</h2>

<p>协程不是什么神密的东西，也不是什么银弹，它就是一个普通的函数（例程routine），只不过它可以异步执行，也就是说launch了一个协程后，这条语句很快就执行完了，马上去执行launch {&hellip;}下面的语句了，协程代码块的执行是在协程里面，它什么时候返回结果是不知道的。也可以挂起，协程挂起后就释放了运行它的线程，并不会阻塞运行它的线程，那么其他协程就有机会运行。</p>

<p>这就涉及另一个重要的东西，就是协程运行的上下文，或者说协程运行的线程环境。协程它就是一个函数，它当然需要运行在某个线程里面。除非特别指定以切换运行的线程，否则所有的协程是运行在主线程中的。</p>

<p>协程的运行环境由<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/">CoroutineContext</a>来定义，但其实基本上不会直接创建这个对象，都是通过参数或者其他构建函数来指定协程的运行上下文环境。</p>

<h3>创建协程时指定上下文</h3>

<p>创建协程的函数launch和async是有多个参数，一共有三个参数，最后一个当然是代码块，前面两个都是有默认值的参数，因此大部分时候可以省略，它们的完整函数签名是：</p>

<pre><code class="Kotlin">fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -&gt; Unit
): Job

fun &lt;T&gt; CoroutineScope.async(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -&gt; T
): Deferred&lt;T&gt;
</code></pre>

<p>第一个参数便是指定协程运行的上下文。现在可以为我们的协程加上线程环境了：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    doWorld()
}

suspend fun doWorld() = coroutineScope {  // this: CoroutineScope
    launch(Dispatchers.Default) {
        delay(1000L)
        println(", coroutines!!")
    }
    println("Hello")
}
</code></pre>

<h3>使用扩展函数withContext</h3>

<p>另外一种方式就是使用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html">扩展函数withContext</a>，在其参数指定的上下文环境中调用代码块中的协程，等待其执行完，并返回结果。</p>

<pre><code class="Kotlin">suspend fun &lt;T&gt; withContext(context: CoroutineContext, block: suspend CoroutineScope.() -&gt; T): T
</code></pre>

<p>上面的例子也可以这样写：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    doWorld()
}

suspend fun doWorld() = coroutineScope {  // this: CoroutineScope
    launch {
        withContext(Dispatchers.Default) {
            delay(1000L)
            println(", coroutines!!")
        }
    }
    println("Hello")
}
</code></pre>

<p>但这并不是好的用法，withContext应该用在一些suspend方法中，并且这些方法想自己指定执行环境，并且执行环境对调用方是透明的。比如说，一个负责用户操作的UesrRepository，它只向外部暴露一些suspend方法，在这些suspend方法内部通过withContext来指定它自己运行的上下文环境，从而不用管调用者的执行环境，不也需要调用者知道repo的执行环境：</p>

<pre><code class="Kotlin">class UserRepository(
    val dispatcher: Dispatcher = Dispathers.IO
) {
    suspend fun login() {
        withContext(dispatcher) {
            // Do login
        }
    }
}
</code></pre>

<p>让每一个架构层次或者模块自己管理好自己运行的上下文，还有一个好处在于，可以方便的通过<strong>依赖注入</strong>来进行<strong>Mock或者测试</strong>。</p>

<h3>使用框架中的上下文环境</h3>

<p>虽然我们可以指定<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/">协程运行的上下文环境</a>，那是不是意味着要自己创建很多的context呢？非也，非也。框架中也预定义好了<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/">很多context</a>，可以直接拿来用，比如<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html">Dispatchers.Default</a>，这是Kotlin中的默认线程适合做计算密集类任务；<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-i-o.html">Dispatchers.IO</a>，这适合做IO密集的操作，如文件读写，网络等；<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html">Dispatchers.Main</a>，这是Kotlin中的主线程（即main函数运行的线程），UI中的主线程（如Swing和安卓的主线程）；等等，当然了，也可以自己创建一个context。</p>

<p>到这里我们可以发现，现代化的并发框架较以前是是非常的完备，从创建，到管理，再到运行环境都考虑的非常全面。比如<a href="https://github.com/ReactiveX/RxJava">RxJava</a>或者我们现在正在学习的协程，都是如此。在Java中，其实也有类似的东西，其实就是<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html">ExecutorService</a>，它就是异步和并发任务运行的环境。只不过，它的API设计的还是太过原始，你仍然 需要自己去实现一个<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html">Executor</a>，并没有像RxJava中的<a href="https://reactivex.io/RxJava/3.x/javadoc/io/reactivex/rxjava3/schedulers/Schedulers.html">Schedulers</a>以及Kotlin中的Dispatchers一样，有一些功能明确的预定义的对象可以直接使用。</p>

<h2>并发性</h2>

<p>并发就是代码『同时运行』，当然 有真并发，那就是并行，比如两台电脑同时都在运行不同的或者相同的应用程序，类似于两个人都在干活儿，这是并行（真并发）；大多数并发都是假的，只不过操作系统以粒度非常小的时间片在不同的代码间来回切换，让人感觉起来好像所有的代码都在同时运行，但真到了CPU的指令周期里面，其实同一个周期只能执行一个命令。当然了，现代处理器都具有多核心，每个核心可以执行一个指令，因此多核心可以真的同时运行多个线程，也可以实现真并发。</p>

<p>并发的前提是要能异步，也就是像我们的launch {&hellip;}一样，它很快就执行完了，这样后面可以继续执行，因此，协程是可以实现并发的，也就是让多个协程『同时运行』：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    doWorld()
}

// Concurrently executes both sections
suspend fun doWorld() = coroutineScope { // this: CoroutineScope
    launch {
        delay(2000L)
        println(", coroutine #2, comes later!")
    }
    launch {
        delay(1000L)
        println(", coroutine #1, here I am!")
    }
    print("Hello")
}
//Hello, coroutine #2, here I am!
//, coroutine #1, comes later!
</code></pre>

<p>注意，我们这里是假并发，我们没有指定线程，两个协程都是运行在主线程里面的，但它们没有相互影响，更没有阻塞发生，它们确实是『同时运行的』。</p>

<p>当然了，在实际开发过程中呢，肯定还是要指定协程的运行线程，以实现真的并发，原因在于真实的软件代码是比较复杂，主线程，以及每个协程都有大量的代码要执行，都去揩主线程的油，肯定 很快就被榨干了，所以必然要上<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-i-o.html">Dispatchers.IO</a>之类的多线程以实现真正的并发。</p>

<h2>可控制性</h2>

<p>好的并发框架一定是可控的，也就是说对于异步任务来说要能很好的<strong>开启</strong>，<strong>等待</strong>和<strong>终止</strong>。Kotlin中的协程是可以做到这一点的。前面说到launch和async都可以创建一个协程，那它俩到底 啥区别？我们从前面它们的函数签名可以看出它俩的返回值是不一样的，launch返回一个<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/">Job对象</a>，而async返回一个<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/">Deferred对象</a>。</p>

<p>Job对象可以理解为协程的一个句柄，可以用来控制协程，比如终止它（取消它cancel），『同步等待』它执行完（join()）。</p>

<pre><code class="Kotlin">suspend fun doWorld() = coroutineScope {
    val job = launch {
        delay(2000L)
        println(" and coroutine #2")
    }
    launch {
        delay(1000L)
        println("from coroutine #1 !")
    }
    println("Hello")
    job.join()
    println("All jobs done.")
}

fun main() = runBlocking {
    doWorld()
}
</code></pre>

<p>上面的例子输出是符合期望的：</p>

<pre><code class="Bash">Hello
from coroutine #1 !
 and coroutine #2
All jobs done.
</code></pre>

<p>而如果，把 job.join()去掉的话，因为launch {&hellip;}创建的协程是异步执行，很快就返回了，最后的语句println(&ldquo;All jobs done.&rdquo;)会得到执行，因为协程都有delay，所以『All jobs done.』要先于协程中的语句输出：</p>

<pre><code class="Bash">Hello
All jobs done?
from coroutine #1 !
 and coroutine #2
</code></pre>

<p><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.gkI-tiJSxqG7wpydbs9EugHaEK?rs=1&amp;pid=ImgDetMain" alt="" /></p>

<p>而Deferred是Job的一个子类，它特有的功能是取得协程的返回结果，通过其await函数可以『同步的等待』协程结果返回，launch可以通过Job来等待协程执行完成，但是拿不到协程的返回结果，这就是launch与async的最大的区别。</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    val one = async { computeOne() }
    val two = async { computeTwo() }

    println(" Finally we got: ${one.await() + two.await()}")
}

private suspend fun computeOne(): Int {
    return withContext(Dispatchers.IO) {
        print("Coroutine #1: Calculating ...")
        delay(2400)
        val res = 12
        println(", got $res")
        return@withContext res
    }
}

private suspend fun computeTwo(): Int {
    return withContext(Dispatchers.IO) {
        print("Coroutine #2: Calculating ...")
        delay(2200)
        val res = 20
        println(", got $res")
        return@withContext res
    }
}
//Coroutine #1: Calculating ...Coroutine #2: Calculating ..., got 20
//, got 12
// Finally we got: 32
</code></pre>

<p><strong>注意，注意</strong>：前面说Job#join()和Deferred#await()都可以『同步地等待』协程执行完成，但这里的『同步等待』是非阻塞式的，它只是把当前协程挂起，虽然说join和await后面的语句在协程返回前不会得到执行，但这并不是像<a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/sleep.html">join/sleep/wait</a>之于<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html">Thread</a>那种阻塞式的。协程的join和await只是挂起，把运行环境中的线程释放，在此期间其协程是可以得到CPU资源（即线程）继续运行的。</p>

<h2>总结</h2>

<p>本文主要介绍了Kotlin中的协程基本使用方法：在一个协程作用域中，通过launch/async来创建一个协程，通过context来切换协程的运行上下文（线程环境），并可以通过Job/Deferred对象来控制协程。</p>

<p>到此，我们可以总结出协程的一些特点：</p>

<ul>
<li><strong>轻量级</strong>，它是纯编程语言层面的东西，不涉及操作系统支持的进程和线程的创建，因此它占用的资源非常少，是轻量级的异步和并发利器。</li>
<li><strong>非阻塞式</strong>，协程最重要的特点是非阻塞，它的等待虽然会让其后面的语句延迟执行，但此时运行的线程已被释放，其他协程可以得到运行。</li>
<li><strong>设施完备</strong>，管理协程的作用域，切换运行环境的context，协程的可控，可以非常优雅的实现结构化并发编程，从而减少出错，并且完全可测。</li>
</ul>


<p>其实，可以看出<strong>协程是一种代码执行上的操作框架</strong>，它能让代码挂起，交出真实的CPU控制权。进程和线程都是操作系统直接支持的，操作硬件资源的方法，一个运行中的线程必须占有一个CPU核心，线程只能被阻塞，无法挂起，因为操作系统切换线程就意味着让CPU去运行另外一个线程，那么前一个线程就进入了阻塞状态(Blocked)，等操作系统再切换回这个线程时，它才得以继续运行，从阻塞状态转为运行状态。而协程是纯的编程语言层面实现的东西，视线程为透明，一旦挂起，就可以去执行另一坨代码，它全靠程序员自己来控制，协程，即一起协作的子例程，这也是协程，作为新一代并发编程范式最大的优势。</p>

<h2>书籍推荐</h2>

<p>《Kotlin编程实战》是推荐的书籍，这本书比较厚实，把Kotlin的每个特性都论述的十分详细。</p>

<h2>实践</h2>

<p>强烈推荐<a href="https://kotlinlang.org/docs/coroutines-and-channels.html">官方的一个实战教程</a>，非常适合入门，难度也不大，并且有答案，可以一步一步的学会使用协程，并理解它。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/coroutines-guide.html">Coroutines guide</a></li>
<li><a href="https://kotlinlang.org/docs/coroutines-basics.html">Coroutines basics</a></li>
<li><a href="https://kotlinlang.org/docs/coroutines-and-channels.html">Coroutines and channels − tutorial</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Kotlin Delegation]]></title>
    <link href="http://toughcoder.net/blog/2023/09/14/understanding-kotlin-delegation/"/>
    <updated>2023-09-14T22:01:46+08:00</updated>
    <id>http://toughcoder.net/blog/2023/09/14/understanding-kotlin-delegation</id>
    <content type="html"><![CDATA[<p>委托或者说委派，是一种设计机制，实现者并不真正的实现某些方法（行为），而是让另外一个对象来当真正的实现者。委拖与依赖注入和延时加载技术结合在一起会产生非常巨大的威力，让代码不但灵活方便扩展，也非常的优雅，但确实会较难以理解。<a href="https://kotlinlang.org/docs/delegation.html">委托机制(Delegation)</a>在Kotlin中的支持是很友好的，并且非常完善，用关键字by和lazy一起就可以写出非常强大的委拖机制代码。</p>

<p><a href=""><img src="https://hashnode.com/utility/r?url=https:%2F%2Fcdn.hashnode.com%2Fres%2Fhashnode%2Fimage%2Fupload%2Fv1629222884259%2FI3f9YGK1M.png%3Fw%3D1200%26h%3D630%26fit%3Dcrop%26crop%3Dentropy%26auto%3Dcompress%2Cformat%26format%3Dwebp%26fm%3Dpng" title="auto auto" ></a></p>

<!-- more -->


<h2><a href="https://en.wikipedia.org/wiki/Delegation_pattern">Delegation Pattern</a></h2>

<p>要想理解Kotlin中的委托，要先理解一下设计模式中的委托模式。严格来说委拖并不是一种设计模式，因为它并没有固定的范式，在GoF以及很多关于设计模式的书中并没有这一模式，准确的来说它是一种行为的实现方式，并不自己直接实现，而是委派给另外一个对象的方法。委托是一种行为模式，它只注重于行为，一般情况下都是对对象的方法进行委托，或者行为产生的结果也就是一个变量或者对象的域也可以委托，但只能委托给一个函数，这个函数会产生结果，以得到域的值。</p>

<p><img src="https://assets.alexandria.raywenderlich.com/books/des/images/c57492352703ffd13faa67205936b3bcb113947305da80d0be80770d0ceea10e/original.png" alt="" /></p>

<h3>委托与代理的区别</h3>

<p>代理是一种正式的设计模式，它强调的是权限和隔离，client只能访问到proxy，而并不知道realObject。而委托是一种实现机制，不自己实现，委派给其他对象去实现，它更强调的是行为和结果。代理是一种委托机制，但委托并不是代理。</p>

<p><img src="https://i1.wp.com/www.robertlarsononline.com/wp-content/uploads/2017/05/ProxyPatternGeneric.png?resize=700%2C388&amp;ssl=1" alt="" /></p>

<p>在理解了委托的概念后，就可以进一步的来看一下Kotlin中的委托了。</p>

<h2><a href="https://kotlinlang.org/docs/delegation.html">实现委托</a></h2>

<p>就是某一个类的实现，完全委托给另外一个对象，为了保持行为的一致，它们都实现了某一个接口。用关键字by来实现这一委托机制：</p>

<pre><code class="kotlin">interface Base {
    fun print()
}

class BaseImpl(val x: Int) : Base {
    override fun print() { print(x) }
}

class Derived(b: Base) : Base by b

fun main() {
    val b = BaseImpl(10)
    Derived(b).print()
}
</code></pre>

<p>类Drived也实现了接口Base，但它并没有自己去实现方法，而是委派给了它的构造参数b，b也是一个实现了接口的对象。这样Drived的行为就都委托给了对象b。而b则可以是任何一个实现了Base接口的对象，并且是在创建Drived时才指定的。更进一步的，这里可以用工厂方法，因为只要能生成一个实现了Base接口的对象即可，甚至可以用依赖注入来动态生成对委托对象。</p>

<p>这里需要明确一下术语，委托给别人的对象称为受托对象或者受托类，真正的做事情的人称之为委托对象。</p>

<p>Kotlin仅用一个关键字by就可以完成委托，编译器会自动生成受托类的实现，它的每个方法就直接调用委托对象的方法，可以理解 为上面的代码会编译生成这要的字节码：</p>

<pre><code class="java">class Derived extends Base {
    private Base impl;
    override void print() {
         impl.print();
    }
}
</code></pre>

<h2><a href="https://kotlinlang.org/docs/delegated-properties.html">属性委托</a></h2>

<pre><code class="kotlin">class Example {
    var p: String by Delegate()
}
</code></pre>

<p>属性委托是把属性的getter/setter委托给某一个函数，或者某一个对象（这个对象要有setValue/getValue方法，本质上仍是委托给一个函数）。</p>

<h2><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/lazy.html">延时机制(lazy)</a></h2>

<p>延时机制的委托才能产生最大的威力，而在Kotlin中，借助by和lazy就能对对象的属性实现延时委托机制，让只有在必要的时候(即第一次访问这个属性的时候)才生产出属性的真实值。</p>

<pre><code class="kotlin">val lazyValue: String by lazy {
    println("computed!")
    "Hello"
}

fun main() {
    println(lazyValue)
    println(lazyValue)
}
</code></pre>

<p>其实，by lazy可以应用在任何地方，不光是属性，常规的变量也是可以的。另外，需要注意lazy不但是第一次用到此变量时才会此具体计算，而且也只计算一次，后续再访问时，会从cache中读取首次计算后的值：</p>

<pre><code class="kotlin">var foo by lazy {
    if (someCondition) {
         generate()
    } else {
         defaultValue
    }
}
</code></pre>

<p>这个例子，假如第一次访问变量foo时，执行lazy后时someCondition是false就会返回defaultValue，而且后续再访问foo也不会再执行这个尾部lambda了，会直接返回defaultValue，因为它被cache住了。所以一般用lazy都是要针对 只读变量，也即<code>val foo by lazy { ... }</code>，这才是最正统的用法。</p>

<p>需要注意，lazy并不是一个关键字，它是一个函数，它只有一个参数就是一个lambda，所以可以写成尾部lambda的方式。</p>

<h2>常规委托</h2>

<p>使用by关键字就可以实现委托，这除了可以用于类的实现，属性实现以外，其实任何一个变量也可以用by来委托给一个函数。</p>

<pre><code class="kotlin">var expand by remember { mutableStateOf(true) }
</code></pre>

<h2>参考资料</h2>

<ul>
<li><a href="https://www.cnblogs.com/itzhoucong/p/14255117.html">设计模式（二）之委派模式（Delegate Pattern）深入浅出 </a></li>
<li><a href="https://learnku.com/docs/99-software-pattern/delegation-pattern/12018">委托模式 Delegation Pattern</a></li>
<li><a href="https://www.zhihu.com/question/23123039">编程设计模式中委托 和代理模式什么区别？</a></li>
<li><a href="https://stackoverflow.com/questions/38250022/what-does-by-keyword-do-in-kotlin">What does &lsquo;by&rsquo; keyword do in Kotlin?</a></li>
<li><a href="https://blog.csdn.net/wzgiceman/article/details/82689135">Kotlin -by 详解</a></li>
<li><a href="https://juejin.cn/post/7057675598671380493">Kotlin常用的by lazy你真的了解吗</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[More About Kotlin Functions]]></title>
    <link href="http://toughcoder.net/blog/2023/09/13/more-about-kotlin-functions/"/>
    <updated>2023-09-13T20:52:36+08:00</updated>
    <id>http://toughcoder.net/blog/2023/09/13/more-about-kotlin-functions</id>
    <content type="html"><![CDATA[<p>Kotlin中的函数是一级对象，除了常规的函数式编程以外，还支持一些非常灵活的特殊用法，可以大大增强代码的可读性和简洁性，让代码更加的优雅，在业界顶级的库如Compose中有大量的应用，今天就来学习一些，以扫清学习Compose的障碍。</p>

<p><a href=""><img src="https://www.callicoder.com/static/faf261ddf8d3f25d8c48da997d9a2dc1/kotlin-functions.png" title="auto auto" ></a></p>

<!-- more -->


<h2><a href="https://kotlinlang.org/docs/extensions.html">Extension Functions</a></h2>

<p>与传统的编程语言如C/C++，Java或者Python最大的不同就是，Kotlin对于类的扩展提供了相当灵活的方式。像Java和Python除了标准的继承方式以外，就只能用注解和Decorator。但对于Kotlin还可以用<a href="https://kotlinlang.org/docs/extensions.html">Extensions</a>这一方式。无论是注解还是Decorator，它的使用方式还是比较笨拙的，可以明显的看出来是额外定义的函数，与原Class是没啥关系的。</p>

<p><img src="https://thetechstack.net/assets/images/banners/kotlin-extension-function.png" alt="" /></p>

<p>比如说，对于整数来说，我们通常会有求绝对值，通常可以这样写：</p>

<pre><code class="kotlin">fun abs(a: Int) = if (a &lt; 0) -a else a
</code></pre>

<p>然后，这样使用：</p>

<pre><code class="kotlin">val aa = abs(a)
</code></pre>

<p>但在Kotlin中，有更优雅的方式：</p>

<pre><code class="kotlin">fun Int.abs() = if (this &lt; 0) -this else this

println((-4).abs())
println(100.abs())
</code></pre>

<p>这就是Extension functions，这样定义了后，可以像整数类型本身定义的方法那样直接在其对象上面调用。</p>

<h3>如何定义Extension functions</h3>

<p>Extension functions是针对Class的，或者一个Type的，指定目标Class名字，和参数就可以了，在函数的内部this就是调用函数时的对象。
<code>kotlin
fun &lt;ClassName&gt;.&lt;function name&gt;(params...): return type {
    // this is the function's receiver, which is the object when function invoked.
    // function implementation
}
</code>
需要注意，Extension functions必须是针对Class的。</p>

<h3>理解Extension functions</h3>

<p>Extension functions并没什么高深和神秘的东西，它只是相当于一个static函数，接收目标Class的对象而已，比如说：</p>

<pre><code class="kotlin">fun Shape.area(): Int = this.length * this.width

fun area(shape: Shape): Int = shape.length * shape.width
</code></pre>

<p>其实这两个函数是完全一样的，上面的那个Extension function其实就相当于后面的那个常规函数。只不过在函数的调用上面更加的方便，看起来更像是目标Class提供的方法一样，更优雅一些。</p>

<h3>Extension function的作用域</h3>

<p>Extension function并不会真的对目标Class做任何修改，它只是相当于你自己定义的一个函数。所以，它的作用域就是你定义的函数的作用域，如果你是在一个文件中定义的，那么它的作用域就是导入了这个文件的地方；如果是在一个类中的，那作用域就是这个类。</p>

<p>另外的问题就是，假如在多个地方定义了相同的Extension function，会发生什么呢，相同的意思就是目标Class一样，函数名字也一样，所做的事情也一样，仍是把它当成普通函数来理解就行，按照虚拟机懒惰加载的原则，应该是第一个被引用到的Extension function生效。</p>

<h3>参考资料</h3>

<ul>
<li><a href="https://www.baeldung.com/kotlin/extension-methods">Extension Functions in Kotlin</a></li>
<li><a href="https://marketsplash.com/tutorials/kotlin/kotlin-extension-function/">Kotlin Extension Function: How To Implement And Use It</a></li>
<li><a href="https://www.geekailab.com/doc/as/book/docs/Part1/Android%E5%BC%80%E5%8F%91%E5%BF%85%E5%A4%87Kotlin%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF/KotlinExtensions.html">让人爱不释手的Kotlin扩展（Extensions）技术探Extensions秘与应用</a></li>
<li><a href="https://www.jianshu.com/p/314cdb1603fc">Kotlin 扩展函数及原理</a></li>
<li><a href="https://juejin.cn/post/6935027613542907941">Kotlin 编程 #3 扩展函数（终于知道为什么 with 用 this，let 用 it）</a></li>
</ul>


<h2><a href="https://kotlinlang.org/docs/functions.html#infix-notation">Infix Functions</a></h2>

<p>准确的来说是Infix notation，它是一种执行函数的特殊方式，并不是定义了特殊的函数。也就是说某个函数被infix修饰了后，就可以用更为简洁的方式来调用它。常规的函数执行（或者说调用）是用函数名字加上括号，括号里面是参数，比如foo()，bar(&ldquo;here&rdquo;)。而infix方式则可以是 <code>参数1 函数名 参数2</code> 这种方式，也即与常规的函数调用完全不一样。看起来像是语言本身的关键字一样。</p>

<p><img src="https://www.fusebes.com/wp-content/uploads/2021/03/Post-Banners-FuseBase-17-1.png" alt="" /></p>

<p>比如，移位并不是运算符，也不是关键字，而是一个被infix修饰的二元参数函数：</p>

<pre><code class="kotlin">finfix un Int.shr(x: Int): Int {...}

8.shr(2) // 这样正常调用也完全可以，把整数8右移2位
8 shr 2 // 这是infix式的用法，其实是等同于上面的函数调用
</code></pre>

<p>infix必须是Extension function，并且只能有一个参数，算上Extension function的接收对象，其实一共是2个参数。标准库中也定义了大量的infix，如整数位移的shr和shl。以及像一些DSL中的函数，都会定义成infix，以让代码更简洁。</p>

<p>总之，下次再见到 <code>a xyz b</code> 这种写法时，不用害怕，并不是有了新的关键字，这里的xyz是infix notation，把它当成函数调用 <code>xyz(a, b)</code> 就好了。</p>

<h3>参考资料</h3>

<ul>
<li><a href="https://www.programiz.com/kotlin-programming/infix-notation">Kotlin Infix Function Call</a></li>
<li><a href="https://www.baeldung.com/kotlin/infix-functions">Infix Functions in Kotlin</a></li>
</ul>


<h2><a href="https://kotlinlang.org/docs/inline-functions.html">inline Functions</a></h2>

<p><img src="https://cdn.educba.com/academy/wp-content/uploads/2021/04/Kotlin-Inline-Function.jpg" alt="" /></p>

<p>常规的lambda会有closure（捕获上下文中的对象），在编译后会产生很多对象，这会导致一些性能问题，但这是标准的函数式编程。</p>

<p>但某些情况下，我提供的是一个单纯的行为（lambda），比如像Collections的forEach以及filter，传入的lambda也好，或者其他函数也好，这是一个单纯的行为，你在集合中遍历时执行它就好。这种情况好，我们希望高阶函数在其函数体内直接使用传入的函数参数就可以了，不需要进行常规的对象创建（closure对象以及函数接口对象）。就可以使用inline关键字来修饰这人高阶函数。</p>

<h3>参考资料</h3>

<ul>
<li><a href="https://www.baeldung.com/kotlin/inline-functions">Inline Functions in Kotlin</a></li>
<li><a href="https://amitshekhar.me/blog/inline-function-in-kotlin">inline function in Kotlin</a></li>
<li><a href="https://www.geeksforgeeks.org/kotlin-inline-functions/">Kotlin Inline Functions</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Kotlin Scope Functions]]></title>
    <link href="http://toughcoder.net/blog/2023/04/12/understanding-kotlin-scope-functions/"/>
    <updated>2023-04-12T15:06:18+08:00</updated>
    <id>http://toughcoder.net/blog/2023/04/12/understanding-kotlin-scope-functions</id>
    <content type="html"><![CDATA[<p>Kotlin是基于JVM衍生出来的新一代通用编程语言，它的目标是简洁，可读和高效，这里的高效并不是代码的运行效率高，而是说项目的开发效率高。Kotlin有太多的小巧的新特性（在Java眼中就是语法糖），比如在Kotlin中有几个作用和用法都非常接近的函数apply/with/run/let/also，它们的正统名字是<strong>作用域函数</strong>(Scope functions)，今天就来学习一下这些函数的使用方法和具体区别。</p>

<p><a href=""><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.eDXYmyuQp-E1wGqx4WnhIgHaEK?pid=ImgDet&amp;rs=1" title="auto auto" ></a></p>

<!-- more -->


<p>Java是面向对象的王牌语言，它的特点是严谨和教条，Java写出来的代码学过Java的人大多都看得懂，所以规模以上的项目现在基本上都用Java，这对维护是有好处的。但Kotlin不一样，它有非常多的特性，融合了众多编程语言的特点，同样一件事情，可能有无数种写法，虽然号称是用标准Kotlin语言实现的，但是即使学过Kotin的人也看不懂。比如虽然你学会了Function，Object和lambda，以及像inline function和extension，但是如果用apply和with写几段方法，你就看不懂了，这就导致了Kotlin虽然易于上手，但是要想学透和提高曲线 就会陡峭许多。</p>

<p><img src="https://tse2-mm.cn.bing.net/th/id/OIP-C.pVewkBVy74Ivnoumj0Gx0wHaF8?pid=ImgDet&amp;rs=1" alt="" /></p>

<h2>到底是个啥</h2>

<p>先来看一下Scope function到底是什么，它们的作用是在一个对象上执行一段代码，我们来看一个简单的例子：有一个类是Person，它有一些属性和方法，我们想对它的一个对象进行操作，通常会这样做：</p>

<pre><code class="kotlin">val alice = Person(name="Alice", age=20,addr="Amsterdam")
println(alice)
alice.moveTo("London")
alice.incrementAge(2)
println("Two years later ${alice.name} is at ${alice.addr}")
</code></pre>

<p>但使用scope function，我们可以这样做：</p>

<pre><code class="kotlin">val alice = Person("Alice", 20, "Amsterdam").apply {
    println(this)
    moveTo("London")
    incrementAge(2)
}
println("Two years later ${alice.name} is at ${alice.addr}")

//Person(name='Alice', age=20, addr='Amsterdam')
//Two years later Alice is at London
</code></pre>

<p>这两段代码的输出是完全一样的，但是第二段明显要简洁很多这就是scope function的作用，仔细看apply后面的lambda块，它是一个scope，犹如在对象的类定义之中，在这个代码块中可以直接引用对象的方法，而不是像常规的那样使用对象的引用。</p>

<p><em>注意</em>：如果不是很尾部lambda的同学可以先行参考<a href="http://toughcoder.net/blog/2023/01/24/understanding-kotlin-functions/">另外一篇文章</a>，以加强理解。</p>

<h2>理解Scope</h2>

<p>作用域也可以理解为一个代码块的上下文，也就是说在一个代码中，可以直接使用的东西，环境变量之于进程，系统框架为应用准备的基础对象，都可以视为一种scope。最为明显的就是类的定义，在类中，我们可以引用this指针来代表当前对象super指针来代表基类，这也是一种scope。lambda捕获的闭包也是一种scope。</p>

<p>Kotlin的scope functions就是把某一个对象当作代码块的scope，代码块中的代码可以方便的使用这个对象。</p>

<h2>Scope funtions的作用</h2>

<p>如同开头讨论的，能用scope function写出来的东西，用常规方式也一样可以做到，那到底图个啥呢？用scope function的方式代码变得更加的简洁和紧凑，我们把针对某一对象的密集操作集中在一起放入一个代码块中，会更加的内聚和紧凑，易于扩展和维护。但也要注意不能滥用，代码块中只应该写与对象相关的操作，与scope对象不相干的事情是绝对不应该放入其中的。</p>

<h2>Scope functions</h2>

<p>主要有6个，它们的应用主体都是一个对象，也就是要在一个对象上面调用这些函数，然后提供一个代码块（lambda）：</p>

<table>
<thead>
<tr>
<th style="text-align:center;"> Scope Function </th>
<th style="text-align:center;"> Object reference </th>
<th style="text-align:center;"> Return value </th>
<th style="text-align:center;"> Description </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center;"> let </td>
<td style="text-align:center;"> it </td>
<td style="text-align:center;"> lambda result </td>
<td style="text-align:center;"> Extension function </td>
</tr>
<tr>
<td style="text-align:center;"> run </td>
<td style="text-align:center;"> this </td>
<td style="text-align:center;"> lambda result </td>
<td style="text-align:center;"> Extension function </td>
</tr>
<tr>
<td style="text-align:center;"> run </td>
<td style="text-align:center;"> _ </td>
<td style="text-align:center;"> lambda result </td>
<td style="text-align:center;"> No object in the scope </td>
</tr>
<tr>
<td style="text-align:center;"> with </td>
<td style="text-align:center;"> this </td>
<td style="text-align:center;"> lambda result </td>
<td style="text-align:center;"> Take the object as an argument </td>
</tr>
<tr>
<td style="text-align:center;"> apply </td>
<td style="text-align:center;"> this </td>
<td style="text-align:center;"> context object </td>
<td style="text-align:center;"> Extension function </td>
</tr>
<tr>
<td style="text-align:center;"> also </td>
<td style="text-align:center;"> it </td>
<td style="text-align:center;"> context object </td>
<td style="text-align:center;"> Extension function </td>
</tr>
</tbody>
</table>


<h2>它们的区别</h2>

<h3>with不是一个extension函数</h3>

<p>其他几个都是extension函数，所以with一定要把scope object作为参数传入。</p>

<h3>scope对象的引用方式</h3>

<p>对于scope function来说scope对象都会作为一个context object，可以在lambda块中使用，有些是作为this指针，有些是作为lambda的默认参数名字也即it指针，但它们都指向context object，本质上是没有区别的只是指针的名字一个是this一个是it。但是，跟类的定义scope是一样的，this指针是可以省略的，但如果it作为参数，则是不能省略的，具体来说，比如说，用apply时，代码块中是this指针，那么可以直接这样写：</p>

<pre><code class="kotlin">val alice = Person("Alice", 20, "Amsterdam").apply {
    println(this)
    moveTo("London")
    incrementAge(2)
}
</code></pre>

<p>当然 你也可以显式的把this写出来，this.moveTo(&ldquo;London&rdquo;)，但这就麻烦多了，何必呢。所以apply最合适的场景是对对象本身的操作，如赋值和修改属性。</p>

<p>但如果是用also，就必须用it了，这个不能省，因为它是对scope对象的引用：
<code>kotlin
alice.also {
    println("Two years later ${it.name} is at ${it.addr}")
}
</code>
所以，also最适合的不是对对象本身的操作，而是一些与对象相关的副作用，如打印日志等。</p>

<h3>返回值不同</h3>

<p>这坨Scope functions是一个函数，它是有返回值的，这个返回是不一样的，apply/also返回的是context object，其他几个则是返回lambda中的返回值也就是lambda的最后一个表达 式或者lambda中显式的return语句。</p>

<p>所以，如果是想继续使用scope object，那么就要用apply/also，如果想得到某个其他值就要用let/run/with，即使说不在乎函数的返回值时，这时也推荐使用also，因为假如后续想继续添加其他操作时，可以直接在后面链接上其他的scope function。其他返回值的let/run/with一般用在一组操作的确定性的终点上面，比如统计均值，那最后的均值计算可以用run，比如文件操作，读写都可以用with。</p>

<h2>如何选择合适的scope函数</h2>

<p>结合它们各自的特点，可以得到如下使用建议：</p>

<h3>如果是更改scope对象本身，用apply()</h3>

<p>比如说要设置某个对象的一坨属性状态，这时就把目标对象作为scope，然后在其上调用apply()，在函数块内把操作都做完：</p>

<pre><code class="Kotlin">val alice = Person("Alice", 20, "Amsterdam").apply {
    println(this)
    moveTo("London")
    incrementAge(2)
}
</code></pre>

<h3>如果是对象弱相关的副作用操作，就用also()</h3>

<p>最为典型的例子就是比如说打印一些日志，这时最好的就是用also。</p>

<h3>判断nullity，不是null时执行一些强相关操作时用let</h3>

<p>基于当前对象，执行一些强相关的操作，这时可以用let，并且可以顺便做nullable检查。</p>

<h3>对象作为一个参数，执行一些转化时用run/with</h3>

<p>把当前对象作为一个参数，或者一个输入，做一些操作，执行一些转化，最终输出为其他对象时，这种时候最好用run/with，比如在不同的架构层级之间转换类型对象时，就可以用run/with。或者在网络返回和本地数据库实体之间转换时，也可以用run/with，区别不大，但用with可读性略强一些，相当于是把对象视为一个上下文，比如：</p>

<pre><code class="Kotlin">val res = nowWeather.getWeather(city)
with (res) {
   WeatherEnity(weather, city)
}
</code></pre>

<p>with函数体内的参数是this，可以直接引用对象的成员，可以使代码非常的简洁，对象成了上下文，又不失可读性。这就让scope函数发挥了最大的价值。</p>

<h2>注意事项</h2>

<p>任何技术和工具要深刻理解它们的应用范围和使用场景以避免滥用，要用到恰到好处才能发挥最大的价值。对于一些非必须的东西，更是如此。</p>

<p>Scope functions是应用于对象上面的，所以前提是当你需要对一个对象进行一些操作时，才可以使用scope functions，具体选择哪一个参考 上面一节的讨论。另外，就是放入代码块中的操作必须全部是scope对象相关的才可以。一个scope function中只能是一组相关的操作，不同组的操作要启用不同的scope functions。比如说网络请求response的处理，可以分为服务器状态码和返回实体的检测，转成具体数据，打印日志这么三个scope functions，而不是全放进一个里面。</p>

<p>总而言之，要视具体的需求和场景，并基于场景选择合适的scope function，切忌过度使用。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/scope-functions.html">Scope functions</a></li>
<li><a href="https://blog.mindorks.com/using-scoped-functions-in-kotlin-let-run-with-also-apply/">Using Scoped Functions in Kotlin - let, run, with, also, apply</a></li>
<li><a href="https://www.digitalocean.com/community/tutorials/kotlin-let-run-also-apply-with">Kotlin let, run, also, apply, with</a></li>
<li><a href="https://shusheng007.top/2020/10/02/1-6/">秒懂Kotlin之彻底掌握Scope Functions (apply, also,let,run,with)</a></li>
<li><a href="https://www.jianshu.com/p/5c4a954d2b2c">Kotlin之let,apply,run,with等函数区别</a></li>
<li><a href="https://juejin.cn/post/6868179386344931342">Kotlin学习：run、with、apply、also、let的区别</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Understanding Kotlin Based DSL]]></title>
    <link href="http://toughcoder.net/blog/2023/02/14/understanding-kotlin-based-dsl/"/>
    <updated>2023-02-14T16:51:58+08:00</updated>
    <id>http://toughcoder.net/blog/2023/02/14/understanding-kotlin-based-dsl</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Domain-specific_language">DSL Domain Specific Langauge</a>是解决特定领域内问题的编程语言，它的特点通常是简洁，虽不通用，但可读性强，呈描述式和声明式，比较典型的例子就是SQL语句和正则表达式，以及一些文本处理工具如Sed和AWK。与之对应的就是通用编程语言<a href="https://en.wikipedia.org/wiki/General-purpose_language">GPL General Purpose Language</a>，能解决几乎所有的计算机问题，没有为特定领域进行定制，但语句可读性远不及DSL，它们的语句一般都是命令式的，如熟悉的C/C++, Java和Python等。</p>

<p><a href=""><img src="https://cdn.educba.com/academy/wp-content/uploads/2022/07/Kotlin-DSL.jpg" title="auto auto" ></a></p>

<!-- more -->


<h2>GPL中的DSL痛点</h2>

<p>DSL的优点是<strong>声明式的，描述式的</strong>，并不在意<strong>具体细节的实现</strong>，比如像SQL语句，我只关心我想要什么，具体如何实现的是底下工具的事情：</p>

<pre><code class="SQL">select (id, name, address)
    where name = "John" and age &lt;= 10
    from classlist
</code></pre>

<p>但，当在GPL，通用编程语言中解决DSL问题时，就会很蛋疼，在任何一个编程语言中实现一个SQL查询 的接口都会相当的笨拙和难用，要么需要创建很多个对象，要么需要传递一大堆令人费解的参数：</p>

<pre><code class="Java">    Cursor cursor = query(uri, projects, where, whereArgs, sortby);
</code></pre>

<p>可读性非常的差，假如能写成DSL那样，可读性会大大的增强。</p>

<h2>DSL式的API</h2>

<p>在Kotlin中，可以写成这样：</p>

<pre><code class="kotlin">query {
    from "classlist"
    where {
        "name" eq "John"
        "age" lessEq 10
    }
}
</code></pre>

<p>可读性大大加强，这样的API使用起来也会如丝般顺滑，因为它符合DSL：描述性的，声明式的，不关心具体实现细节，只关注想要什么。</p>

<h2>背后原理</h2>

<p>Kotlin借助尾部lambda，infix函数，扩展函数。整体来就其实是一个函数调用，因为Kotlin函数最后一个参数如果是lambda时可以写在函数调用之外，所以，一层一层的花括号，其实就是函数调用。</p>

<p>再借助扩展函数和infix函数，可以把另外一些函数调用写成DSL式，比如像二进制按位或运算a or b等同于a.or(b)，这也是一个函数调用，但可读性大大加强。可以像写不作文一样的来写代码。</p>

<p>总之，见到DSL式的语句时不用惊慌，它是合法的Kotlin函数调用，把它理解成为函数调用就可以了。</p>

<h2>合理使用</h2>

<p>虽然DSL式的API能大大提高可读性，像真正的DSL一样去使用，但也要注意合理使用，不能滥用。我们要正向的解决问题，当遇到特定领域(Domain)的问题时，就可以定义和实现出一套符合DSL的API。也就是说我们要利用Kotlin语言提供的能力来实现DSL式的API去解决特定领域的问题。就像Android的布局，就可以定义出一套DSL式的API，这就是当时比较火的<a href="https://github.com/Kotlin/anko">anko</a>(现已废弃了)和现在的Compose，以及像涉及HTML，SQL的等特定领域问题时。</p>

<p>但不能反过来，为了写成DSL式，而去把所有的API都搞成DSL那样，比如把一些常规的操作像网络，像文件操作等都搞成那样，那就纯属滥用了。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/type-safe-builders.html#full-definition-of-the-com-example-html-package">Type-safe builders﻿</a></li>
<li><a href="https://www.baeldung.com/kotlin/dsl">Building DSLs in Kotlin</a></li>
<li><a href="https://coolshell.cn/articles/5709.html">API设计：用流畅接口构造内部DSL</a></li>
<li><a href="https://www.jianshu.com/p/f5f0d38e3e44">Kotlin之美——DSL篇</a></li>
<li><a href="https://blog.mindorks.com/mastering-kotlin-dsl-in-android-step-by-step-guide/">Mastering Kotlin DSL In Android - Step By Step Guide</a></li>
<li><a href="https://brunoaybar.com/how-do-kotlin-dsl-libraries-work/">How do Kotlin DSL libraries work?</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
