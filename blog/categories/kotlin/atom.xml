<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Kotlin | 稀有猿诉]]></title>
  <link href="https://alexhilton.github.io/blog/categories/kotlin/atom.xml" rel="self"/>
  <link href="https://alexhilton.github.io/"/>
  <updated>2024-11-17T20:35:42+08:00</updated>
  <id>https://alexhilton.github.io/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[一文搞懂Kotlin符号处理接口KSP]]></title>
    <link href="https://alexhilton.github.io/blog/2024/04/16/kotlin-ksp-made-easy/"/>
    <updated>2024-04-16T21:17:43+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/04/16/kotlin-ksp-made-easy</id>
    <content type="html"><![CDATA[<p>Kotlin符号处理（Kotlin Symbol Processing）即KSP是可以用于开发轻量级编译器插件的一套API。是Kotlin原生的，Kotlin语法友好的编译器插件。使用简单且易于上手，可以实现一些非常强大的编译时代码处理功能，如代码生成和代码检查。今天就来学习一下KSP的基本原理，以及如何使用KSP API。</p>

<p><a href=""><img src="https://androiddeepdive.github.io/Team-Blog/images/cover_ksp.png" title="auto auto" ></a></p>

<!-- more -->


<p><strong>注意</strong>，本文是Kotlin中较为高级的话题，适合有一定的Kotlin基础的同学，否则理解起来可能有难度，可以事先<a href="https://juejin.cn/column/7351592055908892723">阅读前面的文章</a>。</p>

<h2>什么是KSP</h2>

<p>与前文提到的注解处理器kapt类似，KSP也是一种编译时的插件，能够在编译前处理Kotlin语言的符号。KSP API能地道地处理Kotlin的源码，因为它是专门为Kotlin而设计的，能够完全的理解和识别Kotlin的语言符号，以及Kotlin专属的特性：如扩展函数，声明点泛型变化以及本地函数。KSP API基于Kotlin的语法，把Kotlin程序拆解为各种静态的符号，可以处理如类，成员，函数，参数 以及注解等等。但它并不是运行时的（那是反射做的事情），因此像逻辑如循环和条件语句是没有办法进行处理，以及也无法得到表达式的结果。</p>

<p>虽然KSP是编译器插件，但它是运行在最终编译之前，也就是说在编译器编译全部代码之前，事先会运行KSP插件。所以KSP API最适合做的事情是：</p>

<ol>
<li>读取代码和各种资源文件，并进行分析</li>
<li>生成代码</li>
</ol>


<p>接下来看如何具体使用KSP API。</p>

<h2>配置KSP</h2>

<p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcStf17qaB5JSFveiBVlA6ljiI0OgI3kN4hnQkBKtuFnSw&amp;s" alt="" /></p>

<p>KSP是由谷歌开发的一套工具，包括两部分一个是Kotlin plugin，另一个是依赖库。所以需要在项目的根build.gradle里面，先把plugin添加到项目里：</p>

<pre><code class="Groovy">// The root build.gradle of your project
plugins {
    id 'org.jetbrains.kotlin.jvm' version '1.9.23' apply false
    id 'com.google.devtools.ksp' version '1.9.23-1.0.20' apply false
}
</code></pre>

<p>当然，这一步其实并不是必须的，也可以在每个模块中再配置plugin。</p>

<p>接下来，在使用KSP的模块里面添加plugin，添加依赖以及指明KSP processor，这是最为关键的配置：</p>

<pre><code class="Groovy">// module build.gradle
plugins {
    id 'org.jetbrains.kotlin.jvm'
    id 'com.google.devtools.ksp'
}

dependencies {
    implementation project(':kspannotation')
    ksp project(':kspprocessor')
}
</code></pre>

<p>如果项目顶层指定了plugin的版本，那么到了module这里，就不必再指定版本了。另外就是要注意版本的匹配，ksp的版本前半段『1.9.23』指明 的是最低的Kotlin版本要求。最好是让ksp要求的版本与指定的Kotlin版本匹配或者差距较小，否则可能会有问题。dependencies中的ksp指定的是KSP processor，对于有些库可能注解和定义和KSP的processor可能会在同一个包里，那么写一句就够了，如Room的，就一句：ksp &lsquo;androidx.room:room-compiler:2.6.1&#8217;。</p>

<p>如果是自定义的processor，需要为processor单独建一个library module，配置ksp库为依赖即可：</p>

<pre><code class="Groovy">// KSP processor module build.gradle
plugins {
    id 'org.jetbrains.kotlin.jvm'
}

dependencies {
    implementation project(':kspannotation')

    implementation 'com.google.devtools.ksp:symbol-processing-api:1.9.23-1.0.20'
    implementation 'com.squareup:kotlinpoet-ksp:1.16.0'
}
</code></pre>

<p>典型的KSP procesor（包括网上大部分的例子）都是分了三个module，一个是定义注解的module，一个是实现processor的，一个是使用注解和processor的。但这并不是必须的，为了方便，其实把注解的定义和processor放在一个module就可以了。只要把processor与使用它的module分开来了，就可以。</p>

<p><strong>注意：</strong>对于processor module来说它的类型要是library，并且要是Java library或者Kotlin library，因为这是Kotlin语言层面的东西。对于Android同学来说在新建module时一定要选择『Java or Kotlin Library』。</p>

<h2>实现KSP Processor</h2>

<p>配置好了模块后，剩下的就是要实现一个KSP processor了。</p>

<h3>实现Processor</h3>

<p>大部分工作plugin已经做好了，我们需要做的就是实现一些接口。有两个需要实现，一个是<a href="https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/processing/SymbolProcessorProvider.kt">SymbolProcessorProvider</a>，另一个则是<a href="https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/processing/SymbolProcessor.kt">SymbolProcessor</a>。</p>

<p>SymbolProcessorProvider相当于是processor的一个工厂方法，我们实现它的create方法，返回一个SymbolProcessor实例，一个典型的实现：</p>

<pre><code class="Kotlin">class MyProcessorProvider : SymbolProcessorProvider {
    override fun create(environment: SymbolProcessorEnvironment): SymbolProcessor {
        return MyProcessor(environment.codeGenerator)
    }
}
</code></pre>

<p>它就相当于一个工厂方法，把上下文环境传给processor，SymbolProcessor是重点，我们需要实现它的process方法，针对感兴趣的符号进行处理，比如用<a href="https://square.github.io/kotlinpoet/">KotlinPoet</a>生成代码，这里是发挥创造力的地方：</p>

<pre><code class="Kotlin">class MyProcessor(private val generator: CodeGenerator) : SymbolProcessor {
    override fun process(resolver: Resolver): List&lt;KSAnnotated&gt; {
        val annotatedClasses = resolver
            .getSymbolsWithAnnotation(MyAnnotation::class.java.name)
            .filterIsInstance&lt;KSClassDeclaration&gt;()

        for (aclass in annotatedClasses) {
            val packageName = aclass.packageName.asString()
            val className = aclass.simpleName.asString()
            val methods = aclass.getDeclaredFunctions())
            // ...
         }
        return emptyList()
    }
}
</code></pre>

<h3>注册Processor</h3>

<p>实现了process后还需要把process注册一下，否则ksp plugin无法找到这个processor。在processor module与代码同级文件夹下新建文件『resources/META-INF/services/com.google.devtools.ksp.processing.SymbolProcessorProvider』，然后把刚才实现的provider的完整类名，写在文件里，如果是使用IDE一般都会有提示的。</p>

<pre><code class="Kotlin">// myprocessor/src/main/
//    |-- kotlin/net/toughcoder/
//              |-- MyProcessorProvider.kt
//              |-- MyProcessor.kt
//    |-- resources/META-INF/services/
//              |-- com.google.devtools.ksp.processing.SymbolProcessorProvider
// file: resources/META-INF/services/com.google.devtools.ksp.processing.SymbolProcessorProvider
net.toughcoder.MyProcessorProvider
</code></pre>

<h2>为啥要用KSP</h2>

<p>目前来说KSP最主要应用仍然 是注解的处理，以及配合注解进行代码生成。通过前面一篇<a href="https://juejin.cn/post/7355024828262334501">关于注解的文章</a>中我们知道，注解的处理已经有了一个专门的工具了叫做kapt，就目前来说KSP能做的事情kapt也都能做，它们都是用于编译时代码处理以及代码生成，都能处理注解。那么，在已经有了kapt的前提下，为啥还要搞KSP呢？</p>

<p>kapt虽然是Kotlin的注解处理器，但是它保持Java的兼容性，它直接复用了Java的<a href="https://docs.oracle.com/javase/8/docs/api/javax/annotation/processing/AbstractProcessor.html">AbstractProcessor</a>，要依赖于Java的annotation procssor以及javac，只适用于Kotlin/JVM，其他target用不起来，因此它并不能算是Kotlin原生的工具，对Kotlin的特性支持不友好。再有就是，为了保持与javac的兼容性，它的处理速度很慢，必须先把Kotlin代码转成javac能认识的标准Java代码，这肯定会有不必要的性能开销。基于这些限制，kapt已经停止开发了，处于维护状态了，不会再添加新功能了。<strong>省流点来说，kapt是以Java角度来看待输入代码的（即也要处理的源码），而KSP是以Kotlin角度</strong>。</p>

<p>KSP则是Kotlin原生的，基于Kotlin开发的，且是为了Kotlin开发的，并不受限于javac，因此所有的Kotlin目标平台都能用。并且对Kotlin的特性支持的很友好。它的处理速度也较kapt有提升，因为不必要做编码转换了，省了一道工序。从官方给出的数据看至少能省25%的编译时间。另外，KSP的API使用起来更加的Kotlin友好一些SymbolProcessor传递过来的<a href="https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/processing/Resolver.kt">Resolver</a>有很方便的接口可以取得被标的类，而且符号对象是<a href="https://github.com/google/ksp/blob/main/api/src/main/kotlin/com/google/devtools/ksp/symbol/KSClassDeclaration.kt">KSClassDeclaration</a>，它可以方便的取一个Kotlin类的相关的其他符号，如包名，类名，方法等。</p>

<h2>总结</h2>

<p>通过本文我们理解了KSP的概念，并学会了如何在项目中配置KSP， 以及如何实现一个KSP processor。KSP视Kotlin代码为一系列的静态符号，对Kotlin语言特性支持友好，处于活跃的开发状态且被官方大力支持，因此应该尽早转向KSP。并且相信KSP能做的事情会越来越多。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/ksp-overview.html">Kotlin Symbol Processing API</a></li>
<li><a href="https://developer.android.com/build/migrate-to-ksp">Migrate from kapt to KSP</a></li>
<li><a href="https://www.kodeco.com/33148161-write-a-symbol-processor-with-kotlin-symbol-processing">Write a Symbol Processor with Kotlin Symbol Processing</a></li>
<li><a href="https://www.codecentric.de/wissens-hub/blog/kotlin-symbol-processing-introduction">An Introduction to Kotlin Symbol Processing</a></li>
<li><a href="https://kt.academy/article/ak-ksp">Kotlin Symbol Processing</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin Annotation Made Easy]]></title>
    <link href="https://alexhilton.github.io/blog/2024/04/09/kotlin-annotation-made-easy/"/>
    <updated>2024-04-09T22:14:10+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/04/09/kotlin-annotation-made-easy</id>
    <content type="html"><![CDATA[<p>注解（Annotations）允许我们在代码中添加元数据（Meta data），提供代码以外的信息，这些元数据可以在编译时被编译器或其他工具读取和处理。 Kotlin作为一种功能强大且易于使用的多范式通用编程语言，注解（Annotations）是其核心特性之一。在Kotlin中，注解的使用非常广泛，可以用于框架设计、代码生成、测试、依赖注入等多个方面。今天就来学习一下Kotlin中注解的使用方法。</p>

<p><a href=""><img src="https://appmaster.dev/wp-content/uploads/2023/03/Understan-Kotlin-Annotations-1024x536.jpg" title="auto auto" ></a></p>

<!-- more -->


<p>Kotlin是基于JVM的编程语言，并且可以与Java互通使用，因此事先了解一下Java的注解对于学习Kotlin的注解是非常有帮助的。可以阅读一下前面的文章来<a href="https://juejin.cn/post/7353138889458319412">回顾Java语言的注解</a>。</p>

<h2>什么是注解</h2>

<p>注解是元编程的一种实现方式，它并不直接改变代码，而是为代码提供额外的数据。注解不能单独存在，必须与代码中的其他元素一起使用。在Kotlin中，注解要使用符号『@』后面加一个已定义的注解名字，如『@Deprecated』。注解在Kotlin中的使用非常广泛的，相信有过代码经验的同学都至少看过大量的注解。</p>

<h2>注解的使用方法</h2>

<p>注解的使用是非常的直观的，在需要的代码元素（类，变量，属性，函数，参数等等）加上想要使用的注解就可以了：</p>

<pre><code class="Kotlin">@Fancy class Foo {
    @Fancy fun baz(@Fancy foo: Int): Int {
        return (@Fancy 1)
    }
}
</code></pre>

<p>Kotlin的注解也可以用在lambda上面，这实际上相当于应用于lambda函数生成的函数实例的invoke()上面：</p>

<pre><code class="Kotlin">annotation class Suspendable

val f = @Suspendable { Fiber.sleep(10) }
</code></pre>

<h3>注解的使用点目标</h3>

<p>由于Kotlin最终要编译成为字节码，运行在JVM上，所以它必须符合Java的规范。但语法上Kotlin与Java还是不一样的，比如一句Kotlin代码可能会相当于Java的好几句，换句话说一个Kotlin语句中的元素可能会对应着Java中的好几个。这可能会带来问题。</p>

<p>注解并不能单独出现，它必须作用到某一个语法上的元素，因为Kotlin语法元素可能会对应着几个Java语法元素，那么注解可能会被用在多个目标元素上面。为了能精确的指定注解的作用目标，可以使用『使用点目标』（use-site targets）来标记具体的目标元素：</p>

<pre><code class="Kotlin">class Example(@field:Ann val foo,    // annotate Java field
              @get:Ann val bar,      // annotate Java getter
              @param:Ann val quux)   // annotate Java constructor parameter
</code></pre>

<p>这里面『Ann』是一个注解，其前面的『field/get/param』就用以指定具体的注解目标元素。可用的使用点目标有这些：</p>

<ul>
<li>file</li>
<li>property</li>
<li>field</li>
<li>get 属性的getter</li>
<li>set 属性的setter</li>
<li>receiver 扩展函数或者扩展属性的底层对象</li>
<li>param 构造函数的参数</li>
<li>setparam 属性setter的参数</li>
<li>delegate 指存储着受托对象实例的域成员</li>
</ul>


<p>『receiver』指的是扩展函数发生作用的实例，比如说：</p>

<pre><code class="Kotlin">fun @receiver:Fancy String.myExtension() { ... }
</code></pre>

<p>那么，这个注解『Fancy』将作用于具体调用这个扩展方法myExtension的String实例上面。</p>

<p>这些具体的使用点目标可以精确的指定JVM认识的元素上面，可以发现，它们远比定义注解时的<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/">@Target</a>要丰富。如果不指定具体的使用点目标，那么就会按照@Target指定的目标，如果有多个目标，会按如下顺序选择：</p>

<ul>
<li>param</li>
<li>property</li>
<li>field</li>
</ul>


<h3>兼容Java注解</h3>

<p>Kotlin是完全兼容Java注解，也就是说Java中定义的注解，在Kotlin中都可以直接使用。</p>

<pre><code class="Java">// Java
public @interface Ann {
    int intValue();
    String stringValue();
}
</code></pre>

<pre><code class="Kotlin">// Kotlin
@Ann(intValue = 1, stringValue = "abc") class C
</code></pre>

<p>虽然可以直接用，但毕竟Kotlin的语法要丰富得多，所以为了避免歧义，要使用前面介绍的使用点目标来精确指定注解的作用目标。</p>

<h2>自定义注解</h2>

<p>使用关键字『annotation』来声明自定义注解，如：</p>

<pre><code class="Kotlin">annotation class Fancy
</code></pre>

<p>之后就可以使用注解了：</p>

<pre><code class="Kotlin">@Fancy class Foo {
    @Fancy fun baz(@Fancy foo: Int): Int {
        return (@Fancy 1)
    }
}
</code></pre>

<p>光这样声明还不够，还需要定义注解具体的内容，如可修饰的目标和行为特点，这就需要用到元注解（Meta annotations），也即定义注解时所需要的注解。</p>

<h3>元注解（Meta annotations）</h3>

<h4>@MustBeDocumented</h4>

<p>用于指定此注解是公开API的一部分，必须包含在文档中。</p>

<h4>@Repeatable</h4>

<p>允许在同一个地方多次使用注解。</p>

<h4><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-target/">@Target</a></h4>

<p>用于指定此注解可以应用到哪些程序元素上面，如类和接口，函数，属性和表达式。</p>

<ul>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-c-l-a-s-s.html#kotlin.annotation.AnnotationTarget.CLASS">AnnotationTarget.CLASS</a> - 类型，包括类型原型（classes），接口，对象，注解类型</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-p-r-o-p-e-r-t-y.html#kotlin.annotation.AnnotationTarget.PROPERTY">AnnotationTarget.PROPERTY</a> - 属性</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-f-i-e-l-d.html#kotlin.annotation.AnnotationTarget.FIELD">AnnotationTarget.FIELD</a> - 域变量</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-l-o-c-a-l_-v-a-r-i-a-b-l-e.html#kotlin.annotation.AnnotationTarget.LOCAL_VARIABLE">AnnotationTarget.LOCAL_VARIABLE</a> - 局部变量（本地变量）</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-v-a-l-u-e_-p-a-r-a-m-e-t-e-r.html#kotlin.annotation.AnnotationTarget.VALUE_PARAMETER">AnnotationTarget.VALUE_PARAMETER</a> - 参数</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-c-o-n-s-t-r-u-c-t-o-r.html#kotlin.annotation.AnnotationTarget.CONSTRUCTOR">AnnotationTarget.CONSTRUCTOR</a> - 构造函数</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-f-u-n-c-t-i-o-n.html#kotlin.annotation.AnnotationTarget.FUNCTION">AnnotationTarget.FUNCTION</a> - 函数</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-p-r-o-p-e-r-t-y_-g-e-t-t-e-r.html#kotlin.annotation.AnnotationTarget.PROPERTY_GETTER">AnnotationTarget.PROPERTY_GETTER</a> - 属性的getter</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-target/-p-r-o-p-e-r-t-y_-s-e-t-t-e-r.html#kotlin.annotation.AnnotationTarget.PROPERTY_SETTER">AnnotationTarget.PROPERTY_SETTER</a> - 属性的setter</li>
</ul>


<h4>@Retention</h4>

<p>指定注解信息保存到代码生命周期的哪一阶段，编译前，编译时还是运行时。默认值是运行时，也即在运行时注解是可见的。</p>

<ul>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-retention/-s-o-u-r-c-e.html">AnnotationRetention.SOURCE</a> - 只在源码过程中保留，并不会出现在编译后的class中（二进制文件中）。</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-retention/-b-i-n-a-r-y.html">AnnotationRetention.BINARY</a> - 会在class中保留，但对于运行时并不可见，也就是通过反射无法得到注解。</li>
<li><a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.annotation/-annotation-retention/-r-u-n-t-i-m-e.html">AnnotationRetention.RUNTIME</a> - 注解会保留到运行时，运行时的操作如反射可以解析注解，这是默认的@Rentention值。</li>
</ul>


<h3>构造方法（Constructors）</h3>

<p>与Java很不同的是Kotlin的注解更加的像常规的类（class），注解也可以有构造函数：</p>

<pre><code class="Kotlin">annotation class Special(val why: String)

@Special("example") class Foo {}
</code></pre>

<p>构造函数可以使用的参数包括：</p>

<ul>
<li>基础数据类型Int，Long，Float和String等</li>
<li>类型原型（即class，如Foo::class）</li>
<li>枚举类型</li>
<li>其他注解类型</li>
<li>由以上类型组成的数组</li>
</ul>


<p>注意不能有可能为空（如String?）的类型，当然也不可以传递null给注解的构造函数。还有，如果用其他注解作为参数时，注解名字前就不用再加『@』了：</p>

<pre><code class="Kotlin">annotation class ReplaceWith(val expression: String)

annotation class Deprecated(
        val message: String,
        val replaceWith: ReplaceWith = ReplaceWith(""))
</code></pre>

<h3>注解的实例化（Instantiation）</h3>

<p>在Kotlin中可以通过调用注解的构造函数来实例化一个注解来使用。而不必非要像Java那样用反射接口去获取。</p>

<pre><code class="Kotlin">annotation class InfoMarker(val info: String)

fun processInfo(marker: InfoMarker): Unit = TODO()

fun main(args: Array&lt;String&gt;) {
    if (args.isNotEmpty())
        processInfo(getAnnotationReflective(args))
    else
        processInfo(InfoMarker("default"))
}
</code></pre>

<h2>注解解析</h2>

<p>Kotlin是基于JVM的编程语言，最终要编译成为字节码运行在JVM上面，所以注解的解析与Java语言注解解析是一样的，可以在运行时用反射API来解析注解。关于Java注解解析可以<a href="/blog/2024/03/24/java-annotations-made-easy/">参考另一篇文章</a>，因为运行时注解解析用处并不大，并且也不复杂，看一个简单&#127792;就可以了：</p>

<pre><code class="Kotlin">class Item(
  @Positive val amount: Float, 
  @AllowedNames(["Alice", "Bob"]) val name: String)

val fields = item::class.java.declaredFields
for (field in fields) {
    for (annotation in field.annotations) {
        if (field.isAnnotationPresent(AllowedNames::class.java)) {
            val allowedNames = field.getAnnotation(AllowedNames::class.java)?.names
         }
    }
}
</code></pre>

<h2>注解处理器</h2>

<p>注解是元编程的一种方式，它最大的威力是在编译前进行代码处理和代码生成。除了注解的定义和使用外，更为关键的注解的处理需要用到注解处理器（Annotation Processor），并且要配合编译器插件<a href="https://kotlinlang.org/docs/kapt.html">kapt</a>和<a href="https://kotlinlang.org/docs/ksp-overview.html">KSP</a>来使用。</p>

<p>需要注意，因为注解是JVM支持的特性，在编译时需要借助javac编译器，所以只有运行目标是JVM时注解才有效。因为Kotlin是支持编译为不同运行目标的，除了JVM外，还有JavaScript和Native。</p>

<h3>实现注解处理器</h3>

<p>与Java的注解处理器类似，在定义好注解后，还需要实现一个注解处理器，以对注解进行处理。一般情况下实现AbstractProcessor就可以了。在其process方法中过滤出来想要处理的注解进行处理，比如使用<a href="https://github.com/square/kotlinpoet">KotlinPoet</a>生成代码。</p>

<p>另外，还要注意，注解处理器必须在一个单独的module中，然后添加为使用此注解module的依赖，这是因为注解的处理是在编译前，所以处理器需要在正式编译前就已经编译好。</p>

<pre><code class="kotlin">package net.toughcoder

import javax.annotation.processing.*
import javax.lang.model.element.*
import javax.tools.Diagnostic

@SupportedAnnotationTypes("com.example.MyAnnotation")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
class MyAnnotationProcessor : AbstractProcessor() {

    override fun process(annotations: MutableSet&lt;out TypeElement&gt;, roundEnv: RoundEnvironment): Boolean {
        for (annotation : annotations) {
            for (element : roundEnv.getElementsAnnotatedWith(annotation)) {
                val myAnnotation = element.getAnnotation(MyAnnotation::class.java)
                val message = "Processing element with annotation MyAnnotation(value = ${myAnnotation.value})"
                processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, message, element)
            }
        }
        return true
    }
}
</code></pre>

<p>从例子中可以看到，其实Kotlin中的注解处理器（Processor）直接就是用的Java的，所以在用的时候最好加上Java语言的版本。</p>

<h3>注册注解处理器</h3>

<p>为能正常使用注解处理器，需要把注解处理器放在一个单独的Module里，并作为其他module的依赖，这样能确保它在编译被依赖项时正常使用，被依赖项也即注解使用的地方。</p>

<p>需要在处理器module中与代码平级的文件夹创建resources文件夹，创建一个子文件夹META-INF，再在META-INF创建一个子文件services，在里面创建一个文件名为『javax.annotation.processing.Processor』，然后把实现的注解处理器的完整类名，写在这个文件的第一行：</p>

<pre><code class="Kotlin">// file: resources/META-INF/services/javax.annotation.processing.Processor
net.toughcoder.MyAnnotationProcessor
</code></pre>

<h3>使用注解处理器</h3>

<p><img src="https://bigknol.com/wp-content/uploads/2023/07/android-ksp-kapt-768x439.png" alt="" /></p>

<p>需要做两个事情，一个是把注解处理器添加为其他项目或者module的依赖。然后再用<a href="https://kotlinlang.org/docs/kapt.html">专门处理注解处理器的编译器插件</a>使用注解处理器。</p>

<pre><code class="Groovy">dependencies {
    implementation(kotlin('stdlib'))
    kapt 'net.toughcoder:my-annotation-processor:1.0.0'
}

kapt {
    useBuildCache = true
    annotationProcessors = ['net.toughcoder:my-annotation-processor:1.0.0']
}
</code></pre>

<h2>总结</h2>

<p>本文介绍了Kotlin中注解的基本语法、使用方法和处理过程。通过自定义注解处理器，我们可以在编译时处理注解并生成相应的代码或执行其他任务。注解是Kotlin编程中的核心特性，它可以帮助我们提高代码的可读性、可维护性和可扩展性。大部分的注解都在编译时，也不会对性能产生影响，所以可以放心大胆的用注解来提升开发效率。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/annotations.html">Annotations</a></li>
<li><a href="https://www.baeldung.com/kotlin/annotations">Kotlin Annotations</a></li>
<li><a href="https://kt.academy/article/ak-annotation-processing">Annotation Processing</a></li>
<li><a href="https://www.kodeco.com/8574679-annotation-processing-supercharge-your-development">Annotation Processing: Supercharge Your Development</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Deep Dive Into Kotlin Generics Runtime]]></title>
    <link href="https://alexhilton.github.io/blog/2024/03/16/deep-dive-into-kotlin-generics-runtime/"/>
    <updated>2024-03-16T19:16:00+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/03/16/deep-dive-into-kotlin-generics-runtime</id>
    <content type="html"><![CDATA[<p>通过前面的学习，对Kotlin的泛型已经有了比较全面的了解了，泛型的目的是让通用的代码更加的类型安全。现在我们离写出类型安全的泛型代码还差最后一块拼图，那就是泛型的类型擦除，今天就来深入地学习一下运行时的泛型，彻底的弄懂类型擦除的前因后果，并学会如何在运行时做类型检查和类型转换，以期完成拼图掌握泛型，写出类型安全的通用代码。</p>

<p><a href=""><img src="https://global-uploads.webflow.com/618fa90c201104b94458e1fb/61978c1b9e0bf52082dabe92_Kotlin-Generics.png" title="auto auto" ></a></p>

<!-- more -->


<p>关于泛型话题的一系列文章：</p>

<ul>
<li><a href="/blog/2024/03/04/kotlin-generics-made-easy/">这回就好好聊聊Kotlin的泛型</a></li>
<li><a href="/blog/2024/03/10/java-generics-made-easy/">深入浅出Java泛型</a></li>
<li><a href="/blog/2024/03/13/kotlin-generics-revisited/">Kotlin Generics Revisited</a></li>
<li><a href="">Dive deep into Kotlin type erasure</a></li>
</ul>


<h2>泛型类型擦除（Type erasure）</h2>

<p>泛型的类型安全性（包括类型检查type check，和类型转换type casting）都是由编译器在编译时做的，为了保持在JVM上的兼容性，编译器在保障完类型安全性后会对泛型类型进行<a href="https://en.wikipedia.org/wiki/Type_erasure">擦除（Type erasure）</a>。在运行时泛型类型的实例并不包含其类型信息，也就是说它不知道具体的类型参数，比如Foo&lt;Bar&gt;和Foo&lt;Baz?&gt;都被擦除成了Foo&lt;&#42;&gt;，在虚拟机（JVM）来看，它们的类型是一样的。</p>

<p>因为泛型Foo&lt;T&gt;的类型参数T会<strong>被擦除（erased）</strong>，所以与类型参数相关的类型操作（类型检查is T和类型转换as T）都是不允许的。</p>

<h2>可行的类型检查和转换</h2>

<p>虽然类型参数会被擦除，但并不是说对泛型完全不能进行类型操作。</p>

<h3>星号类型操作</h3>

<p>因为所有泛型会被擦除成为星号无界通配Foo&lt;&#42;&gt;，它相当于Foo&lt;Any?&gt;，是所有Foo泛型的基类，类型参数Any?是根基类，所以可以进行类型检查和类型转换：</p>

<pre><code class="Kotlin">if (something is List&lt;*&gt;) {
    something.forEach { println(it) } // 元素被视为Any?类型
}
</code></pre>

<p>针对星号通配做类型操作，类型参数会被视为Any?。但其实这种类型操作没有任何意义，毕竟Any是根基类，任何类当成Any都是没有问题的。</p>

<h3>完全已知具体的类型参数时</h3>

<p>另外一种情况就是，整个方法的上下文中已经完全知道了具体的类型参数时，不涉及泛型类型时，也是可以进行类型操作的，说的比较绕，我们来看一个&#127792;：</p>

<pre><code class="Kotlin">fun handleStrings(list: MutableList&lt;String) {
    if (list is ArrayList) {
        // list is smart-cast to ArrayList&lt;String&gt;
    }
}
</code></pre>

<p>这个方法并不涉及泛型类型，已经知道了具体的类型参数是String，所以类型操作也是可行的，因为编译器知道具体的类型，能对类型进行检查 保证是类型安全的。并且因为具体类型参数String可以推断出来，所以&lt;String&gt;是可以省略的。</p>

<h2>未检查的转换</h2>

<p>当编译器能推断出具体的类型时，进行类型转换就是安全的，这就是被检查的转型（checked cast），如上面的&#127792;。</p>

<p>如果无法推断出类型时，比如涉及泛型类型T时，因为类型会被擦除，编译器不知道具体的类型，这时as T或者as List&lt;T&gt;都是不安全的，编译器会报错，这就是未检查转型（unchecked cast）。</p>

<p>但如果能确信是类型转换是安全的，可以用注解&#64;Suppress(&ldquo;UNCHECKED_CAST&rdquo;)来忽略。</p>

<h2>用关键reified修饰inline泛型函数</h2>

<p><img src="https://tse3-mm.cn.bing.net/th/id/OIP-C.Y0Gq_pPe6TUb1g0oEN_51wHaEb?rs=1&amp;pid=ImgDetMain" alt="" /></p>

<p>要想能够对泛型类型参数T做类型操作，只能是在用关键字reified修饰了的inline泛型函数，在这种函数体内可以对泛型类型参数T做类型操作，&#127792;如：</p>

<pre><code class="Kotlin">inline fun &lt;reified A, reified B&gt; Pair&lt;*, *&gt;.asPairOf(): Pair&lt;A, B&gt;? {
    if (first !is A || second !is B) return null
    return first as A to second as B
}

val somePair: Pair&lt;Any?, Any?&gt; = "items" to listOf(1, 2, 3)


val stringToSomething = somePair.asPairOf&lt;String, Any&gt;()
val stringToInt = somePair.asPairOf&lt;String, Int&gt;()
</code></pre>

<p>需要注意的是关键字reified能够让针对类型参数T的操作得到编译器的检查，保证安全，是允许的。但是对于泛型仍是不允许的，&#127792;如：</p>

<pre><code class="Kotlin">inline fun &lt;reified T&gt; List&lt;*&gt;.asListOfType(): List&lt;T&gt;? =
    if (all { it is T })
        @Suppress("UNCHECKED_CAST")
        this as List&lt;T&gt; else
        null
</code></pre>

<p>这个inline泛型函数用关键字reified修饰了，因此针对类型参数T是允许类型检查类型转换，如第2行是允许的。但泛型仍是不合法，如第4行，这时可以用上一小节提到的注解&#64;Suppress(&ldquo;UNCHECKED_CAST&rdquo;)来忽略未检查类型转换。</p>

<h2>inline和reified的原理</h2>

<p>对于一些泛型工厂方法，就非常适合使用inline和reified，以保证转换为类型参数（因为工厂方法最终肯定要as T）是允许的且是安全的：</p>

<pre><code class="Kotlin">inline fun &lt;reified T&gt; logger(): Logger = LoggerFactory.getLogger(T::class.java)

class User {
    private val log = logger&lt;User&gt;()
    // ...
}
</code></pre>

<p>关键字reified其实也没有什么神秘的，因为这是inline函数，这种函数是会把函数体嵌入到任何调用它的地方（call site），而每个调用泛型函数的地方必然会有明确的具体类型参数，那么编译器就知道了具体的类型能保证类型安全（checked cast）。上面的工厂方法在调用时就会大概变成酱紫：</p>

<pre><code class="Kotlin">class User {
    private val log = LoggerFactory.getLogger(User.class.java)
}
</code></pre>

<p>这时其实在函数体内已经知道了具体的类型参数User，编译器能够进行类型检查，所以是安全的。</p>

<h2>总结</h2>

<p>本文深入的讨论一下运行时泛型的一些特性，泛型类型在运行时会被擦除，无法做泛型相关的类型操作，因为编译器无法保证其类型安全。例外就是在用reified修饰的inline函数中可以对类型参数T做类型操作，但泛型类型（带尖括号的&lt;T&gt;）仍是会被擦除，可以用注解&#64;Suppress(&ldquo;UNCHECKED_CAST&rdquo;)来忽略unchecked cast。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/generics.html#type-erasure">Type erasure</a></li>
<li><a href="https://www.baeldung.com/kotlin/generics#generics-at-runtime">6. Generics at Runtime</a></li>
<li><a href="https://www.baeldung.com/kotlin/type-erased-list-array-conversion">How to Convert a Type-Erased List to an Array in Kotlin</a></li>
<li><a href="https://discuss.kotlinlang.org/t/type-erasure/14519">Discussion about Type Erasure</a></li>
<li><a href="https://stackoverflow.com/questions/42916801/how-does-erasure-work-in-kotlin">How does erasure work in Kotlin?</a></li>
<li><a href="https://workingdev.net/2018/09/reified-generics-in-kotlin.html">Reified Generics in Kotlin</a></li>
<li><a href="https://duongnt.com/type-erasure-reified/">Type erasure and reified in Kotlin</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Kotlin Generics Revisited]]></title>
    <link href="https://alexhilton.github.io/blog/2024/03/13/kotlin-generics-revisited/"/>
    <updated>2024-03-13T22:33:20+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/03/13/kotlin-generics-revisited</id>
    <content type="html"><![CDATA[<p>在前面的文章中学习Kotlin泛型的基本知识，并且又用了一篇文章来复习了一下Java语言的泛型，有了这些基础我们就可以继续深入的学习Kotlin的泛型了。看它是如何解决Java泛型的遗留问题，再学习一下它的高级特性，最后再总结泛型的最佳实践。</p>

<p><a href=""><img src="https://koenig-media.raywenderlich.com/uploads/2019/09/Generics-feature.png" width="480" height="480"></a></p>

<!-- more -->


<p>本文是作为前面文章的延续和深化，为了更好的阅读效果，建议先回顾一下<a href="/blog/2024/03/10/java-generics-made-easy/">Java泛型基础</a>，和<a href="/blog/2024/03/04/kotlin-generics-made-easy/">Kotlin泛型基础</a>。</p>

<h2>泛型类型参数界限（Upper bounds）</h2>

<p>我们在前面讲解<a href="/blog/2024/03/10/java-generics-made-easy/">Java泛型基础</a>时提到了在声明泛型的时候是可以指定类型参数的界限的，比如用Caculator&lt;T extends Number&gt;可以指定在使用时可以传入的类型参数要是Number或者Number的子类。</p>

<p>在Kotlin中也是可以指定泛型类型参数的界限的，也是用<strong>继承符号:来表示</strong>，&#127792;如：</p>

<pre><code class="Kotlin">class Calculator&lt;T : Number&gt; { ... }
</code></pre>

<p>与Java一样，也可以指定多个界限，要<strong>使用where关键字</strong>：</p>

<pre><code class="Kotlin">class Calculator&lt;T&gt; where T : Number, T : Runnable, T : Closable { ... }

fun &lt;T&gt; copyWhenGreater(list: List&lt;T&gt;, threshold: T): List&lt;String&gt;
    where T : CharSequence,
          T : Comparable&lt;T&gt; {
    return list.filter { it &gt; threshold }.map { it.toString() }
}
</code></pre>

<p>注意：面向对象的继承体系是基类在上面，子类在下面，所以上界的意思是以某个类A为根的继承树，这颗树都可以当成A来使用；下界的意思是从根A到以某个类C为止的一个路径，这个路径上都是C的基类，C都可以当成它们来用。</p>

<p><img src="https://media.geeksforgeeks.org/wp-content/cdn-uploads/20221025185149/Hierarchical-Inheritance-in-Java.jpg" alt="" /></p>

<h2>更优雅的泛型变化(Variance)</h2>

<p>与Java一样，Kotlin的泛型也是不可变的Invariant，比如虽然String是Any的子类，但List&lt;String&gt;并不是List&lt;Any&gt;的子类。泛型变化Variance的目的就是让两个泛型产生与类型参数协同的变化，比如类型C是类A的子类，那么使用它的泛型&lt;C&gt;也应该是&lt;A&gt;的子类，能使用&lt;A&gt;的方，传入&lt;C&gt;一定要是允许的，并要能够是安全的。</p>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.HRZ3CHxJfgk_hG9T11siDQHaD4?rs=1&amp;pid=ImgDetMain" alt="" /></p>

<h3>使用点变化（Use-site variance）</h3>

<p>基于面向对象的基本特性，只有向上转型(Upcasting)是安全的。具体就分为两种场景，从一个生产者中读取对象时，只要生产者的输出声明的T是基类（T是一个上限），无论生产者输出的是T还是它的子类，对于使用者来说（当T来用）就是安全的。这时生产者的泛型要能够进行协变，在Java中用上界界限通配符&lt;? extends T&gt;来进行协变，具体使用时传入T的子类的泛型也是合法的；同理，向一个消费者中写数据时，消费者声明为T的某个基类（这时T是一个下限），向其传入T，对于使用者来说就是安全的。这时消费者的泛型要能进行逆变，在Java中使用下界界限通配符&lt;? super T&gt;来进行逆变，具体使用时传T的基类的泛型也是合法的。</p>

<p>Kotlin中提供了非常容易理解和使用的<strong>关键字out来进行协变（covariance）和in进行逆变（contravariance）</strong>，可以实现Java中的界限通配符一样的功效。Java界限通配符的规则是<strong>PECS（Producer Extends Consumer Super）</strong>，out正好可以更形象的描述一个生产者，而in可以更形象的描述一个消费者，所以Kotlin的关键字更容易理解和记忆。</p>

<pre><code class="Kotlin">open class Animal
class Dog : Animal()

class MyList&lt;E&gt; {
    fun addAll(from: MyList&lt;out E&gt;) {}
    fun getAll(to: MyList&lt;in E&gt;) {}
}

fun main() {
    val animals = MyList&lt;Animal&gt;()
    val dogs = MyList&lt;Dog&gt;()

    animals.addAll(dogs)
    dogs.getAll(animals)
}
</code></pre>

<p>这种泛型变化是发生在调用者调用时，因此也叫做『使用点变化』(Use-site variance)。在Kotlin中也被称作<strong>类型映射</strong>，因为相当于是用&lt;out T&gt;把T给映射成了一个T的生产者，只能调用其get方法；用&lt;in T&gt;映射成一个T的消费者，只能调用set方法。并且呢，对于同一个函数中既有生产者和消费者时，in和out只写一个就行了，&#127792;如：</p>

<pre><code class="Kotlin">fun copy(from: Array&lt;out Any&gt;, to: Array&lt;Any&gt;) { ... }
</code></pre>

<h3>声明点变化（Declaration-site variance）</h3>

<p>Java界限通配符的一个大问题是只能用于方法的参数但不能是返回值，也就是只能是『Use-site variance』。但in和out没有这个限制，因此它们可以用于返回值。只要给类和接口的泛型声明为out或者in就能让类型参数在其所有的方法产生variance，这就是『declaration-site variance』。</p>

<p>但是要遵守out进行协变，也就是<strong>说out是用于生产者</strong>的，只能作为方法的返回值，或者保证不能set，&#127792;如：</p>

<pre><code class="Kotlin">interface Source&lt;out T&gt; {
    fun nextT(): T
}

fun demo(strs: Source&lt;String&gt;) {
    val objects: Source&lt;Any&gt; = strs // This is OK, since T is an out-parameter
    // ...
}
</code></pre>

<p>同理，<strong>用in进行逆变，只能用于消费者</strong>，只能作为方法的参数，或者保证不get，&#127792;如：</p>

<pre><code>interface Comparable&lt;in T&gt; {
    operator fun compareTo(other: T): Int
}

fun demo(x: Comparable&lt;Number&gt;) {
    x.compareTo(1.0) // 1.0 has type Double, which is a subtype of Number
    // Thus, you can assign x to a variable of type Comparable&lt;Double&gt;
    val y: Comparable&lt;Double&gt; = x // OK!
}
</code></pre>

<p>小结一下，Kotlin使用关键字in和out让泛型的协变和逆变变得容易理解得多了，因为它们能够非常清楚的表达出消费者和生产者，只需要记住一个泛型的生产者要用out来修饰，而一个泛型的消费者要用in来修饰就不会出错，这比Java中的界限通配符简单太多了。</p>

<h2>星号映射(Star projections)</h2>

<p>除了use-site variance是一种类型映射外，还有星号映射。首先来说<strong>星号是无界泛型</strong>，也就是说不指定具体的类型参数，意思是任意类型的泛型，换句话说Foo&lt;&#42;&gt;是任何其他泛型的基类（Foo&lt;String&gt;, Foo&lt;Number&gt;等）。但根据不同的上下文，Foo&lt;&#42;&gt;会映射为不同的具体意义的泛型类型：</p>

<ul>
<li>对于Foo&lt;out T : TUpper&gt;，这里的T是一个受上界TUpper限制的协变类型参数，那么Foo&lt;&#42;&gt;就等同于Foo&lt;out TUpper&gt;。</li>
<li>对于Foo&lt;in T&gt;，这里T是逆变类型参数，Foo&lt;&#42;&gt;等同于Foo&lt;in Nothing&gt;。这意思是无法向Foo&lt;&#42;&gt;中写。</li>
<li>对于Foot&lt;T : TUpper&gt;，这里T是一个被上界TUpper限定的不可变类型参数，那么Foo&lt;&#42;&gt;，在读时（作为生产者）等同于Foo&lt;out TUpper&gt;，在写时（作为消费者）等同于Foo&lt;in Nothing&gt;。</li>
</ul>


<p>如果泛型是多元的，那么每个类型参数可以进行不同的映射。比如说如果一个类型是这样声明的interface Function&lt;in T, out U&gt;，那么会有这样的映射：</p>

<ul>
<li>Function&lt;&#42;, String&gt; 意思是Function&lt;in Nothing, String&gt;</li>
<li>Function&lt;Int, &#42;&gt; 意思是Function&lt;Int, out Any?&gt;</li>
<li>Function&lt;&#42;, &#42;&gt; 意思是Function&lt;in Nothing, out Any?&gt;</li>
</ul>


<p>换句话来理解，就是当不指定具体的类型参数，用星星就代表着不知道具体的类型参数，那么视具体的上下文不同星号会被解释不同的意思。不过这玩意儿可读性较差，除非必不得已，否则还是能不用就用它。</p>

<p>注意：在Kotlin中，<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/">根基类是Any</a>它是所有其他类的基类（the root of Kotlin class hierarchy）。而<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-nothing.html">Nothing</a>是不能有实例的类，可以用它来表示不存在的对象（a value that never exists）。比如说，如果 一个函数返回值类型声明为Nothing，那它就不会返回（always throws an exception），注意是<strong>不会返回（never returns）</strong>，并不是没有返回值，没有返回值要<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-unit/">声明为类型Unit</a>。</p>

<h2>绝不为空类型（Definitely non-null type）</h2>

<p>为了保持对Java的互通性，Kotlin还支持把泛型类型参数声明为『绝不为空类型』definitely non-null type。可以<strong>用&amp; Any来声明</strong>，如&lt;T &amp; Any&gt;来声明T是『绝不为空类型』。</p>

<p>这是为了保持与Java的相互调用，有些Java的类和接口是用<strong>注解&#64;NonNull修饰的</strong>，如：</p>

<pre><code class="Java">public interface Game&lt;T&gt; {
    public T save(T x) {}
    @NotNull
    public T load(@NotNull T x) {}
}
</code></pre>

<p>这时在Kotlin里面就要用到<strong>『绝不为空类型』&amp; Any来声明泛型</strong>：</p>

<pre><code class="Kotlin">interface ArcadeGame&lt;T1&gt; : Game&lt;T1&gt; {
    override fun save(x: T1): T1
    // T1 is definitely non-nullable
    override fun load(x: T1 &amp; Any): T1 &amp; Any
}
</code></pre>

<p>注意，在纯Kotlin代码中是用不到这个特性的。只有当涉及Java的&#64; NonNull时才需要『绝不为空类型』。</p>

<h2>下划线操作符</h2>

<p>当编译器能推断出泛型的类型参数时是可以省略掉类型参数的，比如val names = listOf(&ldquo;James&rdquo;, &ldquo;Kevin&rdquo;)，这里得到的类型是List&lt;String&gt;，但我们并没有显示的指定类型参数，这是因为编译器从listOf的参数中就能推断出类型参数是String，所以listOf的返回就是List&lt;String&gt;。</p>

<p>但有些时候，泛型类型太复杂了，没有办法推断出所有的类型，比如有多元泛型参数时。但根据指定的某一个参数，可以推断出剩余的参数时，这时就没有办法完全省略类型参数，剩余的参数却又可以推断出来，写了又浪费。这时就可以用下划线操作符来代表那些可以推断出来的参数。这里的下划线用法跟在lambda中，用下划线替代不使用的参数是一样的。</p>

<pre><code class="Kotlin">abstract class SomeClass&lt;T&gt; {
    abstract fun execute() : T
}

class SomeImplementation : SomeClass&lt;String&gt;() {
    override fun execute(): String = "Test"
}

class OtherImplementation : SomeClass&lt;Int&gt;() {
    override fun execute(): Int = 42
}

object Runner {
    inline fun &lt;reified S: SomeClass&lt;T&gt;, T&gt; run() : T {
        return S::class.java.getDeclaredConstructor().newInstance().execute()
    }
}

fun main() {
    // T is inferred as String because SomeImplementation derives from SomeClass&lt;String&gt;
    val s = Runner.run&lt;SomeImplementation, _&gt;()
    assert(s == "Test")

    // T is inferred as Int because OtherImplementation derives from SomeClass&lt;Int&gt;
    val n = Runner.run&lt;OtherImplementation, _&gt;()
    assert(n == 42)
}
</code></pre>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/generics.html">Generics: in, out, where</a></li>
<li><a href="https://www.gyata.ai/kotlin/kotlin-generics/">Kotlin Generics</a></li>
<li><a href="https://blog.logrocket.com/understanding-kotlin-generics/">Understanding Kotlin generics</a></li>
<li><a href="https://sebhastian.com/kotlin-generics/#google_vignette">Kotlin generics explained with code examples</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/143380842">深入解析Kotlin 泛型</a></li>
<li><a href="https://juejin.cn/post/6959859571242303495">Kotlin（六）深入理解Kotlin泛型</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[这回就好好聊聊Kotlin的泛型]]></title>
    <link href="https://alexhilton.github.io/blog/2024/03/04/kotlin-generics-made-easy/"/>
    <updated>2024-03-04T22:51:58+08:00</updated>
    <id>https://alexhilton.github.io/blog/2024/03/04/kotlin-generics-made-easy</id>
    <content type="html"><![CDATA[<p>泛型(Generics)是静态强类型编程语言中非常强大的特性，可以极大的加强代码的复用，并增强类型安全，减少运行时的类型转换错误。在这篇文章就来详细的学习一下Kotlin中对泛型的支持情况，并学会写出类型安全的可复用代码。</p>

<p><a href=""><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.bl_F0aycuia6QRYMt4AOfQHaFc?rs=1&amp;pid=ImgDetMain" title="auto auto" ></a></p>

<!-- more -->


<h2>泛型基础</h2>

<p>泛型的本质就是能够创建参数化的对象和函数，以实现复用。比如说，我们最熟悉的集合List，它是<strong>与具体类型无关</strong>的数据结构，或者叫做对象容器。列表List的重点在于可扩展长度，但里面具体的对象类型并不是重点，只要是一个对象就可以了。假如没有泛型，可能就要写很多重复的代码，比如字符串列表StringList，数字列表NumberList，等等。用泛型，只<strong>用一个参数化</strong>的List就可以了，用尖括号<strong>&lt;&gt;</strong>来表示参数化。</p>

<pre><code class="Kotlin">val names: List&lt;String&gt; = listOf("James", "Kevin", "Harden")
val rebounds: List&lt;Int&gt; = listOf(2, 14, 7)
</code></pre>

<p>泛型有两种形式，一种是对类进行参数化如List<String>，一种是对函数进行参数化，如max<Int>()。</p>

<h3>参数化的类</h3>

<p>声明方式就是在声明类的时候在类的名字后面用尖括号<strong>&lt;&gt;</strong>来带上一个类型参数，然后在内部就可以当成一个类型来使用：</p>

<pre><code class="Kotlin">class Box&lt;T&gt;(t: T) {
    var value = t
}
</code></pre>

<p>这就创建了一个参数化的容器，它可以持有任何指定类型的对象：</p>

<pre><code class="Kotlin">val box: Box&lt;Int&gt; = Box&lt;Int&gt;(1)
val case: Box&lt;String&gt; = Box&lt;String&gt;("Coat")
</code></pre>

<h3>参数化的函数</h3>

<p>除了参数化的类以外，还可以创建参数化的函数，在函数名字的前面用尖括号<strong>&lt;&gt;</strong>来声明泛型，然后在参数列表以及函数体内就可以当作类型来使用：</p>

<pre><code class="Kotlin">fun &lt;T&gt; singleTonList(item: T): List&lt;T&gt; {
    ...
}
</code></pre>

<p>调用的时候指定一下具体的类型就可以了：</p>

<pre><code class="Kotlin">val l = singletonList&lt;Int&gt;(3)
</code></pre>

<p><strong>注意：</strong>Kotlin语言有强大的类型推断能力，但凡编译器能够推断出类型时，类型的声明都可以省略掉。对于泛型更是如此，比如说，这样写都是合法的：</p>

<pre><code class="Kotlin">val names = listOf("James", "Kevin", "Harden")
val rebounds = listOf(2, 14, 7)
val l = singletonList(3)
</code></pre>

<p>通常情况下，<strong>声明</strong>，<strong>定义</strong>和<strong>赋值</strong>三个地方，只要有一个地方能够让编译器知道具体的类型就够了，其他地方都可以把类型的声明省略掉。</p>

<h2>泛型的本质与优点</h2>

<p>假如不使用泛型，又想写出比较通用的类和函数，唯一可行的方法就是使用通用基类Any当作参数，在Kotlin中Any是所有对象的基类，比如，说想实现一个列表：</p>

<pre><code class="Kotlin">class AnyList {
    fun add(item: Any)
    fun get(idx: Int): Any
}
</code></pre>

<p>这样写可以，但它有很大的问题，就是不能保证类型安全：</p>

<pre><code class="Kotlin">val list = AnyList()
list.add("James")
list.add(13)
val e = (Int) list.get(1)
</code></pre>

<p>一方面我们需要自己进行强行类型转换，但也无法保证你取出来的对象类型与期望的是一致的，更无法保证调用者往里面添加什么对象，因为任何Any的子类都可以让代码通过编译，但在运行时极容易发生类型转换异常ClassCastException。</p>

<p>但用泛型就能很好的解决这个问题，可以得出泛型的优点：</p>

<ol>
<li>不需要做类型转换，编译器会根据指定的具体类型自动做类型转换</li>
<li>类型安全，编译器会帮助做检查，传给泛型的对象必须具有一致的类型，且是指定的类型</li>
<li>保障了运行时的类型安全，因为编译器在编译时做好了检查，所以不会发生运行时的类型错误</li>
</ol>


<p>因此，凡是有需要针对 类型复用的地方，都应该用泛型来实现类型参数化。</p>

<h2>关键字out和关键字in</h2>

<p>大部分情况下，只要给类型和函数加上参数化的类型就够了，但有时候有些复杂情况需要处理。</p>

<h3>协变与逆变</h3>

<p><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98">协变与逆变Covariance and Contravariance</a>是用来描述具有父子继承关系的简单类型，在通过参数化的方法构造出来的更复杂的类型之间是否能保持父子关系的术语。</p>

<p>比如Dog是Animal的子类，根据继承和多态，Dog可以用在任何声明为Animal的语句和表达式中。<strong>变型Variance</strong>指的就是根据已知的父子关系Dog和Animal，如何来确定由它们构成的更复杂类型如List&lt;Dog&gt;和List&lt;Animal&gt;之间的关系？</p>

<p>常规泛型是<strong>不可变的Invariant</strong>，也就是说复杂类型之间的关系与它们具体的参数化类型之间是没有关系的，如List&lt;Dog&gt;并不是List&lt;Animal&gt;，它们之间没有任何关系，不能把List&lt;Dog&gt;当成是List&lt;Animal&gt;，虽然Dog可以被当作Animal。</p>

<p>不可变Invariant有时候会带来不方便，比如说，集合通常都有addAll方法来批量的把对象加入到集合中：</p>

<pre><code class="Kotlin">class List&lt;T&gt; {
    fun addAll(from: List&lt;T&gt;) {
        for (x in from) {
            add(x)
        }
    }
}
val objs: List&lt;Any&gt; = emptyList()
val names: List&lt;String&gt; = listOf("James", "Kevin", "Harden")
objs.addAll(names) // No go, compile error
</code></pre>

<p>这是参数化列表集合，先创建一个具体类型为Any的列表，然后尝试把一个String列表添加到Any列表中，其实这么做是完全安全的，因为String对象是完全可以当作其基类Any来使用的，但泛型的不可变性阻止了我们这么做。</p>

<p>这时就需要<strong>协变</strong>与<strong>逆变</strong>了，也就是通过一定的方法让复杂类型的行为与其参数化类型之间进行协同。</p>

<p><img src="https://phpstan.org/covariance-contravariance.4483af19.png" alt="" /></p>

<h3>关键字out进行协变</h3>

<p>使用out关键能够让泛型进行协变。比如上面例子理想的情况应该是，只要能当作T的类型，都应该能用在addAll中，换句话说把T的子类的列表也应该能够支持，即objs.addAll(names)应该能正常编译并正常运行。使用关键out即可达到这样的效果：</p>

<pre><code class="Kotlin">class List&lt;out T&gt; {
    fun addAll(from: List&lt;T&gt;) {
        for (x in from) {
            add(x)
        }
    }
}
val objs: List&lt;Any&gt; = emptyList()
val names: List&lt;String&gt; = listOf("James", "Kevin", "Harden")
objs.addAll(names) // Okay
</code></pre>

<p>这里的泛型参数from: List<out T>其实是一个生产者，它生产类型为T的对象，所以这里用out来修饰，产出的对象是T或者是T的子类都是会是合法的。或者说当我们想把一个子类的泛型赋给父类的泛型时，就需要对泛型声明为out，以进行协变。</p>

<p><strong>注意：</strong>关键字out与Java泛型中的extend通配符的作用是一样的，指定参数的上限，生产者产生的对象都会向上转型(upcast)为基类，所以需要指定一个上限。</p>

<p>与之相对的，还有in逆变。</p>

<h3>关键字in进行逆变</h3>

<p>有时候情况是相反的，也就是说我们持有的是父类的泛型，但 我们想把它赋给其子类的泛型，这时就可以用in进行逆变。而且必须注意in只能用在消费者中，也就是说是在真实消费对象，为什么呢？其实这里真实发生的是向下转型(downcast)&ndash;把父类的对象赋给子类的引用上面，而向下转型不一定保证是安全的。所以，必须是在真实消费这个对象的地方，只有是期望的真实对象才能被消费。</p>

<pre><code class="Kotlin">class ParameterizedConsumer&lt;in T&gt; {
    fun toString(value: T): String {
        return value.toString()
    }
}

val parameterizedConsumer = ParameterizedConsumer&lt;Number&gt;()

val ref: ParameterizedConsumer&lt;Double&gt; = parameterizedConsumer
</code></pre>

<p><strong>注意：</strong>关键字in与Java泛型中的super是一样的，指定一个下限，因为在消费对象时会转成T，用T来限制成为下限，那么向下转型(downcast)就是安全的。</p>

<h2>任意类型的泛型</h2>

<p>有些比较简单粗暴的场景，就是单纯的想让任意类型的泛型都可以使用，这时关键字out和关键字in可能都不太合适，因为它们只能用于生产者和消费者场景，用以指定类型上限和类型下限。这时可以用<strong>星号&#42;</strong>来当用泛型参数，以表示任意具体类型的泛型都可以使用。</p>

<pre><code class="Kotlin">fun printArray(array: Array&lt;*&gt;) { 
    array.forEach { println(it) }
}

val array = arrayOf(1,2,3) 
printArray(array)
</code></pre>

<h2>关键字reified</h2>

<h3>运行时泛型擦除</h3>

<p>需要注意的是泛型类型在运行时会被擦除(erased)，也就是说在运行时任何对象都是不带有其泛型类型的，具体点的，就是List&lt;String&gt;和List&lt;Int&gt;在运行时，它们的对象实例是一样的，无法知道它们的具体的泛型参数类型。前面讲的各种规则都是发生在编译时间，编译器帮助检查传入的泛型对象是否符合规划，并进行类型转换。到了运行时，泛型类型会被擦除。(为啥会被擦除呢？因为JVM要保持向后兼容，早期的Java没有泛型，只有原始的类型对象(raw type)，所以后来1.5版本后加入的泛型只有擦除掉变成raw type才能保持兼容。)</p>

<h3>关键字reified</h3>

<p>泛型类型擦除会带来一个问题，就是对于泛型类型对象，无法做类型检查(is T)，无法做类型转换(as T)，因为运行时的对象根本不知道它的泛型类型是什么，这会带来极大的不方便，特别是工厂方法就无法使用泛型了，因为无法做类型检查 和转换。</p>

<p>这时inline再加上关键字reified就能完美的解决问题，它们两个配合起来运行时就能保留泛型类型了：</p>

<pre><code class="Kotlin">inline fun &lt;reified T&gt; Iterable&lt;*&gt;.filterIsInstance() = filter { it is T }

&gt;&gt; val set = setOf("1984", 2, 3, "Brave new world", 11)
&gt;&gt; println(set.filterIsInstance&lt;Int&gt;())
[2, 3, 11]
</code></pre>

<p>可以看到类型判断起来作用了。再看一个泛型工厂方法的例子：</p>

<pre><code class="Kotlin">inline fun &lt;reified T&gt; logger(): Logger = LoggerFactory.getLogger(T::class.java)

class User {
    private val log = logger&lt;User&gt;()
    // ...
}
</code></pre>

<h2>练习</h2>

<p>这里强烈推荐谷歌官方给出的关于Kotlin语言中的<a href="https://developer.android.com/codelabs/basic-android-kotlin-compose-generics#0">类型相关的小练习</a>，可以用来巩固加强一下所学的知识。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/generics.html">Generics: in, out, where</a></li>
<li><a href="https://www.geeksforgeeks.org/kotlin-generics/">Kotlin generics</a></li>
<li><a href="https://www.baeldung.com/kotlin/generics">Generics in Kotlin</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32583310">Kotlin 泛型中的 in 和 out</a></li>
<li><a href="https://blog.csdn.net/u011897062/article/details/130832411">Kotlin泛型＜in, out, where＞概念及示例</a></li>
<li><a href="https://rengwuxian.com/kotlin-generics/">Kotlin 的泛型</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
