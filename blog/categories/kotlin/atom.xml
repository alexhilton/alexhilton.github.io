<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Kotlin | 稀有猿诉]]></title>
  <link href="http://toughcoder.net/blog/categories/kotlin/atom.xml" rel="self"/>
  <link href="http://toughcoder.net/"/>
  <updated>2024-03-14T23:01:29+08:00</updated>
  <id>http://toughcoder.net/</id>
  <author>
    <name><![CDATA[Alex Hilton]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Kotlin Generics Revisited]]></title>
    <link href="http://toughcoder.net/blog/2024/03/13/kotlin-generics-revisited/"/>
    <updated>2024-03-13T22:33:20+08:00</updated>
    <id>http://toughcoder.net/blog/2024/03/13/kotlin-generics-revisited</id>
    <content type="html"><![CDATA[<p>在前面的文章中学习Kotlin泛型的基本知识，并且又用了一篇文章来复习了一下Java语言的泛型，有了这些基础我们就可以继续深入的学习Kotlin的泛型了。看它是如何解决Java泛型的遗留问题，再学习一下它的高级特性，最后再总结泛型的最佳实践。</p>

<p><a href=""><img src="https://koenig-media.raywenderlich.com/uploads/2019/09/Generics-feature.png" width="480" height="480"></a></p>

<!-- more -->


<p>本文是作为前面文章的延续和深化，为了更好的阅读效果，建议先回顾一下<a href="http://toughcoder.net/blog/2024/03/10/java-generics-made-easy/">Java泛型基础</a>，和<a href="http://toughcoder.net/blog/2024/03/04/kotlin-generics-made-easy/">Kotlin泛型基础</a>。</p>

<h2>泛型类型参数界限</h2>

<p>我们在前面讲解<a href="http://toughcoder.net/blog/2024/03/10/java-generics-made-easy/">Java泛型基础</a>时提到了在声明泛型的时候是可以指定类型参数的界限的，比如用Caculator&lt;T extends Number&gt;可以指定在使用时可以传入的类型参数要是Number或者Number的子类。</p>

<p>在Kotlin中也是可以指定泛型类型参数的界限的，也是用<strong>继承符号:来表示</strong>，&#127792;如：</p>

<pre><code class="Kotlin">class Calculator&lt;T : Number&gt; { ... }
</code></pre>

<p>与Java一样，也可以指定多个界限，要<strong>使用where关键字</strong>：</p>

<pre><code class="Kotlin">class Calculator&lt;T&gt; where T : Number, T : Runnable, T : Closable { ... }

fun &lt;T&gt; copyWhenGreater(list: List&lt;T&gt;, threshold: T): List&lt;String&gt;
    where T : CharSequence,
          T : Comparable&lt;T&gt; {
    return list.filter { it &gt; threshold }.map { it.toString() }
}
</code></pre>

<h2>更优雅的泛型变化(Variance)</h2>

<p>与Java一样，Kotlin的泛型也是不可变的Invariant，比如虽然String是Any的子类，但List<String>并不是List<Any>的子类。泛型变化Variance的目的就是让两个泛型产生与类型参数协同的变化，比如类型C是类B的子类，那么使用它的泛型&lt;C&gt;也应该是&lt;B&gt;的子类，能使用&lt;B&gt;的方，传入&lt;C&gt;一定要是允许的，并要能够是安全的。</p>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.HRZ3CHxJfgk_hG9T11siDQHaD4?rs=1&amp;pid=ImgDetMain" alt="" /></p>

<h3>使用点变化（Use-site variance）</h3>

<p>基于面向对象的基本特性，只有向上转型(Upcasting)是安全的。具体就分为两种场景，从一个生产者中读取对象时，只要生产者的输出声明的T是基类（T是一个上限），无论生产者输出的是T还是它的子类，对于使用者来说（当T来用）就是安全的。这时生产者的泛型要能够进行协变，在Java中用上界界限通配符&lt;? extends T&gt;来进行协变，具体使用时传入T的子类的泛型也是合法的；同理，向一个消费者中写数据时，消费者声明为T的某个基类（这时T是一个下限），向其传入T，对于使用者来说就是安全的。这时消费者的泛型要能进行逆变，在Java中使用下界界限通配符&lt;? super T&gt;来进行逆变，具体使用时传T的基类的泛型也是合法的。</p>

<p>Kotlin中提供了非常容易理解和使用的关键字out来进行协变(covariance)和in进行逆变(contravariance)，可以实现Java中的界限通配符一样的功效。Java界限通配符的规则是<strong>PECS（Producer Extends Consumer Super）</strong>，out正好可以更形象的描述一个生产者，而in可以更形象的描述一个消费者，所以Kotlin的关键字更容易理解和记忆。</p>

<pre><code class="Kotlin">open class Animal
class Dog : Animal()

class MyList&lt;E&gt; {
    fun addAll(from: MyList&lt;out E&gt;) {}
    fun getAll(to: MyList&lt;in E&gt;) {}
}

fun main() {
    val animals = MyList&lt;Animal&gt;()
    val dogs = MyList&lt;Dog&gt;()

    animals.addAll(dogs)
    dogs.getAll(animals)
}
</code></pre>

<p>这种泛型变化是发生在调用者调用时，因此也叫做『使用点变化』(Use-site variance)。在Kotlin中也被称作<strong>类型映射</strong>，因为相当于是用&lt;out T&gt;把T给映射成了一个T的生产者，只能调用其get方法；用&lt;in T&gt;映射成一个T的消费者，只能调用set方法。并且呢，对于同一个函数中既有生产者和消费者时，in和out只写一个就行了，&#127792;如：</p>

<pre><code class="Kotlin">fun copy(from: Array&lt;out Any&gt;, to: Array&lt;Any&gt;) { ... }
</code></pre>

<h3>声明点变化（Declaration-site variance）</h3>

<p>Java界限通配符的一个大问题是只能用于方法的参数但不能是返回值，也就是只能是『Use-site variance』。但in和out没有这个限制，因此它们可以用于返回值。只要给类和接口的泛型声明为out或者in就能让类型参数在其所有的方法产生variance，这就是『declaration-site variance』。</p>

<p>但是要遵守out进行协变，也就是<strong>说out是用于生产者</strong>的，只能作为方法的返回值，或者保证不能set，&#127792;如：</p>

<pre><code class="Kotlin">interface Source&lt;out T&gt; {
    fun nextT(): T
}

fun demo(strs: Source&lt;String&gt;) {
    val objects: Source&lt;Any&gt; = strs // This is OK, since T is an out-parameter
    // ...
}
</code></pre>

<p>同理，<strong>用in进行逆变，只能用于消费者</strong>，只能作为方法的参数，或者保证不get，&#127792;如：</p>

<pre><code>interface Comparable&lt;in T&gt; {
    operator fun compareTo(other: T): Int
}

fun demo(x: Comparable&lt;Number&gt;) {
    x.compareTo(1.0) // 1.0 has type Double, which is a subtype of Number
    // Thus, you can assign x to a variable of type Comparable&lt;Double&gt;
    val y: Comparable&lt;Double&gt; = x // OK!
}
</code></pre>

<p>小结一下，Kotlin使用关键字in和out让泛型的协变和逆变变得容易理解得多了，因为它们能够非常清楚的表达出消费者和生产者，只需要记住一个泛型的生产者要用out来修饰，而一个泛型的消费者要用in来修饰就不会出错，这比Java中的界限通配符简单太多了。</p>

<h2>星号映射(Star projections)</h2>

<p>除了use-site variance是一种类型映射外，还有星号映射。首先来说<strong>星号是无界泛型</strong>，也就是说不指定具体的类型参数，意思是任意类型的泛型，换句话说Foo&lt;&#42;&gt;是任何其他泛型的基类（Foo&lt;String&gt;, Foo&lt;Number&gt;等）。但根据不同的上下文，Foo&lt;&#42;&gt;会映射为不同的具体意义的泛型类型：</p>

<ul>
<li>对于Foo&lt;out T : TUpper&gt;，这里的T是一个受上界TUpper限制的协变类型参数，那么Foo&lt;&#42;&gt;就等同于Foo&lt;out TUpper&gt;。</li>
<li>对于Foo&lt;in T&gt;，这里T是逆变类型参数，Foo&lt;&#42;&gt;等同于Foo&lt;in Nothing&gt;。这意思是无法向Foo&lt;&#42;&gt;中写。</li>
<li>对于Foot&lt;T : TUpper&gt;，这里T是一个被上界TUpper限定的不可变类型参数，那么Foo&lt;&#42;&gt;，在读时（作为生产者）等同于Foo&lt;out TUpper&gt;，在写时（作为消费者）等同于Foo&lt;in Nothing&gt;。</li>
</ul>


<p>如果泛型是多元的，那么每个类型参数可以进行不同的映射。比如说如果一个类型是这样声明的interface Function&lt;in T, out U&gt;，那么会有这样的映射：</p>

<ul>
<li>Function&lt;&#42;, String&gt; 意思是Function&lt;in Nothing, String&gt;</li>
<li>Function&lt;Int, &#42;&gt; 意思是Function&lt;Int, out Any?&gt;</li>
<li>Function&lt;&#42;, &#42;&gt; 意思是Function&lt;in Nothing, out Any?&gt;</li>
</ul>


<p>换句话来理解，就是当不指定具体的类型参数，用星星就代表着不知道具体的类型参数，那么视具体的上下文不同星号会被解释不同的意思。不过这玩意儿可读性较差，除非必不得已，否则还是能不用就用它。</p>

<h2>泛型擦除</h2>

<h2>绝不为空类型</h2>

<p>为了保持对Java的互通性，Kotlin还支持把泛型类型参数声明为『绝不为空类型』definitely non-null type。可以<strong>用&amp; Any来声明</strong>，如&lt;T &amp; Any&gt;来声明T是『绝不为空类型』。</p>

<p>这是为了保持与Java的相互调用，有些Java的类和接口是用注解&#64;NonNull修饰的，如：</p>

<pre><code class="Java">public interface Game&lt;T&gt; {
    public T save(T x) {}
    @NotNull
    public T load(@NotNull T x) {}
}
</code></pre>

<p>这时在Kotlin里面就要用到『绝不为空类型』&amp; Any来声明泛型：</p>

<pre><code class="Kotlin">interface ArcadeGame&lt;T1&gt; : Game&lt;T1&gt; {
    override fun save(x: T1): T1
    // T1 is definitely non-nullable
    override fun load(x: T1 &amp; Any): T1 &amp; Any
}
</code></pre>

<p>注意，在纯Kotlin代码中是用不到这个特性的。只有当涉及Java的NonNull时才需要『绝不为空类型』。</p>

<h2>下划线操作符</h2>

<p>当编译器能推断出泛型的类型参数时是可以省略掉类型参数的，比如val names = listOf(&ldquo;James&rdquo;, &ldquo;Kevin&rdquo;)，这里得到的类型是List&lt;String&gt;，但我们并没有显示的指定类型参数，这是因为编译器从listOf的参数中就能推断出类型参数是String，所以listOf的返回就是List&lt;String&gt;。</p>

<p>但有些时候，泛型类型太复杂了，没有办法推断出所有的类型，比如有多元泛型参数时。但根据指定的某一个参数，可以推断出剩余的参数时，这时就没有办法完全省略类型参数，剩余的参数却又可以推断出来，写了又浪费。这时就可以用下划线操作符来代表那些可以推断出来的参数。这里的下划线用法跟在lambda中，用下划线替代不使用的参数是一样的。</p>

<pre><code class="Kotlin">abstract class SomeClass&lt;T&gt; {
    abstract fun execute() : T
}

class SomeImplementation : SomeClass&lt;String&gt;() {
    override fun execute(): String = "Test"
}

class OtherImplementation : SomeClass&lt;Int&gt;() {
    override fun execute(): Int = 42
}

object Runner {
    inline fun &lt;reified S: SomeClass&lt;T&gt;, T&gt; run() : T {
        return S::class.java.getDeclaredConstructor().newInstance().execute()
    }
}

fun main() {
    // T is inferred as String because SomeImplementation derives from SomeClass&lt;String&gt;
    val s = Runner.run&lt;SomeImplementation, _&gt;()
    assert(s == "Test")

    // T is inferred as Int because OtherImplementation derives from SomeClass&lt;Int&gt;
    val n = Runner.run&lt;OtherImplementation, _&gt;()
    assert(n == 42)
}
</code></pre>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/generics.html">Generics: in, out, where</a></li>
<li><a href="https://www.gyata.ai/kotlin/kotlin-generics/">Kotlin Generics</a></li>
<li><a href="https://blog.logrocket.com/understanding-kotlin-generics/">Understanding Kotlin generics</a></li>
<li><a href="https://sebhastian.com/kotlin-generics/#google_vignette">Kotlin generics explained with code examples</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/143380842">深入解析Kotlin 泛型</a></li>
<li><a href="https://juejin.cn/post/6959859571242303495">Kotlin（六）深入理解Kotlin泛型</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[这回就好好聊聊Kotlin的泛型]]></title>
    <link href="http://toughcoder.net/blog/2024/03/04/kotlin-generics-made-easy/"/>
    <updated>2024-03-04T22:51:58+08:00</updated>
    <id>http://toughcoder.net/blog/2024/03/04/kotlin-generics-made-easy</id>
    <content type="html"><![CDATA[<p>泛型(Generics)是静态强类型编程语言中非常强大的特性，可以极大的加强代码的复用，并增强类型安全，减少运行时的类型转换错误。在这篇文章就来详细的学习一下Kotlin中对泛型的支持情况，并学会写出类型安全的可复用代码。</p>

<p><a href=""><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.bl_F0aycuia6QRYMt4AOfQHaFc?rs=1&amp;pid=ImgDetMain" title="auto auto" ></a></p>

<!-- more -->


<h2>泛型基础</h2>

<p>泛型的本质就是能够创建参数化的对象和函数，以实现复用。比如说，我们最熟悉的集合List，它是<strong>与具体类型无关</strong>的数据结构，或者叫做对象容器。列表List的重点在于可扩展长度，但里面具体的对象类型并不是重点，只要是一个对象就可以了。假如没有泛型，可能就要写很多重复的代码，比如字符串列表StringList，数字列表NumberList，等等。用泛型，只<strong>用一个参数化</strong>的List就可以了，用尖括号<strong>&lt;&gt;</strong>来表示参数化。</p>

<pre><code class="Kotlin">val names: List&lt;String&gt; = listOf("James", "Kevin", "Harden")
val rebounds: List&lt;Int&gt; = listOf(2, 14, 7)
</code></pre>

<p>泛型有两种形式，一种是对类进行参数化如List<String>，一种是对函数进行参数化，如max<Int>()。</p>

<h3>参数化的类</h3>

<p>声明方式就是在声明类的时候在类的名字后面用尖括号<strong>&lt;&gt;</strong>来带上一个类型参数，然后在内部就可以当成一个类型来使用：</p>

<pre><code class="Kotlin">class Box&lt;T&gt;(t: T) {
    var value = t
}
</code></pre>

<p>这就创建了一个参数化的容器，它可以持有任何指定类型的对象：</p>

<pre><code class="Kotlin">val box: Box&lt;Int&gt; = Box&lt;Int&gt;(1)
val case: Box&lt;String&gt; = Box&lt;String&gt;("Coat")
</code></pre>

<h3>参数化的函数</h3>

<p>除了参数化的类以外，还可以创建参数化的函数，在函数名字的前面用尖括号<strong>&lt;&gt;</strong>来声明泛型，然后在参数列表以及函数体内就可以当作类型来使用：</p>

<pre><code class="Kotlin">fun &lt;T&gt; singleTonList(item: T): List&lt;T&gt; {
    ...
}
</code></pre>

<p>调用的时候指定一下具体的类型就可以了：</p>

<pre><code class="Kotlin">val l = singletonList&lt;Int&gt;(3)
</code></pre>

<p><strong>注意：</strong>Kotlin语言有强大的类型推断能力，但凡编译器能够推断出类型时，类型的声明都可以省略掉。对于泛型更是如此，比如说，这样写都是合法的：</p>

<pre><code class="Kotlin">val names = listOf("James", "Kevin", "Harden")
val rebounds = listOf(2, 14, 7)
val l = singletonList(3)
</code></pre>

<p>通常情况下，<strong>声明</strong>，<strong>定义</strong>和<strong>赋值</strong>三个地方，只要有一个地方能够让编译器知道具体的类型就够了，其他地方都可以把类型的声明省略掉。</p>

<h2>泛型的本质与优点</h2>

<p>假如不使用泛型，又想写出比较通用的类和函数，唯一可行的方法就是使用通用基类Any当作参数，在Kotlin中Any是所有对象的基类，比如，说想实现一个列表：</p>

<pre><code class="Kotlin">class AnyList {
    fun add(item: Any)
    fun get(idx: Int): Any
}
</code></pre>

<p>这样写可以，但它有很大的问题，就是不能保证类型安全：</p>

<pre><code class="Kotlin">val list = AnyList()
list.add("James")
list.add(13)
val e = (Int) list.get(1)
</code></pre>

<p>一方面我们需要自己进行强行类型转换，但也无法保证你取出来的对象类型与期望的是一致的，更无法保证调用者往里面添加什么对象，因为任何Any的子类都可以让代码通过编译，但在运行时极容易发生类型转换异常ClassCastException。</p>

<p>但用泛型就能很好的解决这个问题，可以得出泛型的优点：</p>

<ol>
<li>不需要做类型转换，编译器会根据指定的具体类型自动做类型转换</li>
<li>类型安全，编译器会帮助做检查，传给泛型的对象必须具有一致的类型，且是指定的类型</li>
<li>保障了运行时的类型安全，因为编译器在编译时做好了检查，所以不会发生运行时的类型错误</li>
</ol>


<p>因此，凡是有需要针对 类型复用的地方，都应该用泛型来实现类型参数化。</p>

<h2>关键字out和关键字in</h2>

<p>大部分情况下，只要给类型和函数加上参数化的类型就够了，但有时候有些复杂情况需要处理。</p>

<h3>协变与逆变</h3>

<p><a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98">协变与逆变Covariance and Contravariance</a>是用来描述具有父子继承关系的简单类型，在通过参数化的方法构造出来的更复杂的类型之间是否能保持父子关系的术语。</p>

<p>比如Dog是Animal的子类，根据继承和多态，Dog可以用在任何声明为Animal的语句和表达式中。<strong>变型Variance</strong>指的就是根据已知的父子关系Dog和Animal，如何来确定由它们构成的更复杂类型如List&lt;Dog&gt;和List&lt;Animal&gt;之间的关系？</p>

<p>常规泛型是<strong>不可变的Invariant</strong>，也就是说复杂类型之间的关系与它们具体的参数化类型之间是没有关系的，如List&lt;Dog&gt;并不是List&lt;Animal&gt;，它们之间没有任何关系，不能把List&lt;Dog&gt;当成是List&lt;Animal&gt;，虽然Dog可以被当作Animal。</p>

<p>不可变Invariant有时候会带来不方便，比如说，集合通常都有addAll方法来批量的把对象加入到集合中：</p>

<pre><code class="Kotlin">class List&lt;T&gt; {
    fun addAll(from: List&lt;T&gt;) {
        for (x in from) {
            add(x)
        }
    }
}
val objs: List&lt;Any&gt; = emptyList()
val names: List&lt;String&gt; = listOf("James", "Kevin", "Harden")
objs.addAll(names) // No go, compile error
</code></pre>

<p>这是参数化列表集合，先创建一个具体类型为Any的列表，然后尝试把一个String列表添加到Any列表中，其实这么做是完全安全的，因为String对象是完全可以当作其基类Any来使用的，但泛型的不可变性阻止了我们这么做。</p>

<p>这时就需要<strong>协变</strong>与<strong>逆变</strong>了，也就是通过一定的方法让复杂类型的行为与其参数化类型之间进行协同。</p>

<p><img src="https://phpstan.org/covariance-contravariance.4483af19.png" alt="" /></p>

<h3>关键字out进行协变</h3>

<p>使用out关键能够让泛型进行协变。比如上面例子理想的情况应该是，只要能当作T的类型，都应该能用在addAll中，换句话说把T的子类的列表也应该能够支持，即objs.addAll(names)应该能正常编译并正常运行。使用关键out即可达到这样的效果：</p>

<pre><code class="Kotlin">class List&lt;out T&gt; {
    fun addAll(from: List&lt;T&gt;) {
        for (x in from) {
            add(x)
        }
    }
}
val objs: List&lt;Any&gt; = emptyList()
val names: List&lt;String&gt; = listOf("James", "Kevin", "Harden")
objs.addAll(names) // Okay
</code></pre>

<p>这里的泛型参数from: List<out T>其实是一个生产者，它生产类型为T的对象，所以这里用out来修饰，产出的对象是T或者是T的子类都是会是合法的。或者说当我们想把一个子类的泛型赋给父类的泛型时，就需要对泛型声明为out，以进行协变。</p>

<p><strong>注意：</strong>关键字out与Java泛型中的extend通配符的作用是一样的，指定参数的上限，生产者产生的对象都会向上转型(upcast)为基类，所以需要指定一个上限。</p>

<p>与之相对的，还有in逆变。</p>

<h3>关键字in进行逆变</h3>

<p>有时候情况是相反的，也就是说我们持有的是父类的泛型，但 我们想把它赋给其子类的泛型，这时就可以用in进行逆变。而且必须注意in只能用在消费者中，也就是说是在真实消费对象，为什么呢？其实这里真实发生的是向下转型(downcast)&ndash;把父类的对象赋给子类的引用上面，而向下转型不一定保证是安全的。所以，必须是在真实消费这个对象的地方，只有是期望的真实对象才能被消费。</p>

<pre><code class="Kotlin">class ParameterizedConsumer&lt;in T&gt; {
    fun toString(value: T): String {
        return value.toString()
    }
}

val parameterizedConsumer = ParameterizedConsumer&lt;Number&gt;()

val ref: ParameterizedConsumer&lt;Double&gt; = parameterizedConsumer
</code></pre>

<p><strong>注意：</strong>关键字in与Java泛型中的super是一样的，指定一个下限，因为在消费对象时会转成T，用T来限制成为下限，那么向下转型(downcast)就是安全的。</p>

<h2>任意类型的泛型</h2>

<p>有些比较简单粗暴的场景，就是单纯的想让任意类型的泛型都可以使用，这时关键字out和关键字in可能都不太合适，因为它们只能用于生产者和消费者场景，用以指定类型上限和类型下限。这时可以用<strong>星号&#42;</strong>来当用泛型参数，以表示任意具体类型的泛型都可以使用。</p>

<pre><code class="Kotlin">fun printArray(array: Array&lt;*&gt;) { 
    array.forEach { println(it) }
}

val array = arrayOf(1,2,3) 
printArray(array)
</code></pre>

<h2>关键字reified</h2>

<h3>运行时泛型擦除</h3>

<p>需要注意的是泛型类型在运行时会被擦除(erased)，也就是说在运行时任何对象都是不带有其泛型类型的，具体点的，就是List&lt;String&gt;和List&lt;Int&gt;在运行时，它们的对象实例是一样的，无法知道它们的具体的泛型参数类型。前面讲的各种规则都是发生在编译时间，编译器帮助检查传入的泛型对象是否符合规划，并进行类型转换。到了运行时，泛型类型会被擦除。(为啥会被擦除呢？因为JVM要保持向后兼容，早期的Java没有泛型，只有原始的类型对象(raw type)，所以后来1.5版本后加入的泛型只有擦除掉变成raw type才能保持兼容。)</p>

<h3>关键字reified</h3>

<p>泛型类型擦除会带来一个问题，就是对于泛型类型对象，无法做类型检查(is T)，无法做类型转换(as T)，因为运行时的对象根本不知道它的泛型类型是什么，这会带来极大的不方便，特别是工厂方法就无法使用泛型了，因为无法做类型检查 和转换。</p>

<p>这时inline再加上关键字reified就能完美的解决问题，它们两个配合起来运行时就能保留泛型类型了：</p>

<pre><code class="Kotlin">inline fun &lt;reified T&gt; Iterable&lt;*&gt;.filterIsInstance() = filter { it is T }

&gt;&gt; val set = setOf("1984", 2, 3, "Brave new world", 11)
&gt;&gt; println(set.filterIsInstance&lt;Int&gt;())
[2, 3, 11]
</code></pre>

<p>可以看到类型判断起来作用了。再看一个泛型工厂方法的例子：</p>

<pre><code class="Kotlin">inline fun &lt;reified T&gt; logger(): Logger = LoggerFactory.getLogger(T::class.java)

class User {
    private val log = logger&lt;User&gt;()
    // ...
}
</code></pre>

<h2>练习</h2>

<p>这里强烈推荐谷歌官方给出的关于Kotlin语言中的<a href="https://developer.android.com/codelabs/basic-android-kotlin-compose-generics#0">类型相关的小练习</a>，可以用来巩固加强一下所学的知识。</p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/generics.html">Generics: in, out, where</a></li>
<li><a href="https://www.geeksforgeeks.org/kotlin-generics/">Kotlin generics</a></li>
<li><a href="https://www.baeldung.com/kotlin/generics">Generics in Kotlin</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/32583310">Kotlin 泛型中的 in 和 out</a></li>
<li><a href="https://blog.csdn.net/u011897062/article/details/130832411">Kotlin泛型＜in, out, where＞概念及示例</a></li>
<li><a href="https://rengwuxian.com/kotlin-generics/">Kotlin 的泛型</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[一文带你吃透Kotlin类与对象]]></title>
    <link href="http://toughcoder.net/blog/2024/02/26/kotlin-class-made-easy/"/>
    <updated>2024-02-26T21:22:39+08:00</updated>
    <id>http://toughcoder.net/blog/2024/02/26/kotlin-class-made-easy</id>
    <content type="html"><![CDATA[<p>Kotlin是多范式通用编程语言，对面向对象编程(OOP)自然也提供了全方位的支持。通过<a href="http://toughcoder.net/blog/2018/05/17/introduction-to-kotlin-programming-language/">先前一篇文章</a>，学习了使用Kotlin进行基本面向对象编程的方法，本文将在前文基础之上继续深入的学习面向对象编程的高级特性，以能够写出更加符合OO的代码，并能够从容应对一些复杂的OOP场景。</p>

<p><a href=""><img src="https://bigknol.com/wp-content/uploads/2023/07/kotlin_class_objects.png" title="auto auto" ></a></p>

<!-- more -->


<h2>注意构造的顺序</h2>

<p>在构造对象过程中，有三个地方可以对成员进行初始化：1）是在<strong>首构造方法（Primary constructor）</strong>；2）是在声明成员的同时进行初始化，或者是在<strong>初始化代码块(init {&hellip;})</strong>中；3）是在<strong>次要构造方法(Secondary constructor)</strong>中。</p>

<p>要注意它们之间的<strong>区别和执行顺序</strong>，首构造方法是最先执行的，但它不能运行代码，只能进行赋值；成员声明和初始化代码块(init {&hellip;})是首构造方法的一部分，因此要先于次要构造方法。次要构造方法是最后执行，并且次要构造方法一定要委托到首构造方法。成员声明和初始化代码块之间则依赖于书写的顺序，从上到下执行。</p>

<p>虽然编译器有它的规则来保障顺序，但为了可读性和可维护性，我们不应该完全依赖编译器。这里建议的方式是：</p>

<ul>
<li>把类的最核心的成员放在首构造方法，如必须要依赖的参数，公开的成员，类型体系中的核心成员等，这些应该直接放在首构造方法中，并按重要的顺序进行声明，这样也能方便进行依赖注入和测试Mock对象替换。</li>
<li>私有成员应该在类中声明，并且在声明时进行初始化，如果无法初始化就标记为延迟初始(late init)。</li>
<li>初始化代码块，应该做一些复杂的初始化过程，或者成员之间有关联的初始化，或者做一些构造完成之后的操作。比如像在ViewModel中，构造之后，可能执行拉取数据，这就非常适合放在init {&hellip;}之中。</li>
<li>不建议使用次要构造方法，可以用<strong>给首构造方法的参数设置默认值</strong>的方式来进行成员参数上的重载。</li>
<li>初始化代码块要放在所有成员声明之后，以保障执行顺序。</li>
</ul>


<p>扩展阅读<a href="https://kotlinlang.org/docs/classes.html">Classes﻿</a>和<a href="https://kotlinlang.org/docs/properties.html">Properties﻿</a>。</p>

<h2>妙用late init</h2>

<p>通常成员的初始化可以在声明时完成，比如像集合或者一些简单的原始类型对象（Int, Float, String等）。但如果初始化过程比较复杂，或者初始值较难获得，这种情况下，就适合标记为<strong>延迟初始化late init</strong>，然后在合适的时机对成员进行初始化（比如系统框架层的回调中，或者依赖注入等等）。使用一个未初始化的late init成员时会抛出一个叫做<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-uninitialized-property-access-exception/">UninitializedPropertyAccessException</a>的异常，可以在使用成员变量前用<a href="https://kotlinlang.org/docs/reflection.html#property-references">.isInitialized</a>来判断成员变量是否初始化过：</p>

<pre><code class="Kotlin">if (foo::bar.isInitialized) {
    println(foo.bar)
}
</code></pre>

<p>可以发现，对于Android 开发来说<strong>late init</strong>绝对非常有用，因为对于系统组件，我们无法在其构造方法中进行成员初始化，通常都是在第一个回调(如onCreate)中进行初始化，而这些变量全都应该用late init来标记。</p>

<p>另外，需要注意的是，成员是否有被初始化与成员是否是非法值(如null)并不是同一回事，初始化是第一次对成员对象赋值，赋的什么值(正常对象or null)虚拟机并不关心，但只要有过赋值后变量就初始化过了。因此，<strong>用late init可以帮助减少null检查</strong>。</p>

<p>还需要注意的是，延迟初始化late init与属性委托也不是同一回事，late init通常用于内部私有的成员变量，而属性委托通常用于对外开放的公开成员。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/properties.html">Properties</a>。</p>

<h2>函数式接口</h2>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.aCUdGlN1mIUaSZQXKdceSgHaD4?rs=1&amp;pid=ImgDetMain" alt="" /></p>

<p>接口(interfaces)是更高级别的抽象，专注于行为的抽象，用以实现对象间契约式行为交互。这一部分不打算详细讲解interface的使用，而是重点关注函数式接口(function interface)。Kotlin中的接口与Java 8中的接口是一样的，不再全是抽象方法了，可以有默认方法，也就是对接口的方法添加默认的实现，没有默认实现的方法就是抽象方法了（Abstract method）。只有一个抽象方法的接口称之为函数式接口(functional interface)，或者单个抽象方法接口(Single Abstract Method interface)。用fun interface来声明，如：</p>

<pre><code class="Kotlin">fun interface IntPredict {
    fun accept(i: Int): Boolean
}
</code></pre>

<p>函数式接口的最大优势在于，实现接口时可以简化到只用一个lambda，如：</p>

<pre><code class="Kotlin">val isEnv = IntPredict { it % 2 == 0 }
</code></pre>

<p>注意，只有用fun interface声明的含有一个抽象方法的接口才是函数式接口，才能用lambda。对于普通接口，如果它仅含有一个抽象方法，可以转化为函数式接口，比如原接口是酱紫的：</p>

<pre><code class="Kotlin">interface Printer {
    fun print()
}
</code></pre>

<p>那么，可以直接定义一个fun interface Printer就可以了：</p>

<pre><code class="Kotlin">fun interface Printer {
    fun print()
}
</code></pre>

<p>编译器会帮忙做转化。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/fun-interfaces.html">Functional (SAM) interfaces</a>。</p>

<h2>关键字object的妙用</h2>

<p>关键字object用以方便创建匿名对象的场景，如匿名对象，单例以及静态内部类。</p>

<h3>使用匿名对象</h3>

<p>有些时候我们会实现一些接口，或者继承某个基类，但仅是在本地一次性使用(One shot)，这时匿名对象就派上用场了，类似于Java中的匿名内部类。用<strong>object : </strong>后面跟要实现的接口或者要继承的类：</p>

<pre><code class="Kotlin">window.addMouseListener(object : MouseAdapter() {
    override fun mouseClicked(e: MouseEvent) { ... }
    override fun mouseEntered(e: MouseEvent) { ... }
})
</code></pre>

<h3>单例对象</h3>

<p>用object可以非常方便的实现单例模式：</p>

<pre><code class="Kotlin">object DataProviderManager {
    fun registerDataProvider(provider: DataProvider) { ... }
    val allDataProviders: List&lt;DataProvider&gt;
        get() = { ... }
}
</code></pre>

<p>使用时就直接用类名就可以了：DataProviderManager.registerDataProvider(&hellip;)。</p>

<h3>静态成员和方法</h3>

<p><img src="https://ts1.cn.mm.bing.net/th/id/R-C.b4723d86a22037c40298fff12e484b19?rik=tyTmLVbaHs9Mpw&amp;pid=ImgRaw&amp;r=0" alt="" /></p>

<p>在Java中有静态的成员和方法，用以实现一些属于类的成员和方法，在Kotlin中就需要用companion object来实现同样的功能。</p>

<pre><code class="Kotlin">class MyClass {
    companion object Factory {
        fun create(): MyClass = MyClass()
    }
}
</code></pre>

<p>使用时就是用类+方法：MyClass.create()。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/object-declarations.html">Object expressions and declarations</a>。</p>

<h2>纯数据类型</h2>

<p><img src="https://qwebtechnologies.com/blog/wp-content/uploads/2023/03/Kotlin-Data-Class.png" alt="" /></p>

<p>对于函数式编程，通常要写大量的<a href="https://en.wikipedia.org/wiki/Plain_old_Java_object">PoJo</a>用以在函数之间传递数据，这些对象最大的特点就是仅是数据，且不可变(Immutable)，通常的实现方式就是把成员变量全用final修饰（只读read only）。在Kotlin中，可以非常方便的定义这要的类型，即data class。</p>

<pre><code class="Kotlin">data class User(val name: String, val age: Int)
</code></pre>

<p>针对data class，编译器会自动生成equals, hashCode, toString, copy和componentN方法。注意，虽然成员可以标记为var，但不建议这样做，最好还是都标记为只读val，因为data class就是要Immutable。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/data-classes.html">Data classes</a>。</p>

<h2>密封类和接口</h2>

<p>密封类和接口是指用<strong>关键字sealed</strong>修饰的类和接口。它的作用是限制类的层次结构，用sealed修饰的类和接口，它们的所有子类必须在编译的时候就已知，一旦编译完成，不允许再被继承。</p>

<p>密封类型特别适用于库的设计，能够保证库的完整性。通常用于修饰库中的一些关键的有明确类型要求的类型，如<strong>消息类型，错误类型</strong>等等。因为，库会预定义一些消息类型，以及处理消息的接口，假如调用者扩展了某一消息类型，加了很多自定义的东西，这时再用库中的接口来处理的时候，可能会产生未预期的行为，因为库可能不认识这个新的新的消息类型，但因为是子类继承，语法上是合法的。这时密封类型就能派上用场，把消息类型用sealed修饰，就能保证库的完备性，它提供的错误处理接口一定可以正确处理它定义的消息类型。但注意不能滥用，没有必要为库的每一个类和接口都用sealed修饰，其实大部分时候我们是用不到sealed的。</p>

<p>扩展阅读<a href="https://kotlinlang.org/docs/sealed-classes.html">Sealed classes and interfaces</a>。</p>

<h2>类型别名</h2>

<p>一个非常有意思的特性是类型别名，并不是定义一个新类型，而是取个别名。一般情况下，是为了方便，比如目标类型名字太长时，或者有大量的泛型参数时，就可以为它定义一个别名，图个省流。</p>

<pre><code class="Kotlin">typealias NodeSet = Set&lt;Network.Node&gt;

typealias MyHandler = (Int, String, Any) -&gt; Unit
</code></pre>

<p>扩展阅读<a href="https://kotlinlang.org/docs/type-aliases.html">Type aliases</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[专家之路上的Flow高级秘籍]]></title>
    <link href="http://toughcoder.net/blog/2024/01/27/an-advanced-guide-to-kotlin-flow/"/>
    <updated>2024-01-27T20:59:38+08:00</updated>
    <id>http://toughcoder.net/blog/2024/01/27/an-advanced-guide-to-kotlin-flow</id>
    <content type="html"><![CDATA[<blockquote><p>『君不见，黄河之水天上来，奔流到海不复回。』</p></blockquote>

<p>学习与河流一样，一方面学无止境，又是逆水行舟，不进则退，因为其他人都在卷。<a href="http://toughcoder.net/blog/2024/01/25/kotlin-flow-made-easy/">前文一篇文章</a>讲了Flow的基础，大多数情况下够用了，但是不能停止卷，因为你不卷，就会被别人卷。一旦涉及到复杂的应用场景，就需要用到一些高级的API。今天就来学习一下Flow的高级特性，当遇到问题时也能更从容的应对。</p>

<p><a href=""><img src="https://amitshekhar.me/static/images/blog/flow-api-in-kotlin.png" title="auto auto" ></a></p>

<!-- more -->


<h2>上下文切换</h2>

<p>Flow是基于协程的，是用协程来实现并发，前面也提到过像<a href="">flow {&hellip;}</a>，在上游生产数据，以及中游做变幻时，都是可以直接调用suspend，耗时甚至是阻塞的函数的。而终端操作符如<a href="">collect</a>则是suspend的，调用者（也就是消费者）需要负责确保collect是在协程中调用。我们还知道Flow是是冷流，消费者终端才会触发上游生产者生产，所以对于flow {&hellip;}来说，它的上游和中游运行的上下文来自于终端调用者的上下文，这个叫做『上下文保留』（context preservation），我们可以用一个&#127792; 来验证一下：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    // Should be main by default
    simple().collect { log("Got: $it") }

    // Collect in a specified context
    withContext(Dispatchers.Default) {
        simple().collect { log("Now got: $it") }
    }
}

private fun simple(): Flow&lt;Int&gt; = flow {
    log("Started the simple flow")
    for (i in 1..3) {
        delay(100)
        log("Producing $i")
        emit(i)
    }
}
</code></pre>

<p>输出如下：</p>

<pre><code class="Bash">[main @coroutine#1] Started the simple flow
[main @coroutine#1] Producing 1
[main @coroutine#1] Got: 1
[main @coroutine#1] Producing 2
[main @coroutine#1] Got: 2
[main @coroutine#1] Producing 3
[main @coroutine#1] Got: 3
[DefaultDispatcher-worker-1 @coroutine#1] Started the simple flow
[DefaultDispatcher-worker-1 @coroutine#1] Producing 1
[DefaultDispatcher-worker-1 @coroutine#1] Now got: 1
[DefaultDispatcher-worker-1 @coroutine#1] Producing 2
[DefaultDispatcher-worker-1 @coroutine#1] Now got: 2
[DefaultDispatcher-worker-1 @coroutine#1] Producing 3
[DefaultDispatcher-worker-1 @coroutine#1] Now got: 3
</code></pre>

<p>从这个&#127792; 可以清楚的看到，Flow的context是来自于终端调用者的。</p>

<h3>用flowOn来指定上下文</h3>

<p>有时候使用终端调用者的上下文可能不太方便，因为生产者与消费者的模式其实是解耦的，它们不应该相互受制于对方，对于关键的并发的上下文更是如此。比如说在GUI的应用中，明显应该在工作线程中生产数据，在UI线程中消费数据，从上面的例子来看，由终端调用者来决定上游上下文明显不可取。有同学举手了，欺负我没学过协程是吧？我可以在Flow内部使用withContext来指定上下文啊，我们来试试：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    // Should be main by default
    simple().collect { log("Got: $it") }
}

private fun simple(): Flow&lt;Int&gt; = flow {
    withContext(Dispatchers.Default) {
        log("Started the simple flow")
        for (i in 1..3) {
            delay(100)
            log("Producing $i")
            emit(i)
        }
    }
}
</code></pre>

<p>这位同学可以直接出去了，因为你的代码crash 了：</p>

<pre><code class="Bash">[DefaultDispatcher-worker-1 @coroutine#1] Started the simple flow
[DefaultDispatcher-worker-1 @coroutine#1] Producing 1
Exception in thread "main" java.lang.IllegalStateException: Flow invariant is violated:
        Flow was collected in [CoroutineId(1), "coroutine#1":BlockingCoroutine{Active}@545486c7, BlockingEventLoop@13bfcf14],
        but emission happened in [CoroutineId(1), "coroutine#1":DispatchedCoroutine{Active}@27015c5a, Dispatchers.Default].
        Please refer to 'flow' documentation or use 'flowOn' instead
</code></pre>

<p>意思大概是说Flow内部不让直接用withContext来切上下文，破坏了Flow的不变式，想切上下文要用flowOn。而且仔细看，异常是由emit函数抛出来的。</p>

<p>其实Flow的设计者已经考虑到了这个问题，并且给出了优雅的方式，如果想切换Flow内部（也即上游和中游）的运行上下文，要用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-on.html">flowOn</a>函数：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    // Should be main by default
    simple().collect { log("Got: $it") }
}

private fun simple(): Flow&lt;Int&gt; = flow {
    log("Started the simple flow")
    for (i in 1..3) {
        delay(100)
        log("Producing $i")
        emit(i)
        Thread.sleep(50)
    }
}.flowOn(Dispatchers.Default)
//[DefaultDispatcher-worker-1 @coroutine#2] Started the simple flow
//[DefaultDispatcher-worker-1 @coroutine#2] Producing 1
//[main @coroutine#1] Got: 1
//[DefaultDispatcher-worker-1 @coroutine#2] Producing 2
//[main @coroutine#1] Got: 2
//[DefaultDispatcher-worker-1 @coroutine#2] Producing 3
//[main @coroutine#1] Got: 3
</code></pre>

<p>这回就和谐多了，后台搞生产，UI只展示，完美！还需要特别注意的是<strong>函数flowOn只影响它的上游，不影响它的下游，更不会影响终端</strong>，终端永远都在<strong>其调用者的上下文</strong>中，来看一个&#127792; ：</p>

<pre><code class="Kotlin">withContext(Dispatchers.Main) {    val singleValue = intFlow // will be executed on IO if context wasn't specified before        .map { ... } // Will be executed in IO        .flowOn(Dispatchers.IO)        .filter { ... } // Will be executed in Default        .flowOn(Dispatchers.Default)        .single() // Will be executed in the Main}
</code></pre>

<p>第一个flowOn切到<em>IO</em>，只影响到它前面的创建和map，第二次切换到<em>Default</em>，只影响filter。single是终端，是在<em>Main</em>，因为它的调用者是在<em>Main</em>里面。</p>

<p><strong>注意，注意：</strong> Flow是一个数据流，保持其数据流的特点是相当重要的，无论是正常数据，异常数据，还是出错都是一种数据，应该让其自上而下的流动，在<strong>中游变幻时或者终端时通过操作符来处理</strong>。所以，像硬性的上下文切换，或者异常的try/catch都是不允许的。这就是所谓的流的不变性（Flow invariant）。后面讲异常时还会提到这点。</p>

<h2>任意上下文的Flow builders</h2>

<p>从前面的学习我们知道了，下下文保留的特性，终端会决定上游生产者的上下文，当然也可以通过flowOn来改变上下文。Flow builder其实就是一个生产者，异步的emit数据。但有些时候生产数据时的上下文，也就是调用emit时的上下文，是不确定的。比如说安卓 上面的各种回调（callback）有些是回调在调用者的线程里，有些则不是。<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow.html">flow {&hellip;}</a>中的emit就不能在异步的回调里面调用，这时就要用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/callback-flow.html">callbackFlow {&hellip;}</a>。callbackFlow专门适用于把现有的一些回调转为Flow，最典型的应用就是位置信息：</p>

<pre><code class="Kotlin">fun locationFlow(): Flow&lt;Location&gt; = callbackFlow {
    val listener = object : LocationListener {
        override fun onLocationUpdate(loc: Location) {
            trySend(location)
        }
    }
    locationManager.reqisterLocaitonUpdates(listener)

    awaitClose {
        locationManager.unregisterLocationUpdates(listener)
    }
}
</code></pre>

<p>如果这个Flow，用flow {}去创建会抛异常，因为emit没法在回调中使用。callbackFlow会在回调中发射数据，并在<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/await-close.html">awaitClose</a>代码块中反注册回调以清理资源。awaitClose会在这个流结束时（完成或者被取消）被回调到，以有机会进行资源清理。</p>

<p>其实，无论是flow {}还是callbackFlow {}都是<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/channel-flow.html">channelFlow {}</a>的简单化，channelFlow非常复杂，也超级强大，它可以自带buffer，自带并发，适用于创建一些非常复杂的Flow。在多数时候flow {}和callbackFlow {}就够我们用了。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://stackoverflow.com/questions/61865744/android-kotlin-coroutines-what-is-the-difference-between-flow-callbackflow-ch">Android Kotlin Coroutines: what is the difference between flow, callbackFlow, channelFlow,&hellip; other flow constructors</a></li>
<li><a href="https://www.cnblogs.com/joy99/p/15805962.html">Kotlin 协程四 —— Flow 和 Channel 的应用 </a></li>
<li><a href="https://juejin.cn/post/7220593395420627004">[译]轻松学习Kotlin的Flow、ChannelFlow和CallbackFlow</a></li>
<li><a href="https://juejin.cn/post/7202265125540659259">轻松搞定Kotlin的Flow, ChannelFlow和CallbackFlow - 2</a></li>
</ul>


<h2>副作用函数</h2>

<p>Flow是一个数据流，核心思想是把数据的生产和处理和最终消费分开，上游只负责生产数据，各种操作都应该由中游操作符来做，最终数据由终端消费掉。需要加强数据的封装性，和流的不变性，不破坏管道，用各种转换器来对数据进行操作。那么，对于流何时开始，每个数据何时产生，流什么时候终止，这些事件对于调试来说是很有帮助的。Flow的设计者给出了一系列副作用函数来做之些事情。副作用的意思就是这些函数不会对流本身产生影响。</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-start.html">onStart</a> Flow开始生产之前会调用此函数。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-each.html">onEach</a> 在生产(emit)每个数据之前调用此函数，这个函数最常用被用来打日志，以查看每个产生的数据。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-completion.html">onCompletion</a> 当Flow终止时或者被取消后会调用此函数。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-subscription.html">onSubscritpion</a> 有消费者了时调用此函数（也就是有人collect了此Flow时）。</li>
</ul>


<h2>异常，取消和错误处理</h2>

<p>这一小节重点来看看非正常代码逻辑的处理。先来看看异常处理（Exception handling）。</p>

<h3>用catch函数来处理Flow过程中的异常</h3>

<p>代码随时都可能抛出异常，所以异常处理是一个必须要考虑的事情。当然可以在Flow的各个节点如上游生产，中游变幻和下游终端的代码块里面各种try/catch。一来是不够优雅，再者这会破坏Flow的不变性或者说一致性，它就是管道，数据在里面流动，不应该加以过多的干扰，想要对数据处理应该用操作符。也就是说要让异常（包括其他错误也是如此）对Flow是透明的，意思是说Flow并不关心是否有异常。所以提供了一个<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html">catch函数</a>，它的作用是捕获并处理上游操作中发生的异常：</p>

<pre><code class="Kotlin">simple()    .catch { e -&gt; emit("Caught $e") } // emit on exception    .collect { value -&gt; println(value) }
</code></pre>

<p>需要注意catch与flowOn一样，只影响上游发生的异常，管不了下游：</p>

<pre><code class="Kotlin">flow { emitData() }    .map { computeOne(it) }    .catch { ... } // catches exceptions in emitData and computeOne    .map { computeTwo(it) }    .collect { process(it) } // throws exceptions from process and computeTwo
</code></pre>

<h3>取消Flow</h3>

<p>Flow没有显式的取消函数。Flow是冷流，有消费者时才会去生产数据，消费者停止消费了，Flow自然也就被取消了。终端操作都是suspend的，也就是要在协程中调用，因此<strong>取消终端调用的协程，就会取消Flow。</strong></p>

<h3>错误处理</h3>

<p>其实没有特别的错误处理函数，前面的异常算是一个，如果上游没有抛出异常，就不会有其他错误了，因为错误也是数据的一种类型，并且是由我们自己根据场景来定义的。比如说从网络获取新闻列表，正常时的数据当然是一个个的新闻条目。出错了，比如无网络，或者服务器无响应，这时可能返回一个空的条目，里面有错误的具体信息。但这都是由业务逻辑决定的，是业务逻辑层面的东西。对于Flow而言，都还是有数据的，都是一种数据，具体数据的解读，那是消费者终端的事情，Flow并不关心。</p>

<p>唯一算得上错误处理的函数就是<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/on-empty.html">onEmpty</a>，它会在Flow是空的时候，也就是不生产任何数据的时候被回调。可以在onEmpty里面生产emit数据，比如产生一个带有错误信息的数据，或者产生一个默认值。因为Flow为空，不产生emit任何数据时，管子是空的数据没有流动，Flow的整个链路，特别是终端collect是不会被执行的，这时可能会有问题，比如UI根本无法做出任何react，除非你设置过了默认UI状态，否则可能会不对。这个时候如果用onEmpty去产生一些默认值或者错误信息的话，就能激活整个Flow，终端能做出预期的响应。</p>

<h3>重试机制</h3>

<p>另一个非常有用的函数就是<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/retry.html">retry</a>，它可以预设一个条件，当条件满足时就会触发重新collect。Flow是冷流，有消费者collect时才会触发生产者emit数据，因此重新collect就能让Flow重新emit数据流。</p>

<h2>背压</h2>

<p>Flow是异步数据流，响应式编程范式，上游生产数据，下游终端消费数据。有时候可能会遇到这样一种情况，就是上游数据生产的速度超过了下游终端的消费速度，这会造成数据流积压在管道中，终端无法及时响应。这种情况称为『背压（Back pressure）』。想像一下一个水管，如果进水速度大于水龙头流出的速度，水就会积压在水管里，如果水管是比较薄弱的（如气球），那么它会膨胀，最后爆掉。</p>

<p>通常情况下，当上游是较为可控的生产者时，不会产生背压，但如果是一些不是开发人员可控的，如硬件（触摸事件，位置信息，传感器，摄像头），其他系统（系统框架的回调，或者服务器的Push）等等，就会产生背压，这时必须进行相应的处理。所有的FRP式异步数据流API都必须处理『背压』，Flow也有相应的API来处理：</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/buffer.html">buffer</a> 把生产者的emit的数据缓存，然后用Channel以并发的方式流向中游和下游，可以简单理解为并发地调用collect。正常情况下Flow是顺序的（Sequentially），就是数据从上游到中游再到终端，按顺序流动，先生产的数据先流到collect，这就是顺序的数据流sequentially。用上buffer后，就是会是并发的流，先emit的数据不一定先到collect，这就是concurrently。明显，能用buffer的前提是终端处理数据时没有对数据顺序的依赖。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/conflate.html">conflate</a> 也会像buffer一样启动并发式emit数据，但未能及时被终端消费掉的数据会被丢弃，终端只处理最新数据。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect-latest.html">collectLatest</a> 当有新的数据流出来时，终端只处理最新的数据，此之的终端处理会被取消掉（如果还没有处理完）。</li>
</ul>


<h2>转为热流</h2>

<p>常规的Flow都是冷的(cold flow)，但有时热流(hot flow)也有它的应用场景，Flow API中也有创建热流的方法。
<img src="https://koenig-media.raywenderlich.com/uploads/2021/05/StateFlowAndSharedFlow-twitter.png" alt="" /></p>

<h3>StateFlow</h3>

<p><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/">StateFlow</a>是一个『状态持有』流，它仅包含一个当前元素<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-state-flow/value.html">value</a>，可以用过<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/update.html">update</a>来更新此状态。它是一个热流，可以有多个终端colloctor，每次更新都会把当前的值emit给所有的终端。</p>

<p>可以用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-state-flow.html">构造方法MutableStateFlow</a>创建一个StateFlow，或者通过函数<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/state-in.html">stateIn</a>来把一个冷流转化为一个StateFlow。</p>

<p>StateFlow是比较常用的，在安卓开发中，几乎所有的ViewModel都会用StateFlow来暂存UI状态数据。</p>

<h3>SharedFlow</h3>

<p>比StateFlow更为通用的便是通用的热流<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-shared-flow/">SharedFlow</a>。可以通过构造方法<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-mutable-shared-flow.html">MutableSharedFlow</a>来创建SharedFlow，或者通过函数<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/share-in.html">sharedIn</a>把一个冷流转为SharedFlow。</p>

<p>SharedFlow可以有多个终端collector，所以可以实现一对多的通知，如实现<a href="https://en.wikipedia.org/wiki/Observer_pattern">观察者模式</a>，或者像设置/配置更新，或者广播等等就可以考虑用SharedFlow来实现。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://developer.android.com/kotlin/flow/stateflow-and-sharedflow">StateFlow and SharedFlow</a></li>
<li><a href="https://juejin.cn/post/7314159614065131554">SharedFlow vs StateFlow，一篇看懂选择和使用技巧</a></li>
<li><a href="https://juejin.cn/post/7195569817940164668">Kotlin SharedFlow&amp;StateFlow 热流到底有多热？</a></li>
<li><a href="https://juejin.cn/post/7271832299339169844">ShareFlow与StateFlow实战</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[包教包会的Kotlin Flow教程]]></title>
    <link href="http://toughcoder.net/blog/2024/01/25/kotlin-flow-made-easy/"/>
    <updated>2024-01-25T23:17:51+08:00</updated>
    <id>http://toughcoder.net/blog/2024/01/25/kotlin-flow-made-easy</id>
    <content type="html"><![CDATA[<p>Kotlin中的<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/">Flow</a>是专门用于处理异步数据流的API，是<a href="https://en.wikipedia.org/wiki/Functional_reactive_programming">函数响应式编程范式(Functional Reactive Programming FRP)</a>在Kotlin上的一个实现，并且深度融合了Kotlin的协程。是Kotlin中处理异步数据流问题的首先方案。今天就来认识一下Flow并学会如何使用它。</p>

<p><a href=""><img src="https://blog.mindorks.com/images/kotlin-flow-banner-image.png" title="auto auto" ></a></p>

<!-- more -->


<h2>Hello, Flow!</h2>

<p>老规矩，新学习一个新东西的时候，总是要从一个基础的『Hello, world』开始，快速上手体验，有个第一印象。我们就从一个简单的『Hello, Flow!』开始Flow之旅：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    val simple = flow {
        listOf("Hello", "world", "of", "flows!")
            .forEach {
                delay(100)
                emit(it)
            }
    }

    simple.collect {
        println(it)
    }
}
//Hello
//world
//of
//flows!
</code></pre>

<p>这里创建了一个异步产生String的数据流Flow&lt;String&gt;，会不定时的产生一个String，然后收集此数据流产生的数据，把流出的String对象消费掉。</p>

<p>可以看出Flow本质上是一个<strong>生产者消费者模式</strong>，流出的数据是由生产者产生的，且最终被消费者消费掉。可以把Flow想像成为一个<strong>生产线中的传送带</strong>，产品（数据）在上面不停的流动，经过各个站点的加工，最终成型，由消费者消费掉。从这个小例子中可以看出Flow API的三要素：数据流的<strong>上游</strong>是创建Flow（生产者）；<strong>中游</strong>是变幻操作（数据的处理和加工）；<strong>下游</strong>是收集数据（消费者），我们一一的详细来学习。</p>

<h2>创建Flow</h2>

<p>Flow是一个生产者，创建Flow也就是把数据放到传送带上。数据可以是基础数据或者集合，也可以是其他方式生成的数据，如网络或者回调或者硬件。创建Flow的API称作flow builder函数。</p>

<h3>用集合创建Flow</h3>

<p>这是创建Flow的最简单的方式，有两个，一个是<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow-of.html">flowOf</a>用于从固定数量的元素创建，多用于示例，实际中基本上用不到：</p>

<pre><code class="Kotlin">val simple = flowOf("Hello", "world", "of", "flows!")
simple.collect { println(it) }
</code></pre>

<p>或者，通过<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/as-flow.html">asFlow</a>把现有的集合转为Flow，这个还是比较实用的：</p>

<pre><code class="Kotlin">listOf("Hello", "world", "of", "flows!").asFlow()
    .collect { println(it) }
(1..5).asFlow().collect { println(it) }
</code></pre>

<h3>通用flow builder</h3>

<p>最为通用的flow builder就是<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flow.html">flow {&hellip;}</a>了，这是最为通用，也是最为常用的构造器。在代码块中调用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow-collector/emit.html">emit</a>就可以了，这个代码块会运行在协程之中，所以在这个代码里可以调用suspend函数：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    val simple = flow {
        for (i in 1..3) {
            delay(100)
            println("Emitting: $i")
            emit(i)
        }
    }
    simple.collect { println(it) }
}
//Emitting: 1
//1
//Emitting: 2
//2
//Emitting: 3
//3
</code></pre>

<p>这是一个代码块，只要调用了emit产生数据即可，又可调用suspend函数，因此非常的实用，比如可以执行网络请求，请求回来后emit等等。</p>

<h2>终端操作符</h2>

<p>数据从生产者流出，直到消费者把数据收集起来进行消费，而只有数据被消费了才有意义。因此，还需要终端操作（Terminal flow operators）。需要注意的是终端操作符是Flow的终点，并不算是Flow传送带内部，因此终端操作都是suspend函数，调用者需要负责创建协程以正常调用这些suspending terminal operators。</p>

<p><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.WAtR3lx1-6aO3Cnsl3s3YgHaB7?rs=1&amp;pid=ImgDetMain" alt="" /></p>

<p>常见的终端操作有三个：</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/collect.html">collect</a> 最为通用的，可执行一个代码块，参数就是Flow流出的数据</li>
<li>转换为<a href="https://kotlinlang.org/docs/collections-overview.html">集合Collections</a>，如<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/to-list.html">toList</a>和<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/to-set.html">toSet</a>等，可以方便把收集到的数据转换为集合</li>
<li>取特定的值，如<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/first.html">first()</a>只取第一个，<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/last.html">last</a>只取最后一个, <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/single.html">single</a>只要一个数据（无数据和超过一个数据时都会抛异常。</li>
<li>降维（或者叫作聚合accumulate）操作，如折叠<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/fold.html">fold</a>和化约<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/reduce.html">reduce</a>，折叠和化约可以对数据流进行降维，如求和，求积，求最大值最小值等等。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/count.html">count</a> 其实也是降维的一种，返回数据流中的数据个数，它还可以结合过滤以计算某种过滤条件后的数据数量。</li>
</ul>


<pre><code class="Kotlin">fun main() = runBlocking {
    val simple = flow {
        for (i in 1..3) {
            delay(100)
            println("Emitting: $i")
            emit(i)
        }
    }
    simple.collect { println(it) }
    println("toList: ${simple.toList()}")
    println("first: ${simple.first()}")
    println("sum by fold: ${simple.fold(0) { s, a -&gt; s + a }}")
}
</code></pre>

<p>输出：</p>

<pre><code class="Bash">Emitting: 1
1
Emitting: 2
2
Emitting: 3
3
Emitting: 1
Emitting: 2
Emitting: 3
toList: [1, 2, 3]
Emitting: 1
first: 1
Emitting: 1
Emitting: 2
Emitting: 3
sum by fold: 6
</code></pre>

<p>这些终端操作符都简单，比较好理解，看一眼示例就知道怎么用了。需要注意的就是first()和single()，first是只接收数据流中的第一个，而single则要求数据流只能有一个数据（没有或者超过一个都会抛异常）。比较有意思就是last()，数据流是一个流，一个产品传送带，通常情况下都是指无限或者说不确定数据 数量时才叫数据流，那又何来最后一个数据呢？通常情况下last都是无意义的。只有当我们知道流的生产者只生产有限数量数据时，或者采用了一些限制性的变幻操作符时，last才能派上用场。</p>

<p>再有就是注意fold和reduce的区别，这里它们的区别跟集合上的操作是一样的，fold可以提供初始值，流为空时返回初始值；而reduce没初始值，流为空时会抛异常。</p>

<h2>变幻操作符</h2>

<p>数据在流动的过程中可以对数据进行转化操作，从一种数据类型变别另外一种，这就是变幻(Transformation)，这是数据流最为灵活和强大的一个方面。这跟<a href="https://kotlinlang.org/docs/collection-transformations.html">集合的变幻</a>是类似的。</p>

<p><img src="https://cdn-media-1.freecodecamp.org/images/1*ju5YD8bRZhdCGmptRQdmlw.png" alt="" /></p>

<h3>转换</h3>

<p>最常见的变幻就是转换，也就是把从一种数据类型转换为另一种数据类型，用的最多当然是<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/map.html">map</a>，还有更为通用的<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/transform.html">transform</a>。它们都能把数据流中的数据从一种类型转换为另一种类型，比如把Flow<String>转为Flow<Int>。区别在于，map是死板的转换，一个对象进去，另一个对象作为返回值出来；但transform更为灵活，它并不是把新类型作为返回值，它可以像上游生产者那样产生(emit)新数据，甚至可以产生(emit)多个新数据，它是非常强大的，所有其他的变幻操作符，都是基于transform实现的。</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    val simple = flow {
        for (i in 1..3) {
            delay(100)
            println("Emitting: $i")
            emit(i)
        }
    }

    simple.map { " Mapping to ${it * it}" }
        .collect { println(it) }

    simple.transform { req -&gt;
        emit(" Making request $req")
        emit(performRequest(req))
    }.collect {
        println(it)
    }
}

fun performRequest(req: Int) = "Response for $req"
</code></pre>

<p>输出是:</p>

<pre><code class="Bash">Emitting: 1
 Mapping to 1
Emitting: 2
 Mapping to 4
Emitting: 3
 Mapping to 9
Emitting: 1
 Making request 1
Response for 1
Emitting: 2
 Making request 2
Response for 2
Emitting: 3
 Making request 3
Response for 3
</code></pre>

<p>还有一个操作符<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/with-index.html">withIndex</a>它与集合中的<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/map-indexed.html">mapIndexed</a>是类似的，它的作用是把元素变成IndexedValue，这样在后面就可以得到元素和元素的索引 了，在某些场景下还是比较方便的。</p>

<h3>限制</h3>

<p>数据流里面的数据不一定都是需要的，所以通常需要对数据元素进行过滤，这就是限制性操作符，最常见的就是<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/filter.html">filter</a>，这里与集合的限制操作也是类似的：</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/filter.html">filter</a> 把数据转为布尔型，从而对数据流进行过滤。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/distinct-until-changed.html">distinctUntilChanged</a> 过滤数据流中重复的元素。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/drop.html">drop</a> 丢弃前面一定数量的元素。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/take.html">take</a> 只返回流中前面一定数量的元素，当数量达到时流将被取消，注意take与drop是相反的。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/debounce.html">debounce</a> 仅保留流中一定超时间隔内的元素，比如超时时间是1秒，那只返回到达1秒时最新的元素，这个元素前面的将被丢弃。这个在秒杀场景拦截疯狂点击，或者一个服务中拦截疯狂请求时非常有用。只取一定时间间隔内的最新的元素，拦截掉无效数据。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/sample.html">sample</a> 以一定的时间间隔取元素，与debounce差不多，区别在于debounce会返回最后一个元素，而sample不一定，要看间隔最后一个元素能否落在一个时间间隔内。</li>
</ul>


<pre><code class="Kotlin">@OptIn(FlowPreview::class)
fun main() = runBlocking {
    val constraint = flow {
        emit(1)
        delay(90)
        emit(2)
        delay(90)
        emit(3)
        delay(1010)
        emit(4)
        delay(1010)
        emit(5)
    }

    constraint.filter { it % 2 == 0 }
        .collect { println("filter: $it") }
    constraint.drop(3)
        .collect { println("drop(3): $it") }
    constraint.take(3)
        .collect { println("take(3): $it") }

    constraint.debounce(1000)
        .collect { println("debounce(1000): $it") }
    constraint.sample(1000)
        .collect { println("sample(1000): $it") }
}
</code></pre>

<p>仔细看它们的输出，以理解它们的作用：</p>

<pre><code class="Bash">filter: 2
filter: 4
drop(3): 4
drop(3): 5
take(3): 1
take(3): 2
take(3): 3
debounce(1000): 3
debounce(1000): 4
debounce(1000): 5
sample(1000): 3
sample(1000): 4
</code></pre>

<p>需要留意，debounce和sample是Preview的API，需要<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-flow-preview/">加上Preview注解</a>。</p>

<p>中游的变幻操作符仍属于流的一部分，它们都仍运行在Flow的上下文中，因此，这些操作符内，与流的builder一样，都可以直接调用其他的supsend函数，甚至是其他的耗时的，阻塞的函数都可以调用。并不需要特别的为上游和中游创建上下文。</p>

<p>Flow的操作符特别多，我们需要留意区别中游操作符和下游终端。看这些函数的返回类型就可以了，返回类型是具体数据的，一定是下游终端操作符；而对于上游生产者和中游变幻操作符，其返回值一定是一个Flow。</p>

<h2>高级操作符</h2>

<p>前面讲的操作符都是针对 某一个流本身的，但大多数场景一个流明显不够用啊，我们需要操作多个流，这时就需要用到一些高级操作符了。</p>

<h3>合并多路流</h3>

<p>多路流不可能一个一个的处理，合并成为一路流更加的方便，有以下合并方法：</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/merge.html">归并merge</a>把<strong>数据类型相同的多路流归并为一路</strong>，注意一定是数据类型相同的才可以归并，并且归并后的元素顺序是未知的，也即不会保留原各路流的元素顺序。归并流的数量没有限制。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/zip.html">粘合zip</a> 当想要<strong>把两路流的元素对齐后粘合为一个元素</strong>时，就可以使用<a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/zip.html">zip</a>，当任何一个流结束或者被取消时，zip也就结束了。只能两个两个的粘合。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/combine.html">组合combine</a>把多路流中的每个流的最新元素粘合成新数据，形成一个新的流，其元素是把<strong>每个元素</strong>都用<strong>每路流的最新元素</strong>来转换生成。最少需要2路流，最多支持5路流。</li>
</ul>


<p>用一个&#127792;来感受一下它们的作用：</p>

<pre><code class="Kotlin">fun main() = runBlocking {
    val one = flowOf(1, 2, 3)
                .map(Int::toString)
                .onEach { delay(10) }
    val two = flowOf("a", "b", "c", "d")
                .onEach { delay(25) }
    merge(one, two)
        .collect { println("Merge: $it") }
    one.zip(two) { i, s -&gt; "Zip: $i. $s" }
        .collect { println(it) }
    combine(one, two) { i, s -&gt; "Combine $i with $s" }
        .collect { println(it) }
}
</code></pre>

<p>这里是输出：</p>

<pre><code class="Bash">Merge: 1
Merge: 2
Merge: a
Merge: 3
Merge: b
Merge: c
Merge: d
Zip: 1. a
Zip: 2. b
Zip: 3. c
Combine 2 with a
Combine 3 with a
Combine 3 with b
Combine 3 with c
Combine 3 with d
</code></pre>

<p>通过它们的输出可以看到它们的区别：merge就像把两个水管接到一样，简单没有多余加工，适合数据类型一样的流（比如都是水）；zip会对齐两路流，让能对齐的元素两两结合，对不齐时就结束了。</p>

<p>而combine要等到<strong>集齐每路流的最新元素，才能转换成新数据</strong>，two是较one慢的，看到two的元素『a』时，one最新的元素是『2』，之后one的『3』来了，这时two最新的元素还是『a』，之后one停在了『3』，后续two的元素都与『3』组合。有同学可能会有疑问，为啥one的『1』丢弃了，没找到组合呢？因为它来的太早了，one的『1』来了时，two还没有元素，它肯定会等，但当two的第一个元素『a』来了时，这时one的最新元素已是『2』了，one是10发一个元素，two是隔25发一个元素，所以two的第1个元素到了时，one的第2个元素已经来了，它是最新的，所以组合时会用它。combine要集齐每路流的最新元素才能合成。</p>

<p>总结起来就是，<strong>zip会按顺序对齐元素</strong>；而combine要<strong>集齐每路流的最新元素</strong>，先要<strong>集齐</strong>，齐了时还要<strong>取每个流的最新元素</strong>。可以动手运行示例，修改delay的时间，看输出有啥不一样的，以加深理解。</p>

<h3>展平(Flatten)</h3>

<p>一个Flow就是一个异步数据流，它相当于一个传送带或者管道，货物（具体的数据）在其上面或者里面流动。正常情况下Flow内部都是常规数据（对象）在流动，但Flow本身也是一个对象，因此也可以嵌套，把流当成另一个流的数据，比如Flow&lt;Flow&lt;Int&gt;&gt;，这就是Flow of Flows of Int。Flow是数据流，最终消费者需要的是具体的数据，所以对于嵌套的Flow of Flows，通常都需要在传给终端操作符之前进行展平(flatten)，得到一个faltterned Flow（即从Flow&lt;Flow&lt;Int&gt;&gt;转成Flow&lt;Int&gt;），就可以被终端消费了。操作符中以flat开头的函数都是用于展平的，主要是两类，一类是<strong>展平flatten系</strong>，一类是<strong>先变幻再展平flatMap系</strong>。</p>

<h4>直接展平</h4>

<p>最直观的展平莫过于对于已经是嵌套的Flow of Flows做展平处理，以能让终端操作符正常的消费Flow里面的数据，有两个API可以做展平：</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flatten-concat.html">flattenConcat</a> 把嵌套的Flow of Flows展平为一个Flow，内层的每个流都是按顺序拼接在一起的，串行拼接。比如Flow of 4 Flows，内层有四个管道，那就就变成了『内层1』->『内层2』->『内层3』->『内层4』。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flatten-merge.html">flattenMerge</a> 把Flow of Flows展平为一个Flow，内层的所有Flow是以并发的方式将元素混合流入新管道，是并发式混合，相当于四个管道同时往另一个管道倒水，原流中的顺序会错乱掉。</li>
</ul>


<pre><code class="Kotlin">@OptIn(ExperimentalCoroutinesApi::class)
fun main() = runBlocking {
    val flow2D = flowOf("Hello", "world", "of", "flow!")
        .map { it.toCharArray().map { c -&gt; " '$c' " }.asFlow() }
        .flowOn(Dispatchers.Default)

    flow2D.collect { println("Flow object before flatten: $it") } // Data in flow are Flow objects

    println("With flattenConcat:")
    flow2D.flattenConcat()
        .collect { print(it) }

    println("\nWith flattenMerge:")
    flow2D.flattenMerge()
        .collect { print(it) }
}
//Flow object before flatten: kotlinx.coroutines.flow.FlowKt__BuildersKt$asFlow$$inlined$unsafeFlow$3@1b0375b3
//Flow object before flatten: kotlinx.coroutines.flow.FlowKt__BuildersKt$asFlow$$inlined$unsafeFlow$3@e580929
//Flow object before flatten: kotlinx.coroutines.flow.FlowKt__BuildersKt$asFlow$$inlined$unsafeFlow$3@1cd072a9
//Flow object before flatten: kotlinx.coroutines.flow.FlowKt__BuildersKt$asFlow$$inlined$unsafeFlow$3@7c75222b
//With flattenConcat:
 //'H'  'e'  'l'  'l'  'o'  'w'  'o'  'r'  'l'  'd'  'o'  'f'  'f'  'l'  'o'  'w'  '!' 
//With flattenMerge:
// 'H'  'e'  'l'  'l'  'o'  'w'  'o'  'r'  'l'  'd'  'o'  'f'  'f'  'l'  'o'  'w'  '!'
</code></pre>

<p>从输出中可以看出，如果不展平Flow里面是Flow对象，没法用。flattenConcat是把内层的流串行的接在一起。但flattenMerge的输出似乎与文档描述不太一致，并没有并发式的混合。</p>

<h4>先转换再展平</h4>

<p><img src="https://velog.velcdn.com/images/morning-la/post/59271fa7-8768-43f7-bebf-1387e77d8013/image.png" alt="" /></p>

<p>大多数时候并没有现成的嵌套好的Flow of Flows给你展平，更多的时候是我们需要自己把元素转换为一个Flow，先生成Flow of Flows，然后再展平，且有定义好的API可以直接用：</p>

<ul>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-concat.html">flatMapConcat</a> 先把Flow中的数据做变幻，这个变幻必须从元素变成另一个Flow，这时就变成了嵌套式的Flow of Flows，然后再串行式展平为一个Flow。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-latest.html">flatMapLatest</a> 先把Flow中的最新数据做变幻，这个变幻必须从元素变成另一个Flow，这时会取消掉之前转换生成的内层流，结果虽然也是嵌套，但内层流只有一个，就是原Flow中最新元素转换生成的那个流。然后再展平，这个其实也不需要真展平，因为内层流只有一个，它里面的数据就是最终展平后的数据。</li>
<li><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/flat-map-merge.html">flatMapMerge</a> 与flatMapConcat一样，只不过展平的时候嵌套的内层流是以并发的形式来拼接的。</li>
</ul>


<p>来看个&#127792;就能明白它们的作用了：</p>

<pre><code class="Kotlin">@OptIn(ExperimentalCoroutinesApi::class)
fun main() = runBlocking {
    val source = (1..3).asFlow()
        .onEach { delay(100) }

    println("With flatMapConcat:")
    var start = System.currentTimeMillis()
    source.flatMapConcat(::requestFlow)
        .collect { println("$it at ${System.currentTimeMillis() - start}ms from the start") }

    println("With flatMapMerge:")
    start = System.currentTimeMillis()
    source.flatMapMerge(4, ::requestFlow)
        .collect { println("$it at ${System.currentTimeMillis() - start}ms from the start") }

    println("With flatMapLatest:")
    source.flatMapLatest(::requestFlow)
        .collect { println("$it at ${System.currentTimeMillis() - start}ms from the start") }
}

fun requestFlow(x: Int): Flow&lt;String&gt; = flow {
    emit(" &gt;&gt;[$x]: First: $x")
    delay(150)
    emit(" &gt;&gt;[$x]: Second: ${x * x}")
    delay(200)
    emit(" &gt;&gt;[$x]: Third: ${x * x * x}")
}
</code></pre>

<p>输出比较多：</p>

<pre><code class="Bash">With flatMapConcat:
 &gt;&gt;[1]: First: 1 at 140ms from the start
 &gt;&gt;[1]: Second: 1 at 306ms from the start
 &gt;&gt;[1]: Third: 1 at 508ms from the start
 &gt;&gt;[2]: First: 2 at 613ms from the start
 &gt;&gt;[2]: Second: 4 at 765ms from the start
 &gt;&gt;[2]: Third: 8 at 969ms from the start
 &gt;&gt;[3]: First: 3 at 1074ms from the start
 &gt;&gt;[3]: Second: 9 at 1230ms from the start
 &gt;&gt;[3]: Third: 27 at 1432ms from the start
With flatMapMerge:
 &gt;&gt;[1]: First: 1 at 130ms from the start
 &gt;&gt;[2]: First: 2 at 235ms from the start
 &gt;&gt;[1]: Second: 1 at 284ms from the start
 &gt;&gt;[3]: First: 3 at 341ms from the start
 &gt;&gt;[2]: Second: 4 at 386ms from the start
 &gt;&gt;[1]: Third: 1 at 486ms from the start
 &gt;&gt;[3]: Second: 9 at 492ms from the start
 &gt;&gt;[2]: Third: 8 at 591ms from the start
 &gt;&gt;[3]: Third: 27 at 695ms from the start
With flatMapLatest:
 &gt;&gt;[1]: First: 1 at 807ms from the start
 &gt;&gt;[2]: First: 2 at 915ms from the start
 &gt;&gt;[3]: First: 3 at 1021ms from the start
 &gt;&gt;[3]: Second: 9 at 1173ms from the start
 &gt;&gt;[3]: Third: 27 at 1378ms from the start
</code></pre>

<p><img src="https://velog.velcdn.com/images/morning-la/post/5d218551-4021-4a91-8b85-bf69beb786d6/image.png" alt="" /></p>

<p>这个示例中原始Flow是一个Int值，把它转换成为一个字符串流Flow&lt;String&gt;。从输出中可以看到flatMapConcat确实是串行拼接，并且flatMapMerge是并发式的混合，不保证内部Flow的元素顺序。仔细看flatMapLatest的输出，每当原始Flow中有新的值生成时，之前转换生成的流会被取消，它们并没有运行完（仅第一个元素流出了）。而原始流的最后一个元素『3』则完整的从展平流中流出了。</p>

<p>展平的函数比较多容易学杂，其实有一个非常简单的区分方法：带有<strong>Map字样</strong>的函数就是先把元素<strong>转换成Flow</strong>之后再展平；带有<strong>Concat</strong>就是把嵌套内层流<strong>串行拼接</strong>；而带有<strong>Merge</strong>的则是把内层流<strong>并发式的混合</strong>。使用的时候，如果<strong>想保证顺序就用带有Concat的函数；想要并发性，想高效一些，并且不在乎元素顺序，那就用带有Merge的函数。</strong></p>

<h2>Flow是冷流</h2>

<p>对于数据流来说有<strong>冷热</strong>之分，冷流(Cold stream)是指消费者开始接收数据时，才开始生产数据，换句话说就是生产者消费者整个链路搭建好了后，上游才开始生产数据；热流(Hot stream)，与之相反，不管有没有人在消费，都在生产数据。有一个非常形象的比喻就是，冷流就好比CD，你啥时候都可以听，而且只要你播放就从头开始播放CD上所有的音乐；而热流就好比电台广播，不管你听不听，它总是按它的节奏在广播，今天不听，就错过今天的数据了，今天听跟明天听，听到的内容也是不一样的。</p>

<p>Kotlin的<strong>Flow是冷流</strong>，其实从上面的例子也能看出来，每个例子中都是只创建一个Flow对象，然后有多次collect，但<strong>每次collect都能拿到Flow中完整的数据</strong>，这就是<strong>典型的冷流</strong>。绝大多数场景，我们需要的也都是冷流。</p>

<p>扩展阅读<a href="https://kt.academy/article/cc-hot-cold">Hot and cold data sources</a>。</p>

<h2>与ReactiveX的区别</h2>

<p>Flow是用于处理异步数据流的API，是函数响应式编程范式FRP的一个实现。但它并不是唯一的，更为<a href="https://github.com/ReactiveX/RxJava">流行的RxJava</a>也是符合FRP的异步数据流处理API，它出现的要更早，社区更活跃，资源更丰富，流行程度更高，基本上是每个安卓项目必备的依赖库，同时也是面试必考题。</p>

<p>因为Kotlin是基于JVM的衍生语言，它与Java是互通的，可以混着用。所以RxJava可以直接在Kotlin中使用，无需要任何改动。但毕竟RxJava是原生的Java库，Kotlin中的大量语法糖还是很香的，由此便有了<a href="https://github.com/ReactiveX/RxKotlin">RxKotlin</a>。RxKotlin并不是把<a href="https://reactivex.io/">ReactiveX规范</a>重新实现一遍，它只是一个轻量的粘合库，通过扩展函数和Kotlin的语法糖等，让RxJava更加的Kotlin友好，在Kotlin中使用RxJava时更加的顺滑。但核心仍是RxJava，如并发的实现仍是用线程。</p>

<p>那么Flow相较RxJava有啥区别呢？区别就在于Flow是纯的Kotlin的东西，它们背后的思想是一样的都是异步数据流，都是FRP，但Flow是原生的，它与Kotlin的特性紧密结合，比如它的并发是用协程通信用的是Channel。使用建议就是，如果本身对RxJava很熟悉，且是遗留代码，那就没有必要去再改成Flow；但如果是新开发的纯新功能，并且不与遗留代码交互，也没有与架构冲突，还是建议直接上Flow。</p>

<h2>什么时候用Flow</h2>

<p>每一个工具都有它特定的应用场景，Flow虽好，但不可滥用，要以架构的角度来认清问题的本质，符合才可以用。Flow是用于处理异步数据流的API，是FRP范式下的利器。因此，只当核心业务逻辑是由异步数据流驱动的场景时，用Flow才是合适的。现在绝大多数端（前端，客户端和桌面）GUI应用都是响应式的，用户输入了，或者服务器Push了数据，应用做出响应，所以都是符合FRP范式的。那么重点就在于数据流了，如果数据连串成流，就可以用Flow。比如用户输出，点击事件/文字输入等，这并不只发生一次，所以是数据流（事件流）。核心的业务数据，比如新闻列表，商品列表，文章列表，评论列表等都是流，都可以用Flow。配置，设置和数据库的变化也都是流。</p>

<p>但，一个单篇的文章展示，一个商品展示这就不是流，只有一个文章，即使用流，它也只有一个数据，而且我们知道它只有一个数据。这种情况就没有必要用Flow，直接用一个supsend请求就好了。</p>

<h2>在Android中使用Flow</h2>

<p><img src="https://koenig-media.raywenderlich.com/uploads/2020/05/KotlinFlow-twitter.png" alt="" /></p>

<p>安卓开发的官方语言已经变成了Kotlin了，安卓应用也非常符合FRP范式，那么对于涉及异步数据流的场景自然要使用Flow。</p>

<p>扩展阅读：</p>

<ul>
<li><a href="https://blog.mindorks.com/what-is-flow-in-kotlin-and-how-to-use-it-in-android-project/">What is Flow in Kotlin and how to use it in Android Project?</a></li>
<li><a href="https://developer.android.com/kotlin/flow">Kotlin flows on Android</a></li>
<li><a href="https://github.com/amitshekhariitbhu/Learn-Kotlin-Flow">Learn Kotlin Flow by real examples for Android</a></li>
</ul>


<h2>书籍推荐</h2>

<p>Flow本身的东西其实并不多，就是三板斧：创建，变幻和终端。但Flow背后的思想是很庞大的，想要用好Flow必须要学会函数响应式编程范式。也就是说只有学会以FRP范式来构建软件时，才能真正用好Flow。</p>

<p><a href="https://www.manning.com/books/functional-reactive-programming">《Functional Reactive Programming》</a></p>

<h2>参考资料</h2>

<ul>
<li><a href="https://kotlinlang.org/docs/flow.html">Asynchronous Flow</a></li>
<li><a href="https://amitshekhar.me/blog/flow-api-in-kotlin">Mastering Flow API in Kotlin</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
